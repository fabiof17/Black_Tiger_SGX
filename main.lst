                             #[1]   "main.s"
   27                        	
   28               0010     	CORE_VERSION	=	$10			; Version 1.0
   29                        	
   30                        			; Get the user program's configuration settings, this will
   31                        			; be read from the current directory, if it exists, or the
   32                        			; "../include/" directory if not.
   33                        	
                             #[4]   "..\..\..\include\hucc\core-config.inc"
   34                        			include	"core-config.inc"
    1                        	; ***************************************************************************
    2                        	; ***************************************************************************
    3                        	;
    4                        	; core-config.inc
    5                        	;
    6                        	; Configuration settings for the "CORE(not TM)" PC Engine library code.
    7                        	;
    8                        	; Copyright John Brandwood 2021-2024.
    9                        	;
   10                        	; Distributed under the Boost Software License, Version 1.0.
   11                        	; (See accompanying file LICENSE_1_0.txt or copy at
   12                        	;  http://www.boost.org/LICENSE_1_0.txt)
   13                        	;
   14                        	; ***************************************************************************
   15                        	; ***************************************************************************
   16                        	;
   17                        	; The idea is that you, a PCE developer, copy this file from the ../include/
   18                        	; directory and into your project's directory, and then customize the values
   19                        	; to suit your particular project.
   20                        	;
   21                        	; Because PCEAS searches the current (i.e. project) directory for an include
   22                        	; file first, then it will find your customized copy of the file rather than
   23                        	; the original copy in the ../include/ directory.
   24                        	;
   25                        	; That means that all of the different overlay programs in your project will
   26                        	; share the same overall library configuration for your game.
   27                        	;
   28                        	; ***************************************************************************
   29                        	; ***************************************************************************
   30                        	
   31                        	;
   32                        	; Are we going to take over MPR7?
   33                        	;
   34                        	; While this is the default for the "CORE(not TM)" library, it is definitely
   35                        	; possible to use the library to build CD-ROM code that runs with the System
   36                        	; Card in MPR7, and with the 1st bank remaining in MPR2.
   37                        	;
   38                        	; N.B. The CD-ROM Stage1 loader runs the library with USING_MPR7=0 while it
   39                        	;      installs the kernel into PCE RAM in MPR1.
   40                        	;
   41                        	
   42               0000     		.ifndef	USING_MPR7
   44                        		.endif
   45                        	
   46                        	;
   47                        	; Are we building a CD-ROM overlay that uses an already-built CD-ROM Stage1
   48                        	; loader to install the library's kernel code into PCE RAM in MPR1?
   49                        	;
   50                        	; If this is set, the library's kernel code will be excluded from the build,
   51                        	; which will save about 1KB-3KB of code space in every overlay program!
   52                        	;
   53                        	; N.B. The CD-ROM Stage1 loader sets USING_STAGE1=0 so it builds correctly.
   54                        	;
   55                        	
   56               0000     		.ifndef	USING_STAGE1
   58                        		.endif
   59                        	
   60                        	;
   61                        	; Are we currently building the CD-ROM Stage1 loader?
   62                        	;
   63                        	; If this is set, the library's startup code does not call the __sound_init
   64                        	; macro because the sound driver code is not usually a part of the kernel.
   65                        	;
   66                        	; N.B. The CD-ROM Stage1 loader sets BUILDING_STAGE1=1 so it builds correctly.
   67                        	;
   68                        	
   69               0000     		.ifndef	BUILDING_STAGE1
   71                        		.endif
   72                        	
   73                        	;
   74                        	; Is the last track of the CD a duplicate of the main ISO data track?
   75                        	;
   76                        	; Most CD games put two copies of the same ISO track on the CD, so that data
   77                        	; can be read from the secondary track if the drive has a problem reading it
   78                        	; it from the primary location.
   79                        	;
   80                        	; If set, the secondary track will be enabled when the library first starts.
   81                        	;
   82                        	
   83               0000     		.ifndef	SUPPORT_2ISO
   85                        		.endif
   86                        	
   87                        	;
   88                        	; Maximum number of directory entries to use from the ISO.
   89                        	;
   90                        	; The fewer that we choose, the less RAM memory we need. A setting of 64 is
   91                        	; a good compromise to use until you are putting lots of files on the ISO.
   92                        	;
   93                        	
   94               0000     		.ifndef	MAX_DIRSIZE
   96                        		.endif
   97                        	
   98                        	;
   99                        	; Use the System Card's PSG driver code instead of a modern alternative
  100                        	; sound driver like a DefleMask or Furnace player?
  101                        	;
  102                        	
  103               0000     		.ifndef	USING_PSGDRIVER
  105                        		.endif
  106                        	
  107                        	;
  108                        	; Support development for the Turbo EverDrive v2?
  109                        	;
  110                        	; This only applies to HuCard programs, but when chosen, the "CORE(not TM)"
  111                        	; kernel is moved from bank 0 to bank 2, and a minimal set of startup code
  112                        	; is put in bank 0.
  113                        	;
  114                        	; This is because the TED2 hardware occupies the whole of bank 0 when it is
  115                        	; activated, and so we need to run with a different bank in MPR7.
  116                        	;
  117                        	
  118               0000     		.ifndef	SUPPORT_TED2
  120                        		.endif
  121                        	
  122                        	;
  123                        	; Support development for the SuperGRAFX?
  124                        	;
  125                        	; This enables SuperGRAFX support in certain library functions.
  126                        	;
  127                        	
  128               0000     		.ifndef	SUPPORT_SGX
  130                        		.endif
  131                        	
  132                        	;
  133                        	; Choose SuperGRAFX VPC initialization mode.
  134                        	;
  135                        	; SGX_PARALLAX=0 (useful when VDC #1 is a fullscreen HUD)
  136                        	;
  137                        	;  FRONT
  138                        	;   SP1 = VDC #1 (pce) sprite pixels
  139                        	;   BG1 = VDC #1 (pce) background pixels
  140                        	;   SP2 = VDC #2 (sgx) sprite pixels
  141                        	;   BG2 = VDC #2 (sgx) background pixels
  142                        	;  BACK
  143                        	;
  144                        	; SGX_PARALLAX=1
  145                        	;
  146                        	;  FRONT
  147                        	;   SP1 = VDC #1 (pce) sprite pixels
  148                        	;   SP2 = VDC #2 (sgx) sprite pixels
  149                        	;   BG1 = VDC #1 (pce) background pixels
  150                        	;   BG2 = VDC #2 (sgx) background pixels
  151                        	;  BACK
  152                        	;
  153                        	
  154               0000     		.ifndef	SGX_PARALLAX
  156                        		.endif
  157                        	
  158                        	;
  159                        	; Support development for the ArcadeCard?
  160                        	;
  161                        	; This enables ArcadeCard support in certain library functions.
  162                        	;
  163                        	
  164               0000     		.ifndef	SUPPORT_ACD
  166                        		.endif
  167                        	
  168                        	;
  169                        	; Support development for the IFU's ADPCM hardware?
  170                        	;
  171                        	; Developers would normally just use the System Card functions for ADPCM, but
  172                        	; enabling this adds alternative functions, and allows ADPCM use on a HuCARD.
  173                        	;
  174                        	
  175               0000     		.ifndef	SUPPORT_ADPCM
  177                        		.endif
  178                        	
  179                        	;
  180                        	; Select which version of the joystick library code to include, only one of
  181                        	; these can be set to '1' ...
  182                        	;
  183                        	; SUPPORT_2BUTTON : Only returns buttons I and II.
  184                        	; SUPPORT_6BUTTON : Read buttons III-VI, but ignore a mouse.
  185                        	; SUPPORT_MOUSE	  : Read mouse, but ignore buttons III-VI.
  186                        	;
  187                        	; It doesn't make sense to design a game the relies on both the 6-button and
  188                        	; the mouse, so the joystick library is optimized for one or the other.
  189                        	;
  190                        	; Note that both those devices are always detected and no conflicts occur,
  191                        	; this just controls reading either buttons III-VI or the Mouse Y-movement.
  192                        	;
  193                        	
  194               0000     		.ifndef	SUPPORT_6BUTTON
  200                        		.endif
  201                        	
  202                        	;
  203                        	; How many joypad/mouse devices should be supported?
  204                        	;
  205                        	; This is normally 5, but can be set to 3 (or lower) in order to speed up
  206                        	; the processing and free up CPU time for other code, which is especially
  207                        	; useful for mouse games.
  208                        	;
  209                        	
  210               0000     		.ifndef	MAX_PADS
  212                        		.endif
  213                        	
  214                        	;
  215                        	; Implement a HuC-compatible seperate array for accumulating joypad presses?
  216                        	;
  217                        	; This is only really needed if your game is not expected to run at 60Hz and
  218                        	; so you will sometimes miss joypad presses.
  219                        	;
  220                        	; Alternatively you can set ACCUMULATE_JOY so that joypad presses are always
  221                        	; accumulated in the normal joytrg array, which is how asm programmers would
  222                        	; normally deal with this situation.
  223                        	;
  224                        	
  225               0000     		.ifndef HUC_JOY_EVENTS
  227                        		.endif
  228                        	
  229                        	;
  230                        	; Should "joytrg" accumulate presses, and so need to be explicitely cleared
  231                        	; after reading, or should it just be the result of the last read?
  232                        	;
  233                        	; This option has no effect if HUC_JOY_EVENTS is non-zero since that option
  234                        	; takes precedence over this one!
  235                        	;
  236                        	
  237               0000     		.ifndef ACCUMULATE_JOY
  239                        		.endif
  240                        	
  241                        	;
  242                        	; The DATA_BANK location needs to be set as early as possible so that library
  243                        	; code is able to put data in there before the total overall size of the code
  244                        	; is known.
  245                        	;
  246                        	; By default, DATA_BANK is the next bank after the CORE_BANK.
  247                        	;
  248                        	; RESERVE_BANKS allows developers to reserve some banks between the CORE_BANK
  249                        	; and the DATA_BANK that they can use however they wish.
  250                        	;
  251                        	; One use for RESERVE_BANKS is to create empty space that PCEAS can use when
  252                        	; it relocates procedures. This provides a way for a developer to group code
  253                        	; together at the start of memory, and leave the maximum number of banks for
  254                        	; loading dynamic data from CD-ROM.
  255                        	;
  256                        	; The KickC environment sets RESERVE_BANKS=1 (or higher) so that there is a
  257                        	; a bank for the permanent C code and static constants.
  258                        	;
  259                        	
  260               0000     		.ifndef	RESERVE_BANKS
  266                        		.endif	RESERVE_BANKS
                             #[3]   "..\..\..\include\hucc\core.inc"
   35                        	
   36                        	;
   37                        	; This is a simple macro to call System Card functions when using MPR7 for
   38                        	; running the "CORE(not TM)" PC Engine library code.
   39                        	;
   40                        	
   41                        	system		.macro
   42                        			ldy     #<\1
   43                        			jsr	call_bios
   44                        			.endm
   45                        	
   46                        	;
   47                        	; This replaces the System Card's ex_setvec, because "call_bios" uses the
   48                        	; Y register.
   49                        	;
   50                        	
   51                        	setvec		.macro
   52                        			php
   53                        			sei
   54                        			lda.l	#\2
   55                        			sta.l	\1
   56                        			lda.h	#\2
   57                        			sta.h	\1
   58                        			plp
   59                        			.endm
   60                        	
   61                        	;
   62                        	; Repurpose this System Card variable, since nmi_hook is never used.
   63                        	;
   64                        	; We'll use it as a vector to a user-supplied sound driver instead.
   65                        	;
   66                        	
   67               2206     	sound_hook	=	nmi_hook		; Sound Driver to run in VBL.
   68                        	
   69                        	;
   70                        	; CORE Zero-Page variables, relative to the System Card's ZP variables.
   71                        	;
   72                        	
   73               0000     		.if	USING_PSGDRIVER
   75                        		.else
   76               20EC     	core_zpend	=	$F8:20EC
   77                        		.endif	USING_PSGDRIVER
   78                        	
   79               0001     		.if	SUPPORT_SGX
   80                        	
   81                        			; Put some "CORE(not TM)" variables at the start of Zero Page.
   82                        			;
   83                        			; These are at the *start* of ZP so that the SuperGrafx shadow
   84                        			; "sgx_" registers are at a specific offset from their System
   85                        			; Card "vdc_" counterparts, and they MUST NOT be moved!
   86                        			;
   87                        			; This allows us to put SGX_VDC_OFFSET or PCE_VDC_OFFSET into
   88                        			; the X register, and then index into either set of hardware
   89                        			; registers and the "sgx_reg" or "vdc_reg" shadow-variables.
   90                        	
   91               0000     	PCE_VDC_OFFSET	=	$00		; Offset to PCE VDC chip & shadow vars.
   92               0010     	SGX_VDC_OFFSET	=	$10		; Offset to SGX VDC chip & shadow vars.
   93                        	
   94               2000     			.zp
   95               2000     			.org	$2000
   96    F8:2000             	__temp		ds	2		; $F8:2000 Use within any ASM routine.
   97    F8:2002             	_bp_bank	ds	1		; $F8:2002 Use within any ASM/HuCC routine.
   98    F8:2003             	sgx_crl		ds	1		; $F8:2003 SGX shadow (vdc_crl = $20F3).
   99    F8:2004             	sgx_crh		ds	1		; $F8:2004 SGX shadow (vdc_crh = $20F4).
  100    F8:2005             	core_1stbank	ds	1		; $F8:2005 1st bank of library code.
  101    F8:2006             	sgx_sr		ds	1		; $F8:2006 SGX shadow (vdc_sr  = $20F6).
  102    F8:2007             	sgx_reg		ds	1		; $F8:2007 SGX shadow (vdc_reg = $20F7).
  103                        	
  104               2008     	core_zp1st	=	*		; $F8:2008 1st free user address.
  105                        	
  106                        		.else	SUPPORT_SGX
  116                        		.endif	SUPPORT_SGX
  117                        	
  118                        	;
  119                        	; The kernel code in RAM follows the System Card's RAM variables.
  120                        	;
  121                        	
  122               0000     		.if	USING_PSGDRIVER
  124                        		.else
  125               22D0     	core_ram1st     =	$F8:22D0
  126                        		.endif	USING_PSGDRIVER
  127                        	
  128                        	;
  129                        	; Include the "CORE(not TM)" startup code to begin the HuCARD / Overlay.
  130                        	;
  131                        	
                             #[4]   "..\..\..\include\hucc\core-startup.asm"
  132                        			include	"core-startup.asm"
    1                        	; ***************************************************************************
    2                        	; ***************************************************************************
    3                        	;
    4                        	; core-startup.asm
    5                        	;
    6                        	; The "CORE(not TM)" PC Engine library startup code that runs at boot/reset.
    7                        	;
    8                        	; Copyright John Brandwood 2021-2024.
    9                        	;
   10                        	; Distributed under the Boost Software License, Version 1.0.
   11                        	; (See accompanying file LICENSE_1_0.txt or copy at
   12                        	;  http://www.boost.org/LICENSE_1_0.txt)
   13                        	;
   14                        	; ***************************************************************************
   15                        	; ***************************************************************************
   16                        	;
   17                        	; This is the initialization code in the 1st bank, and it is responsible for
   18                        	; setting up a consistant runtime environment for the developer's program,
   19                        	; so that the developer can concentrate on writing the program itself.
   20                        	;
   21                        	; The idea is that when a program is loaded, the first 40KB of it is mapped
   22                        	; as $4000..$DFFF, and initialization starts at $4000, with the developer's
   23                        	; program getting control after initialization, with a jump to "core_main".
   24                        	;
   25                        	; The initializtion sets up a small kernel of code that provides interrupt
   26                        	; handling that mimics a subset of the System Card's behavior, designed to
   27                        	; act in the same way on HuCARD and CD-ROM, with either the System Card in
   28                        	; MPR7, or with an overlay in MPR7.
   29                        	;
   30                        	; The kernel handles reading the joypad/mouse, and it offers handler hooks
   31                        	; for running the developer's interrupt code.  On CD-ROM systems, it also
   32                        	; handles the loading and running of subsequent overlay programs.
   33                        	;
   34                        	; On HuCARD, the kernel itself runs in MPR7; while on CD-ROM systems it is
   35                        	; run from RAM in MPR1, so that overlay programs are independant from each
   36                        	; other, and can be written in different programming languages.
   37                        	;
   38                        	;
   39                        	; 1) If we're running on a HuCARD, the initialization is simple!
   40                        	;
   41                        	;    The PC Engine's memory map is set to ...
   42                        	;
   43                        	;      MPR0 = bank $FF : PCE hardware
   44                        	;      MPR1 = bank $F8 : PCE RAM with Stack & ZP
   45                        	;      MPR2 = bank $00 : HuCARD ROM
   46                        	;      MPR3 = bank $01 : HuCARD ROM
   47                        	;      MPR4 = bank $02 : HuCARD ROM
   48                        	;      MPR5 = bank $03 : HuCARD ROM
   49                        	;      MPR6 = bank $04 : HuCARD ROM
   50                        	;      MPR7 = bank $00 : HuCARD ROM
   51                        	;
   52                        	;
   53                        	; 2) If we're running on a HuCARD that supports the Turbo Everdrive, then the
   54                        	;    first 2 banks are reserved for mapping the TED2 hardware and a RAM bank.
   55                        	;
   56                        	;    The PC Engine's memory map is set to ...
   57                        	;
   58                        	;      MPR0 = bank $FF : PCE hardware
   59                        	;      MPR1 = bank $F8 : PCE RAM with Stack & ZP
   60                        	;      MPR2 = bank $02 : HuCARD ROM
   61                        	;      MPR3 = bank $03 : HuCARD ROM
   62                        	;      MPR4 = bank $04 : HuCARD ROM
   63                        	;      MPR5 = bank $05 : HuCARD ROM
   64                        	;      MPR6 = bank $06 : HuCARD ROM
   65                        	;      MPR7 = bank $02 : HuCARD ROM
   66                        	;
   67                        	;
   68                        	; 3) If we're running on an old CD System, the overlay is loaded from the ISO
   69                        	;    into banks $80-$87 (64KB max).
   70                        	;
   71                        	;    The PC Engine's memory map is set to ...
   72                        	;
   73                        	;      MPR0 = bank $FF : PCE hardware
   74                        	;      MPR1 = bank $F8 : PCE RAM with Stack & ZP
   75                        	;      MPR2 = bank $80 : CD RAM
   76                        	;      MPR3 = bank $81 : CD RAM
   77                        	;      MPR4 = bank $82 : CD RAM
   78                        	;      MPR5 = bank $83 : CD RAM
   79                        	;      MPR6 = bank $84 : CD RAM
   80                        	;      MPR7 = bank $80 : CD RAM or System Card's bank $00
   81                        	;
   82                        	;
   83                        	; 4) If we're running on a SuperCD System, the overlay is loaded from the ISO
   84                        	;    into banks $68-$87 (256KB max).
   85                        	;
   86                        	;    The PC Engine's memory map is set to ...
   87                        	;
   88                        	;      MPR0 = bank $FF : PCE hardware
   89                        	;      MPR1 = bank $F8 : PCE RAM with Stack & ZP
   90                        	;      MPR2 = bank $68 : SCD RAM
   91                        	;      MPR3 = bank $69 : SCD RAM
   92                        	;      MPR4 = bank $6A : SCD RAM
   93                        	;      MPR5 = bank $6B : SCD RAM
   94                        	;      MPR6 = bank $6C : SCD RAM
   95                        	;      MPR7 = bank $68 : SCD RAM or System Card's bank $00
   96                        	;
   97                        	; ***************************************************************************
   98                        	; ***************************************************************************
   99                        	
  100                        	
  101                        	
  102               E000     			.code
  103               0000     			.bank	0
  104                        	
  105               0000     		.if	SUPPORT_TED2			; Do we want to use a TED2?
  177                        		.endif	SUPPORT_TED2
  178                        	
  179                        	
  180                        	
  181               0001     		.if	USING_MPR7
  182                        	
  183                        	; ***************************************************************************
  184                        	; ***************************************************************************
  185                        	;
  186                        	; RESET VECTORS (when running in MPR7, either as a HuCARD, or a CD overlay)
  187                        	;
  188                        	
  189                        			; Hardware reset and interrupt vectors.
  190                        	
  191               FFF4     			.org	$FFF4
  192                        	
  193    00:FFF4  10         	core_version:	db	CORE_VERSION		; CORE(not TM) Version.
  194    00:FFF5  80         			db	$80			; System Card compatibility.
  195                        	
  196    00:FFF6  5D E0      			dw	core_irq2		; IRQ2	(from CD/ADPCM)
  197    00:FFF8  64 E0      			dw	core_irq1		; IRQ1	(from VDC)
  198    00:FFFA  58 E1      			dw	core_timer		; TIMER (from CPU)
  199    00:FFFC  5E E1      			dw	core_rti		; NMI	(unused)
  200               0000     		.if	CDROM
  202                        		.else
  203    00:FFFE  21 E0      			dw	core_hw_reset		; RESET (HuCARD)
  204                        		.endif	CDROM
  205                        	
  206               0001     		.if	USING_NEWPROC			; If the ".proc" trampolines
  207               FFF3     	__trampolineptr =	$FFF3			; are in MPR7, tell PCEAS to
  208                        		.endif					; put them below the vectors.
  209                        	
  210                        		.else	USING_MPR7
  222                        		.endif	USING_MPR7
  223                        	
  224                        	
  225                        	
  226                        	; ***************************************************************************
  227                        	; ***************************************************************************
  228                        	;
  229                        	; !!! THE HuCARD/OVERLAY PROGRAM'S FIRST BANK STARTS HERE !!!
  230                        	;
  231                        	
  232                        			; Switch to MPR2 for the "CORE(not TM)" library init.
  233                        			;
  234                        			; This is also executed by a HuCARD once it has run
  235                        			; its initial hardware-reset code.
  236                        			;
  237                        			; When run, MPR2-MPR6 are always mapped to the 1st 5 banks of
  238                        			; the overlay program, and MPR7 contains the System Card.
  239                        	
  240               4000     			.org	$4000
  241                        	
  242               0000     	CORE_BANK	=	bank(*) - _bank_base	; It isn't always zero! ;-)
  243                        	
  244               0000     			.bank	CORE_BANK, "CORE_BANK"	; Give it a label.
  245                        	
  246               0001     		.if	USING_MPR7
  247               0007     	CORE_PAGE	=	7			; User code runs in MPR7.
  248                        		.else
  250                        		.endif	USING_MPR7
  251                        	
  252    00:4000  4C 06 40   	core_boot:	jmp	* + 6			; Allow someone to patch this.
  253                        	
  254                        			; Add an ident string so isoLINK can autodetect configuration.
  255                        			;
  256                        			; This allows isoLINK to decide whether to use the IPL-SCD boot
  257                        			; sector hack, and whether to include a SuperGRAFX signature in
  258                        			; the boot sector, without the user having to manually use some
  259                        			; command line parameters, although they are free to do that if
  260                        			; they wish.
  261                        	
  262               0001     		.if	SUPPORT_SGX
  263               0000     		.if	BUILDING_STAGE1
  265                        		.else
  266    00:4003  53 47 58   			db	"SGX"			; SGX SuperCD or SGX HuCARD.
  267                        		.endif	BUILDING_STAGE1
  268                        		.else
  282                        		.endif	SUPPORT_SGX
  283                        	
  284               0000     		.if	CDROM
  331                        		.else	CDROM
  332                        	
  333                        			; Set up HuCARD RAM in a compatible way to the System Card.
  334                        			;
  335                        			; Note that the entire RAM is cleared by "core_hw_reset".
  336                        	
  337    00:4006  A9 1F      			lda	#%11111			; Enable joypad soft-reset.
  338    00:4008  8D 27 22   			sta	joyena
  339                        	
  340                        		.endif	CDROM
  341                        	
  342                        			; Now that RAM is initialized ...
  343                        	
  344    00:400B  43 04      			tma2				; Remember overlay's 1st bank
  345    00:400D  85 05      			sta	<core_1stbank		; $00, $02, $68 or $80!
  346               0001     		.if	USING_MPR7
  347    00:400F  53 80      			tam7				; "CORE(not TM)" takes MPR7!
  348                        		.endif
  349                        	
  350    00:4011  A2 FF      			ldx	#$FF			; Initialize stack pointer.
  351    00:4013  9A         			txs
  352                        	
  353    00:4014  20 5F E1   			jsr	core_clr_hooks		; Reset default hooks.
  354                        	
  355                        	;		stz	TIMER_CR		; Stop HuC6280 timer.
  356                        	;		stz	IRQ_ACK			; Clr HuC6280 timer interrupt.
  357                        	;		stz	IRQ_MSK			; Clr HuC6280 interrupt mask.
  358                        	
  359    00:4017  AD 00 02   			lda	VDC_SR			; Purge any overdue VBL.
  360    00:401A  9C 41 22   			stz	irq_cnt			; Make it easy to check.
  361    00:401D  58         			cli				; Restore interrupts.
  362                        	
  363    00:401E  4C E5 FF   			jmp	core_main		; Start the game's code.
  364                        	
  365                        	
  366                        	
  367               0001     		.if	!CDROM
  368                        	
  369                        	; ***************************************************************************
  370                        	; ***************************************************************************
  371                        	;
  372                        	; HuCARD Kernel Code
  373                        	;
  374                        	; core_ram1st - Start of code to relocate to MPR1.
  375                        	; core_ramend - End of code to relocate to MPR1.
  376                        	;
  377                        	
  378                        			; In a HuCARD, BSS variables start as low as possible.
  379                        	
  380               2200     			.bss
  381               22D0     			.org	core_ram1st
  382               22D0     	core_ramend	=	*
  383               4021     			.code
  384                        	
  385                        			; Normal HuCARD hardware-reset code, executed in MPR7.
  386                        			;
  387                        			; This does the basic PCE startup that every HuCARD (including
  388                        			; a System Card) needs to do, and then it remaps memory to be
  389                        			; compatible with the "CORE(not TM)" CD overlay program start.
  390                        	
  391               E021     			.page	7			; This will run in MPR7.
  392                        	
  393    00:E021  78         	core_hw_reset:	sei				; Disable interrupts.
  394    00:E022  D4         			csh				; Set high-speed mode.
  395    00:E023  D8         			cld
  396                        	
  397    00:E024  A2 FF      			ldx	#$FF			; Initialize stack pointer.
  398    00:E026  9A         			txs
  399    00:E027  8A         			txa				; MPR0 = $FF : PCE hardware
  400    00:E028  53 01      			tam0				; MPR1 = $F8 : PCE RAM
  401    00:E02A  A9 F8      			lda	#$F8
  402    00:E02C  53 02      			tam1
  403                        	
  404    00:E02E  9C 01 0C   			stz	TIMER_CR		; HW reset already does these,
  405    00:E031  9C 03 14   			stz	IRQ_ACK			; but this may be a reset from
  406    00:E034  9C 02 14   			stz	IRQ_MSK			; software (i.e. joypad).
  407                        	
  408    00:E037  F3 53 E0 00			tai	const_0000, $2000, 8192 ; Clear RAM.
         00:E03B  20 00 20    
  409                        	
  410    00:E03E  43 80      			tma7				; Not always bank 0!
  411                        	
  412    00:E040  53 04      			tam2				; Set CD-ROM overlay memory map,
  413    00:E042  1A         			inc	a			; 1st 5 banks in MPR2-MPR6.
  414    00:E043  53 08      			tam3
  415    00:E045  1A         			inc	a
  416    00:E046  53 10      			tam4
  417    00:E048  1A         			inc	a
  418    00:E049  53 20      			tam5
  419    00:E04B  1A         			inc	a
  420    00:E04C  53 40      			tam6
  421                        	
  422    00:E04E  4C 00 40   			jmp	core_boot		; Continue execution in MPR2.
  423                        	
  424                        			; In a HuCARD, the kernel code is permanently in MPR7.
  425                        	
                             #[5]   "..\..\..\include\hucc\core-kernel.asm"
  426                        			include "core-kernel.asm"
    1                        	; ***************************************************************************
    2                        	; ***************************************************************************
    3                        	;
    4                        	; core-kernel.asm
    5                        	;
    6                        	; The "CORE(not TM)" PC Engine library kernel code that runs after startup.
    7                        	;
    8                        	; Copyright John Brandwood 2021-2024.
    9                        	;
   10                        	; Distributed under the Boost Software License, Version 1.0.
   11                        	; (See accompanying file LICENSE_1_0.txt or copy at
   12                        	;  http://www.boost.org/LICENSE_1_0.txt)
   13                        	;
   14                        	; ***************************************************************************
   15                        	; ***************************************************************************
   16                        	;
   17                        	; This code is permanently located in either MPR7 (HuCARD), or MPR1 (CD-ROM),
   18                        	; and it provides a consistant method of interrupt-handling on both systems
   19                        	; that is designed to be compatible with the System Card.
   20                        	;
   21                        	; The library uses the "irq1_hook" for its own VDC interrupt handler, and PCE
   22                        	; developers are expected to use "vsync_hook" and "hsync_hook" for their VDC
   23                        	; interrupt functions.  Plenty of memory is available in the 1st bank for the
   24                        	; developer to put those functions.
   25                        	;
   26                        	; The reason for using "irq1_hook", is so that the library can work properly
   27                        	; if either the current overlay program, or the System Card, are mapped into
   28                        	; MPR7 whenever an interrupt occurs.
   29                        	;
   30                        	; The VDC interupt handler itself is changed from the System Card's handler,
   31                        	; and it is designed to provide faster response to vsync_hook, and to enable
   32                        	; interrupts during the slow(ish) joypad and sound driver code, so that both
   33                        	; raster and timer interrupts are not delayed.
   34                        	;
   35                        	; Developers are free to enable interrupts during their own vsync_hook code,
   36                        	; if they wish to do so.
   37                        	;
   38                        	; On CD-ROM systems, this library kernel also provides a function to load and
   39                        	; run a new overlay program, without relying upon any of the code/data within
   40                        	; the current overlay program's memory (unlike HuC v3).
   41                        	;
   42                        	; ***************************************************************************
   43                        	; ***************************************************************************
   44                        	
   45                        	
   46                        	
   47                        	; ***************************************************************************
   48                        	; ***************************************************************************
   49                        	;
   50                        	; core_kernel - Start of kernel code.
   51                        	;
   52                        	
   53               E051     	core_kernel	=	*
   54                        	
   55                        	
   56                        	
   57                        	; ***************************************************************************
   58                        	; ***************************************************************************
   59                        	;
   60                        	; Useful constants, needed by joypad library code, and used by many others.
   61                        	;
   62                        	; The kernel starts with a non-zero byte so that core-startup.asm can check
   63                        	; whether it has already been loaded into RAM.
   64                        	;
   65                        	
   66    00:E051  FF FF      	const_FFFF:	dw	$FFFF			; Useful constant for TAI.
   67    00:E053  00 00      	const_0000:	dw	$0000			; Useful constant for TAI.
   68                        	
   69    00:E055  01 02 04 08	bit_mask:	db	$01,$02,$04,$08,$10,$20,$40,$80
         00:E059  10 20 40 80 
   70                        	
   71                        	
   72                        	
   73                        	; ***************************************************************************
   74                        	; ***************************************************************************
   75                        	;
   76                        	; core_irq2  - Minimal interrupt handler compatible with System Card.
   77                        	; core_irq1  - Minimal interrupt handler compatible with System Card.
   78                        	; core_timer - Minimal interrupt handler compatible with System Card.
   79                        	; core_rti   - Minimal interrupt handler compatible with System Card.
   80                        	;
   81                        	; Note that it takes 8 cycles to respond to an IRQ.
   82                        	;
   83                        	; These routines are copied to a location in RAM that does not vary when
   84                        	; a different overlay program is loaded.
   85                        	;
   86                        	; All overlay programs are set up to vector interrupts to these routines,
   87                        	; which is designed to avoid interrupt-related crashes when loading a new
   88                        	; overlay on top of an old overlay in memory.
   89                        	;
   90                        	; All of the game's actual interrupt handling itself is done in the "hook"
   91                        	; functions so that everything works the same if the System Card is banked
   92                        	; into MPR7 when an interrupt occurs.
   93                        	;
   94                        	; ***************************************************************************
   95                        	; ***************************************************************************
   96                        	;
   97                        	; Bit settings for irq_vec  ...
   98                        	;
   99                        	;   7 : 1 to skip BIOS hsync processsing
  100                        	;   6 : 1 to call [hsync_hook]
  101                        	;   5 : 1 to skip BIOS vsync processsing
  102                        	;   4 : 1 to call [vsync_hook]
  103                        	;
  104                        	;   3 : 1 to jump [nmi_hook]
  105                        	;   2 : 1 to jump [timer_hook]
  106                        	;   1 : 1 to jump [irq1_hook]
  107                        	;   0 : 1 to jump [irq2_hook]
  108                        	;
  109                        	; ***************************************************************************
  110                        	; ***************************************************************************
  111                        	
  112    00:E05D  8F F5 01   	core_irq2:	bbs0	<irq_vec, .hook		; 8 cycles if using hook.
  113                        	
  114               0000     		.if	CDROM
  138                        		.else
  139                        			; Does this HuCARD support the IFU's ADPCM hardware?
  140                        	
  141               0000     		.if	SUPPORT_ADPCM
  153                        		.endif	SUPPORT_ADPCM
  154                        	
  155    00:E060  40         			rti				; No IRQ2 hardware on HuCARD.
  156                        	
  157    00:E061  6C 00 22   	.hook:		jmp	[irq2_hook]		; 7 cycles.
  158                        		.endif	CDROM
  159                        	
  160                        	
  161                        	
  162                        	; ***************************************************************************
  163                        	; ***************************************************************************
  164                        	;
  165                        	; core_irq1 - Minimal interrupt handler compatible with System Card.
  166                        	;
  167                        	; irq1_handler - Basic "CORE(not TM)" IRQ1 handler to use as the "irq1_hook".
  168                        	;
  169                        	; Doing the IRQ1 handler processing in this hook means that things operate
  170                        	; the same whether the System Card or an Overlay is paged into MPR7.
  171                        	
  172               0000     		.ifndef	HUCC
  181                        		.else
  182                        			; Faster IRQ servicing for HuCC and code that would like to
  183                        			; avoid the 8 cycles used by the "bbs1" instruction that is
  184                        			; taken when the System Card is mapped into MPR7.
  185                        	
  186    00:E064             	core_irq1:	;;;				; 8 (cycles for the INT)
  187               0001     		.if	CDROM || !defined(NO_CORE_IRQ1_HOOK)
  188    00:E064  6C 02 22   			jmp	[irq1_hook]		; 7 cycles.
  189                        	
  190                        		.endif
  191                        		.endif
  192                        	
  193    00:E067  48         	irq1_handler:	pha				; 3 Save all registers.
  194    00:E068  DA         			phx				; 3
  195    00:E069  5A         			phy				; 3
  196                        	
  197               0000     		.ifndef	USING_RCR_MACROS		;   This slows things down
  206                        		.endif	USING_RCR_MACROS
  207                        	
  208    00:E06A  AD 00 02   			lda	VDC_SR			; 6 Acknowledge the VDC's IRQ.
  209    00:E06D  85 F6      			sta	<vdc_sr			; 4 Remember what caused it.
  210                        	
  211               0001     		.if	SUPPORT_SGX
  212    00:E06F  AE 10 02   			ldx	SGX_SR			; 6 Read SGX_SR after VDC_SR in
  213    00:E072  86 06      			stx	<sgx_sr			; 4 case this is not an SGX!
  214                        		.endif
  215                        	
  216                        			; Handle the VDC's RCR interrupt.
  217                        	
  218    00:E074  29 04      	!:		and	#$04			; 2 Is this an HSYNC interrupt?
  219    00:E076  F0 44      			beq	!+			; 2
  220                        	
  221               0001     		.ifdef	USING_RCR_MACROS
  222                        			VDC_RCR_MACRO
                             	
         00:E078  03 06      			st0	#VDC_RCR		; 5
                             	
         00:E07A  AE 18 27   			ldx	vdc_next_region		; 5 X and Y can be greater than
         00:E07D  BC 19 27   			ldy	vdc_regionA_nxt, x	; 5 HUCC_PCE_SPLITS if regionB!
         00:E080  18         			clc				; 2
         00:E081  D0 05      			bne	!set_next_rcr+		; 4 Stop RCR if next line is 0.
                             	
         00:E083  2D 53 E0   			and	const_0000		; 5 A=$00 with the same #cycles
         00:E086  80 05      			bra	!clr_next_rcr+		; 4 as if the branch were taken.
                             	
         00:E088  B9 C8 26   	!set_next_rcr:	lda	vdc_regionA_rcr, y	; 5 Set next RCR 1 line before
         00:E08B  69 3F      			adc	#64-1			; 2 the region begins, or 0 to
         00:E08D  8D 02 02   	!clr_next_rcr:	sta	VDC_DL			; 6 disable.
         00:E090  62         			cla				; 2
         00:E091  2A         			rol	a			; 2
         00:E092  8D 03 02   			sta	VDC_DH			; 6
                             	
         00:E095  03 08      			st0	#VDC_BYR		; 5 Do BYR first to mitigate the
         00:E097  BD F8 26   			lda	vdc_regionA_yl, x	; 5 glitch if the IRQ is delayed.
         00:E09A  8D 02 02   			sta	VDC_DL			; 6 = 105 cycles from RCR on SGX
         00:E09D  BD 08 27   			lda	vdc_regionA_yh, x	; 5
         00:E0A0  8D 03 02   			sta	VDC_DH			; 6
                             	
         00:E0A3  03 05      			st0	#VDC_CR			; 5
         00:E0A5  BD B8 26   			lda	vdc_regionA_crl, x	; 5
                             	;		asl	a
         00:E0A8  8D 02 02   			sta	VDC_DL			; 6
                             	
         00:E0AB  03 07      			st0	#VDC_BXR		; 2
         00:E0AD  BD D8 26   			lda	vdc_regionA_xl, x	; 5
         00:E0B0  8D 02 02   			sta	VDC_DL			; 6
         00:E0B3  BD E8 26   			lda	vdc_regionA_xh, x	; 5
         00:E0B6  8D 03 02   			sta	VDC_DH			; 6 = 156 cycles from RCR if DUO
                             	
                             	;		bcc	!+
                             	;		lda	vdc_regionA_yh, x	; 5
                             	;		sta.l	VCE_CTW			; 6
                             	
         00:E0B9  8C 18 27   			sty	vdc_next_region		; 5
                             	
  223                        		.else
  225                        		.endif
  226                        	
  227               0001     		.if	SUPPORT_SGX
  228                        	
  229                        			; Handle the SGX's RCR interrupt.
  230                        	
  231    00:E0BC  2F 06 50   	!:		bbr2	<sgx_sr, !+		; 6 Is this an HSYNC interrupt?
  232                        	
  233               0001     		.ifdef	USING_RCR_MACROS
  234                        			SGX_RCR_MACRO
                             	
         00:E0BF  A9 06      			lda	#VDC_RCR		; 2
         00:E0C1  8D 10 02   			sta	SGX_AR			; 6
                             	
         00:E0C4  AE 99 27   			ldx	sgx_next_region		; 5 X and Y can be greater than
         00:E0C7  BC 9A 27   			ldy	sgx_regionA_nxt, x	; 5 HUCC_SGX_SPLITS if regionB!
         00:E0CA  18         			clc				; 2
         00:E0CB  D0 05      			bne	!set_next_rcr+		; 4 Stop RCR if next line is 0.
                             	
         00:E0CD  2D 53 E0   			and	const_0000		; 5 A=$00 with the same #cycles
         00:E0D0  80 05      			bra	!clr_next_rcr+		; 4 as if the branch were taken.
                             	
         00:E0D2  B9 49 27   	!set_next_rcr:	lda	sgx_regionA_rcr, y	; 5 Set next RCR 1 line before
         00:E0D5  69 3F      			adc	#64-1			; 2 the region begins, or 0 to
         00:E0D7  8D 12 02   	!clr_next_rcr:	sta	SGX_DL			; 6 disable.
         00:E0DA  62         			cla				; 2
         00:E0DB  2A         			rol	a			; 2
         00:E0DC  8D 13 02   			sta	SGX_DH			; 6
                             	
         00:E0DF  A9 08      			lda	#VDC_BYR		; 2 Do BYR first to mitigate the
         00:E0E1  8D 10 02   			sta	SGX_AR			; 6 glitch if the IRQ is delayed.
         00:E0E4  BD 79 27   			lda	sgx_regionA_yl, x	; 5
         00:E0E7  8D 12 02   			sta	SGX_DL			; 6
         00:E0EA  BD 89 27   			lda	sgx_regionA_yh, x	; 5
         00:E0ED  8D 13 02   			sta	SGX_DH			; 6
                             	
         00:E0F0  A9 05      			lda	#VDC_CR			; 2
         00:E0F2  8D 10 02   			sta	SGX_AR			; 6
         00:E0F5  BD 39 27   			lda	sgx_regionA_crl, x	; 5
         00:E0F8  8D 12 02   			sta	SGX_DL			; 6
                             	
         00:E0FB  A9 07      			lda	#VDC_BXR		; 2
         00:E0FD  8D 10 02   			sta	SGX_AR			; 6
         00:E100  BD 59 27   			lda	sgx_regionA_xl, x	; 5
         00:E103  8D 12 02   			sta	SGX_DL			; 6
         00:E106  BD 69 27   			lda	sgx_regionA_xh, x	; 5
         00:E109  8D 13 02   			sta	SGX_DH			; 6 = 293 cycles (282 if no YH)
                             	
         00:E10C  8C 99 27   			sty	sgx_next_region		; 5
                             	
  235                        		.else
  237                        		.endif
  238                        	
  239                        		.endif	SUPPORT_SGX
  240                        	
  241                        			; Handle the VDC's VBL interrupt.
  242                        	
  243    00:E10F  5F F6 32   	!:		bbr5	<vdc_sr, .exit_irq1	; 6 Is this a VBLANK interrupt?
  244                        	
  245               0001     		.ifdef	USING_RCR_MACROS		;   If we didn't do it earlier
  246               0000     		.if	CDROM				;   then we need to do it now.
  253                        		.endif	CDROM
  254                        		.endif	USING_RCR_MACROS
  255                        	
  256               0001     		.if	SUPPORT_SGX
  257    00:E112  A9 05      			lda	#VDC_CR			; Update the SGX's Control
  258    00:E114  8D 10 02   			sta	SGX_AR			; Register first, just in
  259    00:E117  8D 00 02   			sta	VDC_AR			; case this is not an SGX!
  260    00:E11A  A5 03      			lda	<sgx_crl		
  261    00:E11C  8D 12 02   			sta	SGX_DL
  262    00:E11F  A5 F3      			lda	<vdc_crl
  263    00:E121  8D 02 02   			sta	VDC_DL
  264                        	
  265                        	;		lda	<sgx_crh		; Do not mess with the SGX's
  266                        	;		sta	SGX_DH			; auto-increment!!!
  267                        	;		lda	<vdc_crh		; Do not mess with the VDC's
  268                        	;		sta	VDC_DH			; auto-increment!!!
  269                        		.else
  277                        		.endif	SUPPORT_SGX
  278                        	
  279    00:E124  EE 41 22   			inc	irq_cnt			; Mark that a VBLANK occurred.
  280                        	
  281    00:E127  4F F5 02   			bbr4	<irq_vec, .skip_hookv	; Is a driver registered?
  282                        	
  283    00:E12A  44 26      			bsr	.user_vsync		; Call game's VBLANK code.
  284                        	
  285    00:E12C  DF F5 15   	.skip_hookv:	bbs5	<irq_vec, .exit_vbl	; Should we skip "BIOS" stuff?
  286                        	
  287    00:E12F  58         			cli				; Allow HSYNC and TIMER IRQ.
  288                        	
  289    00:E130  20 DB FF   			call	read_joypads		; Update joypad state.
  290                        	
  291               0000     		.if	USING_PSGDRIVER
  305                        		.else
  306    00:E133  AD 07 22   			lda	sound_hook + 1		; Is a driver registered?
  307    00:E136  F0 0C      			beq	.exit_vbl
  308                        	
  309    00:E138  A9 80      			lda	#$80			; Acquire sound mutex to avoid
  310    00:E13A  0C E7 22   			tsb	sound_mutex		; conflict with a delayed VBL.
  311    00:E13D  30 05      			bmi	.exit_vbl
  312                        	
  313    00:E13F  44 14      			bsr	.user_sound		; Call the driver hook.
  314                        	
  315    00:E141  9C E7 22   			stz	sound_mutex		; Release sound mutex.
  316                        		.endif	USING_PSGDRIVER
  317                        	
  318    00:E144             	.exit_vbl:
  319                        	
  320               0001     		.ifdef	USING_RCR_MACROS		; If USING_RCR_MACROS then 
  321               0000     		.if	CDROM				; restore after the VBLANK.
  326                        		.endif	CDROM
  327                        		.endif	USING_RCR_MACROS
  328                        	
  329    00:E144             	.exit_irq1:
  330                        	
  331               0000     		.ifndef	USING_RCR_MACROS		; If !USING_RCR_MACROS then
  338                        		.endif	USING_RCR_MACROS
  339                        	
  340               0001     		.if	SUPPORT_SGX
  341    00:E144  A5 07      			lda	<sgx_reg		; Restore SGX_AR first, just
  342    00:E146  8D 10 02   			sta	SGX_AR			; in case this is not an SGX!
  343                        		.endif
  344                        	
  345    00:E149  A5 F7      			lda	<vdc_reg		; Restore VDC_AR in case we
  346    00:E14B  8D 00 02   			sta	VDC_AR			; changed it.
  347                        	
  348    00:E14E  7A         			ply				; Restore all registers.
  349    00:E14F  FA         			plx
  350    00:E150  68         			pla
  351                        	
  352    00:E151  40         			rti				; Return from interrupt.
  353                        	
  354    00:E152  6C 08 22   	.user_vsync:	jmp	[vsync_hook]		; 7
  355    00:E155  6C 06 22   	.user_sound:	jmp	[sound_hook]		; 7
  356                        	
  357               0000     		.ifndef	USING_RCR_MACROS
  362                        		.endif	USING_RCR_MACROS
  363                        	
  364                        	
  365                        	
  366                        	; ***************************************************************************
  367                        	; ***************************************************************************
  368                        	;
  369                        	; core_timer - Minimal interrupt handler compatible with System Card.
  370                        	;
  371                        	; tirq_handler - Basic "CORE(not TM)" TIRQ handler to use as the "timer_hook".
  372                        	;
  373                        	; Doing the TIRQ handler processing in this hook means that things operate
  374                        	; the same whether the System Card or an Overlay is paged into MPR7.
  375                        	
  376               0000     		.ifndef	HUCC
  385                        		.else
  386                        			; Faster IRQ servicing for HuCC and code that would like to
  387                        			; avoid the 8 cycles used by the "bbs2" instruction that is
  388                        			; taken when the System Card is mapped into MPR7.
  389                        	
  390    00:E158             	core_timer:	;;;				; 8 (cycles for the INT)
  391               0001     		.if	CDROM || !defined(NO_CORE_TIRQ_HOOK)
  392    00:E158  6C 04 22   			jmp	[timer_hook]		; 7 cycles.
  393                        		.endif
  394                        		.endif
  395                        	
  396    00:E15B             	tirq_handler:
  397               0000     		.ifdef	USING_TIRQ_MACRO
  399                        		.else
  400    00:E15B  9C 03 14   			stz	IRQ_ACK			; 5 Clear timer interrupt.
  401                        		.endif
  402                        	
  403    00:E15E  40         	core_rti:	rti
  404                        	
  405                        	
  406                        	
  407                        	; ***************************************************************************
  408                        	; ***************************************************************************
  409                        	;
  410                        	; core_clr_hooks - Reset default "CORE(not TM)" interrupt-handling hooks.
  411                        	;
  412                        	
  413    00:E15F  08         	core_clr_hooks:	php				; Preserve interrupt state.
  414    00:E160  78         			sei				; Disable interrupts.
  415                        	
  416               0000     		.if	USING_PSGDRIVER
  419                        		.else
  420    00:E161  9C 07 22   			stz.h	sound_hook		; Disable sound driver calls.
  421                        		.endif
  422                        	
  423    00:E164  A9 88      			lda	#<core_sw_reset		; Set up the soft-reset hook.
  424    00:E166  8D 84 22   			sta.l	reset_hook
  425    00:E169  A9 E1      			lda	#>core_sw_reset
  426    00:E16B  8D 85 22   			sta.h	reset_hook
  427                        	
  428    00:E16E  A9 67      			lda	#<irq1_handler		; Set up the IRQ1 hook.
  429    00:E170  8D 02 22   			sta.l	irq1_hook
  430    00:E173  A9 E0      			lda	#>irq1_handler
  431    00:E175  8D 03 22   			sta.h	irq1_hook
  432                        	
  433    00:E178  A9 5B      			lda	#<tirq_handler		; Set up the TIRQ hook.
  434    00:E17A  8D 04 22   			sta.l	timer_hook
  435    00:E17D  A9 E1      			lda	#>tirq_handler
  436    00:E17F  8D 05 22   			sta.h	timer_hook
  437                        	
  438    00:E182  A9 06      			lda	#%00000110		; Replace the System Card's
  439    00:E184  85 F5      			sta	<irq_vec		; IRQ1 and TIRQ processing.
  440                        	
  441    00:E186  28         			plp				; Restore interrupt state.
  442    00:E187  60         			rts
  443                        	
  444                        	
  445                        	
  446                        	; ***************************************************************************
  447                        	; ***************************************************************************
  448                        	;
  449                        	; Include the joypad library, with configuration from "core-config.inc".
  450                        	;
  451                        	
                             #[6]   "..\..\..\include\hucc\joypad.asm"
  452                        			include "joypad.asm"
    1                        	; ***************************************************************************
    2                        	; ***************************************************************************
    3                        	;
    4                        	; joypad.asm
    5                        	;
    6                        	; Read 2-button & 6-button joypads & PCE mouse, with or without a MultiTap.
    7                        	;
    8                        	; Copyright John Brandwood 2019-2025.
    9                        	;
   10                        	; Distributed under the Boost Software License, Version 1.0.
   11                        	; (See accompanying file LICENSE_1_0.txt or copy at
   12                        	;  http://www.boost.org/LICENSE_1_0.txt)
   13                        	;
   14                        	; ***************************************************************************
   15                        	; ***************************************************************************
   16                        	;
   17                        	; Unlike Lemmings, this code does not interfere with a Memory Base 128! ;-)
   18                        	;
   19                        	; ***************************************************************************
   20                        	; ***************************************************************************
   21                        	;
   22                        	; With SUPPORT_MOUSE ..... 2602 cycles to read 5 ports with 5 mice
   23                        	;
   24                        	; With HuC library code .. 2442 cycles to read 5 ports with 5 pads (2-button)
   25                        	; With HuC library code .. 2442 cycles to read 5 ports with 5 pads (6-button)
   26                        	;
   27                        	; With SUPPORT_MOUSE ....  2016 cycles to read 5 ports with 5 pads (2-button)
   28                        	; With SUPPORT_MOUSE ..... 1976 cycles to read 5 ports with 5 pads (6-button)
   29                        	;
   30                        	; With SUPPORT_MOUSE ....  1618 cycles to read 3 ports with 3 mice
   31                        	; With SUPPORT_MOUSE ..... 1462 cycles to read 3 ports with 2 mice
   32                        	; With SUPPORT_MOUSE ..... 1306 cycles to read 3 ports with 1 mouse
   33                        	;
   34                        	; With SUPPORT_6BUTTON ... 1235 cycles to read 5 ports with 5 pads (2-button)
   35                        	; With SUPPORT_6BUTTON ... 1215 cycles to read 5 ports with 5 pads (6-button)
   36                        	;
   37                        	; With SUPPORT_MOUSE ..... 1126 cycles to read 2 ports with 2 mice
   38                        	; With SUPPORT_MOUSE ...... 970 cycles to read 2 ports with 1 mouse
   39                        	;
   40                        	; Only SUPPORT_2BUTTON .... 971 cycles to read 5 ports with 5 pads (2-button)
   41                        	; Only SUPPORT_2BUTTON .... 861 cycles to read 5 ports with 5 pads (6-button)
   42                        	;
   43                        	; With SUPPORT_MOUSE ...... 634 cycles to read 1 port  with 1 mouse
   44                        	;
   45                        	; ***************************************************************************
   46                        	; ***************************************************************************
   47                        	
  142                        	
  143                        	;
  144                        	; Now choose which version of the code to include.
  145                        	;
  146                        	
  147               0000     		.if	SUPPORT_2BUTTON
  278                        		.endif	SUPPORT_2BUTTON
  279                        	
  280                        	
  281                        	
  282               0000     		.if	SUPPORT_MOUSE
  845                        		.else	SUPPORT_MOUSE
  846                        	
  847                        	
  848                        	
  849               0001     		.if	SUPPORT_6BUTTON			; Without mouse!
  850                        	
  851                        	; ***************************************************************************
  852                        	; ***************************************************************************
  853                        	;
  854                        	; read_joypads - full 6-button pad support, but mouse movement is ignored.
  855                        	;
  856                        	; This code distinguishes between a mouse and a 2-button or 6-button joypad,
  857                        	; so that unsupported devices do not have to be unplugged from the MultiTap.
  858                        	;
  859                        	; The code loops two times to get both sets of buttons on a 6-button joypad.
  860                        	;
  861                        	; N.B. Takes approx 1/3 frame to detect mice the first time it is run.
  862                        	;
  863                        	; bit values for joypad 2-button bytes: (MSB = #7; LSB = #0)
  864                        	; ----------------------------------------------------------
  865                        	; bit 0 (ie $01) = I
  866                        	; bit 1 (ie $02) = II
  867                        	; bit 2 (ie $04) = SELECT
  868                        	; bit 3 (ie $08) = RUN
  869                        	; bit 4 (ie $10) = UP
  870                        	; bit 5 (ie $20) = RIGHT
  871                        	; bit 6 (ie $40) = DOWN
  872                        	; bit 7 (ie $80) = LEFT
  873                        	;
  874                        	; bit values for joypad 6-button bytes: (MSB = #7; LSB = #0)
  875                        	; ----------------------------------------------------------
  876                        	; bit 0 (ie $01) = III
  877                        	; bit 1 (ie $02) = IV
  878                        	; bit 2 (ie $04) = V
  879                        	; bit 3 (ie $08) = VI
  880                        	; bit 4 (ie $10) = zero
  881                        	; bit 5 (ie $20) = zero
  882                        	; bit 6 (ie $40) = zero
  883                        	; bit 7 (ie $80) = zero, but set to one if 6-button pad detected.
  884                        	;
  885                        	
  886               E188     			.code
  887                        	
  888               0001     		.if	(* >= $4000)			; Make this a ".proc" if it
  889    11:C834             	read_joypads	.proc                           ; not running in RAM.
  890                        		.else
  892                        		.endif
  893                        	
  894    11:C834  A9 80      			lda	#$80			; Acquire port mutex to avoid
  895    11:C836  0C D0 22   			tsb	port_mutex		; conflict with a delayed VBL
  896    11:C839  30 75      			bmi	.exit			; or access to an MB128.
  897                        	
  898    11:C83B  73 28 22 32			tii	joynow,joyold,MAX_PADS	; Save the previous values.
         11:C83F  22 05 00    
  899    11:C842  73 D3 22 D8			tii	joy6now,joy6old,MAX_PADS
         11:C846  22 05 00    
  900                        	
  901                        			; Reset the 6-btn bits, the user might change the joypad mode!
  902                        	
  903    11:C849  F3 53 E0 D3			tai	const_0000, joy6now, MAX_PADS
         11:C84D  22 05 00    
  904                        	
  905                        			; Detect attached mice the first time this routine is called.
  906                        	
  907    11:C850  AD D2 22   			lda	mouse_flg		; Has mouse detection happened?
  908    11:C853  30 28      			bmi	.calc_pressed
  909                        	
  910    11:C855  A9 05      			lda	#MAX_PADS		; Reset number of pads to read.
  911    11:C857  8D D1 22   			sta	num_ports
  912                        	
  913    11:C85A  A9 1F      			lda	#%00011111		; Try reading everything as a
  914    11:C85C  8D D2 22   			sta	mouse_flg		; mouse.
  915                        	
  916    11:C85F  A0 17      			ldy	#23			; Initialize repeat count.
  917    11:C861  A9 80      			lda	#$80			; Initialize mouse detection.
  918    11:C863  5A         	.detect_loop:	phy
  919    11:C864  48         			pha
  920    11:C865  44 53      			bsr	.read_devices		; Read all devices as if mice.
  921    11:C867  68         			pla
  922    11:C868  82         			clx
  923    11:C869  BC E2 22   	.detect_port:	ldy	mouse_x, x		; A movement of zero means
  924    11:C86C  D0 03      			bne	.detect_next		; this port is a mouse.
  925    11:C86E  1D 55 E0   			ora	bit_mask, x
  926    11:C871  E8         	.detect_next:	inx				; Get the next pad from the
  927    11:C872  E0 05      			cpx	#MAX_PADS		; multitap.
  928    11:C874  D0 F3      			bne	.detect_port
  929    11:C876  7A         			ply				; Repeat the detection test.
  930    11:C877  88         			dey
  931    11:C878  D0 E9      			bne	.detect_loop
  932                        	
  933                        	;	.if	DETECT_PHANTOMS
  934                        	;		cmp	#(1 << MAX_PADS) + 127	; If we find a mouse in every
  935                        	;		bne	.detect_done		; port, then assume mirrored!
  936                        	;		lda	#1			; Report a single mouse in a
  937                        	;		sta	num_ports		; single port.
  938                        	;		lda	#$81
  939                        	;	.endif
  940                        	
  941    11:C87A  8D D2 22   	.detect_done:	sta	mouse_flg		; Report mouse detection.
  942                        	
  943                        			; See what has just been pressed, and check for soft-reset.
  944                        	
  945    11:C87D  44 3B      	.calc_pressed:	bsr	.read_devices		; Read all devices normally.
  946                        	
  947    11:C87F  A2 04      			ldx	#MAX_PADS - 1
  948                        	
  949    11:C881  BD D3 22   	.pressed_loop:	lda	joy6now, x		; Calc which buttons have just
  950    11:C884  5D D8 22   			eor	joy6old, x		; been pressed (6-button).
  951    11:C887  3D D3 22   			and	joy6now, x
  952               0000     		.if	HUC_JOY_EVENTS
  956                        		.else
  957               0000     		.if	ACCUMULATE_JOY
  959                        		.endif
  960    11:C88A  9D DD 22   			sta	joy6trg, x
  961                        		.endif
  962                        	
  963    11:C88D  BD 28 22   			lda	joynow, x		; Calc which buttons have just
  964    11:C890  A8         			tay                             ; been pressed (2-button).
  965    11:C891  5D 32 22   			eor	joyold, x
  966    11:C894  3D 28 22   			and	joynow, x
  967               0000     		.if	HUC_JOY_EVENTS
  971                        		.else
  972               0000     		.if	ACCUMULATE_JOY
  974                        		.endif
  975    11:C897  9D 2D 22   			sta	joytrg, x
  976                        		.endif
  977                        	
  978    11:C89A  C9 04      			cmp	#$04			; Detect the soft-reset combo,
  979    11:C89C  D0 0C      			bne	.not_reset		; hold RUN then press SELECT.
  980    11:C89E  C0 0C      			cpy	#$0C
  981    11:C8A0  D0 08      			bne	.not_reset
  982    11:C8A2  BD 55 E0   			lda	bit_mask, x
  983    11:C8A5  2C 27 22   			bit	joyena
  984    11:C8A8  D0 09      			bne	.soft_reset
  985                        	
  986    11:C8AA  CA         	.not_reset:	dex				; Check the next pad from the
  987    11:C8AB  10 D4      			bpl	.pressed_loop		; multitap.
  988                        	
  989    11:C8AD  9C D0 22   			stz	port_mutex		; Release port mutex.
  990                        	
  991               0001     		.if	(* >= $4000)			; This is a ".proc" if it is
  992                        	.exit:		leave                           ; not running in RAM.
         11:C8B0  4C EF FF   			jmp	leave_proc
  993                        		.else
  995                        		.endif
  996                        	
  997    11:C8B3  78         	.soft_reset:	sei				; Disable interrupts.
  998    11:C8B4  9C D0 22   			stz	port_mutex		; Release port mutex.
  999    11:C8B7  6C 84 22   			jmp	[reset_hook]		; Jump to the soft-reset hook.
 1000                        	
 1001                        			; Read all of the devices attached to the MultiTap.
 1002                        	
 1003    11:C8BA  A2 02      	.read_devices:	ldx	#2			; Repeat this loop 2 times.
 1004                        	
 1005    11:C8BC  A9 01      	.read_multitap:	lda	#$01			; CLR lo, SEL hi for d-pad.
 1006    11:C8BE  8D 00 10   			sta	IO_PORT
 1007    11:C8C1  A9 03      			lda	#$03			; CLR hi, SEL hi, reset tap.
 1008    11:C8C3  8D 00 10   			sta	IO_PORT
 1009    11:C8C6  C2         			cly				; Start at port 1.
 1010                        	
 1011    11:C8C7  A9 01      	.read_port:	lda	#$01			; CLR lo, SEL hi for d-pad.
 1012    11:C8C9  8D 00 10   			sta	IO_PORT			; Wait 1.25us (9 cycles).
 1013                        	
 1014    11:C8CC  B9 55 E0   			lda	bit_mask, y		; Is there a mouse attached?
 1015    11:C8CF  2D D2 22   			and	mouse_flg
 1016    11:C8D2  D0 33      			bne	.read_mouse
 1017                        	
 1018    11:C8D4  AD 00 10   	.read_pad:	lda	IO_PORT			; Read direction-pad bits.
 1019    11:C8D7  9C 00 10   			stz	IO_PORT			; CLR lo, SEL lo for buttons.
 1020    11:C8DA  0A         			asl	a			; Wait 1.25us (9 cycles).
 1021    11:C8DB  0A         			asl	a
 1022    11:C8DC  0A         			asl	a
 1023    11:C8DD  0A         			asl	a
 1024    11:C8DE  F0 1B      			beq	.read_6button		; 6-btn pad if UDLR all held.
 1025                        	
 1026    11:C8E0  99 28 22   	.read_2button:	sta	joynow, y		; Get buttons of 2-btn pad.
 1027    11:C8E3  AD 00 10   			lda	IO_PORT
 1028    11:C8E6  29 0F      			and	#$0F
 1029    11:C8E8  19 28 22   			ora	joynow, y
 1030    11:C8EB  49 FF      			eor	#$FF
 1031    11:C8ED  99 28 22   			sta	joynow, y
 1032                        	
 1033    11:C8F0  C8         	.next_port:	iny				; Get the next pad from the
 1034    11:C8F1  CC D1 22   			cpy	num_ports		; multitap.
 1035    11:C8F4  90 D1      			bcc	.read_port
 1036                        	
 1037    11:C8F6  CA         			dex				; Do the next complete pass.
 1038    11:C8F7  CA         			dex
 1039    11:C8F8  10 C2      			bpl	.read_multitap		; Have we finished 2 passes?
 1040    11:C8FA  60         			rts				; Now that everything is read.
 1041                        	
 1042    11:C8FB  AD 00 10   	.read_6button:	lda	IO_PORT			; Get buttons of 6-btn pad.
 1043    11:C8FE  29 0F      			and	#$0F
 1044    11:C900  49 8F      			eor	#$8F			; Set bit-7 to show that a
 1045    11:C902  99 D3 22   			sta	joy6now, y		; 6-button pad is present.
 1046    11:C905  80 E9      			bra	.next_port
 1047                        	
 1048    11:C907  7C 38 C9   	.read_mouse:	jmp	[.mouse_vectors, x]	; Which mouse info is next?
 1049                        	
 1050                        			; Mouse processing, normally four passes, here just two.
 1051                        	
 1052    11:C90A  A9 1C      	.mouse_x_hi:	lda	#28			; 189 cycle delay after CLR lo
 1053    11:C90C  3A         	.wait_loop:	dec	a			; on port to allow the mouse
 1054    11:C90D  D0 FD      			bne	.wait_loop		; to buffer and reset counters.
 1055                        	
 1056    11:C90F  AD 00 10   			lda	IO_PORT			; Read direction-pad bits.
 1057    11:C912  9C 00 10   			stz	IO_PORT			; CLR lo, SEL lo for buttons.
 1058    11:C915  0A         			asl	a			; Wait 1.25us (9 cycles).
 1059    11:C916  0A         			asl	a
 1060    11:C917  0A         			asl	a
 1061    11:C918  0A         			asl	a
 1062    11:C919  99 E2 22   			sta	mouse_x, y		; Save port's X-hi nibble.
 1063                        	
 1064    11:C91C  AD 00 10   			lda	IO_PORT			; Get mouse buttons.
 1065    11:C91F  29 0F      			and	#$0F
 1066    11:C921  49 0F      			eor	#$0F
 1067    11:C923  99 28 22   			sta	joynow, y
 1068    11:C926  80 C8      			bra	.next_port
 1069                        	
 1070    11:C928  AD 00 10   	.mouse_x_lo:	lda	IO_PORT			; Read direction-pad bits.
 1071    11:C92B  9C 00 10   			stz	IO_PORT			; CLR lo, SEL lo for buttons.
 1072    11:C92E  29 0F      			and	#$0F			; Wait 1.25us (9 cycles).
 1073    11:C930  19 E2 22   			ora	mouse_x, y		; Add port's X-hi nibble.
 1074                        	;		eor	#$FF			; Negate so LEFT is -ve.
 1075                        	;		inc	a
 1076    11:C933  99 E2 22   			sta	mouse_x, y
 1077    11:C936  80 B8      			bra	.next_port
 1078                        	
 1079    11:C938  28 C9      	.mouse_vectors: dw	.mouse_x_lo		; Pass 2
 1080    11:C93A  0A C9      			dw	.mouse_x_hi		; Pass 1
 1081                        	
 1082               0001     		.if	(* >= $4000)			; This is a ".proc" if it is
 1083                        			.endp                           ; not running in RAM.
 1084               22D0     			.bss				; Put the variables in RAM.
 1085                        		.endif
 1086                        	
 1087    F8:22D0             	port_mutex:	ds	1			; NZ when controller port busy.
 1088    F8:22D1             	num_ports:	ds	1			; Set to 1 if no multitap.
 1089    F8:22D2             	mouse_flg:	ds	1			; Which ports are mice?
 1090               0000     		.if	HUC_JOY_EVENTS
 1093                        		.endif
 1094    F8:22D3             	joy6now:	ds	MAX_PADS
 1095    F8:22D8             	joy6old:	ds	MAX_PADS
 1096    F8:22DD             	joy6trg:	ds	MAX_PADS
 1097    F8:22E2             	mouse_x:	ds	MAX_PADS
 1098                        	
 1099               E188     			.code
 1100                        	
 1101                        		.endif	SUPPORT_6BUTTON			; Without mouse!
 1102                        	
 1103                        		.endif	SUPPORT_MOUSE
                             #[5]   "..\..\..\include\hucc\core-kernel.asm"
  453                        	
  454                        	
  455                        	
  456               0001     		.if	!CDROM
  457                        	
  458                        	; ***************************************************************************
  459                        	; ***************************************************************************
  460                        	;
  461                        	; core_sw_reset - Default HuCARD handler for a joypad "soft-reset".
  462                        	;
  463                        	
  464    00:E188  78         	core_sw_reset:	sei				; Disable interrupts.
  465                        	
  466    00:E189  6C FE FF   			jmp	[$FFFE]			; Jump to the HuCARD reset.
  467                        	
  468                        	
  469                        	
  470                        		.else	!CDROM
  616                        		.endif	!CDROM
  617                        	
  618                        	
  619                        	
  620                        	; ***************************************************************************
  621                        	; ***************************************************************************
  622                        	
  623               0001     		.if	(core_kernel >= $4000)		; If not running in RAM, then
  624               22E7     			.bss				; put these variables in RAM.
  625                        		.endif
  626                        	
  627    F8:22E7             	sound_mutex:	ds	1			; NZ when controller port busy.
  628                        	
  629               0001     		.if	SUPPORT_SGX
  630    F8:22E8             	sgx_detected:	ds	1			; NZ if SuperGrafx detected.
  631    F8:22E9             	hsync_hook_sgx:	ds	2			; SGX version of hsync_hook.
  632                        		.endif
  633                        	
  634               0000     		.if	SUPPORT_ACD
  636                        		.endif
  637                        	
  638               0001     		.if	(core_kernel >= $4000)
  639               E18C     			.code
  640                        		.endif
                             #[4]   "..\..\..\include\hucc\core-startup.asm"
  427                        	
  428                        	
  429                        	
  430                        		.else	!CDROM
  524                        		.endif	!CDROM
  525                        	
  526                        	
  527                        	
  528                        	; ***************************************************************************
  529                        	; ***************************************************************************
  530                        	;
  531                        	; With the availability of so many different configuration options, we've now
  532                        	; built somewhere between a few hundred bytes, and a couple of KB, of code in
  533                        	; the CORE_BANK of the HuCARD / overlay program.
  534                        	;
  535                        	; This is the end of the "CORE(not TM)" library code!
  536                        	;
  537                        	; Remember that the ".proc" trampolines are located at the end of this bank,
  538                        	; so the amount of free space left depends upon the number of ".proc" calls.
  539                        	;
  540                        	
  541                        			; Switch to CORE_PAGE to run the developer's game code.
  542               E18C     			.page	CORE_PAGE
  543                        	
  544                        	
  545                        	
  546                        	; ***************************************************************************
  547                        	; ***************************************************************************
  548                        	;
  549                        	; The DATA_BANK location needs to be set as early as possible so that library
  550                        	; code is able to put data in there before the total overall size of the code
  551                        	; is known.
  552                        	;
  553                        	; By default, DATA_BANK is the next bank after the CORE_BANK.
  554                        	;
  555                        	; RESERVE_BANKS allows developers to reserve some banks between the CORE_BANK
  556                        	; and the DATA_BANK that they can use however they wish.
  557                        	;
  558                        	; One use for RESERVE_BANKS is to create empty space that PCEAS can use when
  559                        	; it relocates procedures. This provides a way for a developer to group code
  560                        	; together at the start of memory, and leave the maximum number of banks for
  561                        	; loading dynamic data from CD-ROM.
  562                        	;
  563                        	; The KickC environment sets RESERVE_BANKS=1 (or higher) so that there is a
  564                        	; a bank for the permanent C code and static constants.
  565                        	;
  566                        	; RESERVE_BANKS is normally defined in each project's "core-config.inc".
  567                        	;
  568                        	
  569                        			.opt	d+			; DATA labels use fixed MPR.
  570                        	
  571               0001     			.rsset	CORE_BANK + 1
  572                        	
  573               0000     		.ifdef	NEED_HOME_BANK
  580                        		.endif
  581                        	
  582               0001     		.ifdef	NEED_SOUND_BANK			; Defined in hucc-sound.inc
  583               0000     		.if	NEED_SOUND_BANK			; if the driver wants a bank.
  585                        		.endif
  586                        		.endif
  587                        	
  588               0001     		.ifdef	RESERVE_BANKS			; For CORE projects.
  589               0001     	RESERVED_BANK	.rs	RESERVE_BANKS
  590                        		.endif
  591                        	
  592               0001     		.ifdef	HUCC
  593               0001     		.ifdef	HUC_RESERVE_BANKS		; For HuCC projects.
  594               0001     	HUC_USER_BANK	.rs	HUC_RESERVE_BANKS
  595                        		.endif
  596                        	
  597               0001     	CONST_BANK	.rs	2
  598               6000     			.rodata
  599               0001     			.bank	CONST_BANK, ".rodata"
  600                        		.endif	HUCC
  601                        	
  602               0003     	DATA_BANK	.rs	0
  603               6000     			.data
  604               0000     		.if	BUILDING_STAGE1
  606                        		.else
  607               0003     			.bank	DATA_BANK, ".data"
  608                        		.endif
  609               6000     			.org	$6000
  610                        	
  611               E18C     			.code
                             #[3]   "..\..\..\include\hucc\core.inc"
                             #[2]   "..\..\..\include\hucc\hucc.asm"
  120                        		.else
  126                        		.endif
  127                        	
  128                        			; Allocate this as early as possible to ensure bank-aligned
  129                        			; so that there is no wasted space for aligning the table.
  130                        	
  131               0000     		.if	FAST_MULTIPLY
  138                        		.endif
  139                        	
  140                        			;
  141                        	
  144                        	
  145                        			; The hardware stack is used for expressions.
  146                        	
  147               00FF     	__tos		=	$F8:2101, 255
  148                        	
  149               2008     			.zp
  150               2008     			.align	2
  151    F8:2008             	__stack:	ds	HUCC_STACK_SZ
  152                        	
  153    F8:2088             	__ptr:		ds	2
  154    F8:208A             	__fptr:		ds	2
  155    F8:208C             	__fbank:	ds	1
  156    F8:208D             	__sp:		ds	1
  157                        	
  158                        			; REGTEMP 6-byte stack for temporaries used by SDCC.
  159                        			; Keep the size in sync with NUM_TEMP_REGS in sdcc/src/mos6502/gen.h!
  160                        	
  161    F8:208E             	REGTEMP:	ds	6
  162                        	
  163                        			; HuCC's non-recursive consecutive varargs for printf().
  164                        	
  165               2008     	__vararg1	=	__stack + 0
  166               200A     	__vararg2	=	__stack + 2
  167               200C     	__vararg3	=	__stack + 4
  168               200E     	__vararg4	=	__stack + 6
  169                        	
  170                        			; Pointer used by poke() because __ptr could be overwritten.
  171                        	
  172               20EE     	__poke		=	__si
  173                        	
  174                        			; Used for indirect calls because __ptr could be overwritten.
  175                        	
  176               20EE     	__func		=	__si
  177                        	
  178                        			; Data pointer used by SDCC for indirect indexed memory access.
  179                        	
  180               2088     	DPTR		=	__ptr
  181                        	
  182                        			; Values returned from SDCC functions that don't fit into XA.
  183                        			; These are also used as workspace for SDCC library functions,
  184                        			; including HuCC's multiplication and division functions.
  185                        	
  186    F8:2094             	___SDCC_m6502_ret0:	ds	1
  187    F8:2095             	___SDCC_m6502_ret1:	ds	1
  188    F8:2096             	___SDCC_m6502_ret2:	ds	1
  189    F8:2097             	___SDCC_m6502_ret3:	ds	1
  190                        	
  191               0000     		.if	0
  196                        		.endif
  197                        	
  198                        			; Permanent pointers for fast table-of-squares multiplication.
  199                        	
  200               0000     		.if	FAST_MULTIPLY
  205                        		.endif
  206                        	
  207                        			; HuCC keeps a realtime clock, updated in hucc_vbl.
  208                        			;
  209                        			; Defining this here means that it will go before any HuCC
  210                        			; variables in "globals.h", and so it won't get cleared in
  211                        			; a CDROM game when loading different overlays.
  212                        	
  213               22EB     			.bss
  214    F8:22EB             	old_cnt:	ds	1			; irq_cnt of previous vsync().
  215    F8:22EC             	clock_hh:	ds	1			; System Clock, hours	(0-11)
  216    F8:22ED             	clock_mm:	ds	1			; System Clock, minutes (0-59)
  217    F8:22EE             	clock_ss:	ds	1			; System Clock, seconds (0-59)
  218    F8:22EF             	clock_tt:	ds	1			; System Clock, ticks	(0-59)
  219               E18C     			.code
  220                        	
  221                        			; Critical HuCC libraries that the compiler depends upon.
  222                        			;
  223                        			; These include various macros that must be defined before
  224                        			; they are encountered in any compiler-generated code.
  225                        	
                             #[3]   "..\..\..\include\hucc\hucc-codegen.asm"
  226                        			include "hucc-codegen.asm"	; HuCC i-code macros and funcs.
    1                        	; ***************************************************************************
    2                        	; ***************************************************************************
    3                        	;
    4                        	; hucc-codegen.asm
    5                        	;
    6                        	; The HuCC compiler translates C code into these macros, it does not directly
    7                        	; generate HuC6280 instructions.
    8                        	;
    9                        	; Based on the original HuC macros created by David Michel and the other HuC
   10                        	; developers, later modified and improved by Ulrich Hecht.
   11                        	;
   12                        	; Modifications copyright John Brandwood 2024.
   13                        	;
   14                        	; Distributed under the Boost Software License, Version 1.0.
   15                        	; (See accompanying file LICENSE_1_0.txt or copy at
   16                        	;  http://www.boost.org/LICENSE_1_0.txt)
   17                        	;
   18                        	; ***************************************************************************
   19                        	; ***************************************************************************
   20                        	;
   21                        	; NAMING SCHEME FOR HuCC MACROS ...
   22                        	;
   23                        	;   __function.parameters
   24                        	;
   25                        	; {parameters} is a list of alphanumeric specifiers, starting with {size} and
   26                        	; followed by {where}, followed by {index} if an array, then optional {value}
   27                        	; and finally ending with optional {suffix}
   28                        	;
   29                        	; {size}
   30                        	;   w : 16-bit signed int (default "int" in HuCC)
   31                        	;   c : 16-bit unsigned int (a "cardinal" in Pascal terms)
   32                        	;   b :  8-bit signed char
   33                        	;   u :  8-bit unsigned char (default "char" in HuCC)
   34                        	;
   35                        	; {where} or {index}
   36                        	;   r : HuCC primary register, made up of the Y:A cpu registers
   37                        	;   t : top of expression stack
   38                        	;   p : indirect pointer, usually [__ptr]
   39                        	;   f : structure field (member) offset value
   40                        	;   i : immediate value, i.e. a decimal number
   41                        	;   m : memory, i.e. C global, static, and "-fno-recursive" variables
   42                        	;   s : stack, i.e. C function parameters and locals (not "-fno-recursive")
   43                        	;   a : array, i.e. C global, static, "-fno-recursive" arrays <= 256 bytes
   44                        	;   x : array index already in the X register
   45                        	;   y : array index already in the Y register
   46                        	;
   47                        	; {value} OPTIONAL
   48                        	;   i : immediate value, i.e. a decimal number
   49                        	;   z : zero value
   50                        	;
   51                        	; {suffix} OPTIONAL
   52                        	;   q : quick, used for optimized math on only 8-bit values, because all math
   53                        	;       is normally promoted to "int" size in C; and when optimized stores do
   54                        	;       not need to preserve the primary register contents
   55                        	;
   56                        	; ***************************************************************************
   57                        	; ***************************************************************************
   58                        	
   59                        	
   60                        	
 8399                        	
 8400                        	; ***************************************************************************
 8401                        	; ***************************************************************************
 8402                        	; subroutines for logical and arithmetic shifts by a constant amount
 8403                        	; ***************************************************************************
 8404                        	; ***************************************************************************
 8405                        	
 8406                        	; **************
 8407                        	; Y:A = Y:A << const
 8408                        	
 8409    00:E1BE  0A         	aslw15:		asl	a
 8410    00:E1BF  0A         	aslw14:		asl	a
 8411    00:E1C0  0A         	aslw13:		asl	a
 8412    00:E1C1  0A         	aslw12:		asl	a
 8413    00:E1C2  0A         	aslw11:		asl	a
 8414    00:E1C3  0A         	aslw10:		asl	a
 8415    00:E1C4  0A         	aslw9:		asl	a
 8416    00:E1C5  A8         	aslw8:		tay
 8417    00:E1C6  62         			cla
 8418    00:E1C7  60         			rts
 8419                        	
 8420               0001     		.if	1
 8421    00:E1C8  66 00      	aslw5:		ror	<__temp
 8422    00:E1CA  6A         			ror	a
 8423    00:E1CB  66 00      	aslw6:		ror	<__temp
 8424    00:E1CD  6A         			ror	a
 8425    00:E1CE  66 00      	aslw7:		ror	<__temp
 8426    00:E1D0  6A         			ror	a
 8427    00:E1D1  A4 00      			ldy	<__temp
 8428    00:E1D3  60         			rts
 8429                        		.else
 8436                        		.endif
 8437    00:E1D4  0A         	aslw4:		asl	a
 8438    00:E1D5  26 00      			rol	<__temp
 8439    00:E1D7  0A         	aslw3:		asl	a
 8440    00:E1D8  26 00      			rol	<__temp
 8441    00:E1DA  0A         	aslw2:		asl	a
 8442    00:E1DB  26 00      			rol	<__temp
 8443    00:E1DD  0A         	aslw1:		asl	a
 8444    00:E1DE  26 00      			rol	<__temp
 8445    00:E1E0  A4 00      	aslw0:		ldy	<__temp
 8446    00:E1E2  60         			rts
 8447                        	
 8448                        	; **************
 8449                        	; Y:A = Y:A >> const
 8450                        	
 8451    00:E1E3  C9 80      	asrw15:		cmp	#$80
 8452    00:E1E5  6A         			ror	a
 8453    00:E1E6  C9 80      	asrw14:		cmp	#$80
 8454    00:E1E8  6A         			ror	a
 8455    00:E1E9  C9 80      	asrw13:		cmp	#$80
 8456    00:E1EB  6A         			ror	a
 8457    00:E1EC  C9 80      	asrw12:		cmp	#$80
 8458    00:E1EE  6A         			ror	a
 8459    00:E1EF  C9 80      	asrw11:		cmp	#$80
 8460    00:E1F1  6A         			ror	a
 8461    00:E1F2  C9 80      	asrw10:		cmp	#$80
 8462    00:E1F4  6A         			ror	a
 8463    00:E1F5  C9 80      	asrw9:		cmp	#$80
 8464    00:E1F7  6A         			ror	a
 8465    00:E1F8  C9 80      	asrw8:		cmp	#$80
 8466    00:E1FA  C2         			cly
 8467    00:E1FB  90 01      			bcc	!+
 8468    00:E1FD  88         			dey
 8469    00:E1FE  60         	!:		rts
 8470                        	
 8471    00:E1FF  C0 80      	asrw7:		cpy	#$80
 8472    00:E201  66 00      			ror	<__temp
 8473    00:E203  6A         			ror	a
 8474    00:E204  C0 80      	asrw6:		cpy	#$80
 8475    00:E206  66 00      			ror	<__temp
 8476    00:E208  6A         			ror	a
 8477    00:E209  C0 80      	asrw5:		cpy	#$80
 8478    00:E20B  66 00      			ror	<__temp
 8479    00:E20D  6A         			ror	a
 8480    00:E20E  C0 80      	asrw4:		cpy	#$80
 8481    00:E210  66 00      			ror	<__temp
 8482    00:E212  6A         			ror	a
 8483    00:E213  C0 80      	asrw3:		cpy	#$80
 8484    00:E215  66 00      			ror	<__temp
 8485    00:E217  6A         			ror	a
 8486    00:E218  C0 80      	asrw2:		cpy	#$80
 8487    00:E21A  66 00      			ror	<__temp
 8488    00:E21C  6A         			ror	a
 8489    00:E21D  C0 80      	asrw1:		cpy	#$80
 8490    00:E21F  66 00      			ror	<__temp
 8491    00:E221  6A         			ror	a
 8492    00:E222  A4 00      	asrw0:		ldy	<__temp
 8493    00:E224  60         			rts
 8494                        	
 8495                        	; **************
 8496                        	; Y:A = Y:A >> const
 8497                        	
 8498    00:E225  4A         	lsrw15:		lsr	a
 8499    00:E226  4A         	lsrw14:		lsr	a
 8500    00:E227  4A         	lsrw13:		lsr	a
 8501    00:E228  4A         	lsrw12:		lsr	a
 8502    00:E229  4A         	lsrw11:		lsr	a
 8503    00:E22A  4A         	lsrw10:		lsr	a
 8504    00:E22B  4A         	lsrw9:		lsr	a
 8505    00:E22C  C2         	lsrw8:		cly
 8506    00:E22D  60         			rts
 8507                        	
 8508    00:E22E  46 00      	lsrw7:		lsr	<__temp
 8509    00:E230  6A         			ror	a
 8510    00:E231  46 00      	lsrw6:		lsr	<__temp
 8511    00:E233  6A         			ror	a
 8512    00:E234  46 00      	lsrw5:		lsr	<__temp
 8513    00:E236  6A         			ror	a
 8514    00:E237  46 00      	lsrw4:		lsr	<__temp
 8515    00:E239  6A         			ror	a
 8516    00:E23A  46 00      	lsrw3:		lsr	<__temp
 8517    00:E23C  6A         			ror	a
 8518    00:E23D  46 00      	lsrw2:		lsr	<__temp
 8519    00:E23F  6A         			ror	a
 8520    00:E240  46 00      	lsrw1:		lsr	<__temp
 8521    00:E242  6A         			ror	a
 8522    00:E243  A4 00      	lsrw0:		ldy	<__temp
 8523    00:E245  60         			rts
 8524                        	
 8525                        	
 8526                        	
 8527                        	; ***************************************************************************
 8528                        	; ***************************************************************************
 8529                        	; subroutines for logical and arithmetic shifts by a variable amount
 8530                        	; ***************************************************************************
 8531                        	; ***************************************************************************
 8532                        	
 8533                        	; **************
 8534                        	; Y:A = Y:A << X
 8535                        	
 8536    00:E246  84 00      	asl.wx:		sty	<__temp
 8537    00:E248  E0 10      			cpx	#16
 8538    00:E24A  B0 37      			bcs	!zero+
 8539    00:E24C  CA         			dex
 8540    00:E24D  30 06      			bmi	.done
 8541    00:E24F  0A         	.loop:		asl	a
 8542    00:E250  26 00      			rol	<__temp
 8543    00:E252  CA         			dex
 8544    00:E253  10 FA      			bpl	.loop
 8545    00:E255  A4 00      	.done:		ldy	<__temp
 8546    00:E257  60         			rts
 8547                        	
 8548                        	; **************
 8549                        	; Y:A = Y:A >> X
 8550                        	
 8551    00:E258  84 00      	asr.wx:		sty	<__temp
 8552    00:E25A  10 17      			bpl	!positive+
 8553    00:E25C  E0 10      	!negative:	cpx	#16
 8554    00:E25E  B0 0D      			bcs	.sign
 8555    00:E260  CA         			dex
 8556    00:E261  30 07      			bmi	.done
 8557    00:E263  38         	.loop:		sec
 8558    00:E264  66 00      			ror	<__temp
 8559    00:E266  6A         			ror	a
 8560    00:E267  CA         			dex
 8561    00:E268  10 F9      			bpl	.loop
 8562    00:E26A  A4 00      	.done:		ldy	<__temp
 8563    00:E26C  60         			rts
 8564                        	
 8565    00:E26D  A9 FF      	.sign:		lda	#$FF
 8566    00:E26F  A8         			tay
 8567    00:E270  60         			rts
 8568                        	
 8569                        	; **************
 8570                        	; Y:A = Y:A >> X
 8571                        	
 8572    00:E271  84 00      	lsr.wx:		sty	<__temp
 8573    00:E273  E0 10      	!positive:	cpx	#16
 8574    00:E275  B0 0C      			bcs	!zero+
 8575    00:E277  CA         			dex
 8576    00:E278  30 06      			bmi	.done
 8577    00:E27A  46 00      	.loop:		lsr	<__temp
 8578    00:E27C  6A         			ror	a
 8579    00:E27D  CA         			dex
 8580    00:E27E  10 FA      			bpl	.loop
 8581    00:E280  A4 00      	.done:		ldy	<__temp
 8582    00:E282  60         			rts
 8583                        	
 8584    00:E283  62         	!zero:		cla
 8585    00:E284  C2         			cly
 8586    00:E285  60         			rts
 8587                        	
 8588                        	
 8589                        	
 8590                        	; ***************************************************************************
 8591                        	; ***************************************************************************
 8592                        	; POTENTIAL OPTIMIZATIONS, NOT YET ADDED
 8593                        	; ***************************************************************************
 8594                        	; ***************************************************************************
                             #[2]   "..\..\..\include\hucc\hucc.asm"
                             #[3]   "..\..\..\include\hucc\hucc-baselib.asm"
  227                        			include	"hucc-baselib.asm"	; HuCC base library macros.
    1                        	; ***************************************************************************
    2                        	; ***************************************************************************
    3                        	;
    4                        	; hucc-baselib.asm
    5                        	;
    6                        	; Basic library functions provided (mostly) as macros.
    7                        	;
    8                        	; Copyright John Brandwood 2024-2025.
    9                        	;
   10                        	; Distributed under the Boost Software License, Version 1.0.
   11                        	; (See accompanying file LICENSE_1_0.txt or copy at
   12                        	;  http://www.boost.org/LICENSE_1_0.txt)
   13                        	;
   14                        	; ***************************************************************************
   15                        	; ***************************************************************************
   16                        	
   17                        	
   18                        	
   19                        	; ***************************************************************************
   20                        	; ***************************************************************************
   21                        	;
   22                        	; Make certain System Card variables accessible to HuCC.
   23                        	
   24    00:E286             	_irq_cnt	.alias	irq_cnt
   25    00:E286             	_joynow		.alias	joynow
   26    00:E286             	_joytrg		.alias	joytrg
   27    00:E286             	_joy6now	.alias	joy6now
   28    00:E286             	_joy6trg	.alias	joy6trg
   29    00:E286             	_bg_x1		.alias	bg_x1
   30    00:E286             	_bg_y1		.alias	bg_y1
   31    00:E286             	_bg_x2		.alias	bg_x2
   32    00:E286             	_bg_y2		.alias	bg_y2
   33                        	
   34                        	
   35                        	
   36                        	; ***************************************************************************
   37                        	; ***************************************************************************
   38                        	;
   39                        	; void __fastcall dump_screen( void );
   40                        	;
   41                        	; THIS IS AN ILLEGAL INSTRUCTION ONLY IMPLEMENTED BY THE TGEMU EMULATOR!
   42                        	
   43    00:E286  33         	_dump_screen:	db	0x33
   44                        	
   45                        	
   46                        	
   47                        	; ***************************************************************************
   48                        	; ***************************************************************************
   49                        	;
   50                        	; void __fastcall abort( void );
   51                        	;
   52                        	; THIS IS AN ILLEGAL INSTRUCTION ONLY IMPLEMENTED BY THE TGEMU EMULATOR!
   53                        	
   54    00:E287  E2         	_abort:		db	0xE2
   55                        	
   56                        	
   57                        	
   58                        	; ***************************************************************************
   59                        	; ***************************************************************************
   60                        	;
   61                        	; void __fastcall exit( int value<acc> );
   62                        	;
   63                        	; THIS IS AN ILLEGAL INSTRUCTION ONLY IMPLEMENTED BY THE TGEMU EMULATOR!
   64                        	
   65    00:E288  AA         	_exit.1:	tax				; Put the return code into X.
   66    00:E289  63         			db	0x63
   67                        	
   68    00:E28A  80 FE      	.hang:		bra	.hang			; Hang if used in normal code.
   69                        	
   70                        	
   71                        	
   72                        	; ***************************************************************************
   73                        	; ***************************************************************************
   74                        	;
   75                        	; unsigned char __fastcall __macro cd_execoverlay( unsigned char ovl_index<acc> );
   76                        	;
   77                        	; Execute program overlay from disc
   78                        	;
   79                        	; N.B. This does not return, even if there's an error.
   80                        	
   81                        			.macro	_cd_execoverlay.1
   82                        			tax
   83                        			jmp	exec_overlay
   84                        			.endm
   85                        	
   86                        	
   87                        	
   88                        	; ***************************************************************************
   89                        	; ***************************************************************************
   90                        	;
   91                        	; void __fastcall __nop set_far_base( unsigned char data_bank<_bp_bank>, unsigned char *data_addr<_bp> );
   92                        	; void __fastcall set_far_offset( unsigned int offset<_bp>, unsigned char data_bank<_bp_bank>, unsigned char *data_addr<acc> );
   93                        	
   94    00:E28C             	_set_far_offset.3:
   95    00:E28C  18         			clc
   96    00:E28D  65 EC      			adc.l	<_bp
   97    00:E28F  85 EC      			sta.l	<_bp
   98    00:E291  98         			tya
   99    00:E292  29 1F      			and	#$1F
  100    00:E294  65 ED      			adc.h	<_bp
  101    00:E296  A8         			tay
  102    00:E297  29 1F      			and	#$1F
  103    00:E299  09 60      			ora	#$60
  104    00:E29B  85 ED      			sta.h	<_bp
  105    00:E29D  98         			tya
  106    00:E29E  6A         			ror	a
  107    00:E29F  4A         			lsr	a
  108    00:E2A0  4A         			lsr	a
  109    00:E2A1  4A         			lsr	a
  110    00:E2A2  4A         			lsr	a
  111    00:E2A3  18         			clc
  112    00:E2A4  65 02      			adc	<_bp_bank
  113    00:E2A6  85 02      			sta	<_bp_bank
  114    00:E2A8  60         			rts
  115                        	
  116                        	
  117                        	; ***************************************************************************
  118                        	; ***************************************************************************
  119                        	;
  120                        	; void __fastcall __macro reset_mpr2( void );
  121                        	; void __fastcall __macro reset_mpr34( void );
  122                        	;
  123                        	; void * __fastcall __macro set_mpr2( void __far *addr<_bp_bank:_bp> );
  124                        	; void * __fastcall __macro set_mpr34( void __far *addr<_bp_bank:_bp> );
  125                        	;
  126                        	; void * __fastcall __macro far_set_mpr2( void );
  127                        	; void * __fastcall __macro far_set_mpr34( void );
  128                        	
  129                        	_reset_mpr2	.macro
  130                        		.if	SUPPORT_SGX
  131                        			lda	#$F9
  132                        		.else
  133                        			lda	#$87
  134                        		.endif
  135                        			tam2
  136                        			.endm
  137                        	
  138                        	_reset_mpr34	.macro
  139                        			lda	#CONST_BANK + _bank_base
  140                        			tam3
  141                        			inc	a
  142                        			tam4
  143                        			.endm
  144                        	
  145                        	_farset_mpr2.1	.macro
  146                        			lda	<_bp_bank
  147                        			tam2
  148                        			lda.l	<_bp
  149                        			ldy.h	<_bp
  150                        			.endm
  151                        	
  152                        	_farset_mpr34.1	.macro
  153                        			lda	<_bp_bank
  154                        			tam3
  155                        			inc	a
  156                        			tam4
  157                        			lda.l	<_bp
  158                        			ldy.h	<_bp
  159                        			.endm
  160                        	
  161                        	_far_set_mpr2	.macro
  162                        			lda	<_bp_bank
  163                        			tam2
  164                        			lda.l	<_bp
  165                        			ldy.h	<_bp
  166                        			.endm
  167                        	
  168                        	_far_set_mpr34	.macro
  169                        			lda	<_bp_bank
  170                        			tam3
  171                        			inc	a
  172                        			tam4
  173                        			lda.l	<_bp
  174                        			ldy.h	<_bp
  175                        			.endm
  176                        	
  177                        	
  178                        	
  179                        	; ***************************************************************************
  180                        	; ***************************************************************************
  181                        	;
  182                        	; unsigned char __fastcall __macro ac_exists( void );
  183                        	
  184                        	_ac_exists	.macro
  185                        			cla
  186                        			ldy	ACD_FLAG
  187                        			cpy	#ACD_ID
  188                        			bne	!+
  189                        			inc	a
  190                        	!:		cly
  191                        			.endm
  192                        	
  193                        	
  194                        	
  195                        	; ***************************************************************************
  196                        	; ***************************************************************************
  197                        	;
  198                        	; unsigned char __fastcall __macro _sgx_detect( void );
  199                        	
  200                        	_sgx_detect	.macro
  201                        			lda	sgx_detected
  202                        			cly
  203                        			.endm
  204                        	
  205                        	
  206                        	
  207                        	; ***************************************************************************
  208                        	; ***************************************************************************
  209                        	;
  210                        	; unsigned int __fastcall __macro peek( unsigned int addr<__ptr> );
  211                        	
  212                        	_peek.1		.macro
  213                        			lda	[__ptr]
  214                        			cly
  215                        			.endm
  216                        	
  217                        	
  218                        	
  219                        	; ***************************************************************************
  220                        	; ***************************************************************************
  221                        	;
  222                        	; unsigned int __fastcall __macro peekw( unsigned int addr<__ptr> );
  223                        	
  224                        	_peekw.1	.macro
  225                        			lda	[__ptr]
  226                        			pha
  227                        			ldy	#1
  228                        			lda	[__ptr], y
  229                        			tay
  230                        			pla
  231                        			.endm
  232                        	
  233                        	
  234                        	
  235                        	; ***************************************************************************
  236                        	; ***************************************************************************
  237                        	;
  238                        	; void __fastcall __macro poke( unsigned int addr<__poke>, unsigned char with<acc> );
  239                        	;
  240                        	; N.B. Because the <acc> value can be a complex C calculation, it isn't safe
  241                        	; to use __ptr as the destination, which can be overwritten in C macros.
  242                        	
  243                        	_poke.2		.macro
  244                        			sta	[__poke]
  245                        			.endm
  246                        	
  247                        	
  248                        	
  249                        	; ***************************************************************************
  250                        	; ***************************************************************************
  251                        	;
  252                        	; void __fastcall __macro pokew( unsigned int addr<__poke>, unsigned int with<acc> );
  253                        	;
  254                        	; N.B. Because the <acc> value can be a complex C calculation, it isn't safe
  255                        	; to use __ptr as the destination, which can be overwritten in C macros.
  256                        	
  257                        	_pokew.2	.macro
  258                        			sta	[__poke]
  259                        			tya
  260                        			ldy	#1
  261                        			sta	[__poke], y
  262                        			.endm
  263                        	
  264                        	
  265                        	
  266                        	; ***************************************************************************
  267                        	; ***************************************************************************
  268                        	;
  269                        	; unsigned char __fastcall __macro clock_hh( void );
  270                        	
  271                        	_clock_hh	.macro
  272                        			lda	clock_hh
  273                        			cly
  274                        			.endm
  275                        	
  276                        	
  277                        	
  278                        	; ***************************************************************************
  279                        	; ***************************************************************************
  280                        	;
  281                        	; unsigned char __fastcall __macro clock_mm( void );
  282                        	
  283                        	_clock_mm	.macro
  284                        			lda	clock_mm
  285                        			cly
  286                        			.endm
  287                        	
  288                        	
  289                        	
  290                        	; ***************************************************************************
  291                        	; ***************************************************************************
  292                        	;
  293                        	; unsigned char __fastcall __macro clock_ss( void );
  294                        	
  295                        	_clock_ss	.macro
  296                        			lda	clock_ss
  297                        			cly
  298                        			.endm
  299                        	
  300                        	
  301                        	
  302                        	; ***************************************************************************
  303                        	; ***************************************************************************
  304                        	;
  305                        	; unsigned char __fastcall __macro clock_tt( void );
  306                        	
  307                        	_clock_tt	.macro
  308                        			lda	clock_tt
  309                        			cly
  310                        			.endm
  311                        	
  312                        	
  313                        	
  314                        	; ***************************************************************************
  315                        	; ***************************************************************************
  316                        	;
  317                        	; void __fastcall __macro clock_reset( void );
  318                        	
  319                        	_clock_reset	.macro
  320                        			stz	clock_hh
  321                        			stz	clock_mm
  322                        			stz	clock_ss
  323                        			stz	clock_tt
  324                        			.endm
  325                        	
  326                        	
  327                        	
  328                        	; ***************************************************************************
  329                        	; ***************************************************************************
  330                        	;
  331                        	; unsigned int __fastcall __macro joy( unsigned char which<acc> );
  332                        	
  333                        	_joy.1		.macro
  334                        			tax
  335                        			lda	joynow, x
  336                        		.if	SUPPORT_6BUTTON
  337                        			ldy	joy6now, x
  338                        		.else
  339                        			cly
  340                        		.endif
  341                        			.endm
  342                        	
  343                        	
  344                        	
  345                        	; ***************************************************************************
  346                        	; ***************************************************************************
  347                        	;
  348                        	; unsigned int __fastcall __macro joytrg( unsigned char which<acc> );
  349                        	
  350                        	_joytrg.1	.macro
  351                        			tax
  352                        			lda	joytrg, x
  353                        		.if	SUPPORT_6BUTTON
  354                        			ldy	joy6trg, x
  355                        		.else
  356                        			cly
  357                        		.endif
  358                        			.endm
  359                        	
  360                        	
  361                        	
  362                        	; ***************************************************************************
  363                        	; ***************************************************************************
  364                        	;
  365                        	; unsigned int __fastcall __macro joybuf( unsigned char which<acc> );
  366                        	
  367                        	_joybuf.1	.macro
  368                        		.if	HUC_JOY_EVENTS
  369                        			tax
  370                        			lda	joybuf, x
  371                        		.if	SUPPORT_6BUTTON
  372                        			ldy	joy6buf, x
  373                        		.else
  374                        			cly
  375                        		.endif
  376                        		.else
  377                        			.fail	You must enable HUC_JOY_EVENTS in your hucc-config.inc!
  378                        		.endif
  379                        			.endm
  380                        	
  381                        	
  382                        	
  383                        	; ***************************************************************************
  384                        	; ***************************************************************************
  385                        	;
  386                        	; unsigned int __fastcall __macro get_joy_events( unsigned char which<acc> );
  387                        	;
  388                        	; N.B. This is just a version of joybuf() that clears the accumulated events.
  389                        	
  390                        			.macro	_get_joy_events.1
  391                        		.if	HUC_JOY_EVENTS
  392                        			tax
  393                        			lda	joybuf, x
  394                        			stz	joybuf, x
  395                        		.if	SUPPORT_6BUTTON
  396                        			ldy	joy6buf, x
  397                        			stz	joy6buf, x
  398                        		.else
  399                        			cly
  400                        		.endif
  401                        		.else
  402                        		.if	ACCUMULATE_JOY
  403                        			tax
  404                        			lda	joytrg, x
  405                        			stz	joytrg, x
  406                        		.if	SUPPORT_6BUTTON
  407                        			ldy	joy6trg, x
  408                        			stz	joy6trg, x
  409                        		.else
  410                        			cly
  411                        		.endif
  412                        		.else
  413                        			.fail	You must enable HUC_JOY_EVENTS or ACCUMULATE_JOY in your hucc-config.inc!
  414                        		.endif
  415                        		.endif
  416                        			.endm
  417                        	
  418                        	
  419                        	
  420                        	; ***************************************************************************
  421                        	; ***************************************************************************
  422                        	;
  423                        	; void __fastcall __macro clear_joy_events( unsigned char mask<acc> );
  424                        	
  425                        			.macro	_clear_joy_events.1
  426                        			php
  427                        			sei
  428                        			and	#(1 << MAX_PADS) - 1
  429                        			ldx	#$FF
  430                        	.loop:		inx
  431                        			lsr	a
  432                        			bcc	.next
  433                        		.if	HUC_JOY_EVENTS
  434                        			stz	joybuf, x
  435                        		.if	SUPPORT_6BUTTON
  436                        			stz	joy6buf, x
  437                        		.endif
  438                        		.else
  439                        		.if	ACCUMULATE_JOY
  440                        			stz	joytrg, x
  441                        		.if	SUPPORT_6BUTTON
  442                        			stz	joy6trg, x
  443                        		.endif
  444                        		.else
  445                        			.fail	You must enable HUC_JOY_EVENTS or ACCUMULATE_JOY in your hucc-config.inc!
  446                        		.endif
  447                        		.endif
  448                        	.next:		bne	.loop
  449                        			plp
  450                        			.endm
  451                        	
  452                        	
  453                        	
  454                        	; ***************************************************************************
  455                        	; ***************************************************************************
  456                        	;
  457                        	; void __fastcall srand( unsigned char seed<acc> );
  458                        	
  459               0001     		.ifndef	HUCC_NO_DEFAULT_RANDOM
  460                        	_srand.1	.macro
  461                        			tay
  462                        			jsr	init_random
  463                        			.endm
  464                        		.endif
  465                        	
  466                        	
  467                        	
  468                        	; ***************************************************************************
  469                        	; ***************************************************************************
  470                        	;
  471                        	; unsigned int __fastcall rand( void );
  472                        	; unsigned char __fastcall rand8( void );
  473                        	
  474               0001     		.ifndef	HUCC_NO_DEFAULT_RANDOM
  475    00:E2A9  20 C3 E5   	_rand:		jsr	get_random		; Random in A, preserve Y.
  476    00:E2AC  A8         			tay
  477    00:E2AD  4C C3 E5   			jmp	get_random		; Random in A, preserve Y.
  478                        		.endif
  479                        	
  480                        	
  481                        	
  482                        	; ***************************************************************************
  483                        	; ***************************************************************************
  484                        	;
  485                        	; unsigned char __fastcall random8( unsigned char limit<acc> );
  486                        	;
  487                        	; IN :	A = range (0..255)
  488                        	; OUT : A = random number interval 0 <= x < A
  489                        	
  490               0001     		.ifndef	HUCC_NO_DEFAULT_RANDOM
  491                        	
  492    00:E2B0  A8         	_random8.1:	tay				; Preserve the limit.
  493    00:E2B1  20 C3 E5   			jsr	get_random		; Random in A, preserve Y.
  494                        	
  495    00:E2B4  20 F0 E4   			jsr	__muluchar
  496    00:E2B7  98         			tya				; Do a 8.0 x 0.8 fixed point
  497    00:E2B8  C2         			cly				; fractional multiply.
  498    00:E2B9  60         			rts
  499                        		.endif
  500                        	
  501                        	
  502                        	
  503                        	; ***************************************************************************
  504                        	; ***************************************************************************
  505                        	;
  506                        	; unsigned char __fastcall random( unsigned char limit<acc> );
  507                        	;
  508                        	; IN :	A = range (0..128), 129..255 is treated as 128
  509                        	; OUT : A = random number interval 0 <= x < A
  510                        	
  511               0001     		.ifndef	HUCC_NO_DEFAULT_RANDOM
  512                        	
  513    00:E2BA  A8         	_random.1:	tay				; Preserve the limit.
  514    00:E2BB  20 C3 E5   			jsr	get_random		; Random in A, preserve Y.
  515                        	
  516    00:E2BE  C0 80      			cpy	#128			; Check the limit.
  517    00:E2C0  90 04      			bcc	!+
  518                        	
  519    00:E2C2  29 7F      			and	#$7F			; Just mask the random if
  520    00:E2C4  C2         			cly				; the limit is >= 128.
  521    00:E2C5  60         			rts
  522                        	
  523    00:E2C6  20 F0 E4   	!:		jsr	__muluchar
  524    00:E2C9  98         			tya				; If the limit is < 128 then
  525    00:E2CA  C2         			cly				; do a 8.0 x 0.8 fixed point
  526    00:E2CB  60         			rts				; fractional multiply.
  527                        		.endif
  528                        	
  529                        	
  530                        	
  531                        	; ***************************************************************************
  532                        	; ***************************************************************************
  533                        	;
  534                        	; unsigned char __fastcall __builtin_ffs( unsigned int value<__temp> );
  535                        	
  536                        			.proc	___builtin_ffs.1
  556                        			.endp
  557                        	
  558                        	
  559                        	
  560                        	; ***************************************************************************
  561                        	; ***************************************************************************
  562                        	;
  563                        	; N.B. Declared in hucc-string.h, but defined here because they're macros!
  564                        	;
  565                        	; int __fastcall __macro memcmp( unsigned char *destination<_di>, unsigned char *source<_bp>, unsigned int count<acc> );
  566                        	
  567                        	_memcmp.3	.macro
  568                        			stz	<_bp_bank		; Map the source string.
  569                        			call	_farmemcmp.3
  570                        			.endm
  571                        	
  572                        	
  573                        	
  574                        	; ***************************************************************************
  575                        	; ***************************************************************************
  576                        	;
  577                        	; N.B. Declared in hucc-gfx.h, but defined here because they're macros!
  578                        	;
  579                        	; void __fastcall __macro get_color( unsigned int index<VCE_CTA> );
  580                        	
  581                        	_get_color.1	.macro
  582                        			lda.l	VCE_CTR
  583                        			ldy.h	VCE_CTR
  584                        			.endm
  585                        	
  586                        	
  587                        	
  588                        	; ***************************************************************************
  589                        	; ***************************************************************************
  590                        	;
  591                        	; N.B. Declared in hucc-gfx.h, but defined here because they're macros!
  592                        	;
  593                        	; void __fastcall __macro fade_to_black( unsigned int __far *from<_bp_bank:_bp>, unsigned int *destination<_di>, unsigned char num_colors<_al>, unsigned char value_to_sub<_ah> );
  594                        	; void __fastcall __macro fade_to_white( unsigned int __far *from<_bp_bank:_bp>, unsigned int *destination<_di>, unsigned char num_colors<_al>, unsigned char value_to_add<_ah> );
  595                        	; void __fastcall __macro cross_fade_to( unsigned int __far *from<_bp_bank:_bp>, unsigned int *destination<_di>, unsigned char num_colors<_al>, unsigned char which_component<_ah );
  596                        	;
  597                        	; void __fastcall __macro far_fade_to_black( unsigned int *destination<_di>, unsigned char num_colors<_al>, unsigned char value_to_sub<_ah> );
  598                        	; void __fastcall __macro far_fade_to_white( unsigned int *destination<_di>, unsigned char num_colors<_al>, unsigned char value_to_add<_ah> );
  599                        	; void __fastcall __macro far_cross_fade_to( unsigned int *destination<_di>, unsigned char num_colors<_al>, unsigned char which_component<_ah );
  600                        	
  601                        			.macro	_fade_to_black.4
  602                        			ldy	<_bp_bank
  603                        			call	fade_to_black
  604                        			.endm
  605                        	
  606                        			.macro	_fade_to_white.4
  607                        			ldy	<_bp_bank
  608                        			call	fade_to_white
  609                        			.endm
  610                        	
  611                        			.macro	_cross_fade_to.4
  612                        			ldy	<_bp_bank
  613                        			call	cross_fade_to
  614                        			.endm
  615                        	
  616                        			.macro	_far_fade_to_black.3
  617                        			ldy	<_bp_bank
  618                        			call	fade_to_black
  619                        			.endm
  620                        	
  621                        			.macro	_far_fade_to_white.3
  622                        			ldy	<_bp_bank
  623                        			call	fade_to_white
  624                        			.endm
  625                        	
  626                        			.macro	_far_cross_fade_to.3
  627                        			ldy	<_bp_bank
  628                        			call	cross_fade_to
  629                        			.endm
  630                        	
  631                        	
  632                        	
  633                        	; ***************************************************************************
  634                        	; ***************************************************************************
  635                        	;
  636                        	; N.B. Declared in hucc-gfx.h, but defined here because they're macros!
  637                        	;
  638                        	; void __fastcall __macro set_xres( unsigned int x_pixels<_ax> );
  639                        	; void __fastcall __macro sgx_set_xres( unsigned int x_pixels<_ax> );
  640                        	;
  641                        	; void __fastcall set_xres( unsigned int x_pixels<_ax>, unsigned char blur_flag<_bl> );
  642                        	; void __fastcall sgx_set_xres( unsigned int x_pixels<_ax>, unsigned char blur_flag<_bl> );
  643                        	
  644                        	_set_xres.1	.macro
  645                        			lda	#XRES_SOFT
  646                        			sta	<_bl
  647                        			call	_set_xres.2
  648                        			.endm
  649                        	
  650               0001     		.if	SUPPORT_SGX
  651                        			.macro	_sgx_set_xres.1
  652                        			lda	#XRES_SOFT
  653                        			sta	<_bl
  654                        			call	_sgx_set_xres.2
  655                        			.endm
  656                        		.endif
  657                        	
  658                        	
  659                        	
  660                        	; ***************************************************************************
  661                        	; ***************************************************************************
  662                        	;
  663                        	; N.B. Declared in hucc-gfx.h, but defined here because they're macros!
  664                        	;
  665                        	; unsigned int __fastcall __macro vram_addr( unsigned char bat_x<_al>, unsigned char bat_y<_ah> );
  666                        	; unsigned int __fastcall __macro sgx_vram_addr( unsigned char bat_x<_al>, unsigned char bat_y<_ah> );
  667                        	
  668                        			.macro	_vram_addr.2
  669                        			cla
  670                        			bit	vdc_bat_width
  671                        			bmi	!w128+
  672                        			bvs	!w64+
  673                        	!w32:		lsr	<_ah
  674                        			ror	a
  675                        	!w64:		lsr	<_ah
  676                        			ror	a
  677                        	!w128:		lsr	<_ah
  678                        			ror	a
  679                        			ora	<_al
  680                        			ldy	<_ah
  681                        			.endm
  682                        	
  683               0001     		.if	SUPPORT_SGX
  684                        			.macro	_sgx_vram_addr.2
  685                        			cla
  686                        			bit	sgx_bat_width
  687                        			bmi	!w128+
  688                        			bvs	!w64+
  689                        	!w32:		lsr	<_ah
  690                        			ror	a
  691                        	!w64:		lsr	<_ah
  692                        			ror	a
  693                        	!w128:		lsr	<_ah
  694                        			ror	a
  695                        			ora	<_al
  696                        			ldy	<_ah
  697                        			.endm
  698                        		.endif
  699                        	
  700                        	
  701                        	
  702                        	; ***************************************************************************
  703                        	; ***************************************************************************
  704                        	;
  705                        	; N.B. Declared in hucc-gfx.h, but defined here because they're macros!
  706                        	;
  707                        	; unsigned int __fastcall __macro get_vram( unsigned int address<_di> );
  708                        	; void __fastcall __macro put_vram( unsigned int address<_di>, unsigned int data<acc> );
  709                        	;
  710                        	; unsigned int __fastcall __macro sgx_get_vram( unsigned int address<_di> );
  711                        	; void __fastcall __macro sgx_put_vram( unsigned int address<_di>, unsigned int data<acc> );
  712                        	
  713                        			.macro	_get_vram.1
  714                        			jsr	vdc_di_to_marr
  715                        			lda	VDC_DL
  716                        			ldy	VDC_DH
  717                        			.endm
  718                        	
  719                        			.macro	_put_vram.2
  720                        			pha
  721                        			jsr	vdc_di_to_mawr
  722                        			pla
  723                        			sta	VDC_DL
  724                        			sty	VDC_DH
  725                        			.endm
  726                        	
  727               0001     		.if	SUPPORT_SGX
  728                        			.macro	_sgx_get_vram.1
  729                        			jsr	sgx_di_to_marr
  730                        			lda	SGX_DL
  731                        			ldy	SGX_DH
  732                        			.endm
  733                        	
  734                        			.macro	_sgx_put_vram.2
  735                        			pha
  736                        			jsr	sgx_di_to_mawr
  737                        			pla
  738                        			sta	SGX_DL
  739                        			sty	SGX_DH
  740                        			.endm
  741                        		.endif
  742                        	
  743                        	
  744                        	
  745                        	; ***************************************************************************
  746                        	; ***************************************************************************
  747                        	;
  748                        	; N.B. Declared in hucc-gfx.h, but defined here because they're macros!
  749                        	;
  750                        	; void __fastcall __macro set_bgpal( unsigned char palette<_al>, unsigned char __far *data<_bp_bank:_bp> );
  751                        	; void __fastcall __macro set_bgpal( unsigned char palette<_al>, unsigned char __far *data<_bp_bank:_bp>, unsigned int num_palettes<_ah> );
  752                        	; void __fastcall __macro set_sprpal( unsigned char palette<_al>, unsigned char __far *data<_bp_bank:_bp> );
  753                        	; void __fastcall __macro set_sprpal( unsigned char palette<_al>, unsigned char __far *data<_bp_bank:_bp>, unsigned int num_palettes<_ah> );
  754                        	
  755                        	_set_bgpal.2	.macro
  756                        			lda	#1
  757                        			sta	<_ah
  758                        			call	_load_palette.3
  759                        			.endm
  760                        	
  761                        	_set_bgpal.3	.macro
  762                        			call	_load_palette.3
  763                        			.endm
  764                        	
  765                        	_set_sprpal.2	.macro
  766                        			lda	#1
  767                        			sta	<_ah
  768                        			smb4	<_al
  769                        			call	_load_palette.3
  770                        			.endm
  771                        	
  772                        	_set_sprpal.3	.macro
  773                        			smb4	<_al
  774                        			call	_load_palette.3
  775                        			.endm
  776                        	
  777                        	
  778                        	
  779                        	; ***************************************************************************
  780                        	; ***************************************************************************
  781                        	;
  782                        	; N.B. Declared in hucc-gfx.h, but defined here because they're macros!
  783                        	;
  784                        	; void __fastcall __macro load_vram( unsigned int vram<_di>, unsigned char __far *data<_bp_bank:_bp>, unsigned int num_words<_ax> );
  785                        	; void __fastcall __macro sgx_load_vram( unsigned int vram<_di>, unsigned char __far *data<_bp_bank:_bp>, unsigned int num_words<_ax> );
  786                        	;
  787                        	; void __fastcall __macro far_load_vram( unsigned int vram<_di>, unsigned int num_words<_ax> );
  788                        	; void __fastcall __macro sgx_far_load_vram( unsigned int vram<_di>, unsigned int num_words<_ax> );
  789                        	;
  790                        	
  791               0001     		.if	SUPPORT_SGX
  792                        			.macro	_sgx_load_vram.3
  793                        			ldx	#SGX_VDC_OFFSET		; Offset to SGX VDC.
  794                        			call	load_vram_x
  795                        			.endm
  796                        	
  797                        			.macro	_sgx_far_load_vram.2
  798                        			ldx	#SGX_VDC_OFFSET		; Offset to SGX VDC.
  799                        			call	load_vram_x
  800                        			.endm
  801                        		.endif
  802                        	
  803                        			.macro	_load_vram.3
  804                        			clx				; Offset to PCE VDC.
  805                        			call	load_vram_x
  806                        			.endm
  807                        	
  808                        			.macro	_far_load_vram.2
  809                        			clx				; Offset to PCE VDC.
  810                        			call	load_vram_x
  811                        			.endm
  812                        	
  813                        	
  814                        	
  815                        	; ***************************************************************************
  816                        	; ***************************************************************************
  817                        	;
  818                        	; N.B. Declared in hucc-gfx.h, but defined here because they're macros!
  819                        	;
  820                        	; void __fastcall __macro load_sprites( unsigned int vram<_di>, unsigned char __far *data<_bp_bank:_bp>, unsigned int num_groups<acc> );
  821                        	; void __fastcall __macro sgx_load_sprites( unsigned int vram<_di>, unsigned char __far *data<_bp_bank:_bp>, unsigned int num_groups<acc> );
  822                        	; void __fastcall __macro far_load_sprites( unsigned int vram<_di>, unsigned int num_groups<acc> );
  823                        	; void __fastcall __macro sgx_far_load_sprites( unsigned int vram<_di>, unsigned int num_groups<acc> );
  824                        	
  825               0001     		.if	SUPPORT_SGX
  826                        			.macro	_sgx_load_sprites.3
  827                        			stz.l	<_ax
  828                        			asl	a
  829                        			sta.h	<_ax
  830                        			ldx	#SGX_VDC_OFFSET		; Offset to SGX VDC.
  831                        			call	load_vram_x
  832                        			.endm
  833                        	
  834                        			.macro	_sgx_far_load_sprites.2
  835                        			stz.l	<_ax
  836                        			asl	a
  837                        			sta.h	<_ax
  838                        			ldx	#SGX_VDC_OFFSET		; Offset to SGX VDC.
  839                        			call	load_vram_x
  840                        			.endm
  841                        		.endif
  842                        	
  843                        			.macro	_load_sprites.3
  844                        			stz.l	<_ax
  845                        			asl	a
  846                        			sta.h	<_ax
  847                        			clx				; Offset to PCE VDC.
  848                        			call	load_vram_x
  849                        			.endm
  850                        	
  851                        			.macro	_far_load_sprites.2
  852                        			stz.l	<_ax
  853                        			asl	a
  854                        			sta.h	<_ax
  855                        			clx				; Offset to PCE VDC.
  856                        			call	load_vram_x
  857                        			.endm
  858                        	
  859                        	
  860                        	
  861                        	; ***************************************************************************
  862                        	; ***************************************************************************
  863                        	;
  864                        	; N.B. Declared in hucc-gfx.h, but defined here because they're macros!
  865                        	;
  866                        	; void __fastcall load_default_font( void );
  867                        	; void __fastcall sgx_load_default_font( void );
  868                        	;
  869                        	
  870               0001     		.if	SUPPORT_SGX
  871                        			.macro	_sgx_load_default_font
  872                        			ldx	#SGX_VDC_OFFSET		; Offset to SGX VDC.
  873                        			call	huc_monofont_x
  874                        			.endm
  875                        		.endif
  876                        	
  877                        			.macro	_load_default_font
  878                        			clx				; Offset to PCE VDC.
  879                        			call	huc_monofont_x
  880                        			.endm
  881                        	
  882                        	
  883                        	
  884                        	; ***************************************************************************
  885                        	; ***************************************************************************
  886                        	
  887               0000     		.if	0
  905                        		.endif
                             #[2]   "..\..\..\include\hucc\hucc.asm"
  228                        	
  229               0000     		.if	CDROM
  231                        		.endif
  232                        	
  233                        			; Definitions for compatibility with old HuC/MagicKit projects.
  234                        	
  235               0001     		.ifndef	HUCC_NO_DEPRECATED
                             #[3]   "..\..\..\include\hucc\hucc-deprecated.inc"
  236                        			include	"hucc-deprecated.inc"
    1                        	; ***************************************************************************
    2                        	; ***************************************************************************
    3                        	;
    4                        	; hucc-deprecated.inc
    5                        	;
    6                        	; Macros and definitions for compatibility with old HuC/MagicKit projects.
    7                        	;
    8                        	; Based on the original HuC and MagicKit definitions by David Michel and the
    9                        	; other original HuC developers.
   10                        	;
   11                        	; ***************************************************************************
   12                        	; ***************************************************************************
   13                        	
   14                        			; For compatibility with HuC projects that use the old name.
   15                        	
   16               0001     	HUC_USER_RESERVED = HUC_USER_BANK
   17                        	
   18                        			; For compatibility with code that expects the HuC naming that
   19                        			; is used in the newer HuC, rather than the original HuC v3.21.
   20                        			;
   21                        			; Code generated by HuCC uses the original single-underscore.
   22                        	
   23               0001     		.if	1				
   24               0002     	__bp		=	$F8:20EC, 2		; base pointer
   25               0002     	__si		=	$F8:20EE, 2		; source address
   26               0002     	__di		=	$F8:20F0, 2		; destination address
   27                        	
   28               0002     	__ax		=	$F8:20F8, 2
   29               0001     	__al		=	$F8:20F8, 1
   30               0001     	__ah		=	$F8:20F9, 1
   31                        	
   32               0002     	__bx		=	$F8:20FA, 2
   33               0001     	__bl		=	$F8:20FA, 1
   34               0001     	__bh		=	$F8:20FB, 1
   35                        	
   36               0002     	__cx		=	$F8:20FC, 2
   37               0001     	__cl		=	$F8:20FC, 1
   38               0001     	__ch		=	$F8:20FD, 1
   39                        	
   40               0002     	__dx		=	$F8:20FE, 2
   41               0001     	__dl		=	$F8:20FE, 1
   42               0001     	__dh		=	$F8:20FF, 1
   43                        		.endif
   44                        	
   45                        			; For compatibility with code that expects the HuC naming that
   46                        			; is used rather than the shorter upper-case #define naming.
   47                        	
   48               0001     		.if	1				
   49               0001     	video_reg	=	$FF:0200, 1		; Address/Status Register
   50               0001     	video_reg_l	=	$FF:0200, 1		; Address/Status Register
   51               0001     	video_reg_h	=	$FF:0201, 1		; Address/Status Register
   52               0002     	video_data	=	$FF:0202, 2		; Data (Read/Write) Low
   53               0001     	video_data_l	=	$FF:0202, 1		; Data (Read/Write) Low
   54               0001     	video_data_h	=	$FF:0203, 1		; Data (Read/Write) High
   55                        	
   56               0002     	color_ctrl	=	$FF:0400, 2		; Control Register
   57               0002     	color_reg	=	$FF:0402, 2		; Color Table Address
   58               0001     	color_reg_l	=	$FF:0402, 1		; Color Table Address
   59               0001     	color_reg_h	=	$FF:0402, 1		; Color Table Address
   60               0002     	color_data	=	$FF:0404, 2		; Color Table Data Read/Write
   61               0001     	color_data_l	=	$FF:0404, 1		; Color Table Data Read/Write
   62               0001     	color_data_h	=	$FF:0405, 1		; Color Table Data Read/Write
   63                        	
   64               0001     	psg_ch		=	$FF:0800, 1		; Channel Select
   65               0001     	psg_mainvol	=	$FF:0801, 1		; Main Amplitude Level
   66               0001     	psg_freqlo	=	$FF:0802, 1		; Frequency Low
   67               0001     	psg_freqhi	=	$FF:0803, 1		; Frequency High
   68               0001     	psg_ctrl	=	$FF:0804, 1		; Control & Channel Amplitude
   69               0001     	psg_pan		=	$FF:0805, 1		; L/R Amplitude Level
   70               0001     	psg_wavebuf	=	$FF:0806, 1		; Waveform
   71               0001     	psg_noise	=	$FF:0807, 1		; Noise
   72               0001     	psg_lfofreq	=	$FF:0808, 1		; LFO Frequency
   73               0001     	psg_lfoctrl	=	$FF:0809, 1		; LFO Control
   74                        	
   75               0001     	irq_m		=	irq_vec, 1		; Old System Card name.
   76               0002     	irq2_jmp	=	irq2_hook, 2		; Old System Card name.
   77               0002     	irq1_jmp	=	irq1_hook, 2		; Old System Card name.
   78               0002     	timer_jmp	=	timer_hook, 2		; Old System Card name.
   79               0002     	nmi_jmp		=	nmi_hook, 2		; Old System Card name.
   80               0002     	sat_adr		=	satb_addr, 2		; Old System Card name.
   81               0005     	joy		=	joynow, 5		; Old System Card name.
   82               0001     	mwr_m		=	vdc_mwr, 1		; Old System Card name.
   83               0001     	dcr_m		=	vdc_dcr, 1		; Old System Card name.
   84                        		.endif
   85                        	
   86                        			; Macros for compatibility with #asm usage in old HuC projects.
   87                        	
   88                        	stw		.macro
   89                        			lda.l	\1
   90                        			sta.l	\2
   91                        			lda.h	\1
   92                        			sta.h	\2
   93                        			.endm
   94                        	
   95                        	stb		.macro
   96                        			lda	\1
   97                        			sta	\2
   98                        			.endm
   99                        	
  100                        	addw		.macro
  101                        		.if	(\# = 3)
  102                        			clc
  103                        			lda.l	\2
  104                        			adc.l	\1
  105                        			sta.l	\3
  106                        			lda.h	\2
  107                        			adc.h	\1
  108                        			sta.h	\3
  109                        		.else
  110                        			clc
  111                        			lda.l	\2
  112                        			adc.l	\1
  113                        			sta.l	\2
  114                        			lda.h	\2
  115                        			adc.h	\1
  116                        			sta.h	\2
  117                        		.endif
  118                        			.endm
  119                        	
  120                        	add		.macro			; add byte-sized value to
  121                        		.if (\# = 2)			; register A (handle carry
  122                        			lda	\2		; flag)
  123                        			clc
  124                        			adc	\1
  125                        			sta	\2
  126                        		.else
  127                        			clc
  128                        			adc	\1
  129                        		.endif
  130                        			.endm
  131                        	
  132                        	subw		.macro
  133                        			sec
  134                        			lda.l	\2
  135                        			sbc.l	\1
  136                        			sta.l	\2
  137                        			lda.h	\2
  138                        			sbc.h	\1
  139                        			sta.h	\2
  140                        			.endm
  141                        	
  142                        	sub		.macro			; subtract byte-sized value
  143                        		.if (\# = 2)			; from register A (handle
  144                        			lda	\2		; carry flag)
  145                        			sec
  146                        			sbc	\1
  147                        			sta	\2
  148                        		.else
  149                        			sec
  150                        			sbc	\1
  151                        		.endif
  152                        			.endm
  153                        	
  154                        	incw		.macro			; increment a word-sized
  155                        			inc.l	\1		; value at stated memory
  156                        			bne	!+		; location
  157                        			inc.h	\1
  158                        	!:
  159                        			.endm
  160                        	
  161                        	decw		.macro			; decrement a word-sized
  162                        			lda	\1		; value at stated memory
  163                        			bne	!+		; location
  164                        			dec.h	\1
  165                        	!:		dec.l	\1
  166                        			.endm
  167                        	
  168                        	lbne		.macro
  169                        			bne	\1
  170                        			.endm
  171                        	
  172                        	lbeq		.macro
  173                        			beq	\1
  174                        			.endm
  175                        	
  176                        	lbpl		.macro
  177                        			bpl	\1
  178                        			.endm
  179                        	
  180                        	lbmi		.macro
  181                        			bmi	\1
  182                        			.endm
  183                        	
  184                        	lbcc		.macro
  185                        			bcc	\1
  186                        			.endm
  187                        	
  188                        	lbcs		.macro
  189                        			bcs	\1
  190                        			.endm
  191                        	
  192                        	lblo		.macro
  193                        			bcc	\1
  194                        			.endm
  195                        	
  196                        	lbhs		.macro
  197                        			bcs	\1
  198                        			.endm
  199                        	
  200                        	__ldwi		.macro
  201                        		__ld.wi		\1
  202                        			.endm
                             #[2]   "..\..\..\include\hucc\hucc.asm"
  237                        		.endif
  238                        	
  239                        			;
  240                        			;
  241                        			;
  242                        	
  243                        	
  244                        	
  245                        	; ***************************************************************************
  246                        	; ***************************************************************************
  247                        	;
  248                        	; core_main - This is executed after "CORE(not TM)" library initialization.
  249                        	;
  250                        	; This is the first code assembled after the library includes, so we're still
  251                        	; in the CORE_BANK, usually ".bank 0"; and because this is assembled with the
  252                        	; default configuration from "include/core-config.inc", which sets the option
  253                        	; "USING_MPR7", then we're running in MPR7 ($E000-$FFFF).
  254                        	
  255    11:CF97             	core_main	.proc
  256                        	
  257               0001     		.if	SUPPORT_SGX
  258    11:CF97  A9 F9      			lda	#$F9			; Map the 2nd SGX RAM bank.
  259                        		.else
  261                        		.endif
  262    11:CF99  53 04      			tam2
  263                        	
  264    11:CF9B  A9 01      			lda	#CONST_BANK + _bank_base; Map HuCC's .RODATA bank.
  265    11:CF9D  53 08      			tam3
  266    11:CF9F  1A         			inc	a
  267    11:CFA0  53 10      			tam4
  268                        	
  269               0000     		.ifdef	HOME_BANK
  271                        		.else
  272    11:CFA2  1A         			inc	a
  273                        		.endif
  274    11:CFA3  53 20      			tam5
  275                        	
  276    11:CFA5  08         			php				; Disable interrupts while
  277    11:CFA6  78         			sei				; clearing overlay's BSS.
  278                        	
  279               0000     		.ifndef	USING_RCR_MACROS
  294                        		.endif	USING_RCR_MACROS
  295                        	
  296    11:CFA7  A9 CC      			lda	#<hucc_vbl		; Setup HuCC's VBL IRQ handler.
  297    11:CFA9  8D 08 22   			sta.l	vsync_hook
  298    11:CFAC  A9 E2      			lda	#>hucc_vbl
  299    11:CFAE  8D 09 22   			sta.h	vsync_hook
  300                        	
  301               0000     		.if	CDROM				; Overlays should clear BSS.
  303                        		.else
  304    11:CFB1  73 FE CF F0			tii	.rom_tia, ram_tia, 16	; Only needed on HuCARD.
         11:CFB5  22 10 00    
  305                        		.endif	CDROM
  306                        	
  307               0000     		.if	(__heap_start - __bss_init)	; Copy initialized BSS data.
  309                        		.endif
  310                        	
  311    11:CFB8  F3 FC CF 08			tai	.stack_fill, __stack, HUCC_STACK_SZ
         11:CFBC  20 80 00    
  312                        	
  313               0000     		.if	FAST_MULTIPLY
  322                        		.endif
  323                        	
  324    11:CFBF  A9 10      			lda	#$10			; Enable HuCC's vblank IRQ
  325    11:CFC1  04 F5      			tsb	<irq_vec		; handler.
  326                        	
  327                        			__sound_init			; Initialize a sound driver.
  328                        	
  329    11:CFC3  AD 00 02   			lda	VDC_SR			; Purge any overdue VBL.
  330    11:CFC6  9C 41 22   			stz	irq_cnt			; Make it easy to check.
  331                        	
  332    11:CFC9  28         			plp				; Restore interrupts.
  333                        	
  334               0001     		.ifndef	HUCC_NO_DEFAULT_SCREEN
  335    11:CFCA  20 D1 FF   			call	_init_256x224		; HuCC initializes the VDC and
  336    11:CFCD  20 16 E4   			jsr	set_dspon		; turns the display on.
  337                        		.endif
  338                        	
  339               0001     		.ifndef	HUCC_NO_DEFAULT_FONT
  340    11:CFD0  A9 01      			lda	#1			; HuCC loads a default font.
  341    11:CFD2  8D A6 26   			sta	monofont_fg
  342    11:CFD5  9C A7 26   			stz	monofont_bg
  343                        			_load_default_font
         11:CFD8  82         			clx				; Offset to PCE VDC.
         11:CFD9  20 C7 FF   			call	huc_monofont_x
  344    11:CFDC  A9 01      			lda	#$01			; Set the font palette entry to
  345    11:CFDE  8D 02 04   			sta.l	VCE_CTA			; cyan which is a) visible, but
  346    11:CFE1  9C 03 04   			stz.h	VCE_CTA			; b) a clear indicator that the
  347    11:CFE4  A0 96      			ldy	#$96			; user hasn't set a palette yet.
  348    11:CFE6  8C 04 04   			sty.l	VCE_CTW
  349    11:CFE9  8D 05 04   			sta.h	VCE_CTW
  350                        		.endif
  351                        	
  352               0001     		.ifndef	HUCC_NO_DEFAULT_RANDOM
  353    11:CFEC  AC 41 22   			ldy	irq_cnt			; Initialize random seed.
  354    11:CFEF  20 BD FF   			call	init_random
  355                        		.endif
  356                        	
  357    11:CFF2  A2 80      			ldx	#HUCC_STACK_SZ		; Initialize the HuCC stack.
  358    11:CFF4  86 8D      			stx	<__sp
  359                        	
  360    11:CFF6  20 B3 FF   			call	_main			; Execute the HuCC program.
  361                        	
  362    11:CFF9  4C 88 E2   			jmp	_exit.1			; Pass the exit code on.
  363                        	
  364    11:CFFC  EA EA      	.stack_fill:	db	$EA,$EA			; To make it easier to see.
  365                        	
  366               0001     		.if	!CDROM
  367                        	
  368    11:CFFE  E3 34 12 02	.rom_tia:	tia	$1234, VDC_DL, 32
         11:D002  02 20 00    
  369    11:D005  60         			rts
  370                        	
  371    11:D006  73 34 12 78	.rom_tii:	tii	$1234, $5678, $9ABC
         11:D00A  56 BC 9A    
  372    11:D00D  60         			rts
  373                        	
  374               22F0     			.bss
  375    F8:22F0             	ram_tia:	ds	8
  376    F8:22F8             	ram_tii:	ds	8
  377               D00E     			.code
  378                        	
  379                        		.endif	!CDROM
  380                        	
  381                        			.endp
  382                        	
  383                        			;
  384                        			; Self-Modifying TIA and TII instruction subroutines.
  385                        			;
  386                        			; These need to be in permanently-accessible memory so that
  387                        			; HuCC code can modify the values as __fastcall parameters.
  388                        			;
  389                        	
  390               0000     		.if	CDROM
  398                        		.endif	CDROM
  399                        	
  400               22F0     			rsset	ram_tia
  401               22F0     	ram_tia_opc	rs	1
  402               22F1     	ram_tia_src	rs	2
  403               22F3     	ram_tia_dst	rs	2
  404               22F5     	ram_tia_len	rs	2
  405               22F7     	ram_tia_rts	rs	1
  406                        	
  407               22F8     			rsset	ram_tii
  408               22F8     	ram_tii_opc	rs	1
  409               22F9     	ram_tii_src	rs	2
  410               22FB     	ram_tii_dst	rs	2
  411               22FD     	ram_tii_len	rs	2
  412               22FF     	ram_tii_rts	rs	1
  413                        	
  414                        	
  415                        	
  416                        	; ***************************************************************************
  417                        	; ***************************************************************************
  418                        	;
  419                        	; hucc_vbl - vblank IRQ handler, called by the "CORE(not TM)" kernel.
  420                        	;
  421                        	; This uses the kernel's hook to process things during vblank. It returns
  422                        	; with a simple RTS, and it can corrupt any register.
  423                        	;
  424                        	; Any slow routines in here should enable interrupts and protect itself from
  425                        	; re-entrancy problems.
  426                        	;
  427                        	
  428    00:E2CC  20 A9 FF   	hucc_vbl:	call	vbl_init_scroll		; Prepare for the next frame.
  429                        	
  430    00:E2CF  F8         			sed				; Update the HuC system clock
  431    00:E2D0  38         			sec				; which is in BCD here rather
  432    00:E2D1  AD EF 22   			lda	clock_tt		; than the binary one in HuC.
  433    00:E2D4  69 00      			adc	#0			; BCD add ...
  434    00:E2D6  C9 60      			cmp	#$60			; ... but binary comparison.
  435    00:E2D8  90 28      			bcc	.ticks
  436    00:E2DA  AD EE 22   			lda	clock_ss
  437    00:E2DD  69 00      			adc	#0			; BCD add ...
  438    00:E2DF  C9 60      			cmp	#$60			; ... but binary comparison.
  439    00:E2E1  90 1B      			bcc	.seconds
  440    00:E2E3  AD ED 22   			lda	clock_mm
  441    00:E2E6  69 00      			adc	#0			; BCD add ...
  442    00:E2E8  C9 60      			cmp	#$60			; ... but binary comparison.
  443    00:E2EA  90 0E      			bcc	.minutes
  444    00:E2EC  AD EC 22   			lda	clock_hh
  445    00:E2EF  69 00      			adc	#0			; BCD add ...
  446    00:E2F1  C9 12      			cmp	#$12			; ... but binary comparison.
  447    00:E2F3  90 01      			bcc	.hours
  448    00:E2F5  62         			cla
  449    00:E2F6  8D EC 22   	.hours:		sta	clock_hh
  450    00:E2F9  62         			cla
  451    00:E2FA  8D ED 22   	.minutes:	sta	clock_mm
  452    00:E2FD  62         			cla
  453    00:E2FE  8D EE 22   	.seconds:	sta	clock_ss
  454    00:E301  62         			cla
  455    00:E302  8D EF 22   	.ticks:		sta	clock_tt
  456    00:E305  D8         			cld
  457                        	
  458    00:E306  4C 96 E3   			jmp	xfer_palettes		; Upload any palette changes.
                             #[1]   "main.s"
   15               6000     			.data
   16               0003     			.bank	DATA_BANK
   17                        	
   18               E309     		.code
   19                        	
   20                        		.dbg	line,	"..\..\..\include\hucc\globals.h", 1; // **************************************************************************
   21                        		.dbg	line,	"..\..\..\include\hucc\globals.h", 2; // **************************************************************************
   22                        		.dbg	line,	"..\..\..\include\hucc\globals.h", 3; //
   23                        		.dbg	line,	"..\..\..\include\hucc\globals.h", 4; // globals.h
   24                        		.dbg	line,	"..\..\..\include\hucc\globals.h", 5; //
   25                        		.dbg	line,	"..\..\..\include\hucc\globals.h", 6; // **************************************************************************
   26                        		.dbg	line,	"..\..\..\include\hucc\globals.h", 7; // **************************************************************************
   27                        		.dbg	line,	"..\..\..\include\hucc\globals.h", 8; //
   28                        		.dbg	line,	"..\..\..\include\hucc\globals.h", 9; // The idea is that you, a PCE developer, copy this file from the ../include/
   29                        		.dbg	line,	"..\..\..\include\hucc\globals.h", 10; // directory and into your project's directory, and then define the variables
   30                        		.dbg	line,	"..\..\..\include\hucc\globals.h", 11; // that you want to have shared access to in all overlay programs on your CD.
   31                        		.dbg	line,	"..\..\..\include\hucc\globals.h", 12; //
   32                        		.dbg	line,	"..\..\..\include\hucc\globals.h", 13; // Because PCEAS searches the current (i.e. project) directory for an include
   33                        		.dbg	line,	"..\..\..\include\hucc\globals.h", 14; // file first, then it will find your customized copy of the file rather than
   34                        		.dbg	line,	"..\..\..\include\hucc\globals.h", 15; // the original copy in the ../include/ directory.
   35                        		.dbg	line,	"..\..\..\include\hucc\globals.h", 16; //
   36                        		.dbg	line,	"..\..\..\include\hucc\globals.h", 17; // **************************************************************************
   37                        		.dbg	line,	"..\..\..\include\hucc\globals.h", 18; // **************************************************************************
   38                        		.dbg	clear
   39               2300     		.bss
   40    F8:2300             	huc_globals:
   41                        	
   42    F8:2300             	huc_globals_end:
   43               E309     		.code
   44                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 1; #ifndef _hucc_legacy_h
   45                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 2; #define _hucc_legacy_h
   46                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 4; /****************************************************************************
   47                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 5; ; ***************************************************************************
   48                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 6; ;
   49                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 7; ; huc.h
   50                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 8; ;
   51                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 9; ; HuCC wrapper file to include a default set of HuC-compatible functions.
   52                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 10; ;
   53                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 11; ; Copyright John Brandwood 2024.
   54                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 12; ;
   55                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 13; ; Distributed under the Boost Software License, Version 1.0.
   56                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 14; ; (See accompanying file LICENSE_1_0.txt or copy at
   57                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 15; ;  http://www.boost.org/LICENSE_1_0.txt)
   58                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 16; ;
   59                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 17; ; ***************************************************************************
   60                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 18; ; ***************************************************************************
   61                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 19; ;
   62                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 20; ; When the HuCC compiler is invoked with the "--legacy" option to compile old
   63                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 21; ; projects, then this "huc.h" file is automatically included.
   64                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 22; ;
   65                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 23; ; This file includes a set of the individual HuCC headers which correspond to
   66                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 24; ; HuC's built-in functions and MagicKit library.
   67                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 25; ;
   68                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 26; ; New HuCC projects should, preferably, include the specific headers that are
   69                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 27; ; needed, which will then allow them to replace parts of the standard library
   70                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 28; ; with newer functions, or they can just manually include this "huc.h" file.
   71                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 29; ;
   72                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 30; ; ***************************************************************************
   73                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 31; ; **************************************************************************/
   74                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 33; #include "hucc-systemcard.h"
   75                        		.dbg	line,	"..\..\..\include\hucc\hucc-systemcard.h", 1; #ifndef _hucc_systemcard_h
   76                        		.dbg	line,	"..\..\..\include\hucc\hucc-systemcard.h", 2; #define _hucc_systemcard_h
   77                        		.dbg	line,	"..\..\..\include\hucc\hucc-systemcard.h", 4; /****************************************************************************
   78                        		.dbg	line,	"..\..\..\include\hucc\hucc-systemcard.h", 5; ; ***************************************************************************
   79                        		.dbg	line,	"..\..\..\include\hucc\hucc-systemcard.h", 6; ;
   80                        		.dbg	line,	"..\..\..\include\hucc\hucc-systemcard.h", 7; ; hucc-systemcard.h
   81                        		.dbg	line,	"..\..\..\include\hucc\hucc-systemcard.h", 8; ;
   82                        		.dbg	line,	"..\..\..\include\hucc\hucc-systemcard.h", 9; ; Macros and library functions for using the System Card.
   83                        		.dbg	line,	"..\..\..\include\hucc\hucc-systemcard.h", 10; ;
   84                        		.dbg	line,	"..\..\..\include\hucc\hucc-systemcard.h", 11; ; Copyright John Brandwood 2024.
   85                        		.dbg	line,	"..\..\..\include\hucc\hucc-systemcard.h", 12; ;
   86                        		.dbg	line,	"..\..\..\include\hucc\hucc-systemcard.h", 13; ; Distributed under the Boost Software License, Version 1.0.
   87                        		.dbg	line,	"..\..\..\include\hucc\hucc-systemcard.h", 14; ; (See accompanying file LICENSE_1_0.txt or copy at
   88                        		.dbg	line,	"..\..\..\include\hucc\hucc-systemcard.h", 15; ;  http://www.boost.org/LICENSE_1_0.txt)
   89                        		.dbg	line,	"..\..\..\include\hucc\hucc-systemcard.h", 16; ;
   90                        		.dbg	line,	"..\..\..\include\hucc\hucc-systemcard.h", 17; ; ***************************************************************************
   91                        		.dbg	line,	"..\..\..\include\hucc\hucc-systemcard.h", 18; ; ***************************************************************************
   92                        		.dbg	line,	"..\..\..\include\hucc\hucc-systemcard.h", 19; ;
   93                        		.dbg	line,	"..\..\..\include\hucc\hucc-systemcard.h", 20; ; Because these are mainly macros, and so must be included before being used
   94                        		.dbg	line,	"..\..\..\include\hucc\hucc-systemcard.h", 21; ; in compiled code, the actual functions here are written to avoid using any
   95                        		.dbg	line,	"..\..\..\include\hucc\hucc-systemcard.h", 22; ; BSS memory so that HuCC's overlay global-shared-variables are not effected.
   96                        		.dbg	line,	"..\..\..\include\hucc\hucc-systemcard.h", 23; ;
   97                        		.dbg	line,	"..\..\..\include\hucc\hucc-systemcard.h", 24; ; ***************************************************************************
   98                        		.dbg	line,	"..\..\..\include\hucc\hucc-systemcard.h", 25; ; **************************************************************************/
   99                        		.dbg	line,	"..\..\..\include\hucc\hucc-systemcard.h", 27; // *************
  100                        		.dbg	line,	"..\..\..\include\hucc\hucc-systemcard.h", 28; // Backup RAM defines ...
  101                        		.dbg	line,	"..\..\..\include\hucc\hucc-systemcard.h", 29; // *************
  102                        		.dbg	line,	"..\..\..\include\hucc\hucc-systemcard.h", 31; #define  BM_OK             0
  103                        		.dbg	line,	"..\..\..\include\hucc\hucc-systemcard.h", 32; #define  BM_NOT_FOUND      1
  104                        		.dbg	line,	"..\..\..\include\hucc\hucc-systemcard.h", 33; #define  BM_BAD_CHECKSUM   2
  105                        		.dbg	line,	"..\..\..\include\hucc\hucc-systemcard.h", 34; #define  BM_DIR_CORRUPTED  3
  106                        		.dbg	line,	"..\..\..\include\hucc\hucc-systemcard.h", 35; #define  BM_FILE_EMPTY     4
  107                        		.dbg	line,	"..\..\..\include\hucc\hucc-systemcard.h", 36; #define  BM_FULL           5
  108                        		.dbg	line,	"..\..\..\include\hucc\hucc-systemcard.h", 37; #define  BM_NOT_FORMATED   0xFF			// HuC incorrect spelling.
  109                        		.dbg	line,	"..\..\..\include\hucc\hucc-systemcard.h", 38; #define  BM_NOT_FORMATTED  0xFF			// HuCC can use a dictionary!
  110                        		.dbg	line,	"..\..\..\include\hucc\hucc-systemcard.h", 40; #define  BRAM_STARTPTR     0x8010
  111                        		.dbg	line,	"..\..\..\include\hucc\hucc-systemcard.h", 42; // *************
  112                        		.dbg	line,	"..\..\..\include\hucc\hucc-systemcard.h", 43; // CD defines ...
  113                        		.dbg	line,	"..\..\..\include\hucc\hucc-systemcard.h", 44; // *************
  114                        		.dbg	line,	"..\..\..\include\hucc\hucc-systemcard.h", 46; #define	CDPLAY_MUTE		0
  115                        		.dbg	line,	"..\..\..\include\hucc\hucc-systemcard.h", 47; #define	CDPLAY_REPEAT		1
  116                        		.dbg	line,	"..\..\..\include\hucc\hucc-systemcard.h", 48; #define	CDPLAY_NORMAL		2
  117                        		.dbg	line,	"..\..\..\include\hucc\hucc-systemcard.h", 49; #define	CDPLAY_ENDOFDISC	0
  118                        		.dbg	line,	"..\..\..\include\hucc\hucc-systemcard.h", 51; #define	CDFADE_CANCEL	0
  119                        		.dbg	line,	"..\..\..\include\hucc\hucc-systemcard.h", 52; #define	CDFADE_PCM6	8
  120                        		.dbg	line,	"..\..\..\include\hucc\hucc-systemcard.h", 53; #define	CDFADE_ADPCM6	10
  121                        		.dbg	line,	"..\..\..\include\hucc\hucc-systemcard.h", 54; #define	CDFADE_PCM2	12
  122                        		.dbg	line,	"..\..\..\include\hucc\hucc-systemcard.h", 55; #define	CDFADE_ADPCM2	14
  123                        		.dbg	line,	"..\..\..\include\hucc\hucc-systemcard.h", 57; #define CDTRK_AUDIO	0
  124                        		.dbg	line,	"..\..\..\include\hucc\hucc-systemcard.h", 58; #define CDTRK_DATA	4
  125                        		.dbg	line,	"..\..\..\include\hucc\hucc-systemcard.h", 60; // *************
  126                        		.dbg	line,	"..\..\..\include\hucc\hucc-systemcard.h", 61; // ADPCM defines ...
  127                        		.dbg	line,	"..\..\..\include\hucc\hucc-systemcard.h", 62; // *************
  128                        		.dbg	line,	"..\..\..\include\hucc\hucc-systemcard.h", 64; #define	ADPLAY_AUTOSTOP		0
  129                        		.dbg	line,	"..\..\..\include\hucc\hucc-systemcard.h", 65; #define	ADPLAY_REPEAT		0x80
  130                        		.dbg	line,	"..\..\..\include\hucc\hucc-systemcard.h", 67; #define ADPLAY_FREQ_16KHZ	0xE
  131                        		.dbg	line,	"..\..\..\include\hucc\hucc-systemcard.h", 68; #define ADPLAY_FREQ_10KHZ	0xD
  132                        		.dbg	line,	"..\..\..\include\hucc\hucc-systemcard.h", 69; #define ADPLAY_FREQ_8KHZ	0xC
  133                        		.dbg	line,	"..\..\..\include\hucc\hucc-systemcard.h", 70; #define ADPLAY_FREQ_6KHZ	0xB
  134                        		.dbg	line,	"..\..\..\include\hucc\hucc-systemcard.h", 71; #define ADPLAY_FREQ_5KHZ	0xA
  135                        		.dbg	line,	"..\..\..\include\hucc\hucc-systemcard.h", 73; #define ADREAD_RAM	0
  136                        		.dbg	line,	"..\..\..\include\hucc\hucc-systemcard.h", 74; #define ADREAD_VRAM	0xFF
  137                        		.dbg	line,	"..\..\..\include\hucc\hucc-systemcard.h", 76; #define ADWRITE_RAM	0
  138                        		.dbg	line,	"..\..\..\include\hucc\hucc-systemcard.h", 77; #define ADWRITE_VRAM	0xFF
  139                        		.dbg	line,	"..\..\..\include\hucc\hucc-systemcard.h", 79; // *************
  140                        		.dbg	line,	"..\..\..\include\hucc\hucc-systemcard.h", 80; // Functions in hucc-systemcard.asm ...
  141                        		.dbg	line,	"..\..\..\include\hucc\hucc-systemcard.h", 81; // *************
  142                        		.dbg	line,	"..\..\..\include\hucc\hucc-systemcard.h", 83; #ifdef __HUCC__
  143                        		.dbg	line,	"..\..\..\include\hucc\hucc-systemcard.h", 85; #asmdef	HUCC_USES_SYSTEMCARD 1
  144               0001     	HUCC_USES_SYSTEMCARD = 1
  145                        		.dbg	line,	"..\..\..\include\hucc\hucc-systemcard.h", 87; extern void __fastcall __macro cd_boot( void );
  146                        		.dbg	line,	"..\..\..\include\hucc\hucc-systemcard.h", 88; extern unsigned int __fastcall __macro cd_getver( void );
  147                        		.dbg	line,	"..\..\..\include\hucc\hucc-systemcard.h", 89; extern void __fastcall __macro cd_reset( void );
  148                        		.dbg	line,	"..\..\..\include\hucc\hucc-systemcard.h", 90; extern unsigned char __fastcall __macro cd_pause( void );
  149                        		.dbg	line,	"..\..\..\include\hucc\hucc-systemcard.h", 91; extern unsigned char __fastcall cd_unpause( void );
  150                        		.dbg	line,	"..\..\..\include\hucc\hucc-systemcard.h", 92; extern void __fastcall __macro cd_fade( unsigned char type<acc> );
  151                        		.dbg	line,	"..\..\..\include\hucc\hucc-systemcard.h", 93; extern unsigned char __fastcall cd_playtrk( unsigned char start_track<_bx>, unsigned char end_track<_cx>, unsigned char mode<_dh> );
  152                        		.dbg	line,	"..\..\..\include\hucc\hucc-systemcard.h", 94; extern unsigned char __fastcall cd_playmsf( unsigned char start_minute<_al>,  unsigned char start_second<_ah>,  unsigned char start_frame<_bl>, unsigned char end_minute<_cl>,  unsigned char end_second<_ch>,  unsigned char end_frame<_dl>,  unsigned char mode<_dh> );
  153                        		.dbg	line,	"..\..\..\include\hucc\hucc-systemcard.h", 95; extern unsigned char __fastcall cd_fastvram( unsigned char ovl_index<_cl>, unsigned int sect_offset<_si>, unsigned int vramaddr<_bx>, unsigned int sectors<_al> );
  154                        		.dbg	line,	"..\..\..\include\hucc\hucc-systemcard.h", 96; extern unsigned char __fastcall cd_loadvram( unsigned char ovl_index<_cl>, unsigned int sect_offset<_si>, unsigned int vramaddr<_bx>, unsigned int bytes<_ax> );
  155                        		.dbg	line,	"..\..\..\include\hucc\hucc-systemcard.h", 97; extern unsigned char __fastcall cd_loaddata( unsigned char ovl_index<_cl>, unsigned int sect_offset<_si>, unsigned char __far *buffer<_bp_bank:_bp>, unsigned int bytes<__ptr> );
  156                        		.dbg	line,	"..\..\..\include\hucc\hucc-systemcard.h", 98; extern unsigned char __fastcall cd_loadbank( unsigned char ovl_index<_cl>, unsigned int sect_offset<_si>, unsigned char bank<_bl>, unsigned int sectors<_al> );
  157                        		.dbg	line,	"..\..\..\include\hucc\hucc-systemcard.h", 99; extern unsigned char __fastcall __macro cd_status( unsigned char mode<acc> );
  158                        		.dbg	line,	"..\..\..\include\hucc\hucc-systemcard.h", 101; extern void __fastcall __macro ad_reset( void );
  159                        		.dbg	line,	"..\..\..\include\hucc\hucc-systemcard.h", 102; extern unsigned char __fastcall __macro ad_trans( unsigned char ovl_index<_cl>, unsigned int sect_offset<_si>, unsigned char nb_sectors<_dh>, unsigned int ad_addr<_bx> );
  160                        		.dbg	line,	"..\..\..\include\hucc\hucc-systemcard.h", 103; extern void __fastcall __macro ad_read( unsigned int ad_addr<_cx>, unsigned char mode<_dh>, unsigned int buf<_bx>, unsigned int bytes<_ax> );
  161                        		.dbg	line,	"..\..\..\include\hucc\hucc-systemcard.h", 104; extern void __fastcall __macro ad_write( unsigned int ad_addr<_cx>, unsigned char mode<_dh>, unsigned int buf<_bx>, unsigned int bytes<_ax> );
  162                        		.dbg	line,	"..\..\..\include\hucc\hucc-systemcard.h", 105; extern unsigned char __fastcall __macro ad_play( unsigned int ad_addr<_bx>, unsigned int bytes<_ax>, unsigned char freq<_dh>, unsigned char mode<_dl> );
  163                        		.dbg	line,	"..\..\..\include\hucc\hucc-systemcard.h", 106; extern unsigned char __fastcall __macro ad_cplay( unsigned char ovl_index<_cl>, unsigned int sect_offset<_si>, unsigned int nb_sectors<_bx>, unsigned char freq<_dh> );
  164                        		.dbg	line,	"..\..\..\include\hucc\hucc-systemcard.h", 107; extern void __fastcall __macro ad_stop( void );
  165                        		.dbg	line,	"..\..\..\include\hucc\hucc-systemcard.h", 108; extern unsigned char __fastcall __macro ad_stat( void );
  166                        		.dbg	line,	"..\..\..\include\hucc\hucc-systemcard.h", 110; extern unsigned char __fastcall bm_check( void );
  167                        		.dbg	line,	"..\..\..\include\hucc\hucc-systemcard.h", 111; extern unsigned char __fastcall bm_format( void );
  168                        		.dbg	line,	"..\..\..\include\hucc\hucc-systemcard.h", 112; extern unsigned int __fastcall __macro bm_free( void );
  169                        		.dbg	line,	"..\..\..\include\hucc\hucc-systemcard.h", 113; extern unsigned char __fastcall __macro bm_read( unsigned char *buffer<_bx>, unsigned char *name<_ax>, unsigned int offset<_dx>, unsigned int length<_cx> );
  170                        		.dbg	line,	"..\..\..\include\hucc\hucc-systemcard.h", 114; extern unsigned char __fastcall __macro bm_write( unsigned char *buffer<_bx>, unsigned char *name<_ax>, unsigned int offset<_dx>, unsigned int length<_cx> );
  171                        		.dbg	line,	"..\..\..\include\hucc\hucc-systemcard.h", 115; extern unsigned char __fastcall __macro bm_delete( unsigned char *name<_ax> );
  172                        		.dbg	line,	"..\..\..\include\hucc\hucc-systemcard.h", 117; // Deprecated functions ...
  173                        		.dbg	line,	"..\..\..\include\hucc\hucc-systemcard.h", 119; extern unsigned char __fastcall __macro bm_exist( unsigned char *name<_ax> );
  174                        		.dbg	line,	"..\..\..\include\hucc\hucc-systemcard.h", 120; extern unsigned char __fastcall __macro bm_create( unsigned char *name<_ax>, unsigned int length<_cx> );
  175                        		.dbg	line,	"..\..\..\include\hucc\hucc-systemcard.h", 122; // void __fastcall _xsafe add_sectors( unsigned int sector_offset<acc> );
  176                        		.dbg	line,	"..\..\..\include\hucc\hucc-systemcard.h", 124; #endif // __HUCC__
  177                        		.dbg	line,	"..\..\..\include\hucc\hucc-systemcard.h", 126; #endif // _hucc_systemcard_h
  178                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 34; #include "hucc-baselib.h"
  179                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 1; #ifndef _hucc_baselib_h
  180                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 2; #define _hucc_baselib_h
  181                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 4; /****************************************************************************
  182                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 5; ; ***************************************************************************
  183                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 6; ;
  184                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 7; ; hucc-baselib.h
  185                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 8; ;
  186                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 9; ; Basic library functions provided as macros.
  187                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 10; ;
  188                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 11; ; Copyright John Brandwood 2024.
  189                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 12; ;
  190                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 13; ; Distributed under the Boost Software License, Version 1.0.
  191                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 14; ; (See accompanying file LICENSE_1_0.txt or copy at
  192                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 15; ;  http://www.boost.org/LICENSE_1_0.txt)
  193                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 16; ;
  194                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 17; ; ***************************************************************************
  195                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 18; ; **************************************************************************/
  196                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 20; // *************
  197                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 21; // Joypad defines ...
  198                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 22; // *************
  199                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 24; #define	JOY_A		0x01
  200                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 25; #define	JOY_I		0x01
  201                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 26; #define	JOY_B		0x02
  202                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 27; #define	JOY_II		0x02
  203                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 28; #define	JOY_SLCT	0x04
  204                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 29; #define	JOY_SEL		0x04
  205                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 30; #define	JOY_STRT	0x08
  206                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 31; #define	JOY_RUN		0x08
  207                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 32; #define	JOY_UP		0x10
  208                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 33; #define	JOY_RGHT	0x20
  209                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 34; #define	JOY_RIGHT	0x20
  210                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 35; #define	JOY_DOWN	0x40
  211                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 36; #define	JOY_LEFT	0x80
  212                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 38; #define	JOY_C		0x0100
  213                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 39; #define	JOY_III		0x0100
  214                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 40; #define	JOY_D		0x0200
  215                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 41; #define	JOY_IV		0x0200
  216                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 42; #define	JOY_E		0x0400
  217                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 43; #define	JOY_V		0x0400
  218                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 44; #define	JOY_F		0x0800
  219                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 45; #define	JOY_VI		0x0800
  220                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 47; #define JOY_SIXBUT	0x8000
  221                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 48; #define JOY_TYPE6	0x8000
  222                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 50; // *************
  223                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 51; // SuperGRAFX VPC settings for set_vpc_ctl() ...
  224                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 52; // *************
  225                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 54; #define VPC_SPR1_BKG1_SPR2_BKG2	0x3000 // same as SGX_PARALLAX=0
  226                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 55; #define VPC_SPR1_SPR2_BKG1_BKG2	0x7000 // same as SGX_PARALLAX=1
  227                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 56; #define VPC_BKG1_BKG2_SPR1_SPR2	0xB000
  228                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 58; // *************
  229                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 59; // System Card variables ...
  230                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 60; // *************
  231                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 62; extern unsigned int si;
  232                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 63; extern unsigned int di;
  233                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 64; extern unsigned int bp;
  234                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 66; extern unsigned int ax;
  235                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 67; extern unsigned int bx;
  236                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 68; extern unsigned int cx;
  237                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 69; extern unsigned int dx;
  238                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 71; extern unsigned char al;
  239                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 72; extern unsigned char ah;
  240                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 73; extern unsigned char bl;
  241                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 74; extern unsigned char bh;
  242                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 75; extern unsigned char cl;
  243                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 76; extern unsigned char ch;
  244                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 77; extern unsigned char dl;
  245                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 78; extern unsigned char dh;
  246                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 80; extern unsigned char irq_cnt;
  247                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 81; extern unsigned char joynow[5];
  248                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 82; extern unsigned char joytrg[5];
  249                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 83; extern unsigned char joy6now[5];
  250                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 84; extern unsigned char joy6trg[5];
  251                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 85; extern unsigned int  bg_x1;
  252                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 86; extern unsigned int  bg_y1;
  253                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 87; extern unsigned int  bg_x2;
  254                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 88; extern unsigned int  bg_y2;
  255                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 90; // *************
  256                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 91; // Special macros to get information from PCEAS ...
  257                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 92; // *************
  258                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 94; #define BANK( datasym ) ((unsigned) (&__bank__ ## datasym))
  259                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 95; #define SIZEOF( datasym ) ((unsigned) (&__sizeof__ ## datasym))
  260                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 96; #define COUNTOF( datasym ) ((unsigned) (&__countof__ ## datasym))
  261                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 97; #define OVERLAY( datasym ) ((unsigned) (&__overlay__ ## datasym))
  262                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 100; // *************
  263                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 101; // Functions in hucc-baselib.asm ...
  264                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 102; // *************
  265                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 104; #ifdef __HUCC__
  266                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 106; #asmdef	HUCC_USES_BASELIB 1
  267               0001     	HUCC_USES_BASELIB = 1
  268                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 108; #define	_OPTIMIZE 1
  269                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 111; // *************
  270                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 112; // Hardware Detection
  271                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 113; // *************
  272                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 115; extern unsigned char __fastcall __macro sgx_detect( void );
  273                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 116; extern unsigned char __fastcall __macro ac_exists( void );
  274                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 119; // *************
  275                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 120; // Memory Access
  276                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 121; // *************
  277                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 123; extern unsigned char __fastcall __macro peek( unsigned int addr<__ptr> );
  278                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 124; extern unsigned int  __fastcall __macro peekw( unsigned int addr<__ptr> );
  279                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 126; extern void __fastcall __macro poke( unsigned int addr<__poke>, unsigned char with<acc> );
  280                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 127; extern void __fastcall __macro pokew( unsigned int addr<__poke>, unsigned int with<acc> );
  281                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 129; extern unsigned char __fastcall farpeek( void __far *addr<_bp_bank:_bp> );
  282                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 130; extern unsigned int  __fastcall farpeekw( void __far *addr<_bp_bank:_bp> );
  283                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 132; extern void __fastcall __nop set_far_base( unsigned char data_bank<_bp_bank>, unsigned char *data_addr<_bp> );
  284                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 133; extern void __fastcall set_far_offset( unsigned int offset<_bp>, unsigned char data_bank<_bp_bank>, unsigned char *data_addr<acc> );
  285                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 135; extern unsigned char __fastcall far_peek( void );
  286                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 136; extern unsigned int  __fastcall far_peekw( void );
  287                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 138; extern void __fastcall __macro reset_mpr2( void );
  288                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 139; extern void __fastcall __macro reset_mpr34( void );
  289                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 141; extern void * __fastcall __macro farset_mpr2( void __far *addr<_bp_bank:_bp> );
  290                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 142; extern void * __fastcall __macro farset_mpr34( void __far *addr<_bp_bank:_bp> );
  291                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 144; extern void * __fastcall __macro far_set_mpr2( void );
  292                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 145; extern void * __fastcall __macro far_set_mpr34( void );
  293                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 148; // *************
  294                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 149; // Clock Functions
  295                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 150; // *************
  296                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 152; extern unsigned char __fastcall __macro clock_hh( void );
  297                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 153; extern unsigned char __fastcall __macro clock_mm( void );
  298                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 154; extern unsigned char __fastcall __macro clock_ss( void );
  299                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 155; extern unsigned char __fastcall __macro clock_tt( void );
  300                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 156; extern void __fastcall __macro clock_reset( void );
  301                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 159; // *************
  302                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 160; // Joypad Functions
  303                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 161; // *************
  304                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 163; extern unsigned int __fastcall __macro joy( unsigned char which<acc> );
  305                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 164; extern unsigned int __fastcall __macro joytrg( unsigned char which<acc> );
  306                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 167; // *************
  307                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 168; // Number Functions
  308                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 169; // *************
  309                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 171; extern int __fastcall abs( int value<acc> );
  310                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 173; extern void __fastcall __macro srand( unsigned char seed<acc> );
  311                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 174; extern unsigned int __fastcall rand( void );
  312                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 175; extern unsigned char __fastcall rand8( void );
  313                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 177; // Note: "limit" is 0..255.
  314                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 178; extern unsigned char __fastcall random8( unsigned char limit<acc> );
  315                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 180; // Note: "limit" is 0..128, 129..255 are treated as 128!
  316                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 181; extern unsigned char __fastcall random( unsigned char limit<acc> );
  317                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 184; // *************
  318                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 185; // Overlay Execution
  319                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 186; // *************
  320                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 188; extern unsigned char __fastcall __macro cd_execoverlay( unsigned char ovl_index<acc> );
  321                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 191; // *************
  322                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 192; // Functions that are only optionally available if configured in your hucc-config.inc
  323                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 193; // *************
  324                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 195; extern unsigned int __fastcall __macro joybuf( unsigned char which<acc> );
  325                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 196; extern unsigned int __fastcall __macro get_joy_events( unsigned char which<acc> );
  326                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 197; extern void __fastcall __macro clear_joy_events( unsigned char mask<acc> );
  327                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 200; // *************
  328                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 201; // Functions that are only implemented in the TGEMU emulator for unit-testing
  329                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 202; // the compiler, and which should never be used in normal HuCC projects ...
  330                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 203; // *************
  331                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 205; extern void __fastcall dump_screen( void );
  332                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 206; extern void __fastcall abort( void );
  333                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 207; extern void __fastcall exit( int value<acc> );
  334                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 209; extern unsigned char __fastcall __builtin_ffs( unsigned int value<__temp> );
  335                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 211; #endif // __HUCC__
  336                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 213; #endif // _hucc_baselib_h
  337                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 35; #include "hucc-gfx.h"
  338                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 1; #ifndef _hucc_gfx_h
  339                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 2; #define _hucc_gfx_h
  340                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 4; /****************************************************************************
  341                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 5; ; ***************************************************************************
  342                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 6; ;
  343                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 7; ; huc-gfx.h
  344                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 8; ;
  345                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 9; ; Based on the original HuC and MagicKit functions by David Michel and the
  346                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 10; ; other original HuC developers.
  347                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 11; ;
  348                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 12; ; Modifications copyright John Brandwood 2024.
  349                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 13; ;
  350                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 14; ; Distributed under the Boost Software License, Version 1.0.
  351                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 15; ; (See accompanying file LICENSE_1_0.txt or copy at
  352                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 16; ;  http://www.boost.org/LICENSE_1_0.txt)
  353                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 17; ;
  354                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 18; ; ***************************************************************************
  355                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 19; ; **************************************************************************/
  356                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 21; // *************
  357                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 22; // Screen defines ...
  358                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 23; // *************
  359                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 25; #define	SCR_SIZE_32x32	0
  360                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 26; #define	SCR_SIZE_64x32	1
  361                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 27; #define	SCR_SIZE_128x32	2
  362                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 28; #define	SCR_SIZE_32x64	4
  363                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 29; #define	SCR_SIZE_64x64	5
  364                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 30; #define	SCR_SIZE_128x64	6
  365                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 32; #define	XRES_SHARP	0
  366                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 33; #define	XRES_SOFT	4
  367                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 34; #define	XRES_KEEP	128
  368                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 36; #define VPC_WIN_A	0x00
  369                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 37; #define VPC_WIN_B	0x01
  370                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 38; #define	VPC_WIN_AB	0x02
  371                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 39; #define	VPC_WIN_NONE	0x03
  372                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 40; #define	VPC_NORM	0x00
  373                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 41; #define	VPC_SPR		0x04
  374                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 42; #define	VPC_INV_SPR	0x08
  375                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 43; #define VDC1_ON		0x01
  376                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 44; #define	VDC1_OFF	0x00
  377                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 45; #define VDC2_ON		0x02
  378                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 46; #define	VDC2_OFF	0x00
  379                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 47; #define VDC_ON		0x03
  380                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 48; #define	VDC_OFF		0x00
  381                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 50; // *************
  382                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 51; // Functions in hucc-gfx.asm ...
  383                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 52; // *************
  384                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 54; #ifdef __HUCC__
  385                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 56; #asmdef	HUCC_USES_GFX 1
  386               0001     	HUCC_USES_GFX = 1
  387                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 58; // *************
  388                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 59; // Color and Palette Functions
  389                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 60; // *************
  390                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 62; extern void __fastcall clear_palette( void );
  391                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 64; extern void __fastcall __nop set_color( unsigned int index<VCE_CTA>, unsigned int value<VCE_CTW> );
  392                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 65; extern void __fastcall set_color_rgb( unsigned int index<VCE_CTA>, unsigned char r<_al>, unsigned char g<_ah>, unsigned char b<acc> );
  393                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 66; extern unsigned int __fastcall __macro get_color( unsigned int index<VCE_CTA> );
  394                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 68; extern void __fastcall load_palette( unsigned char palette<_al>, unsigned char __far *data<_bp_bank:_bp>, unsigned char num_palettes<_ah> );
  395                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 69; extern void __fastcall far_load_palette( unsigned char palette<_al>, unsigned char num_palettes<_ah> );
  396                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 71; extern void __fastcall read_palette( unsigned char palette<_al>, unsigned char num_palettes<_ah>, unsigned int *destination<_di> );
  397                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 73; extern void __fastcall __macro fade_to_black( unsigned int __far *from<_bp_bank:_bp>, unsigned int *destination<_di>, unsigned char num_colors<_al>, unsigned char value_to_sub<_ah> );
  398                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 74; extern void __fastcall __macro fade_to_white( unsigned int __far *from<_bp_bank:_bp>, unsigned int *destination<_di>, unsigned char num_colors<_al>, unsigned char value_to_add<_ah> );
  399                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 75; extern void __fastcall __macro cross_fade_to( unsigned int __far *from<_bp_bank:_bp>, unsigned int *destination<_di>, unsigned char num_colors<_al>, unsigned char which_component<_ah> );
  400                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 77; extern void __fastcall __macro far_fade_to_black( unsigned int *destination<_di>, unsigned char num_colors<_al>, unsigned char value_to_sub<_ah> );
  401                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 78; extern void __fastcall __macro far_fade_to_white( unsigned int *destination<_di>, unsigned char num_colors<_al>, unsigned char value_to_add<_ah> );
  402                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 79; extern void __fastcall __macro far_cross_fade_to( unsigned int *destination<_di>, unsigned char num_colors<_al>, unsigned char which_component<_ah> );
  403                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 83; // *************
  404                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 84; // Video Functions
  405                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 85; // *************
  406                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 87; extern void __fastcall init_240x208( void );
  407                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 88; extern void __fastcall init_256x224( void );
  408                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 90; extern void __fastcall vsync( void );
  409                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 91; extern void __fastcall vsync( unsigned char count<_al> );
  410                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 93; extern void __fastcall disp_on( void );
  411                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 94; extern void __fastcall disp_off( void );
  412                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 96; extern void __fastcall set_screen_size( unsigned char value<_al> );
  413                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 98; extern void __fastcall set_xres( unsigned int x_pixels<_ax>, unsigned char blur_flag<_bl> );
  414                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 100; extern void __fastcall cls( void );
  415                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 101; extern void __fastcall cls( unsigned int tile<acc> );
  416                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 103; extern unsigned int __fastcall __macro vram_addr( unsigned char bat_x<_al>, unsigned char bat_y<_ah> );
  417                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 104; extern unsigned int __fastcall __macro get_vram( unsigned int address<_di> );
  418                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 105; extern void __fastcall __macro put_vram( unsigned int address<_di>, unsigned int data<acc> );
  419                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 107; extern void __fastcall __macro load_vram( unsigned int vram<_di>, unsigned char __far *data<_bp_bank:_bp>, unsigned int num_words<_ax> );
  420                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 108; extern void __fastcall __macro far_load_vram( unsigned int vram<_di>,  unsigned int num_words<_ax> );
  421                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 110; extern void __fastcall load_bat( unsigned int vram<_di>, unsigned char __far *data<_bp_bank:_bp>, unsigned char tiles_w<_al>, unsigned char tiles_h<_ah> );
  422                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 111; extern void __fastcall far_load_bat( unsigned int vram<_di>, unsigned char tiles_w<_al>, unsigned char tiles_h<_ah> );
  423                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 113; extern void __fastcall __macro load_sprites( unsigned int vram<_di>, unsigned char __far *data<_bp_bank:_bp>, unsigned int num_groups<acc> );
  424                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 114; extern void __fastcall __macro far_load_sprites( unsigned int vram<_di>, unsigned int num_groups<acc> );
  425                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 116; extern void __fastcall vram2vram( unsigned int vram_dst<_ax>, unsigned int vram_src<_bx>, unsigned int word_len<_cx> );
  426                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 119; // *************
  427                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 120; // SuperGRAFX Video Functions
  428                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 121; // *************
  429                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 123; extern void __fastcall __nop vpc_set_ctl( unsigned int bits<VPC_CR> );
  430                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 124; extern void __fastcall __nop vpc_set_win1( unsigned int width<VPC_WINDOW1> );
  431                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 125; extern void __fastcall __nop vpc_set_win2( unsigned int width<VPC_WINDOW2> );
  432                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 127; extern void __fastcall sgx_set_screen_size( unsigned char value<_al> );
  433                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 129; extern void __fastcall sgx_set_xres( unsigned int x_pixels<_ax>, unsigned char blur_flag<_bl> );
  434                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 131; extern void __fastcall sgx_cls( void );
  435                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 132; extern void __fastcall sgx_cls( unsigned int tile<acc> );
  436                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 134; extern unsigned int __fastcall __macro sgx_vram_addr( unsigned char bat_x<_al>, unsigned char bat_y<_ah> );
  437                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 135; extern unsigned int __fastcall __macro sgx_get_vram( unsigned int address<_di> );
  438                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 136; extern void __fastcall __macro sgx_put_vram( unsigned int address<_di>, unsigned int data<acc> );
  439                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 138; extern void __fastcall __macro sgx_load_vram( unsigned int vram<_di>, unsigned char __far *data<_bp_bank:_bp>, unsigned int num_words<_ax> );
  440                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 139; extern void __fastcall __macro sgx_far_load_vram( unsigned int vram<_di>, unsigned int num_words<_ax> );
  441                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 141; extern void __fastcall sgx_load_bat( unsigned int vram<_di>, unsigned char __far *data<_bp_bank:_bp>, unsigned char tiles_w<_al>, unsigned char tiles_h<_ah> );
  442                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 142; extern void __fastcall sgx_far_load_bat( unsigned int vram<_di>, unsigned char tiles_w<_al>, unsigned char tiles_h<_ah> );
  443                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 144; extern void __fastcall __macro sgx_load_sprites( unsigned int vram<_di>, unsigned char __far *data<_bp_bank:_bp>, unsigned int num_groups<acc> );
  444                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 145; extern void __fastcall __macro sgx_far_load_sprites( unsigned int vram<_di>, unsigned int num_groups<acc> );
  445                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 147; extern void __fastcall sgx_vram2vram( unsigned int vram_dst<_ax>, unsigned int vram_src<_bx>, unsigned int word_len<_cx> );
  446                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 150; // *************
  447                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 151; // Font Functions
  448                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 152; // *************
  449                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 154; extern void __fastcall set_font_addr( unsigned int vram<acc> );
  450                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 155; extern void __fastcall set_font_pal( unsigned char palette<acc> );
  451                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 157; extern void __fastcall load_font( unsigned char __far *font<_bp_bank:_bp>, unsigned char count<_al>, unsigned int vram<acc> );
  452                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 158; extern void __fastcall far_load_font( unsigned char count<_al>, unsigned int vram<acc> );
  453                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 160; extern void __fastcall __nop set_font_color( unsigned char foreground<monofont_fg>, unsigned char background<monofont_bg> );
  454                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 161; extern void __fastcall __macro load_default_font( void );
  455                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 164; // *************
  456                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 165; // SuperGRAFX Font Functions
  457                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 166; // *************
  458                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 168; extern void __fastcall sgx_set_font_addr( unsigned int vram<acc> );
  459                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 169; extern void __fastcall sgx_set_font_pal( unsigned char palette<acc> );
  460                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 171; extern void __fastcall sgx_load_font( char __far *font<_bp_bank:_bp>, unsigned char count<_al>, unsigned int vram<acc> );
  461                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 172; extern void __fastcall sgx_far_load_font( unsigned char count<_al>, unsigned int vram<acc> );
  462                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 174; extern void __fastcall __macro sgx_load_default_font( void );
  463                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 177; // *************
  464                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 178; // Deprecated functions ...
  465                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 179; // *************
  466                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 181; extern void __fastcall __macro set_xres( unsigned int x_pixels<_ax> );
  467                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 182; extern void __fastcall __macro sgx_set_xres( unsigned int x_pixels<_ax> );
  468                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 184; extern void __fastcall load_background( unsigned char __far *tiles<_bp_bank:_bp>, unsigned char __far *palettes<__fbank:__fptr>, unsigned char __far *bat<_cl:_bx>, unsigned char w<_dl>, unsigned char h<_dh> );
  469                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 186; extern void __fastcall __macro set_bgpal( unsigned char palette<_al>, unsigned char __far *data<_bp_bank:_bp> );
  470                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 187; extern void __fastcall __macro set_bgpal( unsigned char palette<_al>, unsigned char __far *data<_bp_bank:_bp>, unsigned int num_palettes<_ah> );
  471                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 188; extern void __fastcall __macro set_sprpal( unsigned char palette<_al>, unsigned char __far *data<_bp_bank:_bp> );
  472                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 189; extern void __fastcall __macro set_sprpal( unsigned char palette<_al>, unsigned char __far *data<_bp_bank:_bp>, unsigned int num_palettes<_ah> );
  473                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 191; extern void __fastcall load_font( char __far *font<_bp_bank:_bp>, unsigned char count<_al> );
  474                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 193; extern void __fastcall put_string( unsigned char *string<_bp>, unsigned char bat_x<_dil>, unsigned char bat_y<_dih> );
  475                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 195; extern void __fastcall put_char( unsigned char digit<_bl>, unsigned char bat_x<_dil>, unsigned char bat_y<_dih> );
  476                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 196; extern void __fastcall put_digit( unsigned char digit<_bl>, unsigned char bat_x<_dil>, unsigned char bat_y<_dih> );
  477                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 197; extern void __fastcall put_hex( unsigned int number<_bx>, unsigned char length<_cl>, unsigned char bat_x<_dil>, unsigned char bat_y<_dih> );
  478                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 198; extern void __fastcall put_number( unsigned int number<_bx>, unsigned char length<_cl>, unsigned char bat_x<_dil>, unsigned char bat_y<_dih> );
  479                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 199; extern void __fastcall put_raw( unsigned int data<_bx>, unsigned char bat_x<_dil>, unsigned char bat_y<_dih> );
  480                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 201; #endif // __HUCC__
  481                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 203; #endif // _hucc_gfx_h
  482                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 36; #include "hucc-string.h"
  483                        		.dbg	line,	"..\..\..\include\hucc\hucc-string.h", 1; #ifndef _hucc_string_h
  484                        		.dbg	line,	"..\..\..\include\hucc\hucc-string.h", 2; #define _hucc_string_h
  485                        		.dbg	line,	"..\..\..\include\hucc\hucc-string.h", 4; /****************************************************************************
  486                        		.dbg	line,	"..\..\..\include\hucc\hucc-string.h", 5; ; ***************************************************************************
  487                        		.dbg	line,	"..\..\..\include\hucc\hucc-string.h", 6; ;
  488                        		.dbg	line,	"..\..\..\include\hucc\hucc-string.h", 7; ; hucc-string.h
  489                        		.dbg	line,	"..\..\..\include\hucc\hucc-string.h", 8; ;
  490                        		.dbg	line,	"..\..\..\include\hucc\hucc-string.h", 9; ; Not-quite-standard, but fast, replacements for <string.h>.
  491                        		.dbg	line,	"..\..\..\include\hucc\hucc-string.h", 10; ;
  492                        		.dbg	line,	"..\..\..\include\hucc\hucc-string.h", 11; ; Copyright John Brandwood 2024.
  493                        		.dbg	line,	"..\..\..\include\hucc\hucc-string.h", 12; ;
  494                        		.dbg	line,	"..\..\..\include\hucc\hucc-string.h", 13; ; Distributed under the Boost Software License, Version 1.0.
  495                        		.dbg	line,	"..\..\..\include\hucc\hucc-string.h", 14; ; (See accompanying file LICENSE_1_0.txt or copy at
  496                        		.dbg	line,	"..\..\..\include\hucc\hucc-string.h", 15; ;  http://www.boost.org/LICENSE_1_0.txt)
  497                        		.dbg	line,	"..\..\..\include\hucc\hucc-string.h", 16; ;
  498                        		.dbg	line,	"..\..\..\include\hucc\hucc-string.h", 17; ; ***************************************************************************
  499                        		.dbg	line,	"..\..\..\include\hucc\hucc-string.h", 18; ; ***************************************************************************
  500                        		.dbg	line,	"..\..\..\include\hucc\hucc-string.h", 19; ;
  501                        		.dbg	line,	"..\..\..\include\hucc\hucc-string.h", 20; ; !!! WARNING : non-standard return values !!!
  502                        		.dbg	line,	"..\..\..\include\hucc\hucc-string.h", 21; ;
  503                        		.dbg	line,	"..\..\..\include\hucc\hucc-string.h", 22; ; Strings are limited to a maximum of 255 characters (+ the terminator)!
  504                        		.dbg	line,	"..\..\..\include\hucc\hucc-string.h", 23; ;
  505                        		.dbg	line,	"..\..\..\include\hucc\hucc-string.h", 24; ; The memcpy(), strcpy() and strcat() functions do NOT return the destination
  506                        		.dbg	line,	"..\..\..\include\hucc\hucc-string.h", 25; ; address, and they are declared "void" to check that the value is not used.
  507                        		.dbg	line,	"..\..\..\include\hucc\hucc-string.h", 26; ;
  508                        		.dbg	line,	"..\..\..\include\hucc\hucc-string.h", 27; ; mempcpy() is provided which returns the end address instead of the starting
  509                        		.dbg	line,	"..\..\..\include\hucc\hucc-string.h", 28; ; address, because this is typically more useful.
  510                        		.dbg	line,	"..\..\..\include\hucc\hucc-string.h", 29; ;
  511                        		.dbg	line,	"..\..\..\include\hucc\hucc-string.h", 30; ; Please note that both memcpy() and memset() are implemented using a TII for
  512                        		.dbg	line,	"..\..\..\include\hucc\hucc-string.h", 31; ; speed, and so the length should be < 16 bytes if used in time-critical bits
  513                        		.dbg	line,	"..\..\..\include\hucc\hucc-string.h", 32; ; of code (such as when using a split screen) because they delay interrupts.
  514                        		.dbg	line,	"..\..\..\include\hucc\hucc-string.h", 33; ;
  515                        		.dbg	line,	"..\..\..\include\hucc\hucc-string.h", 34; ; strncpy() and strncat() are not provided, because strncpy() was not created
  516                        		.dbg	line,	"..\..\..\include\hucc\hucc-string.h", 35; ; for the purpose of avoiding string overruns, and strncat() is just a poorly
  517                        		.dbg	line,	"..\..\..\include\hucc\hucc-string.h", 36; ; designed function IMHO.
  518                        		.dbg	line,	"..\..\..\include\hucc\hucc-string.h", 37; ;
  519                        		.dbg	line,	"..\..\..\include\hucc\hucc-string.h", 38; ; POSIX strlcpy() and strlcat() are provided instead, but once again they are
  520                        		.dbg	line,	"..\..\..\include\hucc\hucc-string.h", 39; ; slightly non-standard in that the return value when there is an overflow is
  521                        		.dbg	line,	"..\..\..\include\hucc\hucc-string.h", 40; ; the buffer size (so that the overflow can be detected), instead of the full
  522                        		.dbg	line,	"..\..\..\include\hucc\hucc-string.h", 41; ; size of the destination string that was too big to fit in the buffer.
  523                        		.dbg	line,	"..\..\..\include\hucc\hucc-string.h", 42; ;
  524                        		.dbg	line,	"..\..\..\include\hucc\hucc-string.h", 43; ; ***************************************************************************
  525                        		.dbg	line,	"..\..\..\include\hucc\hucc-string.h", 44; ; **************************************************************************/
  526                        		.dbg	line,	"..\..\..\include\hucc\hucc-string.h", 46; // *************
  527                        		.dbg	line,	"..\..\..\include\hucc\hucc-string.h", 47; // Functions in hucc-string.asm ...
  528                        		.dbg	line,	"..\..\..\include\hucc\hucc-string.h", 48; // *************
  529                        		.dbg	line,	"..\..\..\include\hucc\hucc-string.h", 50; #ifdef __HUCC__
  530                        		.dbg	line,	"..\..\..\include\hucc\hucc-string.h", 52; #asmdef	HUCC_USES_STRING 1
  531               0001     	HUCC_USES_STRING = 1
  532                        		.dbg	line,	"..\..\..\include\hucc\hucc-string.h", 54; extern void __fastcall strcpy( char *destination<_di>, char *source<_bp> );
  533                        		.dbg	line,	"..\..\..\include\hucc\hucc-string.h", 55; extern void __fastcall strcat( char *destination<_di>, char *source<_bp> );
  534                        		.dbg	line,	"..\..\..\include\hucc\hucc-string.h", 57; extern unsigned int __fastcall strlen( char *source<_bp> );
  535                        		.dbg	line,	"..\..\..\include\hucc\hucc-string.h", 59; extern unsigned int __fastcall strlcpy( char *destination<_di>, char *source<_bp>, unsigned char size<acc> );
  536                        		.dbg	line,	"..\..\..\include\hucc\hucc-string.h", 60; extern unsigned int __fastcall strlcat( char *destination<_di>, char *source<_bp>, unsigned char size<acc> );
  537                        		.dbg	line,	"..\..\..\include\hucc\hucc-string.h", 62; extern void __fastcall memcpy( unsigned char *destination<ram_tii_dst>, unsigned char *source<ram_tii_src>, unsigned int count<acc> );
  538                        		.dbg	line,	"..\..\..\include\hucc\hucc-string.h", 63; extern void __fastcall farmemcpy( unsigned char *destination<ram_tii_dst>, unsigned char __far *source<_bp_bank:ram_tii_src>, unsigned int count<acc> );
  539                        		.dbg	line,	"..\..\..\include\hucc\hucc-string.h", 64; extern void __fastcall far_memcpy( unsigned char *destination<ram_tii_dst>, unsigned int count<acc> );
  540                        		.dbg	line,	"..\..\..\include\hucc\hucc-string.h", 66; extern unsigned char * __fastcall mempcpy( unsigned char *destination<ram_tii_dst>, unsigned char *source<ram_tii_src>, unsigned int count<acc> );
  541                        		.dbg	line,	"..\..\..\include\hucc\hucc-string.h", 67; extern unsigned char * __fastcall farmempcpy( unsigned char *destination<ram_tii_dst>, unsigned char __far *source<_bp_bank:ram_tii_src>, unsigned int count<acc> );
  542                        		.dbg	line,	"..\..\..\include\hucc\hucc-string.h", 68; extern unsigned char * __fastcall far_mempcpy( unsigned char *destination<ram_tii_dst>, unsigned int count<acc> );
  543                        		.dbg	line,	"..\..\..\include\hucc\hucc-string.h", 70; extern void __fastcall memset( unsigned char *destination<ram_tii_src>, unsigned char value<_al>, unsigned int count<acc> );
  544                        		.dbg	line,	"..\..\..\include\hucc\hucc-string.h", 72; //  0 	if strings are equal
  545                        		.dbg	line,	"..\..\..\include\hucc\hucc-string.h", 73; //  1 	if the first non-matching character in string1 > string2 (in ASCII).
  546                        		.dbg	line,	"..\..\..\include\hucc\hucc-string.h", 74; // -1 	if the first non-matching character in string1 < string2 (in ASCII).
  547                        		.dbg	line,	"..\..\..\include\hucc\hucc-string.h", 76; extern int __fastcall strcmp( char *string1<_di>, char *string2<_bp> );
  548                        		.dbg	line,	"..\..\..\include\hucc\hucc-string.h", 77; extern int __fastcall strncmp( char *string1<_di>, char *string2<_bp>, unsigned int count<_ax> );
  549                        		.dbg	line,	"..\..\..\include\hucc\hucc-string.h", 79; extern int __fastcall __macro memcmp( unsigned char *string1<_di>, unsigned char *string2<_bp>, unsigned int count<acc> );
  550                        		.dbg	line,	"..\..\..\include\hucc\hucc-string.h", 80; extern int __fastcall farmemcmp( unsigned char *string1<_di>, unsigned char __far *string2<_bp_bank:_bp>, unsigned int count<acc> );
  551                        		.dbg	line,	"..\..\..\include\hucc\hucc-string.h", 81; extern int __fastcall far_memcmp( unsigned char *string1<_di>, unsigned int count<acc> );
  552                        		.dbg	line,	"..\..\..\include\hucc\hucc-string.h", 83; #endif // __HUCC__
  553                        		.dbg	line,	"..\..\..\include\hucc\hucc-string.h", 85; #endif // _hucc_string_h
  554                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 37; #include "hucc-old-scroll.h"
  555                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-scroll.h", 1; #ifndef _hucc_old_scroll_h
  556                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-scroll.h", 2; #define _hucc_old_scroll_h
  557                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-scroll.h", 4; /****************************************************************************
  558                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-scroll.h", 5; ; ***************************************************************************
  559                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-scroll.h", 6; ;
  560                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-scroll.h", 7; ; hucc-old-scroll.h
  561                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-scroll.h", 8; ;
  562                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-scroll.h", 9; ; Based on the original HuC and MagicKit functions by David Michel and the
  563                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-scroll.h", 10; ; other original HuC developers.
  564                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-scroll.h", 11; ;
  565                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-scroll.h", 12; ; Modifications copyright John Brandwood 2024.
  566                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-scroll.h", 13; ;
  567                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-scroll.h", 14; ; Distributed under the Boost Software License, Version 1.0.
  568                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-scroll.h", 15; ; (See accompanying file LICENSE_1_0.txt or copy at
  569                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-scroll.h", 16; ;  http://www.boost.org/LICENSE_1_0.txt)
  570                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-scroll.h", 17; ;
  571                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-scroll.h", 18; ; ***************************************************************************
  572                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-scroll.h", 19; ; ***************************************************************************
  573                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-scroll.h", 20; ;
  574                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-scroll.h", 21; ; HuC's old scrolling library is provided for use with existing HuC projects,
  575                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-scroll.h", 22; ; but it should preferably be avoided in new projects because it is slow and
  576                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-scroll.h", 23; ; forever limited by its choice to handle gaps between areas, and sorting.
  577                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-scroll.h", 24; ;
  578                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-scroll.h", 25; ; HuCC's new scrolling library puts the responibility for defining both gaps
  579                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-scroll.h", 26; ; and the display order into the project's hands, but in return it runs much
  580                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-scroll.h", 27; ; faster, using less than 1/6 of the processing time in VBLANK, and far less
  581                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-scroll.h", 28; ; time in the RCR interrputs themselves. It also supports the 2nd SuperGRAFX
  582                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-scroll.h", 29; ; screen layer, which HuC's old scrolling library ignores.
  583                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-scroll.h", 30; ;
  584                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-scroll.h", 31; ; ***************************************************************************
  585                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-scroll.h", 32; ; **************************************************************************/
  586                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-scroll.h", 34; // *************
  587                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-scroll.h", 35; // Functions in hucc-old-scroll.asm ...
  588                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-scroll.h", 36; // *************
  589                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-scroll.h", 38; #ifdef __HUCC__
  590                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-scroll.h", 40; #asmdef	HUCC_USES_OLD_SCROLL 1
  591               0001     	HUCC_USES_OLD_SCROLL = 1
  592                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-scroll.h", 42; extern void __fastcall scroll( unsigned char num<_al>, unsigned int x<_cx>, unsigned int y<_dx>, unsigned char top<_ah>, unsigned char bottom<_bl>, unsigned char disp<acc> );
  593                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-scroll.h", 43; extern void __fastcall scroll_disable( unsigned char num<acc> );
  594                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-scroll.h", 45; #endif // __HUCC__
  595                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-scroll.h", 47; #endif // _hucc_old_scroll_h
  596                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 38; #include "hucc-old-spr.h"
  597                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-spr.h", 1; #ifndef _hucc_old_spr_h
  598                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-spr.h", 2; #define _hucc_old_spr_h
  599                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-spr.h", 4; /****************************************************************************
  600                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-spr.h", 5; ; ***************************************************************************
  601                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-spr.h", 6; ;
  602                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-spr.h", 7; ; hucc-old-spr.h
  603                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-spr.h", 8; ;
  604                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-spr.h", 9; ; Based on the original HuC and MagicKit functions by David Michel and the
  605                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-spr.h", 10; ; other original HuC developers.
  606                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-spr.h", 11; ;
  607                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-spr.h", 12; ; Modifications copyright John Brandwood 2024.
  608                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-spr.h", 13; ;
  609                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-spr.h", 14; ; Distributed under the Boost Software License, Version 1.0.
  610                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-spr.h", 15; ; (See accompanying file LICENSE_1_0.txt or copy at
  611                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-spr.h", 16; ;  http://www.boost.org/LICENSE_1_0.txt)
  612                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-spr.h", 17; ;
  613                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-spr.h", 18; ; ***************************************************************************
  614                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-spr.h", 19; ; **************************************************************************/
  615                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-spr.h", 21; // *************
  616                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-spr.h", 22; // Sprite defines ...
  617                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-spr.h", 23; // *************
  618                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-spr.h", 25; #define FLIP_X_MASK 0x08
  619                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-spr.h", 26; #define FLIP_Y_MASK 0x80
  620                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-spr.h", 27; #define FLIP_MAS    0x88
  621                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-spr.h", 28; #define SIZE_MAS    0x31
  622                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-spr.h", 30; #define NO_FLIP     0x00
  623                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-spr.h", 31; #define NO_FLIP_X   0x00
  624                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-spr.h", 32; #define NO_FLIP_Y   0x00
  625                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-spr.h", 33; #define FLIP_X      0x08
  626                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-spr.h", 34; #define FLIP_Y      0x80
  627                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-spr.h", 35; #define SZ_16x16    0x00
  628                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-spr.h", 36; #define SZ_16x32    0x10
  629                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-spr.h", 37; #define SZ_16x64    0x30
  630                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-spr.h", 38; #define SZ_32x16    0x01
  631                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-spr.h", 39; #define SZ_32x32    0x11
  632                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-spr.h", 40; #define	SZ_32x64    0x31
  633                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-spr.h", 42; // *************
  634                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-spr.h", 43; // Functions in hucc-old-spr.asm ...
  635                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-spr.h", 44; // *************
  636                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-spr.h", 46; #ifdef __HUCC__
  637                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-spr.h", 48; #asmdef	HUCC_USES_OLD_SPR 1
  638               0001     	HUCC_USES_OLD_SPR = 1
  639                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-spr.h", 50; extern void __fastcall init_satb( void );
  640                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-spr.h", 51; extern void __fastcall reset_satb( void );
  641                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-spr.h", 52; extern void __fastcall satb_update( void );
  642                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-spr.h", 53; extern void __fastcall spr_set( unsigned char num<acc> );
  643                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-spr.h", 54; extern void __fastcall spr_hide( void );
  644                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-spr.h", 55; extern void __fastcall spr_show( void );
  645                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-spr.h", 56; extern void __fastcall spr_x( unsigned int value<acc> );
  646                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-spr.h", 57; extern void __fastcall spr_y( unsigned int value<acc> );
  647                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-spr.h", 58; extern void __fastcall spr_pattern( unsigned int vaddr<acc> );
  648                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-spr.h", 59; extern void __fastcall spr_ctrl( unsigned char mask<_al>, unsigned char value<acc> );
  649                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-spr.h", 60; extern void __fastcall spr_pal( unsigned char palette<acc> );
  650                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-spr.h", 61; extern void __fastcall spr_pri( unsigned char priority<acc> );
  651                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-spr.h", 63; extern unsigned int __fastcall spr_get_x( void );
  652                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-spr.h", 64; extern unsigned int __fastcall spr_get_y( void );
  653                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-spr.h", 66; extern void __fastcall sgx_init_satb( void );
  654                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-spr.h", 67; extern void __fastcall sgx_reset_satb( void );
  655                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-spr.h", 68; extern void __fastcall sgx_satb_update( void );
  656                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-spr.h", 69; extern void __fastcall sgx_spr_set( unsigned char num<acc> );
  657                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-spr.h", 70; extern void __fastcall sgx_spr_hide( void );
  658                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-spr.h", 71; extern void __fastcall sgx_spr_show( void );
  659                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-spr.h", 72; extern void __fastcall sgx_spr_x( unsigned int value<acc> );
  660                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-spr.h", 73; extern void __fastcall sgx_spr_y( unsigned int value<acc> );
  661                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-spr.h", 74; extern void __fastcall sgx_spr_pattern( unsigned int vaddr<acc> );
  662                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-spr.h", 75; extern void __fastcall sgx_spr_ctrl( unsigned char mask<_al>, unsigned char value<acc> );
  663                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-spr.h", 76; extern void __fastcall sgx_spr_pal( unsigned char palette<acc> );
  664                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-spr.h", 77; extern void __fastcall sgx_spr_pri( unsigned char priority<acc> );
  665                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-spr.h", 79; extern unsigned int __fastcall sgx_spr_get_x( void );
  666                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-spr.h", 80; extern unsigned int __fastcall sgx_spr_get_y( void );
  667                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-spr.h", 82; #endif // __HUCC__
  668                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-spr.h", 84; #endif // _hucc_old_spr_h
  669                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 39; #include "hucc-old-map.h"
  670                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-map.h", 1; #ifndef _hucc_old_map_h
  671                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-map.h", 2; #define _hucc_old_map_h
  672                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-map.h", 4; /****************************************************************************
  673                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-map.h", 5; ; ***************************************************************************
  674                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-map.h", 6; ;
  675                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-map.h", 7; ; hucc-old-map.h
  676                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-map.h", 8; ;
  677                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-map.h", 9; ; Based on the original HuC and MagicKit functions by David Michel and the
  678                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-map.h", 10; ; other original HuC developers.
  679                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-map.h", 11; ;
  680                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-map.h", 12; ; Modifications copyright John Brandwood 2024.
  681                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-map.h", 13; ;
  682                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-map.h", 14; ; Distributed under the Boost Software License, Version 1.0.
  683                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-map.h", 15; ; (See accompanying file LICENSE_1_0.txt or copy at
  684                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-map.h", 16; ;  http://www.boost.org/LICENSE_1_0.txt)
  685                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-map.h", 17; ;
  686                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-map.h", 18; ; ***************************************************************************
  687                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-map.h", 19; ; **************************************************************************/
  688                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-map.h", 21; // *************
  689                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-map.h", 22; // Functions in hucc-old-map.asm ...
  690                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-map.h", 23; // *************
  691                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-map.h", 25; #ifdef __HUCC__
  692                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-map.h", 27; #asmdef	HUCC_USES_OLD_MAP 1
  693               0001     	HUCC_USES_OLD_MAP = 1
  694                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-map.h", 29; extern void __fastcall set_tile_address( unsigned int vram<_di> );
  695                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-map.h", 30; extern void __fastcall sgx_set_tile_address( unsigned int vram<_di> );
  696                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-map.h", 32; extern void __fastcall __nop set_tile_data( unsigned char __far *tiles<vdc_tile_bank:vdc_tile_addr>, unsigned char num_tiles<vdc_num_tiles>, unsigned char __far *palette_table<vdc_attr_bank:vdc_attr_addr>, unsigned char tile_type<vdc_tile_type> );
  697                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-map.h", 33; extern void __fastcall __nop sgx_set_tile_data( unsigned char __far *tiles<sgx_tile_bank:sgx_tile_addr>, unsigned char num_tiles<sgx_num_tiles>, unsigned char __far *palette_table<sgx_attr_bank:sgx_attr_addr>, unsigned char tile_type<sgx_tile_type> );
  698                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-map.h", 35; extern void __fastcall __nop set_far_tile_data( unsigned char tile_bank<vdc_tile_bank>, unsigned char *tile_addr<vdc_tile_addr>, unsigned char num_tiles<vdc_num_tiles>, unsigned char palette_table_bank<vdc_attr_bank>, unsigned char *palette_table_addr<vdc_attr_addr>, unsigned char tile_type<vdc_tile_type> );
  699                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-map.h", 36; extern void __fastcall __nop sgx_set_far_tile_data( unsigned char tile_bank<sgx_tile_bank>, unsigned char *tile_addr<sgx_tile_addr>, unsigned char num_tiles<sgx_num_tiles>, unsigned char palette_table_bank<sgx_attr_bank>, unsigned char *palette_table_addr<sgx_attr_addr>, unsigned char tile_type<sgx_tile_type> );
  700                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-map.h", 38; extern void __fastcall __nop set_map_data( unsigned char __far *map<vdc_map_bank:vdc_map_addr>, unsigned char w<vdc_map_width>, unsigned char h<vdc_map_height> );
  701                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-map.h", 39; extern void __fastcall __nop sgx_set_map_data( unsigned char __far *map<sgx_map_bank:sgx_map_addr>, unsigned char w<sgx_map_width>, unsigned char h<sgx_map_height> );
  702                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-map.h", 41; extern void __fastcall __nop set_far_map_data( unsigned char map_bank<vdc_map_bank>, unsigned char *map_addr<vdc_map_addr>, unsigned char w<vdc_map_width>, unsigned char h<vdc_map_height> );
  703                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-map.h", 42; extern void __fastcall __nop sgx_set_far_map_data( unsigned char map_bank<vdc_map_bank>, unsigned char *map_addr<vdc_map_addr>, unsigned char w<sgx_map_width>, unsigned char h<sgx_map_height> );
  704                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-map.h", 44; extern void __fastcall load_tile( unsigned int vram<_di> );
  705                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-map.h", 45; extern void __fastcall sgx_load_tile( unsigned int vram<_di> );
  706                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-map.h", 47; extern void __fastcall load_map( unsigned char bat_x<_al>, unsigned char bat_y<_ah>, int map_x<_bx>, int map_y<_dx>, unsigned char tiles_w<_cl>, unsigned char tiles_h<_ch> );
  707                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-map.h", 48; extern void __fastcall sgx_load_map( unsigned char bat_x<_al>, unsigned char bat_y<_ah>, int map_x<_bx>, int map_y<_dx>, unsigned char tiles_w<_cl>, unsigned char tiles_h<_ch> );
  708                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-map.h", 50; extern unsigned char __fastcall map_get_tile( unsigned char map_x<_bl>, unsigned char map_y<_bh> );
  709                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-map.h", 51; extern unsigned char __fastcall sgx_map_get_tile( unsigned char map_x<_bl>, unsigned char map_y<_bh> );
  710                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-map.h", 53; extern void __fastcall map_put_tile( unsigned char map_x<_bl>, unsigned char map_y<_bh>, unsigned char tile<_al> );
  711                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-map.h", 54; extern void __fastcall sgx_map_put_tile( unsigned char map_x<_bl>, unsigned char map_y<_bh>, unsigned char tile<_al> );
  712                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-map.h", 56; extern void __fastcall put_tile( unsigned char tile<_bl>, unsigned char bat_x<_al>, unsigned char bat_y<_ah> );
  713                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-map.h", 57; extern void __fastcall sgx_put_tile( unsigned char tile<_bl>, unsigned char bat_x<_al>, unsigned char bat_y<_ah> );
  714                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-map.h", 59; // Deprecated functions ...
  715                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-map.h", 61; extern void __fastcall set_tile_data( unsigned char *tile_ex<_di> );
  716                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-map.h", 63; extern void __fastcall __nop set_map_pals( unsigned char __far *palette_table<vdc_attr_bank:vdc_attr_addr> );
  717                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-map.h", 64; extern void __fastcall __nop set_map_tile_type( unsigned char tile_type<vdc_tile_type> );
  718                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-map.h", 66; extern void __fastcall __nop sgx_set_map_pals( unsigned char __far *palette_table<sgx_attr_bank:sgx_attr_addr> );
  719                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-map.h", 67; extern void __fastcall __nop sgx_set_map_tile_type( unsigned char tile_type<sgx_tile_type> );
  720                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-map.h", 69; extern void __fastcall set_map_tile_base( unsigned int vram<_di> );
  721                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-map.h", 70; extern void __fastcall sgx_set_map_tile_base( unsigned int vram<_di> );
  722                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-map.h", 72; #endif // __HUCC__
  723                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-map.h", 74; #endif // _hucc_old_map_h
  724                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 40; #include "hucc-old-line.h"
  725                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-line.h", 1; #ifndef _hucc_old_line_h
  726                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-line.h", 2; #define _hucc_old_line_h
  727                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-line.h", 4; /****************************************************************************
  728                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-line.h", 5; ; ***************************************************************************
  729                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-line.h", 6; ;
  730                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-line.h", 7; ; hucc-old-line.h
  731                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-line.h", 8; ;
  732                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-line.h", 9; ; Based on the original HuC and MagicKit functions by David Michel and the
  733                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-line.h", 10; ; other original HuC developers.
  734                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-line.h", 11; ;
  735                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-line.h", 12; ; Modifications copyright John Brandwood 2024.
  736                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-line.h", 13; ;
  737                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-line.h", 14; ; Distributed under the Boost Software License, Version 1.0.
  738                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-line.h", 15; ; (See accompanying file LICENSE_1_0.txt or copy at
  739                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-line.h", 16; ;  http://www.boost.org/LICENSE_1_0.txt)
  740                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-line.h", 17; ;
  741                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-line.h", 18; ; ***************************************************************************
  742                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-line.h", 19; ; **************************************************************************/
  743                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-line.h", 21; // *************
  744                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-line.h", 22; // Functions in hucc-old-line.asm ...
  745                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-line.h", 23; // *************
  746                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-line.h", 25; #ifdef __HUCC__
  747                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-line.h", 27; #asmdef	HUCC_USES_OLD_LINE 1
  748               0001     	HUCC_USES_OLD_LINE = 1
  749                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-line.h", 29; extern void __fastcall gfx_init( unsigned int start_vram_addr<_ax> );
  750                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-line.h", 30; extern void __fastcall gfx_clear( unsigned int start_vram_addr<_di> );
  751                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-line.h", 31; extern void __fastcall gfx_plot( unsigned int x<_gfx_x1>, unsigned int y<_gfx_y1>, char color<_gfx_color> );
  752                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-line.h", 32; extern void __fastcall gfx_line( unsigned int x1<_gfx_x1>, unsigned int y1<_gfx_y1>, unsigned int x2<_gfx_x2>, unsigned int y2<_gfx_y2>, unsigned char color<_gfx_color> );
  753                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-line.h", 34; #endif // __HUCC__
  754                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-line.h", 36; #endif // _hucc_old_line_h
  755                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 42; #endif // _hucc_legacy_h
  756                        		.dbg	line,	"main.c", 1; #include "huc.h"
  757                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 1; #ifndef _hucc_legacy_h
  758                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 2; #define _hucc_legacy_h
  759                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 4; /****************************************************************************
  760                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 5; ; ***************************************************************************
  761                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 6; ;
  762                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 7; ; huc.h
  763                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 8; ;
  764                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 9; ; HuCC wrapper file to include a default set of HuC-compatible functions.
  765                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 10; ;
  766                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 11; ; Copyright John Brandwood 2024.
  767                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 12; ;
  768                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 13; ; Distributed under the Boost Software License, Version 1.0.
  769                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 14; ; (See accompanying file LICENSE_1_0.txt or copy at
  770                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 15; ;  http://www.boost.org/LICENSE_1_0.txt)
  771                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 16; ;
  772                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 17; ; ***************************************************************************
  773                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 18; ; ***************************************************************************
  774                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 19; ;
  775                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 20; ; When the HuCC compiler is invoked with the "--legacy" option to compile old
  776                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 21; ; projects, then this "huc.h" file is automatically included.
  777                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 22; ;
  778                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 23; ; This file includes a set of the individual HuCC headers which correspond to
  779                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 24; ; HuC's built-in functions and MagicKit library.
  780                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 25; ;
  781                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 26; ; New HuCC projects should, preferably, include the specific headers that are
  782                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 27; ; needed, which will then allow them to replace parts of the standard library
  783                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 28; ; with newer functions, or they can just manually include this "huc.h" file.
  784                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 29; ;
  785                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 30; ; ***************************************************************************
  786                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 31; ; **************************************************************************/
  787                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 33; #include "hucc-systemcard.h"
  788                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 34; #include "hucc-baselib.h"
  789                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 35; #include "hucc-gfx.h"
  790                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 36; #include "hucc-string.h"
  791                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 37; #include "hucc-old-scroll.h"
  792                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 38; #include "hucc-old-spr.h"
  793                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 39; #include "hucc-old-map.h"
  794                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 40; #include "hucc-old-line.h"
  795                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 42; #endif // _hucc_legacy_h
  796                        		.dbg	line,	"main.c", 2; #include "hucc-scroll.h"
  797                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 1; #ifndef _hucc_scroll_h
  798                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 2; #define _hucc_scroll_h
  799                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 4; /****************************************************************************
  800                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 5; ; ***************************************************************************
  801                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 6; ;
  802                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 7; ; hucc-scroll.h
  803                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 8; ;
  804                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 9; ; Routines for a fast split-screen scrolling system.
  805                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 10; ;
  806                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 11; ; Copyright John Brandwood 2024.
  807                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 12; ;
  808                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 13; ; Distributed under the Boost Software License, Version 1.0.
  809                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 14; ; (See accompanying file LICENSE_1_0.txt or copy at
  810                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 15; ;  http://www.boost.org/LICENSE_1_0.txt)
  811                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 16; ;
  812                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 17; ; ***************************************************************************
  813                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 18; ; ***************************************************************************
  814                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 19; ;
  815                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 20; ; The maximum number of splits for each screen layer is set in your project's
  816                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 21; ; "hucc-config.inc" file, with the library having a limit of 128-per-layer.
  817                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 22; ;
  818                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 23; ; Your first active split must be defined to start at screen line 0, and then
  819                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 24; ; the rest of the active splits must be in increasing line order to match the
  820                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 25; ; way that the PC Engine displays the output image.
  821                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 26; ;
  822                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 27; ; You can have disabled splits interleaved with your active splits.
  823                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 28; ;
  824                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 29; ; Splits that are normally disabled can be used to create full screen effects
  825                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 30; ; such as bouncing the screen up and down by adding blank areas at the top or
  826                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 31; ; bottom of the screen, and then rapidly changing the height of those areas.
  827                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 32; ;
  828                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 33; ; ***************************************************************************
  829                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 34; ; **************************************************************************/
  830                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 36; // *************
  831                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 37; // VDC bits for display_flags ...
  832                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 38; // *************
  833                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 40; #ifndef BKG_OFF
  834                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 41; #define BKG_OFF 0x00
  835                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 42; #endif
  836                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 44; #ifndef SPR_OFF
  837                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 45; #define SPR_OFF 0x00
  838                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 46; #endif
  839                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 48; #ifndef BKG_ON
  840                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 49; #define BKG_ON 0x80
  841                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 50; #endif
  842                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 52; #ifndef SPR_ON
  843                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 53; #define SPR_ON 0x40
  844                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 54; #endif
  845                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 56; // *************
  846                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 57; // Functions in hucc-scroll.asm ...
  847                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 58; // *************
  848                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 60; #ifdef __HUCC__
  849                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 62; #asmdef	HUCC_USES_NEW_SCROLL 1
  850               0001     	HUCC_USES_NEW_SCROLL = 1
  851                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 64; extern void __fastcall scroll_split( unsigned char index<_al>, unsigned char screen_line<_ah>, unsigned int bat_x<_bx>, unsigned int bat_y<_cx>, unsigned char display_flags<_dl> );
  852                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 65; extern void __fastcall sgx_scroll_split( unsigned char index<_al>, unsigned char screen_line<_ah>, unsigned int bat_x<_bx>, unsigned int bat_y<_cx>, unsigned char display_flags<_dl> );
  853                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 67; extern void __fastcall disable_split( unsigned char index<acc> );
  854                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 68; extern void __fastcall sgx_disable_split( unsigned char index<acc> );
  855                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 70; extern void __fastcall __macro disable_all_splits( void );
  856                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 71; extern void __fastcall __macro sgx_disable_all_splits( void );
  857                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 73; #asm
  858                        		.dbg	clear
  859                        			.macro	_disable_all_splits
  860                        			ldy	#HUCC_PCE_SPLITS - 1
  861                        	!loop:		tya
  862                        			call	_disable_split.1
  863                        			dey
  864                        			bpl	!loop-
  865                        			.endm
  866                        			.macro	_sgx_disable_all_splits
  867                        			ldy	#HUCC_SGX_SPLITS - 1
  868                        	!loop:		tya
  869                        			call	_sgx_disable_split.1
  870                        			dey
  871                        			bpl	!loop-
  872                        			.endm
  873                        	
  874                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 89; #endasm
  875                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 91; #endif // __HUCC__
  876                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 93; #endif // _hucc_scroll_h
  877                        		.dbg	line,	"main.c", 3; #include "hucc-chrmap.h"
  878                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 1; #ifndef _hucc_chrmap_h
  879                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 2; #define _hucc_chrmap_h
  880                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 4; /****************************************************************************
  881                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 5; ; ***************************************************************************
  882                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 6; ;
  883                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 7; ; hucc-chrmap.h
  884                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 8; ;
  885                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 9; ; A simple map system based on 8x8 characters (aka "tiles") in BAT format.
  886                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 10; ;
  887                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 11; ; Copyright John Brandwood 2025.
  888                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 12; ;
  889                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 13; ; Distributed under the Boost Software License, Version 1.0.
  890                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 14; ; (See accompanying file LICENSE_1_0.txt or copy at
  891                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 15; ;  http://www.boost.org/LICENSE_1_0.txt)
  892                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 16; ;
  893                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 17; ; ***************************************************************************
  894                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 18; ; ***************************************************************************
  895                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 19; ;
  896                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 20; ; The maximum X and Y size for chrmaps is 256 characters (2048 pixels).
  897                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 21; ;
  898                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 22; ; The maximum total size for a chrmap is 16KBytes, which allows for maps up
  899                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 23; ; to 256x32 tiles (2048x256 pixels).
  900                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 24; ;
  901                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 25; ; ***************************************************************************
  902                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 26; ; **************************************************************************/
  903                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 28; // *************
  904                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 29; // This code extends the blkmap library ...
  905                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 30; // *************
  906                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 32; #include "hucc-blkmap.h"
  907                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 1; #ifndef _hucc_blkmap_h
  908                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 2; #define _hucc_blkmap_h
  909                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 4; /****************************************************************************
  910                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 5; ; ***************************************************************************
  911                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 6; ;
  912                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 7; ; hucc-blkmap.h
  913                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 8; ;
  914                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 9; ; A map system based on 16x16 meta-tiles (aka "blocks", aka CHR/BLK/MAP).
  915                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 10; ;
  916                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 11; ; Copyright John Brandwood 2025.
  917                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 12; ;
  918                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 13; ; Distributed under the Boost Software License, Version 1.0.
  919                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 14; ; (See accompanying file LICENSE_1_0.txt or copy at
  920                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 15; ;  http://www.boost.org/LICENSE_1_0.txt)
  921                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 16; ;
  922                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 17; ; ***************************************************************************
  923                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 18; ; ***************************************************************************
  924                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 19; ;
  925                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 20; ; The maximum X and Y size for blkmaps is 128 blocks (2048 pixels).
  926                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 21; ;
  927                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 22; ; The maximum total size for a blkmap is 16KBytes, which allows for maps up
  928                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 23; ; to 128x128 blocks (2048x2048 pixels).
  929                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 24; ;
  930                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 25; ; Huge multi-screen blkmaps are also supported (optionally).
  931                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 26; ;
  932                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 27; ; The maximum X and Y for multi-screen maps is 128 screens (32768 pixels).
  933                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 28; ;
  934                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 29; ; The maximum total size for a multi-screen map is 8KBytes, which allows for
  935                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 30; ; a total of 1024 screens.
  936                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 31; ;
  937                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 32; ; ***************************************************************************
  938                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 33; ; **************************************************************************/
  939                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 35; // *************
  940                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 36; // Functions in blkmap.asm ...
  941                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 37; // *************
  942                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 39; #ifdef __HUCC__
  943                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 41; #asmdef	HUCC_USES_BLKMAP 1
  944               0001     	HUCC_USES_BLKMAP = 1
  945                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 43; // Current top-left of drawn map in pixels.
  946                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 44; extern unsigned int   vdc_map_pxl_x;
  947                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 45; extern unsigned int   vdc_map_pxl_y;
  948                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 47; // Width and height to draw/scroll in characters (not tiles).
  949                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 48; extern unsigned char  vdc_map_draw_w;
  950                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 49; extern unsigned char  vdc_map_draw_h;
  951                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 51; // Width of map (or multi-screen BAT) in tiles.
  952                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 52; extern unsigned char  vdc_map_line_w;
  953                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 54; // Width of map in screens (if multi-screen map).
  954                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 55; extern unsigned char  vdc_map_scrn_w;
  955                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 57; // Extra information returned by get_map_block() and sgx_get_map_block(),
  956                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 58; // which are the collision flags and the mask/overlay sprite for the BLK.
  957                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 59; extern unsigned char  map_blk_flag;
  958                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 60; extern unsigned char  map_blk_mask;
  959                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 62; extern unsigned char  vdc_scr_bank;
  960                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 63; extern unsigned char *vdc_scr_addr;
  961                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 65; extern unsigned char  vdc_map_bank;
  962                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 66; extern unsigned char *vdc_map_addr;
  963                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 68; extern unsigned char  vdc_blk_bank;
  964                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 69; extern unsigned char *vdc_blk_addr;
  965                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 71; extern unsigned char  vdc_tbl_bank;
  966                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 72; extern unsigned char *vdc_tbl_addr;
  967                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 74; extern void __fastcall set_blocks( unsigned char __far *blk_def<vdc_blk_bank:vdc_blk_addr>, unsigned char __far *flg_def<vdc_tbl_bank:vdc_tbl_addr>, unsigned char number_of_blocks<_al> );
  968                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 75; extern void __fastcall __macro set_blkmap( unsigned char __far *blk_map<vdc_map_bank:vdc_map_addr>, unsigned char blocks_w<vdc_map_line_w> );
  969                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 76; extern void __fastcall __macro set_multimap( unsigned char __far *multi_map<vdc_scr_bank:vdc_scr_addr>, unsigned char screens_w<vdc_map_scrn_w> );
  970                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 78; extern void __fastcall draw_map( void );
  971                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 79; extern void __fastcall scroll_map( void );
  972                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 81; extern void __fastcall blit_map( unsigned char tile_x<map_bat_x>, unsigned char tile_y<map_bat_y>, unsigned char tile_w<map_draw_x>, unsigned char tile_h<map_draw_y> );
  973                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 83; extern unsigned char __fastcall get_map_block( unsigned int x<map_pxl_x>, unsigned int y<map_pxl_y> );
  974                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 85; #asm
  975                        		.dbg	clear
  976                        			.macro	_set_blkmap.2
  977                        			stz	vdc_scr_bank
  978                        			.endm
  979                        			.macro	_set_multimap.2
  980                        			lda	vdc_bat_width
  981                        			lsr	a
  982                        			sta	vdc_map_line_w
  983                        			.endm
  984                        			.macro	SCREEN
  985                        			db	(((\1) & $1FFF) | $6000) >> 8, bank(\1)
  986                        			db	(((\2) & $1FFF) | $4000) >> 8, bank(\2)
  987                        			db	(((\3) & $1FFF) | $6000) >> 8, bank(\3)
  988                        			dw	(\4)
  989                        			.endm
  990                        	
  991                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 102; #endasm
  992                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 104; #ifdef _SGX
  993                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 106; // Current top-left of drawn map in pixels.
  994                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 107; extern unsigned int   sgx_map_pxl_x;
  995                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 108; extern unsigned int   sgx_map_pxl_y;
  996                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 110; // Width and height to draw/scroll in characters (not tiles).
  997                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 111; extern unsigned char  sgx_map_draw_w;
  998                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 112; extern unsigned char  sgx_map_draw_h;
  999                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 114; // Width of map (or multi-screen BAT) in tiles.
 1000                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 115; extern unsigned char  sgx_map_line_w;
 1001                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 117; // Width of map in screens (if multi-screen map).
 1002                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 118; extern unsigned char  sgx_map_scrn_w;
 1003                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 120; extern unsigned char  sgx_scr_bank;
 1004                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 121; extern unsigned char *sgx_scr_addr;
 1005                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 123; extern unsigned char  sgx_map_bank;
 1006                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 124; extern unsigned char *sgx_map_addr;
 1007                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 126; extern unsigned char  sgx_blk_bank;
 1008                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 127; extern unsigned char *sgx_blk_addr;
 1009                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 129; extern unsigned char  sgx_tbl_bank;
 1010                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 130; extern unsigned char *sgx_tbl_addr;
 1011                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 132; extern void __fastcall sgx_set_blocks( unsigned char __far *blk_def<sgx_blk_bank:sgx_blk_addr>, unsigned char __far *flg_def<sgx_tbl_bank:sgx_tbl_addr>, unsigned char number_of_blocks<_al> );
 1012                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 133; extern void __fastcall __macro sgx_set_blkmap( unsigned char __far *blk_map<sgx_map_bank:sgx_map_addr>, unsigned char blocks_w<sgx_map_line_w> );
 1013                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 134; extern void __fastcall __macro sgx_set_multimap( unsigned char __far *multi_map<sgx_scr_bank:sgx_scr_addr>, unsigned char screens_w<sgx_map_scrn_w> );
 1014                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 136; extern void __fastcall sgx_draw_map( void );
 1015                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 137; extern void __fastcall sgx_scroll_map( void );
 1016                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 139; extern void __fastcall sgx_blit_map( unsigned char tile_x<map_bat_x>, unsigned char tile_y<map_bat_y>, unsigned char tile_w<map_draw_x>, unsigned char tile_h<map_draw_y> );
 1017                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 141; extern unsigned char __fastcall sgx_get_map_block( unsigned int x<map_pxl_x>, unsigned int y<map_pxl_y> );
 1018                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 143; #asm
 1019                        		.dbg	clear
 1020                        			.macro	_sgx_set_blkmap.2
 1021                        			stz	sgx_scr_bank
 1022                        			.endm
 1023                        			.macro	_sgx_set_multimap.2
 1024                        			lda	sgx_bat_width
 1025                        			lsr	a
 1026                        			sta	sgx_map_line_w
 1027                        			.endm
 1028                        	
 1029                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 153; #endasm
 1030                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 155; #endif
 1031                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 157; #endif // __HUCC__
 1032                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 159; #endif // _hucc_blkmap_h
 1033                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 34; // *************
 1034                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 35; // Functions in chrmap.asm ...
 1035                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 36; // *************
 1036                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 38; #ifdef __HUCC__
 1037                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 40; #asmdef	HUCC_USES_CHRMAP 1
 1038               0001     	HUCC_USES_CHRMAP = 1
 1039                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 42; extern void __fastcall __nop set_chrmap( unsigned char __far *chrmap<vdc_map_bank:vdc_map_addr>, unsigned char tiles_w<vdc_map_line_w> );
 1040                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 44; extern void __fastcall draw_bat( void );
 1041                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 45; extern void __fastcall scroll_bat( void );
 1042                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 47; extern void __fastcall blit_bat( unsigned char tile_x<map_bat_x>, unsigned char tile_y<map_bat_y>, unsigned char tile_w<map_draw_x>, unsigned char tile_h<map_draw_y> );
 1043                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 49; #ifdef _SGX
 1044                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 51; extern void __fastcall __nop sgx_set_chrmap( unsigned char __far *chrmap<sgx_map_bank:sgx_map_addr>, unsigned char tiles_w<sgx_map_line_w> );
 1045                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 53; extern void __fastcall sgx_draw_bat( void );
 1046                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 54; extern void __fastcall sgx_scroll_bat( void );
 1047                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 56; extern void __fastcall sgx_blit_bat( unsigned char tile_x<map_bat_x>, unsigned char tile_y<map_bat_y>, unsigned char tile_w<map_draw_x>, unsigned char tile_h<map_draw_y> );
 1048                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 58; #endif
 1049                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 60; #endif // __HUCC__
 1050                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 62; #endif // _hucc_chrmap_h
 1051                        		.dbg	line,	"main.c", 4; #include "hucc-blkmap.h"
 1052                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 1; #ifndef _hucc_blkmap_h
 1053                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 2; #define _hucc_blkmap_h
 1054                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 4; /****************************************************************************
 1055                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 5; ; ***************************************************************************
 1056                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 6; ;
 1057                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 7; ; hucc-blkmap.h
 1058                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 8; ;
 1059                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 9; ; A map system based on 16x16 meta-tiles (aka "blocks", aka CHR/BLK/MAP).
 1060                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 10; ;
 1061                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 11; ; Copyright John Brandwood 2025.
 1062                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 12; ;
 1063                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 13; ; Distributed under the Boost Software License, Version 1.0.
 1064                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 14; ; (See accompanying file LICENSE_1_0.txt or copy at
 1065                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 15; ;  http://www.boost.org/LICENSE_1_0.txt)
 1066                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 16; ;
 1067                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 17; ; ***************************************************************************
 1068                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 18; ; ***************************************************************************
 1069                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 19; ;
 1070                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 20; ; The maximum X and Y size for blkmaps is 128 blocks (2048 pixels).
 1071                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 21; ;
 1072                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 22; ; The maximum total size for a blkmap is 16KBytes, which allows for maps up
 1073                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 23; ; to 128x128 blocks (2048x2048 pixels).
 1074                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 24; ;
 1075                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 25; ; Huge multi-screen blkmaps are also supported (optionally).
 1076                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 26; ;
 1077                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 27; ; The maximum X and Y for multi-screen maps is 128 screens (32768 pixels).
 1078                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 28; ;
 1079                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 29; ; The maximum total size for a multi-screen map is 8KBytes, which allows for
 1080                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 30; ; a total of 1024 screens.
 1081                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 31; ;
 1082                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 32; ; ***************************************************************************
 1083                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 33; ; **************************************************************************/
 1084                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 35; // *************
 1085                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 36; // Functions in blkmap.asm ...
 1086                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 37; // *************
 1087                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 39; #ifdef __HUCC__
 1088                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 41; #asmdef	HUCC_USES_BLKMAP 1
 1089                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 43; // Current top-left of drawn map in pixels.
 1090                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 44; extern unsigned int   vdc_map_pxl_x;
 1091                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 45; extern unsigned int   vdc_map_pxl_y;
 1092                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 47; // Width and height to draw/scroll in characters (not tiles).
 1093                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 48; extern unsigned char  vdc_map_draw_w;
 1094                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 49; extern unsigned char  vdc_map_draw_h;
 1095                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 51; // Width of map (or multi-screen BAT) in tiles.
 1096                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 52; extern unsigned char  vdc_map_line_w;
 1097                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 54; // Width of map in screens (if multi-screen map).
 1098                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 55; extern unsigned char  vdc_map_scrn_w;
 1099                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 57; // Extra information returned by get_map_block() and sgx_get_map_block(),
 1100                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 58; // which are the collision flags and the mask/overlay sprite for the BLK.
 1101                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 59; extern unsigned char  map_blk_flag;
 1102                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 60; extern unsigned char  map_blk_mask;
 1103                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 62; extern unsigned char  vdc_scr_bank;
 1104                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 63; extern unsigned char *vdc_scr_addr;
 1105                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 65; extern unsigned char  vdc_map_bank;
 1106                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 66; extern unsigned char *vdc_map_addr;
 1107                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 68; extern unsigned char  vdc_blk_bank;
 1108                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 69; extern unsigned char *vdc_blk_addr;
 1109                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 71; extern unsigned char  vdc_tbl_bank;
 1110                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 72; extern unsigned char *vdc_tbl_addr;
 1111                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 74; extern void __fastcall set_blocks( unsigned char __far *blk_def<vdc_blk_bank:vdc_blk_addr>, unsigned char __far *flg_def<vdc_tbl_bank:vdc_tbl_addr>, unsigned char number_of_blocks<_al> );
 1112                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 75; extern void __fastcall __macro set_blkmap( unsigned char __far *blk_map<vdc_map_bank:vdc_map_addr>, unsigned char blocks_w<vdc_map_line_w> );
 1113                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 76; extern void __fastcall __macro set_multimap( unsigned char __far *multi_map<vdc_scr_bank:vdc_scr_addr>, unsigned char screens_w<vdc_map_scrn_w> );
 1114                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 78; extern void __fastcall draw_map( void );
 1115                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 79; extern void __fastcall scroll_map( void );
 1116                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 81; extern void __fastcall blit_map( unsigned char tile_x<map_bat_x>, unsigned char tile_y<map_bat_y>, unsigned char tile_w<map_draw_x>, unsigned char tile_h<map_draw_y> );
 1117                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 83; extern unsigned char __fastcall get_map_block( unsigned int x<map_pxl_x>, unsigned int y<map_pxl_y> );
 1118                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 85; #asm
 1119                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 86; .macro	_set_blkmap.2
 1120                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 87; stz	vdc_scr_bank
 1121                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 88; .endm
 1122                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 90; .macro	_set_multimap.2
 1123                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 91; lda	vdc_bat_width
 1124                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 92; lsr	a
 1125                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 93; sta	vdc_map_line_w
 1126                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 94; .endm
 1127                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 96; .macro	SCREEN
 1128                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 97; db	(((\1) & $1FFF) | $6000) >> 8, bank(\1)
 1129                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 98; db	(((\2) & $1FFF) | $4000) >> 8, bank(\2)
 1130                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 99; db	(((\3) & $1FFF) | $6000) >> 8, bank(\3)
 1131                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 100; dw	(\4)
 1132                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 101; .endm
 1133                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 102; #endasm
 1134                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 104; #ifdef _SGX
 1135                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 106; // Current top-left of drawn map in pixels.
 1136                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 107; extern unsigned int   sgx_map_pxl_x;
 1137                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 108; extern unsigned int   sgx_map_pxl_y;
 1138                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 110; // Width and height to draw/scroll in characters (not tiles).
 1139                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 111; extern unsigned char  sgx_map_draw_w;
 1140                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 112; extern unsigned char  sgx_map_draw_h;
 1141                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 114; // Width of map (or multi-screen BAT) in tiles.
 1142                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 115; extern unsigned char  sgx_map_line_w;
 1143                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 117; // Width of map in screens (if multi-screen map).
 1144                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 118; extern unsigned char  sgx_map_scrn_w;
 1145                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 120; extern unsigned char  sgx_scr_bank;
 1146                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 121; extern unsigned char *sgx_scr_addr;
 1147                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 123; extern unsigned char  sgx_map_bank;
 1148                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 124; extern unsigned char *sgx_map_addr;
 1149                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 126; extern unsigned char  sgx_blk_bank;
 1150                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 127; extern unsigned char *sgx_blk_addr;
 1151                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 129; extern unsigned char  sgx_tbl_bank;
 1152                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 130; extern unsigned char *sgx_tbl_addr;
 1153                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 132; extern void __fastcall sgx_set_blocks( unsigned char __far *blk_def<sgx_blk_bank:sgx_blk_addr>, unsigned char __far *flg_def<sgx_tbl_bank:sgx_tbl_addr>, unsigned char number_of_blocks<_al> );
 1154                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 133; extern void __fastcall __macro sgx_set_blkmap( unsigned char __far *blk_map<sgx_map_bank:sgx_map_addr>, unsigned char blocks_w<sgx_map_line_w> );
 1155                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 134; extern void __fastcall __macro sgx_set_multimap( unsigned char __far *multi_map<sgx_scr_bank:sgx_scr_addr>, unsigned char screens_w<sgx_map_scrn_w> );
 1156                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 136; extern void __fastcall sgx_draw_map( void );
 1157                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 137; extern void __fastcall sgx_scroll_map( void );
 1158                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 139; extern void __fastcall sgx_blit_map( unsigned char tile_x<map_bat_x>, unsigned char tile_y<map_bat_y>, unsigned char tile_w<map_draw_x>, unsigned char tile_h<map_draw_y> );
 1159                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 141; extern unsigned char __fastcall sgx_get_map_block( unsigned int x<map_pxl_x>, unsigned int y<map_pxl_y> );
 1160                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 143; #asm
 1161                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 144; .macro	_sgx_set_blkmap.2
 1162                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 145; stz	sgx_scr_bank
 1163                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 146; .endm
 1164                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 148; .macro	_sgx_set_multimap.2
 1165                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 149; lda	sgx_bat_width
 1166                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 150; lsr	a
 1167                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 151; sta	sgx_map_line_w
 1168                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 152; .endm
 1169                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 153; #endasm
 1170                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 155; #endif
 1171                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 157; #endif // __HUCC__
 1172                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 159; #endif // _hucc_blkmap_h
 1173                        		.dbg	line,	"main.c", 7; #include "include/constants.c"
 1174                        		.dbg	line,	"include\constants.c", 1; //*****************************************************************************//
 1175                        		.dbg	line,	"include\constants.c", 2; //                                                                             //
 1176                        		.dbg	line,	"include\constants.c", 3; //                                SYSTEM CONSTANTS                             //
 1177                        		.dbg	line,	"include\constants.c", 4; //                                                                             //
 1178                        		.dbg	line,	"include\constants.c", 5; //*****************************************************************************//
 1179                        		.dbg	line,	"include\constants.c", 7; #define FALSE 0
 1180                        		.dbg	line,	"include\constants.c", 8; #define TRUE  1
 1181                        		.dbg	line,	"include\constants.c", 10; #define YES   1
 1182                        		.dbg	line,	"include\constants.c", 11; #define NO    2
 1183                        		.dbg	line,	"include\constants.c", 13; #define JOYPAD_1 0
 1184                        		.dbg	line,	"include\constants.c", 14; #define JOYPAD_2 1
 1185                        		.dbg	line,	"include\constants.c", 16; #define BAT_SIZE_W 2048 // IN PIXELS
 1186                        		.dbg	line,	"include\constants.c", 17; #define BAT_SIZE_H 256  // IN PIXELS
 1187                        		.dbg	line,	"include\constants.c", 19; #define NUMBERS_FONT_VRAM_ADR   0x0900
 1188                        		.dbg	line,	"include\constants.c", 21; #define JOY_DIR_PRESSED (JOY_DOWN | JOY_UP | JOY_RIGHT | JOY_LEFT)
 1189                        		.dbg	line,	"include\constants.c", 24; #define TILES_1   16
 1190                        		.dbg	line,	"include\constants.c", 25; #define TILES_2   32
 1191                        		.dbg	line,	"include\constants.c", 26; #define TILES_3   48
 1192                        		.dbg	line,	"include\constants.c", 27; #define TILES_4   64
 1193                        		.dbg	line,	"include\constants.c", 28; #define TILES_8   128
 1194                        		.dbg	line,	"include\constants.c", 29; #define TILES_16  256
 1195                        		.dbg	line,	"include\constants.c", 30; #define TILES_32  512
 1196                        		.dbg	line,	"include\constants.c", 31; #define TILES_48  768
 1197                        		.dbg	line,	"include\constants.c", 32; #define TILES_64  1024
 1198                        		.dbg	line,	"include\constants.c", 33; #define TILES_80  1280
 1199                        		.dbg	line,	"include\constants.c", 34; #define TILES_96  1536
 1200                        		.dbg	line,	"include\constants.c", 37; #define OFFSET_PLAYER_WALK_1     512
 1201                        		.dbg	line,	"include\constants.c", 38; #define OFFSET_PLAYER_WALK_2     1024
 1202                        		.dbg	line,	"include\constants.c", 39; #define OFFSET_PLAYER_WALK_3     1536
 1203                        		.dbg	line,	"include\constants.c", 40; #define OFFSET_PLAYER_WALK_4     2048
 1204                        		.dbg	line,	"include\constants.c", 41; #define OFFSET_PLAYER_WALK_5     2560
 1205                        		.dbg	line,	"include\constants.c", 42; #define OFFSET_PLAYER_WALK_6     3072
 1206                        		.dbg	line,	"include\constants.c", 44; #define OFFSET_PLAYER_JUMP       3584
 1207                        		.dbg	line,	"include\constants.c", 45; #define OFFSET_PLAYER_CROUCH     4096
 1208                        		.dbg	line,	"include\constants.c", 46; #define OFFSET_PLAYER_HANG       4608
 1209                        		.dbg	line,	"include\constants.c", 48; #define OFFSET_PLAYER_CLIMB_1    5120
 1210                        		.dbg	line,	"include\constants.c", 49; #define OFFSET_PLAYER_CLIMB_2    5632
 1211                        		.dbg	line,	"include\constants.c", 50; #define OFFSET_PLAYER_CLIMB_3    6144
 1212                        		.dbg	line,	"include\constants.c", 51; #define OFFSET_PLAYER_CLIMB_4    6656
 1213                        		.dbg	line,	"include\constants.c", 53; #define OFFSET_PLAYER_FALL       7680
 1214                        		.dbg	line,	"include\constants.c", 60; #define SEQUENCE_TITLE      0
 1215                        		.dbg	line,	"include\constants.c", 61; #define SEQUENCE_INTRO      1
 1216                        		.dbg	line,	"include\constants.c", 62; #define SEQUENCE_GAME       2
 1217                        		.dbg	line,	"include\constants.c", 63; #define SEQUENCE_NPC        3
 1218                        		.dbg	line,	"include\constants.c", 64; #define SEQUENCE_SHOP       4
 1219                        		.dbg	line,	"include\constants.c", 67; #define CAMERA_RECENTER_VELOCITY    4
 1220                        		.dbg	line,	"include\constants.c", 72; //-----------------------------------------------------------------------------//
 1221                        		.dbg	line,	"include\constants.c", 73; //                                                                             //
 1222                        		.dbg	line,	"include\constants.c", 74; //                                   PLAYER                                    //
 1223                        		.dbg	line,	"include\constants.c", 75; //                                                                             //
 1224                        		.dbg	line,	"include\constants.c", 76; //-----------------------------------------------------------------------------//
 1225                        		.dbg	line,	"include\constants.c", 78; #define AXIS_RIGHT          0
 1226                        		.dbg	line,	"include\constants.c", 79; #define AXIS_LEFT           1
 1227                        		.dbg	line,	"include\constants.c", 80; #define AXIS_UP             2
 1228                        		.dbg	line,	"include\constants.c", 81; #define AXIS_DOWN           3
 1229                        		.dbg	line,	"include\constants.c", 85; #define STATE_IDLE          0
 1230                        		.dbg	line,	"include\constants.c", 86; #define STATE_WALK          1
 1231                        		.dbg	line,	"include\constants.c", 87; #define STATE_PUNCH         2
 1232                        		.dbg	line,	"include\constants.c", 88; #define STATE_JUMP          4
 1233                        		.dbg	line,	"include\constants.c", 89; #define STATE_JUMP_RIGHT    5
 1234                        		.dbg	line,	"include\constants.c", 90; #define STATE_JUMP_LEFT     6
 1235                        		.dbg	line,	"include\constants.c", 91; #define STATE_CROUCH        7
 1236                        		.dbg	line,	"include\constants.c", 92; #define STATE_CROUCH_PUNCH  8
 1237                        		.dbg	line,	"include\constants.c", 93; #define STATE_FALL          9
 1238                        		.dbg	line,	"include\constants.c", 94; #define STATE_HANG          10
 1239                        		.dbg	line,	"include\constants.c", 95; #define STATE_CLIMB_UP      11
 1240                        		.dbg	line,	"include\constants.c", 96; #define STATE_CLIMB_DOWN    12
 1241                        		.dbg	line,	"include\constants.c", 97; #define STATE_JUMP_LADDER   13
 1242                        		.dbg	line,	"include\constants.c", 101; #define PLAYER_VRAM_ADR     0x1800
 1243                        		.dbg	line,	"include\constants.c", 103; #define PLAYER_BASE_Y_POS   128
 1244                        		.dbg	line,	"include\constants.c", 106; #define RESPAWN_DEAD        1
 1245                        		.dbg	line,	"include\constants.c", 107; #define RESPAWN_SHOP        2
 1246                        		.dbg	line,	"include\constants.c", 112; //-----------------------------------------------------------------------------//
 1247                        		.dbg	line,	"include\constants.c", 113; //                                                                             //
 1248                        		.dbg	line,	"include\constants.c", 114; //                                  COLLISIONS                                 //
 1249                        		.dbg	line,	"include\constants.c", 115; //                                                                             //
 1250                        		.dbg	line,	"include\constants.c", 116; //-----------------------------------------------------------------------------//
 1251                        		.dbg	line,	"include\constants.c", 118; #define TILE_EMPTY          0
 1252                        		.dbg	line,	"include\constants.c", 119; #define TILE_BG             1
 1253                        		.dbg	line,	"include\constants.c", 120; #define TILE_LADDER         2
 1254                        		.dbg	line,	"include\constants.c", 125; //-----------------------------------------------------------------------------//
 1255                        		.dbg	line,	"include\constants.c", 126; //                                                                             //
 1256                        		.dbg	line,	"include\constants.c", 127; //                                     HUD                                     //
 1257                        		.dbg	line,	"include\constants.c", 128; //                                                                             //
 1258                        		.dbg	line,	"include\constants.c", 129; //-----------------------------------------------------------------------------//
 1259                        		.dbg	line,	"include\constants.c", 131; #define LIFEBAR_1_VRAM_ADR      0x1000
 1260                        		.dbg	line,	"include\constants.c", 132; #define LIFEBAR_2_VRAM_ADR      LIFEBAR_1_VRAM_ADR+TILES_2
 1261                        		.dbg	line,	"include\constants.c", 133; #define LIFEBAR_3_VRAM_ADR      LIFEBAR_2_VRAM_ADR+TILES_2
 1262                        		.dbg	line,	"include\constants.c", 134; #define LIFEBAR_4_VRAM_ADR      LIFEBAR_3_VRAM_ADR+TILES_2
 1263                        		.dbg	line,	"include\constants.c", 135; #define LIFEBAR_5_VRAM_ADR      LIFEBAR_4_VRAM_ADR+TILES_2
 1264                        		.dbg	line,	"include\constants.c", 137; #define WEAPON_VRAM_ADR         LIFEBAR_5_VRAM_ADR+TILES_2
 1265                        		.dbg	line,	"include\constants.c", 138; #define ARMOR_VRAM_ADR          WEAPON_VRAM_ADR+TILES_4
 1266                        		.dbg	line,	"include\constants.c", 143; //-----------------------------------------------------------------------------//
 1267                        		.dbg	line,	"include\constants.c", 144; //                                                                             //
 1268                        		.dbg	line,	"include\constants.c", 145; //                                    LEVELS                                   //
 1269                        		.dbg	line,	"include\constants.c", 146; //                                                                             //
 1270                        		.dbg	line,	"include\constants.c", 147; //-----------------------------------------------------------------------------//
 1271                        		.dbg	line,	"include\constants.c", 149; #define LV1_WALL_VRAM_ADR       0x1000
 1272                        		.dbg	line,	"include\constants.c", 150; #define LV1_DOOR_VRAM_ADR       LV1_WALL_VRAM_ADR+256
 1273                        		.dbg	line,	"include\constants.c", 153; #define OBJECT_NUMBER_LV1       23
 1274                        		.dbg	line,	"include\constants.c", 154; #define CHEST_NUMBER_LV1        2
 1275                        		.dbg	line,	"include\constants.c", 155; #define NPC_NUMBER_LV1          2
 1276                        		.dbg	line,	"include\constants.c", 157; #define OBJECT_START_INDEX_LV1  3
 1277                        		.dbg	line,	"include\constants.c", 158; #define CHEST_START_INDEX_LV1   OBJECT_START_INDEX_LV1+OBJECT_NUMBER_LV1
 1278                        		.dbg	line,	"include\constants.c", 159; #define NPC_START_INDEX_LV1     CHEST_START_INDEX_LV1+CHEST_NUMBER_LV1
 1279                        		.dbg	line,	"include\constants.c", 164; //-----------------------------------------------------------------------------//
 1280                        		.dbg	line,	"include\constants.c", 165; //                                                                             //
 1281                        		.dbg	line,	"include\constants.c", 166; //                                   OBJECT                                    //
 1282                        		.dbg	line,	"include\constants.c", 167; //                                                                             //
 1283                        		.dbg	line,	"include\constants.c", 168; //-----------------------------------------------------------------------------//
 1284                        		.dbg	line,	"include\constants.c", 170; #define TYPE_HOURGLASS          0
 1285                        		.dbg	line,	"include\constants.c", 171; #define TYPE_POT                1
 1286                        		.dbg	line,	"include\constants.c", 172; #define TYPE_POW                2
 1287                        		.dbg	line,	"include\constants.c", 173; #define TYPE_CHEST              3
 1288                        		.dbg	line,	"include\constants.c", 174; #define TYPE_GRAY_KEY           4
 1289                        		.dbg	line,	"include\constants.c", 175; #define TYPE_GOLD_KEY           5
 1290                        		.dbg	line,	"include\constants.c", 176; #define TYPE_1UP                6
 1291                        		.dbg	line,	"include\constants.c", 177; #define TYPE_COIN_1             7
 1292                        		.dbg	line,	"include\constants.c", 178; #define TYPE_COIN_5             8
 1293                        		.dbg	line,	"include\constants.c", 179; #define TYPE_COIN_10            9
 1294                        		.dbg	line,	"include\constants.c", 180; #define TYPE_COIN_50            10
 1295                        		.dbg	line,	"include\constants.c", 181; #define TYPE_COIN_100           11
 1296                        		.dbg	line,	"include\constants.c", 182; #define TYPE_COIN_500           12
 1297                        		.dbg	line,	"include\constants.c", 183; #define TYPE_COIN_1000          13
 1298                        		.dbg	line,	"include\constants.c", 184; #define TYPE_YASHICHI           14
 1299                        		.dbg	line,	"include\constants.c", 187; #define STATE_ACTIVE            0
 1300                        		.dbg	line,	"include\constants.c", 188; #define STATE_INACTIVE          1
 1301                        		.dbg	line,	"include\constants.c", 190; #define OBJECT_MARGIN           10//9
 1302                        		.dbg	line,	"include\constants.c", 193; #define POT1_VRAM_ADR           0x1C00
 1303                        		.dbg	line,	"include\constants.c", 194; #define POT2_VRAM_ADR           POT1_VRAM_ADR+TILES_4
 1304                        		.dbg	line,	"include\constants.c", 195; #define POT3_VRAM_ADR           POT2_VRAM_ADR+TILES_4
 1305                        		.dbg	line,	"include\constants.c", 196; #define POT4_VRAM_ADR           POT3_VRAM_ADR+TILES_4
 1306                        		.dbg	line,	"include\constants.c", 197; #define POT5_VRAM_ADR           POT4_VRAM_ADR+TILES_4
 1307                        		.dbg	line,	"include\constants.c", 198; #define POT6_VRAM_ADR           POT5_VRAM_ADR+TILES_4
 1308                        		.dbg	line,	"include\constants.c", 199; #define POT7_VRAM_ADR           POT6_VRAM_ADR+TILES_4
 1309                        		.dbg	line,	"include\constants.c", 200; #define POT8_VRAM_ADR           POT7_VRAM_ADR+TILES_4
 1310                        		.dbg	line,	"include\constants.c", 202; #define POW_VRAM_ADR            POT8_VRAM_ADR+TILES_4
 1311                        		.dbg	line,	"include\constants.c", 203; #define GRAY_KEY_VRAM_ADR       POW_VRAM_ADR+TILES_4
 1312                        		.dbg	line,	"include\constants.c", 204; #define GOLD_KEY_VRAM_ADR       GRAY_KEY_VRAM_ADR+TILES_4
 1313                        		.dbg	line,	"include\constants.c", 205; #define LIFE_VRAM_ADR           GOLD_KEY_VRAM_ADR+TILES_4
 1314                        		.dbg	line,	"include\constants.c", 207; #define COIN_1_VRAM_ADR         LIFE_VRAM_ADR+TILES_4
 1315                        		.dbg	line,	"include\constants.c", 208; #define COIN_5_VRAM_ADR         COIN_1_VRAM_ADR+TILES_4
 1316                        		.dbg	line,	"include\constants.c", 209; #define COIN_10_VRAM_ADR        COIN_5_VRAM_ADR+TILES_4
 1317                        		.dbg	line,	"include\constants.c", 210; #define COIN_50_VRAM_ADR        COIN_10_VRAM_ADR+TILES_4
 1318                        		.dbg	line,	"include\constants.c", 211; #define COIN_100_VRAM_ADR       COIN_50_VRAM_ADR+TILES_4
 1319                        		.dbg	line,	"include\constants.c", 212; #define COIN_500_VRAM_ADR       COIN_100_VRAM_ADR+TILES_4
 1320                        		.dbg	line,	"include\constants.c", 213; #define COIN_1000_VRAM_ADR      COIN_500_VRAM_ADR+TILES_4
 1321                        		.dbg	line,	"include\constants.c", 215; #define STAR_VRAM_ADR           COIN_1000_VRAM_ADR+TILES_4
 1322                        		.dbg	line,	"include\constants.c", 216; #define OCTOPUS_VRAM_ADR        STAR_VRAM_ADR+TILES_4
 1323                        		.dbg	line,	"include\constants.c", 217; #define FRUIT_VRAM_ADR          OCTOPUS_VRAM_ADR+TILES_4
 1324                        		.dbg	line,	"include\constants.c", 218; #define BARREL_VRAM_ADR         FRUIT_VRAM_ADR+TILES_4
 1325                        		.dbg	line,	"include\constants.c", 219; #define HOURGLASS_VRAM_ADR      BARREL_VRAM_ADR+TILES_4
 1326                        		.dbg	line,	"include\constants.c", 220; #define BAMBOO_VRAM_ADR         HOURGLASS_VRAM_ADR+TILES_4
 1327                        		.dbg	line,	"include\constants.c", 221; #define YASHICHI_VRAM_ADR       BAMBOO_VRAM_ADR+TILES_4
 1328                        		.dbg	line,	"include\constants.c", 222; #define ELEPHANT_VRAM_ADR       YASHICHI_VRAM_ADR+TILES_4
 1329                        		.dbg	line,	"include\constants.c", 223; #define DRAGONFLY_VRAM_ADR      ELEPHANT_VRAM_ADR+TILES_4
 1330                        		.dbg	line,	"include\constants.c", 224; #define COW_VRAM_ADR            DRAGONFLY_VRAM_ADR+TILES_4
 1331                        		.dbg	line,	"include\constants.c", 225; #define MOBICHAN_VRAM_ADR       COW_VRAM_ADR+TILES_4
 1332                        		.dbg	line,	"include\constants.c", 227; #define CHEST_VRAM_ADR          0x2400
 1333                        		.dbg	line,	"include\constants.c", 228; #define NPC_VRAM_ADR            CHEST_VRAM_ADR+TILES_96
 1334                        		.dbg	line,	"include\constants.c", 233; //-----------------------------------------------------------------------------//
 1335                        		.dbg	line,	"include\constants.c", 234; //                                                                             //
 1336                        		.dbg	line,	"include\constants.c", 235; //                                    NPC                                      //
 1337                        		.dbg	line,	"include\constants.c", 236; //                                                                             //
 1338                        		.dbg	line,	"include\constants.c", 237; //-----------------------------------------------------------------------------//
 1339                        		.dbg	line,	"include\constants.c", 239; #define TYPE_NPC_REWARD         0
 1340                        		.dbg	line,	"include\constants.c", 240; #define TYPE_NPC_SHOP           1
 1341                        		.dbg	line,	"include\constants.c", 245; //-----------------------------------------------------------------------------//
 1342                        		.dbg	line,	"include\constants.c", 246; //                                                                             //
 1343                        		.dbg	line,	"include\constants.c", 247; //                                    SHOP                                     //
 1344                        		.dbg	line,	"include\constants.c", 248; //                                                                             //
 1345                        		.dbg	line,	"include\constants.c", 249; //-----------------------------------------------------------------------------//
 1346                        		.dbg	line,	"include\constants.c", 251; #define SHOP_PHASE_ENTER        0
 1347                        		.dbg	line,	"include\constants.c", 252; #define SHOP_PHASE_BUY          1
 1348                        		.dbg	line,	"include\constants.c", 253; #define SHOP_PHASE_EXIT         2
 1349                        		.dbg	line,	"include\constants.c", 255; #define TYPE_ITEM_WEAPON_2      0
 1350                        		.dbg	line,	"include\constants.c", 256; #define TYPE_ITEM_WEAPON_3      1
 1351                        		.dbg	line,	"include\constants.c", 257; #define TYPE_ITEM_WEAPON_4      2
 1352                        		.dbg	line,	"include\constants.c", 258; #define TYPE_ITEM_WEAPON_5      3
 1353                        		.dbg	line,	"include\constants.c", 259; #define TYPE_ITEM_KEY           4
 1354                        		.dbg	line,	"include\constants.c", 261; #define TYPE_ITEM_ARMOR_2       5
 1355                        		.dbg	line,	"include\constants.c", 262; #define TYPE_ITEM_ARMOR_3       6
 1356                        		.dbg	line,	"include\constants.c", 263; #define TYPE_ITEM_ARMOR_4       7
 1357                        		.dbg	line,	"include\constants.c", 264; #define TYPE_ITEM_ARMOR_5       8
 1358                        		.dbg	line,	"include\constants.c", 265; #define TYPE_ITEM_POTION        9
 1359                        		.dbg	line,	"main.c", 8; #include "include/variables.c"
 1360                        		.dbg	line,	"include\variables.c", 1; #include "huc.h"
 1361                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 1; #ifndef _hucc_legacy_h
 1362                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 2; #define _hucc_legacy_h
 1363                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 4; /****************************************************************************
 1364                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 5; ; ***************************************************************************
 1365                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 6; ;
 1366                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 7; ; huc.h
 1367                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 8; ;
 1368                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 9; ; HuCC wrapper file to include a default set of HuC-compatible functions.
 1369                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 10; ;
 1370                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 11; ; Copyright John Brandwood 2024.
 1371                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 12; ;
 1372                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 13; ; Distributed under the Boost Software License, Version 1.0.
 1373                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 14; ; (See accompanying file LICENSE_1_0.txt or copy at
 1374                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 15; ;  http://www.boost.org/LICENSE_1_0.txt)
 1375                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 16; ;
 1376                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 17; ; ***************************************************************************
 1377                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 18; ; ***************************************************************************
 1378                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 19; ;
 1379                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 20; ; When the HuCC compiler is invoked with the "--legacy" option to compile old
 1380                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 21; ; projects, then this "huc.h" file is automatically included.
 1381                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 22; ;
 1382                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 23; ; This file includes a set of the individual HuCC headers which correspond to
 1383                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 24; ; HuC's built-in functions and MagicKit library.
 1384                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 25; ;
 1385                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 26; ; New HuCC projects should, preferably, include the specific headers that are
 1386                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 27; ; needed, which will then allow them to replace parts of the standard library
 1387                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 28; ; with newer functions, or they can just manually include this "huc.h" file.
 1388                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 29; ;
 1389                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 30; ; ***************************************************************************
 1390                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 31; ; **************************************************************************/
 1391                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 33; #include "hucc-systemcard.h"
 1392                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 34; #include "hucc-baselib.h"
 1393                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 35; #include "hucc-gfx.h"
 1394                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 36; #include "hucc-string.h"
 1395                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 37; #include "hucc-old-scroll.h"
 1396                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 38; #include "hucc-old-spr.h"
 1397                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 39; #include "hucc-old-map.h"
 1398                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 40; #include "hucc-old-line.h"
 1399                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 42; #endif // _hucc_legacy_h
 1400                        		.dbg	line,	"include\variables.c", 2; #include "hucc-scroll.h"
 1401                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 1; #ifndef _hucc_scroll_h
 1402                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 2; #define _hucc_scroll_h
 1403                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 4; /****************************************************************************
 1404                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 5; ; ***************************************************************************
 1405                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 6; ;
 1406                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 7; ; hucc-scroll.h
 1407                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 8; ;
 1408                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 9; ; Routines for a fast split-screen scrolling system.
 1409                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 10; ;
 1410                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 11; ; Copyright John Brandwood 2024.
 1411                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 12; ;
 1412                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 13; ; Distributed under the Boost Software License, Version 1.0.
 1413                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 14; ; (See accompanying file LICENSE_1_0.txt or copy at
 1414                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 15; ;  http://www.boost.org/LICENSE_1_0.txt)
 1415                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 16; ;
 1416                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 17; ; ***************************************************************************
 1417                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 18; ; ***************************************************************************
 1418                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 19; ;
 1419                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 20; ; The maximum number of splits for each screen layer is set in your project's
 1420                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 21; ; "hucc-config.inc" file, with the library having a limit of 128-per-layer.
 1421                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 22; ;
 1422                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 23; ; Your first active split must be defined to start at screen line 0, and then
 1423                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 24; ; the rest of the active splits must be in increasing line order to match the
 1424                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 25; ; way that the PC Engine displays the output image.
 1425                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 26; ;
 1426                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 27; ; You can have disabled splits interleaved with your active splits.
 1427                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 28; ;
 1428                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 29; ; Splits that are normally disabled can be used to create full screen effects
 1429                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 30; ; such as bouncing the screen up and down by adding blank areas at the top or
 1430                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 31; ; bottom of the screen, and then rapidly changing the height of those areas.
 1431                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 32; ;
 1432                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 33; ; ***************************************************************************
 1433                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 34; ; **************************************************************************/
 1434                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 36; // *************
 1435                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 37; // VDC bits for display_flags ...
 1436                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 38; // *************
 1437                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 40; #ifndef BKG_OFF
 1438                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 41; #define BKG_OFF 0x00
 1439                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 42; #endif
 1440                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 44; #ifndef SPR_OFF
 1441                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 45; #define SPR_OFF 0x00
 1442                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 46; #endif
 1443                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 48; #ifndef BKG_ON
 1444                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 49; #define BKG_ON 0x80
 1445                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 50; #endif
 1446                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 52; #ifndef SPR_ON
 1447                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 53; #define SPR_ON 0x40
 1448                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 54; #endif
 1449                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 56; // *************
 1450                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 57; // Functions in hucc-scroll.asm ...
 1451                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 58; // *************
 1452                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 60; #ifdef __HUCC__
 1453                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 62; #asmdef	HUCC_USES_NEW_SCROLL 1
 1454                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 64; extern void __fastcall scroll_split( unsigned char index<_al>, unsigned char screen_line<_ah>, unsigned int bat_x<_bx>, unsigned int bat_y<_cx>, unsigned char display_flags<_dl> );
 1455                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 65; extern void __fastcall sgx_scroll_split( unsigned char index<_al>, unsigned char screen_line<_ah>, unsigned int bat_x<_bx>, unsigned int bat_y<_cx>, unsigned char display_flags<_dl> );
 1456                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 67; extern void __fastcall disable_split( unsigned char index<acc> );
 1457                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 68; extern void __fastcall sgx_disable_split( unsigned char index<acc> );
 1458                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 70; extern void __fastcall __macro disable_all_splits( void );
 1459                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 71; extern void __fastcall __macro sgx_disable_all_splits( void );
 1460                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 73; #asm
 1461                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 74; .macro	_disable_all_splits
 1462                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 75; ldy	#HUCC_PCE_SPLITS - 1
 1463                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 76; !loop:		tya
 1464                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 77; call	_disable_split.1
 1465                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 78; dey
 1466                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 79; bpl	!loop-
 1467                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 80; .endm
 1468                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 82; .macro	_sgx_disable_all_splits
 1469                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 83; ldy	#HUCC_SGX_SPLITS - 1
 1470                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 84; !loop:		tya
 1471                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 85; call	_sgx_disable_split.1
 1472                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 86; dey
 1473                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 87; bpl	!loop-
 1474                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 88; .endm
 1475                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 89; #endasm
 1476                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 91; #endif // __HUCC__
 1477                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 93; #endif // _hucc_scroll_h
 1478                        		.dbg	line,	"include\variables.c", 3; #include "hucc-chrmap.h"
 1479                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 1; #ifndef _hucc_chrmap_h
 1480                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 2; #define _hucc_chrmap_h
 1481                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 4; /****************************************************************************
 1482                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 5; ; ***************************************************************************
 1483                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 6; ;
 1484                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 7; ; hucc-chrmap.h
 1485                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 8; ;
 1486                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 9; ; A simple map system based on 8x8 characters (aka "tiles") in BAT format.
 1487                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 10; ;
 1488                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 11; ; Copyright John Brandwood 2025.
 1489                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 12; ;
 1490                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 13; ; Distributed under the Boost Software License, Version 1.0.
 1491                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 14; ; (See accompanying file LICENSE_1_0.txt or copy at
 1492                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 15; ;  http://www.boost.org/LICENSE_1_0.txt)
 1493                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 16; ;
 1494                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 17; ; ***************************************************************************
 1495                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 18; ; ***************************************************************************
 1496                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 19; ;
 1497                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 20; ; The maximum X and Y size for chrmaps is 256 characters (2048 pixels).
 1498                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 21; ;
 1499                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 22; ; The maximum total size for a chrmap is 16KBytes, which allows for maps up
 1500                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 23; ; to 256x32 tiles (2048x256 pixels).
 1501                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 24; ;
 1502                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 25; ; ***************************************************************************
 1503                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 26; ; **************************************************************************/
 1504                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 28; // *************
 1505                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 29; // This code extends the blkmap library ...
 1506                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 30; // *************
 1507                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 32; #include "hucc-blkmap.h"
 1508                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 34; // *************
 1509                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 35; // Functions in chrmap.asm ...
 1510                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 36; // *************
 1511                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 38; #ifdef __HUCC__
 1512                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 40; #asmdef	HUCC_USES_CHRMAP 1
 1513                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 42; extern void __fastcall __nop set_chrmap( unsigned char __far *chrmap<vdc_map_bank:vdc_map_addr>, unsigned char tiles_w<vdc_map_line_w> );
 1514                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 44; extern void __fastcall draw_bat( void );
 1515                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 45; extern void __fastcall scroll_bat( void );
 1516                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 47; extern void __fastcall blit_bat( unsigned char tile_x<map_bat_x>, unsigned char tile_y<map_bat_y>, unsigned char tile_w<map_draw_x>, unsigned char tile_h<map_draw_y> );
 1517                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 49; #ifdef _SGX
 1518                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 51; extern void __fastcall __nop sgx_set_chrmap( unsigned char __far *chrmap<sgx_map_bank:sgx_map_addr>, unsigned char tiles_w<sgx_map_line_w> );
 1519                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 53; extern void __fastcall sgx_draw_bat( void );
 1520                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 54; extern void __fastcall sgx_scroll_bat( void );
 1521                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 56; extern void __fastcall sgx_blit_bat( unsigned char tile_x<map_bat_x>, unsigned char tile_y<map_bat_y>, unsigned char tile_w<map_draw_x>, unsigned char tile_h<map_draw_y> );
 1522                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 58; #endif
 1523                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 60; #endif // __HUCC__
 1524                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 62; #endif // _hucc_chrmap_h
 1525                        		.dbg	line,	"include\variables.c", 4; #include "hucc-blkmap.h"
 1526                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 1; #ifndef _hucc_blkmap_h
 1527                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 2; #define _hucc_blkmap_h
 1528                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 4; /****************************************************************************
 1529                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 5; ; ***************************************************************************
 1530                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 6; ;
 1531                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 7; ; hucc-blkmap.h
 1532                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 8; ;
 1533                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 9; ; A map system based on 16x16 meta-tiles (aka "blocks", aka CHR/BLK/MAP).
 1534                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 10; ;
 1535                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 11; ; Copyright John Brandwood 2025.
 1536                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 12; ;
 1537                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 13; ; Distributed under the Boost Software License, Version 1.0.
 1538                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 14; ; (See accompanying file LICENSE_1_0.txt or copy at
 1539                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 15; ;  http://www.boost.org/LICENSE_1_0.txt)
 1540                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 16; ;
 1541                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 17; ; ***************************************************************************
 1542                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 18; ; ***************************************************************************
 1543                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 19; ;
 1544                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 20; ; The maximum X and Y size for blkmaps is 128 blocks (2048 pixels).
 1545                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 21; ;
 1546                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 22; ; The maximum total size for a blkmap is 16KBytes, which allows for maps up
 1547                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 23; ; to 128x128 blocks (2048x2048 pixels).
 1548                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 24; ;
 1549                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 25; ; Huge multi-screen blkmaps are also supported (optionally).
 1550                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 26; ;
 1551                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 27; ; The maximum X and Y for multi-screen maps is 128 screens (32768 pixels).
 1552                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 28; ;
 1553                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 29; ; The maximum total size for a multi-screen map is 8KBytes, which allows for
 1554                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 30; ; a total of 1024 screens.
 1555                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 31; ;
 1556                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 32; ; ***************************************************************************
 1557                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 33; ; **************************************************************************/
 1558                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 35; // *************
 1559                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 36; // Functions in blkmap.asm ...
 1560                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 37; // *************
 1561                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 39; #ifdef __HUCC__
 1562                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 41; #asmdef	HUCC_USES_BLKMAP 1
 1563                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 43; // Current top-left of drawn map in pixels.
 1564                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 44; extern unsigned int   vdc_map_pxl_x;
 1565                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 45; extern unsigned int   vdc_map_pxl_y;
 1566                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 47; // Width and height to draw/scroll in characters (not tiles).
 1567                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 48; extern unsigned char  vdc_map_draw_w;
 1568                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 49; extern unsigned char  vdc_map_draw_h;
 1569                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 51; // Width of map (or multi-screen BAT) in tiles.
 1570                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 52; extern unsigned char  vdc_map_line_w;
 1571                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 54; // Width of map in screens (if multi-screen map).
 1572                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 55; extern unsigned char  vdc_map_scrn_w;
 1573                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 57; // Extra information returned by get_map_block() and sgx_get_map_block(),
 1574                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 58; // which are the collision flags and the mask/overlay sprite for the BLK.
 1575                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 59; extern unsigned char  map_blk_flag;
 1576                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 60; extern unsigned char  map_blk_mask;
 1577                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 62; extern unsigned char  vdc_scr_bank;
 1578                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 63; extern unsigned char *vdc_scr_addr;
 1579                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 65; extern unsigned char  vdc_map_bank;
 1580                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 66; extern unsigned char *vdc_map_addr;
 1581                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 68; extern unsigned char  vdc_blk_bank;
 1582                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 69; extern unsigned char *vdc_blk_addr;
 1583                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 71; extern unsigned char  vdc_tbl_bank;
 1584                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 72; extern unsigned char *vdc_tbl_addr;
 1585                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 74; extern void __fastcall set_blocks( unsigned char __far *blk_def<vdc_blk_bank:vdc_blk_addr>, unsigned char __far *flg_def<vdc_tbl_bank:vdc_tbl_addr>, unsigned char number_of_blocks<_al> );
 1586                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 75; extern void __fastcall __macro set_blkmap( unsigned char __far *blk_map<vdc_map_bank:vdc_map_addr>, unsigned char blocks_w<vdc_map_line_w> );
 1587                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 76; extern void __fastcall __macro set_multimap( unsigned char __far *multi_map<vdc_scr_bank:vdc_scr_addr>, unsigned char screens_w<vdc_map_scrn_w> );
 1588                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 78; extern void __fastcall draw_map( void );
 1589                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 79; extern void __fastcall scroll_map( void );
 1590                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 81; extern void __fastcall blit_map( unsigned char tile_x<map_bat_x>, unsigned char tile_y<map_bat_y>, unsigned char tile_w<map_draw_x>, unsigned char tile_h<map_draw_y> );
 1591                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 83; extern unsigned char __fastcall get_map_block( unsigned int x<map_pxl_x>, unsigned int y<map_pxl_y> );
 1592                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 85; #asm
 1593                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 86; .macro	_set_blkmap.2
 1594                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 87; stz	vdc_scr_bank
 1595                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 88; .endm
 1596                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 90; .macro	_set_multimap.2
 1597                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 91; lda	vdc_bat_width
 1598                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 92; lsr	a
 1599                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 93; sta	vdc_map_line_w
 1600                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 94; .endm
 1601                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 96; .macro	SCREEN
 1602                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 97; db	(((\1) & $1FFF) | $6000) >> 8, bank(\1)
 1603                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 98; db	(((\2) & $1FFF) | $4000) >> 8, bank(\2)
 1604                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 99; db	(((\3) & $1FFF) | $6000) >> 8, bank(\3)
 1605                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 100; dw	(\4)
 1606                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 101; .endm
 1607                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 102; #endasm
 1608                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 104; #ifdef _SGX
 1609                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 106; // Current top-left of drawn map in pixels.
 1610                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 107; extern unsigned int   sgx_map_pxl_x;
 1611                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 108; extern unsigned int   sgx_map_pxl_y;
 1612                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 110; // Width and height to draw/scroll in characters (not tiles).
 1613                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 111; extern unsigned char  sgx_map_draw_w;
 1614                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 112; extern unsigned char  sgx_map_draw_h;
 1615                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 114; // Width of map (or multi-screen BAT) in tiles.
 1616                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 115; extern unsigned char  sgx_map_line_w;
 1617                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 117; // Width of map in screens (if multi-screen map).
 1618                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 118; extern unsigned char  sgx_map_scrn_w;
 1619                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 120; extern unsigned char  sgx_scr_bank;
 1620                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 121; extern unsigned char *sgx_scr_addr;
 1621                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 123; extern unsigned char  sgx_map_bank;
 1622                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 124; extern unsigned char *sgx_map_addr;
 1623                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 126; extern unsigned char  sgx_blk_bank;
 1624                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 127; extern unsigned char *sgx_blk_addr;
 1625                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 129; extern unsigned char  sgx_tbl_bank;
 1626                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 130; extern unsigned char *sgx_tbl_addr;
 1627                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 132; extern void __fastcall sgx_set_blocks( unsigned char __far *blk_def<sgx_blk_bank:sgx_blk_addr>, unsigned char __far *flg_def<sgx_tbl_bank:sgx_tbl_addr>, unsigned char number_of_blocks<_al> );
 1628                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 133; extern void __fastcall __macro sgx_set_blkmap( unsigned char __far *blk_map<sgx_map_bank:sgx_map_addr>, unsigned char blocks_w<sgx_map_line_w> );
 1629                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 134; extern void __fastcall __macro sgx_set_multimap( unsigned char __far *multi_map<sgx_scr_bank:sgx_scr_addr>, unsigned char screens_w<sgx_map_scrn_w> );
 1630                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 136; extern void __fastcall sgx_draw_map( void );
 1631                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 137; extern void __fastcall sgx_scroll_map( void );
 1632                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 139; extern void __fastcall sgx_blit_map( unsigned char tile_x<map_bat_x>, unsigned char tile_y<map_bat_y>, unsigned char tile_w<map_draw_x>, unsigned char tile_h<map_draw_y> );
 1633                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 141; extern unsigned char __fastcall sgx_get_map_block( unsigned int x<map_pxl_x>, unsigned int y<map_pxl_y> );
 1634                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 143; #asm
 1635                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 144; .macro	_sgx_set_blkmap.2
 1636                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 145; stz	sgx_scr_bank
 1637                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 146; .endm
 1638                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 148; .macro	_sgx_set_multimap.2
 1639                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 149; lda	sgx_bat_width
 1640                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 150; lsr	a
 1641                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 151; sta	sgx_map_line_w
 1642                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 152; .endm
 1643                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 153; #endasm
 1644                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 155; #endif
 1645                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 157; #endif // __HUCC__
 1646                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 159; #endif // _hucc_blkmap_h
 1647                        		.dbg	line,	"include\variables.c", 13; unsigned char   sequence_id,
 1648                        		.dbg	line,	"include\variables.c", 14; sequence_loaded,
 1649                        		.dbg	line,	"include\variables.c", 16; level_id,
 1650                        		.dbg	line,	"include\variables.c", 18; // PLAYER //
 1651                        		.dbg	line,	"include\variables.c", 19; respawn,
 1652                        		.dbg	line,	"include\variables.c", 20; player_id,
 1653                        		.dbg	line,	"include\variables.c", 21; player_state,
 1654                        		.dbg	line,	"include\variables.c", 22; player_axis,
 1655                        		.dbg	line,	"include\variables.c", 23; player_previous_axis,
 1656                        		.dbg	line,	"include\variables.c", 24; player_counter_anim,
 1657                        		.dbg	line,	"include\variables.c", 25; player_index_jump,
 1658                        		.dbg	line,	"include\variables.c", 26; player_index_fall,
 1659                        		.dbg	line,	"include\variables.c", 28; player_naked,
 1660                        		.dbg	line,	"include\variables.c", 30; jump_ladder,
 1661                        		.dbg	line,	"include\variables.c", 31; jump_max_index,
 1662                        		.dbg	line,	"include\variables.c", 33; // ARMOR + WEAPON //
 1663                        		.dbg	line,	"include\variables.c", 34; armor_level,
 1664                        		.dbg	line,	"include\variables.c", 35; weapon_level,
 1665                        		.dbg	line,	"include\variables.c", 37; // HUD //
 1666                        		.dbg	line,	"include\variables.c", 38; life_amount,
 1667                        		.dbg	line,	"include\variables.c", 39; key_amount,
 1668                        		.dbg	line,	"include\variables.c", 40; potion_amount,
 1669                        		.dbg	line,	"include\variables.c", 42; // TIME //
 1670                        		.dbg	line,	"include\variables.c", 43; minutes,
 1671                        		.dbg	line,	"include\variables.c", 44; seconds,
 1672                        		.dbg	line,	"include\variables.c", 45; time_counter,
 1673                        		.dbg	line,	"include\variables.c", 47; minutes_backup,
 1674                        		.dbg	line,	"include\variables.c", 48; seconds_backup,
 1675                        		.dbg	line,	"include\variables.c", 51; // OBJECTS //
 1676                        		.dbg	line,	"include\variables.c", 52; object_start_index,
 1677                        		.dbg	line,	"include\variables.c", 53; level_object_number,
 1678                        		.dbg	line,	"include\variables.c", 54; onscreen_object_number,
 1679                        		.dbg	line,	"include\variables.c", 55; 
 1680                        		.dbg	line,	"include\variables.c", 56; list_object_type[25],
 1681                        		.dbg	line,	"include\variables.c", 57; list_object_state[25],
 1682                        		.dbg	line,	"include\variables.c", 58; list_object_energy[25],
 1683                        		.dbg	line,	"include\variables.c", 59; list_reward_type[25],
 1684                        		.dbg	line,	"include\variables.c", 60; 
 1685                        		.dbg	line,	"include\variables.c", 61; list_onscreen_object[8],
 1686                        		.dbg	line,	"include\variables.c", 62; 
 1687                        		.dbg	line,	"include\variables.c", 63; // CHESTS //
 1688                        		.dbg	line,	"include\variables.c", 64; chest_start_index,
 1689                        		.dbg	line,	"include\variables.c", 65; level_chest_number,
 1690                        		.dbg	line,	"include\variables.c", 66; onscreen_chest_number,
 1691                        		.dbg	line,	"include\variables.c", 67; 
 1692                        		.dbg	line,	"include\variables.c", 68; list_chest_state[8],
 1693                        		.dbg	line,	"include\variables.c", 69; list_onscreen_chest[8],
 1694                        		.dbg	line,	"include\variables.c", 71; // NPC //
 1695                        		.dbg	line,	"include\variables.c", 72; npc_start_index,
 1696                        		.dbg	line,	"include\variables.c", 73; level_npc_number,
 1697                        		.dbg	line,	"include\variables.c", 74; onscreen_npc_number,
 1698                        		.dbg	line,	"include\variables.c", 76; list_npc_type[9],
 1699                        		.dbg	line,	"include\variables.c", 77; list_npc_state[9],
 1700                        		.dbg	line,	"include\variables.c", 78; list_onscreen_npc[9],
 1701                        		.dbg	line,	"include\variables.c", 80; // SHOPS //
 1702                        		.dbg	line,	"include\variables.c", 81; index_x,
 1703                        		.dbg	line,	"include\variables.c", 82; index_y,
 1704                        		.dbg	line,	"include\variables.c", 83; item_index,
 1705                        		.dbg	line,	"include\variables.c", 85; shop_phase,
 1706                        		.dbg	line,	"include\variables.c", 86; shop_counter,
 1707                        		.dbg	line,	"include\variables.c", 87; 
 1708                        		.dbg	line,	"include\variables.c", 88; tilemap_mask[256];
 1709                        		.dbg	line,	"include\variables.c", 93; signed int      player_pos_x,
 1710                        		.dbg	line,	"include\variables.c", 94; player_pos_y,
 1711                        		.dbg	line,	"include\variables.c", 95; camera_max_y_position,
 1712                        		.dbg	line,	"include\variables.c", 97; camera_pos_x_backup,
 1713                        		.dbg	line,	"include\variables.c", 98; camera_pos_y_backup,
 1714                        		.dbg	line,	"include\variables.c", 101; list_object_x_pos[25],
 1715                        		.dbg	line,	"include\variables.c", 102; list_object_y_pos[25],
 1716                        		.dbg	line,	"include\variables.c", 103; list_object_x_pos_ref[25],
 1717                        		.dbg	line,	"include\variables.c", 104; list_object_y_pos_ref[25],
 1718                        		.dbg	line,	"include\variables.c", 107; list_chest_x_pos[8],
 1719                        		.dbg	line,	"include\variables.c", 108; list_chest_y_pos[8],
 1720                        		.dbg	line,	"include\variables.c", 109; list_chest_x_pos_ref[8],
 1721                        		.dbg	line,	"include\variables.c", 110; list_chest_y_pos_ref[8],
 1722                        		.dbg	line,	"include\variables.c", 113; list_npc_x_pos[9],
 1723                        		.dbg	line,	"include\variables.c", 114; list_npc_y_pos[9],
 1724                        		.dbg	line,	"include\variables.c", 115; list_npc_x_pos_ref[9],
 1725                        		.dbg	line,	"include\variables.c", 116; list_npc_y_pos_ref[9];
 1726                        		.dbg	line,	"include\variables.c", 117; 
 1727                        		.dbg	line,	"include\variables.c", 121; int             zenny_amount,
 1728                        		.dbg	line,	"include\variables.c", 122; score,
 1729                        		.dbg	line,	"include\variables.c", 124; shop_prices[10];
 1730                        		.dbg	line,	"include\variables.c", 129; extern unsigned char tileset_LV1_BG_B[];
 1731                        		.dbg	line,	"include\variables.c", 130; extern unsigned char multimap_LV1_BG_B[];
 1732                        		.dbg	line,	"include\variables.c", 132; extern unsigned char tileset_HUD[];
 1733                        		.dbg	line,	"include\variables.c", 133; extern unsigned char multimap_LV1_BG_A[];
 1734                        		.dbg	line,	"include\variables.c", 135; extern unsigned char tileset_SHOP_BG_B[];
 1735                        		.dbg	line,	"include\variables.c", 138; int *ptr_SHOP_ITEM_PRICES;
 1736                        		.dbg	line,	"main.c", 11; #include "include/gfx_BG.c"
 1737                        		.dbg	line,	"include\gfx_BG.c", 1; #include "huc.h"
 1738                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 1; #ifndef _hucc_legacy_h
 1739                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 2; #define _hucc_legacy_h
 1740                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 4; /****************************************************************************
 1741                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 5; ; ***************************************************************************
 1742                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 6; ;
 1743                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 7; ; huc.h
 1744                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 8; ;
 1745                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 9; ; HuCC wrapper file to include a default set of HuC-compatible functions.
 1746                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 10; ;
 1747                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 11; ; Copyright John Brandwood 2024.
 1748                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 12; ;
 1749                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 13; ; Distributed under the Boost Software License, Version 1.0.
 1750                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 14; ; (See accompanying file LICENSE_1_0.txt or copy at
 1751                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 15; ;  http://www.boost.org/LICENSE_1_0.txt)
 1752                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 16; ;
 1753                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 17; ; ***************************************************************************
 1754                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 18; ; ***************************************************************************
 1755                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 19; ;
 1756                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 20; ; When the HuCC compiler is invoked with the "--legacy" option to compile old
 1757                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 21; ; projects, then this "huc.h" file is automatically included.
 1758                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 22; ;
 1759                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 23; ; This file includes a set of the individual HuCC headers which correspond to
 1760                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 24; ; HuC's built-in functions and MagicKit library.
 1761                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 25; ;
 1762                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 26; ; New HuCC projects should, preferably, include the specific headers that are
 1763                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 27; ; needed, which will then allow them to replace parts of the standard library
 1764                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 28; ; with newer functions, or they can just manually include this "huc.h" file.
 1765                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 29; ;
 1766                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 30; ; ***************************************************************************
 1767                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 31; ; **************************************************************************/
 1768                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 33; #include "hucc-systemcard.h"
 1769                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 34; #include "hucc-baselib.h"
 1770                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 35; #include "hucc-gfx.h"
 1771                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 36; #include "hucc-string.h"
 1772                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 37; #include "hucc-old-scroll.h"
 1773                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 38; #include "hucc-old-spr.h"
 1774                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 39; #include "hucc-old-map.h"
 1775                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 40; #include "hucc-old-line.h"
 1776                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 42; #endif // _hucc_legacy_h
 1777                        		.dbg	line,	"include\gfx_BG.c", 2; #include "hucc-scroll.h"
 1778                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 1; #ifndef _hucc_scroll_h
 1779                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 2; #define _hucc_scroll_h
 1780                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 4; /****************************************************************************
 1781                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 5; ; ***************************************************************************
 1782                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 6; ;
 1783                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 7; ; hucc-scroll.h
 1784                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 8; ;
 1785                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 9; ; Routines for a fast split-screen scrolling system.
 1786                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 10; ;
 1787                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 11; ; Copyright John Brandwood 2024.
 1788                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 12; ;
 1789                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 13; ; Distributed under the Boost Software License, Version 1.0.
 1790                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 14; ; (See accompanying file LICENSE_1_0.txt or copy at
 1791                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 15; ;  http://www.boost.org/LICENSE_1_0.txt)
 1792                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 16; ;
 1793                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 17; ; ***************************************************************************
 1794                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 18; ; ***************************************************************************
 1795                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 19; ;
 1796                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 20; ; The maximum number of splits for each screen layer is set in your project's
 1797                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 21; ; "hucc-config.inc" file, with the library having a limit of 128-per-layer.
 1798                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 22; ;
 1799                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 23; ; Your first active split must be defined to start at screen line 0, and then
 1800                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 24; ; the rest of the active splits must be in increasing line order to match the
 1801                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 25; ; way that the PC Engine displays the output image.
 1802                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 26; ;
 1803                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 27; ; You can have disabled splits interleaved with your active splits.
 1804                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 28; ;
 1805                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 29; ; Splits that are normally disabled can be used to create full screen effects
 1806                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 30; ; such as bouncing the screen up and down by adding blank areas at the top or
 1807                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 31; ; bottom of the screen, and then rapidly changing the height of those areas.
 1808                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 32; ;
 1809                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 33; ; ***************************************************************************
 1810                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 34; ; **************************************************************************/
 1811                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 36; // *************
 1812                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 37; // VDC bits for display_flags ...
 1813                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 38; // *************
 1814                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 40; #ifndef BKG_OFF
 1815                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 41; #define BKG_OFF 0x00
 1816                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 42; #endif
 1817                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 44; #ifndef SPR_OFF
 1818                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 45; #define SPR_OFF 0x00
 1819                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 46; #endif
 1820                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 48; #ifndef BKG_ON
 1821                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 49; #define BKG_ON 0x80
 1822                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 50; #endif
 1823                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 52; #ifndef SPR_ON
 1824                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 53; #define SPR_ON 0x40
 1825                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 54; #endif
 1826                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 56; // *************
 1827                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 57; // Functions in hucc-scroll.asm ...
 1828                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 58; // *************
 1829                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 60; #ifdef __HUCC__
 1830                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 62; #asmdef	HUCC_USES_NEW_SCROLL 1
 1831                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 64; extern void __fastcall scroll_split( unsigned char index<_al>, unsigned char screen_line<_ah>, unsigned int bat_x<_bx>, unsigned int bat_y<_cx>, unsigned char display_flags<_dl> );
 1832                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 65; extern void __fastcall sgx_scroll_split( unsigned char index<_al>, unsigned char screen_line<_ah>, unsigned int bat_x<_bx>, unsigned int bat_y<_cx>, unsigned char display_flags<_dl> );
 1833                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 67; extern void __fastcall disable_split( unsigned char index<acc> );
 1834                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 68; extern void __fastcall sgx_disable_split( unsigned char index<acc> );
 1835                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 70; extern void __fastcall __macro disable_all_splits( void );
 1836                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 71; extern void __fastcall __macro sgx_disable_all_splits( void );
 1837                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 73; #asm
 1838                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 74; .macro	_disable_all_splits
 1839                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 75; ldy	#HUCC_PCE_SPLITS - 1
 1840                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 76; !loop:		tya
 1841                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 77; call	_disable_split.1
 1842                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 78; dey
 1843                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 79; bpl	!loop-
 1844                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 80; .endm
 1845                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 82; .macro	_sgx_disable_all_splits
 1846                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 83; ldy	#HUCC_SGX_SPLITS - 1
 1847                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 84; !loop:		tya
 1848                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 85; call	_sgx_disable_split.1
 1849                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 86; dey
 1850                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 87; bpl	!loop-
 1851                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 88; .endm
 1852                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 89; #endasm
 1853                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 91; #endif // __HUCC__
 1854                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 93; #endif // _hucc_scroll_h
 1855                        		.dbg	line,	"include\gfx_BG.c", 3; #include "hucc-chrmap.h"
 1856                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 1; #ifndef _hucc_chrmap_h
 1857                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 2; #define _hucc_chrmap_h
 1858                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 4; /****************************************************************************
 1859                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 5; ; ***************************************************************************
 1860                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 6; ;
 1861                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 7; ; hucc-chrmap.h
 1862                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 8; ;
 1863                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 9; ; A simple map system based on 8x8 characters (aka "tiles") in BAT format.
 1864                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 10; ;
 1865                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 11; ; Copyright John Brandwood 2025.
 1866                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 12; ;
 1867                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 13; ; Distributed under the Boost Software License, Version 1.0.
 1868                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 14; ; (See accompanying file LICENSE_1_0.txt or copy at
 1869                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 15; ;  http://www.boost.org/LICENSE_1_0.txt)
 1870                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 16; ;
 1871                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 17; ; ***************************************************************************
 1872                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 18; ; ***************************************************************************
 1873                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 19; ;
 1874                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 20; ; The maximum X and Y size for chrmaps is 256 characters (2048 pixels).
 1875                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 21; ;
 1876                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 22; ; The maximum total size for a chrmap is 16KBytes, which allows for maps up
 1877                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 23; ; to 256x32 tiles (2048x256 pixels).
 1878                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 24; ;
 1879                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 25; ; ***************************************************************************
 1880                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 26; ; **************************************************************************/
 1881                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 28; // *************
 1882                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 29; // This code extends the blkmap library ...
 1883                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 30; // *************
 1884                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 32; #include "hucc-blkmap.h"
 1885                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 34; // *************
 1886                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 35; // Functions in chrmap.asm ...
 1887                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 36; // *************
 1888                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 38; #ifdef __HUCC__
 1889                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 40; #asmdef	HUCC_USES_CHRMAP 1
 1890                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 42; extern void __fastcall __nop set_chrmap( unsigned char __far *chrmap<vdc_map_bank:vdc_map_addr>, unsigned char tiles_w<vdc_map_line_w> );
 1891                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 44; extern void __fastcall draw_bat( void );
 1892                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 45; extern void __fastcall scroll_bat( void );
 1893                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 47; extern void __fastcall blit_bat( unsigned char tile_x<map_bat_x>, unsigned char tile_y<map_bat_y>, unsigned char tile_w<map_draw_x>, unsigned char tile_h<map_draw_y> );
 1894                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 49; #ifdef _SGX
 1895                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 51; extern void __fastcall __nop sgx_set_chrmap( unsigned char __far *chrmap<sgx_map_bank:sgx_map_addr>, unsigned char tiles_w<sgx_map_line_w> );
 1896                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 53; extern void __fastcall sgx_draw_bat( void );
 1897                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 54; extern void __fastcall sgx_scroll_bat( void );
 1898                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 56; extern void __fastcall sgx_blit_bat( unsigned char tile_x<map_bat_x>, unsigned char tile_y<map_bat_y>, unsigned char tile_w<map_draw_x>, unsigned char tile_h<map_draw_y> );
 1899                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 58; #endif
 1900                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 60; #endif // __HUCC__
 1901                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 62; #endif // _hucc_chrmap_h
 1902                        		.dbg	line,	"include\gfx_BG.c", 4; #include "hucc-blkmap.h"
 1903                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 1; #ifndef _hucc_blkmap_h
 1904                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 2; #define _hucc_blkmap_h
 1905                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 4; /****************************************************************************
 1906                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 5; ; ***************************************************************************
 1907                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 6; ;
 1908                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 7; ; hucc-blkmap.h
 1909                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 8; ;
 1910                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 9; ; A map system based on 16x16 meta-tiles (aka "blocks", aka CHR/BLK/MAP).
 1911                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 10; ;
 1912                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 11; ; Copyright John Brandwood 2025.
 1913                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 12; ;
 1914                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 13; ; Distributed under the Boost Software License, Version 1.0.
 1915                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 14; ; (See accompanying file LICENSE_1_0.txt or copy at
 1916                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 15; ;  http://www.boost.org/LICENSE_1_0.txt)
 1917                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 16; ;
 1918                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 17; ; ***************************************************************************
 1919                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 18; ; ***************************************************************************
 1920                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 19; ;
 1921                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 20; ; The maximum X and Y size for blkmaps is 128 blocks (2048 pixels).
 1922                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 21; ;
 1923                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 22; ; The maximum total size for a blkmap is 16KBytes, which allows for maps up
 1924                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 23; ; to 128x128 blocks (2048x2048 pixels).
 1925                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 24; ;
 1926                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 25; ; Huge multi-screen blkmaps are also supported (optionally).
 1927                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 26; ;
 1928                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 27; ; The maximum X and Y for multi-screen maps is 128 screens (32768 pixels).
 1929                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 28; ;
 1930                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 29; ; The maximum total size for a multi-screen map is 8KBytes, which allows for
 1931                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 30; ; a total of 1024 screens.
 1932                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 31; ;
 1933                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 32; ; ***************************************************************************
 1934                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 33; ; **************************************************************************/
 1935                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 35; // *************
 1936                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 36; // Functions in blkmap.asm ...
 1937                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 37; // *************
 1938                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 39; #ifdef __HUCC__
 1939                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 41; #asmdef	HUCC_USES_BLKMAP 1
 1940                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 43; // Current top-left of drawn map in pixels.
 1941                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 44; extern unsigned int   vdc_map_pxl_x;
 1942                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 45; extern unsigned int   vdc_map_pxl_y;
 1943                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 47; // Width and height to draw/scroll in characters (not tiles).
 1944                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 48; extern unsigned char  vdc_map_draw_w;
 1945                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 49; extern unsigned char  vdc_map_draw_h;
 1946                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 51; // Width of map (or multi-screen BAT) in tiles.
 1947                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 52; extern unsigned char  vdc_map_line_w;
 1948                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 54; // Width of map in screens (if multi-screen map).
 1949                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 55; extern unsigned char  vdc_map_scrn_w;
 1950                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 57; // Extra information returned by get_map_block() and sgx_get_map_block(),
 1951                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 58; // which are the collision flags and the mask/overlay sprite for the BLK.
 1952                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 59; extern unsigned char  map_blk_flag;
 1953                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 60; extern unsigned char  map_blk_mask;
 1954                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 62; extern unsigned char  vdc_scr_bank;
 1955                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 63; extern unsigned char *vdc_scr_addr;
 1956                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 65; extern unsigned char  vdc_map_bank;
 1957                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 66; extern unsigned char *vdc_map_addr;
 1958                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 68; extern unsigned char  vdc_blk_bank;
 1959                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 69; extern unsigned char *vdc_blk_addr;
 1960                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 71; extern unsigned char  vdc_tbl_bank;
 1961                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 72; extern unsigned char *vdc_tbl_addr;
 1962                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 74; extern void __fastcall set_blocks( unsigned char __far *blk_def<vdc_blk_bank:vdc_blk_addr>, unsigned char __far *flg_def<vdc_tbl_bank:vdc_tbl_addr>, unsigned char number_of_blocks<_al> );
 1963                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 75; extern void __fastcall __macro set_blkmap( unsigned char __far *blk_map<vdc_map_bank:vdc_map_addr>, unsigned char blocks_w<vdc_map_line_w> );
 1964                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 76; extern void __fastcall __macro set_multimap( unsigned char __far *multi_map<vdc_scr_bank:vdc_scr_addr>, unsigned char screens_w<vdc_map_scrn_w> );
 1965                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 78; extern void __fastcall draw_map( void );
 1966                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 79; extern void __fastcall scroll_map( void );
 1967                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 81; extern void __fastcall blit_map( unsigned char tile_x<map_bat_x>, unsigned char tile_y<map_bat_y>, unsigned char tile_w<map_draw_x>, unsigned char tile_h<map_draw_y> );
 1968                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 83; extern unsigned char __fastcall get_map_block( unsigned int x<map_pxl_x>, unsigned int y<map_pxl_y> );
 1969                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 85; #asm
 1970                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 86; .macro	_set_blkmap.2
 1971                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 87; stz	vdc_scr_bank
 1972                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 88; .endm
 1973                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 90; .macro	_set_multimap.2
 1974                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 91; lda	vdc_bat_width
 1975                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 92; lsr	a
 1976                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 93; sta	vdc_map_line_w
 1977                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 94; .endm
 1978                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 96; .macro	SCREEN
 1979                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 97; db	(((\1) & $1FFF) | $6000) >> 8, bank(\1)
 1980                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 98; db	(((\2) & $1FFF) | $4000) >> 8, bank(\2)
 1981                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 99; db	(((\3) & $1FFF) | $6000) >> 8, bank(\3)
 1982                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 100; dw	(\4)
 1983                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 101; .endm
 1984                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 102; #endasm
 1985                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 104; #ifdef _SGX
 1986                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 106; // Current top-left of drawn map in pixels.
 1987                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 107; extern unsigned int   sgx_map_pxl_x;
 1988                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 108; extern unsigned int   sgx_map_pxl_y;
 1989                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 110; // Width and height to draw/scroll in characters (not tiles).
 1990                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 111; extern unsigned char  sgx_map_draw_w;
 1991                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 112; extern unsigned char  sgx_map_draw_h;
 1992                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 114; // Width of map (or multi-screen BAT) in tiles.
 1993                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 115; extern unsigned char  sgx_map_line_w;
 1994                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 117; // Width of map in screens (if multi-screen map).
 1995                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 118; extern unsigned char  sgx_map_scrn_w;
 1996                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 120; extern unsigned char  sgx_scr_bank;
 1997                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 121; extern unsigned char *sgx_scr_addr;
 1998                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 123; extern unsigned char  sgx_map_bank;
 1999                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 124; extern unsigned char *sgx_map_addr;
 2000                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 126; extern unsigned char  sgx_blk_bank;
 2001                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 127; extern unsigned char *sgx_blk_addr;
 2002                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 129; extern unsigned char  sgx_tbl_bank;
 2003                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 130; extern unsigned char *sgx_tbl_addr;
 2004                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 132; extern void __fastcall sgx_set_blocks( unsigned char __far *blk_def<sgx_blk_bank:sgx_blk_addr>, unsigned char __far *flg_def<sgx_tbl_bank:sgx_tbl_addr>, unsigned char number_of_blocks<_al> );
 2005                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 133; extern void __fastcall __macro sgx_set_blkmap( unsigned char __far *blk_map<sgx_map_bank:sgx_map_addr>, unsigned char blocks_w<sgx_map_line_w> );
 2006                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 134; extern void __fastcall __macro sgx_set_multimap( unsigned char __far *multi_map<sgx_scr_bank:sgx_scr_addr>, unsigned char screens_w<sgx_map_scrn_w> );
 2007                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 136; extern void __fastcall sgx_draw_map( void );
 2008                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 137; extern void __fastcall sgx_scroll_map( void );
 2009                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 139; extern void __fastcall sgx_blit_map( unsigned char tile_x<map_bat_x>, unsigned char tile_y<map_bat_y>, unsigned char tile_w<map_draw_x>, unsigned char tile_h<map_draw_y> );
 2010                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 141; extern unsigned char __fastcall sgx_get_map_block( unsigned int x<map_pxl_x>, unsigned int y<map_pxl_y> );
 2011                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 143; #asm
 2012                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 144; .macro	_sgx_set_blkmap.2
 2013                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 145; stz	sgx_scr_bank
 2014                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 146; .endm
 2015                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 148; .macro	_sgx_set_multimap.2
 2016                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 149; lda	sgx_bat_width
 2017                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 150; lsr	a
 2018                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 151; sta	sgx_map_line_w
 2019                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 152; .endm
 2020                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 153; #endasm
 2021                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 155; #endif
 2022                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 157; #endif // __HUCC__
 2023                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 159; #endif // _hucc_blkmap_h
 2024                        		.dbg	line,	"include\gfx_BG.c", 13; #incchr(tileset_FONT,"res/maps/tiles_FONT.png");
 2025               6000     		.data
 2026    03:6000             	_tileset_FONT: 	.incchr		"res/maps/tiles_FONT.png"
 2027               E309     		.code
 2028                        		.dbg	line,	"include\gfx_BG.c", 14; //#incchr(tileset_NUMBERS_FONT,"res/maps/tiles_NUMBERS_FONT.png");
 2029                        		.dbg	line,	"include\gfx_BG.c", 17; //**************************************************************************************//
 2030                        		.dbg	line,	"include\gfx_BG.c", 18; //                                                                                      //
 2031                        		.dbg	line,	"include\gfx_BG.c", 19; //                                       LEVEL 1                                        //
 2032                        		.dbg	line,	"include\gfx_BG.c", 20; //                                                                                      //
 2033                        		.dbg	line,	"include\gfx_BG.c", 21; //**************************************************************************************//
 2034                        		.dbg	line,	"include\gfx_BG.c", 23; #incchr(tileset_LV1_WALL,"res/maps/tiles_LV1_WALL.png", 4 , 4);
 2035               6C00     		.data
 2036    03:6C00             	_tileset_LV1_WALL: 	.incchr		"res/maps/tiles_LV1_WALL.png", 4, 4
 2037               E309     		.code
 2038                        		.dbg	line,	"include\gfx_BG.c", 24; #incchr(tileset_LV1_DOOR_OPEN,"res/maps/tiles_LV1_DOOR_OPEN.png", 4 , 6);
 2039               6E00     		.data
 2040    03:6E00             	_tileset_LV1_DOOR_OPEN: 	.incchr		"res/maps/tiles_LV1_DOOR_OPEN.png", 4, 6
 2041               E309     		.code
 2042                        		.dbg	line,	"include\gfx_BG.c", 25; #incchr(tileset_LV1_DOOR_CLOSED,"res/maps/tiles_LV1_DOOR_CLOSED.png", 4 , 6);
 2043               7100     		.data
 2044    03:7100             	_tileset_LV1_DOOR_CLOSED: 	.incchr		"res/maps/tiles_LV1_DOOR_CLOSED.png", 4, 6
 2045               E309     		.code
 2046                        		.dbg	line,	"include\gfx_BG.c", 27; #incchr(tileset_LIFE_RED,"res/maps/tileset_LIFE_RED.png", 2 , 1);
 2047               7400     		.data
 2048    03:7400             	_tileset_LIFE_RED: 	.incchr		"res/maps/tileset_LIFE_RED.png", 2, 1
 2049               E309     		.code
 2050                        		.dbg	line,	"include\gfx_BG.c", 28; #incchr(tileset_LIFE_ORANGE,"res/maps/tileset_LIFE_ORANGE.png", 2 , 1);
 2051               7440     		.data
 2052    03:7440             	_tileset_LIFE_ORANGE: 	.incchr		"res/maps/tileset_LIFE_ORANGE.png", 2, 1
 2053               E309     		.code
 2054                        		.dbg	line,	"include\gfx_BG.c", 29; #incchr(tileset_LIFE_YELLOW,"res/maps/tileset_LIFE_YELLOW.png", 2 , 1);
 2055               7480     		.data
 2056    03:7480             	_tileset_LIFE_YELLOW: 	.incchr		"res/maps/tileset_LIFE_YELLOW.png", 2, 1
 2057               E309     		.code
 2058                        		.dbg	line,	"include\gfx_BG.c", 30; #incchr(tileset_LIFE_EMPTY,"res/maps/tileset_LIFE_EMPTY.png", 2 , 1);
 2059               74C0     		.data
 2060    03:74C0             	_tileset_LIFE_EMPTY: 	.incchr		"res/maps/tileset_LIFE_EMPTY.png", 2, 1
 2061               E309     		.code
 2062                        		.dbg	line,	"include\gfx_BG.c", 32; #incchr(tileset_ARMOR_1,"res/maps/tileset_ARMOR_1.png", 2 , 2);
 2063               7500     		.data
 2064    03:7500             	_tileset_ARMOR_1: 	.incchr		"res/maps/tileset_ARMOR_1.png", 2, 2
 2065               E309     		.code
 2066                        		.dbg	line,	"include\gfx_BG.c", 33; #incchr(tileset_ARMOR_2,"res/maps/tileset_ARMOR_2.png", 2 , 2);
 2067               7580     		.data
 2068    03:7580             	_tileset_ARMOR_2: 	.incchr		"res/maps/tileset_ARMOR_2.png", 2, 2
 2069               E309     		.code
 2070                        		.dbg	line,	"include\gfx_BG.c", 34; #incchr(tileset_ARMOR_4,"res/maps/tileset_ARMOR_4.png", 2 , 2);
 2071               7600     		.data
 2072    03:7600             	_tileset_ARMOR_4: 	.incchr		"res/maps/tileset_ARMOR_4.png", 2, 2
 2073               E309     		.code
 2074                        		.dbg	line,	"include\gfx_BG.c", 35; #incchr(tileset_ARMOR_8,"res/maps/tileset_ARMOR_8.png", 2 , 2);
 2075               7680     		.data
 2076    03:7680             	_tileset_ARMOR_8: 	.incchr		"res/maps/tileset_ARMOR_8.png", 2, 2
 2077               E309     		.code
 2078                        		.dbg	line,	"include\gfx_BG.c", 37; #incchr(tileset_WEAPON_1,"res/maps/tileset_WEAPON_1.png", 2 , 2);
 2079               7700     		.data
 2080    03:7700             	_tileset_WEAPON_1: 	.incchr		"res/maps/tileset_WEAPON_1.png", 2, 2
 2081               E309     		.code
 2082                        		.dbg	line,	"include\gfx_BG.c", 38; #incchr(tileset_WEAPON_2,"res/maps/tileset_WEAPON_2.png", 2 , 2);
 2083               7780     		.data
 2084    03:7780             	_tileset_WEAPON_2: 	.incchr		"res/maps/tileset_WEAPON_2.png", 2, 2
 2085               E309     		.code
 2086                        		.dbg	line,	"include\gfx_BG.c", 39; #incchr(tileset_WEAPON_4,"res/maps/tileset_WEAPON_4.png", 2 , 2);
 2087               7800     		.data
 2088    03:7800             	_tileset_WEAPON_4: 	.incchr		"res/maps/tileset_WEAPON_4.png", 2, 2
 2089               E309     		.code
 2090                        		.dbg	line,	"include\gfx_BG.c", 40; #incchr(tileset_WEAPON_5,"res/maps/tileset_WEAPON_5.png", 2 , 2);
 2091               7880     		.data
 2092    03:7880             	_tileset_WEAPON_5: 	.incchr		"res/maps/tileset_WEAPON_5.png", 2, 2
 2093               E309     		.code
 2094                        		.dbg	line,	"include\gfx_BG.c", 41; #incchr(tileset_WEAPON_8,"res/maps/tileset_WEAPON_8.png", 2 , 2);
 2095               7900     		.data
 2096    03:7900             	_tileset_WEAPON_8: 	.incchr		"res/maps/tileset_WEAPON_8.png", 2, 2
 2097               E309     		.code
 2098                        		.dbg	line,	"include\gfx_BG.c", 44; //--------------------------------------------------------------------------------------//
 2099                        		.dbg	line,	"include\gfx_BG.c", 45; //                                        VDC 2                                         //
 2100                        		.dbg	line,	"include\gfx_BG.c", 46; //--------------------------------------------------------------------------------------//
 2101                        		.dbg	line,	"include\gfx_BG.c", 48; #asm
 2102                        		.dbg	clear
 2103               0001     	OPTIMIZE	=	1
 2104               7980     			.data
 2105                        	; EXTRACT TILESET
 2106                        	;----------------
 2107    03:7980             	_tileset_LV1_BG_B:  incchr	"res/maps/template_LV1_WALL.png"
 2108    03:7B80             			incchr	"res/maps/template_LV1_DOOR.png"
 2109    03:7E80             			incchr	"res/maps/tilemap_LV1_BG_B.png", OPTIMIZE
 2110                        	; EXTRACT BLOCKS
 2111                        	;--------------
 2112    07:7000             	blocks_LV1_BG_B1:	incblk	"res/maps/tilemap_LV1_BG_B.png" , 0x1000 ,    0 ,   0 ,  64 , 32 , _tileset_LV1_BG_B ; // 96x16 = 1536 | 32x16 =  512
 2113    07:7800             	blocks_LV1_BG_B2:	incblk	"res/maps/tilemap_LV1_BG_B.png" , 0x1000 , 1024 ,   0 ,  96 , 32 , _tileset_LV1_BG_B ; // 64x16 = 1024 | 32x16 =  512
 2114    08:6000             	blocks_LV1_BG_B3:	incblk	"res/maps/tilemap_LV1_BG_B.png" , 0x1000 ,    0 , 512 ,  64 , 32 , _tileset_LV1_BG_B ; // 96x16 = 1536 | 16x16 =  256
 2115    08:6800             	blocks_LV1_BG_B4:	incblk	"res/maps/tilemap_LV1_BG_B.png" , 0x1000 , 1024 , 512 ,  96 , 32 , _tileset_LV1_BG_B ; // 64x16 = 1024 | 16x16 =  256
 2116                        	; EXTRACT MAPS
 2117                        	;------------
 2118               7000     			align	256
 2119    08:7000             	MAP_LV1_BG_B1:		incmap	"res/maps/tilemap_LV1_BG_B.png",    0 ,   0 ,  64 , 32 , blocks_LV1_BG_B1 ; // 96x16 = 1536 | 32x16 =  512
 2120               7800     			align	256
 2121    08:7800             	MAP_LV1_BG_B2:		incmap	"res/maps/tilemap_LV1_BG_B.png", 1024 ,   0 ,  96 , 32 , blocks_LV1_BG_B2 ; // 64x16 = 1024 | 32x16 =  512
 2122               6400     			align	256
 2123    09:6400             	MAP_LV1_BG_B3:		incmap	"res/maps/tilemap_LV1_BG_B.png",    0 , 512 ,  64 , 32 , blocks_LV1_BG_B3 ; // 96x16 = 1536 | 16x16 =  256
 2124               6C00     			align	256
 2125    09:6C00             	MAP_LV1_BG_B4:		incmap	"res/maps/tilemap_LV1_BG_B.png", 1024 , 512 ,  96 , 32 , blocks_LV1_BG_B4 ; // 64x16 = 1024 | 16x16 =  256
 2126                        	; MASK (EMPTY)
 2127                        	;----------------
 2128    09:7800  00 00 00 00	dummy_tbl:	ds	256
         09:7804  00 00 00 00 
         09:7808  00 00 00 00 
         09:780C  00 00 00 00 
         09:7810  00 00 00 00 
         09:7814  00 00 00 00 
         09:7818  00 00 00 00 
         09:781C  00 00 00 00 
         09:7820  00 00 00 00 
         09:7824  00 00 00 00 
         09:7828  00 00 00 00 
         09:782C  00 00 00 00 
         09:7830  00 00 00 00 
         09:7834  00 00 00 00 
         09:7838  00 00 00 00 
         09:783C  00 00 00 00 
         09:7840  00 00 00 00 
         09:7844  00 00 00 00 
         09:7848  00 00 00 00 
         09:784C  00 00 00 00 
         09:7850  00 00 00 00 
         09:7854  00 00 00 00 
         09:7858  00 00 00 00 
         09:785C  00 00 00 00 
         09:7860  00 00 00 00 
         09:7864  00 00 00 00 
         09:7868  00 00 00 00 
         09:786C  00 00 00 00 
         09:7870  00 00 00 00 
         09:7874  00 00 00 00 
         09:7878  00 00 00 00 
         09:787C  00 00 00 00 
         09:7880  00 00 00 00 
         09:7884  00 00 00 00 
         09:7888  00 00 00 00 
         09:788C  00 00 00 00 
         09:7890  00 00 00 00 
         09:7894  00 00 00 00 
         09:7898  00 00 00 00 
         09:789C  00 00 00 00 
         09:78A0  00 00 00 00 
         09:78A4  00 00 00 00 
         09:78A8  00 00 00 00 
         09:78AC  00 00 00 00 
         09:78B0  00 00 00 00 
         09:78B4  00 00 00 00 
         09:78B8  00 00 00 00 
         09:78BC  00 00 00 00 
         09:78C0  00 00 00 00 
         09:78C4  00 00 00 00 
         09:78C8  00 00 00 00 
         09:78CC  00 00 00 00 
         09:78D0  00 00 00 00 
         09:78D4  00 00 00 00 
         09:78D8  00 00 00 00 
         09:78DC  00 00 00 00 
         09:78E0  00 00 00 00 
         09:78E4  00 00 00 00 
         09:78E8  00 00 00 00 
         09:78EC  00 00 00 00 
         09:78F0  00 00 00 00 
         09:78F4  00 00 00 00 
         09:78F8  00 00 00 00 
         09:78FC  00 00 00 00 
 2129                        	; SWIZZLE MAPS
 2130                        	;-------------
 2131    09:7900             	swizzle	MAP_LV1_BG_B1,  32, 16 ;
 2132    09:7900             	swizzle	MAP_LV1_BG_B2,  32, 16 ;
 2133    09:7900             	swizzle	MAP_LV1_BG_B3,  32, 16 ;
 2134    09:7900             	swizzle	MAP_LV1_BG_B4,  32, 16 ;
 2135                        	; BUILD MULTIMAP
 2136                        	;---------------
 2137    09:7900             	_multimap_LV1_BG_B:
 2138                        			; 1st line of 5 screens (512x256)
 2139                        			SCREEN MAP_LV1_BG_B1 + 0x0000, blocks_LV1_BG_B1, dummy_tbl, 0
         09:7900  70 08      			db	(((MAP_LV1_BG_B1 + 0x0000) & $1FFF) | $6000) >> 8, bank(MAP_LV1_BG_B1 + 0x0000)
         09:7902  50 07      			db	(((blocks_LV1_BG_B1) & $1FFF) | $4000) >> 8, bank(blocks_LV1_BG_B1)
         09:7904  78 09      			db	(((dummy_tbl) & $1FFF) | $6000) >> 8, bank(dummy_tbl)
         09:7906  00 00      			dw	(0)
 2140                        			SCREEN MAP_LV1_BG_B1 + 0x0200, blocks_LV1_BG_B1, dummy_tbl, 0
         09:7908  72 08      			db	(((MAP_LV1_BG_B1 + 0x0200) & $1FFF) | $6000) >> 8, bank(MAP_LV1_BG_B1 + 0x0200)
         09:790A  50 07      			db	(((blocks_LV1_BG_B1) & $1FFF) | $4000) >> 8, bank(blocks_LV1_BG_B1)
         09:790C  78 09      			db	(((dummy_tbl) & $1FFF) | $6000) >> 8, bank(dummy_tbl)
         09:790E  00 00      			dw	(0)
 2141                        			SCREEN MAP_LV1_BG_B2 + 0x0000, blocks_LV1_BG_B2, dummy_tbl, 0
         09:7910  78 08      			db	(((MAP_LV1_BG_B2 + 0x0000) & $1FFF) | $6000) >> 8, bank(MAP_LV1_BG_B2 + 0x0000)
         09:7912  58 07      			db	(((blocks_LV1_BG_B2) & $1FFF) | $4000) >> 8, bank(blocks_LV1_BG_B2)
         09:7914  78 09      			db	(((dummy_tbl) & $1FFF) | $6000) >> 8, bank(dummy_tbl)
         09:7916  00 00      			dw	(0)
 2142                        			SCREEN MAP_LV1_BG_B2 + 0x0200, blocks_LV1_BG_B2, dummy_tbl, 0
         09:7918  7A 08      			db	(((MAP_LV1_BG_B2 + 0x0200) & $1FFF) | $6000) >> 8, bank(MAP_LV1_BG_B2 + 0x0200)
         09:791A  58 07      			db	(((blocks_LV1_BG_B2) & $1FFF) | $4000) >> 8, bank(blocks_LV1_BG_B2)
         09:791C  78 09      			db	(((dummy_tbl) & $1FFF) | $6000) >> 8, bank(dummy_tbl)
         09:791E  00 00      			dw	(0)
 2143                        			SCREEN MAP_LV1_BG_B2 + 0x0400, blocks_LV1_BG_B2, dummy_tbl, 0
         09:7920  7C 08      			db	(((MAP_LV1_BG_B2 + 0x0400) & $1FFF) | $6000) >> 8, bank(MAP_LV1_BG_B2 + 0x0400)
         09:7922  58 07      			db	(((blocks_LV1_BG_B2) & $1FFF) | $4000) >> 8, bank(blocks_LV1_BG_B2)
         09:7924  78 09      			db	(((dummy_tbl) & $1FFF) | $6000) >> 8, bank(dummy_tbl)
         09:7926  00 00      			dw	(0)
 2144                        			; 2nd line of 5 screens (512x256)
 2145                        			SCREEN MAP_LV1_BG_B1 + 0x0400, blocks_LV1_BG_B1, dummy_tbl, 0
         09:7928  74 08      			db	(((MAP_LV1_BG_B1 + 0x0400) & $1FFF) | $6000) >> 8, bank(MAP_LV1_BG_B1 + 0x0400)
         09:792A  50 07      			db	(((blocks_LV1_BG_B1) & $1FFF) | $4000) >> 8, bank(blocks_LV1_BG_B1)
         09:792C  78 09      			db	(((dummy_tbl) & $1FFF) | $6000) >> 8, bank(dummy_tbl)
         09:792E  00 00      			dw	(0)
 2146                        			SCREEN MAP_LV1_BG_B1 + 0x0600, blocks_LV1_BG_B1, dummy_tbl, 0
         09:7930  76 08      			db	(((MAP_LV1_BG_B1 + 0x0600) & $1FFF) | $6000) >> 8, bank(MAP_LV1_BG_B1 + 0x0600)
         09:7932  50 07      			db	(((blocks_LV1_BG_B1) & $1FFF) | $4000) >> 8, bank(blocks_LV1_BG_B1)
         09:7934  78 09      			db	(((dummy_tbl) & $1FFF) | $6000) >> 8, bank(dummy_tbl)
         09:7936  00 00      			dw	(0)
 2147                        			SCREEN MAP_LV1_BG_B2 + 0x0600, blocks_LV1_BG_B2, dummy_tbl, 0
         09:7938  7E 08      			db	(((MAP_LV1_BG_B2 + 0x0600) & $1FFF) | $6000) >> 8, bank(MAP_LV1_BG_B2 + 0x0600)
         09:793A  58 07      			db	(((blocks_LV1_BG_B2) & $1FFF) | $4000) >> 8, bank(blocks_LV1_BG_B2)
         09:793C  78 09      			db	(((dummy_tbl) & $1FFF) | $6000) >> 8, bank(dummy_tbl)
         09:793E  00 00      			dw	(0)
 2148                        			SCREEN MAP_LV1_BG_B2 + 0x0800, blocks_LV1_BG_B2, dummy_tbl, 0
         09:7940  60 09      			db	(((MAP_LV1_BG_B2 + 0x0800) & $1FFF) | $6000) >> 8, bank(MAP_LV1_BG_B2 + 0x0800)
         09:7942  58 07      			db	(((blocks_LV1_BG_B2) & $1FFF) | $4000) >> 8, bank(blocks_LV1_BG_B2)
         09:7944  78 09      			db	(((dummy_tbl) & $1FFF) | $6000) >> 8, bank(dummy_tbl)
         09:7946  00 00      			dw	(0)
 2149                        			SCREEN MAP_LV1_BG_B2 + 0x0A00, blocks_LV1_BG_B2, dummy_tbl, 0
         09:7948  62 09      			db	(((MAP_LV1_BG_B2 + 0x0A00) & $1FFF) | $6000) >> 8, bank(MAP_LV1_BG_B2 + 0x0A00)
         09:794A  58 07      			db	(((blocks_LV1_BG_B2) & $1FFF) | $4000) >> 8, bank(blocks_LV1_BG_B2)
         09:794C  78 09      			db	(((dummy_tbl) & $1FFF) | $6000) >> 8, bank(dummy_tbl)
         09:794E  00 00      			dw	(0)
 2150                        			; 3rd line of 5 screens (512x256)
 2151                        			SCREEN MAP_LV1_BG_B3 + 0x0000, blocks_LV1_BG_B3, dummy_tbl, 0
         09:7950  64 09      			db	(((MAP_LV1_BG_B3 + 0x0000) & $1FFF) | $6000) >> 8, bank(MAP_LV1_BG_B3 + 0x0000)
         09:7952  40 08      			db	(((blocks_LV1_BG_B3) & $1FFF) | $4000) >> 8, bank(blocks_LV1_BG_B3)
         09:7954  78 09      			db	(((dummy_tbl) & $1FFF) | $6000) >> 8, bank(dummy_tbl)
         09:7956  00 00      			dw	(0)
 2152                        			SCREEN MAP_LV1_BG_B3 + 0x0200, blocks_LV1_BG_B3, dummy_tbl, 0
         09:7958  66 09      			db	(((MAP_LV1_BG_B3 + 0x0200) & $1FFF) | $6000) >> 8, bank(MAP_LV1_BG_B3 + 0x0200)
         09:795A  40 08      			db	(((blocks_LV1_BG_B3) & $1FFF) | $4000) >> 8, bank(blocks_LV1_BG_B3)
         09:795C  78 09      			db	(((dummy_tbl) & $1FFF) | $6000) >> 8, bank(dummy_tbl)
         09:795E  00 00      			dw	(0)
 2153                        			SCREEN MAP_LV1_BG_B4 + 0x0000, blocks_LV1_BG_B4, dummy_tbl, 0
         09:7960  6C 09      			db	(((MAP_LV1_BG_B4 + 0x0000) & $1FFF) | $6000) >> 8, bank(MAP_LV1_BG_B4 + 0x0000)
         09:7962  48 08      			db	(((blocks_LV1_BG_B4) & $1FFF) | $4000) >> 8, bank(blocks_LV1_BG_B4)
         09:7964  78 09      			db	(((dummy_tbl) & $1FFF) | $6000) >> 8, bank(dummy_tbl)
         09:7966  00 00      			dw	(0)
 2154                        			SCREEN MAP_LV1_BG_B4 + 0x0200, blocks_LV1_BG_B4, dummy_tbl, 0
         09:7968  6E 09      			db	(((MAP_LV1_BG_B4 + 0x0200) & $1FFF) | $6000) >> 8, bank(MAP_LV1_BG_B4 + 0x0200)
         09:796A  48 08      			db	(((blocks_LV1_BG_B4) & $1FFF) | $4000) >> 8, bank(blocks_LV1_BG_B4)
         09:796C  78 09      			db	(((dummy_tbl) & $1FFF) | $6000) >> 8, bank(dummy_tbl)
         09:796E  00 00      			dw	(0)
 2155                        			SCREEN MAP_LV1_BG_B4 + 0x0400, blocks_LV1_BG_B4, dummy_tbl, 0
         09:7970  70 09      			db	(((MAP_LV1_BG_B4 + 0x0400) & $1FFF) | $6000) >> 8, bank(MAP_LV1_BG_B4 + 0x0400)
         09:7972  48 08      			db	(((blocks_LV1_BG_B4) & $1FFF) | $4000) >> 8, bank(blocks_LV1_BG_B4)
         09:7974  78 09      			db	(((dummy_tbl) & $1FFF) | $6000) >> 8, bank(dummy_tbl)
         09:7976  00 00      			dw	(0)
 2156                        			; 4th line of 5 screens (512x256)
 2157                        			SCREEN MAP_LV1_BG_B3 + 0x0400, blocks_LV1_BG_B3, dummy_tbl, 0
         09:7978  68 09      			db	(((MAP_LV1_BG_B3 + 0x0400) & $1FFF) | $6000) >> 8, bank(MAP_LV1_BG_B3 + 0x0400)
         09:797A  40 08      			db	(((blocks_LV1_BG_B3) & $1FFF) | $4000) >> 8, bank(blocks_LV1_BG_B3)
         09:797C  78 09      			db	(((dummy_tbl) & $1FFF) | $6000) >> 8, bank(dummy_tbl)
         09:797E  00 00      			dw	(0)
 2158                        			SCREEN MAP_LV1_BG_B3 + 0x0600, blocks_LV1_BG_B3, dummy_tbl, 0
         09:7980  6A 09      			db	(((MAP_LV1_BG_B3 + 0x0600) & $1FFF) | $6000) >> 8, bank(MAP_LV1_BG_B3 + 0x0600)
         09:7982  40 08      			db	(((blocks_LV1_BG_B3) & $1FFF) | $4000) >> 8, bank(blocks_LV1_BG_B3)
         09:7984  78 09      			db	(((dummy_tbl) & $1FFF) | $6000) >> 8, bank(dummy_tbl)
         09:7986  00 00      			dw	(0)
 2159                        			SCREEN MAP_LV1_BG_B4 + 0x0600, blocks_LV1_BG_B4, dummy_tbl, 0
         09:7988  72 09      			db	(((MAP_LV1_BG_B4 + 0x0600) & $1FFF) | $6000) >> 8, bank(MAP_LV1_BG_B4 + 0x0600)
         09:798A  48 08      			db	(((blocks_LV1_BG_B4) & $1FFF) | $4000) >> 8, bank(blocks_LV1_BG_B4)
         09:798C  78 09      			db	(((dummy_tbl) & $1FFF) | $6000) >> 8, bank(dummy_tbl)
         09:798E  00 00      			dw	(0)
 2160                        			SCREEN MAP_LV1_BG_B4 + 0x0800, blocks_LV1_BG_B4, dummy_tbl, 0
         09:7990  74 09      			db	(((MAP_LV1_BG_B4 + 0x0800) & $1FFF) | $6000) >> 8, bank(MAP_LV1_BG_B4 + 0x0800)
         09:7992  48 08      			db	(((blocks_LV1_BG_B4) & $1FFF) | $4000) >> 8, bank(blocks_LV1_BG_B4)
         09:7994  78 09      			db	(((dummy_tbl) & $1FFF) | $6000) >> 8, bank(dummy_tbl)
         09:7996  00 00      			dw	(0)
 2161                        			SCREEN MAP_LV1_BG_B4 + 0x0A00, blocks_LV1_BG_B4, dummy_tbl, 0
         09:7998  76 09      			db	(((MAP_LV1_BG_B4 + 0x0A00) & $1FFF) | $6000) >> 8, bank(MAP_LV1_BG_B4 + 0x0A00)
         09:799A  48 08      			db	(((blocks_LV1_BG_B4) & $1FFF) | $4000) >> 8, bank(blocks_LV1_BG_B4)
         09:799C  78 09      			db	(((dummy_tbl) & $1FFF) | $6000) >> 8, bank(dummy_tbl)
         09:799E  00 00      			dw	(0)
 2162                        	;//--------------------------------------------------------------------------------------//
 2163                        	;//                                        VDC 1                                         //
 2164                        	;//--------------------------------------------------------------------------------------//
 2165                        	; EXTRACT TILESET
 2166                        	;----------------
 2167    09:79A0             	_tileset_HUD:	incchr	"res/maps/template_LIFEBAR_1.png"
 2168    09:79E0             			incchr	"res/maps/template_LIFEBAR_2.png"
 2169    09:7A20             			incchr	"res/maps/template_LIFEBAR_3.png"
 2170    09:7A60             			incchr	"res/maps/template_LIFEBAR_4.png"
 2171    09:7AA0             			incchr	"res/maps/template_LIFEBAR_5.png"
 2172    09:7AE0             			incchr	"res/maps/tileset_WEAPON_1.png"
 2173    09:7B60             			incchr	"res/maps/tileset_ARMOR_2.png"
 2174    09:7BE0             			incchr	"res/maps/tilemap_HUD.png", OPTIMIZE
 2175                        	; EXTRACT BLOCKS
 2176                        	;--------------
 2177    0A:6000             	blocks_HUD1:	incblk	"res/maps/tilemap_HUD.png" , 0x1000 ,    0 ,   0 , 128 , 64 , _tileset_HUD ; // 128x16 = 2048 | 64x16 = 1024
 2178    0A:6800             	blocks_HUD2:	incblk	"res/maps/tilemap_HUD.png" , 0x1000 , 2048 ,   0 ,  32 , 64 , _tileset_HUD ; //  32x16 =  512 | 64x16 = 1024
 2179                        	; EXTRACT MAPS
 2180                        	;------------
 2181               7000     			align	256
 2182    0A:7000             	MAP_HUD1:		incmap	"res/maps/tilemap_HUD.png",    0 ,   0 , 128 , 64 , blocks_HUD1 ; // 128x16 = 2048 | 64x16 = 1024
 2183    0B:7000             			flagmap "res/maps/collision_LV1.png",       0 ,   0 , 128 , 64 , MAP_HUD1
 2184               7000     			align	256
 2185    0B:7000             	MAP_HUD2:		incmap	"res/maps/tilemap_HUD.png", 2048 ,   0 ,  32 , 64 , blocks_HUD2 ; //  32x16 =  512 | 64x16 = 1024
 2186    0B:7800             			flagmap "res/maps/collision_LV1.png",    2048 ,   0 ,  32 , 64 , MAP_HUD2
 2187                        	; SWIZZLE MAPS
 2188                        	;-------------
 2189    0B:7800             	swizzle	MAP_HUD1,  32, 16 ;
 2190    0B:7800             	swizzle	MAP_HUD2,  32, 16 ;
 2191                        	; BUILD MULTIMAP
 2192                        	;---------------
 2193    0B:7800             	_multimap_LV1_BG_A:
 2194                        			; 1st line of 5 screens (512x256)
 2195                        			SCREEN MAP_HUD1 + 0x0000, blocks_HUD1, dummy_tbl, 0
         0B:7800  70 0A      			db	(((MAP_HUD1 + 0x0000) & $1FFF) | $6000) >> 8, bank(MAP_HUD1 + 0x0000)
         0B:7802  40 0A      			db	(((blocks_HUD1) & $1FFF) | $4000) >> 8, bank(blocks_HUD1)
         0B:7804  78 09      			db	(((dummy_tbl) & $1FFF) | $6000) >> 8, bank(dummy_tbl)
         0B:7806  00 00      			dw	(0)
 2196                        			SCREEN MAP_HUD1 + 0x0200, blocks_HUD1, dummy_tbl, 0
         0B:7808  72 0A      			db	(((MAP_HUD1 + 0x0200) & $1FFF) | $6000) >> 8, bank(MAP_HUD1 + 0x0200)
         0B:780A  40 0A      			db	(((blocks_HUD1) & $1FFF) | $4000) >> 8, bank(blocks_HUD1)
         0B:780C  78 09      			db	(((dummy_tbl) & $1FFF) | $6000) >> 8, bank(dummy_tbl)
         0B:780E  00 00      			dw	(0)
 2197                        			SCREEN MAP_HUD1 + 0x0400, blocks_HUD1, dummy_tbl, 0
         0B:7810  74 0A      			db	(((MAP_HUD1 + 0x0400) & $1FFF) | $6000) >> 8, bank(MAP_HUD1 + 0x0400)
         0B:7812  40 0A      			db	(((blocks_HUD1) & $1FFF) | $4000) >> 8, bank(blocks_HUD1)
         0B:7814  78 09      			db	(((dummy_tbl) & $1FFF) | $6000) >> 8, bank(dummy_tbl)
         0B:7816  00 00      			dw	(0)
 2198                        			SCREEN MAP_HUD1 + 0x0600, blocks_HUD1, dummy_tbl, 0
         0B:7818  76 0A      			db	(((MAP_HUD1 + 0x0600) & $1FFF) | $6000) >> 8, bank(MAP_HUD1 + 0x0600)
         0B:781A  40 0A      			db	(((blocks_HUD1) & $1FFF) | $4000) >> 8, bank(blocks_HUD1)
         0B:781C  78 09      			db	(((dummy_tbl) & $1FFF) | $6000) >> 8, bank(dummy_tbl)
         0B:781E  00 00      			dw	(0)
 2199                        			SCREEN MAP_HUD2 + 0x0000, blocks_HUD2, dummy_tbl, 0
         0B:7820  70 0B      			db	(((MAP_HUD2 + 0x0000) & $1FFF) | $6000) >> 8, bank(MAP_HUD2 + 0x0000)
         0B:7822  48 0A      			db	(((blocks_HUD2) & $1FFF) | $4000) >> 8, bank(blocks_HUD2)
         0B:7824  78 09      			db	(((dummy_tbl) & $1FFF) | $6000) >> 8, bank(dummy_tbl)
         0B:7826  00 00      			dw	(0)
 2200                        			; 2nd line of 5 screens (512x256)
 2201                        			SCREEN MAP_HUD1 + 0x0800, blocks_HUD1, dummy_tbl, 0
         0B:7828  78 0A      			db	(((MAP_HUD1 + 0x0800) & $1FFF) | $6000) >> 8, bank(MAP_HUD1 + 0x0800)
         0B:782A  40 0A      			db	(((blocks_HUD1) & $1FFF) | $4000) >> 8, bank(blocks_HUD1)
         0B:782C  78 09      			db	(((dummy_tbl) & $1FFF) | $6000) >> 8, bank(dummy_tbl)
         0B:782E  00 00      			dw	(0)
 2202                        			SCREEN MAP_HUD1 + 0x0A00, blocks_HUD1, dummy_tbl, 0
         0B:7830  7A 0A      			db	(((MAP_HUD1 + 0x0A00) & $1FFF) | $6000) >> 8, bank(MAP_HUD1 + 0x0A00)
         0B:7832  40 0A      			db	(((blocks_HUD1) & $1FFF) | $4000) >> 8, bank(blocks_HUD1)
         0B:7834  78 09      			db	(((dummy_tbl) & $1FFF) | $6000) >> 8, bank(dummy_tbl)
         0B:7836  00 00      			dw	(0)
 2203                        			SCREEN MAP_HUD1 + 0x0C00, blocks_HUD1, dummy_tbl, 0
         0B:7838  7C 0A      			db	(((MAP_HUD1 + 0x0C00) & $1FFF) | $6000) >> 8, bank(MAP_HUD1 + 0x0C00)
         0B:783A  40 0A      			db	(((blocks_HUD1) & $1FFF) | $4000) >> 8, bank(blocks_HUD1)
         0B:783C  78 09      			db	(((dummy_tbl) & $1FFF) | $6000) >> 8, bank(dummy_tbl)
         0B:783E  00 00      			dw	(0)
 2204                        			SCREEN MAP_HUD1 + 0x0E00, blocks_HUD1, dummy_tbl, 0
         0B:7840  7E 0A      			db	(((MAP_HUD1 + 0x0E00) & $1FFF) | $6000) >> 8, bank(MAP_HUD1 + 0x0E00)
         0B:7842  40 0A      			db	(((blocks_HUD1) & $1FFF) | $4000) >> 8, bank(blocks_HUD1)
         0B:7844  78 09      			db	(((dummy_tbl) & $1FFF) | $6000) >> 8, bank(dummy_tbl)
         0B:7846  00 00      			dw	(0)
 2205                        			SCREEN MAP_HUD2 + 0x0200, blocks_HUD2, dummy_tbl, 0
         0B:7848  72 0B      			db	(((MAP_HUD2 + 0x0200) & $1FFF) | $6000) >> 8, bank(MAP_HUD2 + 0x0200)
         0B:784A  48 0A      			db	(((blocks_HUD2) & $1FFF) | $4000) >> 8, bank(blocks_HUD2)
         0B:784C  78 09      			db	(((dummy_tbl) & $1FFF) | $6000) >> 8, bank(dummy_tbl)
         0B:784E  00 00      			dw	(0)
 2206                        			; 3rd line of 5 screens (512x256)
 2207                        			SCREEN MAP_HUD1 + 0x1000, blocks_HUD1, dummy_tbl, 0
         0B:7850  60 0B      			db	(((MAP_HUD1 + 0x1000) & $1FFF) | $6000) >> 8, bank(MAP_HUD1 + 0x1000)
         0B:7852  40 0A      			db	(((blocks_HUD1) & $1FFF) | $4000) >> 8, bank(blocks_HUD1)
         0B:7854  78 09      			db	(((dummy_tbl) & $1FFF) | $6000) >> 8, bank(dummy_tbl)
         0B:7856  00 00      			dw	(0)
 2208                        			SCREEN MAP_HUD1 + 0x1200, blocks_HUD1, dummy_tbl, 0
         0B:7858  62 0B      			db	(((MAP_HUD1 + 0x1200) & $1FFF) | $6000) >> 8, bank(MAP_HUD1 + 0x1200)
         0B:785A  40 0A      			db	(((blocks_HUD1) & $1FFF) | $4000) >> 8, bank(blocks_HUD1)
         0B:785C  78 09      			db	(((dummy_tbl) & $1FFF) | $6000) >> 8, bank(dummy_tbl)
         0B:785E  00 00      			dw	(0)
 2209                        			SCREEN MAP_HUD1 + 0x1400, blocks_HUD1, dummy_tbl, 0
         0B:7860  64 0B      			db	(((MAP_HUD1 + 0x1400) & $1FFF) | $6000) >> 8, bank(MAP_HUD1 + 0x1400)
         0B:7862  40 0A      			db	(((blocks_HUD1) & $1FFF) | $4000) >> 8, bank(blocks_HUD1)
         0B:7864  78 09      			db	(((dummy_tbl) & $1FFF) | $6000) >> 8, bank(dummy_tbl)
         0B:7866  00 00      			dw	(0)
 2210                        			SCREEN MAP_HUD1 + 0x1600, blocks_HUD1, dummy_tbl, 0
         0B:7868  66 0B      			db	(((MAP_HUD1 + 0x1600) & $1FFF) | $6000) >> 8, bank(MAP_HUD1 + 0x1600)
         0B:786A  40 0A      			db	(((blocks_HUD1) & $1FFF) | $4000) >> 8, bank(blocks_HUD1)
         0B:786C  78 09      			db	(((dummy_tbl) & $1FFF) | $6000) >> 8, bank(dummy_tbl)
         0B:786E  00 00      			dw	(0)
 2211                        			SCREEN MAP_HUD2 + 0x0400, blocks_HUD2, dummy_tbl, 0
         0B:7870  74 0B      			db	(((MAP_HUD2 + 0x0400) & $1FFF) | $6000) >> 8, bank(MAP_HUD2 + 0x0400)
         0B:7872  48 0A      			db	(((blocks_HUD2) & $1FFF) | $4000) >> 8, bank(blocks_HUD2)
         0B:7874  78 09      			db	(((dummy_tbl) & $1FFF) | $6000) >> 8, bank(dummy_tbl)
         0B:7876  00 00      			dw	(0)
 2212                        			; 4th line of 5 screens (512x256)
 2213                        			SCREEN MAP_HUD1 + 0x1800, blocks_HUD1, dummy_tbl, 0
         0B:7878  68 0B      			db	(((MAP_HUD1 + 0x1800) & $1FFF) | $6000) >> 8, bank(MAP_HUD1 + 0x1800)
         0B:787A  40 0A      			db	(((blocks_HUD1) & $1FFF) | $4000) >> 8, bank(blocks_HUD1)
         0B:787C  78 09      			db	(((dummy_tbl) & $1FFF) | $6000) >> 8, bank(dummy_tbl)
         0B:787E  00 00      			dw	(0)
 2214                        			SCREEN MAP_HUD1 + 0x1A00, blocks_HUD1, dummy_tbl, 0
         0B:7880  6A 0B      			db	(((MAP_HUD1 + 0x1A00) & $1FFF) | $6000) >> 8, bank(MAP_HUD1 + 0x1A00)
         0B:7882  40 0A      			db	(((blocks_HUD1) & $1FFF) | $4000) >> 8, bank(blocks_HUD1)
         0B:7884  78 09      			db	(((dummy_tbl) & $1FFF) | $6000) >> 8, bank(dummy_tbl)
         0B:7886  00 00      			dw	(0)
 2215                        			SCREEN MAP_HUD1 + 0x1C00, blocks_HUD1, dummy_tbl, 0
         0B:7888  6C 0B      			db	(((MAP_HUD1 + 0x1C00) & $1FFF) | $6000) >> 8, bank(MAP_HUD1 + 0x1C00)
         0B:788A  40 0A      			db	(((blocks_HUD1) & $1FFF) | $4000) >> 8, bank(blocks_HUD1)
         0B:788C  78 09      			db	(((dummy_tbl) & $1FFF) | $6000) >> 8, bank(dummy_tbl)
         0B:788E  00 00      			dw	(0)
 2216                        			SCREEN MAP_HUD1 + 0x1E00, blocks_HUD1, dummy_tbl, 0
         0B:7890  6E 0B      			db	(((MAP_HUD1 + 0x1E00) & $1FFF) | $6000) >> 8, bank(MAP_HUD1 + 0x1E00)
         0B:7892  40 0A      			db	(((blocks_HUD1) & $1FFF) | $4000) >> 8, bank(blocks_HUD1)
         0B:7894  78 09      			db	(((dummy_tbl) & $1FFF) | $6000) >> 8, bank(dummy_tbl)
         0B:7896  00 00      			dw	(0)
 2217                        			SCREEN MAP_HUD2 + 0x0600, blocks_HUD2, dummy_tbl, 0
         0B:7898  76 0B      			db	(((MAP_HUD2 + 0x0600) & $1FFF) | $6000) >> 8, bank(MAP_HUD2 + 0x0600)
         0B:789A  48 0A      			db	(((blocks_HUD2) & $1FFF) | $4000) >> 8, bank(blocks_HUD2)
         0B:789C  78 09      			db	(((dummy_tbl) & $1FFF) | $6000) >> 8, bank(dummy_tbl)
         0B:789E  00 00      			dw	(0)
 2218               E309     			.code
 2219                        	
 2220                        		.dbg	line,	"include\gfx_BG.c", 208; #endasm
 2221                        		.dbg	line,	"include\gfx_BG.c", 212; //--------------------------------------------------------------------------------------//
 2222                        		.dbg	line,	"include\gfx_BG.c", 213; //                                   EXTRACT PALETTES                                   //
 2223                        		.dbg	line,	"include\gfx_BG.c", 214; //--------------------------------------------------------------------------------------//
 2224                        		.dbg	line,	"include\gfx_BG.c", 216; #incpal(palette_LV1,"res/maps/tilemap_LV1_BG_B.png");
 2225               78A0     		.data
 2226    0B:78A0             	_palette_LV1:	.incpal		"res/maps/tilemap_LV1_BG_B.png"
 2227               E309     		.code
 2228                        		.dbg	line,	"include\gfx_BG.c", 225; //**************************************************************************************//
 2229                        		.dbg	line,	"include\gfx_BG.c", 226; //                                                                                      //
 2230                        		.dbg	line,	"include\gfx_BG.c", 227; //                                         SHOP                                         //
 2231                        		.dbg	line,	"include\gfx_BG.c", 228; //                                                                                      //
 2232                        		.dbg	line,	"include\gfx_BG.c", 229; //**************************************************************************************//
 2233                        		.dbg	line,	"include\gfx_BG.c", 231; #asm
 2234                        		.dbg	clear
 2235               0001     	OPTIMIZE	=	1
 2236               7AA0     			.data
 2237                        	;//--------------------------------------------------------------------------------------//
 2238                        	;//                                        VDC 1                                         //
 2239                        	;//--------------------------------------------------------------------------------------//
 2240                        	; EXTRACT TILESET
 2241                        	;----------------
 2242    0B:7AA0             	_tileset_SHOP_BG_B:		incchr	"res/maps/template_ITEM_1.png"
 2243    0B:7B20             			incchr	"res/maps/template_ITEM_2.png"
 2244    0B:7BA0             			incchr	"res/maps/template_ITEM_3.png"
 2245    0B:7C20             			incchr	"res/maps/template_ITEM_4.png"
 2246    0B:7CA0             			incchr	"res/maps/template_ITEM_5.png"
 2247    0B:7D20             			incchr	"res/maps/template_ITEM_6.png"
 2248    0B:7DA0             			incchr	"res/maps/template_ITEM_7.png"
 2249    0B:7E20             			incchr	"res/maps/template_ITEM_8.png"
 2250    0B:7EA0             			incchr	"res/maps/template_ITEM_9.png"
 2251    0B:7F20             			incchr	"res/maps/template_ITEM_10.png"
 2252    0B:7FA0             			incchr	"res/maps/tilemap_SHOP_BG_B.png", OPTIMIZE
 2253               E309     			.code
 2254                        	
 2255                        		.dbg	line,	"include\gfx_BG.c", 255; #endasm
 2256                        		.dbg	line,	"include\gfx_BG.c", 258; // EXTRACT BLOCKS //
 2257                        		.dbg	line,	"include\gfx_BG.c", 259; #incblk(blocks_SHOP_BG_B, "res/maps/tilemap_SHOP_BG_B.png", 0x1000, tileset_SHOP_BG_B);
 2258               7400     		.data
 2259    0D:7800             	_blocks_SHOP_BG_B:	.incblk		"res/maps/tilemap_SHOP_BG_B.png", 4096, _tileset_SHOP_BG_B
 2260               E309     		.code
 2261                        		.dbg	line,	"include\gfx_BG.c", 261; // EXTRACT MAP //
 2262                        		.dbg	line,	"include\gfx_BG.c", 262; #incmap(map_SHOP_BG_B, "res/maps/tilemap_SHOP_BG_B.png", blocks_SHOP_BG_B);
 2263               8000     		.data
 2264    0E:6000             	_map_SHOP_BG_B:	.incmap		"res/maps/tilemap_SHOP_BG_B.png", _blocks_SHOP_BG_B
 2265               E309     		.code
 2266                        		.dbg	line,	"include\gfx_BG.c", 265; //--------------------------------------------------------------------------------------//
 2267                        		.dbg	line,	"include\gfx_BG.c", 266; //                                        ITEMS                                         //
 2268                        		.dbg	line,	"include\gfx_BG.c", 267; //--------------------------------------------------------------------------------------//
 2269                        		.dbg	line,	"include\gfx_BG.c", 269; #incchr(tiles_ITEM_WEAPON_2,"res/maps/tiles_ITEM_WEAPON_2.png", 2 , 2);
 2270               60E0     		.data
 2271    0E:60E0             	_tiles_ITEM_WEAPON_2: 	.incchr		"res/maps/tiles_ITEM_WEAPON_2.png", 2, 2
 2272               E309     		.code
 2273                        		.dbg	line,	"include\gfx_BG.c", 270; #incchr(tiles_ITEM_WEAPON_3,"res/maps/tiles_ITEM_WEAPON_3.png", 2 , 2);
 2274               6160     		.data
 2275    0E:6160             	_tiles_ITEM_WEAPON_3: 	.incchr		"res/maps/tiles_ITEM_WEAPON_3.png", 2, 2
 2276               E309     		.code
 2277                        		.dbg	line,	"include\gfx_BG.c", 271; #incchr(tiles_ITEM_WEAPON_4,"res/maps/tiles_ITEM_WEAPON_4.png", 2 , 2);
 2278               61E0     		.data
 2279    0E:61E0             	_tiles_ITEM_WEAPON_4: 	.incchr		"res/maps/tiles_ITEM_WEAPON_4.png", 2, 2
 2280               E309     		.code
 2281                        		.dbg	line,	"include\gfx_BG.c", 272; #incchr(tiles_ITEM_WEAPON_5,"res/maps/tiles_ITEM_WEAPON_5.png", 2 , 2);
 2282               6260     		.data
 2283    0E:6260             	_tiles_ITEM_WEAPON_5: 	.incchr		"res/maps/tiles_ITEM_WEAPON_5.png", 2, 2
 2284               E309     		.code
 2285                        		.dbg	line,	"include\gfx_BG.c", 273; #incchr(tiles_ITEM_KEY,"res/maps/tiles_ITEM_KEY.png", 2 , 2);
 2286               62E0     		.data
 2287    0E:62E0             	_tiles_ITEM_KEY: 	.incchr		"res/maps/tiles_ITEM_KEY.png", 2, 2
 2288               E309     		.code
 2289                        		.dbg	line,	"include\gfx_BG.c", 274; #incchr(tiles_ITEM_ARMOR_2,"res/maps/tiles_ITEM_ARMOR_2.png", 2 , 2);
 2290               6360     		.data
 2291    0E:6360             	_tiles_ITEM_ARMOR_2: 	.incchr		"res/maps/tiles_ITEM_ARMOR_2.png", 2, 2
 2292               E309     		.code
 2293                        		.dbg	line,	"include\gfx_BG.c", 275; #incchr(tiles_ITEM_ARMOR_3,"res/maps/tiles_ITEM_ARMOR_3.png", 2 , 2);
 2294               63E0     		.data
 2295    0E:63E0             	_tiles_ITEM_ARMOR_3: 	.incchr		"res/maps/tiles_ITEM_ARMOR_3.png", 2, 2
 2296               E309     		.code
 2297                        		.dbg	line,	"include\gfx_BG.c", 276; #incchr(tiles_ITEM_ARMOR_4,"res/maps/tiles_ITEM_ARMOR_4.png", 2 , 2);
 2298               6460     		.data
 2299    0E:6460             	_tiles_ITEM_ARMOR_4: 	.incchr		"res/maps/tiles_ITEM_ARMOR_4.png", 2, 2
 2300               E309     		.code
 2301                        		.dbg	line,	"include\gfx_BG.c", 277; #incchr(tiles_ITEM_ARMOR_5,"res/maps/tiles_ITEM_ARMOR_5.png", 2 , 2);
 2302               64E0     		.data
 2303    0E:64E0             	_tiles_ITEM_ARMOR_5: 	.incchr		"res/maps/tiles_ITEM_ARMOR_5.png", 2, 2
 2304               E309     		.code
 2305                        		.dbg	line,	"include\gfx_BG.c", 278; #incchr(tiles_ITEM_POTION,"res/maps/tiles_ITEM_POTION.png", 2 , 2);
 2306               6560     		.data
 2307    0E:6560             	_tiles_ITEM_POTION: 	.incchr		"res/maps/tiles_ITEM_POTION.png", 2, 2
 2308               E309     		.code
 2309                        		.dbg	line,	"include\gfx_BG.c", 280; //#incchr(tileset_NUMBERS_SHOP_FONT,"res/maps/tiles_NUMBERS_SHOP_FONT.png");
 2310                        		.dbg	line,	"include\gfx_BG.c", 283; //--------------------------------------------------------------------------------------//
 2311                        		.dbg	line,	"include\gfx_BG.c", 284; //                                   EXTRACT PALETTES                                   //
 2312                        		.dbg	line,	"include\gfx_BG.c", 285; //--------------------------------------------------------------------------------------//
 2313                        		.dbg	line,	"include\gfx_BG.c", 287; #incpal(palette_SHOP,"res/maps/tilemap_SHOP_BG_B.png");
 2314               65E0     		.data
 2315    0E:65E0             	_palette_SHOP:	.incpal		"res/maps/tilemap_SHOP_BG_B.png"
 2316               E309     		.code
 2317                        		.dbg	line,	"include\gfx_BG.c", 288; #incpal(palette_SHOP_ITEMS,"res/palettes/palette_SHOP_ITEMS.png");
 2318               67E0     		.data
 2319    0E:67E0             	_palette_SHOP_ITEMS:	.incpal		"res/palettes/palette_SHOP_ITEMS.png"
 2320               E309     		.code
 2321                        		.dbg	line,	"main.c", 12; #include "include/gfx_SPRITES.c"
 2322                        		.dbg	line,	"include\gfx_SPRITES.c", 1; #include "huc.h"
 2323                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 1; #ifndef _hucc_legacy_h
 2324                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 2; #define _hucc_legacy_h
 2325                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 4; /****************************************************************************
 2326                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 5; ; ***************************************************************************
 2327                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 6; ;
 2328                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 7; ; huc.h
 2329                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 8; ;
 2330                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 9; ; HuCC wrapper file to include a default set of HuC-compatible functions.
 2331                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 10; ;
 2332                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 11; ; Copyright John Brandwood 2024.
 2333                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 12; ;
 2334                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 13; ; Distributed under the Boost Software License, Version 1.0.
 2335                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 14; ; (See accompanying file LICENSE_1_0.txt or copy at
 2336                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 15; ;  http://www.boost.org/LICENSE_1_0.txt)
 2337                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 16; ;
 2338                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 17; ; ***************************************************************************
 2339                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 18; ; ***************************************************************************
 2340                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 19; ;
 2341                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 20; ; When the HuCC compiler is invoked with the "--legacy" option to compile old
 2342                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 21; ; projects, then this "huc.h" file is automatically included.
 2343                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 22; ;
 2344                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 23; ; This file includes a set of the individual HuCC headers which correspond to
 2345                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 24; ; HuC's built-in functions and MagicKit library.
 2346                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 25; ;
 2347                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 26; ; New HuCC projects should, preferably, include the specific headers that are
 2348                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 27; ; needed, which will then allow them to replace parts of the standard library
 2349                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 28; ; with newer functions, or they can just manually include this "huc.h" file.
 2350                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 29; ;
 2351                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 30; ; ***************************************************************************
 2352                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 31; ; **************************************************************************/
 2353                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 33; #include "hucc-systemcard.h"
 2354                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 34; #include "hucc-baselib.h"
 2355                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 35; #include "hucc-gfx.h"
 2356                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 36; #include "hucc-string.h"
 2357                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 37; #include "hucc-old-scroll.h"
 2358                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 38; #include "hucc-old-spr.h"
 2359                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 39; #include "hucc-old-map.h"
 2360                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 40; #include "hucc-old-line.h"
 2361                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 42; #endif // _hucc_legacy_h
 2362                        		.dbg	line,	"include\gfx_SPRITES.c", 10; // EXTRACT PLAYER TILES //
 2363                        		.dbg	line,	"include\gfx_SPRITES.c", 11; #incspr(tiles_SPR_PLAYER_ARMOR,"res/sprites/tiles_SPR_PLAYER_ARMOR.png")
 2364               69E0     		.data
 2365    0E:69E0             	_tiles_SPR_PLAYER_ARMOR:	.incspr		"res/sprites/tiles_SPR_PLAYER_ARMOR.png"
 2366               E309     		.code
 2367                        		.dbg	line,	"include\gfx_SPRITES.c", 13; // EXTRACT PLAYER PALETTE //
 2368                        		.dbg	line,	"include\gfx_SPRITES.c", 14; #incpal(palette_PLAYER_1,"res/palettes/palette_PLAYER_1.png");
 2369               69E0     		.data
 2370    0F:69E0             	_palette_PLAYER_1:	.incpal		"res/palettes/palette_PLAYER_1.png"
 2371               E309     		.code
 2372                        		.dbg	line,	"include\gfx_SPRITES.c", 15; #incpal(palette_PLAYER_4,"res/palettes/palette_PLAYER_4.png");
 2373               6BE0     		.data
 2374    0F:6BE0             	_palette_PLAYER_4:	.incpal		"res/palettes/palette_PLAYER_4.png"
 2375               E309     		.code
 2376                        		.dbg	line,	"include\gfx_SPRITES.c", 16; #incpal(palette_PLAYER_5,"res/palettes/palette_PLAYER_5.png");
 2377               6DE0     		.data
 2378    0F:6DE0             	_palette_PLAYER_5:	.incpal		"res/palettes/palette_PLAYER_5.png"
 2379               E309     		.code
 2380                        		.dbg	line,	"include\gfx_SPRITES.c", 17; #incpal(palette_PLAYER_8,"res/palettes/palette_PLAYER_8.png");
 2381               6FE0     		.data
 2382    0F:6FE0             	_palette_PLAYER_8:	.incpal		"res/palettes/palette_PLAYER_8.png"
 2383               E309     		.code
 2384                        		.dbg	line,	"include\gfx_SPRITES.c", 20; #incspr(tiles_SPR_HIT,"res/sprites/tiles_SPR_HIT.png")
 2385               71E0     		.data
 2386    0F:71E0             	_tiles_SPR_HIT:	.incspr		"res/sprites/tiles_SPR_HIT.png"
 2387               E309     		.code
 2388                        		.dbg	line,	"include\gfx_SPRITES.c", 23; // EXTRACT OBJECTS TILES //
 2389                        		.dbg	line,	"include\gfx_SPRITES.c", 24; #incspr(tiles_SPR_BARREL,"res/sprites/tiles_SPR_BARREL.png")
 2390               7260     		.data
 2391    0F:7260             	_tiles_SPR_BARREL:	.incspr		"res/sprites/tiles_SPR_BARREL.png"
 2392               E309     		.code
 2393                        		.dbg	line,	"include\gfx_SPRITES.c", 25; #incspr(tiles_SPR_CHEST,"res/sprites/tiles_SPR_CHEST.png")
 2394               72E0     		.data
 2395    0F:72E0             	_tiles_SPR_CHEST:	.incspr		"res/sprites/tiles_SPR_CHEST.png"
 2396               E309     		.code
 2397                        		.dbg	line,	"include\gfx_SPRITES.c", 26; #incspr(tiles_SPR_COIN_1,"res/sprites/tiles_SPR_COIN_1.png")
 2398               7EE0     		.data
 2399    0F:7EE0             	_tiles_SPR_COIN_1:	.incspr		"res/sprites/tiles_SPR_COIN_1.png"
 2400               E309     		.code
 2401                        		.dbg	line,	"include\gfx_SPRITES.c", 27; #incspr(tiles_SPR_COIN_5,"res/sprites/tiles_SPR_COIN_5.png")
 2402               7F60     		.data
 2403    0F:7F60             	_tiles_SPR_COIN_5:	.incspr		"res/sprites/tiles_SPR_COIN_5.png"
 2404               E309     		.code
 2405                        		.dbg	line,	"include\gfx_SPRITES.c", 28; #incspr(tiles_SPR_COIN_10,"res/sprites/tiles_SPR_COIN_10.png")
 2406               7FE0     		.data
 2407    0F:7FE0             	_tiles_SPR_COIN_10:	.incspr		"res/sprites/tiles_SPR_COIN_10.png"
 2408               E309     		.code
 2409                        		.dbg	line,	"include\gfx_SPRITES.c", 29; #incspr(tiles_SPR_COIN_50,"res/sprites/tiles_SPR_COIN_50.png")
 2410               6060     		.data
 2411    10:6060             	_tiles_SPR_COIN_50:	.incspr		"res/sprites/tiles_SPR_COIN_50.png"
 2412               E309     		.code
 2413                        		.dbg	line,	"include\gfx_SPRITES.c", 30; #incspr(tiles_SPR_COIN_100,"res/sprites/tiles_SPR_COIN_100.png")
 2414               60E0     		.data
 2415    10:60E0             	_tiles_SPR_COIN_100:	.incspr		"res/sprites/tiles_SPR_COIN_100.png"
 2416               E309     		.code
 2417                        		.dbg	line,	"include\gfx_SPRITES.c", 31; #incspr(tiles_SPR_COIN_500,"res/sprites/tiles_SPR_COIN_500.png")
 2418               6160     		.data
 2419    10:6160             	_tiles_SPR_COIN_500:	.incspr		"res/sprites/tiles_SPR_COIN_500.png"
 2420               E309     		.code
 2421                        		.dbg	line,	"include\gfx_SPRITES.c", 32; #incspr(tiles_SPR_COIN_1000,"res/sprites/tiles_SPR_COIN_1000.png")
 2422               61E0     		.data
 2423    10:61E0             	_tiles_SPR_COIN_1000:	.incspr		"res/sprites/tiles_SPR_COIN_1000.png"
 2424               E309     		.code
 2425                        		.dbg	line,	"include\gfx_SPRITES.c", 33; #incspr(tiles_SPR_FRUIT,"res/sprites/tiles_SPR_FRUIT.png")
 2426               6260     		.data
 2427    10:6260             	_tiles_SPR_FRUIT:	.incspr		"res/sprites/tiles_SPR_FRUIT.png"
 2428               E309     		.code
 2429                        		.dbg	line,	"include\gfx_SPRITES.c", 34; #incspr(tiles_SPR_GRAY_KEY,"res/sprites/tiles_SPR_GRAY_KEY.png")
 2430               62E0     		.data
 2431    10:62E0             	_tiles_SPR_GRAY_KEY:	.incspr		"res/sprites/tiles_SPR_GRAY_KEY.png"
 2432               E309     		.code
 2433                        		.dbg	line,	"include\gfx_SPRITES.c", 35; #incspr(tiles_SPR_GOLD_KEY,"res/sprites/tiles_SPR_GOLD_KEY.png")
 2434               6360     		.data
 2435    10:6360             	_tiles_SPR_GOLD_KEY:	.incspr		"res/sprites/tiles_SPR_GOLD_KEY.png"
 2436               E309     		.code
 2437                        		.dbg	line,	"include\gfx_SPRITES.c", 36; #incspr(tiles_SPR_HOURGLASS,"res/sprites/tiles_SPR_HOURGLASS.png")
 2438               63E0     		.data
 2439    10:63E0             	_tiles_SPR_HOURGLASS:	.incspr		"res/sprites/tiles_SPR_HOURGLASS.png"
 2440               E309     		.code
 2441                        		.dbg	line,	"include\gfx_SPRITES.c", 37; #incspr(tiles_SPR_LIFE,"res/sprites/tiles_SPR_LIFE.png")
 2442               6460     		.data
 2443    10:6460             	_tiles_SPR_LIFE:	.incspr		"res/sprites/tiles_SPR_LIFE.png"
 2444               E309     		.code
 2445                        		.dbg	line,	"include\gfx_SPRITES.c", 38; #incspr(tiles_SPR_OCTOPUS,"res/sprites/tiles_SPR_OCTOPUS.png")
 2446               64E0     		.data
 2447    10:64E0             	_tiles_SPR_OCTOPUS:	.incspr		"res/sprites/tiles_SPR_OCTOPUS.png"
 2448               E309     		.code
 2449                        		.dbg	line,	"include\gfx_SPRITES.c", 39; #incspr(tiles_SPR_POT,"res/sprites/tiles_SPR_POT.png")
 2450               6560     		.data
 2451    10:6560             	_tiles_SPR_POT:	.incspr		"res/sprites/tiles_SPR_POT.png"
 2452               E309     		.code
 2453                        		.dbg	line,	"include\gfx_SPRITES.c", 40; #incspr(tiles_SPR_POW,"res/sprites/tiles_SPR_POW.png")
 2454               6960     		.data
 2455    10:6960             	_tiles_SPR_POW:	.incspr		"res/sprites/tiles_SPR_POW.png"
 2456               E309     		.code
 2457                        		.dbg	line,	"include\gfx_SPRITES.c", 41; #incspr(tiles_SPR_STAR,"res/sprites/tiles_SPR_STAR.png")
 2458               69E0     		.data
 2459    10:69E0             	_tiles_SPR_STAR:	.incspr		"res/sprites/tiles_SPR_STAR.png"
 2460               E309     		.code
 2461                        		.dbg	line,	"include\gfx_SPRITES.c", 42; #incspr(tiles_SPR_BAMBOO,"res/sprites/tiles_SPR_BAMBOO.png")
 2462               6A60     		.data
 2463    10:6A60             	_tiles_SPR_BAMBOO:	.incspr		"res/sprites/tiles_SPR_BAMBOO.png"
 2464               E309     		.code
 2465                        		.dbg	line,	"include\gfx_SPRITES.c", 43; #incspr(tiles_SPR_YASHICHI,"res/sprites/tiles_SPR_YASHICHI.png")
 2466               6AE0     		.data
 2467    10:6AE0             	_tiles_SPR_YASHICHI:	.incspr		"res/sprites/tiles_SPR_YASHICHI.png"
 2468               E309     		.code
 2469                        		.dbg	line,	"include\gfx_SPRITES.c", 44; #incspr(tiles_SPR_ELEPHANT,"res/sprites/tiles_SPR_ELEPHANT.png")
 2470               6B60     		.data
 2471    10:6B60             	_tiles_SPR_ELEPHANT:	.incspr		"res/sprites/tiles_SPR_ELEPHANT.png"
 2472               E309     		.code
 2473                        		.dbg	line,	"include\gfx_SPRITES.c", 45; #incspr(tiles_SPR_DRAGONFLY,"res/sprites/tiles_SPR_DRAGONFLY.png")
 2474               6BE0     		.data
 2475    10:6BE0             	_tiles_SPR_DRAGONFLY:	.incspr		"res/sprites/tiles_SPR_DRAGONFLY.png"
 2476               E309     		.code
 2477                        		.dbg	line,	"include\gfx_SPRITES.c", 46; #incspr(tiles_SPR_COW,"res/sprites/tiles_SPR_COW.png")
 2478               6C60     		.data
 2479    10:6C60             	_tiles_SPR_COW:	.incspr		"res/sprites/tiles_SPR_COW.png"
 2480               E309     		.code
 2481                        		.dbg	line,	"include\gfx_SPRITES.c", 47; #incspr(tiles_SPR_MOBICHAN,"res/sprites/tiles_SPR_MOBICHAN.png")
 2482               6CE0     		.data
 2483    10:6CE0             	_tiles_SPR_MOBICHAN:	.incspr		"res/sprites/tiles_SPR_MOBICHAN.png"
 2484               E309     		.code
 2485                        		.dbg	line,	"include\gfx_SPRITES.c", 49; // EXTRACT OBJECTS PALETTE //
 2486                        		.dbg	line,	"include\gfx_SPRITES.c", 50; #incpal(palette_objects_1,"res/palettes/palette_objects_1.png");
 2487               6D60     		.data
 2488    10:6D60             	_palette_objects_1:	.incpal		"res/palettes/palette_objects_1.png"
 2489               E309     		.code
 2490                        		.dbg	line,	"include\gfx_SPRITES.c", 51; #incpal(palette_objects_2,"res/palettes/palette_objects_2.png");
 2491               6F60     		.data
 2492    10:6F60             	_palette_objects_2:	.incpal		"res/palettes/palette_objects_2.png"
 2493               E309     		.code
 2494                        		.dbg	line,	"include\gfx_SPRITES.c", 54; // EXTRACT NPCS TILES //
 2495                        		.dbg	line,	"include\gfx_SPRITES.c", 55; #incspr(tiles_SPR_NPC,"res/sprites/tiles_SPR_NPC.png")
 2496               7160     		.data
 2497    10:7160             	_tiles_SPR_NPC:	.incspr		"res/sprites/tiles_SPR_NPC.png"
 2498               E309     		.code
 2499                        		.dbg	line,	"include\gfx_SPRITES.c", 59; // EXTRACT CURSOR TILES //
 2500                        		.dbg	line,	"include\gfx_SPRITES.c", 60; #incspr(tiles_SPR_CURSOR,"res/sprites/tiles_SPR_CURSOR.png")
 2501               7D60     		.data
 2502    10:7D60             	_tiles_SPR_CURSOR:	.incspr		"res/sprites/tiles_SPR_CURSOR.png"
 2503               E309     		.code
 2504                        		.dbg	line,	"main.c", 15; #include "include/tables_NPC.c"
 2505                        		.dbg	line,	"include\tables_NPC.c", 1; //-----------------------------------------------------------------------------//
 2506                        		.dbg	line,	"include\tables_NPC.c", 2; //                                                                             //
 2507                        		.dbg	line,	"include\tables_NPC.c", 3; //                                   LEVEL 1                                   //
 2508                        		.dbg	line,	"include\tables_NPC.c", 4; //                                                                             //
 2509                        		.dbg	line,	"include\tables_NPC.c", 5; //-----------------------------------------------------------------------------//
 2510                        		.dbg	line,	"include\tables_NPC.c", 7; const char              TABLE_NPC_TYPE_LV1[NPC_NUMBER_LV1]              =   {
 2511                        		.dbg	line,	"include\tables_NPC.c", 8; TYPE_NPC_SHOP,
 2512                        		.dbg	line,	"include\tables_NPC.c", 9; TYPE_NPC_REWARD
 2513                        		.dbg	line,	"include\tables_NPC.c", 10; };
 2514                        		.dbg	line,	"include\tables_NPC.c", 13; const signed int        TABLE_NPC_X_POS_REF_LV1[NPC_NUMBER_LV1]         =   {
 2515                        		.dbg	line,	"include\tables_NPC.c", 14; 912,
 2516                        		.dbg	line,	"include\tables_NPC.c", 15; 1232
 2517                        		.dbg	line,	"include\tables_NPC.c", 16; };
 2518                        		.dbg	line,	"include\tables_NPC.c", 19; const signed int        TABLE_NPC_Y_POS_REF_LV1[NPC_NUMBER_LV1]         =   {
 2519                        		.dbg	line,	"include\tables_NPC.c", 20; 576,
 2520                        		.dbg	line,	"include\tables_NPC.c", 21; 400
 2521                        		.dbg	line,	"include\tables_NPC.c", 22; };
 2522                        		.dbg	line,	"main.c", 16; #include "include/tables_OBJECT.c"
 2523                        		.dbg	line,	"include\tables_OBJECT.c", 1; //-----------------------------------------------------------------------------//
 2524                        		.dbg	line,	"include\tables_OBJECT.c", 2; //                                                                             //
 2525                        		.dbg	line,	"include\tables_OBJECT.c", 3; //                                   LEVEL 1                                   //
 2526                        		.dbg	line,	"include\tables_OBJECT.c", 4; //                                                                             //
 2527                        		.dbg	line,	"include\tables_OBJECT.c", 5; //-----------------------------------------------------------------------------//
 2528                        		.dbg	line,	"include\tables_OBJECT.c", 7; const char              TABLE_OBJECT_TYPE_LV1[OBJECT_NUMBER_LV1]      =   {
 2529                        		.dbg	line,	"include\tables_OBJECT.c", 8; TYPE_HOURGLASS,
 2530                        		.dbg	line,	"include\tables_OBJECT.c", 9; TYPE_POT,
 2531                        		.dbg	line,	"include\tables_OBJECT.c", 10; TYPE_POT,
 2532                        		.dbg	line,	"include\tables_OBJECT.c", 11; TYPE_POT,
 2533                        		.dbg	line,	"include\tables_OBJECT.c", 12; TYPE_POT,
 2534                        		.dbg	line,	"include\tables_OBJECT.c", 13; TYPE_POT,
 2535                        		.dbg	line,	"include\tables_OBJECT.c", 14; TYPE_POT,
 2536                        		.dbg	line,	"include\tables_OBJECT.c", 15; TYPE_POW,
 2537                        		.dbg	line,	"include\tables_OBJECT.c", 16; TYPE_POT,
 2538                        		.dbg	line,	"include\tables_OBJECT.c", 17; TYPE_POT,
 2539                        		.dbg	line,	"include\tables_OBJECT.c", 19; //
 2540                        		.dbg	line,	"include\tables_OBJECT.c", 20; TYPE_POT,
 2541                        		.dbg	line,	"include\tables_OBJECT.c", 21; TYPE_POT,
 2542                        		.dbg	line,	"include\tables_OBJECT.c", 22; TYPE_POT,
 2543                        		.dbg	line,	"include\tables_OBJECT.c", 23; TYPE_POT,
 2544                        		.dbg	line,	"include\tables_OBJECT.c", 24; TYPE_POT,
 2545                        		.dbg	line,	"include\tables_OBJECT.c", 25; TYPE_POT,
 2546                        		.dbg	line,	"include\tables_OBJECT.c", 26; TYPE_POT,
 2547                        		.dbg	line,	"include\tables_OBJECT.c", 27; TYPE_POT,
 2548                        		.dbg	line,	"include\tables_OBJECT.c", 28; TYPE_POT,
 2549                        		.dbg	line,	"include\tables_OBJECT.c", 29; TYPE_POT,
 2550                        		.dbg	line,	"include\tables_OBJECT.c", 31; //
 2551                        		.dbg	line,	"include\tables_OBJECT.c", 32; TYPE_POT,
 2552                        		.dbg	line,	"include\tables_OBJECT.c", 33; TYPE_POT,
 2553                        		.dbg	line,	"include\tables_OBJECT.c", 34; TYPE_POT
 2554                        		.dbg	line,	"include\tables_OBJECT.c", 35; };
 2555                        		.dbg	line,	"include\tables_OBJECT.c", 38; const signed int        TABLE_OBJECT_X_POS_REF_LV1[OBJECT_NUMBER_LV1] =   {
 2556                        		.dbg	line,	"include\tables_OBJECT.c", 39; 1680,
 2557                        		.dbg	line,	"include\tables_OBJECT.c", 40; 1280,
 2558                        		.dbg	line,	"include\tables_OBJECT.c", 41; 1472,
 2559                        		.dbg	line,	"include\tables_OBJECT.c", 42; 1440,
 2560                        		.dbg	line,	"include\tables_OBJECT.c", 43; 1168,
 2561                        		.dbg	line,	"include\tables_OBJECT.c", 44; 1200,
 2562                        		.dbg	line,	"include\tables_OBJECT.c", 45; 960,
 2563                        		.dbg	line,	"include\tables_OBJECT.c", 46; 984,
 2564                        		.dbg	line,	"include\tables_OBJECT.c", 47; 1360,
 2565                        		.dbg	line,	"include\tables_OBJECT.c", 48; 1392,
 2566                        		.dbg	line,	"include\tables_OBJECT.c", 50; //
 2567                        		.dbg	line,	"include\tables_OBJECT.c", 51; 1552,
 2568                        		.dbg	line,	"include\tables_OBJECT.c", 52; 1680,
 2569                        		.dbg	line,	"include\tables_OBJECT.c", 53; 1712,
 2570                        		.dbg	line,	"include\tables_OBJECT.c", 54; 1744,
 2571                        		.dbg	line,	"include\tables_OBJECT.c", 55; 1248,
 2572                        		.dbg	line,	"include\tables_OBJECT.c", 56; 1280,
 2573                        		.dbg	line,	"include\tables_OBJECT.c", 57; 1168,
 2574                        		.dbg	line,	"include\tables_OBJECT.c", 58; 1040,
 2575                        		.dbg	line,	"include\tables_OBJECT.c", 59; 640,
 2576                        		.dbg	line,	"include\tables_OBJECT.c", 60; 672,
 2577                        		.dbg	line,	"include\tables_OBJECT.c", 62; //
 2578                        		.dbg	line,	"include\tables_OBJECT.c", 63; 336,
 2579                        		.dbg	line,	"include\tables_OBJECT.c", 64; 368,
 2580                        		.dbg	line,	"include\tables_OBJECT.c", 65; 416
 2581                        		.dbg	line,	"include\tables_OBJECT.c", 66; };
 2582                        		.dbg	line,	"include\tables_OBJECT.c", 69; const signed int        TABLE_OBJECT_Y_POS_REF_LV1[OBJECT_NUMBER_LV1] =   {
 2583                        		.dbg	line,	"include\tables_OBJECT.c", 70; 384,
 2584                        		.dbg	line,	"include\tables_OBJECT.c", 71; 416,
 2585                        		.dbg	line,	"include\tables_OBJECT.c", 72; 480,
 2586                        		.dbg	line,	"include\tables_OBJECT.c", 73; 496,
 2587                        		.dbg	line,	"include\tables_OBJECT.c", 74; 560,
 2588                        		.dbg	line,	"include\tables_OBJECT.c", 75; 560,
 2589                        		.dbg	line,	"include\tables_OBJECT.c", 76; 592,
 2590                        		.dbg	line,	"include\tables_OBJECT.c", 77; 592,
 2591                        		.dbg	line,	"include\tables_OBJECT.c", 78; 592,
 2592                        		.dbg	line,	"include\tables_OBJECT.c", 79; 592,
 2593                        		.dbg	line,	"include\tables_OBJECT.c", 81; //
 2594                        		.dbg	line,	"include\tables_OBJECT.c", 82; 704,
 2595                        		.dbg	line,	"include\tables_OBJECT.c", 83; 720,
 2596                        		.dbg	line,	"include\tables_OBJECT.c", 84; 720,
 2597                        		.dbg	line,	"include\tables_OBJECT.c", 85; 720,
 2598                        		.dbg	line,	"include\tables_OBJECT.c", 86; 736,
 2599                        		.dbg	line,	"include\tables_OBJECT.c", 87; 736,
 2600                        		.dbg	line,	"include\tables_OBJECT.c", 88; 752,
 2601                        		.dbg	line,	"include\tables_OBJECT.c", 89; 848,
 2602                        		.dbg	line,	"include\tables_OBJECT.c", 90; 880,
 2603                        		.dbg	line,	"include\tables_OBJECT.c", 91; 880,
 2604                        		.dbg	line,	"include\tables_OBJECT.c", 93; //
 2605                        		.dbg	line,	"include\tables_OBJECT.c", 94; 896,
 2606                        		.dbg	line,	"include\tables_OBJECT.c", 95; 896,
 2607                        		.dbg	line,	"include\tables_OBJECT.c", 96; 896
 2608                        		.dbg	line,	"include\tables_OBJECT.c", 97; };
 2609                        		.dbg	line,	"include\tables_OBJECT.c", 100; /*const char              TABLE_REWARD_TYPE_LV1[OBJECT_NUMBER_LV1]       =   {
 2610                        		.dbg	line,	"include\tables_OBJECT.c", 101; TYPE_POT
 2611                        		.dbg	line,	"include\tables_OBJECT.c", 102; TYPE_POT,
 2612                        		.dbg	line,	"include\tables_OBJECT.c", 103; TYPE_POT,
 2613                        		.dbg	line,	"include\tables_OBJECT.c", 104; TYPE_POT,
 2614                        		.dbg	line,	"include\tables_OBJECT.c", 105; TYPE_POT,
 2615                        		.dbg	line,	"include\tables_OBJECT.c", 106; TYPE_POT,
 2616                        		.dbg	line,	"include\tables_OBJECT.c", 107; TYPE_POT,
 2617                        		.dbg	line,	"include\tables_OBJECT.c", 108; TYPE_POW,
 2618                        		.dbg	line,	"include\tables_OBJECT.c", 109; TYPE_POT,
 2619                        		.dbg	line,	"include\tables_OBJECT.c", 110; TYPE_POT,
 2620                        		.dbg	line,	"include\tables_OBJECT.c", 112; //
 2621                        		.dbg	line,	"include\tables_OBJECT.c", 113; TYPE_POT,
 2622                        		.dbg	line,	"include\tables_OBJECT.c", 114; TYPE_POT,
 2623                        		.dbg	line,	"include\tables_OBJECT.c", 115; TYPE_POT,
 2624                        		.dbg	line,	"include\tables_OBJECT.c", 116; TYPE_POT,
 2625                        		.dbg	line,	"include\tables_OBJECT.c", 117; TYPE_POT,
 2626                        		.dbg	line,	"include\tables_OBJECT.c", 118; TYPE_POT,
 2627                        		.dbg	line,	"include\tables_OBJECT.c", 119; TYPE_POT,
 2628                        		.dbg	line,	"include\tables_OBJECT.c", 120; TYPE_POT,
 2629                        		.dbg	line,	"include\tables_OBJECT.c", 122; //
 2630                        		.dbg	line,	"include\tables_OBJECT.c", 123; TYPE_GRAY_KEY,
 2631                        		.dbg	line,	"include\tables_OBJECT.c", 124; TYPE_GRAY_KEY,
 2632                        		.dbg	line,	"include\tables_OBJECT.c", 125; TYPE_GRAY_KEY,
 2633                        		.dbg	line,	"include\tables_OBJECT.c", 126; TYPE_COIN_5,
 2634                        		.dbg	line,	"include\tables_OBJECT.c", 127; TYPE_GRAY_KEY
 2635                        		.dbg	line,	"include\tables_OBJECT.c", 128; };*/
 2636                        		.dbg	line,	"include\tables_OBJECT.c", 133; const signed int        TABLE_CHEST_X_POS_REF_LV1[CHEST_NUMBER_LV1]   =   {
 2637                        		.dbg	line,	"include\tables_OBJECT.c", 134; 1072,
 2638                        		.dbg	line,	"include\tables_OBJECT.c", 135; 816
 2639                        		.dbg	line,	"include\tables_OBJECT.c", 136; };
 2640                        		.dbg	line,	"include\tables_OBJECT.c", 139; const signed int        TABLE_CHEST_Y_POS_REF_LV1[CHEST_NUMBER_LV1]   =   {
 2641                        		.dbg	line,	"include\tables_OBJECT.c", 140; 832,
 2642                        		.dbg	line,	"include\tables_OBJECT.c", 141; 848
 2643                        		.dbg	line,	"main.c", 16; };
 2644                        		.dbg	line,	"main.c", 17; #include "include/tables_PLAYER.c"
 2645                        		.dbg	line,	"include\tables_PLAYER.c", 3; const unsigned char     *TABLE_PLAYER_TILES_ADR[2]     =   {
 2646                        		.dbg	line,	"include\tables_PLAYER.c", 4; &tiles_SPR_PLAYER_ARMOR,
 2647                        		.dbg	line,	"include\tables_PLAYER.c", 5; &tiles_SPR_PLAYER_ARMOR
 2648                        		.dbg	line,	"include\tables_PLAYER.c", 6; };
 2649                        		.dbg	line,	"include\tables_PLAYER.c", 9; const unsigned char     TABLE_PLAYER_TILES_BANK[2]     =   {
 2650                        		.dbg	line,	"include\tables_PLAYER.c", 10; ^tiles_SPR_PLAYER_ARMOR,
 2651                        		.dbg	line,	"include\tables_PLAYER.c", 11; ^tiles_SPR_PLAYER_ARMOR
 2652                        		.dbg	line,	"include\tables_PLAYER.c", 12; };
 2653                        		.dbg	line,	"include\tables_PLAYER.c", 15; const signed char       TABLE_PLAYER_JUMP_V[35]     =   {
 2654                        		.dbg	line,	"include\tables_PLAYER.c", 16; // UPWARD
 2655                        		.dbg	line,	"include\tables_PLAYER.c", 17; -4,
 2656                        		.dbg	line,	"include\tables_PLAYER.c", 18; -5,
 2657                        		.dbg	line,	"include\tables_PLAYER.c", 19; -10,
 2658                        		.dbg	line,	"include\tables_PLAYER.c", 20; -4,
 2659                        		.dbg	line,	"include\tables_PLAYER.c", 21; -4,
 2660                        		.dbg	line,	"include\tables_PLAYER.c", 22; -7,
 2661                        		.dbg	line,	"include\tables_PLAYER.c", 23; -6,
 2662                        		.dbg	line,	"include\tables_PLAYER.c", 24; -3,
 2663                        		.dbg	line,	"include\tables_PLAYER.c", 25; -5,
 2664                        		.dbg	line,	"include\tables_PLAYER.c", 26; -2,
 2665                        		.dbg	line,	"include\tables_PLAYER.c", 27; -4,
 2666                        		.dbg	line,	"include\tables_PLAYER.c", 28; -1,
 2667                        		.dbg	line,	"include\tables_PLAYER.c", 29; -1,
 2668                        		.dbg	line,	"include\tables_PLAYER.c", 30; -1,
 2669                        		.dbg	line,	"include\tables_PLAYER.c", 31; -1,
 2670                        		.dbg	line,	"include\tables_PLAYER.c", 32; 0,
 2671                        		.dbg	line,	"include\tables_PLAYER.c", 33; 0,
 2672                        		.dbg	line,	"include\tables_PLAYER.c", 34; 0,
 2673                        		.dbg	line,	"include\tables_PLAYER.c", 35; 0,
 2674                        		.dbg	line,	"include\tables_PLAYER.c", 36; // DOWNWARD
 2675                        		.dbg	line,	"include\tables_PLAYER.c", 37; 1,
 2676                        		.dbg	line,	"include\tables_PLAYER.c", 38; 1,
 2677                        		.dbg	line,	"include\tables_PLAYER.c", 39; 1,
 2678                        		.dbg	line,	"include\tables_PLAYER.c", 40; 1,
 2679                        		.dbg	line,	"include\tables_PLAYER.c", 41; 4,
 2680                        		.dbg	line,	"include\tables_PLAYER.c", 42; 2,
 2681                        		.dbg	line,	"include\tables_PLAYER.c", 43; 5,
 2682                        		.dbg	line,	"include\tables_PLAYER.c", 44; 3,
 2683                        		.dbg	line,	"include\tables_PLAYER.c", 45; 6,
 2684                        		.dbg	line,	"include\tables_PLAYER.c", 46; 7,
 2685                        		.dbg	line,	"include\tables_PLAYER.c", 47; 4,
 2686                        		.dbg	line,	"include\tables_PLAYER.c", 48; 4,
 2687                        		.dbg	line,	"include\tables_PLAYER.c", 49; 10,
 2688                        		.dbg	line,	"include\tables_PLAYER.c", 50; 4,
 2689                        		.dbg	line,	"include\tables_PLAYER.c", 51; 4,
 2690                        		.dbg	line,	"include\tables_PLAYER.c", 52; 5
 2691                        		.dbg	line,	"include\tables_PLAYER.c", 53; };
 2692                        		.dbg	line,	"include\tables_PLAYER.c", 56; const signed char       TABLE_PLAYER_FALL[21]       =   {
 2693                        		.dbg	line,	"include\tables_PLAYER.c", 57; 0,
 2694                        		.dbg	line,	"include\tables_PLAYER.c", 58; 0,
 2695                        		.dbg	line,	"include\tables_PLAYER.c", 59; 0,
 2696                        		.dbg	line,	"include\tables_PLAYER.c", 60; 0,
 2697                        		.dbg	line,	"include\tables_PLAYER.c", 61; 1,
 2698                        		.dbg	line,	"include\tables_PLAYER.c", 62; 1,
 2699                        		.dbg	line,	"include\tables_PLAYER.c", 63; 1,
 2700                        		.dbg	line,	"include\tables_PLAYER.c", 64; 1,
 2701                        		.dbg	line,	"include\tables_PLAYER.c", 65; 2,
 2702                        		.dbg	line,	"include\tables_PLAYER.c", 66; 2,
 2703                        		.dbg	line,	"include\tables_PLAYER.c", 67; 2,
 2704                        		.dbg	line,	"include\tables_PLAYER.c", 68; 2,
 2705                        		.dbg	line,	"include\tables_PLAYER.c", 69; 3,
 2706                        		.dbg	line,	"include\tables_PLAYER.c", 70; 3,
 2707                        		.dbg	line,	"include\tables_PLAYER.c", 71; 3,
 2708                        		.dbg	line,	"include\tables_PLAYER.c", 72; 4,
 2709                        		.dbg	line,	"include\tables_PLAYER.c", 73; 4,
 2710                        		.dbg	line,	"include\tables_PLAYER.c", 74; 4,
 2711                        		.dbg	line,	"include\tables_PLAYER.c", 75; 4,
 2712                        		.dbg	line,	"include\tables_PLAYER.c", 76; 4,
 2713                        		.dbg	line,	"include\tables_PLAYER.c", 77; 5
 2714                        		.dbg	line,	"include\tables_PLAYER.c", 78; };
 2715                        		.dbg	line,	"include\tables_PLAYER.c", 81; const signed char       TABLE_PLAYER_JUMP_LADDER[30]    =   {
 2716                        		.dbg	line,	"include\tables_PLAYER.c", 82; // UPWARD
 2717                        		.dbg	line,	"include\tables_PLAYER.c", 83; -4,
 2718                        		.dbg	line,	"include\tables_PLAYER.c", 84; -4,
 2719                        		.dbg	line,	"include\tables_PLAYER.c", 85; -3,
 2720                        		.dbg	line,	"include\tables_PLAYER.c", 86; -3,
 2721                        		.dbg	line,	"include\tables_PLAYER.c", 87; -3,
 2722                        		.dbg	line,	"include\tables_PLAYER.c", 88; -2,
 2723                        		.dbg	line,	"include\tables_PLAYER.c", 89; -2,
 2724                        		.dbg	line,	"include\tables_PLAYER.c", 90; -2,
 2725                        		.dbg	line,	"include\tables_PLAYER.c", 91; -1,
 2726                        		.dbg	line,	"include\tables_PLAYER.c", 92; -1,
 2727                        		.dbg	line,	"include\tables_PLAYER.c", 93; -1,
 2728                        		.dbg	line,	"include\tables_PLAYER.c", 94; -1,
 2729                        		.dbg	line,	"include\tables_PLAYER.c", 95; -1,
 2730                        		.dbg	line,	"include\tables_PLAYER.c", 96; 0,
 2731                        		.dbg	line,	"include\tables_PLAYER.c", 97; 0,
 2732                        		.dbg	line,	"include\tables_PLAYER.c", 98; 0,
 2733                        		.dbg	line,	"include\tables_PLAYER.c", 99; 0,
 2734                        		.dbg	line,	"include\tables_PLAYER.c", 100; // DOWNWARD
 2735                        		.dbg	line,	"include\tables_PLAYER.c", 101; 1,
 2736                        		.dbg	line,	"include\tables_PLAYER.c", 102; 1,
 2737                        		.dbg	line,	"include\tables_PLAYER.c", 103; 1,
 2738                        		.dbg	line,	"include\tables_PLAYER.c", 104; 1,
 2739                        		.dbg	line,	"include\tables_PLAYER.c", 105; 1,
 2740                        		.dbg	line,	"include\tables_PLAYER.c", 106; 2,
 2741                        		.dbg	line,	"include\tables_PLAYER.c", 107; 2,
 2742                        		.dbg	line,	"include\tables_PLAYER.c", 108; 2,
 2743                        		.dbg	line,	"include\tables_PLAYER.c", 109; 3,
 2744                        		.dbg	line,	"include\tables_PLAYER.c", 110; 3,
 2745                        		.dbg	line,	"include\tables_PLAYER.c", 111; 3,
 2746                        		.dbg	line,	"include\tables_PLAYER.c", 112; 4,
 2747                        		.dbg	line,	"include\tables_PLAYER.c", 113; 4
 2748                        		.dbg	line,	"main.c", 17; };
 2749                        		.dbg	line,	"main.c", 18; #include "include/tables_SHOP.c"
 2750                        		.dbg	line,	"include\tables_SHOP.c", 1; //-----------------------------------------------------------------------------//
 2751                        		.dbg	line,	"include\tables_SHOP.c", 2; //                                                                             //
 2752                        		.dbg	line,	"include\tables_SHOP.c", 3; //                                   LEVEL 1                                   //
 2753                        		.dbg	line,	"include\tables_SHOP.c", 4; //                                                                             //
 2754                        		.dbg	line,	"include\tables_SHOP.c", 5; //-----------------------------------------------------------------------------//
 2755                        		.dbg	line,	"include\tables_SHOP.c", 7; const char              TABLE_SHOP_ITEMS_LV1[10]        =   {
 2756                        		.dbg	line,	"include\tables_SHOP.c", 8; TYPE_ITEM_WEAPON_2,
 2757                        		.dbg	line,	"include\tables_SHOP.c", 9; TYPE_ITEM_WEAPON_3,
 2758                        		.dbg	line,	"include\tables_SHOP.c", 10; TYPE_ITEM_WEAPON_4,
 2759                        		.dbg	line,	"include\tables_SHOP.c", 11; TYPE_ITEM_WEAPON_5,
 2760                        		.dbg	line,	"include\tables_SHOP.c", 12; TYPE_ITEM_KEY,
 2761                        		.dbg	line,	"include\tables_SHOP.c", 14; TYPE_ITEM_ARMOR_2,
 2762                        		.dbg	line,	"include\tables_SHOP.c", 15; TYPE_ITEM_ARMOR_3,
 2763                        		.dbg	line,	"include\tables_SHOP.c", 16; TYPE_ITEM_ARMOR_4,
 2764                        		.dbg	line,	"include\tables_SHOP.c", 17; TYPE_ITEM_ARMOR_5,
 2765                        		.dbg	line,	"include\tables_SHOP.c", 18; TYPE_ITEM_POTION
 2766                        		.dbg	line,	"include\tables_SHOP.c", 19; };
 2767                        		.dbg	line,	"include\tables_SHOP.c", 22; const int               TABLE_SHOP_PRICES_LV1[10]       =   {
 2768                        		.dbg	line,	"include\tables_SHOP.c", 23; 100,
 2769                        		.dbg	line,	"include\tables_SHOP.c", 24; 1000,
 2770                        		.dbg	line,	"include\tables_SHOP.c", 25; 2400,
 2771                        		.dbg	line,	"include\tables_SHOP.c", 26; 9600,
 2772                        		.dbg	line,	"include\tables_SHOP.c", 27; 30,
 2773                        		.dbg	line,	"include\tables_SHOP.c", 28; 80,
 2774                        		.dbg	line,	"include\tables_SHOP.c", 29; 300,
 2775                        		.dbg	line,	"include\tables_SHOP.c", 30; 800,
 2776                        		.dbg	line,	"include\tables_SHOP.c", 31; 1600,
 2777                        		.dbg	line,	"include\tables_SHOP.c", 32; 150
 2778                        		.dbg	line,	"include\tables_SHOP.c", 33; };
 2779                        		.dbg	line,	"include\tables_SHOP.c", 36; const unsigned char     *TABLE_SHOP_ITEMS_TILES_ADR[10]     =   {
 2780                        		.dbg	line,	"include\tables_SHOP.c", 37; &tiles_ITEM_WEAPON_2,
 2781                        		.dbg	line,	"include\tables_SHOP.c", 38; &tiles_ITEM_WEAPON_3,
 2782                        		.dbg	line,	"include\tables_SHOP.c", 39; &tiles_ITEM_WEAPON_4,
 2783                        		.dbg	line,	"include\tables_SHOP.c", 40; &tiles_ITEM_WEAPON_5,
 2784                        		.dbg	line,	"include\tables_SHOP.c", 41; &tiles_ITEM_KEY,
 2785                        		.dbg	line,	"include\tables_SHOP.c", 42; &tiles_ITEM_ARMOR_2,
 2786                        		.dbg	line,	"include\tables_SHOP.c", 43; &tiles_ITEM_ARMOR_3,
 2787                        		.dbg	line,	"include\tables_SHOP.c", 44; &tiles_ITEM_ARMOR_4,
 2788                        		.dbg	line,	"include\tables_SHOP.c", 45; &tiles_ITEM_ARMOR_5,
 2789                        		.dbg	line,	"include\tables_SHOP.c", 46; &tiles_ITEM_POTION
 2790                        		.dbg	line,	"include\tables_SHOP.c", 47; };
 2791                        		.dbg	line,	"include\tables_SHOP.c", 50; const unsigned char     TABLE_SHOP_ITEMS_TILES_BANK[10]     =   {
 2792                        		.dbg	line,	"include\tables_SHOP.c", 51; ^tiles_ITEM_WEAPON_2,
 2793                        		.dbg	line,	"include\tables_SHOP.c", 52; ^tiles_ITEM_WEAPON_3,
 2794                        		.dbg	line,	"include\tables_SHOP.c", 53; ^tiles_ITEM_WEAPON_4,
 2795                        		.dbg	line,	"include\tables_SHOP.c", 54; ^tiles_ITEM_WEAPON_5,
 2796                        		.dbg	line,	"include\tables_SHOP.c", 55; ^tiles_ITEM_KEY,
 2797                        		.dbg	line,	"include\tables_SHOP.c", 56; ^tiles_ITEM_ARMOR_2,
 2798                        		.dbg	line,	"include\tables_SHOP.c", 57; ^tiles_ITEM_ARMOR_3,
 2799                        		.dbg	line,	"include\tables_SHOP.c", 58; ^tiles_ITEM_ARMOR_4,
 2800                        		.dbg	line,	"include\tables_SHOP.c", 59; ^tiles_ITEM_ARMOR_5,
 2801                        		.dbg	line,	"include\tables_SHOP.c", 60; ^tiles_ITEM_POTION
 2802                        		.dbg	line,	"include\tables_SHOP.c", 61; };
 2803                        		.dbg	line,	"include\tables_SHOP.c", 64; const char              TABLE_CURSOR_POS_X[11]              =   {
 2804                        		.dbg	line,	"include\tables_SHOP.c", 65; 24,
 2805                        		.dbg	line,	"include\tables_SHOP.c", 66; 56,
 2806                        		.dbg	line,	"include\tables_SHOP.c", 67; 96,
 2807                        		.dbg	line,	"include\tables_SHOP.c", 68; 136,
 2808                        		.dbg	line,	"include\tables_SHOP.c", 69; 176,
 2809                        		.dbg	line,	"include\tables_SHOP.c", 70; 24,
 2810                        		.dbg	line,	"include\tables_SHOP.c", 71; 56,
 2811                        		.dbg	line,	"include\tables_SHOP.c", 72; 96,
 2812                        		.dbg	line,	"include\tables_SHOP.c", 73; 136,
 2813                        		.dbg	line,	"include\tables_SHOP.c", 74; 176,
 2814                        		.dbg	line,	"include\tables_SHOP.c", 75; 212
 2815                        		.dbg	line,	"include\tables_SHOP.c", 76; };
 2816                        		.dbg	line,	"main.c", 22; #include "include/routines_LEVELS.c"
 2817                        		.dbg	line,	"include\routines_LEVELS.c", 1; #include "huc.h"
 2818                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 1; #ifndef _hucc_legacy_h
 2819                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 2; #define _hucc_legacy_h
 2820                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 4; /****************************************************************************
 2821                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 5; ; ***************************************************************************
 2822                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 6; ;
 2823                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 7; ; huc.h
 2824                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 8; ;
 2825                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 9; ; HuCC wrapper file to include a default set of HuC-compatible functions.
 2826                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 10; ;
 2827                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 11; ; Copyright John Brandwood 2024.
 2828                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 12; ;
 2829                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 13; ; Distributed under the Boost Software License, Version 1.0.
 2830                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 14; ; (See accompanying file LICENSE_1_0.txt or copy at
 2831                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 15; ;  http://www.boost.org/LICENSE_1_0.txt)
 2832                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 16; ;
 2833                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 17; ; ***************************************************************************
 2834                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 18; ; ***************************************************************************
 2835                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 19; ;
 2836                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 20; ; When the HuCC compiler is invoked with the "--legacy" option to compile old
 2837                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 21; ; projects, then this "huc.h" file is automatically included.
 2838                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 22; ;
 2839                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 23; ; This file includes a set of the individual HuCC headers which correspond to
 2840                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 24; ; HuC's built-in functions and MagicKit library.
 2841                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 25; ;
 2842                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 26; ; New HuCC projects should, preferably, include the specific headers that are
 2843                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 27; ; needed, which will then allow them to replace parts of the standard library
 2844                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 28; ; with newer functions, or they can just manually include this "huc.h" file.
 2845                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 29; ;
 2846                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 30; ; ***************************************************************************
 2847                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 31; ; **************************************************************************/
 2848                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 33; #include "hucc-systemcard.h"
 2849                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 34; #include "hucc-baselib.h"
 2850                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 35; #include "hucc-gfx.h"
 2851                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 36; #include "hucc-string.h"
 2852                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 37; #include "hucc-old-scroll.h"
 2853                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 38; #include "hucc-old-spr.h"
 2854                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 39; #include "hucc-old-map.h"
 2855                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 40; #include "hucc-old-line.h"
 2856                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 42; #endif // _hucc_legacy_h
 2857                        		.dbg	line,	"include\routines_LEVELS.c", 2; #include "hucc-scroll.h"
 2858                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 1; #ifndef _hucc_scroll_h
 2859                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 2; #define _hucc_scroll_h
 2860                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 4; /****************************************************************************
 2861                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 5; ; ***************************************************************************
 2862                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 6; ;
 2863                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 7; ; hucc-scroll.h
 2864                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 8; ;
 2865                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 9; ; Routines for a fast split-screen scrolling system.
 2866                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 10; ;
 2867                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 11; ; Copyright John Brandwood 2024.
 2868                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 12; ;
 2869                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 13; ; Distributed under the Boost Software License, Version 1.0.
 2870                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 14; ; (See accompanying file LICENSE_1_0.txt or copy at
 2871                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 15; ;  http://www.boost.org/LICENSE_1_0.txt)
 2872                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 16; ;
 2873                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 17; ; ***************************************************************************
 2874                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 18; ; ***************************************************************************
 2875                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 19; ;
 2876                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 20; ; The maximum number of splits for each screen layer is set in your project's
 2877                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 21; ; "hucc-config.inc" file, with the library having a limit of 128-per-layer.
 2878                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 22; ;
 2879                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 23; ; Your first active split must be defined to start at screen line 0, and then
 2880                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 24; ; the rest of the active splits must be in increasing line order to match the
 2881                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 25; ; way that the PC Engine displays the output image.
 2882                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 26; ;
 2883                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 27; ; You can have disabled splits interleaved with your active splits.
 2884                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 28; ;
 2885                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 29; ; Splits that are normally disabled can be used to create full screen effects
 2886                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 30; ; such as bouncing the screen up and down by adding blank areas at the top or
 2887                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 31; ; bottom of the screen, and then rapidly changing the height of those areas.
 2888                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 32; ;
 2889                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 33; ; ***************************************************************************
 2890                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 34; ; **************************************************************************/
 2891                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 36; // *************
 2892                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 37; // VDC bits for display_flags ...
 2893                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 38; // *************
 2894                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 40; #ifndef BKG_OFF
 2895                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 41; #define BKG_OFF 0x00
 2896                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 42; #endif
 2897                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 44; #ifndef SPR_OFF
 2898                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 45; #define SPR_OFF 0x00
 2899                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 46; #endif
 2900                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 48; #ifndef BKG_ON
 2901                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 49; #define BKG_ON 0x80
 2902                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 50; #endif
 2903                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 52; #ifndef SPR_ON
 2904                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 53; #define SPR_ON 0x40
 2905                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 54; #endif
 2906                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 56; // *************
 2907                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 57; // Functions in hucc-scroll.asm ...
 2908                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 58; // *************
 2909                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 60; #ifdef __HUCC__
 2910                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 62; #asmdef	HUCC_USES_NEW_SCROLL 1
 2911                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 64; extern void __fastcall scroll_split( unsigned char index<_al>, unsigned char screen_line<_ah>, unsigned int bat_x<_bx>, unsigned int bat_y<_cx>, unsigned char display_flags<_dl> );
 2912                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 65; extern void __fastcall sgx_scroll_split( unsigned char index<_al>, unsigned char screen_line<_ah>, unsigned int bat_x<_bx>, unsigned int bat_y<_cx>, unsigned char display_flags<_dl> );
 2913                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 67; extern void __fastcall disable_split( unsigned char index<acc> );
 2914                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 68; extern void __fastcall sgx_disable_split( unsigned char index<acc> );
 2915                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 70; extern void __fastcall __macro disable_all_splits( void );
 2916                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 71; extern void __fastcall __macro sgx_disable_all_splits( void );
 2917                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 73; #asm
 2918                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 74; .macro	_disable_all_splits
 2919                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 75; ldy	#HUCC_PCE_SPLITS - 1
 2920                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 76; !loop:		tya
 2921                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 77; call	_disable_split.1
 2922                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 78; dey
 2923                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 79; bpl	!loop-
 2924                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 80; .endm
 2925                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 82; .macro	_sgx_disable_all_splits
 2926                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 83; ldy	#HUCC_SGX_SPLITS - 1
 2927                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 84; !loop:		tya
 2928                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 85; call	_sgx_disable_split.1
 2929                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 86; dey
 2930                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 87; bpl	!loop-
 2931                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 88; .endm
 2932                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 89; #endasm
 2933                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 91; #endif // __HUCC__
 2934                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 93; #endif // _hucc_scroll_h
 2935                        		.dbg	line,	"include\routines_LEVELS.c", 3; #include "hucc-chrmap.h"
 2936                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 1; #ifndef _hucc_chrmap_h
 2937                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 2; #define _hucc_chrmap_h
 2938                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 4; /****************************************************************************
 2939                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 5; ; ***************************************************************************
 2940                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 6; ;
 2941                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 7; ; hucc-chrmap.h
 2942                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 8; ;
 2943                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 9; ; A simple map system based on 8x8 characters (aka "tiles") in BAT format.
 2944                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 10; ;
 2945                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 11; ; Copyright John Brandwood 2025.
 2946                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 12; ;
 2947                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 13; ; Distributed under the Boost Software License, Version 1.0.
 2948                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 14; ; (See accompanying file LICENSE_1_0.txt or copy at
 2949                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 15; ;  http://www.boost.org/LICENSE_1_0.txt)
 2950                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 16; ;
 2951                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 17; ; ***************************************************************************
 2952                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 18; ; ***************************************************************************
 2953                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 19; ;
 2954                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 20; ; The maximum X and Y size for chrmaps is 256 characters (2048 pixels).
 2955                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 21; ;
 2956                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 22; ; The maximum total size for a chrmap is 16KBytes, which allows for maps up
 2957                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 23; ; to 256x32 tiles (2048x256 pixels).
 2958                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 24; ;
 2959                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 25; ; ***************************************************************************
 2960                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 26; ; **************************************************************************/
 2961                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 28; // *************
 2962                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 29; // This code extends the blkmap library ...
 2963                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 30; // *************
 2964                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 32; #include "hucc-blkmap.h"
 2965                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 34; // *************
 2966                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 35; // Functions in chrmap.asm ...
 2967                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 36; // *************
 2968                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 38; #ifdef __HUCC__
 2969                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 40; #asmdef	HUCC_USES_CHRMAP 1
 2970                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 42; extern void __fastcall __nop set_chrmap( unsigned char __far *chrmap<vdc_map_bank:vdc_map_addr>, unsigned char tiles_w<vdc_map_line_w> );
 2971                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 44; extern void __fastcall draw_bat( void );
 2972                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 45; extern void __fastcall scroll_bat( void );
 2973                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 47; extern void __fastcall blit_bat( unsigned char tile_x<map_bat_x>, unsigned char tile_y<map_bat_y>, unsigned char tile_w<map_draw_x>, unsigned char tile_h<map_draw_y> );
 2974                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 49; #ifdef _SGX
 2975                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 51; extern void __fastcall __nop sgx_set_chrmap( unsigned char __far *chrmap<sgx_map_bank:sgx_map_addr>, unsigned char tiles_w<sgx_map_line_w> );
 2976                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 53; extern void __fastcall sgx_draw_bat( void );
 2977                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 54; extern void __fastcall sgx_scroll_bat( void );
 2978                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 56; extern void __fastcall sgx_blit_bat( unsigned char tile_x<map_bat_x>, unsigned char tile_y<map_bat_y>, unsigned char tile_w<map_draw_x>, unsigned char tile_h<map_draw_y> );
 2979                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 58; #endif
 2980                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 60; #endif // __HUCC__
 2981                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 62; #endif // _hucc_chrmap_h
 2982                        		.dbg	line,	"include\routines_LEVELS.c", 4; #include "hucc-blkmap.h"
 2983                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 1; #ifndef _hucc_blkmap_h
 2984                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 2; #define _hucc_blkmap_h
 2985                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 4; /****************************************************************************
 2986                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 5; ; ***************************************************************************
 2987                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 6; ;
 2988                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 7; ; hucc-blkmap.h
 2989                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 8; ;
 2990                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 9; ; A map system based on 16x16 meta-tiles (aka "blocks", aka CHR/BLK/MAP).
 2991                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 10; ;
 2992                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 11; ; Copyright John Brandwood 2025.
 2993                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 12; ;
 2994                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 13; ; Distributed under the Boost Software License, Version 1.0.
 2995                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 14; ; (See accompanying file LICENSE_1_0.txt or copy at
 2996                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 15; ;  http://www.boost.org/LICENSE_1_0.txt)
 2997                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 16; ;
 2998                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 17; ; ***************************************************************************
 2999                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 18; ; ***************************************************************************
 3000                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 19; ;
 3001                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 20; ; The maximum X and Y size for blkmaps is 128 blocks (2048 pixels).
 3002                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 21; ;
 3003                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 22; ; The maximum total size for a blkmap is 16KBytes, which allows for maps up
 3004                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 23; ; to 128x128 blocks (2048x2048 pixels).
 3005                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 24; ;
 3006                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 25; ; Huge multi-screen blkmaps are also supported (optionally).
 3007                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 26; ;
 3008                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 27; ; The maximum X and Y for multi-screen maps is 128 screens (32768 pixels).
 3009                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 28; ;
 3010                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 29; ; The maximum total size for a multi-screen map is 8KBytes, which allows for
 3011                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 30; ; a total of 1024 screens.
 3012                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 31; ;
 3013                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 32; ; ***************************************************************************
 3014                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 33; ; **************************************************************************/
 3015                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 35; // *************
 3016                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 36; // Functions in blkmap.asm ...
 3017                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 37; // *************
 3018                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 39; #ifdef __HUCC__
 3019                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 41; #asmdef	HUCC_USES_BLKMAP 1
 3020                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 43; // Current top-left of drawn map in pixels.
 3021                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 44; extern unsigned int   vdc_map_pxl_x;
 3022                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 45; extern unsigned int   vdc_map_pxl_y;
 3023                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 47; // Width and height to draw/scroll in characters (not tiles).
 3024                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 48; extern unsigned char  vdc_map_draw_w;
 3025                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 49; extern unsigned char  vdc_map_draw_h;
 3026                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 51; // Width of map (or multi-screen BAT) in tiles.
 3027                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 52; extern unsigned char  vdc_map_line_w;
 3028                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 54; // Width of map in screens (if multi-screen map).
 3029                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 55; extern unsigned char  vdc_map_scrn_w;
 3030                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 57; // Extra information returned by get_map_block() and sgx_get_map_block(),
 3031                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 58; // which are the collision flags and the mask/overlay sprite for the BLK.
 3032                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 59; extern unsigned char  map_blk_flag;
 3033                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 60; extern unsigned char  map_blk_mask;
 3034                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 62; extern unsigned char  vdc_scr_bank;
 3035                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 63; extern unsigned char *vdc_scr_addr;
 3036                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 65; extern unsigned char  vdc_map_bank;
 3037                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 66; extern unsigned char *vdc_map_addr;
 3038                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 68; extern unsigned char  vdc_blk_bank;
 3039                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 69; extern unsigned char *vdc_blk_addr;
 3040                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 71; extern unsigned char  vdc_tbl_bank;
 3041                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 72; extern unsigned char *vdc_tbl_addr;
 3042                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 74; extern void __fastcall set_blocks( unsigned char __far *blk_def<vdc_blk_bank:vdc_blk_addr>, unsigned char __far *flg_def<vdc_tbl_bank:vdc_tbl_addr>, unsigned char number_of_blocks<_al> );
 3043                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 75; extern void __fastcall __macro set_blkmap( unsigned char __far *blk_map<vdc_map_bank:vdc_map_addr>, unsigned char blocks_w<vdc_map_line_w> );
 3044                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 76; extern void __fastcall __macro set_multimap( unsigned char __far *multi_map<vdc_scr_bank:vdc_scr_addr>, unsigned char screens_w<vdc_map_scrn_w> );
 3045                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 78; extern void __fastcall draw_map( void );
 3046                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 79; extern void __fastcall scroll_map( void );
 3047                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 81; extern void __fastcall blit_map( unsigned char tile_x<map_bat_x>, unsigned char tile_y<map_bat_y>, unsigned char tile_w<map_draw_x>, unsigned char tile_h<map_draw_y> );
 3048                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 83; extern unsigned char __fastcall get_map_block( unsigned int x<map_pxl_x>, unsigned int y<map_pxl_y> );
 3049                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 85; #asm
 3050                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 86; .macro	_set_blkmap.2
 3051                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 87; stz	vdc_scr_bank
 3052                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 88; .endm
 3053                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 90; .macro	_set_multimap.2
 3054                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 91; lda	vdc_bat_width
 3055                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 92; lsr	a
 3056                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 93; sta	vdc_map_line_w
 3057                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 94; .endm
 3058                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 96; .macro	SCREEN
 3059                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 97; db	(((\1) & $1FFF) | $6000) >> 8, bank(\1)
 3060                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 98; db	(((\2) & $1FFF) | $4000) >> 8, bank(\2)
 3061                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 99; db	(((\3) & $1FFF) | $6000) >> 8, bank(\3)
 3062                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 100; dw	(\4)
 3063                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 101; .endm
 3064                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 102; #endasm
 3065                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 104; #ifdef _SGX
 3066                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 106; // Current top-left of drawn map in pixels.
 3067                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 107; extern unsigned int   sgx_map_pxl_x;
 3068                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 108; extern unsigned int   sgx_map_pxl_y;
 3069                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 110; // Width and height to draw/scroll in characters (not tiles).
 3070                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 111; extern unsigned char  sgx_map_draw_w;
 3071                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 112; extern unsigned char  sgx_map_draw_h;
 3072                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 114; // Width of map (or multi-screen BAT) in tiles.
 3073                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 115; extern unsigned char  sgx_map_line_w;
 3074                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 117; // Width of map in screens (if multi-screen map).
 3075                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 118; extern unsigned char  sgx_map_scrn_w;
 3076                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 120; extern unsigned char  sgx_scr_bank;
 3077                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 121; extern unsigned char *sgx_scr_addr;
 3078                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 123; extern unsigned char  sgx_map_bank;
 3079                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 124; extern unsigned char *sgx_map_addr;
 3080                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 126; extern unsigned char  sgx_blk_bank;
 3081                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 127; extern unsigned char *sgx_blk_addr;
 3082                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 129; extern unsigned char  sgx_tbl_bank;
 3083                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 130; extern unsigned char *sgx_tbl_addr;
 3084                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 132; extern void __fastcall sgx_set_blocks( unsigned char __far *blk_def<sgx_blk_bank:sgx_blk_addr>, unsigned char __far *flg_def<sgx_tbl_bank:sgx_tbl_addr>, unsigned char number_of_blocks<_al> );
 3085                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 133; extern void __fastcall __macro sgx_set_blkmap( unsigned char __far *blk_map<sgx_map_bank:sgx_map_addr>, unsigned char blocks_w<sgx_map_line_w> );
 3086                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 134; extern void __fastcall __macro sgx_set_multimap( unsigned char __far *multi_map<sgx_scr_bank:sgx_scr_addr>, unsigned char screens_w<sgx_map_scrn_w> );
 3087                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 136; extern void __fastcall sgx_draw_map( void );
 3088                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 137; extern void __fastcall sgx_scroll_map( void );
 3089                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 139; extern void __fastcall sgx_blit_map( unsigned char tile_x<map_bat_x>, unsigned char tile_y<map_bat_y>, unsigned char tile_w<map_draw_x>, unsigned char tile_h<map_draw_y> );
 3090                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 141; extern unsigned char __fastcall sgx_get_map_block( unsigned int x<map_pxl_x>, unsigned int y<map_pxl_y> );
 3091                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 143; #asm
 3092                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 144; .macro	_sgx_set_blkmap.2
 3093                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 145; stz	sgx_scr_bank
 3094                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 146; .endm
 3095                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 148; .macro	_sgx_set_multimap.2
 3096                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 149; lda	sgx_bat_width
 3097                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 150; lsr	a
 3098                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 151; sta	sgx_map_line_w
 3099                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 152; .endm
 3100                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 153; #endasm
 3101                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 155; #endif
 3102                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 157; #endif // __HUCC__
 3103                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 159; #endif // _hucc_blkmap_h
 3104                        		.dbg	line,	"include\routines_LEVELS.c", 13; void hide_LEVEL_SPRITES()
 3105                        		.dbg	line,	"include\routines_LEVELS.c", 14; {
 3106                        	;***********************
 3107                        	;***********************
 3108                        	
 3109                        		.hucc
 3110    11:D414             		.proc		_hide_LEVEL_SPRITES
 3111                        		__enter		_hide_LEVEL_SPRITES
 3112                        	
 3113                        		.dbg	line,	"include\routines_LEVELS.c", 15; char i;
 3114                        	
 3115                        		.dbg	line,	"include\routines_LEVELS.c", 17; for(i=0 ; i<64 ; i++)
 3116                        		__st.umiq	0, __hide_LEVEL_SPRITES_end - 1  /* i */
         11:D414  9C 44 26   			stz	__hide_LEVEL_SPRITES_end - 1
 3117    11:D417             	.LL3:
 3118                        		__ld.umq	__hide_LEVEL_SPRITES_end - 1  /* i */
         11:D417  AD 44 26   			lda	__hide_LEVEL_SPRITES_end - 1
 3119                        		__ult_b.uiq	64
         11:D41A  C9 40      			cmp	#64		; Subtract integer from A.
         11:D41C  6A         			ror	a		; CC if A < integer.
         11:D41D  49 80      			eor	#$80
         11:D41F  2A         			rol	a
 3120                        		__btrue		.LL5
         11:D420  B0 07      			bcs	.LL5
 3121                        		__bra		.LL6
         11:D422  80 10      			bra	.LL6
 3122    11:D424             	.LL4:
 3123                        		__inc.umq	__hide_LEVEL_SPRITES_end - 1  /* i */
         11:D424  EE 44 26   			inc	__hide_LEVEL_SPRITES_end - 1
 3124                        		__bra		.LL3
         11:D427  80 EE      			bra	.LL3
 3125    11:D429             	.LL5:
 3126                        	
 3127                        		.dbg	line,	"include\routines_LEVELS.c", 18; {
 3128                        	
 3129                        		.dbg	line,	"include\routines_LEVELS.c", 19; spr_set(i);
 3130                        		__ld.umq	__hide_LEVEL_SPRITES_end - 1  /* i */
         11:D429  AD 44 26   			lda	__hide_LEVEL_SPRITES_end - 1
 3131                        		__call		_spr_set.1
         11:D42C  20 DD E7   			call	_spr_set.1
 3132                        	
 3133                        		.dbg	line,	"include\routines_LEVELS.c", 20; spr_hide();
 3134                        		__call		_spr_hide
         11:D42F  20 F8 E7   			call	_spr_hide
 3135                        	
 3136                        		.dbg	line,	"include\routines_LEVELS.c", 21; }
 3137                        		__bra		.LL4
         11:D432  80 F0      			bra	.LL4
 3138    11:D434             	.LL6:
 3139                        	
 3140                        		.dbg	line,	"include\routines_LEVELS.c", 22; }
 3141    11:D434             	.LL2:
 3142                        		__return	0
         11:D434  4C EF FF   			jmp	leave_proc
 3143                        		.dbg	clear
 3144                        		.endp
 3145                        		.pceas
 3146                        	
 3147                        		.dbg	line,	"include\routines_LEVELS.c", 27; void display_LIFE()
 3148                        		.dbg	line,	"include\routines_LEVELS.c", 28; {
 3149                        	;***********************
 3150                        	;***********************
 3151                        	
 3152                        		.hucc
 3153                        		.proc		_display_LIFE
 3162                        		.endp
 3163                        		.pceas
 3164                        	
 3165                        		.dbg	line,	"include\routines_LEVELS.c", 33; void display_SCORE()
 3166                        		.dbg	line,	"include\routines_LEVELS.c", 34; {
 3167                        	;***********************
 3168                        	;***********************
 3169                        	
 3170                        		.hucc
 3171    02:DFE3             		.proc		_display_SCORE
 3172                        		__enter		_display_SCORE
 3173                        	
 3174                        		.dbg	line,	"include\routines_LEVELS.c", 35; put_number(score,6,14,1);
 3175                        		__ld.wm		_score
         02:DFE3  AD 29 26   			lda.l	_score
         02:DFE6  AC 2A 26   			ldy.h	_score
 3176                        		__st.wmq	_bx
         02:DFE9  85 FA      			sta.l	_bx
         02:DFEB  84 FB      			sty.h	_bx
 3177                        		__st.umiq	6, _cl
         02:DFED  A9 06      			lda.l	#6
         02:DFEF  85 FC      			sta	_cl
 3178                        		__st.umiq	14, _dil
         02:DFF1  A9 0E      			lda.l	#14
         02:DFF3  85 F0      			sta	_dil
 3179                        		__st.umiq	1, _dih
         02:DFF5  A9 01      			lda.l	#1
         02:DFF7  85 F1      			sta	_dih
 3180                        		__call		_put_number.4
         02:DFF9  20 9F FF   			call	_put_number.4
 3181                        	
 3182                        		.dbg	line,	"include\routines_LEVELS.c", 36; }
 3183    02:DFFC             	.LL8:
 3184                        		__return	0
         02:DFFC  4C EF FF   			jmp	leave_proc
 3185                        		.dbg	clear
 3186                        		.endp
 3187                        		.pceas
 3188                        	
 3189                        		.dbg	line,	"include\routines_LEVELS.c", 39; void display_TIME_LEVEL()
 3190                        		.dbg	line,	"include\routines_LEVELS.c", 40; {
 3191                        	;***********************
 3192                        	;***********************
 3193                        	
 3194                        		.hucc
 3195    10:DF60             		.proc		_display_TIME_LEVEL
 3196                        		__enter		_display_TIME_LEVEL
 3197                        	
 3198                        		.dbg	line,	"include\routines_LEVELS.c", 41; put_number(minutes,1,1,3);
 3199                        		__ld.um		_minutes
         10:DF60  AD 23 23   			lda	_minutes
         10:DF63  C2         			cly
 3200                        		__st.wmq	_bx
         10:DF64  85 FA      			sta.l	_bx
         10:DF66  84 FB      			sty.h	_bx
 3201                        		__st.umiq	1, _cl
         10:DF68  A9 01      			lda.l	#1
         10:DF6A  85 FC      			sta	_cl
 3202                        		__st.umiq	1, _dil
         10:DF6C  A9 01      			lda.l	#1
         10:DF6E  85 F0      			sta	_dil
 3203                        		__st.umiq	3, _dih
         10:DF70  A9 03      			lda.l	#3
         10:DF72  85 F1      			sta	_dih
 3204                        		__call		_put_number.4
         10:DF74  20 9F FF   			call	_put_number.4
 3205                        	
 3206                        		.dbg	line,	"include\routines_LEVELS.c", 43; if(seconds < 10)
 3207                        		__ld.umq	_seconds
         10:DF77  AD 24 23   			lda	_seconds
 3208                        		__ult_b.uiq	10
         10:DF7A  C9 0A      			cmp	#10		; Subtract integer from A.
         10:DF7C  6A         			ror	a		; CC if A < integer.
         10:DF7D  49 80      			eor	#$80
         10:DF7F  2A         			rol	a
 3209                        		__bfalse	.LL10
         10:DF80  90 2C      			bcc	.LL10
 3210                        	
 3211                        		.dbg	line,	"include\routines_LEVELS.c", 44; {
 3212                        	
 3213                        		.dbg	line,	"include\routines_LEVELS.c", 45; put_number(0,1,3,3);
 3214                        		__st.wmiq	0, _bx
         10:DF82  64 FA      			stz.l	_bx
         10:DF84  64 FB      			stz.h	_bx
 3215                        		__st.umiq	1, _cl
         10:DF86  A9 01      			lda.l	#1
         10:DF88  85 FC      			sta	_cl
 3216                        		__st.umiq	3, _dil
         10:DF8A  A9 03      			lda.l	#3
         10:DF8C  85 F0      			sta	_dil
 3217                        		__st.umiq	3, _dih
         10:DF8E  A9 03      			lda.l	#3
         10:DF90  85 F1      			sta	_dih
 3218                        		__call		_put_number.4
         10:DF92  20 9F FF   			call	_put_number.4
 3219                        	
 3220                        		.dbg	line,	"include\routines_LEVELS.c", 46; put_number(seconds,1,4,3);
 3221                        		__ld.um		_seconds
         10:DF95  AD 24 23   			lda	_seconds
         10:DF98  C2         			cly
 3222                        		__st.wmq	_bx
         10:DF99  85 FA      			sta.l	_bx
         10:DF9B  84 FB      			sty.h	_bx
 3223                        		__st.umiq	1, _cl
         10:DF9D  A9 01      			lda.l	#1
         10:DF9F  85 FC      			sta	_cl
 3224                        		__st.umiq	4, _dil
         10:DFA1  A9 04      			lda.l	#4
         10:DFA3  85 F0      			sta	_dil
 3225                        		__st.umiq	3, _dih
         10:DFA5  A9 03      			lda.l	#3
         10:DFA7  85 F1      			sta	_dih
 3226                        		__call		_put_number.4
         10:DFA9  20 9F FF   			call	_put_number.4
 3227                        	
 3228                        		.dbg	line,	"include\routines_LEVELS.c", 47; }
 3229                        	
 3230                        		.dbg	line,	"include\routines_LEVELS.c", 49; else
 3231                        		__bra		.LL11
         10:DFAC  80 17      			bra	.LL11
 3232    10:DFAE             	.LL10:
 3233                        	
 3234                        		.dbg	line,	"include\routines_LEVELS.c", 50; {
 3235                        	
 3236                        		.dbg	line,	"include\routines_LEVELS.c", 51; put_number(seconds,2,3,3);
 3237                        		__ld.um		_seconds
         10:DFAE  AD 24 23   			lda	_seconds
         10:DFB1  C2         			cly
 3238                        		__st.wmq	_bx
         10:DFB2  85 FA      			sta.l	_bx
         10:DFB4  84 FB      			sty.h	_bx
 3239                        		__st.umiq	2, _cl
         10:DFB6  A9 02      			lda.l	#2
         10:DFB8  85 FC      			sta	_cl
 3240                        		__st.umiq	3, _dil
         10:DFBA  A9 03      			lda.l	#3
         10:DFBC  85 F0      			sta	_dil
 3241                        		__st.umiq	3, _dih
         10:DFBE  A9 03      			lda.l	#3
         10:DFC0  85 F1      			sta	_dih
 3242                        		__call		_put_number.4
         10:DFC2  20 9F FF   			call	_put_number.4
 3243                        	
 3244                        		.dbg	line,	"include\routines_LEVELS.c", 52; }
 3245    10:DFC5             	.LL11:
 3246                        	
 3247                        		.dbg	line,	"include\routines_LEVELS.c", 54; time_counter += 1;
 3248                        		__add_st.umiq	1, _time_counter
         10:DFC5  EE 25 23   			inc	_time_counter
 3249                        	
 3250                        		.dbg	line,	"include\routines_LEVELS.c", 56; if(time_counter == 60)
 3251                        		__ld.umq	_time_counter
         10:DFC8  AD 25 23   			lda	_time_counter
 3252                        		__equ_b.uiq	60
         10:DFCB  C9 3C      			cmp	#60
         10:DFCD  F0 01      			beq	!+
         10:DFCF  18         			clc
         10:DFD0             	!:
 3253                        		__bfalse	.LL12
         10:DFD0  90 28      			bcc	.LL12
 3254                        	
 3255                        		.dbg	line,	"include\routines_LEVELS.c", 57; {
 3256                        	
 3257                        		.dbg	line,	"include\routines_LEVELS.c", 58; time_counter = 0;
 3258                        		__st.umiq	0, _time_counter
         10:DFD2  9C 25 23   			stz	_time_counter
 3259                        	
 3260                        		.dbg	line,	"include\routines_LEVELS.c", 60; if(seconds > 0)
 3261                        		__ld.umq	_seconds
         10:DFD5  AD 24 23   			lda	_seconds
 3262                        		__ugt_b.uiq	0
         10:DFD8  18         			clc			; Subtract integer+1 from A.
         10:DFD9  E9 00      			sbc	#0		; CS if A > integer.
 3263                        		__bfalse	.LL13
         10:DFDB  90 05      			bcc	.LL13
 3264                        	
 3265                        		.dbg	line,	"include\routines_LEVELS.c", 61; {
 3266                        	
 3267                        		.dbg	line,	"include\routines_LEVELS.c", 62; seconds -= 1;
 3268                        		__sub_st.umiq	1, _seconds
         10:DFDD  CE 24 23   			dec	_seconds
 3269                        	
 3270                        		.dbg	line,	"include\routines_LEVELS.c", 63; }
 3271                        	
 3272                        		.dbg	line,	"include\routines_LEVELS.c", 65; else
 3273                        		__bra		.LL14
         10:DFE0  80 18      			bra	.LL14
 3274    10:DFE2             	.LL13:
 3275                        	
 3276                        		.dbg	line,	"include\routines_LEVELS.c", 66; {
 3277                        	
 3278                        		.dbg	line,	"include\routines_LEVELS.c", 67; if(minutes > 0)
 3279                        		__ld.umq	_minutes
         10:DFE2  AD 23 23   			lda	_minutes
 3280                        		__ugt_b.uiq	0
         10:DFE5  18         			clc			; Subtract integer+1 from A.
         10:DFE6  E9 00      			sbc	#0		; CS if A > integer.
 3281                        		__bfalse	.LL15
         10:DFE8  90 0A      			bcc	.LL15
 3282                        	
 3283                        		.dbg	line,	"include\routines_LEVELS.c", 68; {
 3284                        	
 3285                        		.dbg	line,	"include\routines_LEVELS.c", 69; seconds = 59;
 3286                        		__st.umiq	59, _seconds
         10:DFEA  A9 3B      			lda.l	#59
         10:DFEC  8D 24 23   			sta	_seconds
 3287                        	
 3288                        		.dbg	line,	"include\routines_LEVELS.c", 70; minutes -= 1;
 3289                        		__sub_st.umiq	1, _minutes
         10:DFEF  CE 23 23   			dec	_minutes
 3290                        	
 3291                        		.dbg	line,	"include\routines_LEVELS.c", 71; }
 3292                        	
 3293                        		.dbg	line,	"include\routines_LEVELS.c", 73; else
 3294                        		__bra		.LL16
         10:DFF2  80 06      			bra	.LL16
 3295    10:DFF4             	.LL15:
 3296                        	
 3297                        		.dbg	line,	"include\routines_LEVELS.c", 74; {
 3298                        	
 3299                        		.dbg	line,	"include\routines_LEVELS.c", 75; seconds = 0;
 3300                        		__st.umiq	0, _seconds
         10:DFF4  9C 24 23   			stz	_seconds
 3301                        	
 3302                        		.dbg	line,	"include\routines_LEVELS.c", 76; minutes = 0;
 3303                        		__st.umiq	0, _minutes
         10:DFF7  9C 23 23   			stz	_minutes
 3304                        	
 3305                        		.dbg	line,	"include\routines_LEVELS.c", 77; // TIME OUT //
 3306                        	
 3307                        		.dbg	line,	"include\routines_LEVELS.c", 78; }
 3308    10:DFFA             	.LL16:
 3309                        	
 3310                        		.dbg	line,	"include\routines_LEVELS.c", 79; }
 3311    10:DFFA             	.LL14:
 3312                        	
 3313                        		.dbg	line,	"include\routines_LEVELS.c", 80; } 
 3314                        	
 3315                        		.dbg	line,	"include\routines_LEVELS.c", 81; }
 3316    10:DFFA             	.LL12:
 3317    10:DFFA             	.LL9:
 3318                        		__return	0
         10:DFFA  4C EF FF   			jmp	leave_proc
 3319                        		.dbg	clear
 3320                        		.endp
 3321                        		.pceas
 3322                        	
 3323                        		.dbg	line,	"include\routines_LEVELS.c", 84; void display_KEY()
 3324                        		.dbg	line,	"include\routines_LEVELS.c", 85; {
 3325                        	;***********************
 3326                        	;***********************
 3327                        	
 3328                        		.hucc
 3329    11:D46F             		.proc		_display_KEY
 3330                        		__enter		_display_KEY
 3331                        	
 3332                        		.dbg	line,	"include\routines_LEVELS.c", 86; put_number(key_amount,2,7,27);
 3333                        		__ld.um		_key_amount
         11:D46F  AD 21 23   			lda	_key_amount
         11:D472  C2         			cly
 3334                        		__st.wmq	_bx
         11:D473  85 FA      			sta.l	_bx
         11:D475  84 FB      			sty.h	_bx
 3335                        		__st.umiq	2, _cl
         11:D477  A9 02      			lda.l	#2
         11:D479  85 FC      			sta	_cl
 3336                        		__st.umiq	7, _dil
         11:D47B  A9 07      			lda.l	#7
         11:D47D  85 F0      			sta	_dil
 3337                        		__st.umiq	27, _dih
         11:D47F  A9 1B      			lda.l	#27
         11:D481  85 F1      			sta	_dih
 3338                        		__call		_put_number.4
         11:D483  20 9F FF   			call	_put_number.4
 3339                        	
 3340                        		.dbg	line,	"include\routines_LEVELS.c", 87; }
 3341    11:D486             	.LL17:
 3342                        		__return	0
         11:D486  4C EF FF   			jmp	leave_proc
 3343                        		.dbg	clear
 3344                        		.endp
 3345                        		.pceas
 3346                        	
 3347                        		.dbg	line,	"include\routines_LEVELS.c", 90; void display_POTION()
 3348                        		.dbg	line,	"include\routines_LEVELS.c", 91; {
 3349                        	;***********************
 3350                        	;***********************
 3351                        	
 3352                        		.hucc
 3353    11:D489             		.proc		_display_POTION
 3354                        		__enter		_display_POTION
 3355                        	
 3356                        		.dbg	line,	"include\routines_LEVELS.c", 92; put_number(potion_amount,2,19,27);
 3357                        		__ld.um		_potion_amount
         11:D489  AD 22 23   			lda	_potion_amount
         11:D48C  C2         			cly
 3358                        		__st.wmq	_bx
         11:D48D  85 FA      			sta.l	_bx
         11:D48F  84 FB      			sty.h	_bx
 3359                        		__st.umiq	2, _cl
         11:D491  A9 02      			lda.l	#2
         11:D493  85 FC      			sta	_cl
 3360                        		__st.umiq	19, _dil
         11:D495  A9 13      			lda.l	#19
         11:D497  85 F0      			sta	_dil
 3361                        		__st.umiq	27, _dih
         11:D499  A9 1B      			lda.l	#27
         11:D49B  85 F1      			sta	_dih
 3362                        		__call		_put_number.4
         11:D49D  20 9F FF   			call	_put_number.4
 3363                        	
 3364                        		.dbg	line,	"include\routines_LEVELS.c", 93; }
 3365    11:D4A0             	.LL18:
 3366                        		__return	0
         11:D4A0  4C EF FF   			jmp	leave_proc
 3367                        		.dbg	clear
 3368                        		.endp
 3369                        		.pceas
 3370                        	
 3371                        		.dbg	line,	"include\routines_LEVELS.c", 96; void display_ZENNY()
 3372                        		.dbg	line,	"include\routines_LEVELS.c", 97; {
 3373                        	;***********************
 3374                        	;***********************
 3375                        	
 3376                        		.hucc
 3377    11:D437             		.proc		_display_ZENNY
 3378                        		__enter		_display_ZENNY
 3379                        	
 3380                        		.dbg	line,	"include\routines_LEVELS.c", 98; put_number(zenny_amount,5,26,4);
 3381                        		__ld.wm		_zenny_amount
         11:D437  AD 27 26   			lda.l	_zenny_amount
         11:D43A  AC 28 26   			ldy.h	_zenny_amount
 3382                        		__st.wmq	_bx
         11:D43D  85 FA      			sta.l	_bx
         11:D43F  84 FB      			sty.h	_bx
 3383                        		__st.umiq	5, _cl
         11:D441  A9 05      			lda.l	#5
         11:D443  85 FC      			sta	_cl
 3384                        		__st.umiq	26, _dil
         11:D445  A9 1A      			lda.l	#26
         11:D447  85 F0      			sta	_dil
 3385                        		__st.umiq	4, _dih
         11:D449  A9 04      			lda.l	#4
         11:D44B  85 F1      			sta	_dih
 3386                        		__call		_put_number.4
         11:D44D  20 9F FF   			call	_put_number.4
 3387                        	
 3388                        		.dbg	line,	"include\routines_LEVELS.c", 99; }
 3389    11:D450             	.LL19:
 3390                        		__return	0
         11:D450  4C EF FF   			jmp	leave_proc
 3391                        		.dbg	clear
 3392                        		.endp
 3393                        		.pceas
 3394                        	
 3395                        		.dbg	line,	"include\routines_LEVELS.c", 104; void scroll_object()
 3396                        		.dbg	line,	"include\routines_LEVELS.c", 105; {
 3397                        	;***********************
 3398                        	;***********************
 3399                        	
 3400                        		.hucc
 3401    11:C184             		.proc		_scroll_object
 3402                        		__enter		_scroll_object
 3403                        	
 3404                        		.dbg	line,	"include\routines_LEVELS.c", 106; char i;
 3405                        	
 3406                        		.dbg	line,	"include\routines_LEVELS.c", 107; onscreen_object_number = 0;
 3407                        		__st.umiq	0, _onscreen_object_number
         11:C184  9C 2A 23   			stz	_onscreen_object_number
 3408                        	
 3409                        		.dbg	line,	"include\routines_LEVELS.c", 109; for(i=0 ; i<level_object_number ; i++)
 3410                        		__st.umiq	0, __scroll_object_end - 1  /* i */
         11:C187  9C 44 26   			stz	__scroll_object_end - 1
 3411    11:C18A             	.LL21:
 3412                        		__ld.umq	__scroll_object_end - 1  /* i */
         11:C18A  AD 44 26   			lda	__scroll_object_end - 1
 3413                        		__ult_b.umq	_level_object_number
         11:C18D  CD 29 23   			cmp	_level_object_number		; Subtract memory from A.
         11:C190  6A         			ror	a		; CC if A < memory.
         11:C191  49 80      			eor	#$80
         11:C193  2A         			rol	a
 3414                        		__btrue		.LL23
         11:C194  B0 08      			bcs	.LL23
 3415                        		__bra		.LL24
         11:C196  4C E8 C2   			bra	.LL24
 3416    11:C199             	.LL22:
 3417                        		__inc.umq	__scroll_object_end - 1  /* i */
         11:C199  EE 44 26   			inc	__scroll_object_end - 1
 3418                        		__bra		.LL21
         11:C19C  80 EC      			bra	.LL21
 3419    11:C19E             	.LL23:
 3420                        	
 3421                        		.dbg	line,	"include\routines_LEVELS.c", 110; {
 3422                        	
 3423                        		.dbg	line,	"include\routines_LEVELS.c", 111; if(list_object_state[i] != STATE_INACTIVE)
 3424                        		__ldx.umq	__scroll_object_end - 1  /* i */
         11:C19E  AE 44 26   			ldx	__scroll_object_end - 1
 3425                        		__ld.uaxq	_list_object_state
         11:C1A1  BD 44 23   			lda	_list_object_state, x
 3426                        		__neq_b.uiq	1
         11:C1A4  38         			sec
         11:C1A5  49 01      			eor	#1
         11:C1A7  D0 01      			bne	!+
         11:C1A9  18         			clc
         11:C1AA             	!:
 3427                        		__bfalse	.LL25
         11:C1AA  90 ED      			bcc	.LL25
 3428                        	
 3429                        		.dbg	line,	"include\routines_LEVELS.c", 112; {
 3430                        	
 3431                        		.dbg	line,	"include\routines_LEVELS.c", 113; char scroll_allowed = FALSE;
 3432                        		__st.umiq	0, __scroll_object_end - 2  /* scroll_allowed */
         11:C1AC  9C 43 26   			stz	__scroll_object_end - 2
 3433                        	
 3434                        		.dbg	line,	"include\routines_LEVELS.c", 114; 
 3435                        	
 3436                        		.dbg	line,	"include\routines_LEVELS.c", 115; // IF OBJECT X POSITION IS INFERIOR TO SCREEN RIGHT SIDE //
 3437                        	
 3438                        		.dbg	line,	"include\routines_LEVELS.c", 116; if(list_object_x_pos_ref[i] < sgx_map_pxl_x + 256)
 3439                        		__ld.wm		_sgx_map_pxl_x
         11:C1AF  AD 89 26   			lda.l	_sgx_map_pxl_x
         11:C1B2  AC 8A 26   			ldy.h	_sgx_map_pxl_x
 3440                        		__add.wi	256
         11:C1B5  18         			clc
         11:C1B6  69 00      			adc.l	#256
         11:C1B8  42         			say
         11:C1B9  69 01      			adc.h	#256
         11:C1BB  42         			say
 3441                        		__ld2x.um	__scroll_object_end - 1  /* i */
         11:C1BC  AA         			tax
         11:C1BD  AD 44 26   			lda	__scroll_object_end - 1
         11:C1C0  0A         			asl	a
         11:C1C1  22         			sax
 3442                        		__ugt_w.wax	_list_object_x_pos_ref
         11:C1C2  18         			clc			; Subtract memory+1 from Y:A.
         11:C1C3  FD 3B 25   			sbc.l	_list_object_x_pos_ref, x
         11:C1C6  98         			tya
         11:C1C7  FD 3C 25   			sbc.h	_list_object_x_pos_ref, x		; CS if Y:A > memory.
 3443                        		__bfalse	.LL26
         11:C1CA  B0 03 4C 4F			bcc	.LL26
         11:C1CE  C2          
 3444                        	
 3445                        		.dbg	line,	"include\routines_LEVELS.c", 117; {
 3446                        	
 3447                        		.dbg	line,	"include\routines_LEVELS.c", 118; // IF OBJECT X POSITION IS SUPERIOR TO SCREEN LEFT SIDE PLUS 16 PX //
 3448                        	
 3449                        		.dbg	line,	"include\routines_LEVELS.c", 119; if(list_object_x_pos_ref[i] - sgx_map_pxl_x + 16 > 0)
 3450                        		__ld2x.umq	__scroll_object_end - 1  /* i */
         11:C1CF  AD 44 26   			lda	__scroll_object_end - 1
         11:C1D2  0A         			asl	a
         11:C1D3  AA         			tax
 3451                        		__ld.wax	_list_object_x_pos_ref
         11:C1D4  BD 3B 25   			lda.l	_list_object_x_pos_ref, x
         11:C1D7  BC 3C 25   			ldy.h	_list_object_x_pos_ref, x
 3452                        		__sub.wm	_sgx_map_pxl_x
         11:C1DA  38         			sec
         11:C1DB  ED 89 26   			sbc.l	_sgx_map_pxl_x
         11:C1DE  42         			say
         11:C1DF  ED 8A 26   			sbc.h	_sgx_map_pxl_x
         11:C1E2  42         			say
 3453                        		__add.wi	16
         11:C1E3  18         			clc
         11:C1E4  69 10      			adc.l	#16
         11:C1E6  90 01      			bcc	!+
         11:C1E8  C8         			iny
         11:C1E9             	!:
 3454                        		__sgt_w.wi	0
         11:C1E9  18         			clc			; Subtract integer+1 from Y:A.
         11:C1EA  E9 00      			sbc.l	#0
         11:C1EC  98         			tya
         11:C1ED  E9 00      			sbc.h	#0
         11:C1EF  50 02      			bvc	!+
         11:C1F1  49 80      			eor	#$80		; +ve if Y:A > integer (signed).
         11:C1F3  49 80      	!:		eor	#$80
         11:C1F5  0A         			asl	a
 3455                        		__bfalse	.LL27
         11:C1F6  90 57      			bcc	.LL27
 3456                        	
 3457                        		.dbg	line,	"include\routines_LEVELS.c", 120; {
 3458                        	
 3459                        		.dbg	line,	"include\routines_LEVELS.c", 121; // IF OBJECT Y POSITION IS INFERIOR TO SCREEN BOTTOM //
 3460                        	
 3461                        		.dbg	line,	"include\routines_LEVELS.c", 122; if(list_object_y_pos_ref[i] < sgx_map_pxl_y + 224)
 3462                        		__ld.wm		_sgx_map_pxl_y
         11:C1F8  AD 8B 26   			lda.l	_sgx_map_pxl_y
         11:C1FB  AC 8C 26   			ldy.h	_sgx_map_pxl_y
 3463                        		__add.wi	224
         11:C1FE  18         			clc
         11:C1FF  69 E0      			adc.l	#224
         11:C201  90 01      			bcc	!+
         11:C203  C8         			iny
         11:C204             	!:
 3464                        		__ld2x.um	__scroll_object_end - 1  /* i */
         11:C204  AA         			tax
         11:C205  AD 44 26   			lda	__scroll_object_end - 1
         11:C208  0A         			asl	a
         11:C209  22         			sax
 3465                        		__ugt_w.wax	_list_object_y_pos_ref
         11:C20A  18         			clc			; Subtract memory+1 from Y:A.
         11:C20B  FD 6D 25   			sbc.l	_list_object_y_pos_ref, x
         11:C20E  98         			tya
         11:C20F  FD 6E 25   			sbc.h	_list_object_y_pos_ref, x		; CS if Y:A > memory.
 3466                        		__bfalse	.LL28
         11:C212  90 3B      			bcc	.LL28
 3467                        	
 3468                        		.dbg	line,	"include\routines_LEVELS.c", 123; {
 3469                        	
 3470                        		.dbg	line,	"include\routines_LEVELS.c", 124; // IF OBJECT Y POSITION IS SUPERIOR TO SCREEN TOP PLUS 16 PX //
 3471                        	
 3472                        		.dbg	line,	"include\routines_LEVELS.c", 125; if(list_object_y_pos_ref[i] - sgx_map_pxl_y + 16 > 0)
 3473                        		__ld2x.umq	__scroll_object_end - 1  /* i */
         11:C214  AD 44 26   			lda	__scroll_object_end - 1
         11:C217  0A         			asl	a
         11:C218  AA         			tax
 3474                        		__ld.wax	_list_object_y_pos_ref
         11:C219  BD 6D 25   			lda.l	_list_object_y_pos_ref, x
         11:C21C  BC 6E 25   			ldy.h	_list_object_y_pos_ref, x
 3475                        		__sub.wm	_sgx_map_pxl_y
         11:C21F  38         			sec
         11:C220  ED 8B 26   			sbc.l	_sgx_map_pxl_y
         11:C223  42         			say
         11:C224  ED 8C 26   			sbc.h	_sgx_map_pxl_y
         11:C227  42         			say
 3476                        		__add.wi	16
         11:C228  18         			clc
         11:C229  69 10      			adc.l	#16
         11:C22B  90 01      			bcc	!+
         11:C22D  C8         			iny
         11:C22E             	!:
 3477                        		__sgt_w.wi	0
         11:C22E  18         			clc			; Subtract integer+1 from Y:A.
         11:C22F  E9 00      			sbc.l	#0
         11:C231  98         			tya
         11:C232  E9 00      			sbc.h	#0
         11:C234  50 02      			bvc	!+
         11:C236  49 80      			eor	#$80		; +ve if Y:A > integer (signed).
         11:C238  49 80      	!:		eor	#$80
         11:C23A  0A         			asl	a
 3478                        		__bfalse	.LL29
         11:C23B  90 12      			bcc	.LL29
 3479                        	
 3480                        		.dbg	line,	"include\routines_LEVELS.c", 126; {
 3481                        	
 3482                        		.dbg	line,	"include\routines_LEVELS.c", 127; // WE STORE THE OBJECT ID //
 3483                        	
 3484                        		.dbg	line,	"include\routines_LEVELS.c", 128; //put_number(i,2,0,2+onscreen_object_number);
 3485                        	
 3486                        		.dbg	line,	"include\routines_LEVELS.c", 129; list_onscreen_object[onscreen_object_number] = i;
 3487                        		__ldx.umq	_onscreen_object_number
         11:C23D  AE 2A 23   			ldx	_onscreen_object_number
 3488                        		__ld.um		__scroll_object_end - 1  /* i */
         11:C240  AD 44 26   			lda	__scroll_object_end - 1
         11:C243  C2         			cly
 3489                        		__st.uaxq	_list_onscreen_object
         11:C244  9D 8F 23   			sta	_list_onscreen_object, x
 3490                        	
 3491                        		.dbg	line,	"include\routines_LEVELS.c", 130; onscreen_object_number += 1;
 3492                        		__add_st.umiq	1, _onscreen_object_number
         11:C247  EE 2A 23   			inc	_onscreen_object_number
 3493                        	
 3494                        		.dbg	line,	"include\routines_LEVELS.c", 131; 
 3495                        	
 3496                        		.dbg	line,	"include\routines_LEVELS.c", 132; //list_object_visibility[i] = ON_SCREEN;
 3497                        	
 3498                        		.dbg	line,	"include\routines_LEVELS.c", 133; scroll_allowed = TRUE;
 3499                        		__st.umiq	1, __scroll_object_end - 2  /* scroll_allowed */
         11:C24A  A9 01      			lda.l	#1
         11:C24C  8D 43 26   			sta	__scroll_object_end - 2
 3500                        	
 3501                        		.dbg	line,	"include\routines_LEVELS.c", 134; }
 3502                        	
 3503                        		.dbg	line,	"include\routines_LEVELS.c", 135; }
 3504    11:C24F             	.LL29:
 3505                        	
 3506                        		.dbg	line,	"include\routines_LEVELS.c", 136; }
 3507    11:C24F             	.LL28:
 3508                        	
 3509                        		.dbg	line,	"include\routines_LEVELS.c", 137; }
 3510    11:C24F             	.LL27:
 3511                        	
 3512                        		.dbg	line,	"include\routines_LEVELS.c", 139; // IF OBJECTS IS WITHIN THE SCREEN LIMITS //
 3513                        	
 3514                        		.dbg	line,	"include\routines_LEVELS.c", 140; if(scroll_allowed == TRUE)
 3515    11:C24F             	.LL26:
 3516                        		__ld.umq	__scroll_object_end - 2  /* scroll_allowed */
         11:C24F  AD 43 26   			lda	__scroll_object_end - 2
 3517                        		__equ_b.uiq	1
         11:C252  C9 01      			cmp	#1
         11:C254  F0 01      			beq	!+
         11:C256  18         			clc
         11:C257             	!:
 3518                        		__bfalse	.LL30
         11:C257  90 44      			bcc	.LL30
 3519                        	
 3520                        		.dbg	line,	"include\routines_LEVELS.c", 141; {
 3521                        	
 3522                        		.dbg	line,	"include\routines_LEVELS.c", 142; list_object_x_pos[i] = list_object_x_pos_ref[i] - sgx_map_pxl_x;
 3523                        		__ld2x.umq	__scroll_object_end - 1  /* i */
         11:C259  AD 44 26   			lda	__scroll_object_end - 1
         11:C25C  0A         			asl	a
         11:C25D  AA         			tax
 3524                        		__ld.wax	_list_object_x_pos_ref
         11:C25E  BD 3B 25   			lda.l	_list_object_x_pos_ref, x
         11:C261  BC 3C 25   			ldy.h	_list_object_x_pos_ref, x
 3525                        		__sub.wm	_sgx_map_pxl_x
         11:C264  38         			sec
         11:C265  ED 89 26   			sbc.l	_sgx_map_pxl_x
         11:C268  42         			say
         11:C269  ED 8A 26   			sbc.h	_sgx_map_pxl_x
         11:C26C  42         			say
 3526                        		__ld2x.um	__scroll_object_end - 1  /* i */
         11:C26D  AA         			tax
         11:C26E  AD 44 26   			lda	__scroll_object_end - 1
         11:C271  0A         			asl	a
         11:C272  22         			sax
 3527                        		__st.waxq	_list_object_x_pos
         11:C273  9D D7 24   			sta.l	_list_object_x_pos, x
         11:C276  98         			tya
         11:C277  9D D8 24   			sta.h	_list_object_x_pos, x
 3528                        	
 3529                        		.dbg	line,	"include\routines_LEVELS.c", 143; list_object_y_pos[i] = list_object_y_pos_ref[i] - sgx_map_pxl_y;
 3530                        		__ld2x.umq	__scroll_object_end - 1  /* i */
         11:C27A  AD 44 26   			lda	__scroll_object_end - 1
         11:C27D  0A         			asl	a
         11:C27E  AA         			tax
 3531                        		__ld.wax	_list_object_y_pos_ref
         11:C27F  BD 6D 25   			lda.l	_list_object_y_pos_ref, x
         11:C282  BC 6E 25   			ldy.h	_list_object_y_pos_ref, x
 3532                        		__sub.wm	_sgx_map_pxl_y
         11:C285  38         			sec
         11:C286  ED 8B 26   			sbc.l	_sgx_map_pxl_y
         11:C289  42         			say
         11:C28A  ED 8C 26   			sbc.h	_sgx_map_pxl_y
         11:C28D  42         			say
 3533                        		__ld2x.um	__scroll_object_end - 1  /* i */
         11:C28E  AA         			tax
         11:C28F  AD 44 26   			lda	__scroll_object_end - 1
         11:C292  0A         			asl	a
         11:C293  22         			sax
 3534                        		__st.waxq	_list_object_y_pos
         11:C294  9D 09 25   			sta.l	_list_object_y_pos, x
         11:C297  98         			tya
         11:C298  9D 0A 25   			sta.h	_list_object_y_pos, x
 3535                        	
 3536                        		.dbg	line,	"include\routines_LEVELS.c", 144; }
 3537                        	
 3538                        		.dbg	line,	"include\routines_LEVELS.c", 146; else
 3539                        		__bra		.LL31
         11:C29B  80 1E      			bra	.LL31
 3540    11:C29D             	.LL30:
 3541                        	
 3542                        		.dbg	line,	"include\routines_LEVELS.c", 147; {
 3543                        	
 3544                        		.dbg	line,	"include\routines_LEVELS.c", 148; list_object_x_pos[i] = -16;
 3545                        		__ld2x.umq	__scroll_object_end - 1  /* i */
         11:C29D  AD 44 26   			lda	__scroll_object_end - 1
         11:C2A0  0A         			asl	a
         11:C2A1  AA         			tax
 3546                        		__st.waxiq	-16, _list_object_x_pos
         11:C2A2  A9 F0      			lda.l	#-16
         11:C2A4  9D D7 24   			sta.l	_list_object_x_pos, x
         11:C2A7  A9 FF      			lda.h	#-16
         11:C2A9  9D D8 24   			sta.h	_list_object_x_pos, x
 3547                        	
 3548                        		.dbg	line,	"include\routines_LEVELS.c", 149; list_object_y_pos[i] = -16;
 3549                        		__ld2x.umq	__scroll_object_end - 1  /* i */
         11:C2AC  AD 44 26   			lda	__scroll_object_end - 1
         11:C2AF  0A         			asl	a
         11:C2B0  AA         			tax
 3550                        		__st.waxiq	-16, _list_object_y_pos
         11:C2B1  A9 F0      			lda.l	#-16
         11:C2B3  9D 09 25   			sta.l	_list_object_y_pos, x
         11:C2B6  A9 FF      			lda.h	#-16
         11:C2B8  9D 0A 25   			sta.h	_list_object_y_pos, x
 3551                        	
 3552                        		.dbg	line,	"include\routines_LEVELS.c", 150; //list_object_visibility[i] = OFF_SCREEN;
 3553                        	
 3554                        		.dbg	line,	"include\routines_LEVELS.c", 151; }
 3555    11:C2BB             	.LL31:
 3556                        	
 3557                        		.dbg	line,	"include\routines_LEVELS.c", 153; spr_set(i + object_start_index);
 3558                        		__ld.um		__scroll_object_end - 1  /* i */
         11:C2BB  AD 44 26   			lda	__scroll_object_end - 1
         11:C2BE  C2         			cly
 3559                        		__add.um	_object_start_index
         11:C2BF  18         			clc
         11:C2C0  6D 28 23   			adc	_object_start_index
         11:C2C3  90 01      			bcc	!+
         11:C2C5  C8         			iny
         11:C2C6             	!:
 3560                        		__call		_spr_set.1
         11:C2C6  20 DD E7   			call	_spr_set.1
 3561                        	
 3562                        		.dbg	line,	"include\routines_LEVELS.c", 155; spr_x(list_object_x_pos[i]);
 3563                        		__ld2x.umq	__scroll_object_end - 1  /* i */
         11:C2C9  AD 44 26   			lda	__scroll_object_end - 1
         11:C2CC  0A         			asl	a
         11:C2CD  AA         			tax
 3564                        		__ld.wax	_list_object_x_pos
         11:C2CE  BD D7 24   			lda.l	_list_object_x_pos, x
         11:C2D1  BC D8 24   			ldy.h	_list_object_x_pos, x
 3565                        		__call		_spr_x.1
         11:C2D4  20 0A E8   			call	_spr_x.1
 3566                        	
 3567                        		.dbg	line,	"include\routines_LEVELS.c", 156; spr_y(list_object_y_pos[i]);
 3568                        		__ld2x.umq	__scroll_object_end - 1  /* i */
         11:C2D7  AD 44 26   			lda	__scroll_object_end - 1
         11:C2DA  0A         			asl	a
         11:C2DB  AA         			tax
 3569                        		__ld.wax	_list_object_y_pos
         11:C2DC  BD 09 25   			lda.l	_list_object_y_pos, x
         11:C2DF  BC 0A 25   			ldy.h	_list_object_y_pos, x
 3570                        		__call		_spr_y.1
         11:C2E2  20 19 E8   			call	_spr_y.1
 3571                        	
 3572                        		.dbg	line,	"include\routines_LEVELS.c", 157; }
 3573                        	
 3574                        		.dbg	line,	"include\routines_LEVELS.c", 158; }
 3575    11:C2E5             	.LL25	.alias		.LL22
 3576                        		__bra		.LL22
         11:C2E5  4C 99 C1   			bra	.LL22
 3577    11:C2E8             	.LL24:
 3578                        	
 3579                        		.dbg	line,	"include\routines_LEVELS.c", 159; }
 3580    11:C2E8             	.LL20:
 3581                        		__return	0
         11:C2E8  4C EF FF   			jmp	leave_proc
 3582                        		.dbg	clear
 3583                        		.endp
 3584                        		.pceas
 3585                        	
 3586                        		.dbg	line,	"include\routines_LEVELS.c", 162; void scroll_chest()
 3587                        		.dbg	line,	"include\routines_LEVELS.c", 163; {
 3588                        	;***********************
 3589                        	;***********************
 3590                        	
 3591                        		.hucc
 3592    11:C2EB             		.proc		_scroll_chest
 3593                        		__enter		_scroll_chest
 3594                        	
 3595                        		.dbg	line,	"include\routines_LEVELS.c", 164; char i;
 3596                        	
 3597                        		.dbg	line,	"include\routines_LEVELS.c", 165; onscreen_chest_number = 0;
 3598                        		__st.umiq	0, _onscreen_chest_number
         11:C2EB  9C 99 23   			stz	_onscreen_chest_number
 3599                        	
 3600                        		.dbg	line,	"include\routines_LEVELS.c", 167; for(i=0 ; i<level_chest_number ; i++)
 3601                        		__st.umiq	0, __scroll_chest_end - 1  /* i */
         11:C2EE  9C 44 26   			stz	__scroll_chest_end - 1
 3602    11:C2F1             	.LL33:
 3603                        		__ld.umq	__scroll_chest_end - 1  /* i */
         11:C2F1  AD 44 26   			lda	__scroll_chest_end - 1
 3604                        		__ult_b.umq	_level_chest_number
         11:C2F4  CD 98 23   			cmp	_level_chest_number		; Subtract memory from A.
         11:C2F7  6A         			ror	a		; CC if A < memory.
         11:C2F8  49 80      			eor	#$80
         11:C2FA  2A         			rol	a
 3605                        		__btrue		.LL35
         11:C2FB  B0 08      			bcs	.LL35
 3606                        		__bra		.LL36
         11:C2FD  4C 4F C4   			bra	.LL36
 3607    11:C300             	.LL34:
 3608                        		__inc.umq	__scroll_chest_end - 1  /* i */
         11:C300  EE 44 26   			inc	__scroll_chest_end - 1
 3609                        		__bra		.LL33
         11:C303  80 EC      			bra	.LL33
 3610    11:C305             	.LL35:
 3611                        	
 3612                        		.dbg	line,	"include\routines_LEVELS.c", 168; {
 3613                        	
 3614                        		.dbg	line,	"include\routines_LEVELS.c", 169; if(list_chest_state[i] != STATE_INACTIVE)
 3615                        		__ldx.umq	__scroll_chest_end - 1  /* i */
         11:C305  AE 44 26   			ldx	__scroll_chest_end - 1
 3616                        		__ld.uaxq	_list_chest_state
         11:C308  BD 9A 23   			lda	_list_chest_state, x
 3617                        		__neq_b.uiq	1
         11:C30B  38         			sec
         11:C30C  49 01      			eor	#1
         11:C30E  D0 01      			bne	!+
         11:C310  18         			clc
         11:C311             	!:
 3618                        		__bfalse	.LL37
         11:C311  90 ED      			bcc	.LL37
 3619                        	
 3620                        		.dbg	line,	"include\routines_LEVELS.c", 170; {
 3621                        	
 3622                        		.dbg	line,	"include\routines_LEVELS.c", 171; char scroll_allowed = FALSE;
 3623                        		__st.umiq	0, __scroll_chest_end - 2  /* scroll_allowed */
         11:C313  9C 43 26   			stz	__scroll_chest_end - 2
 3624                        	
 3625                        		.dbg	line,	"include\routines_LEVELS.c", 172; 
 3626                        	
 3627                        		.dbg	line,	"include\routines_LEVELS.c", 173; // IF CHEST X POSITION IS INFERIOR TO SCREEN RIGHT SIDE //
 3628                        	
 3629                        		.dbg	line,	"include\routines_LEVELS.c", 174; if(list_chest_x_pos_ref[i] < sgx_map_pxl_x + 256)
 3630                        		__ld.wm		_sgx_map_pxl_x
         11:C316  AD 89 26   			lda.l	_sgx_map_pxl_x
         11:C319  AC 8A 26   			ldy.h	_sgx_map_pxl_x
 3631                        		__add.wi	256
         11:C31C  18         			clc
         11:C31D  69 00      			adc.l	#256
         11:C31F  42         			say
         11:C320  69 01      			adc.h	#256
         11:C322  42         			say
 3632                        		__ld2x.um	__scroll_chest_end - 1  /* i */
         11:C323  AA         			tax
         11:C324  AD 44 26   			lda	__scroll_chest_end - 1
         11:C327  0A         			asl	a
         11:C328  22         			sax
 3633                        		__ugt_w.wax	_list_chest_x_pos_ref
         11:C329  18         			clc			; Subtract memory+1 from Y:A.
         11:C32A  FD BF 25   			sbc.l	_list_chest_x_pos_ref, x
         11:C32D  98         			tya
         11:C32E  FD C0 25   			sbc.h	_list_chest_x_pos_ref, x		; CS if Y:A > memory.
 3634                        		__bfalse	.LL38
         11:C331  B0 03 4C B6			bcc	.LL38
         11:C335  C3          
 3635                        	
 3636                        		.dbg	line,	"include\routines_LEVELS.c", 175; {
 3637                        	
 3638                        		.dbg	line,	"include\routines_LEVELS.c", 176; // IF CHEST X POSITION IS SUPERIOR TO SCREEN LEFT SIDE PLUS 32 PX //
 3639                        	
 3640                        		.dbg	line,	"include\routines_LEVELS.c", 177; if(list_chest_x_pos_ref[i] - sgx_map_pxl_x + 32 > 0)
 3641                        		__ld2x.umq	__scroll_chest_end - 1  /* i */
         11:C336  AD 44 26   			lda	__scroll_chest_end - 1
         11:C339  0A         			asl	a
         11:C33A  AA         			tax
 3642                        		__ld.wax	_list_chest_x_pos_ref
         11:C33B  BD BF 25   			lda.l	_list_chest_x_pos_ref, x
         11:C33E  BC C0 25   			ldy.h	_list_chest_x_pos_ref, x
 3643                        		__sub.wm	_sgx_map_pxl_x
         11:C341  38         			sec
         11:C342  ED 89 26   			sbc.l	_sgx_map_pxl_x
         11:C345  42         			say
         11:C346  ED 8A 26   			sbc.h	_sgx_map_pxl_x
         11:C349  42         			say
 3644                        		__add.wi	32
         11:C34A  18         			clc
         11:C34B  69 20      			adc.l	#32
         11:C34D  90 01      			bcc	!+
         11:C34F  C8         			iny
         11:C350             	!:
 3645                        		__sgt_w.wi	0
         11:C350  18         			clc			; Subtract integer+1 from Y:A.
         11:C351  E9 00      			sbc.l	#0
         11:C353  98         			tya
         11:C354  E9 00      			sbc.h	#0
         11:C356  50 02      			bvc	!+
         11:C358  49 80      			eor	#$80		; +ve if Y:A > integer (signed).
         11:C35A  49 80      	!:		eor	#$80
         11:C35C  0A         			asl	a
 3646                        		__bfalse	.LL39
         11:C35D  90 57      			bcc	.LL39
 3647                        	
 3648                        		.dbg	line,	"include\routines_LEVELS.c", 178; {
 3649                        	
 3650                        		.dbg	line,	"include\routines_LEVELS.c", 179; // IF CHEST Y POSITION IS INFERIOR TO SCREEN BOTTOM //
 3651                        	
 3652                        		.dbg	line,	"include\routines_LEVELS.c", 180; if(list_chest_y_pos_ref[i] < sgx_map_pxl_y + 224)
 3653                        		__ld.wm		_sgx_map_pxl_y
         11:C35F  AD 8B 26   			lda.l	_sgx_map_pxl_y
         11:C362  AC 8C 26   			ldy.h	_sgx_map_pxl_y
 3654                        		__add.wi	224
         11:C365  18         			clc
         11:C366  69 E0      			adc.l	#224
         11:C368  90 01      			bcc	!+
         11:C36A  C8         			iny
         11:C36B             	!:
 3655                        		__ld2x.um	__scroll_chest_end - 1  /* i */
         11:C36B  AA         			tax
         11:C36C  AD 44 26   			lda	__scroll_chest_end - 1
         11:C36F  0A         			asl	a
         11:C370  22         			sax
 3656                        		__ugt_w.wax	_list_chest_y_pos_ref
         11:C371  18         			clc			; Subtract memory+1 from Y:A.
         11:C372  FD CF 25   			sbc.l	_list_chest_y_pos_ref, x
         11:C375  98         			tya
         11:C376  FD D0 25   			sbc.h	_list_chest_y_pos_ref, x		; CS if Y:A > memory.
 3657                        		__bfalse	.LL40
         11:C379  90 3B      			bcc	.LL40
 3658                        	
 3659                        		.dbg	line,	"include\routines_LEVELS.c", 181; {
 3660                        	
 3661                        		.dbg	line,	"include\routines_LEVELS.c", 182; // IF CHEST Y POSITION IS SUPERIOR TO SCREEN TOP PLUS 32 PX //
 3662                        	
 3663                        		.dbg	line,	"include\routines_LEVELS.c", 183; if(list_chest_y_pos_ref[i] - sgx_map_pxl_y + 32 > 0)
 3664                        		__ld2x.umq	__scroll_chest_end - 1  /* i */
         11:C37B  AD 44 26   			lda	__scroll_chest_end - 1
         11:C37E  0A         			asl	a
         11:C37F  AA         			tax
 3665                        		__ld.wax	_list_chest_y_pos_ref
         11:C380  BD CF 25   			lda.l	_list_chest_y_pos_ref, x
         11:C383  BC D0 25   			ldy.h	_list_chest_y_pos_ref, x
 3666                        		__sub.wm	_sgx_map_pxl_y
         11:C386  38         			sec
         11:C387  ED 8B 26   			sbc.l	_sgx_map_pxl_y
         11:C38A  42         			say
         11:C38B  ED 8C 26   			sbc.h	_sgx_map_pxl_y
         11:C38E  42         			say
 3667                        		__add.wi	32
         11:C38F  18         			clc
         11:C390  69 20      			adc.l	#32
         11:C392  90 01      			bcc	!+
         11:C394  C8         			iny
         11:C395             	!:
 3668                        		__sgt_w.wi	0
         11:C395  18         			clc			; Subtract integer+1 from Y:A.
         11:C396  E9 00      			sbc.l	#0
         11:C398  98         			tya
         11:C399  E9 00      			sbc.h	#0
         11:C39B  50 02      			bvc	!+
         11:C39D  49 80      			eor	#$80		; +ve if Y:A > integer (signed).
         11:C39F  49 80      	!:		eor	#$80
         11:C3A1  0A         			asl	a
 3669                        		__bfalse	.LL41
         11:C3A2  90 12      			bcc	.LL41
 3670                        	
 3671                        		.dbg	line,	"include\routines_LEVELS.c", 184; {
 3672                        	
 3673                        		.dbg	line,	"include\routines_LEVELS.c", 185; // WE STORE THE CHEST ID //
 3674                        	
 3675                        		.dbg	line,	"include\routines_LEVELS.c", 186; list_onscreen_chest[onscreen_chest_number] = i;
 3676                        		__ldx.umq	_onscreen_chest_number
         11:C3A4  AE 99 23   			ldx	_onscreen_chest_number
 3677                        		__ld.um		__scroll_chest_end - 1  /* i */
         11:C3A7  AD 44 26   			lda	__scroll_chest_end - 1
         11:C3AA  C2         			cly
 3678                        		__st.uaxq	_list_onscreen_chest
         11:C3AB  9D A2 23   			sta	_list_onscreen_chest, x
 3679                        	
 3680                        		.dbg	line,	"include\routines_LEVELS.c", 187; onscreen_chest_number += 1;
 3681                        		__add_st.umiq	1, _onscreen_chest_number
         11:C3AE  EE 99 23   			inc	_onscreen_chest_number
 3682                        	
 3683                        		.dbg	line,	"include\routines_LEVELS.c", 188; 
 3684                        	
 3685                        		.dbg	line,	"include\routines_LEVELS.c", 189; scroll_allowed = TRUE;
 3686                        		__st.umiq	1, __scroll_chest_end - 2  /* scroll_allowed */
         11:C3B1  A9 01      			lda.l	#1
         11:C3B3  8D 43 26   			sta	__scroll_chest_end - 2
 3687                        	
 3688                        		.dbg	line,	"include\routines_LEVELS.c", 190; }
 3689                        	
 3690                        		.dbg	line,	"include\routines_LEVELS.c", 191; }
 3691    11:C3B6             	.LL41:
 3692                        	
 3693                        		.dbg	line,	"include\routines_LEVELS.c", 192; }
 3694    11:C3B6             	.LL40:
 3695                        	
 3696                        		.dbg	line,	"include\routines_LEVELS.c", 193; }
 3697    11:C3B6             	.LL39:
 3698                        	
 3699                        		.dbg	line,	"include\routines_LEVELS.c", 195; // IF CHEST IS WITHIN THE SCREEN LIMITS //
 3700                        	
 3701                        		.dbg	line,	"include\routines_LEVELS.c", 196; if(scroll_allowed == TRUE)
 3702    11:C3B6             	.LL38:
 3703                        		__ld.umq	__scroll_chest_end - 2  /* scroll_allowed */
         11:C3B6  AD 43 26   			lda	__scroll_chest_end - 2
 3704                        		__equ_b.uiq	1
         11:C3B9  C9 01      			cmp	#1
         11:C3BB  F0 01      			beq	!+
         11:C3BD  18         			clc
         11:C3BE             	!:
 3705                        		__bfalse	.LL42
         11:C3BE  90 44      			bcc	.LL42
 3706                        	
 3707                        		.dbg	line,	"include\routines_LEVELS.c", 197; {
 3708                        	
 3709                        		.dbg	line,	"include\routines_LEVELS.c", 198; list_chest_x_pos[i] = list_chest_x_pos_ref[i] - sgx_map_pxl_x;
 3710                        		__ld2x.umq	__scroll_chest_end - 1  /* i */
         11:C3C0  AD 44 26   			lda	__scroll_chest_end - 1
         11:C3C3  0A         			asl	a
         11:C3C4  AA         			tax
 3711                        		__ld.wax	_list_chest_x_pos_ref
         11:C3C5  BD BF 25   			lda.l	_list_chest_x_pos_ref, x
         11:C3C8  BC C0 25   			ldy.h	_list_chest_x_pos_ref, x
 3712                        		__sub.wm	_sgx_map_pxl_x
         11:C3CB  38         			sec
         11:C3CC  ED 89 26   			sbc.l	_sgx_map_pxl_x
         11:C3CF  42         			say
         11:C3D0  ED 8A 26   			sbc.h	_sgx_map_pxl_x
         11:C3D3  42         			say
 3713                        		__ld2x.um	__scroll_chest_end - 1  /* i */
         11:C3D4  AA         			tax
         11:C3D5  AD 44 26   			lda	__scroll_chest_end - 1
         11:C3D8  0A         			asl	a
         11:C3D9  22         			sax
 3714                        		__st.waxq	_list_chest_x_pos
         11:C3DA  9D 9F 25   			sta.l	_list_chest_x_pos, x
         11:C3DD  98         			tya
         11:C3DE  9D A0 25   			sta.h	_list_chest_x_pos, x
 3715                        	
 3716                        		.dbg	line,	"include\routines_LEVELS.c", 199; list_chest_y_pos[i] = list_chest_y_pos_ref[i] - sgx_map_pxl_y;
 3717                        		__ld2x.umq	__scroll_chest_end - 1  /* i */
         11:C3E1  AD 44 26   			lda	__scroll_chest_end - 1
         11:C3E4  0A         			asl	a
         11:C3E5  AA         			tax
 3718                        		__ld.wax	_list_chest_y_pos_ref
         11:C3E6  BD CF 25   			lda.l	_list_chest_y_pos_ref, x
         11:C3E9  BC D0 25   			ldy.h	_list_chest_y_pos_ref, x
 3719                        		__sub.wm	_sgx_map_pxl_y
         11:C3EC  38         			sec
         11:C3ED  ED 8B 26   			sbc.l	_sgx_map_pxl_y
         11:C3F0  42         			say
         11:C3F1  ED 8C 26   			sbc.h	_sgx_map_pxl_y
         11:C3F4  42         			say
 3720                        		__ld2x.um	__scroll_chest_end - 1  /* i */
         11:C3F5  AA         			tax
         11:C3F6  AD 44 26   			lda	__scroll_chest_end - 1
         11:C3F9  0A         			asl	a
         11:C3FA  22         			sax
 3721                        		__st.waxq	_list_chest_y_pos
         11:C3FB  9D AF 25   			sta.l	_list_chest_y_pos, x
         11:C3FE  98         			tya
         11:C3FF  9D B0 25   			sta.h	_list_chest_y_pos, x
 3722                        	
 3723                        		.dbg	line,	"include\routines_LEVELS.c", 200; }
 3724                        	
 3725                        		.dbg	line,	"include\routines_LEVELS.c", 202; else
 3726                        		__bra		.LL43
         11:C402  80 1E      			bra	.LL43
 3727    11:C404             	.LL42:
 3728                        	
 3729                        		.dbg	line,	"include\routines_LEVELS.c", 203; {
 3730                        	
 3731                        		.dbg	line,	"include\routines_LEVELS.c", 204; list_chest_x_pos[i] = -32;
 3732                        		__ld2x.umq	__scroll_chest_end - 1  /* i */
         11:C404  AD 44 26   			lda	__scroll_chest_end - 1
         11:C407  0A         			asl	a
         11:C408  AA         			tax
 3733                        		__st.waxiq	-32, _list_chest_x_pos
         11:C409  A9 E0      			lda.l	#-32
         11:C40B  9D 9F 25   			sta.l	_list_chest_x_pos, x
         11:C40E  A9 FF      			lda.h	#-32
         11:C410  9D A0 25   			sta.h	_list_chest_x_pos, x
 3734                        	
 3735                        		.dbg	line,	"include\routines_LEVELS.c", 205; list_chest_y_pos[i] = -32;
 3736                        		__ld2x.umq	__scroll_chest_end - 1  /* i */
         11:C413  AD 44 26   			lda	__scroll_chest_end - 1
         11:C416  0A         			asl	a
         11:C417  AA         			tax
 3737                        		__st.waxiq	-32, _list_chest_y_pos
         11:C418  A9 E0      			lda.l	#-32
         11:C41A  9D AF 25   			sta.l	_list_chest_y_pos, x
         11:C41D  A9 FF      			lda.h	#-32
         11:C41F  9D B0 25   			sta.h	_list_chest_y_pos, x
 3738                        	
 3739                        		.dbg	line,	"include\routines_LEVELS.c", 206; }
 3740    11:C422             	.LL43:
 3741                        	
 3742                        		.dbg	line,	"include\routines_LEVELS.c", 208; spr_set(i + chest_start_index);
 3743                        		__ld.um		__scroll_chest_end - 1  /* i */
         11:C422  AD 44 26   			lda	__scroll_chest_end - 1
         11:C425  C2         			cly
 3744                        		__add.um	_chest_start_index
         11:C426  18         			clc
         11:C427  6D 97 23   			adc	_chest_start_index
         11:C42A  90 01      			bcc	!+
         11:C42C  C8         			iny
         11:C42D             	!:
 3745                        		__call		_spr_set.1
         11:C42D  20 DD E7   			call	_spr_set.1
 3746                        	
 3747                        		.dbg	line,	"include\routines_LEVELS.c", 210; spr_x(list_chest_x_pos[i]);
 3748                        		__ld2x.umq	__scroll_chest_end - 1  /* i */
         11:C430  AD 44 26   			lda	__scroll_chest_end - 1
         11:C433  0A         			asl	a
         11:C434  AA         			tax
 3749                        		__ld.wax	_list_chest_x_pos
         11:C435  BD 9F 25   			lda.l	_list_chest_x_pos, x
         11:C438  BC A0 25   			ldy.h	_list_chest_x_pos, x
 3750                        		__call		_spr_x.1
         11:C43B  20 0A E8   			call	_spr_x.1
 3751                        	
 3752                        		.dbg	line,	"include\routines_LEVELS.c", 211; spr_y(list_chest_y_pos[i]);
 3753                        		__ld2x.umq	__scroll_chest_end - 1  /* i */
         11:C43E  AD 44 26   			lda	__scroll_chest_end - 1
         11:C441  0A         			asl	a
         11:C442  AA         			tax
 3754                        		__ld.wax	_list_chest_y_pos
         11:C443  BD AF 25   			lda.l	_list_chest_y_pos, x
         11:C446  BC B0 25   			ldy.h	_list_chest_y_pos, x
 3755                        		__call		_spr_y.1
         11:C449  20 19 E8   			call	_spr_y.1
 3756                        	
 3757                        		.dbg	line,	"include\routines_LEVELS.c", 212; }
 3758                        	
 3759                        		.dbg	line,	"include\routines_LEVELS.c", 213; }
 3760    11:C44C             	.LL37	.alias		.LL34
 3761                        		__bra		.LL34
         11:C44C  4C 00 C3   			bra	.LL34
 3762    11:C44F             	.LL36:
 3763                        	
 3764                        		.dbg	line,	"include\routines_LEVELS.c", 214; }
 3765    11:C44F             	.LL32:
 3766                        		__return	0
         11:C44F  4C EF FF   			jmp	leave_proc
 3767                        		.dbg	clear
 3768                        		.endp
 3769                        		.pceas
 3770                        	
 3771                        		.dbg	line,	"include\routines_LEVELS.c", 217; void scroll_npc()
 3772                        		.dbg	line,	"include\routines_LEVELS.c", 218; {
 3773                        	;***********************
 3774                        	;***********************
 3775                        	
 3776                        		.hucc
 3777    11:C452             		.proc		_scroll_npc
 3778                        		__enter		_scroll_npc
 3779                        	
 3780                        		.dbg	line,	"include\routines_LEVELS.c", 219; char i;
 3781                        	
 3782                        		.dbg	line,	"include\routines_LEVELS.c", 220; onscreen_npc_number = 0;
 3783                        		__st.umiq	0, _onscreen_npc_number
         11:C452  9C AC 23   			stz	_onscreen_npc_number
 3784                        	
 3785                        		.dbg	line,	"include\routines_LEVELS.c", 222; for(i=0 ; i<level_npc_number ; i++)
 3786                        		__st.umiq	0, __scroll_npc_end - 1  /* i */
         11:C455  9C 44 26   			stz	__scroll_npc_end - 1
 3787    11:C458             	.LL45:
 3788                        		__ld.umq	__scroll_npc_end - 1  /* i */
         11:C458  AD 44 26   			lda	__scroll_npc_end - 1
 3789                        		__ult_b.umq	_level_npc_number
         11:C45B  CD AB 23   			cmp	_level_npc_number		; Subtract memory from A.
         11:C45E  6A         			ror	a		; CC if A < memory.
         11:C45F  49 80      			eor	#$80
         11:C461  2A         			rol	a
 3790                        		__btrue		.LL47
         11:C462  B0 08      			bcs	.LL47
 3791                        		__bra		.LL48
         11:C464  4C B6 C5   			bra	.LL48
 3792    11:C467             	.LL46:
 3793                        		__inc.umq	__scroll_npc_end - 1  /* i */
         11:C467  EE 44 26   			inc	__scroll_npc_end - 1
 3794                        		__bra		.LL45
         11:C46A  80 EC      			bra	.LL45
 3795    11:C46C             	.LL47:
 3796                        	
 3797                        		.dbg	line,	"include\routines_LEVELS.c", 223; {
 3798                        	
 3799                        		.dbg	line,	"include\routines_LEVELS.c", 224; if(list_npc_state[i] != STATE_INACTIVE)
 3800                        		__ldx.umq	__scroll_npc_end - 1  /* i */
         11:C46C  AE 44 26   			ldx	__scroll_npc_end - 1
 3801                        		__ld.uaxq	_list_npc_state
         11:C46F  BD B6 23   			lda	_list_npc_state, x
 3802                        		__neq_b.uiq	1
         11:C472  38         			sec
         11:C473  49 01      			eor	#1
         11:C475  D0 01      			bne	!+
         11:C477  18         			clc
         11:C478             	!:
 3803                        		__bfalse	.LL49
         11:C478  90 ED      			bcc	.LL49
 3804                        	
 3805                        		.dbg	line,	"include\routines_LEVELS.c", 225; {
 3806                        	
 3807                        		.dbg	line,	"include\routines_LEVELS.c", 226; char scroll_allowed = FALSE;
 3808                        		__st.umiq	0, __scroll_npc_end - 2  /* scroll_allowed */
         11:C47A  9C 43 26   			stz	__scroll_npc_end - 2
 3809                        	
 3810                        		.dbg	line,	"include\routines_LEVELS.c", 227; 
 3811                        	
 3812                        		.dbg	line,	"include\routines_LEVELS.c", 228; // IF NPC X POSITION IS INFERIOR TO SCREEN RIGHT SIDE //
 3813                        	
 3814                        		.dbg	line,	"include\routines_LEVELS.c", 229; if(list_npc_x_pos_ref[i] < sgx_map_pxl_x + 256)
 3815                        		__ld.wm		_sgx_map_pxl_x
         11:C47D  AD 89 26   			lda.l	_sgx_map_pxl_x
         11:C480  AC 8A 26   			ldy.h	_sgx_map_pxl_x
 3816                        		__add.wi	256
         11:C483  18         			clc
         11:C484  69 00      			adc.l	#256
         11:C486  42         			say
         11:C487  69 01      			adc.h	#256
         11:C489  42         			say
 3817                        		__ld2x.um	__scroll_npc_end - 1  /* i */
         11:C48A  AA         			tax
         11:C48B  AD 44 26   			lda	__scroll_npc_end - 1
         11:C48E  0A         			asl	a
         11:C48F  22         			sax
 3818                        		__ugt_w.wax	_list_npc_x_pos_ref
         11:C490  18         			clc			; Subtract memory+1 from Y:A.
         11:C491  FD 03 26   			sbc.l	_list_npc_x_pos_ref, x
         11:C494  98         			tya
         11:C495  FD 04 26   			sbc.h	_list_npc_x_pos_ref, x		; CS if Y:A > memory.
 3819                        		__bfalse	.LL50
         11:C498  B0 03 4C 1D			bcc	.LL50
         11:C49C  C5          
 3820                        	
 3821                        		.dbg	line,	"include\routines_LEVELS.c", 230; {
 3822                        	
 3823                        		.dbg	line,	"include\routines_LEVELS.c", 231; // IF NPC X POSITION IS SUPERIOR TO SCREEN LEFT SIDE PLUS 32 PX //
 3824                        	
 3825                        		.dbg	line,	"include\routines_LEVELS.c", 232; if(list_npc_x_pos_ref[i] - sgx_map_pxl_x + 32 > 0)
 3826                        		__ld2x.umq	__scroll_npc_end - 1  /* i */
         11:C49D  AD 44 26   			lda	__scroll_npc_end - 1
         11:C4A0  0A         			asl	a
         11:C4A1  AA         			tax
 3827                        		__ld.wax	_list_npc_x_pos_ref
         11:C4A2  BD 03 26   			lda.l	_list_npc_x_pos_ref, x
         11:C4A5  BC 04 26   			ldy.h	_list_npc_x_pos_ref, x
 3828                        		__sub.wm	_sgx_map_pxl_x
         11:C4A8  38         			sec
         11:C4A9  ED 89 26   			sbc.l	_sgx_map_pxl_x
         11:C4AC  42         			say
         11:C4AD  ED 8A 26   			sbc.h	_sgx_map_pxl_x
         11:C4B0  42         			say
 3829                        		__add.wi	32
         11:C4B1  18         			clc
         11:C4B2  69 20      			adc.l	#32
         11:C4B4  90 01      			bcc	!+
         11:C4B6  C8         			iny
         11:C4B7             	!:
 3830                        		__sgt_w.wi	0
         11:C4B7  18         			clc			; Subtract integer+1 from Y:A.
         11:C4B8  E9 00      			sbc.l	#0
         11:C4BA  98         			tya
         11:C4BB  E9 00      			sbc.h	#0
         11:C4BD  50 02      			bvc	!+
         11:C4BF  49 80      			eor	#$80		; +ve if Y:A > integer (signed).
         11:C4C1  49 80      	!:		eor	#$80
         11:C4C3  0A         			asl	a
 3831                        		__bfalse	.LL51
         11:C4C4  90 57      			bcc	.LL51
 3832                        	
 3833                        		.dbg	line,	"include\routines_LEVELS.c", 233; {
 3834                        	
 3835                        		.dbg	line,	"include\routines_LEVELS.c", 234; // IF NPC Y POSITION IS INFERIOR TO SCREEN BOTTOM //
 3836                        	
 3837                        		.dbg	line,	"include\routines_LEVELS.c", 235; if(list_npc_y_pos_ref[i] < sgx_map_pxl_y + 224)
 3838                        		__ld.wm		_sgx_map_pxl_y
         11:C4C6  AD 8B 26   			lda.l	_sgx_map_pxl_y
         11:C4C9  AC 8C 26   			ldy.h	_sgx_map_pxl_y
 3839                        		__add.wi	224
         11:C4CC  18         			clc
         11:C4CD  69 E0      			adc.l	#224
         11:C4CF  90 01      			bcc	!+
         11:C4D1  C8         			iny
         11:C4D2             	!:
 3840                        		__ld2x.um	__scroll_npc_end - 1  /* i */
         11:C4D2  AA         			tax
         11:C4D3  AD 44 26   			lda	__scroll_npc_end - 1
         11:C4D6  0A         			asl	a
         11:C4D7  22         			sax
 3841                        		__ugt_w.wax	_list_npc_y_pos_ref
         11:C4D8  18         			clc			; Subtract memory+1 from Y:A.
         11:C4D9  FD 15 26   			sbc.l	_list_npc_y_pos_ref, x
         11:C4DC  98         			tya
         11:C4DD  FD 16 26   			sbc.h	_list_npc_y_pos_ref, x		; CS if Y:A > memory.
 3842                        		__bfalse	.LL52
         11:C4E0  90 3B      			bcc	.LL52
 3843                        	
 3844                        		.dbg	line,	"include\routines_LEVELS.c", 236; {
 3845                        	
 3846                        		.dbg	line,	"include\routines_LEVELS.c", 237; // IF NPC Y POSITION IS SUPERIOR TO SCREEN TOP PLUS 32 PX //
 3847                        	
 3848                        		.dbg	line,	"include\routines_LEVELS.c", 238; if(list_npc_y_pos_ref[i] - sgx_map_pxl_y + 32 > 0)
 3849                        		__ld2x.umq	__scroll_npc_end - 1  /* i */
         11:C4E2  AD 44 26   			lda	__scroll_npc_end - 1
         11:C4E5  0A         			asl	a
         11:C4E6  AA         			tax
 3850                        		__ld.wax	_list_npc_y_pos_ref
         11:C4E7  BD 15 26   			lda.l	_list_npc_y_pos_ref, x
         11:C4EA  BC 16 26   			ldy.h	_list_npc_y_pos_ref, x
 3851                        		__sub.wm	_sgx_map_pxl_y
         11:C4ED  38         			sec
         11:C4EE  ED 8B 26   			sbc.l	_sgx_map_pxl_y
         11:C4F1  42         			say
         11:C4F2  ED 8C 26   			sbc.h	_sgx_map_pxl_y
         11:C4F5  42         			say
 3852                        		__add.wi	32
         11:C4F6  18         			clc
         11:C4F7  69 20      			adc.l	#32
         11:C4F9  90 01      			bcc	!+
         11:C4FB  C8         			iny
         11:C4FC             	!:
 3853                        		__sgt_w.wi	0
         11:C4FC  18         			clc			; Subtract integer+1 from Y:A.
         11:C4FD  E9 00      			sbc.l	#0
         11:C4FF  98         			tya
         11:C500  E9 00      			sbc.h	#0
         11:C502  50 02      			bvc	!+
         11:C504  49 80      			eor	#$80		; +ve if Y:A > integer (signed).
         11:C506  49 80      	!:		eor	#$80
         11:C508  0A         			asl	a
 3854                        		__bfalse	.LL53
         11:C509  90 12      			bcc	.LL53
 3855                        	
 3856                        		.dbg	line,	"include\routines_LEVELS.c", 239; {
 3857                        	
 3858                        		.dbg	line,	"include\routines_LEVELS.c", 240; // WE STORE THE NPC ID //
 3859                        	
 3860                        		.dbg	line,	"include\routines_LEVELS.c", 241; list_onscreen_npc[onscreen_npc_number] = i;
 3861                        		__ldx.umq	_onscreen_npc_number
         11:C50B  AE AC 23   			ldx	_onscreen_npc_number
 3862                        		__ld.um		__scroll_npc_end - 1  /* i */
         11:C50E  AD 44 26   			lda	__scroll_npc_end - 1
         11:C511  C2         			cly
 3863                        		__st.uaxq	_list_onscreen_npc
         11:C512  9D BF 23   			sta	_list_onscreen_npc, x
 3864                        	
 3865                        		.dbg	line,	"include\routines_LEVELS.c", 242; onscreen_npc_number += 1;
 3866                        		__add_st.umiq	1, _onscreen_npc_number
         11:C515  EE AC 23   			inc	_onscreen_npc_number
 3867                        	
 3868                        		.dbg	line,	"include\routines_LEVELS.c", 243; 
 3869                        	
 3870                        		.dbg	line,	"include\routines_LEVELS.c", 244; scroll_allowed = TRUE;
 3871                        		__st.umiq	1, __scroll_npc_end - 2  /* scroll_allowed */
         11:C518  A9 01      			lda.l	#1
         11:C51A  8D 43 26   			sta	__scroll_npc_end - 2
 3872                        	
 3873                        		.dbg	line,	"include\routines_LEVELS.c", 245; }
 3874                        	
 3875                        		.dbg	line,	"include\routines_LEVELS.c", 246; }
 3876    11:C51D             	.LL53:
 3877                        	
 3878                        		.dbg	line,	"include\routines_LEVELS.c", 247; }
 3879    11:C51D             	.LL52:
 3880                        	
 3881                        		.dbg	line,	"include\routines_LEVELS.c", 248; }
 3882    11:C51D             	.LL51:
 3883                        	
 3884                        		.dbg	line,	"include\routines_LEVELS.c", 250; // IF NPC IS WITHIN THE SCREEN LIMITS //
 3885                        	
 3886                        		.dbg	line,	"include\routines_LEVELS.c", 251; if(scroll_allowed == TRUE)
 3887    11:C51D             	.LL50:
 3888                        		__ld.umq	__scroll_npc_end - 2  /* scroll_allowed */
         11:C51D  AD 43 26   			lda	__scroll_npc_end - 2
 3889                        		__equ_b.uiq	1
         11:C520  C9 01      			cmp	#1
         11:C522  F0 01      			beq	!+
         11:C524  18         			clc
         11:C525             	!:
 3890                        		__bfalse	.LL54
         11:C525  90 44      			bcc	.LL54
 3891                        	
 3892                        		.dbg	line,	"include\routines_LEVELS.c", 252; {
 3893                        	
 3894                        		.dbg	line,	"include\routines_LEVELS.c", 253; list_npc_x_pos[i] = list_npc_x_pos_ref[i] - sgx_map_pxl_x;
 3895                        		__ld2x.umq	__scroll_npc_end - 1  /* i */
         11:C527  AD 44 26   			lda	__scroll_npc_end - 1
         11:C52A  0A         			asl	a
         11:C52B  AA         			tax
 3896                        		__ld.wax	_list_npc_x_pos_ref
         11:C52C  BD 03 26   			lda.l	_list_npc_x_pos_ref, x
         11:C52F  BC 04 26   			ldy.h	_list_npc_x_pos_ref, x
 3897                        		__sub.wm	_sgx_map_pxl_x
         11:C532  38         			sec
         11:C533  ED 89 26   			sbc.l	_sgx_map_pxl_x
         11:C536  42         			say
         11:C537  ED 8A 26   			sbc.h	_sgx_map_pxl_x
         11:C53A  42         			say
 3898                        		__ld2x.um	__scroll_npc_end - 1  /* i */
         11:C53B  AA         			tax
         11:C53C  AD 44 26   			lda	__scroll_npc_end - 1
         11:C53F  0A         			asl	a
         11:C540  22         			sax
 3899                        		__st.waxq	_list_npc_x_pos
         11:C541  9D DF 25   			sta.l	_list_npc_x_pos, x
         11:C544  98         			tya
         11:C545  9D E0 25   			sta.h	_list_npc_x_pos, x
 3900                        	
 3901                        		.dbg	line,	"include\routines_LEVELS.c", 254; list_npc_y_pos[i] = list_npc_y_pos_ref[i] - sgx_map_pxl_y;
 3902                        		__ld2x.umq	__scroll_npc_end - 1  /* i */
         11:C548  AD 44 26   			lda	__scroll_npc_end - 1
         11:C54B  0A         			asl	a
         11:C54C  AA         			tax
 3903                        		__ld.wax	_list_npc_y_pos_ref
         11:C54D  BD 15 26   			lda.l	_list_npc_y_pos_ref, x
         11:C550  BC 16 26   			ldy.h	_list_npc_y_pos_ref, x
 3904                        		__sub.wm	_sgx_map_pxl_y
         11:C553  38         			sec
         11:C554  ED 8B 26   			sbc.l	_sgx_map_pxl_y
         11:C557  42         			say
         11:C558  ED 8C 26   			sbc.h	_sgx_map_pxl_y
         11:C55B  42         			say
 3905                        		__ld2x.um	__scroll_npc_end - 1  /* i */
         11:C55C  AA         			tax
         11:C55D  AD 44 26   			lda	__scroll_npc_end - 1
         11:C560  0A         			asl	a
         11:C561  22         			sax
 3906                        		__st.waxq	_list_npc_y_pos
         11:C562  9D F1 25   			sta.l	_list_npc_y_pos, x
         11:C565  98         			tya
         11:C566  9D F2 25   			sta.h	_list_npc_y_pos, x
 3907                        	
 3908                        		.dbg	line,	"include\routines_LEVELS.c", 255; }
 3909                        	
 3910                        		.dbg	line,	"include\routines_LEVELS.c", 257; else
 3911                        		__bra		.LL55
         11:C569  80 1E      			bra	.LL55
 3912    11:C56B             	.LL54:
 3913                        	
 3914                        		.dbg	line,	"include\routines_LEVELS.c", 258; {
 3915                        	
 3916                        		.dbg	line,	"include\routines_LEVELS.c", 259; list_npc_x_pos[i] = -32;
 3917                        		__ld2x.umq	__scroll_npc_end - 1  /* i */
         11:C56B  AD 44 26   			lda	__scroll_npc_end - 1
         11:C56E  0A         			asl	a
         11:C56F  AA         			tax
 3918                        		__st.waxiq	-32, _list_npc_x_pos
         11:C570  A9 E0      			lda.l	#-32
         11:C572  9D DF 25   			sta.l	_list_npc_x_pos, x
         11:C575  A9 FF      			lda.h	#-32
         11:C577  9D E0 25   			sta.h	_list_npc_x_pos, x
 3919                        	
 3920                        		.dbg	line,	"include\routines_LEVELS.c", 260; list_npc_y_pos[i] = -32;
 3921                        		__ld2x.umq	__scroll_npc_end - 1  /* i */
         11:C57A  AD 44 26   			lda	__scroll_npc_end - 1
         11:C57D  0A         			asl	a
         11:C57E  AA         			tax
 3922                        		__st.waxiq	-32, _list_npc_y_pos
         11:C57F  A9 E0      			lda.l	#-32
         11:C581  9D F1 25   			sta.l	_list_npc_y_pos, x
         11:C584  A9 FF      			lda.h	#-32
         11:C586  9D F2 25   			sta.h	_list_npc_y_pos, x
 3923                        	
 3924                        		.dbg	line,	"include\routines_LEVELS.c", 261; }
 3925    11:C589             	.LL55:
 3926                        	
 3927                        		.dbg	line,	"include\routines_LEVELS.c", 263; spr_set(i + npc_start_index);
 3928                        		__ld.um		__scroll_npc_end - 1  /* i */
         11:C589  AD 44 26   			lda	__scroll_npc_end - 1
         11:C58C  C2         			cly
 3929                        		__add.um	_npc_start_index
         11:C58D  18         			clc
         11:C58E  6D AA 23   			adc	_npc_start_index
         11:C591  90 01      			bcc	!+
         11:C593  C8         			iny
         11:C594             	!:
 3930                        		__call		_spr_set.1
         11:C594  20 DD E7   			call	_spr_set.1
 3931                        	
 3932                        		.dbg	line,	"include\routines_LEVELS.c", 265; spr_x(list_npc_x_pos[i]);
 3933                        		__ld2x.umq	__scroll_npc_end - 1  /* i */
         11:C597  AD 44 26   			lda	__scroll_npc_end - 1
         11:C59A  0A         			asl	a
         11:C59B  AA         			tax
 3934                        		__ld.wax	_list_npc_x_pos
         11:C59C  BD DF 25   			lda.l	_list_npc_x_pos, x
         11:C59F  BC E0 25   			ldy.h	_list_npc_x_pos, x
 3935                        		__call		_spr_x.1
         11:C5A2  20 0A E8   			call	_spr_x.1
 3936                        	
 3937                        		.dbg	line,	"include\routines_LEVELS.c", 266; spr_y(list_npc_y_pos[i]);
 3938                        		__ld2x.umq	__scroll_npc_end - 1  /* i */
         11:C5A5  AD 44 26   			lda	__scroll_npc_end - 1
         11:C5A8  0A         			asl	a
         11:C5A9  AA         			tax
 3939                        		__ld.wax	_list_npc_y_pos
         11:C5AA  BD F1 25   			lda.l	_list_npc_y_pos, x
         11:C5AD  BC F2 25   			ldy.h	_list_npc_y_pos, x
 3940                        		__call		_spr_y.1
         11:C5B0  20 19 E8   			call	_spr_y.1
 3941                        	
 3942                        		.dbg	line,	"include\routines_LEVELS.c", 267; }
 3943                        	
 3944                        		.dbg	line,	"include\routines_LEVELS.c", 268; }
 3945    11:C5B3             	.LL49	.alias		.LL46
 3946                        		__bra		.LL46
         11:C5B3  4C 67 C4   			bra	.LL46
 3947    11:C5B6             	.LL48:
 3948                        	
 3949                        		.dbg	line,	"include\routines_LEVELS.c", 269; }
 3950    11:C5B6             	.LL44:
 3951                        		__return	0
         11:C5B6  4C EF FF   			jmp	leave_proc
 3952                        		.dbg	clear
 3953                        		.endp
 3954                        		.pceas
 3955                        	
 3956                        		.dbg	line,	"include\routines_LEVELS.c", 274; int check_TILE_DEPTH(signed char x_offset , signed char y_offset)
 3957                        		.dbg	line,	"include\routines_LEVELS.c", 275; {
 3958                        	;***********************
 3959                        	;***********************
 3960                        	
 3961                        		.hucc
 3962    11:CF1D             		.proc		_check_TILE_DEPTH
 3963                        		__enter		_check_TILE_DEPTH
 3964                        	
 3965                        		.dbg	line,	"include\routines_LEVELS.c", 276; int player_COLL_X;
 3966                        	
 3967                        		.dbg	line,	"include\routines_LEVELS.c", 277; int player_COLL_Y;
 3968                        	
 3969                        		.dbg	line,	"include\routines_LEVELS.c", 280; player_COLL_X = player_pos_x + x_offset;
 3970                        		__ld.bs		2  /* x_offset */
         11:CF1D  A6 8D      			ldx	<__sp
         11:CF1F  B5 0A      			lda	<__stack + 2, x
         11:CF21  C2         			cly
         11:CF22  10 01      			bpl	!+	; signed
         11:CF24  88         			dey
         11:CF25             	!:
 3971                        		__add.wm	_player_pos_x
         11:CF25  18         			clc
         11:CF26  6D CD 24   			adc.l	_player_pos_x
         11:CF29  42         			say
         11:CF2A  6D CE 24   			adc.h	_player_pos_x
         11:CF2D  42         			say
 3972                        		__st.wmq	__check_TILE_DEPTH_end - 2  /* player_COLL_X */
         11:CF2E  8D 43 26   			sta.l	__check_TILE_DEPTH_end - 2
         11:CF31  8C 44 26   			sty.h	__check_TILE_DEPTH_end - 2
 3973                        	
 3974                        		.dbg	line,	"include\routines_LEVELS.c", 281; player_COLL_Y = player_pos_y + 32 - y_offset;//32
 3975                        		__ld.wm		_player_pos_y
         11:CF34  AD CF 24   			lda.l	_player_pos_y
         11:CF37  AC D0 24   			ldy.h	_player_pos_y
 3976                        		__add.wi	32
         11:CF3A  18         			clc
         11:CF3B  69 20      			adc.l	#32
         11:CF3D  90 01      			bcc	!+
         11:CF3F  C8         			iny
         11:CF40             	!:
 3977                        		__push.wr
         11:CF40  5A         			phy
         11:CF41  48         			pha
 3978                        		__ld.bs		0  /* y_offset */
         11:CF42  A6 8D      			ldx	<__sp
         11:CF44  B5 08      			lda	<__stack + 0, x
         11:CF46  C2         			cly
         11:CF47  10 01      			bpl	!+	; signed
         11:CF49  88         			dey
         11:CF4A             	!:
 3979                        		__sub.wt
         11:CF4A  BA         			tsx
         11:CF4B  38         			sec
         11:CF4C  49 FF      			eor	#$FF
         11:CF4E  7D 01 21   			adc.l	__tos, x
         11:CF51  42         			say
         11:CF52  49 FF      			eor	#$FF
         11:CF54  7D 02 21   			adc.h	__tos, x
         11:CF57  42         			say
         11:CF58  E8         			inx
         11:CF59  E8         			inx
         11:CF5A  9A         			txs
 3980                        		__st.wmq	__check_TILE_DEPTH_end - 4  /* player_COLL_Y */
         11:CF5B  8D 41 26   			sta.l	__check_TILE_DEPTH_end - 4
         11:CF5E  8C 42 26   			sty.h	__check_TILE_DEPTH_end - 4
 3981                        	
 3982                        		.dbg	line,	"include\routines_LEVELS.c", 283; get_map_block(player_COLL_X + sgx_map_pxl_x, player_COLL_Y + sgx_map_pxl_y);
 3983                        		__ld.wm		__check_TILE_DEPTH_end - 2  /* player_COLL_X */
         11:CF61  AD 43 26   			lda.l	__check_TILE_DEPTH_end - 2
         11:CF64  AC 44 26   			ldy.h	__check_TILE_DEPTH_end - 2
 3984                        		__add.wm	_sgx_map_pxl_x
         11:CF67  18         			clc
         11:CF68  6D 89 26   			adc.l	_sgx_map_pxl_x
         11:CF6B  42         			say
         11:CF6C  6D 8A 26   			adc.h	_sgx_map_pxl_x
         11:CF6F  42         			say
 3985                        		__st.wmq	map_pxl_x
         11:CF70  85 FC      			sta.l	map_pxl_x
         11:CF72  84 FD      			sty.h	map_pxl_x
 3986                        		__ld.wm		__check_TILE_DEPTH_end - 4  /* player_COLL_Y */
         11:CF74  AD 41 26   			lda.l	__check_TILE_DEPTH_end - 4
         11:CF77  AC 42 26   			ldy.h	__check_TILE_DEPTH_end - 4
 3987                        		__add.wm	_sgx_map_pxl_y
         11:CF7A  18         			clc
         11:CF7B  6D 8B 26   			adc.l	_sgx_map_pxl_y
         11:CF7E  42         			say
         11:CF7F  6D 8C 26   			adc.h	_sgx_map_pxl_y
         11:CF82  42         			say
 3988                        		__st.wmq	map_pxl_y
         11:CF83  85 FE      			sta.l	map_pxl_y
         11:CF85  84 FF      			sty.h	map_pxl_y
 3989                        		__call		_get_map_block.2
         11:CF87  20 95 FF   			call	_get_map_block.2
 3990                        	
 3991                        		.dbg	line,	"include\routines_LEVELS.c", 284; }
 3992    11:CF8A             	.LL56:
 3993                        		__modsp		4
         11:CF8A  AA         			tax
         11:CF8B  A5 8D      			lda	<__sp
         11:CF8D  18         			clc
         11:CF8E  69 04      			adc	#4
         11:CF90  85 8D      			sta	<__sp
         11:CF92  8A         			txa
 3994                        		__return	1
         11:CF93  AA         			tax
         11:CF94  4C EF FF   			jmp	leave_proc
 3995                        		.dbg	clear
 3996                        		.endp
 3997                        		.pceas
 3998                        	
 3999                        		.dbg	line,	"include\routines_LEVELS.c", 286; // CHECK COLLISION WITH BG //
 4000                        		.dbg	line,	"include\routines_LEVELS.c", 287; int check_BG(signed char x_offset , signed char y_offset)
 4001                        		.dbg	line,	"include\routines_LEVELS.c", 288; {
 4002                        	;***********************
 4003                        	;***********************
 4004                        	
 4005                        		.hucc
 4006    11:D078             		.proc		_check_BG
 4007                        		__enter		_check_BG
 4008                        	
 4009                        		.dbg	line,	"include\routines_LEVELS.c", 289; int player_COLL_X;
 4010                        	
 4011                        		.dbg	line,	"include\routines_LEVELS.c", 290; int player_COLL_Y;
 4012                        	
 4013                        		.dbg	line,	"include\routines_LEVELS.c", 293; player_COLL_X = player_pos_x + x_offset;
 4014                        		__ld.bs		2  /* x_offset */
         11:D078  A6 8D      			ldx	<__sp
         11:D07A  B5 0A      			lda	<__stack + 2, x
         11:D07C  C2         			cly
         11:D07D  10 01      			bpl	!+	; signed
         11:D07F  88         			dey
         11:D080             	!:
 4015                        		__add.wm	_player_pos_x
         11:D080  18         			clc
         11:D081  6D CD 24   			adc.l	_player_pos_x
         11:D084  42         			say
         11:D085  6D CE 24   			adc.h	_player_pos_x
         11:D088  42         			say
 4016                        		__st.wmq	__check_BG_end - 2  /* player_COLL_X */
         11:D089  8D 43 26   			sta.l	__check_BG_end - 2
         11:D08C  8C 44 26   			sty.h	__check_BG_end - 2
 4017                        	
 4018                        		.dbg	line,	"include\routines_LEVELS.c", 294; player_COLL_Y = player_pos_y + y_offset;
 4019                        		__ld.bs		0  /* y_offset */
         11:D08F  A6 8D      			ldx	<__sp
         11:D091  B5 08      			lda	<__stack + 0, x
         11:D093  C2         			cly
         11:D094  10 01      			bpl	!+	; signed
         11:D096  88         			dey
         11:D097             	!:
 4020                        		__add.wm	_player_pos_y
         11:D097  18         			clc
         11:D098  6D CF 24   			adc.l	_player_pos_y
         11:D09B  42         			say
         11:D09C  6D D0 24   			adc.h	_player_pos_y
         11:D09F  42         			say
 4021                        		__st.wmq	__check_BG_end - 4  /* player_COLL_Y */
         11:D0A0  8D 41 26   			sta.l	__check_BG_end - 4
         11:D0A3  8C 42 26   			sty.h	__check_BG_end - 4
 4022                        	
 4023                        		.dbg	line,	"include\routines_LEVELS.c", 296; get_map_block(player_COLL_X + sgx_map_pxl_x, player_COLL_Y + sgx_map_pxl_y);
 4024                        		__ld.wm		__check_BG_end - 2  /* player_COLL_X */
         11:D0A6  AD 43 26   			lda.l	__check_BG_end - 2
         11:D0A9  AC 44 26   			ldy.h	__check_BG_end - 2
 4025                        		__add.wm	_sgx_map_pxl_x
         11:D0AC  18         			clc
         11:D0AD  6D 89 26   			adc.l	_sgx_map_pxl_x
         11:D0B0  42         			say
         11:D0B1  6D 8A 26   			adc.h	_sgx_map_pxl_x
         11:D0B4  42         			say
 4026                        		__st.wmq	map_pxl_x
         11:D0B5  85 FC      			sta.l	map_pxl_x
         11:D0B7  84 FD      			sty.h	map_pxl_x
 4027                        		__ld.wm		__check_BG_end - 4  /* player_COLL_Y */
         11:D0B9  AD 41 26   			lda.l	__check_BG_end - 4
         11:D0BC  AC 42 26   			ldy.h	__check_BG_end - 4
 4028                        		__add.wm	_sgx_map_pxl_y
         11:D0BF  18         			clc
         11:D0C0  6D 8B 26   			adc.l	_sgx_map_pxl_y
         11:D0C3  42         			say
         11:D0C4  6D 8C 26   			adc.h	_sgx_map_pxl_y
         11:D0C7  42         			say
 4029                        		__st.wmq	map_pxl_y
         11:D0C8  85 FE      			sta.l	map_pxl_y
         11:D0CA  84 FF      			sty.h	map_pxl_y
 4030                        		__call		_get_map_block.2
         11:D0CC  20 95 FF   			call	_get_map_block.2
 4031                        	
 4032                        		.dbg	line,	"include\routines_LEVELS.c", 297; }
 4033    11:D0CF             	.LL57:
 4034                        		__modsp		4
         11:D0CF  AA         			tax
         11:D0D0  A5 8D      			lda	<__sp
         11:D0D2  18         			clc
         11:D0D3  69 04      			adc	#4
         11:D0D5  85 8D      			sta	<__sp
         11:D0D7  8A         			txa
 4035                        		__return	1
         11:D0D8  AA         			tax
         11:D0D9  4C EF FF   			jmp	leave_proc
 4036                        		.dbg	clear
 4037                        		.endp
 4038                        		.pceas
 4039                        	
 4040                        		.dbg	line,	"include\routines_LEVELS.c", 299; // CHECK COLLISION WITH OBJECTS //
 4041                        		.dbg	line,	"include\routines_LEVELS.c", 300; void check_OBJECT()
 4042                        		.dbg	line,	"include\routines_LEVELS.c", 301; {
 4043                        	;***********************
 4044                        	;***********************
 4045                        	
 4046                        		.hucc
 4047    11:C000             		.proc		_check_OBJECT
 4048                        		__enter		_check_OBJECT
 4049                        	
 4050                        		.dbg	line,	"include\routines_LEVELS.c", 302; if(onscreen_object_number != 0)
 4051                        		__tst.um	_onscreen_object_number
         11:C000  AD 2A 23   			lda	_onscreen_object_number
         11:C003  C9 01      			cmp	#1
 4052                        		__bfalse	.LL59
         11:C005  B0 03 4C 81			bcc	.LL59
         11:C009  C1          
 4053                        	
 4054                        		.dbg	line,	"include\routines_LEVELS.c", 303; {
 4055                        	
 4056                        		.dbg	line,	"include\routines_LEVELS.c", 304; char i;
 4057                        	
 4058                        		.dbg	line,	"include\routines_LEVELS.c", 305; char current_object_id;
 4059                        	
 4060                        		.dbg	line,	"include\routines_LEVELS.c", 306; char current_object_type;
 4061                        	
 4062                        		.dbg	line,	"include\routines_LEVELS.c", 308; for(i=0 ; i<onscreen_object_number ; i++)
 4063                        		__st.umiq	0, __check_OBJECT_end - 1  /* i */
         11:C00A  9C 02 23   			stz	__check_OBJECT_end - 1
 4064    11:C00D             	.LL60:
 4065                        		__ld.umq	__check_OBJECT_end - 1  /* i */
         11:C00D  AD 02 23   			lda	__check_OBJECT_end - 1
 4066                        		__ult_b.umq	_onscreen_object_number
         11:C010  CD 2A 23   			cmp	_onscreen_object_number		; Subtract memory from A.
         11:C013  6A         			ror	a		; CC if A < memory.
         11:C014  49 80      			eor	#$80
         11:C016  2A         			rol	a
 4067                        		__btrue		.LL62
         11:C017  B0 08      			bcs	.LL62
 4068                        		__bra		.LL63
         11:C019  4C 81 C1   			bra	.LL63
 4069    11:C01C             	.LL61:
 4070                        		__inc.umq	__check_OBJECT_end - 1  /* i */
         11:C01C  EE 02 23   			inc	__check_OBJECT_end - 1
 4071                        		__bra		.LL60
         11:C01F  80 EC      			bra	.LL60
 4072    11:C021             	.LL62:
 4073                        	
 4074                        		.dbg	line,	"include\routines_LEVELS.c", 309; {
 4075                        	
 4076                        		.dbg	line,	"include\routines_LEVELS.c", 310; // RETRIEVE OBJECT INDEX IN THE LIST //
 4077                        	
 4078                        		.dbg	line,	"include\routines_LEVELS.c", 311; current_object_id = list_onscreen_object[i];
 4079                        		__ldx.umq	__check_OBJECT_end - 1  /* i */
         11:C021  AE 02 23   			ldx	__check_OBJECT_end - 1
 4080                        		__ld.uax	_list_onscreen_object
         11:C024  BD 8F 23   			lda	_list_onscreen_object, x
         11:C027  C2         			cly
 4081                        		__st.umq	__check_OBJECT_end - 2  /* current_object_id */
         11:C028  8D 01 23   			sta	__check_OBJECT_end - 2
 4082                        	
 4083                        		.dbg	line,	"include\routines_LEVELS.c", 312; // RETRIEVE OBJECT TYPE //
 4084                        	
 4085                        		.dbg	line,	"include\routines_LEVELS.c", 313; current_object_type = list_object_type[current_object_id];
 4086                        		__ldx.umq	__check_OBJECT_end - 2  /* current_object_id */
         11:C02B  AE 01 23   			ldx	__check_OBJECT_end - 2
 4087                        		__ld.uax	_list_object_type
         11:C02E  BD 2B 23   			lda	_list_object_type, x
         11:C031  C2         			cly
 4088                        		__st.umq	__check_OBJECT_end - 3  /* current_object_type */
         11:C032  8D 00 23   			sta	__check_OBJECT_end - 3
 4089                        	
 4090                        		.dbg	line,	"include\routines_LEVELS.c", 315; if(current_object_type != TYPE_POT)
 4091                        		__ld.umq	__check_OBJECT_end - 3  /* current_object_type */
         11:C035  AD 00 23   			lda	__check_OBJECT_end - 3
 4092                        		__neq_b.uiq	1
         11:C038  38         			sec
         11:C039  49 01      			eor	#1
         11:C03B  D0 01      			bne	!+
         11:C03D  18         			clc
         11:C03E             	!:
 4093                        		__bfalse	.LL64
         11:C03E  90 DC      			bcc	.LL64
 4094                        	
 4095                        		.dbg	line,	"include\routines_LEVELS.c", 316; {
 4096                        	
 4097                        		.dbg	line,	"include\routines_LEVELS.c", 317; if(abs( (player_pos_x + 16) - (list_object_x_pos[current_object_id] + 8) ) < OBJECT_MARGIN)
 4098                        		__ld.wm		_player_pos_x
         11:C040  AD CD 24   			lda.l	_player_pos_x
         11:C043  AC CE 24   			ldy.h	_player_pos_x
 4099                        		__add.wi	16
         11:C046  18         			clc
         11:C047  69 10      			adc.l	#16
         11:C049  90 01      			bcc	!+
         11:C04B  C8         			iny
         11:C04C             	!:
 4100                        		__push.wr
         11:C04C  5A         			phy
         11:C04D  48         			pha
 4101                        		__ld2x.umq	__check_OBJECT_end - 2  /* current_object_id */
         11:C04E  AD 01 23   			lda	__check_OBJECT_end - 2
         11:C051  0A         			asl	a
         11:C052  AA         			tax
 4102                        		__ld.wax	_list_object_x_pos
         11:C053  BD D7 24   			lda.l	_list_object_x_pos, x
         11:C056  BC D8 24   			ldy.h	_list_object_x_pos, x
 4103                        		__add.wi	8
         11:C059  18         			clc
         11:C05A  69 08      			adc.l	#8
         11:C05C  90 01      			bcc	!+
         11:C05E  C8         			iny
         11:C05F             	!:
 4104                        		__sub.wt
         11:C05F  BA         			tsx
         11:C060  38         			sec
         11:C061  49 FF      			eor	#$FF
         11:C063  7D 01 21   			adc.l	__tos, x
         11:C066  42         			say
         11:C067  49 FF      			eor	#$FF
         11:C069  7D 02 21   			adc.h	__tos, x
         11:C06C  42         			say
         11:C06D  E8         			inx
         11:C06E  E8         			inx
         11:C06F  9A         			txs
 4105                        		__call		_abs.1
         11:C070  20 09 E5   			call	_abs.1
 4106                        		__slt_w.wi	10
         11:C073  C9 0A      			cmp.l	#10		; Subtract integer from Y:A.
         11:C075  98         			tya
         11:C076  E9 00      			sbc.h	#10
         11:C078  50 02      			bvc	!+
         11:C07A  49 80      			eor	#$80		; -ve if Y:A < integer (signed).
         11:C07C  0A         	!:		asl	a
 4107                        		__bfalse	.LL65
         11:C07D  90 9D      			bcc	.LL65
 4108                        	
 4109                        		.dbg	line,	"include\routines_LEVELS.c", 318; {
 4110                        	
 4111                        		.dbg	line,	"include\routines_LEVELS.c", 319; if(abs( (player_pos_y + 16) - (list_object_y_pos[current_object_id] + 8) ) < OBJECT_MARGIN)
 4112                        		__ld.wm		_player_pos_y
         11:C07F  AD CF 24   			lda.l	_player_pos_y
         11:C082  AC D0 24   			ldy.h	_player_pos_y
 4113                        		__add.wi	16
         11:C085  18         			clc
         11:C086  69 10      			adc.l	#16
         11:C088  90 01      			bcc	!+
         11:C08A  C8         			iny
         11:C08B             	!:
 4114                        		__push.wr
         11:C08B  5A         			phy
         11:C08C  48         			pha
 4115                        		__ld2x.umq	__check_OBJECT_end - 2  /* current_object_id */
         11:C08D  AD 01 23   			lda	__check_OBJECT_end - 2
         11:C090  0A         			asl	a
         11:C091  AA         			tax
 4116                        		__ld.wax	_list_object_y_pos
         11:C092  BD 09 25   			lda.l	_list_object_y_pos, x
         11:C095  BC 0A 25   			ldy.h	_list_object_y_pos, x
 4117                        		__add.wi	8
         11:C098  18         			clc
         11:C099  69 08      			adc.l	#8
         11:C09B  90 01      			bcc	!+
         11:C09D  C8         			iny
         11:C09E             	!:
 4118                        		__sub.wt
         11:C09E  BA         			tsx
         11:C09F  38         			sec
         11:C0A0  49 FF      			eor	#$FF
         11:C0A2  7D 01 21   			adc.l	__tos, x
         11:C0A5  42         			say
         11:C0A6  49 FF      			eor	#$FF
         11:C0A8  7D 02 21   			adc.h	__tos, x
         11:C0AB  42         			say
         11:C0AC  E8         			inx
         11:C0AD  E8         			inx
         11:C0AE  9A         			txs
 4119                        		__call		_abs.1
         11:C0AF  20 09 E5   			call	_abs.1
 4120                        		__slt_w.wi	10
         11:C0B2  C9 0A      			cmp.l	#10		; Subtract integer from Y:A.
         11:C0B4  98         			tya
         11:C0B5  E9 00      			sbc.h	#10
         11:C0B7  50 02      			bvc	!+
         11:C0B9  49 80      			eor	#$80		; -ve if Y:A < integer (signed).
         11:C0BB  0A         	!:		asl	a
 4121                        		__bfalse	.LL66
         11:C0BC  B0 03 4C 1C			bcc	.LL66
         11:C0C0  C0          
 4122                        	
 4123                        		.dbg	line,	"include\routines_LEVELS.c", 320; {
 4124                        	
 4125                        		.dbg	line,	"include\routines_LEVELS.c", 321; // THE OBJECT DISAPPEARS //
 4126                        	
 4127                        		.dbg	line,	"include\routines_LEVELS.c", 322; list_object_x_pos[current_object_id] = -16;
 4128                        		__ld2x.umq	__check_OBJECT_end - 2  /* current_object_id */
         11:C0C1  AD 01 23   			lda	__check_OBJECT_end - 2
         11:C0C4  0A         			asl	a
         11:C0C5  AA         			tax
 4129                        		__st.waxiq	-16, _list_object_x_pos
         11:C0C6  A9 F0      			lda.l	#-16
         11:C0C8  9D D7 24   			sta.l	_list_object_x_pos, x
         11:C0CB  A9 FF      			lda.h	#-16
         11:C0CD  9D D8 24   			sta.h	_list_object_x_pos, x
 4130                        	
 4131                        		.dbg	line,	"include\routines_LEVELS.c", 323; list_object_y_pos[current_object_id] = -16;
 4132                        		__ld2x.umq	__check_OBJECT_end - 2  /* current_object_id */
         11:C0D0  AD 01 23   			lda	__check_OBJECT_end - 2
         11:C0D3  0A         			asl	a
         11:C0D4  AA         			tax
 4133                        		__st.waxiq	-16, _list_object_y_pos
         11:C0D5  A9 F0      			lda.l	#-16
         11:C0D7  9D 09 25   			sta.l	_list_object_y_pos, x
         11:C0DA  A9 FF      			lda.h	#-16
         11:C0DC  9D 0A 25   			sta.h	_list_object_y_pos, x
 4134                        	
 4135                        		.dbg	line,	"include\routines_LEVELS.c", 324; list_object_state[current_object_id] = STATE_INACTIVE;
 4136                        		__ldx.umq	__check_OBJECT_end - 2  /* current_object_id */
         11:C0DF  AE 01 23   			ldx	__check_OBJECT_end - 2
 4137                        		__st.uaxiq	1, _list_object_state
         11:C0E2  A9 01      			lda.l	#1
         11:C0E4  9D 44 23   			sta	_list_object_state, x
 4138                        	
 4139                        		.dbg	line,	"include\routines_LEVELS.c", 326; spr_set(current_object_id + object_start_index);
 4140                        		__ld.um		__check_OBJECT_end - 2  /* current_object_id */
         11:C0E7  AD 01 23   			lda	__check_OBJECT_end - 2
         11:C0EA  C2         			cly
 4141                        		__add.um	_object_start_index
         11:C0EB  18         			clc
         11:C0EC  6D 28 23   			adc	_object_start_index
         11:C0EF  90 01      			bcc	!+
         11:C0F1  C8         			iny
         11:C0F2             	!:
 4142                        		__call		_spr_set.1
         11:C0F2  20 DD E7   			call	_spr_set.1
 4143                        	
 4144                        		.dbg	line,	"include\routines_LEVELS.c", 327; spr_x(list_object_x_pos[current_object_id]);
 4145                        		__ld2x.umq	__check_OBJECT_end - 2  /* current_object_id */
         11:C0F5  AD 01 23   			lda	__check_OBJECT_end - 2
         11:C0F8  0A         			asl	a
         11:C0F9  AA         			tax
 4146                        		__ld.wax	_list_object_x_pos
         11:C0FA  BD D7 24   			lda.l	_list_object_x_pos, x
         11:C0FD  BC D8 24   			ldy.h	_list_object_x_pos, x
 4147                        		__call		_spr_x.1
         11:C100  20 0A E8   			call	_spr_x.1
 4148                        	
 4149                        		.dbg	line,	"include\routines_LEVELS.c", 328; spr_y(list_object_y_pos[current_object_id]);
 4150                        		__ld2x.umq	__check_OBJECT_end - 2  /* current_object_id */
         11:C103  AD 01 23   			lda	__check_OBJECT_end - 2
         11:C106  0A         			asl	a
         11:C107  AA         			tax
 4151                        		__ld.wax	_list_object_y_pos
         11:C108  BD 09 25   			lda.l	_list_object_y_pos, x
         11:C10B  BC 0A 25   			ldy.h	_list_object_y_pos, x
 4152                        		__call		_spr_y.1
         11:C10E  20 19 E8   			call	_spr_y.1
 4153                        	
 4154                        		.dbg	line,	"include\routines_LEVELS.c", 329; 
 4155                        	
 4156                        		.dbg	line,	"include\routines_LEVELS.c", 331; switch(current_object_type)
 4157                        		__ld.umq	__check_OBJECT_end - 3  /* current_object_type */
         11:C111  AD 00 23   			lda	__check_OBJECT_end - 3
 4158                        		__bra		.LL67
         11:C114  80 4A      			bra	.LL67
 4159                        	
 4160                        		.dbg	line,	"include\routines_LEVELS.c", 332; {
 4161                        	
 4162                        		.dbg	line,	"include\routines_LEVELS.c", 333; case TYPE_HOURGLASS:
 4163    11:C116             	.LL69:
 4164                        		__case		0
 4165                        	
 4166                        		.dbg	line,	"include\routines_LEVELS.c", 334; if(seconds + 30 > 59)
 4167                        		__ld.um		_seconds
         11:C116  AD 24 23   			lda	_seconds
         11:C119  C2         			cly
 4168                        		__add.wi	30
         11:C11A  18         			clc
         11:C11B  69 1E      			adc.l	#30
         11:C11D  90 01      			bcc	!+
         11:C11F  C8         			iny
         11:C120             	!:
 4169                        		__sgt_w.wi	59
         11:C120  18         			clc			; Subtract integer+1 from Y:A.
         11:C121  E9 3B      			sbc.l	#59
         11:C123  98         			tya
         11:C124  E9 00      			sbc.h	#59
         11:C126  50 02      			bvc	!+
         11:C128  49 80      			eor	#$80		; +ve if Y:A > integer (signed).
         11:C12A  49 80      	!:		eor	#$80
         11:C12C  0A         			asl	a
 4170                        		__bfalse	.LL70
         11:C12D  90 13      			bcc	.LL70
 4171                        	
 4172                        		.dbg	line,	"include\routines_LEVELS.c", 335; {
 4173                        	
 4174                        		.dbg	line,	"include\routines_LEVELS.c", 336; seconds = seconds + 30 - 60;
 4175                        		__ld.um		_seconds
         11:C12F  AD 24 23   			lda	_seconds
         11:C132  C2         			cly
 4176                        		__sub.wi	30
         11:C133  38         			sec
         11:C134  E9 1E      			sbc.l	#30
         11:C136  B0 01      			bcs	!+
         11:C138  88         			dey
         11:C139             	!:
 4177                        		__st.umq	_seconds
         11:C139  8D 24 23   			sta	_seconds
 4178                        	
 4179                        		.dbg	line,	"include\routines_LEVELS.c", 337; minutes += 1;
 4180                        		__add_st.umiq	1, _minutes
         11:C13C  EE 23 23   			inc	_minutes
 4181                        	
 4182                        		.dbg	line,	"include\routines_LEVELS.c", 338; }
 4183                        	
 4184                        		.dbg	line,	"include\routines_LEVELS.c", 340; else
 4185                        		__bra		.LL71
         11:C13F  4C 1C C0   			bra	.LL71
 4186    11:C142             	.LL70:
 4187                        	
 4188                        		.dbg	line,	"include\routines_LEVELS.c", 341; {
 4189                        	
 4190                        		.dbg	line,	"include\routines_LEVELS.c", 342; seconds += 30;
 4191                        		__add_st.umiq	30, _seconds
         11:C142  18         			clc
         11:C143  AD 24 23   			lda	_seconds
         11:C146  69 1E      			adc	#30
         11:C148  8D 24 23   			sta	_seconds
 4192                        	
 4193                        		.dbg	line,	"include\routines_LEVELS.c", 343; }
 4194    11:C14B             	.LL71	.alias		.LL68
 4195                        	
 4196                        		.dbg	line,	"include\routines_LEVELS.c", 345; break;
 4197                        		__bra		.LL68
         11:C14B  4C 1C C0   			bra	.LL68
 4198                        	
 4199                        		.dbg	line,	"include\routines_LEVELS.c", 347; case TYPE_POW:
 4200    11:C14E             	.LL72:
 4201                        		__case		2
 4202                        	
 4203                        		.dbg	line,	"include\routines_LEVELS.c", 348; //
 4204                        	
 4205                        		.dbg	line,	"include\routines_LEVELS.c", 349; break;
 4206                        		__bra		.LL68
         11:C14E  4C 1C C0   			bra	.LL68
 4207                        	
 4208                        		.dbg	line,	"include\routines_LEVELS.c", 351; case TYPE_GRAY_KEY:
 4209    11:C151             	.LL73:
 4210                        		__case		4
 4211                        	
 4212                        		.dbg	line,	"include\routines_LEVELS.c", 352; key_amount += 1;
 4213                        		__add_st.umiq	1, _key_amount
         11:C151  EE 21 23   			inc	_key_amount
 4214                        	
 4215                        		.dbg	line,	"include\routines_LEVELS.c", 353; display_KEY();
 4216                        		__call		_display_KEY
         11:C154  20 8B FF   			call	_display_KEY
 4217                        	
 4218                        		.dbg	line,	"include\routines_LEVELS.c", 354; break;
 4219                        		__bra		.LL68
         11:C157  4C 1C C0   			bra	.LL68
 4220                        	
 4221                        		.dbg	line,	"include\routines_LEVELS.c", 356; case TYPE_YASHICHI:
 4222    11:C15A             	.LL74:
 4223                        		__case		14
 4224                        	
 4225                        		.dbg	line,	"include\routines_LEVELS.c", 357; life_amount += 1;
 4226                        		__add_st.umiq	1, _life_amount
         11:C15A  EE 20 23   			inc	_life_amount
 4227                        	
 4228                        		.dbg	line,	"include\routines_LEVELS.c", 358; break;
 4229                        		__bra		.LL68
         11:C15D  4C 1C C0   			bra	.LL68
 4230                        	
 4231                        		.dbg	line,	"include\routines_LEVELS.c", 359; }
 4232    11:C160             	.LL67:
 4233                        		__switch_c.ur	4
         11:C160  A2 05      			ldx	#4 + 1
         11:C162  CA         	!loop:		dex
         11:C163  F0 05      			beq	!found+
         11:C165  DD 6F C1   			cmp	!table+ - 1, x
         11:C168  D0 F8      			bne	!loop-
         11:C16A  8A         	!found:		txa
         11:C16B  0A         			asl	a
         11:C16C  AA         			tax
         11:C16D  7C 74 C1   			jmp	[!table+ + 4, x]
 4234                        	
 4235    11:C170  0E 04 02 00	!table:		db	14, 4, 2, 0
 4236    11:C174  1C C0      			dw	.LL68
 4237    11:C176  5A C1      			dw	.LL74, .LL73, .LL72, .LL69
         11:C178  51 C1       
         11:C17A  4E C1       
         11:C17C  16 C1       
 4238                        	
 4239    11:C17E             	.LL68	.alias		.LL61
 4240                        	
 4241                        		.dbg	line,	"include\routines_LEVELS.c", 360; }
 4242                        	
 4243                        		.dbg	line,	"include\routines_LEVELS.c", 361; }
 4244    11:C17E             	.LL66	.alias		.LL61
 4245                        	
 4246                        		.dbg	line,	"include\routines_LEVELS.c", 362; }
 4247    11:C17E             	.LL65	.alias		.LL61
 4248                        	
 4249                        		.dbg	line,	"include\routines_LEVELS.c", 363; }
 4250    11:C17E             	.LL64	.alias		.LL61
 4251                        		__bra		.LL61
         11:C17E  4C 1C C0   			bra	.LL61
 4252    11:C181             	.LL63:
 4253                        	
 4254                        		.dbg	line,	"include\routines_LEVELS.c", 364; }
 4255                        	
 4256                        		.dbg	line,	"include\routines_LEVELS.c", 365; }
 4257    11:C181             	.LL59:
 4258    11:C181             	.LL58:
 4259                        		__return	0
         11:C181  4C EF FF   			jmp	leave_proc
 4260                        		.dbg	clear
 4261                        		.endp
 4262               7F60     		.data
 4263               2300     		.bss
 4264    F8:2300             	__check_OBJECT_loc:
 4265    F8:2300             			ds	3
 4266    F8:2303             	__check_OBJECT_end:
 4267               E309     		.code
 4268                        		.pceas
 4269                        	
 4270                        		.dbg	line,	"include\routines_LEVELS.c", 367; // CHECK COLLISION WITH NPCS //
 4271                        		.dbg	line,	"include\routines_LEVELS.c", 368; void check_NPC()
 4272                        		.dbg	line,	"include\routines_LEVELS.c", 369; {
 4273                        	;***********************
 4274                        	;***********************
 4275                        	
 4276                        		.hucc
 4277    11:C5B9             		.proc		_check_NPC
 4278                        		__enter		_check_NPC
 4279                        	
 4280                        		.dbg	line,	"include\routines_LEVELS.c", 370; if(onscreen_npc_number != 0)
 4281                        		__tst.um	_onscreen_npc_number
         11:C5B9  AD AC 23   			lda	_onscreen_npc_number
         11:C5BC  C9 01      			cmp	#1
 4282                        		__bfalse	.LL76
         11:C5BE  B0 03 4C F4			bcc	.LL76
         11:C5C2  C6          
 4283                        	
 4284                        		.dbg	line,	"include\routines_LEVELS.c", 371; {
 4285                        	
 4286                        		.dbg	line,	"include\routines_LEVELS.c", 372; if(player_state == STATE_IDLE || player_state == STATE_WALK)
 4287                        		__not.um	_player_state
         11:C5C3  AD 15 23   			lda	_player_state
         11:C5C6  18         			clc
         11:C5C7  D0 01      			bne	!+
         11:C5C9  38         			sec
         11:C5CA             	!:
 4288                        		__btrue		.LL78
         11:C5CA  B0 08      			bcs	.LL78
 4289                        		__ld.umq	_player_state
         11:C5CC  AD 15 23   			lda	_player_state
 4290                        		__equ_b.uiq	1
         11:C5CF  C9 01      			cmp	#1
         11:C5D1  F0 01      			beq	!+
         11:C5D3  18         			clc
         11:C5D4             	!:
 4291    11:C5D4             	.LL78:
 4292                        		__bfalse	.LL77
         11:C5D4  B0 03 4C F4			bcc	.LL77
         11:C5D8  C6          
 4293                        	
 4294                        		.dbg	line,	"include\routines_LEVELS.c", 373; {
 4295                        	
 4296                        		.dbg	line,	"include\routines_LEVELS.c", 374; char i;
 4297                        	
 4298                        		.dbg	line,	"include\routines_LEVELS.c", 375; char current_npc_id;
 4299                        	
 4300                        		.dbg	line,	"include\routines_LEVELS.c", 376; char current_npc_type;
 4301                        	
 4302                        		.dbg	line,	"include\routines_LEVELS.c", 378; for(i=0 ; i<onscreen_npc_number ; i++)
 4303                        		__st.umiq	0, __check_NPC_end - 1  /* i */
         11:C5D9  9C 44 26   			stz	__check_NPC_end - 1
 4304    11:C5DC             	.LL79:
 4305                        		__ld.umq	__check_NPC_end - 1  /* i */
         11:C5DC  AD 44 26   			lda	__check_NPC_end - 1
 4306                        		__ult_b.umq	_onscreen_npc_number
         11:C5DF  CD AC 23   			cmp	_onscreen_npc_number		; Subtract memory from A.
         11:C5E2  6A         			ror	a		; CC if A < memory.
         11:C5E3  49 80      			eor	#$80
         11:C5E5  2A         			rol	a
 4307                        		__btrue		.LL81
         11:C5E6  B0 08      			bcs	.LL81
 4308                        		__bra		.LL82
         11:C5E8  4C F4 C6   			bra	.LL82
 4309    11:C5EB             	.LL80:
 4310                        		__inc.umq	__check_NPC_end - 1  /* i */
         11:C5EB  EE 44 26   			inc	__check_NPC_end - 1
 4311                        		__bra		.LL79
         11:C5EE  80 EC      			bra	.LL79
 4312    11:C5F0             	.LL81:
 4313                        	
 4314                        		.dbg	line,	"include\routines_LEVELS.c", 379; {
 4315                        	
 4316                        		.dbg	line,	"include\routines_LEVELS.c", 380; // RETRIEVE NPC INDEX IN THE LIST //
 4317                        	
 4318                        		.dbg	line,	"include\routines_LEVELS.c", 381; current_npc_id = list_onscreen_npc[i];
 4319                        		__ldx.umq	__check_NPC_end - 1  /* i */
         11:C5F0  AE 44 26   			ldx	__check_NPC_end - 1
 4320                        		__ld.uax	_list_onscreen_npc
         11:C5F3  BD BF 23   			lda	_list_onscreen_npc, x
         11:C5F6  C2         			cly
 4321                        		__st.umq	__check_NPC_end - 2  /* current_npc_id */
         11:C5F7  8D 43 26   			sta	__check_NPC_end - 2
 4322                        	
 4323                        		.dbg	line,	"include\routines_LEVELS.c", 383; if(list_npc_state[current_npc_id] == STATE_ACTIVE)
 4324                        		__ldx.umq	__check_NPC_end - 2  /* current_npc_id */
         11:C5FA  AE 43 26   			ldx	__check_NPC_end - 2
 4325                        		__not.uax	_list_npc_state
         11:C5FD  BD B6 23   			lda	_list_npc_state, x
         11:C600  18         			clc
         11:C601  D0 01      			bne	!+
         11:C603  38         			sec
         11:C604             	!:
 4326                        		__bfalse	.LL83
         11:C604  90 E5      			bcc	.LL83
 4327                        	
 4328                        		.dbg	line,	"include\routines_LEVELS.c", 384; {
 4329                        	
 4330                        		.dbg	line,	"include\routines_LEVELS.c", 385; // RETRIEVE NPC TYPE //
 4331                        	
 4332                        		.dbg	line,	"include\routines_LEVELS.c", 386; current_npc_type = list_npc_type[current_npc_id];
 4333                        		__ldx.umq	__check_NPC_end - 2  /* current_npc_id */
         11:C606  AE 43 26   			ldx	__check_NPC_end - 2
 4334                        		__ld.uax	_list_npc_type
         11:C609  BD AD 23   			lda	_list_npc_type, x
         11:C60C  C2         			cly
 4335                        		__st.umq	__check_NPC_end - 3  /* current_npc_type */
         11:C60D  8D 42 26   			sta	__check_NPC_end - 3
 4336                        	
 4337                        		.dbg	line,	"include\routines_LEVELS.c", 388; if(abs( (player_pos_x + 16) - (list_npc_x_pos[current_npc_id] + 16) ) < OBJECT_MARGIN)
 4338                        		__ld.wm		_player_pos_x
         11:C610  AD CD 24   			lda.l	_player_pos_x
         11:C613  AC CE 24   			ldy.h	_player_pos_x
 4339                        		__add.wi	16
         11:C616  18         			clc
         11:C617  69 10      			adc.l	#16
         11:C619  90 01      			bcc	!+
         11:C61B  C8         			iny
         11:C61C             	!:
 4340                        		__push.wr
         11:C61C  5A         			phy
         11:C61D  48         			pha
 4341                        		__ld2x.umq	__check_NPC_end - 2  /* current_npc_id */
         11:C61E  AD 43 26   			lda	__check_NPC_end - 2
         11:C621  0A         			asl	a
         11:C622  AA         			tax
 4342                        		__ld.wax	_list_npc_x_pos
         11:C623  BD DF 25   			lda.l	_list_npc_x_pos, x
         11:C626  BC E0 25   			ldy.h	_list_npc_x_pos, x
 4343                        		__add.wi	16
         11:C629  18         			clc
         11:C62A  69 10      			adc.l	#16
         11:C62C  90 01      			bcc	!+
         11:C62E  C8         			iny
         11:C62F             	!:
 4344                        		__sub.wt
         11:C62F  BA         			tsx
         11:C630  38         			sec
         11:C631  49 FF      			eor	#$FF
         11:C633  7D 01 21   			adc.l	__tos, x
         11:C636  42         			say
         11:C637  49 FF      			eor	#$FF
         11:C639  7D 02 21   			adc.h	__tos, x
         11:C63C  42         			say
         11:C63D  E8         			inx
         11:C63E  E8         			inx
         11:C63F  9A         			txs
 4345                        		__call		_abs.1
         11:C640  20 09 E5   			call	_abs.1
 4346                        		__slt_w.wi	10
         11:C643  C9 0A      			cmp.l	#10		; Subtract integer from Y:A.
         11:C645  98         			tya
         11:C646  E9 00      			sbc.h	#10
         11:C648  50 02      			bvc	!+
         11:C64A  49 80      			eor	#$80		; -ve if Y:A < integer (signed).
         11:C64C  0A         	!:		asl	a
 4347                        		__bfalse	.LL84
         11:C64D  90 9C      			bcc	.LL84
 4348                        	
 4349                        		.dbg	line,	"include\routines_LEVELS.c", 389; {
 4350                        	
 4351                        		.dbg	line,	"include\routines_LEVELS.c", 390; if(abs( (player_pos_y + 16) - (list_npc_y_pos[current_npc_id] + 16) ) < OBJECT_MARGIN)
 4352                        		__ld.wm		_player_pos_y
         11:C64F  AD CF 24   			lda.l	_player_pos_y
         11:C652  AC D0 24   			ldy.h	_player_pos_y
 4353                        		__add.wi	16
         11:C655  18         			clc
         11:C656  69 10      			adc.l	#16
         11:C658  90 01      			bcc	!+
         11:C65A  C8         			iny
         11:C65B             	!:
 4354                        		__push.wr
         11:C65B  5A         			phy
         11:C65C  48         			pha
 4355                        		__ld2x.umq	__check_NPC_end - 2  /* current_npc_id */
         11:C65D  AD 43 26   			lda	__check_NPC_end - 2
         11:C660  0A         			asl	a
         11:C661  AA         			tax
 4356                        		__ld.wax	_list_npc_y_pos
         11:C662  BD F1 25   			lda.l	_list_npc_y_pos, x
         11:C665  BC F2 25   			ldy.h	_list_npc_y_pos, x
 4357                        		__add.wi	16
         11:C668  18         			clc
         11:C669  69 10      			adc.l	#16
         11:C66B  90 01      			bcc	!+
         11:C66D  C8         			iny
         11:C66E             	!:
 4358                        		__sub.wt
         11:C66E  BA         			tsx
         11:C66F  38         			sec
         11:C670  49 FF      			eor	#$FF
         11:C672  7D 01 21   			adc.l	__tos, x
         11:C675  42         			say
         11:C676  49 FF      			eor	#$FF
         11:C678  7D 02 21   			adc.h	__tos, x
         11:C67B  42         			say
         11:C67C  E8         			inx
         11:C67D  E8         			inx
         11:C67E  9A         			txs
 4359                        		__call		_abs.1
         11:C67F  20 09 E5   			call	_abs.1
 4360                        		__slt_w.wi	10
         11:C682  C9 0A      			cmp.l	#10		; Subtract integer from Y:A.
         11:C684  98         			tya
         11:C685  E9 00      			sbc.h	#10
         11:C687  50 02      			bvc	!+
         11:C689  49 80      			eor	#$80		; -ve if Y:A < integer (signed).
         11:C68B  0A         	!:		asl	a
 4361                        		__bfalse	.LL85
         11:C68C  B0 03 4C EB			bcc	.LL85
         11:C690  C5          
 4362                        	
 4363                        		.dbg	line,	"include\routines_LEVELS.c", 391; {               
 4364                        	
 4365                        		.dbg	line,	"include\routines_LEVELS.c", 392; switch(current_npc_type)
 4366                        		__ld.umq	__check_NPC_end - 3  /* current_npc_type */
         11:C691  AD 42 26   			lda	__check_NPC_end - 3
 4367                        		__bra		.LL86
         11:C694  80 4A      			bra	.LL86
 4368                        	
 4369                        		.dbg	line,	"include\routines_LEVELS.c", 393; {
 4370                        	
 4371                        		.dbg	line,	"include\routines_LEVELS.c", 394; case TYPE_NPC_REWARD:
 4372    11:C696             	.LL88:
 4373                        		__case		0
 4374                        	
 4375                        		.dbg	line,	"include\routines_LEVELS.c", 395; //
 4376                        	
 4377                        		.dbg	line,	"include\routines_LEVELS.c", 396; break;
 4378                        		__bra		.LL87
         11:C696  4C EB C5   			bra	.LL87
 4379                        	
 4380                        		.dbg	line,	"include\routines_LEVELS.c", 398; case TYPE_NPC_SHOP:
 4381    11:C699             	.LL89:
 4382                        		__case		1
 4383                        	
 4384                        		.dbg	line,	"include\routines_LEVELS.c", 399; disp_off();
 4385                        		__call		_disp_off
         11:C699  20 29 E4   			call	_disp_off
 4386                        	
 4387                        		.dbg	line,	"include\routines_LEVELS.c", 400; minutes_backup = minutes;
 4388                        		__ld.um		_minutes
         11:C69C  AD 23 23   			lda	_minutes
         11:C69F  C2         			cly
 4389                        		__st.umq	_minutes_backup
         11:C6A0  8D 26 23   			sta	_minutes_backup
 4390                        	
 4391                        		.dbg	line,	"include\routines_LEVELS.c", 401; seconds_backup = seconds;
 4392                        		__ld.um		_seconds
         11:C6A3  AD 24 23   			lda	_seconds
         11:C6A6  C2         			cly
 4393                        		__st.umq	_seconds_backup
         11:C6A7  8D 27 23   			sta	_seconds_backup
 4394                        	
 4395                        		.dbg	line,	"include\routines_LEVELS.c", 402; list_npc_state[current_npc_id] = STATE_INACTIVE;
 4396                        		__ldx.umq	__check_NPC_end - 2  /* current_npc_id */
         11:C6AA  AE 43 26   			ldx	__check_NPC_end - 2
 4397                        		__st.uaxiq	1, _list_npc_state
         11:C6AD  A9 01      			lda.l	#1
         11:C6AF  9D B6 23   			sta	_list_npc_state, x
 4398                        	
 4399                        		.dbg	line,	"include\routines_LEVELS.c", 403; camera_pos_x_backup = sgx_map_pxl_x;
 4400                        		__ld.wm		_sgx_map_pxl_x
         11:C6B2  AD 89 26   			lda.l	_sgx_map_pxl_x
         11:C6B5  AC 8A 26   			ldy.h	_sgx_map_pxl_x
 4401                        		__st.wmq	_camera_pos_x_backup
         11:C6B8  8D D3 24   			sta.l	_camera_pos_x_backup
         11:C6BB  8C D4 24   			sty.h	_camera_pos_x_backup
 4402                        	
 4403                        		.dbg	line,	"include\routines_LEVELS.c", 404; camera_pos_y_backup = list_npc_y_pos_ref[current_npc_id] - 128;                                    
 4404                        		__ld2x.umq	__check_NPC_end - 2  /* current_npc_id */
         11:C6BE  AD 43 26   			lda	__check_NPC_end - 2
         11:C6C1  0A         			asl	a
         11:C6C2  AA         			tax
 4405                        		__ld.wax	_list_npc_y_pos_ref
         11:C6C3  BD 15 26   			lda.l	_list_npc_y_pos_ref, x
         11:C6C6  BC 16 26   			ldy.h	_list_npc_y_pos_ref, x
 4406                        		__sub.wi	128
         11:C6C9  38         			sec
         11:C6CA  E9 80      			sbc.l	#128
         11:C6CC  B0 01      			bcs	!+
         11:C6CE  88         			dey
         11:C6CF             	!:
 4407                        		__st.wmq	_camera_pos_y_backup
         11:C6CF  8D D5 24   			sta.l	_camera_pos_y_backup
         11:C6D2  8C D6 24   			sty.h	_camera_pos_y_backup
 4408                        	
 4409                        		.dbg	line,	"include\routines_LEVELS.c", 405; sequence_loaded = FALSE;
 4410                        		__st.umiq	0, _sequence_loaded
         11:C6D5  9C 11 23   			stz	_sequence_loaded
 4411                        	
 4412                        		.dbg	line,	"include\routines_LEVELS.c", 406; sequence_id = SEQUENCE_SHOP;
 4413                        		__st.umiq	4, _sequence_id
         11:C6D8  A9 04      			lda.l	#4
         11:C6DA  8D 10 23   			sta	_sequence_id
 4414                        	
 4415                        		.dbg	line,	"include\routines_LEVELS.c", 407; break;
 4416                        		__bra		.LL87
         11:C6DD  4C EB C5   			bra	.LL87
 4417                        	
 4418                        		.dbg	line,	"include\routines_LEVELS.c", 408; }
 4419    11:C6E0             	.LL86:
 4420                        		__switch_r.ur	0, 1
         11:C6E0  C9 02      			cmp	#(1 - 0) + 1
         11:C6E2  90 02      			bcc	!found+
         11:C6E4  A9 02      	!default:	lda	#(1 - 0) + 1
         11:C6E6  0A         	!found:		asl	a
         11:C6E7  AA         			tax
         11:C6E8  7C EB C6   			jmp	[!table+, x]
 4421                        	
 4422    11:C6EB  96 C6      	!table:		dw	.LL88, .LL89
         11:C6ED  99 C6       
 4423    11:C6EF  EB C5      			dw	.LL87
 4424    11:C6F1             	.LL87	.alias		.LL80
 4425                        	
 4426                        		.dbg	line,	"include\routines_LEVELS.c", 409; }
 4427                        	
 4428                        		.dbg	line,	"include\routines_LEVELS.c", 410; }
 4429    11:C6F1             	.LL85	.alias		.LL80
 4430                        	
 4431                        		.dbg	line,	"include\routines_LEVELS.c", 411; }
 4432    11:C6F1             	.LL84	.alias		.LL80
 4433                        	
 4434                        		.dbg	line,	"include\routines_LEVELS.c", 412; }
 4435    11:C6F1             	.LL83	.alias		.LL80
 4436                        		__bra		.LL80
         11:C6F1  4C EB C5   			bra	.LL80
 4437    11:C6F4             	.LL82:
 4438                        	
 4439                        		.dbg	line,	"include\routines_LEVELS.c", 413; }
 4440                        	
 4441                        		.dbg	line,	"include\routines_LEVELS.c", 414; }
 4442    11:C6F4             	.LL77:
 4443                        	
 4444                        		.dbg	line,	"include\routines_LEVELS.c", 415; }
 4445    11:C6F4             	.LL76:
 4446    11:C6F4             	.LL75:
 4447                        		__return	0
         11:C6F4  4C EF FF   			jmp	leave_proc
 4448                        		.dbg	clear
 4449                        		.endp
 4450                        		.pceas
 4451                        	
 4452                        		.dbg	line,	"include\routines_LEVELS.c", 421; void scroll_BG()
 4453                        		.dbg	line,	"include\routines_LEVELS.c", 422; {
 4454                        	;***********************
 4455                        	;***********************
 4456                        	
 4457                        		.hucc
 4458    11:D345             		.proc		_scroll_BG
 4459                        		__enter		_scroll_BG
 4460                        	
 4461                        		.dbg	line,	"include\routines_LEVELS.c", 423; // UPDATE VDC2 BG //
 4462                        	
 4463                        		.dbg	line,	"include\routines_LEVELS.c", 424; sgx_scroll_map();
 4464                        		__call		_sgx_scroll_map
         11:D345  20 81 FF   			call	_sgx_scroll_map
 4465                        	
 4466                        		.dbg	line,	"include\routines_LEVELS.c", 426; //--------------------------------------------------------------------------------------//
 4467                        	
 4468                        		.dbg	line,	"include\routines_LEVELS.c", 427; //                                        VDC 2                                         //
 4469                        	
 4470                        		.dbg	line,	"include\routines_LEVELS.c", 428; //--------------------------------------------------------------------------------------//
 4471                        	
 4472                        		.dbg	line,	"include\routines_LEVELS.c", 430; sgx_scroll_split(0,   0, sgx_map_pxl_x & (BAT_SIZE_W - 1), sgx_map_pxl_y & (BAT_SIZE_H - 1), BKG_ON | SPR_ON);
 4473                        		__st.umiq	0, _al
         11:D348  64 F8      			stz	_al
 4474                        		__st.umiq	0, _ah
         11:D34A  64 F9      			stz	_ah
 4475                        		__ld.wm		_sgx_map_pxl_x
         11:D34C  AD 89 26   			lda.l	_sgx_map_pxl_x
         11:D34F  AC 8A 26   			ldy.h	_sgx_map_pxl_x
 4476                        		__and.wi	2047
         11:D352  29 FF      			and.l	#2047
         11:D354  42         			say
         11:D355  29 07      			and.h	#2047
         11:D357  42         			say
 4477                        		__st.wmq	_bx
         11:D358  85 FA      			sta.l	_bx
         11:D35A  84 FB      			sty.h	_bx
 4478                        		__ld.wm		_sgx_map_pxl_y
         11:D35C  AD 8B 26   			lda.l	_sgx_map_pxl_y
         11:D35F  AC 8C 26   			ldy.h	_sgx_map_pxl_y
 4479                        		__and.wi	255
         11:D362  29 FF      			and	#255
         11:D364  C2         			cly
 4480                        		__st.wmq	_cx
         11:D365  85 FC      			sta.l	_cx
         11:D367  84 FD      			sty.h	_cx
 4481                        		__st.umiq	192, _dl
         11:D369  A9 C0      			lda.l	#192
         11:D36B  85 FE      			sta	_dl
 4482                        		__call		_sgx_scroll_split.5
         11:D36D  20 77 FF   			call	_sgx_scroll_split.5
 4483                        	
 4484                        		.dbg	line,	"include\routines_LEVELS.c", 431; }
 4485    11:D370             	.LL90:
 4486                        		__return	0
         11:D370  4C EF FF   			jmp	leave_proc
 4487                        		.dbg	clear
 4488                        		.endp
 4489                        		.pceas
 4490                        	
 4491                        		.dbg	line,	"include\routines_LEVELS.c", 434; void recenter_CAMERA()
 4492                        		.dbg	line,	"include\routines_LEVELS.c", 435; {
 4493                        	;***********************
 4494                        	;***********************
 4495                        	
 4496                        		.hucc
 4497    11:C93C             		.proc		_recenter_CAMERA
 4498                        		__enter		_recenter_CAMERA
 4499                        	
 4500                        		.dbg	line,	"include\routines_LEVELS.c", 436; signed char camera_y_move;
 4501                        	
 4502                        		.dbg	line,	"include\routines_LEVELS.c", 438; spr_set(player_id);
 4503                        		__ld.umq	_player_id
         11:C93C  AD 14 23   			lda	_player_id
 4504                        		__call		_spr_set.1
         11:C93F  20 DD E7   			call	_spr_set.1
 4505                        	
 4506                        		.dbg	line,	"include\routines_LEVELS.c", 441; if(player_pos_y < 128)
 4507                        		__ld.wm		_player_pos_y
         11:C942  AD CF 24   			lda.l	_player_pos_y
         11:C945  AC D0 24   			ldy.h	_player_pos_y
 4508                        		__slt_w.wi	128
         11:C948  C9 80      			cmp.l	#128		; Subtract integer from Y:A.
         11:C94A  98         			tya
         11:C94B  E9 00      			sbc.h	#128
         11:C94D  50 02      			bvc	!+
         11:C94F  49 80      			eor	#$80		; -ve if Y:A < integer (signed).
         11:C951  0A         	!:		asl	a
 4509                        		__bfalse	.LL92
         11:C952  90 70      			bcc	.LL92
 4510                        	
 4511                        		.dbg	line,	"include\routines_LEVELS.c", 442; {
 4512                        	
 4513                        		.dbg	line,	"include\routines_LEVELS.c", 443; player_pos_y += CAMERA_RECENTER_VELOCITY;
 4514                        		__add_st.wmiq	4, _player_pos_y
         11:C954  18         			clc
         11:C955  AD CF 24   			lda.l	_player_pos_y
         11:C958  69 04      			adc.l	#4
         11:C95A  8D CF 24   			sta.l	_player_pos_y
         11:C95D  90 03      			bcc	!+
         11:C95F  EE D0 24   			inc.h	_player_pos_y
         11:C962             	!:
 4515                        	
 4516                        		.dbg	line,	"include\routines_LEVELS.c", 445; if(player_pos_y > 128)
 4517                        		__ld.wm		_player_pos_y
         11:C962  AD CF 24   			lda.l	_player_pos_y
         11:C965  AC D0 24   			ldy.h	_player_pos_y
 4518                        		__sgt_w.wi	128
         11:C968  18         			clc			; Subtract integer+1 from Y:A.
         11:C969  E9 80      			sbc.l	#128
         11:C96B  98         			tya
         11:C96C  E9 00      			sbc.h	#128
         11:C96E  50 02      			bvc	!+
         11:C970  49 80      			eor	#$80		; +ve if Y:A > integer (signed).
         11:C972  49 80      	!:		eor	#$80
         11:C974  0A         			asl	a
 4519                        		__bfalse	.LL93
         11:C975  90 24      			bcc	.LL93
 4520                        	
 4521                        		.dbg	line,	"include\routines_LEVELS.c", 446; {
 4522                        	
 4523                        		.dbg	line,	"include\routines_LEVELS.c", 447; camera_y_move = CAMERA_RECENTER_VELOCITY - (player_pos_y - 128);
 4524                        		__ld.wm		_player_pos_y
         11:C977  AD CF 24   			lda.l	_player_pos_y
         11:C97A  AC D0 24   			ldy.h	_player_pos_y
 4525                        		__sub.wi	128
         11:C97D  38         			sec
         11:C97E  E9 80      			sbc.l	#128
         11:C980  B0 01      			bcs	!+
         11:C982  88         			dey
         11:C983             	!:
 4526                        		__isub.wi	4
         11:C983  38         			sec
         11:C984  49 FF      			eor	#$FF
         11:C986  69 04      			adc.l	#4
         11:C988  42         			say
         11:C989  49 FF      			eor	#$FF
         11:C98B  69 00      			adc.h	#4
         11:C98D  42         			say
 4527                        		__st.umq	__recenter_CAMERA_end - 1  /* camera_y_move */
         11:C98E  8D 44 26   			sta	__recenter_CAMERA_end - 1
 4528                        	
 4529                        		.dbg	line,	"include\routines_LEVELS.c", 449; player_pos_y = 128;
 4530                        		__st.wmiq	128, _player_pos_y
         11:C991  A9 80      			lda.l	#128
         11:C993  8D CF 24   			sta.l	_player_pos_y
         11:C996  9C D0 24   			stz.h	_player_pos_y
 4531                        	
 4532                        		.dbg	line,	"include\routines_LEVELS.c", 450; }
 4533                        	
 4534                        		.dbg	line,	"include\routines_LEVELS.c", 452; else
 4535                        		__bra		.LL94
         11:C999  80 05      			bra	.LL94
 4536    11:C99B             	.LL93:
 4537                        	
 4538                        		.dbg	line,	"include\routines_LEVELS.c", 453; {
 4539                        	
 4540                        		.dbg	line,	"include\routines_LEVELS.c", 454; camera_y_move = CAMERA_RECENTER_VELOCITY;
 4541                        		__st.umiq	4, __recenter_CAMERA_end - 1  /* camera_y_move */
         11:C99B  A9 04      			lda.l	#4
         11:C99D  8D 44 26   			sta	__recenter_CAMERA_end - 1
 4542                        	
 4543                        		.dbg	line,	"include\routines_LEVELS.c", 455; }
 4544    11:C9A0             	.LL94:
 4545                        	
 4546                        		.dbg	line,	"include\routines_LEVELS.c", 457; spr_y(player_pos_y);
 4547                        		__ld.wm		_player_pos_y
         11:C9A0  AD CF 24   			lda.l	_player_pos_y
         11:C9A3  AC D0 24   			ldy.h	_player_pos_y
 4548                        		__call		_spr_y.1
         11:C9A6  20 19 E8   			call	_spr_y.1
 4549                        	
 4550                        		.dbg	line,	"include\routines_LEVELS.c", 459; sgx_map_pxl_y -= camera_y_move;
 4551                        		__ld.bm		__recenter_CAMERA_end - 1  /* camera_y_move */
         11:C9A9  AD 44 26   			lda	__recenter_CAMERA_end - 1
         11:C9AC  C2         			cly
         11:C9AD  10 01      			bpl	!+
         11:C9AF  88         			dey
         11:C9B0             	!:
 4552                        		__isub_st.wmq	_sgx_map_pxl_y
         11:C9B0  38         			sec
         11:C9B1  49 FF      			eor	#$FF
         11:C9B3  6D 8B 26   			adc.l	_sgx_map_pxl_y
         11:C9B6  8D 8B 26   			sta.l	_sgx_map_pxl_y
         11:C9B9  98         			tya
         11:C9BA  49 FF      			eor	#$FF
         11:C9BC  6D 8C 26   			adc.h	_sgx_map_pxl_y
         11:C9BF  8D 8C 26   			sta.h	_sgx_map_pxl_y
 4553                        	
 4554                        		.dbg	line,	"include\routines_LEVELS.c", 460; }
 4555                        	
 4556                        		.dbg	line,	"include\routines_LEVELS.c", 463; else if(player_pos_y > 128)
 4557                        		__bra		.LL95
         11:C9C2  80 7C      			bra	.LL95
 4558    11:C9C4             	.LL92:
 4559                        		__ld.wm		_player_pos_y
         11:C9C4  AD CF 24   			lda.l	_player_pos_y
         11:C9C7  AC D0 24   			ldy.h	_player_pos_y
 4560                        		__sgt_w.wi	128
         11:C9CA  18         			clc			; Subtract integer+1 from Y:A.
         11:C9CB  E9 80      			sbc.l	#128
         11:C9CD  98         			tya
         11:C9CE  E9 00      			sbc.h	#128
         11:C9D0  50 02      			bvc	!+
         11:C9D2  49 80      			eor	#$80		; +ve if Y:A > integer (signed).
         11:C9D4  49 80      	!:		eor	#$80
         11:C9D6  0A         			asl	a
 4561                        		__bfalse	.LL96
         11:C9D7  90 67      			bcc	.LL96
 4562                        	
 4563                        		.dbg	line,	"include\routines_LEVELS.c", 464; {
 4564                        	
 4565                        		.dbg	line,	"include\routines_LEVELS.c", 465; player_pos_y -= CAMERA_RECENTER_VELOCITY;
 4566                        		__sub_st.wmiq	4, _player_pos_y
         11:C9D9  38         			sec
         11:C9DA  AD CF 24   			lda.l	_player_pos_y
         11:C9DD  E9 04      			sbc.l	#4
         11:C9DF  8D CF 24   			sta.l	_player_pos_y
         11:C9E2  B0 03      			bcs	!+
         11:C9E4  CE D0 24   			dec.h	_player_pos_y
         11:C9E7             	!:
 4567                        	
 4568                        		.dbg	line,	"include\routines_LEVELS.c", 467; if(player_pos_y < 128)
 4569                        		__ld.wm		_player_pos_y
         11:C9E7  AD CF 24   			lda.l	_player_pos_y
         11:C9EA  AC D0 24   			ldy.h	_player_pos_y
 4570                        		__slt_w.wi	128
         11:C9ED  C9 80      			cmp.l	#128		; Subtract integer from Y:A.
         11:C9EF  98         			tya
         11:C9F0  E9 00      			sbc.h	#128
         11:C9F2  50 02      			bvc	!+
         11:C9F4  49 80      			eor	#$80		; -ve if Y:A < integer (signed).
         11:C9F6  0A         	!:		asl	a
 4571                        		__bfalse	.LL97
         11:C9F7  90 24      			bcc	.LL97
 4572                        	
 4573                        		.dbg	line,	"include\routines_LEVELS.c", 468; {
 4574                        	
 4575                        		.dbg	line,	"include\routines_LEVELS.c", 469; camera_y_move = CAMERA_RECENTER_VELOCITY - (128 - player_pos_y);
 4576                        		__ld.wi		128
         11:C9F9  A9 80      			lda.l	#128
         11:C9FB  C2         			cly
 4577                        		__sub.wm	_player_pos_y
         11:C9FC  38         			sec
         11:C9FD  ED CF 24   			sbc.l	_player_pos_y
         11:CA00  42         			say
         11:CA01  ED D0 24   			sbc.h	_player_pos_y
         11:CA04  42         			say
 4578                        		__isub.wi	4
         11:CA05  38         			sec
         11:CA06  49 FF      			eor	#$FF
         11:CA08  69 04      			adc.l	#4
         11:CA0A  42         			say
         11:CA0B  49 FF      			eor	#$FF
         11:CA0D  69 00      			adc.h	#4
         11:CA0F  42         			say
 4579                        		__st.umq	__recenter_CAMERA_end - 1  /* camera_y_move */
         11:CA10  8D 44 26   			sta	__recenter_CAMERA_end - 1
 4580                        	
 4581                        		.dbg	line,	"include\routines_LEVELS.c", 471; player_pos_y = 128;
 4582                        		__st.wmiq	128, _player_pos_y
         11:CA13  A9 80      			lda.l	#128
         11:CA15  8D CF 24   			sta.l	_player_pos_y
         11:CA18  9C D0 24   			stz.h	_player_pos_y
 4583                        	
 4584                        		.dbg	line,	"include\routines_LEVELS.c", 472; }
 4585                        	
 4586                        		.dbg	line,	"include\routines_LEVELS.c", 474; else
 4587                        		__bra		.LL98
         11:CA1B  80 05      			bra	.LL98
 4588    11:CA1D             	.LL97:
 4589                        	
 4590                        		.dbg	line,	"include\routines_LEVELS.c", 475; {
 4591                        	
 4592                        		.dbg	line,	"include\routines_LEVELS.c", 476; camera_y_move = CAMERA_RECENTER_VELOCITY;
 4593                        		__st.umiq	4, __recenter_CAMERA_end - 1  /* camera_y_move */
         11:CA1D  A9 04      			lda.l	#4
         11:CA1F  8D 44 26   			sta	__recenter_CAMERA_end - 1
 4594                        	
 4595                        		.dbg	line,	"include\routines_LEVELS.c", 477; }
 4596    11:CA22             	.LL98:
 4597                        	
 4598                        		.dbg	line,	"include\routines_LEVELS.c", 479; spr_y(player_pos_y);
 4599                        		__ld.wm		_player_pos_y
         11:CA22  AD CF 24   			lda.l	_player_pos_y
         11:CA25  AC D0 24   			ldy.h	_player_pos_y
 4600                        		__call		_spr_y.1
         11:CA28  20 19 E8   			call	_spr_y.1
 4601                        	
 4602                        		.dbg	line,	"include\routines_LEVELS.c", 481; sgx_map_pxl_y += camera_y_move;
 4603                        		__ld.bm		__recenter_CAMERA_end - 1  /* camera_y_move */
         11:CA2B  AD 44 26   			lda	__recenter_CAMERA_end - 1
         11:CA2E  C2         			cly
         11:CA2F  10 01      			bpl	!+
         11:CA31  88         			dey
         11:CA32             	!:
 4604                        		__add_st.wmq	_sgx_map_pxl_y
         11:CA32  18         			clc
         11:CA33  6D 8B 26   			adc.l	_sgx_map_pxl_y
         11:CA36  8D 8B 26   			sta.l	_sgx_map_pxl_y
         11:CA39  98         			tya
         11:CA3A  6D 8C 26   			adc.h	_sgx_map_pxl_y
         11:CA3D  8D 8C 26   			sta.h	_sgx_map_pxl_y
 4605                        	
 4606                        		.dbg	line,	"include\routines_LEVELS.c", 482; }
 4607                        	
 4608                        		.dbg	line,	"include\routines_LEVELS.c", 483; }
 4609    11:CA40             	.LL96:
 4610    11:CA40             	.LL95:
 4611    11:CA40             	.LL91:
 4612                        		__return	0
         11:CA40  4C EF FF   			jmp	leave_proc
 4613                        		.dbg	clear
 4614                        		.endp
 4615                        		.pceas
 4616                        	
 4617                        		.dbg	line,	"include\routines_LEVELS.c", 492; void joypad_BUTTONS()
 4618                        		.dbg	line,	"include\routines_LEVELS.c", 493; {
 4619                        	;***********************
 4620                        	;***********************
 4621                        	
 4622                        		.hucc
 4623    11:CA43             		.proc		_joypad_BUTTONS
 4624                        		__enter		_joypad_BUTTONS
 4625                        	
 4626                        		.dbg	line,	"include\routines_LEVELS.c", 494; if(joytrg(JOYPAD_1) == JOY_I)
 4627                        		__ld.uiq	0
         11:CA43  62         			cla
 4628                        		 _joytrg.1
         11:CA44  AA         			tax
         11:CA45  BD 2D 22   			lda	joytrg, x
         11:CA48  BC DD 22   			ldy	joy6trg, x
 4629                        		__equ_w.wi	1
         11:CA4B  C9 01      			cmp.l	#1
         11:CA4D  D0 04      			bne	!false+
         11:CA4F  C0 00      			cpy.h	#1
         11:CA51  F0 01      			beq	!+
         11:CA53  18         	!false:		clc
         11:CA54             	!:
 4630                        		__bfalse	.LL100
         11:CA54  B0 03 4C 14			bcc	.LL100
         11:CA58  CB          
 4631                        	
 4632                        		.dbg	line,	"include\routines_LEVELS.c", 495; {
 4633                        	
 4634                        		.dbg	line,	"include\routines_LEVELS.c", 496; if(player_state == STATE_IDLE)
 4635                        		__not.um	_player_state
         11:CA59  AD 15 23   			lda	_player_state
         11:CA5C  18         			clc
         11:CA5D  D0 01      			bne	!+
         11:CA5F  38         			sec
         11:CA60             	!:
 4636                        		__bfalse	.LL101
         11:CA60  90 0B      			bcc	.LL101
 4637                        	
 4638                        		.dbg	line,	"include\routines_LEVELS.c", 497; {
 4639                        	
 4640                        		.dbg	line,	"include\routines_LEVELS.c", 498; player_counter_anim = 0;
 4641                        		__st.umiq	0, _player_counter_anim
         11:CA62  9C 18 23   			stz	_player_counter_anim
 4642                        	
 4643                        		.dbg	line,	"include\routines_LEVELS.c", 500; player_state = STATE_JUMP;
 4644                        		__st.umiq	4, _player_state
         11:CA65  A9 04      			lda.l	#4
         11:CA67  8D 15 23   			sta	_player_state
 4645                        	
 4646                        		.dbg	line,	"include\routines_LEVELS.c", 501; }
 4647                        	
 4648                        		.dbg	line,	"include\routines_LEVELS.c", 504; else if(player_state == STATE_WALK)
 4649                        		__bra		.LL102
         11:CA6A  4C 14 CB   			bra	.LL102
 4650    11:CA6D             	.LL101:
 4651                        		__ld.umq	_player_state
         11:CA6D  AD 15 23   			lda	_player_state
 4652                        		__equ_b.uiq	1
         11:CA70  C9 01      			cmp	#1
         11:CA72  F0 01      			beq	!+
         11:CA74  18         			clc
         11:CA75             	!:
 4653                        		__bfalse	.LL103
         11:CA75  90 13      			bcc	.LL103
 4654                        	
 4655                        		.dbg	line,	"include\routines_LEVELS.c", 505; {
 4656                        	
 4657                        		.dbg	line,	"include\routines_LEVELS.c", 506; player_counter_anim = 0;
 4658                        		__st.umiq	0, _player_counter_anim
         11:CA77  9C 18 23   			stz	_player_counter_anim
 4659                        	
 4660                        		.dbg	line,	"include\routines_LEVELS.c", 508; player_state = STATE_JUMP_RIGHT + player_axis;
 4661                        		__ld.wi		5
         11:CA7A  A9 05      			lda.l	#5
         11:CA7C  C2         			cly
 4662                        		__add.um	_player_axis
         11:CA7D  18         			clc
         11:CA7E  6D 16 23   			adc	_player_axis
         11:CA81  90 01      			bcc	!+
         11:CA83  C8         			iny
         11:CA84             	!:
 4663                        		__st.umq	_player_state
         11:CA84  8D 15 23   			sta	_player_state
 4664                        	
 4665                        		.dbg	line,	"include\routines_LEVELS.c", 509; }
 4666                        	
 4667                        		.dbg	line,	"include\routines_LEVELS.c", 512; else if(player_state == STATE_HANG || player_state == STATE_CLIMB_UP || player_state == STATE_CLIMB_DOWN)
 4668                        		__bra		.LL104
         11:CA87  4C 14 CB   			bra	.LL104
 4669    11:CA8A             	.LL103:
 4670                        		__ld.umq	_player_state
         11:CA8A  AD 15 23   			lda	_player_state
 4671                        		__equ_b.uiq	10
         11:CA8D  C9 0A      			cmp	#10
         11:CA8F  F0 01      			beq	!+
         11:CA91  18         			clc
         11:CA92             	!:
 4672                        		__btrue		.LL106
         11:CA92  B0 08      			bcs	.LL106
 4673                        		__ld.umq	_player_state
         11:CA94  AD 15 23   			lda	_player_state
 4674                        		__equ_b.uiq	11
         11:CA97  C9 0B      			cmp	#11
         11:CA99  F0 01      			beq	!+
         11:CA9B  18         			clc
         11:CA9C             	!:
 4675    11:CA9C             	.LL106:
 4676                        		__btrue		.LL107
         11:CA9C  B0 08      			bcs	.LL107
 4677                        		__ld.umq	_player_state
         11:CA9E  AD 15 23   			lda	_player_state
 4678                        		__equ_b.uiq	12
         11:CAA1  C9 0C      			cmp	#12
         11:CAA3  F0 01      			beq	!+
         11:CAA5  18         			clc
         11:CAA6             	!:
 4679    11:CAA6             	.LL107:
 4680                        		__bfalse	.LL105
         11:CAA6  90 6C      			bcc	.LL105
 4681                        	
 4682                        		.dbg	line,	"include\routines_LEVELS.c", 513; {
 4683                        	
 4684                        		.dbg	line,	"include\routines_LEVELS.c", 514; if(joy(JOYPAD_1) & JOY_RIGHT)
 4685                        		__ld.uiq	0
         11:CAA8  62         			cla
 4686                        		 _joy.1
         11:CAA9  AA         			tax
         11:CAAA  BD 28 22   			lda	joynow, x
         11:CAAD  BC D3 22   			ldy	joy6now, x
 4687                        		__tand.wi	32
         11:CAB0  29 20      			and	#32
         11:CAB2  C9 01      	!:		cmp	#1
 4688                        		__bfalse	.LL108
         11:CAB4  90 0A      			bcc	.LL108
 4689                        	
 4690                        		.dbg	line,	"include\routines_LEVELS.c", 515; {
 4691                        	
 4692                        		.dbg	line,	"include\routines_LEVELS.c", 516; player_counter_anim = 0;
 4693                        		__st.umiq	0, _player_counter_anim
         11:CAB6  9C 18 23   			stz	_player_counter_anim
 4694                        	
 4695                        		.dbg	line,	"include\routines_LEVELS.c", 518; player_state = STATE_JUMP_RIGHT;
 4696                        		__st.umiq	5, _player_state
         11:CAB9  A9 05      			lda.l	#5
         11:CABB  8D 15 23   			sta	_player_state
 4697                        	
 4698                        		.dbg	line,	"include\routines_LEVELS.c", 519; }
 4699                        	
 4700                        		.dbg	line,	"include\routines_LEVELS.c", 521; else if(joy(JOYPAD_1) & JOY_LEFT)
 4701                        		__bra		.LL109
         11:CABE  80 54      			bra	.LL109
 4702    11:CAC0             	.LL108:
 4703                        		__ld.uiq	0
         11:CAC0  62         			cla
 4704                        		 _joy.1
         11:CAC1  AA         			tax
         11:CAC2  BD 28 22   			lda	joynow, x
         11:CAC5  BC D3 22   			ldy	joy6now, x
 4705                        		__tand.wi	128
         11:CAC8  29 80      			and	#128
         11:CACA  C9 01      	!:		cmp	#1
 4706                        		__bfalse	.LL110
         11:CACC  90 0A      			bcc	.LL110
 4707                        	
 4708                        		.dbg	line,	"include\routines_LEVELS.c", 522; {
 4709                        	
 4710                        		.dbg	line,	"include\routines_LEVELS.c", 523; player_counter_anim = 0;
 4711                        		__st.umiq	0, _player_counter_anim
         11:CACE  9C 18 23   			stz	_player_counter_anim
 4712                        	
 4713                        		.dbg	line,	"include\routines_LEVELS.c", 525; player_state = STATE_JUMP_LEFT;
 4714                        		__st.umiq	6, _player_state
         11:CAD1  A9 06      			lda.l	#6
         11:CAD3  8D 15 23   			sta	_player_state
 4715                        	
 4716                        		.dbg	line,	"include\routines_LEVELS.c", 526; }
 4717                        	
 4718                        		.dbg	line,	"include\routines_LEVELS.c", 528; else if(joy(JOYPAD_1) & JOY_UP)
 4719                        		__bra		.LL111
         11:CAD6  80 3C      			bra	.LL111
 4720    11:CAD8             	.LL110:
 4721                        		__ld.uiq	0
         11:CAD8  62         			cla
 4722                        		 _joy.1
         11:CAD9  AA         			tax
         11:CADA  BD 28 22   			lda	joynow, x
         11:CADD  BC D3 22   			ldy	joy6now, x
 4723                        		__tand.wi	16
         11:CAE0  29 10      			and	#16
         11:CAE2  C9 01      	!:		cmp	#1
 4724                        		__bfalse	.LL112
         11:CAE4  90 2E      			bcc	.LL112
 4725                        	
 4726                        		.dbg	line,	"include\routines_LEVELS.c", 529; {
 4727                        	
 4728                        		.dbg	line,	"include\routines_LEVELS.c", 530; player_counter_anim = 0;
 4729                        		__st.umiq	0, _player_counter_anim
         11:CAE6  9C 18 23   			stz	_player_counter_anim
 4730                        	
 4731                        		.dbg	line,	"include\routines_LEVELS.c", 532; check_BG( 15 , 8 );
 4732                        		__ld.wi		15
         11:CAE9  A9 0F      			lda.l	#15
         11:CAEB  C2         			cly
 4733                        		__pusharg.wr
         11:CAEC  A6 8D      			ldx	<__sp
         11:CAEE  CA         			dex
         11:CAEF  CA         			dex
         11:CAF0  95 08      			sta.l	<__stack, x
         11:CAF2  94 09      			sty.h	<__stack, x
         11:CAF4  86 8D      			stx	<__sp
 4734                        		__ld.wi		8
         11:CAF6  A9 08      			lda.l	#8
         11:CAF8  C2         			cly
 4735                        		__pusharg.wr
         11:CAF9  A6 8D      			ldx	<__sp
         11:CAFB  CA         			dex
         11:CAFC  CA         			dex
         11:CAFD  95 08      			sta.l	<__stack, x
         11:CAFF  94 09      			sty.h	<__stack, x
         11:CB01  86 8D      			stx	<__sp
 4736                        		__call		_check_BG
         11:CB03  20 6D FF   			call	_check_BG
 4737                        	
 4738                        		.dbg	line,	"include\routines_LEVELS.c", 534; if(map_blk_flag == TILE_EMPTY)
 4739                        		__not.um	_map_blk_flag
         11:CB06  AD AA 2B   			lda	_map_blk_flag
         11:CB09  18         			clc
         11:CB0A  D0 01      			bne	!+
         11:CB0C  38         			sec
         11:CB0D             	!:
 4740                        		__bfalse	.LL113
         11:CB0D  90 05      			bcc	.LL113
 4741                        	
 4742                        		.dbg	line,	"include\routines_LEVELS.c", 535; {
 4743                        	
 4744                        		.dbg	line,	"include\routines_LEVELS.c", 536; player_state = STATE_JUMP_LADDER;
 4745                        		__st.umiq	13, _player_state
         11:CB0F  A9 0D      			lda.l	#13
         11:CB11  8D 15 23   			sta	_player_state
 4746                        	
 4747                        		.dbg	line,	"include\routines_LEVELS.c", 537; }
 4748                        	
 4749                        		.dbg	line,	"include\routines_LEVELS.c", 538; }
 4750    11:CB14             	.LL113:
 4751                        	
 4752                        		.dbg	line,	"include\routines_LEVELS.c", 539; }
 4753    11:CB14             	.LL112:
 4754    11:CB14             	.LL111:
 4755    11:CB14             	.LL109:
 4756                        	
 4757                        		.dbg	line,	"include\routines_LEVELS.c", 540; }
 4758    11:CB14             	.LL105:
 4759    11:CB14             	.LL104:
 4760    11:CB14             	.LL102:
 4761                        	
 4762                        		.dbg	line,	"include\routines_LEVELS.c", 541; }
 4763    11:CB14             	.LL100:
 4764    11:CB14             	.LL99:
 4765                        		__return	0
         11:CB14  4C EF FF   			jmp	leave_proc
 4766                        		.dbg	clear
 4767                        		.endp
 4768                        		.pceas
 4769                        	
 4770                        		.dbg	line,	"include\routines_LEVELS.c", 544; void joypad_DIR()
 4771                        		.dbg	line,	"include\routines_LEVELS.c", 545; {
 4772                        	;***********************
 4773                        	;***********************
 4774                        	
 4775                        		.hucc
 4776    02:C86D             		.proc		_joypad_DIR
 4777                        		__enter		_joypad_DIR
 4778                        	
 4779                        		.dbg	line,	"include\routines_LEVELS.c", 546; //--------------------------------------------------------------------------------------//
 4780                        	
 4781                        		.dbg	line,	"include\routines_LEVELS.c", 547; //                                        NO DIR                                        //
 4782                        	
 4783                        		.dbg	line,	"include\routines_LEVELS.c", 548; //--------------------------------------------------------------------------------------//
 4784                        	
 4785                        		.dbg	line,	"include\routines_LEVELS.c", 550; if(! (joy(JOYPAD_1) & JOY_DIR_PRESSED) )
 4786                        		__ld.uiq	0
         02:C86D  62         			cla
 4787                        		 _joy.1
         02:C86E  AA         			tax
         02:C86F  BD 28 22   			lda	joynow, x
         02:C872  BC D3 22   			ldy	joy6now, x
 4788                        		__nand.wi	240
         02:C875  18         			clc
         02:C876  29 F0      			and	#240
         02:C878  D0 01      			bne	!+
         02:C87A  38         			sec
         02:C87B             	!:
 4789                        		__bfalse	.LL115
         02:C87B  90 3C      			bcc	.LL115
 4790                        	
 4791                        		.dbg	line,	"include\routines_LEVELS.c", 551; {
 4792                        	
 4793                        		.dbg	line,	"include\routines_LEVELS.c", 552; if(player_state == STATE_WALK || player_state == STATE_CROUCH)
 4794                        		__ld.umq	_player_state
         02:C87D  AD 15 23   			lda	_player_state
 4795                        		__equ_b.uiq	1
         02:C880  C9 01      			cmp	#1
         02:C882  F0 01      			beq	!+
         02:C884  18         			clc
         02:C885             	!:
 4796                        		__btrue		.LL117
         02:C885  B0 08      			bcs	.LL117
 4797                        		__ld.umq	_player_state
         02:C887  AD 15 23   			lda	_player_state
 4798                        		__equ_b.uiq	7
         02:C88A  C9 07      			cmp	#7
         02:C88C  F0 01      			beq	!+
         02:C88E  18         			clc
         02:C88F             	!:
 4799    02:C88F             	.LL117:
 4800                        		__bfalse	.LL116
         02:C88F  90 0A      			bcc	.LL116
 4801                        	
 4802                        		.dbg	line,	"include\routines_LEVELS.c", 553; {
 4803                        	
 4804                        		.dbg	line,	"include\routines_LEVELS.c", 554; player_counter_anim = 1;
 4805                        		__st.umiq	1, _player_counter_anim
         02:C891  A9 01      			lda.l	#1
         02:C893  8D 18 23   			sta	_player_counter_anim
 4806                        	
 4807                        		.dbg	line,	"include\routines_LEVELS.c", 555; player_state = STATE_IDLE;
 4808                        		__st.umiq	0, _player_state
         02:C896  9C 15 23   			stz	_player_state
 4809                        	
 4810                        		.dbg	line,	"include\routines_LEVELS.c", 556; }
 4811                        	
 4812                        		.dbg	line,	"include\routines_LEVELS.c", 559; else if(player_state == STATE_CLIMB_UP || player_state == STATE_CLIMB_DOWN)
 4813                        		__bra		.LL118
         02:C899  80 1E      			bra	.LL118
 4814    02:C89B             	.LL116:
 4815                        		__ld.umq	_player_state
         02:C89B  AD 15 23   			lda	_player_state
 4816                        		__equ_b.uiq	11
         02:C89E  C9 0B      			cmp	#11
         02:C8A0  F0 01      			beq	!+
         02:C8A2  18         			clc
         02:C8A3             	!:
 4817                        		__btrue		.LL120
         02:C8A3  B0 08      			bcs	.LL120
 4818                        		__ld.umq	_player_state
         02:C8A5  AD 15 23   			lda	_player_state
 4819                        		__equ_b.uiq	12
         02:C8A8  C9 0C      			cmp	#12
         02:C8AA  F0 01      			beq	!+
         02:C8AC  18         			clc
         02:C8AD             	!:
 4820    02:C8AD             	.LL120:
 4821                        		__bfalse	.LL119
         02:C8AD  90 0A      			bcc	.LL119
 4822                        	
 4823                        		.dbg	line,	"include\routines_LEVELS.c", 560; {
 4824                        	
 4825                        		.dbg	line,	"include\routines_LEVELS.c", 561; player_counter_anim = 1;
 4826                        		__st.umiq	1, _player_counter_anim
         02:C8AF  A9 01      			lda.l	#1
         02:C8B1  8D 18 23   			sta	_player_counter_anim
 4827                        	
 4828                        		.dbg	line,	"include\routines_LEVELS.c", 562; player_state = STATE_HANG;
 4829                        		__st.umiq	10, _player_state
         02:C8B4  A9 0A      			lda.l	#10
         02:C8B6  8D 15 23   			sta	_player_state
 4830                        	
 4831                        		.dbg	line,	"include\routines_LEVELS.c", 563; }
 4832                        	
 4833                        		.dbg	line,	"include\routines_LEVELS.c", 564; }
 4834    02:C8B9             	.LL119:
 4835    02:C8B9             	.LL118:
 4836                        	
 4837                        		.dbg	line,	"include\routines_LEVELS.c", 567; //--------------------------------------------------------------------------------------//
 4838                        	
 4839                        		.dbg	line,	"include\routines_LEVELS.c", 568; //                                     RIGHT BUTTON                                     //
 4840                        	
 4841                        		.dbg	line,	"include\routines_LEVELS.c", 569; //--------------------------------------------------------------------------------------//
 4842                        	
 4843                        		.dbg	line,	"include\routines_LEVELS.c", 571; if(joy(JOYPAD_1) & JOY_RIGHT)
 4844    02:C8B9             	.LL115:
 4845                        		__ld.uiq	0
         02:C8B9  62         			cla
 4846                        		 _joy.1
         02:C8BA  AA         			tax
         02:C8BB  BD 28 22   			lda	joynow, x
         02:C8BE  BC D3 22   			ldy	joy6now, x
 4847                        		__tand.wi	32
         02:C8C1  29 20      			and	#32
         02:C8C3  C9 01      	!:		cmp	#1
 4848                        		__bfalse	.LL121
         02:C8C5  B0 03 4C A2			bcc	.LL121
         02:C8C9  C9          
 4849                        	
 4850                        		.dbg	line,	"include\routines_LEVELS.c", 572; {
 4851                        	
 4852                        		.dbg	line,	"include\routines_LEVELS.c", 573; if(player_state == STATE_IDLE || player_state == STATE_WALK)
 4853                        		__not.um	_player_state
         02:C8CA  AD 15 23   			lda	_player_state
         02:C8CD  18         			clc
         02:C8CE  D0 01      			bne	!+
         02:C8D0  38         			sec
         02:C8D1             	!:
 4854                        		__btrue		.LL123
         02:C8D1  B0 08      			bcs	.LL123
 4855                        		__ld.umq	_player_state
         02:C8D3  AD 15 23   			lda	_player_state
 4856                        		__equ_b.uiq	1
         02:C8D6  C9 01      			cmp	#1
         02:C8D8  F0 01      			beq	!+
         02:C8DA  18         			clc
         02:C8DB             	!:
 4857    02:C8DB             	.LL123:
 4858                        		__bfalse	.LL122
         02:C8DB  90 47      			bcc	.LL122
 4859                        	
 4860                        		.dbg	line,	"include\routines_LEVELS.c", 574; {
 4861                        	
 4862                        		.dbg	line,	"include\routines_LEVELS.c", 575; player_axis = AXIS_RIGHT;
 4863                        		__st.umiq	0, _player_axis
         02:C8DD  9C 16 23   			stz	_player_axis
 4864                        	
 4865                        		.dbg	line,	"include\routines_LEVELS.c", 577; if(player_previous_axis != player_axis)
 4866                        		__ld.umq	_player_previous_axis
         02:C8E0  AD 17 23   			lda	_player_previous_axis
 4867                        		__neq_b.umq	_player_axis
         02:C8E3  38         			sec
         02:C8E4  4D 16 23   			eor	_player_axis
         02:C8E7  D0 01      			bne	!+
         02:C8E9  18         			clc
         02:C8EA             	!:
 4868                        		__bfalse	.LL124
         02:C8EA  90 15      			bcc	.LL124
 4869                        	
 4870                        		.dbg	line,	"include\routines_LEVELS.c", 578; {
 4871                        	
 4872                        		.dbg	line,	"include\routines_LEVELS.c", 579; player_previous_axis = player_axis;
 4873                        		__ld.um		_player_axis
         02:C8EC  AD 16 23   			lda	_player_axis
         02:C8EF  C2         			cly
 4874                        		__st.umq	_player_previous_axis
         02:C8F0  8D 17 23   			sta	_player_previous_axis
 4875                        	
 4876                        		.dbg	line,	"include\routines_LEVELS.c", 581; spr_set(player_id);
 4877                        		__ld.umq	_player_id
         02:C8F3  AD 14 23   			lda	_player_id
 4878                        		__call		_spr_set.1
         02:C8F6  20 DD E7   			call	_spr_set.1
 4879                        	
 4880                        		.dbg	line,	"include\routines_LEVELS.c", 582; spr_ctrl(FLIP_MAS, NO_FLIP_X);
 4881                        		__st.umiq	136, _al
         02:C8F9  A9 88      			lda.l	#136
         02:C8FB  85 F8      			sta	_al
 4882                        		__ld.uiq	0
         02:C8FD  62         			cla
 4883                        		__call		_spr_ctrl.2
         02:C8FE  20 3C E8   			call	_spr_ctrl.2
 4884                        	
 4885                        		.dbg	line,	"include\routines_LEVELS.c", 583; }
 4886                        	
 4887                        		.dbg	line,	"include\routines_LEVELS.c", 585; if(joy(JOYPAD_1) & JOY_DOWN)
 4888    02:C901             	.LL124:
 4889                        		__ld.uiq	0
         02:C901  62         			cla
 4890                        		 _joy.1
         02:C902  AA         			tax
         02:C903  BD 28 22   			lda	joynow, x
         02:C906  BC D3 22   			ldy	joy6now, x
 4891                        		__tand.wi	64
         02:C909  29 40      			and	#64
         02:C90B  C9 01      	!:		cmp	#1
 4892                        		__bfalse	.LL125
         02:C90D  90 0D      			bcc	.LL125
 4893                        	
 4894                        		.dbg	line,	"include\routines_LEVELS.c", 586; {
 4895                        	
 4896                        		.dbg	line,	"include\routines_LEVELS.c", 587; player_counter_anim = 1;
 4897                        		__st.umiq	1, _player_counter_anim
         02:C90F  A9 01      			lda.l	#1
         02:C911  8D 18 23   			sta	_player_counter_anim
 4898                        	
 4899                        		.dbg	line,	"include\routines_LEVELS.c", 588; player_state = STATE_CROUCH;
 4900                        		__st.umiq	7, _player_state
         02:C914  A9 07      			lda.l	#7
         02:C916  8D 15 23   			sta	_player_state
 4901                        	
 4902                        		.dbg	line,	"include\routines_LEVELS.c", 589; return;
 4903                        		__bra		.LL114
         02:C919  4C 93 CC   			bra	.LL114
 4904                        	
 4905                        		.dbg	line,	"include\routines_LEVELS.c", 590; }
 4906                        	
 4907                        		.dbg	line,	"include\routines_LEVELS.c", 592; player_state = STATE_WALK;
 4908    02:C91C             	.LL125:
 4909                        		__st.umiq	1, _player_state
         02:C91C  A9 01      			lda.l	#1
         02:C91E  8D 15 23   			sta	_player_state
 4910                        	
 4911                        		.dbg	line,	"include\routines_LEVELS.c", 593; }
 4912                        	
 4913                        		.dbg	line,	"include\routines_LEVELS.c", 596; else if(player_state == STATE_JUMP || player_state == STATE_JUMP_LEFT || player_state == STATE_CROUCH || player_state == STATE_FALL || player_state == STATE_HANG)
 4914                        		__bra		.LL126
         02:C921  4C 93 CC   			bra	.LL126
 4915    02:C924             	.LL122:
 4916                        		__ld.umq	_player_state
         02:C924  AD 15 23   			lda	_player_state
 4917                        		__equ_b.uiq	4
         02:C927  C9 04      			cmp	#4
         02:C929  F0 01      			beq	!+
         02:C92B  18         			clc
         02:C92C             	!:
 4918                        		__btrue		.LL128
         02:C92C  B0 08      			bcs	.LL128
 4919                        		__ld.umq	_player_state
         02:C92E  AD 15 23   			lda	_player_state
 4920                        		__equ_b.uiq	6
         02:C931  C9 06      			cmp	#6
         02:C933  F0 01      			beq	!+
         02:C935  18         			clc
         02:C936             	!:
 4921    02:C936             	.LL128:
 4922                        		__btrue		.LL129
         02:C936  B0 08      			bcs	.LL129
 4923                        		__ld.umq	_player_state
         02:C938  AD 15 23   			lda	_player_state
 4924                        		__equ_b.uiq	7
         02:C93B  C9 07      			cmp	#7
         02:C93D  F0 01      			beq	!+
         02:C93F  18         			clc
         02:C940             	!:
 4925    02:C940             	.LL129:
 4926                        		__btrue		.LL130
         02:C940  B0 08      			bcs	.LL130
 4927                        		__ld.umq	_player_state
         02:C942  AD 15 23   			lda	_player_state
 4928                        		__equ_b.uiq	9
         02:C945  C9 09      			cmp	#9
         02:C947  F0 01      			beq	!+
         02:C949  18         			clc
         02:C94A             	!:
 4929    02:C94A             	.LL130:
 4930                        		__btrue		.LL131
         02:C94A  B0 08      			bcs	.LL131
 4931                        		__ld.umq	_player_state
         02:C94C  AD 15 23   			lda	_player_state
 4932                        		__equ_b.uiq	10
         02:C94F  C9 0A      			cmp	#10
         02:C951  F0 01      			beq	!+
         02:C953  18         			clc
         02:C954             	!:
 4933    02:C954             	.LL131:
 4934                        		__bfalse	.LL127
         02:C954  90 28      			bcc	.LL127
 4935                        	
 4936                        		.dbg	line,	"include\routines_LEVELS.c", 597; {
 4937                        	
 4938                        		.dbg	line,	"include\routines_LEVELS.c", 598; if(player_axis == AXIS_LEFT)
 4939                        		__ld.umq	_player_axis
         02:C956  AD 16 23   			lda	_player_axis
 4940                        		__equ_b.uiq	1
         02:C959  C9 01      			cmp	#1
         02:C95B  F0 01      			beq	!+
         02:C95D  18         			clc
         02:C95E             	!:
 4941                        		__bfalse	.LL132
         02:C95E  B0 03 4C 93			bcc	.LL132
         02:C962  CC          
 4942                        	
 4943                        		.dbg	line,	"include\routines_LEVELS.c", 599; {
 4944                        	
 4945                        		.dbg	line,	"include\routines_LEVELS.c", 600; player_axis = AXIS_RIGHT;
 4946                        		__st.umiq	0, _player_axis
         02:C963  9C 16 23   			stz	_player_axis
 4947                        	
 4948                        		.dbg	line,	"include\routines_LEVELS.c", 601; player_previous_axis = player_axis;
 4949                        		__ld.um		_player_axis
         02:C966  AD 16 23   			lda	_player_axis
         02:C969  C2         			cly
 4950                        		__st.umq	_player_previous_axis
         02:C96A  8D 17 23   			sta	_player_previous_axis
 4951                        	
 4952                        		.dbg	line,	"include\routines_LEVELS.c", 603; spr_set(player_id);
 4953                        		__ld.umq	_player_id
         02:C96D  AD 14 23   			lda	_player_id
 4954                        		__call		_spr_set.1
         02:C970  20 DD E7   			call	_spr_set.1
 4955                        	
 4956                        		.dbg	line,	"include\routines_LEVELS.c", 604; spr_ctrl(FLIP_MAS, NO_FLIP_X);
 4957                        		__st.umiq	136, _al
         02:C973  A9 88      			lda.l	#136
         02:C975  85 F8      			sta	_al
 4958                        		__ld.uiq	0
         02:C977  62         			cla
 4959                        		__call		_spr_ctrl.2
         02:C978  20 3C E8   			call	_spr_ctrl.2
 4960                        	
 4961                        		.dbg	line,	"include\routines_LEVELS.c", 605; }
 4962                        	
 4963                        		.dbg	line,	"include\routines_LEVELS.c", 606; }
 4964    02:C97B             	.LL132	.alias		.LL133
 4965                        	
 4966                        		.dbg	line,	"include\routines_LEVELS.c", 609; else if(player_state == STATE_CLIMB_UP || player_state == STATE_CLIMB_DOWN)
 4967                        		__bra		.LL133
         02:C97B  4C 93 CC   			bra	.LL133
 4968    02:C97E             	.LL127:
 4969                        		__ld.umq	_player_state
         02:C97E  AD 15 23   			lda	_player_state
 4970                        		__equ_b.uiq	11
         02:C981  C9 0B      			cmp	#11
         02:C983  F0 01      			beq	!+
         02:C985  18         			clc
         02:C986             	!:
 4971                        		__btrue		.LL135
         02:C986  B0 08      			bcs	.LL135
 4972                        		__ld.umq	_player_state
         02:C988  AD 15 23   			lda	_player_state
 4973                        		__equ_b.uiq	12
         02:C98B  C9 0C      			cmp	#12
         02:C98D  F0 01      			beq	!+
         02:C98F  18         			clc
         02:C990             	!:
 4974    02:C990             	.LL135:
 4975                        		__bfalse	.LL134
         02:C990  B0 03 4C 93			bcc	.LL134
         02:C994  CC          
 4976                        	
 4977                        		.dbg	line,	"include\routines_LEVELS.c", 610; {
 4978                        	
 4979                        		.dbg	line,	"include\routines_LEVELS.c", 611; player_counter_anim = 1;
 4980                        		__st.umiq	1, _player_counter_anim
         02:C995  A9 01      			lda.l	#1
         02:C997  8D 18 23   			sta	_player_counter_anim
 4981                        	
 4982                        		.dbg	line,	"include\routines_LEVELS.c", 612; player_state = STATE_HANG;
 4983                        		__st.umiq	10, _player_state
         02:C99A  A9 0A      			lda.l	#10
         02:C99C  8D 15 23   			sta	_player_state
 4984                        	
 4985                        		.dbg	line,	"include\routines_LEVELS.c", 613; }
 4986                        	
 4987                        		.dbg	line,	"include\routines_LEVELS.c", 614; }
 4988    02:C99F             	.LL134	.alias		.LL136
 4989    02:C99F             	.LL133	.alias		.LL136
 4990    02:C99F             	.LL126	.alias		.LL136
 4991                        	
 4992                        		.dbg	line,	"include\routines_LEVELS.c", 617; //--------------------------------------------------------------------------------------//
 4993                        	
 4994                        		.dbg	line,	"include\routines_LEVELS.c", 618; //                                     LEFT BUTTON                                      //
 4995                        	
 4996                        		.dbg	line,	"include\routines_LEVELS.c", 619; //--------------------------------------------------------------------------------------//
 4997                        	
 4998                        		.dbg	line,	"include\routines_LEVELS.c", 621; else if(joy(JOYPAD_1) & JOY_LEFT)
 4999                        		__bra		.LL136
         02:C99F  4C 93 CC   			bra	.LL136
 5000    02:C9A2             	.LL121:
 5001                        		__ld.uiq	0
         02:C9A2  62         			cla
 5002                        		 _joy.1
         02:C9A3  AA         			tax
         02:C9A4  BD 28 22   			lda	joynow, x
         02:C9A7  BC D3 22   			ldy	joy6now, x
 5003                        		__tand.wi	128
         02:C9AA  29 80      			and	#128
         02:C9AC  C9 01      	!:		cmp	#1
 5004                        		__bfalse	.LL137
         02:C9AE  B0 03 4C 90			bcc	.LL137
         02:C9B2  CA          
 5005                        	
 5006                        		.dbg	line,	"include\routines_LEVELS.c", 622; {
 5007                        	
 5008                        		.dbg	line,	"include\routines_LEVELS.c", 623; if(player_state == STATE_IDLE || player_state == STATE_WALK)
 5009                        		__not.um	_player_state
         02:C9B3  AD 15 23   			lda	_player_state
         02:C9B6  18         			clc
         02:C9B7  D0 01      			bne	!+
         02:C9B9  38         			sec
         02:C9BA             	!:
 5010                        		__btrue		.LL139
         02:C9BA  B0 08      			bcs	.LL139
 5011                        		__ld.umq	_player_state
         02:C9BC  AD 15 23   			lda	_player_state
 5012                        		__equ_b.uiq	1
         02:C9BF  C9 01      			cmp	#1
         02:C9C1  F0 01      			beq	!+
         02:C9C3  18         			clc
         02:C9C4             	!:
 5013    02:C9C4             	.LL139:
 5014                        		__bfalse	.LL138
         02:C9C4  90 4A      			bcc	.LL138
 5015                        	
 5016                        		.dbg	line,	"include\routines_LEVELS.c", 624; {
 5017                        	
 5018                        		.dbg	line,	"include\routines_LEVELS.c", 625; player_axis = AXIS_LEFT;
 5019                        		__st.umiq	1, _player_axis
         02:C9C6  A9 01      			lda.l	#1
         02:C9C8  8D 16 23   			sta	_player_axis
 5020                        	
 5021                        		.dbg	line,	"include\routines_LEVELS.c", 627; if(player_previous_axis != player_axis)
 5022                        		__ld.umq	_player_previous_axis
         02:C9CB  AD 17 23   			lda	_player_previous_axis
 5023                        		__neq_b.umq	_player_axis
         02:C9CE  38         			sec
         02:C9CF  4D 16 23   			eor	_player_axis
         02:C9D2  D0 01      			bne	!+
         02:C9D4  18         			clc
         02:C9D5             	!:
 5024                        		__bfalse	.LL140
         02:C9D5  90 16      			bcc	.LL140
 5025                        	
 5026                        		.dbg	line,	"include\routines_LEVELS.c", 628; {
 5027                        	
 5028                        		.dbg	line,	"include\routines_LEVELS.c", 629; player_previous_axis = player_axis;
 5029                        		__ld.um		_player_axis
         02:C9D7  AD 16 23   			lda	_player_axis
         02:C9DA  C2         			cly
 5030                        		__st.umq	_player_previous_axis
         02:C9DB  8D 17 23   			sta	_player_previous_axis
 5031                        	
 5032                        		.dbg	line,	"include\routines_LEVELS.c", 631; spr_set(player_id);
 5033                        		__ld.umq	_player_id
         02:C9DE  AD 14 23   			lda	_player_id
 5034                        		__call		_spr_set.1
         02:C9E1  20 DD E7   			call	_spr_set.1
 5035                        	
 5036                        		.dbg	line,	"include\routines_LEVELS.c", 632; spr_ctrl(FLIP_MAS, FLIP_X);
 5037                        		__st.umiq	136, _al
         02:C9E4  A9 88      			lda.l	#136
         02:C9E6  85 F8      			sta	_al
 5038                        		__ld.uiq	8
         02:C9E8  A9 08      			lda	#8
 5039                        		__call		_spr_ctrl.2
         02:C9EA  20 3C E8   			call	_spr_ctrl.2
 5040                        	
 5041                        		.dbg	line,	"include\routines_LEVELS.c", 633; }
 5042                        	
 5043                        		.dbg	line,	"include\routines_LEVELS.c", 635; if(joy(JOYPAD_1) & JOY_DOWN)
 5044    02:C9ED             	.LL140:
 5045                        		__ld.uiq	0
         02:C9ED  62         			cla
 5046                        		 _joy.1
         02:C9EE  AA         			tax
         02:C9EF  BD 28 22   			lda	joynow, x
         02:C9F2  BC D3 22   			ldy	joy6now, x
 5047                        		__tand.wi	64
         02:C9F5  29 40      			and	#64
         02:C9F7  C9 01      	!:		cmp	#1
 5048                        		__bfalse	.LL141
         02:C9F9  90 0D      			bcc	.LL141
 5049                        	
 5050                        		.dbg	line,	"include\routines_LEVELS.c", 636; {
 5051                        	
 5052                        		.dbg	line,	"include\routines_LEVELS.c", 637; player_counter_anim = 1;
 5053                        		__st.umiq	1, _player_counter_anim
         02:C9FB  A9 01      			lda.l	#1
         02:C9FD  8D 18 23   			sta	_player_counter_anim
 5054                        	
 5055                        		.dbg	line,	"include\routines_LEVELS.c", 638; player_state = STATE_CROUCH;
 5056                        		__st.umiq	7, _player_state
         02:CA00  A9 07      			lda.l	#7
         02:CA02  8D 15 23   			sta	_player_state
 5057                        	
 5058                        		.dbg	line,	"include\routines_LEVELS.c", 639; return;
 5059                        		__bra		.LL114
         02:CA05  4C 93 CC   			bra	.LL114
 5060                        	
 5061                        		.dbg	line,	"include\routines_LEVELS.c", 640; }
 5062                        	
 5063                        		.dbg	line,	"include\routines_LEVELS.c", 642; player_state = STATE_WALK;
 5064    02:CA08             	.LL141:
 5065                        		__st.umiq	1, _player_state
         02:CA08  A9 01      			lda.l	#1
         02:CA0A  8D 15 23   			sta	_player_state
 5066                        	
 5067                        		.dbg	line,	"include\routines_LEVELS.c", 643; }
 5068                        	
 5069                        		.dbg	line,	"include\routines_LEVELS.c", 646; else if(player_state == STATE_JUMP || player_state == STATE_JUMP_RIGHT || player_state == STATE_CROUCH || player_state == STATE_FALL || player_state == STATE_HANG)
 5070                        		__bra		.LL142
         02:CA0D  4C 93 CC   			bra	.LL142
 5071    02:CA10             	.LL138:
 5072                        		__ld.umq	_player_state
         02:CA10  AD 15 23   			lda	_player_state
 5073                        		__equ_b.uiq	4
         02:CA13  C9 04      			cmp	#4
         02:CA15  F0 01      			beq	!+
         02:CA17  18         			clc
         02:CA18             	!:
 5074                        		__btrue		.LL144
         02:CA18  B0 08      			bcs	.LL144
 5075                        		__ld.umq	_player_state
         02:CA1A  AD 15 23   			lda	_player_state
 5076                        		__equ_b.uiq	5
         02:CA1D  C9 05      			cmp	#5
         02:CA1F  F0 01      			beq	!+
         02:CA21  18         			clc
         02:CA22             	!:
 5077    02:CA22             	.LL144:
 5078                        		__btrue		.LL145
         02:CA22  B0 08      			bcs	.LL145
 5079                        		__ld.umq	_player_state
         02:CA24  AD 15 23   			lda	_player_state
 5080                        		__equ_b.uiq	7
         02:CA27  C9 07      			cmp	#7
         02:CA29  F0 01      			beq	!+
         02:CA2B  18         			clc
         02:CA2C             	!:
 5081    02:CA2C             	.LL145:
 5082                        		__btrue		.LL146
         02:CA2C  B0 08      			bcs	.LL146
 5083                        		__ld.umq	_player_state
         02:CA2E  AD 15 23   			lda	_player_state
 5084                        		__equ_b.uiq	9
         02:CA31  C9 09      			cmp	#9
         02:CA33  F0 01      			beq	!+
         02:CA35  18         			clc
         02:CA36             	!:
 5085    02:CA36             	.LL146:
 5086                        		__btrue		.LL147
         02:CA36  B0 08      			bcs	.LL147
 5087                        		__ld.umq	_player_state
         02:CA38  AD 15 23   			lda	_player_state
 5088                        		__equ_b.uiq	10
         02:CA3B  C9 0A      			cmp	#10
         02:CA3D  F0 01      			beq	!+
         02:CA3F  18         			clc
         02:CA40             	!:
 5089    02:CA40             	.LL147:
 5090                        		__bfalse	.LL143
         02:CA40  90 2A      			bcc	.LL143
 5091                        	
 5092                        		.dbg	line,	"include\routines_LEVELS.c", 647; {
 5093                        	
 5094                        		.dbg	line,	"include\routines_LEVELS.c", 648; if(player_axis == AXIS_RIGHT)
 5095                        		__not.um	_player_axis
         02:CA42  AD 16 23   			lda	_player_axis
         02:CA45  18         			clc
         02:CA46  D0 01      			bne	!+
         02:CA48  38         			sec
         02:CA49             	!:
 5096                        		__bfalse	.LL148
         02:CA49  B0 03 4C 93			bcc	.LL148
         02:CA4D  CC          
 5097                        	
 5098                        		.dbg	line,	"include\routines_LEVELS.c", 649; {
 5099                        	
 5100                        		.dbg	line,	"include\routines_LEVELS.c", 650; player_axis = AXIS_LEFT;
 5101                        		__st.umiq	1, _player_axis
         02:CA4E  A9 01      			lda.l	#1
         02:CA50  8D 16 23   			sta	_player_axis
 5102                        	
 5103                        		.dbg	line,	"include\routines_LEVELS.c", 651; player_previous_axis = player_axis;
 5104                        		__ld.um		_player_axis
         02:CA53  AD 16 23   			lda	_player_axis
         02:CA56  C2         			cly
 5105                        		__st.umq	_player_previous_axis
         02:CA57  8D 17 23   			sta	_player_previous_axis
 5106                        	
 5107                        		.dbg	line,	"include\routines_LEVELS.c", 653; spr_set(player_id);
 5108                        		__ld.umq	_player_id
         02:CA5A  AD 14 23   			lda	_player_id
 5109                        		__call		_spr_set.1
         02:CA5D  20 DD E7   			call	_spr_set.1
 5110                        	
 5111                        		.dbg	line,	"include\routines_LEVELS.c", 654; spr_ctrl(FLIP_MAS, FLIP_X);
 5112                        		__st.umiq	136, _al
         02:CA60  A9 88      			lda.l	#136
         02:CA62  85 F8      			sta	_al
 5113                        		__ld.uiq	8
         02:CA64  A9 08      			lda	#8
 5114                        		__call		_spr_ctrl.2
         02:CA66  20 3C E8   			call	_spr_ctrl.2
 5115                        	
 5116                        		.dbg	line,	"include\routines_LEVELS.c", 655; }
 5117                        	
 5118                        		.dbg	line,	"include\routines_LEVELS.c", 656; }
 5119    02:CA69             	.LL148	.alias		.LL149
 5120                        	
 5121                        		.dbg	line,	"include\routines_LEVELS.c", 659; else if(player_state == STATE_CLIMB_UP || player_state == STATE_CLIMB_DOWN)
 5122                        		__bra		.LL149
         02:CA69  4C 93 CC   			bra	.LL149
 5123    02:CA6C             	.LL143:
 5124                        		__ld.umq	_player_state
         02:CA6C  AD 15 23   			lda	_player_state
 5125                        		__equ_b.uiq	11
         02:CA6F  C9 0B      			cmp	#11
         02:CA71  F0 01      			beq	!+
         02:CA73  18         			clc
         02:CA74             	!:
 5126                        		__btrue		.LL151
         02:CA74  B0 08      			bcs	.LL151
 5127                        		__ld.umq	_player_state
         02:CA76  AD 15 23   			lda	_player_state
 5128                        		__equ_b.uiq	12
         02:CA79  C9 0C      			cmp	#12
         02:CA7B  F0 01      			beq	!+
         02:CA7D  18         			clc
         02:CA7E             	!:
 5129    02:CA7E             	.LL151:
 5130                        		__bfalse	.LL150
         02:CA7E  B0 03 4C 93			bcc	.LL150
         02:CA82  CC          
 5131                        	
 5132                        		.dbg	line,	"include\routines_LEVELS.c", 660; {
 5133                        	
 5134                        		.dbg	line,	"include\routines_LEVELS.c", 661; player_counter_anim = 1;
 5135                        		__st.umiq	1, _player_counter_anim
         02:CA83  A9 01      			lda.l	#1
         02:CA85  8D 18 23   			sta	_player_counter_anim
 5136                        	
 5137                        		.dbg	line,	"include\routines_LEVELS.c", 662; player_state = STATE_HANG;
 5138                        		__st.umiq	10, _player_state
         02:CA88  A9 0A      			lda.l	#10
         02:CA8A  8D 15 23   			sta	_player_state
 5139                        	
 5140                        		.dbg	line,	"include\routines_LEVELS.c", 663; }
 5141                        	
 5142                        		.dbg	line,	"include\routines_LEVELS.c", 664; }
 5143    02:CA8D             	.LL150	.alias		.LL152
 5144    02:CA8D             	.LL149	.alias		.LL152
 5145    02:CA8D             	.LL142	.alias		.LL152
 5146                        	
 5147                        		.dbg	line,	"include\routines_LEVELS.c", 667; //--------------------------------------------------------------------------------------//
 5148                        	
 5149                        		.dbg	line,	"include\routines_LEVELS.c", 668; //                                      UP BUTTON                                       //
 5150                        	
 5151                        		.dbg	line,	"include\routines_LEVELS.c", 669; //--------------------------------------------------------------------------------------//
 5152                        	
 5153                        		.dbg	line,	"include\routines_LEVELS.c", 671; else if(joy(JOYPAD_1) & JOY_UP)
 5154                        		__bra		.LL152
         02:CA8D  4C 93 CC   			bra	.LL152
 5155    02:CA90             	.LL137:
 5156                        		__ld.uiq	0
         02:CA90  62         			cla
 5157                        		 _joy.1
         02:CA91  AA         			tax
         02:CA92  BD 28 22   			lda	joynow, x
         02:CA95  BC D3 22   			ldy	joy6now, x
 5158                        		__tand.wi	16
         02:CA98  29 10      			and	#16
         02:CA9A  C9 01      	!:		cmp	#1
 5159                        		__bfalse	.LL153
         02:CA9C  B0 03 4C 65			bcc	.LL153
         02:CAA0  CB          
 5160                        	
 5161                        		.dbg	line,	"include\routines_LEVELS.c", 672; {
 5162                        	
 5163                        		.dbg	line,	"include\routines_LEVELS.c", 673; if(player_state == STATE_HANG || player_state == STATE_CLIMB_UP || player_state == STATE_CLIMB_DOWN)
 5164                        		__ld.umq	_player_state
         02:CAA1  AD 15 23   			lda	_player_state
 5165                        		__equ_b.uiq	10
         02:CAA4  C9 0A      			cmp	#10
         02:CAA6  F0 01      			beq	!+
         02:CAA8  18         			clc
         02:CAA9             	!:
 5166                        		__btrue		.LL155
         02:CAA9  B0 08      			bcs	.LL155
 5167                        		__ld.umq	_player_state
         02:CAAB  AD 15 23   			lda	_player_state
 5168                        		__equ_b.uiq	11
         02:CAAE  C9 0B      			cmp	#11
         02:CAB0  F0 01      			beq	!+
         02:CAB2  18         			clc
         02:CAB3             	!:
 5169    02:CAB3             	.LL155:
 5170                        		__btrue		.LL156
         02:CAB3  B0 08      			bcs	.LL156
 5171                        		__ld.umq	_player_state
         02:CAB5  AD 15 23   			lda	_player_state
 5172                        		__equ_b.uiq	12
         02:CAB8  C9 0C      			cmp	#12
         02:CABA  F0 01      			beq	!+
         02:CABC  18         			clc
         02:CABD             	!:
 5173    02:CABD             	.LL156:
 5174                        		__bfalse	.LL154
         02:CABD  B0 03 4C 93			bcc	.LL154
         02:CAC1  CC          
 5175                        	
 5176                        		.dbg	line,	"include\routines_LEVELS.c", 674; {
 5177                        	
 5178                        		.dbg	line,	"include\routines_LEVELS.c", 675; unsigned char i;
 5179                        	
 5180                        		.dbg	line,	"include\routines_LEVELS.c", 677; check_BG( 15 , 8 );
 5181                        		__ld.wi		15
         02:CAC2  A9 0F      			lda.l	#15
         02:CAC4  C2         			cly
 5182                        		__pusharg.wr
         02:CAC5  A6 8D      			ldx	<__sp
         02:CAC7  CA         			dex
         02:CAC8  CA         			dex
         02:CAC9  95 08      			sta.l	<__stack, x
         02:CACB  94 09      			sty.h	<__stack, x
         02:CACD  86 8D      			stx	<__sp
 5183                        		__ld.wi		8
         02:CACF  A9 08      			lda.l	#8
         02:CAD1  C2         			cly
 5184                        		__pusharg.wr
         02:CAD2  A6 8D      			ldx	<__sp
         02:CAD4  CA         			dex
         02:CAD5  CA         			dex
         02:CAD6  95 08      			sta.l	<__stack, x
         02:CAD8  94 09      			sty.h	<__stack, x
         02:CADA  86 8D      			stx	<__sp
 5185                        		__call		_check_BG
         02:CADC  20 6D FF   			call	_check_BG
 5186                        	
 5187                        		.dbg	line,	"include\routines_LEVELS.c", 679; if(map_blk_flag == TILE_EMPTY)
 5188                        		__not.um	_map_blk_flag
         02:CADF  AD AA 2B   			lda	_map_blk_flag
         02:CAE2  18         			clc
         02:CAE3  D0 01      			bne	!+
         02:CAE5  38         			sec
         02:CAE6             	!:
 5189                        		__bfalse	.LL157
         02:CAE6  90 67      			bcc	.LL157
 5190                        	
 5191                        		.dbg	line,	"include\routines_LEVELS.c", 680; {
 5192                        	
 5193                        		.dbg	line,	"include\routines_LEVELS.c", 681; for(i=1 ; i<3 ; i++)
 5194                        		__st.umiq	1, __joypad_DIR_end - 1  /* i */
         02:CAE8  A9 01      			lda.l	#1
         02:CAEA  8D 04 23   			sta	__joypad_DIR_end - 1
 5195    02:CAED             	.LL158:
 5196                        		__ld.umq	__joypad_DIR_end - 1  /* i */
         02:CAED  AD 04 23   			lda	__joypad_DIR_end - 1
 5197                        		__ult_b.uiq	3
         02:CAF0  C9 03      			cmp	#3		; Subtract integer from A.
         02:CAF2  6A         			ror	a		; CC if A < integer.
         02:CAF3  49 80      			eor	#$80
         02:CAF5  2A         			rol	a
 5198                        		__btrue		.LL160
         02:CAF6  B0 07      			bcs	.LL160
 5199                        		__bra		.LL161
         02:CAF8  80 63      			bra	.LL161
 5200    02:CAFA             	.LL159:
 5201                        		__inc.umq	__joypad_DIR_end - 1  /* i */
         02:CAFA  EE 04 23   			inc	__joypad_DIR_end - 1
 5202                        		__bra		.LL158
         02:CAFD  80 EE      			bra	.LL158
 5203    02:CAFF             	.LL160:
 5204                        	
 5205                        		.dbg	line,	"include\routines_LEVELS.c", 682; {
 5206                        	
 5207                        		.dbg	line,	"include\routines_LEVELS.c", 683; check_BG( 15 , 8 + i );
 5208                        		__ld.wi		15
         02:CAFF  A9 0F      			lda.l	#15
         02:CB01  C2         			cly
 5209                        		__pusharg.wr
         02:CB02  A6 8D      			ldx	<__sp
         02:CB04  CA         			dex
         02:CB05  CA         			dex
         02:CB06  95 08      			sta.l	<__stack, x
         02:CB08  94 09      			sty.h	<__stack, x
         02:CB0A  86 8D      			stx	<__sp
 5210                        		__ld.wi		8
         02:CB0C  A9 08      			lda.l	#8
         02:CB0E  C2         			cly
 5211                        		__add.um	__joypad_DIR_end - 1  /* i */
         02:CB0F  18         			clc
         02:CB10  6D 04 23   			adc	__joypad_DIR_end - 1
         02:CB13  90 01      			bcc	!+
         02:CB15  C8         			iny
         02:CB16             	!:
 5212                        		__pusharg.wr
         02:CB16  A6 8D      			ldx	<__sp
         02:CB18  CA         			dex
         02:CB19  CA         			dex
         02:CB1A  95 08      			sta.l	<__stack, x
         02:CB1C  94 09      			sty.h	<__stack, x
         02:CB1E  86 8D      			stx	<__sp
 5213                        		__call		_check_BG
         02:CB20  20 6D FF   			call	_check_BG
 5214                        	
 5215                        		.dbg	line,	"include\routines_LEVELS.c", 685; if(map_blk_flag == TILE_LADDER)
 5216                        		__ld.umq	_map_blk_flag
         02:CB23  AD AA 2B   			lda	_map_blk_flag
 5217                        		__equ_b.uiq	2
         02:CB26  C9 02      			cmp	#2
         02:CB28  F0 01      			beq	!+
         02:CB2A  18         			clc
         02:CB2B             	!:
 5218                        		__bfalse	.LL162
         02:CB2B  90 CD      			bcc	.LL162
 5219                        	
 5220                        		.dbg	line,	"include\routines_LEVELS.c", 686; {
 5221                        	
 5222                        		.dbg	line,	"include\routines_LEVELS.c", 687; sgx_map_pxl_y -= (2 - i);
 5223                        		__ld.wi		2
         02:CB2D  A9 02      			lda.l	#2
         02:CB2F  C2         			cly
 5224                        		__sub.um	__joypad_DIR_end - 1  /* i */
         02:CB30  38         			sec
         02:CB31  ED 04 23   			sbc	__joypad_DIR_end - 1
         02:CB34  B0 01      			bcs	!+
         02:CB36  88         			dey
         02:CB37             	!:
 5225                        		__isub_st.wmq	_sgx_map_pxl_y
         02:CB37  38         			sec
         02:CB38  49 FF      			eor	#$FF
         02:CB3A  6D 8B 26   			adc.l	_sgx_map_pxl_y
         02:CB3D  8D 8B 26   			sta.l	_sgx_map_pxl_y
         02:CB40  98         			tya
         02:CB41  49 FF      			eor	#$FF
         02:CB43  6D 8C 26   			adc.h	_sgx_map_pxl_y
         02:CB46  8D 8C 26   			sta.h	_sgx_map_pxl_y
 5226                        	
 5227                        		.dbg	line,	"include\routines_LEVELS.c", 688; break;
 5228                        		__bra		.LL161
         02:CB49  80 12      			bra	.LL161
 5229                        	
 5230                        		.dbg	line,	"include\routines_LEVELS.c", 689; }
 5231                        	
 5232                        		.dbg	line,	"include\routines_LEVELS.c", 690; }
 5233    02:CB4B             	.LL162	.alias		.LL159
 5234                        		__bra		.LL159
         02:CB4B  80 AD      			bra	.LL159
 5235    02:CB4D             	.LL161	.alias		.LL163
 5236                        	
 5237                        		.dbg	line,	"include\routines_LEVELS.c", 691; }
 5238                        	
 5239                        		.dbg	line,	"include\routines_LEVELS.c", 693; else
 5240                        		__bra		.LL163
         02:CB4D  80 0E      			bra	.LL163
 5241    02:CB4F             	.LL157:
 5242                        	
 5243                        		.dbg	line,	"include\routines_LEVELS.c", 694; {
 5244                        	
 5245                        		.dbg	line,	"include\routines_LEVELS.c", 695; sgx_map_pxl_y -= 2;
 5246                        		__sub_st.wmiq	2, _sgx_map_pxl_y
         02:CB4F  38         			sec
         02:CB50  AD 8B 26   			lda.l	_sgx_map_pxl_y
         02:CB53  E9 02      			sbc.l	#2
         02:CB55  8D 8B 26   			sta.l	_sgx_map_pxl_y
         02:CB58  B0 03      			bcs	!+
         02:CB5A  CE 8C 26   			dec.h	_sgx_map_pxl_y
         02:CB5D             	!:
 5247                        	
 5248                        		.dbg	line,	"include\routines_LEVELS.c", 696; }
 5249    02:CB5D             	.LL163:
 5250                        	
 5251                        		.dbg	line,	"include\routines_LEVELS.c", 698; player_state = STATE_CLIMB_UP;
 5252                        		__st.umiq	11, _player_state
         02:CB5D  A9 0B      			lda.l	#11
         02:CB5F  8D 15 23   			sta	_player_state
 5253                        	
 5254                        		.dbg	line,	"include\routines_LEVELS.c", 699; }
 5255                        	
 5256                        		.dbg	line,	"include\routines_LEVELS.c", 700; }
 5257    02:CB62             	.LL154	.alias		.LL164
 5258                        	
 5259                        		.dbg	line,	"include\routines_LEVELS.c", 703; //--------------------------------------------------------------------------------------//
 5260                        	
 5261                        		.dbg	line,	"include\routines_LEVELS.c", 704; //                                     DOWN BUTTON                                      //
 5262                        	
 5263                        		.dbg	line,	"include\routines_LEVELS.c", 705; //--------------------------------------------------------------------------------------//
 5264                        	
 5265                        		.dbg	line,	"include\routines_LEVELS.c", 707; else if(joy(JOYPAD_1) & JOY_DOWN)
 5266                        		__bra		.LL164
         02:CB62  4C 93 CC   			bra	.LL164
 5267    02:CB65             	.LL153:
 5268                        		__ld.uiq	0
         02:CB65  62         			cla
 5269                        		 _joy.1
         02:CB66  AA         			tax
         02:CB67  BD 28 22   			lda	joynow, x
         02:CB6A  BC D3 22   			ldy	joy6now, x
 5270                        		__tand.wi	64
         02:CB6D  29 40      			and	#64
         02:CB6F  C9 01      	!:		cmp	#1
 5271                        		__bfalse	.LL165
         02:CB71  B0 03 4C 93			bcc	.LL165
         02:CB75  CC          
 5272                        	
 5273                        		.dbg	line,	"include\routines_LEVELS.c", 708; {
 5274                        	
 5275                        		.dbg	line,	"include\routines_LEVELS.c", 709; if(player_state == STATE_IDLE || player_state == STATE_WALK)
 5276                        		__not.um	_player_state
         02:CB76  AD 15 23   			lda	_player_state
         02:CB79  18         			clc
         02:CB7A  D0 01      			bne	!+
         02:CB7C  38         			sec
         02:CB7D             	!:
 5277                        		__btrue		.LL167
         02:CB7D  B0 08      			bcs	.LL167
 5278                        		__ld.umq	_player_state
         02:CB7F  AD 15 23   			lda	_player_state
 5279                        		__equ_b.uiq	1
         02:CB82  C9 01      			cmp	#1
         02:CB84  F0 01      			beq	!+
         02:CB86  18         			clc
         02:CB87             	!:
 5280    02:CB87             	.LL167:
 5281                        		__bfalse	.LL166
         02:CB87  90 0D      			bcc	.LL166
 5282                        	
 5283                        		.dbg	line,	"include\routines_LEVELS.c", 710; {
 5284                        	
 5285                        		.dbg	line,	"include\routines_LEVELS.c", 711; player_counter_anim = 1;
 5286                        		__st.umiq	1, _player_counter_anim
         02:CB89  A9 01      			lda.l	#1
         02:CB8B  8D 18 23   			sta	_player_counter_anim
 5287                        	
 5288                        		.dbg	line,	"include\routines_LEVELS.c", 712; player_state = STATE_CROUCH;
 5289                        		__st.umiq	7, _player_state
         02:CB8E  A9 07      			lda.l	#7
         02:CB90  8D 15 23   			sta	_player_state
 5290                        	
 5291                        		.dbg	line,	"include\routines_LEVELS.c", 713; }
 5292                        	
 5293                        		.dbg	line,	"include\routines_LEVELS.c", 716; else if(player_state == STATE_HANG || player_state == STATE_CLIMB_UP || player_state == STATE_CLIMB_DOWN)
 5294                        		__bra		.LL168
         02:CB93  4C 93 CC   			bra	.LL168
 5295    02:CB96             	.LL166:
 5296                        		__ld.umq	_player_state
         02:CB96  AD 15 23   			lda	_player_state
 5297                        		__equ_b.uiq	10
         02:CB99  C9 0A      			cmp	#10
         02:CB9B  F0 01      			beq	!+
         02:CB9D  18         			clc
         02:CB9E             	!:
 5298                        		__btrue		.LL170
         02:CB9E  B0 08      			bcs	.LL170
 5299                        		__ld.umq	_player_state
         02:CBA0  AD 15 23   			lda	_player_state
 5300                        		__equ_b.uiq	11
         02:CBA3  C9 0B      			cmp	#11
         02:CBA5  F0 01      			beq	!+
         02:CBA7  18         			clc
         02:CBA8             	!:
 5301    02:CBA8             	.LL170:
 5302                        		__btrue		.LL171
         02:CBA8  B0 08      			bcs	.LL171
 5303                        		__ld.umq	_player_state
         02:CBAA  AD 15 23   			lda	_player_state
 5304                        		__equ_b.uiq	12
         02:CBAD  C9 0C      			cmp	#12
         02:CBAF  F0 01      			beq	!+
         02:CBB1  18         			clc
         02:CBB2             	!:
 5305    02:CBB2             	.LL171:
 5306                        		__bfalse	.LL169
         02:CBB2  B0 03 4C 93			bcc	.LL169
         02:CBB6  CC          
 5307                        	
 5308                        		.dbg	line,	"include\routines_LEVELS.c", 717; {
 5309                        	
 5310                        		.dbg	line,	"include\routines_LEVELS.c", 718; unsigned char i;
 5311                        	
 5312                        		.dbg	line,	"include\routines_LEVELS.c", 720; check_BG( 15 , 10 );
 5313                        		__ld.wi		15
         02:CBB7  A9 0F      			lda.l	#15
         02:CBB9  C2         			cly
 5314                        		__pusharg.wr
         02:CBBA  A6 8D      			ldx	<__sp
         02:CBBC  CA         			dex
         02:CBBD  CA         			dex
         02:CBBE  95 08      			sta.l	<__stack, x
         02:CBC0  94 09      			sty.h	<__stack, x
         02:CBC2  86 8D      			stx	<__sp
 5315                        		__ld.wi		10
         02:CBC4  A9 0A      			lda.l	#10
         02:CBC6  C2         			cly
 5316                        		__pusharg.wr
         02:CBC7  A6 8D      			ldx	<__sp
         02:CBC9  CA         			dex
         02:CBCA  CA         			dex
         02:CBCB  95 08      			sta.l	<__stack, x
         02:CBCD  94 09      			sty.h	<__stack, x
         02:CBCF  86 8D      			stx	<__sp
 5317                        		__call		_check_BG
         02:CBD1  20 6D FF   			call	_check_BG
 5318                        	
 5319                        		.dbg	line,	"include\routines_LEVELS.c", 722; if(map_blk_flag == TILE_EMPTY)
 5320                        		__not.um	_map_blk_flag
         02:CBD4  AD AA 2B   			lda	_map_blk_flag
         02:CBD7  18         			clc
         02:CBD8  D0 01      			bne	!+
         02:CBDA  38         			sec
         02:CBDB             	!:
 5321                        		__bfalse	.LL172
         02:CBDB  B0 03 4C 80			bcc	.LL172
         02:CBDF  CC          
 5322                        	
 5323                        		.dbg	line,	"include\routines_LEVELS.c", 723; {
 5324                        	
 5325                        		.dbg	line,	"include\routines_LEVELS.c", 724; for(i=1 ; i<3 ; i++)
 5326                        		__st.umiq	1, __joypad_DIR_end - 2  /* i */
         02:CBE0  A9 01      			lda.l	#1
         02:CBE2  8D 03 23   			sta	__joypad_DIR_end - 2
 5327    02:CBE5             	.LL173:
 5328                        		__ld.umq	__joypad_DIR_end - 2  /* i */
         02:CBE5  AD 03 23   			lda	__joypad_DIR_end - 2
 5329                        		__ult_b.uiq	3
         02:CBE8  C9 03      			cmp	#3		; Subtract integer from A.
         02:CBEA  6A         			ror	a		; CC if A < integer.
         02:CBEB  49 80      			eor	#$80
         02:CBED  2A         			rol	a
 5330                        		__btrue		.LL175
         02:CBEE  B0 08      			bcs	.LL175
 5331                        		__bra		.LL176
         02:CBF0  4C 93 CC   			bra	.LL176
 5332    02:CBF3             	.LL174:
 5333                        		__inc.umq	__joypad_DIR_end - 2  /* i */
         02:CBF3  EE 03 23   			inc	__joypad_DIR_end - 2
 5334                        		__bra		.LL173
         02:CBF6  80 ED      			bra	.LL173
 5335    02:CBF8             	.LL175:
 5336                        	
 5337                        		.dbg	line,	"include\routines_LEVELS.c", 725; {
 5338                        	
 5339                        		.dbg	line,	"include\routines_LEVELS.c", 726; check_BG( 15 , 22 + i );
 5340                        		__ld.wi		15
         02:CBF8  A9 0F      			lda.l	#15
         02:CBFA  C2         			cly
 5341                        		__pusharg.wr
         02:CBFB  A6 8D      			ldx	<__sp
         02:CBFD  CA         			dex
         02:CBFE  CA         			dex
         02:CBFF  95 08      			sta.l	<__stack, x
         02:CC01  94 09      			sty.h	<__stack, x
         02:CC03  86 8D      			stx	<__sp
 5342                        		__ld.wi		22
         02:CC05  A9 16      			lda.l	#22
         02:CC07  C2         			cly
 5343                        		__add.um	__joypad_DIR_end - 2  /* i */
         02:CC08  18         			clc
         02:CC09  6D 03 23   			adc	__joypad_DIR_end - 2
         02:CC0C  90 01      			bcc	!+
         02:CC0E  C8         			iny
         02:CC0F             	!:
 5344                        		__pusharg.wr
         02:CC0F  A6 8D      			ldx	<__sp
         02:CC11  CA         			dex
         02:CC12  CA         			dex
         02:CC13  95 08      			sta.l	<__stack, x
         02:CC15  94 09      			sty.h	<__stack, x
         02:CC17  86 8D      			stx	<__sp
 5345                        		__call		_check_BG
         02:CC19  20 6D FF   			call	_check_BG
 5346                        	
 5347                        		.dbg	line,	"include\routines_LEVELS.c", 728; if(map_blk_flag == TILE_LADDER)
 5348                        		__ld.umq	_map_blk_flag
         02:CC1C  AD AA 2B   			lda	_map_blk_flag
 5349                        		__equ_b.uiq	2
         02:CC1F  C9 02      			cmp	#2
         02:CC21  F0 01      			beq	!+
         02:CC23  18         			clc
         02:CC24             	!:
 5350                        		__bfalse	.LL177
         02:CC24  90 1A      			bcc	.LL177
 5351                        	
 5352                        		.dbg	line,	"include\routines_LEVELS.c", 729; {
 5353                        	
 5354                        		.dbg	line,	"include\routines_LEVELS.c", 730; sgx_map_pxl_y += (2 - i);
 5355                        		__ld.wi		2
         02:CC26  A9 02      			lda.l	#2
         02:CC28  C2         			cly
 5356                        		__sub.um	__joypad_DIR_end - 2  /* i */
         02:CC29  38         			sec
         02:CC2A  ED 03 23   			sbc	__joypad_DIR_end - 2
         02:CC2D  B0 01      			bcs	!+
         02:CC2F  88         			dey
         02:CC30             	!:
 5357                        		__add_st.wmq	_sgx_map_pxl_y
         02:CC30  18         			clc
         02:CC31  6D 8B 26   			adc.l	_sgx_map_pxl_y
         02:CC34  8D 8B 26   			sta.l	_sgx_map_pxl_y
         02:CC37  98         			tya
         02:CC38  6D 8C 26   			adc.h	_sgx_map_pxl_y
         02:CC3B  8D 8C 26   			sta.h	_sgx_map_pxl_y
 5358                        	
 5359                        		.dbg	line,	"include\routines_LEVELS.c", 731; break;
 5360                        		__bra		.LL176
         02:CC3E  80 53      			bra	.LL176
 5361                        	
 5362                        		.dbg	line,	"include\routines_LEVELS.c", 732; }
 5363                        	
 5364                        		.dbg	line,	"include\routines_LEVELS.c", 734; else
 5365    02:CC40             	.LL177:
 5366                        	
 5367                        		.dbg	line,	"include\routines_LEVELS.c", 735; {
 5368                        	
 5369                        		.dbg	line,	"include\routines_LEVELS.c", 736; set_far_offset(OFFSET_PLAYER_FALL,TABLE_PLAYER_TILES_BANK[player_naked],TABLE_PLAYER_TILES_ADR[player_naked]);
 5370                        		__st.wmiq	7680, _bp
         02:CC40  64 EC      			stz.l	_bp
         02:CC42  A9 1E      			lda.h	#7680
         02:CC44  85 ED      			sta.h	_bp
 5371                        		__ldx.umq	_player_naked
         02:CC46  AE 1B 23   			ldx	_player_naked
 5372                        		__ld.uax	_TABLE_PLAYER_TILES_BANK
         02:CC49  BD F7 60   			lda	_TABLE_PLAYER_TILES_BANK, x
         02:CC4C  C2         			cly
 5373                        		__st.umq	_bp_bank
         02:CC4D  85 02      			sta	_bp_bank
 5374                        		__ld2x.umq	_player_naked
         02:CC4F  AD 1B 23   			lda	_player_naked
         02:CC52  0A         			asl	a
         02:CC53  AA         			tax
 5375                        		__ld.wax	_TABLE_PLAYER_TILES_ADR
         02:CC54  BD F3 60   			lda.l	_TABLE_PLAYER_TILES_ADR, x
         02:CC57  BC F4 60   			ldy.h	_TABLE_PLAYER_TILES_ADR, x
 5376                        		__call		_set_far_offset.3
         02:CC5A  20 8C E2   			call	_set_far_offset.3
 5377                        	
 5378                        		.dbg	line,	"include\routines_LEVELS.c", 737; far_load_vram(PLAYER_VRAM_ADR,TILES_16);
 5379                        		__st.wmiq	6144, _di
         02:CC5D  64 F0      			stz.l	_di
         02:CC5F  A9 18      			lda.h	#6144
         02:CC61  85 F1      			sta.h	_di
 5380                        		__st.wmiq	256, _ax
         02:CC63  64 F8      			stz.l	_ax
         02:CC65  A9 01      			lda.h	#256
         02:CC67  85 F9      			sta.h	_ax
 5381                        		 _far_load_vram.2
         02:CC69  82         			clx				; Offset to PCE VDC.
         02:CC6A  20 63 FF   			call	load_vram_x
 5382                        	
 5383                        		.dbg	line,	"include\routines_LEVELS.c", 739; jump_ladder = FALSE;
 5384                        		__st.umiq	0, _jump_ladder
         02:CC6D  9C 1C 23   			stz	_jump_ladder
 5385                        	
 5386                        		.dbg	line,	"include\routines_LEVELS.c", 740; player_index_jump = 0;
 5387                        		__st.umiq	0, _player_index_jump
         02:CC70  9C 19 23   			stz	_player_index_jump
 5388                        	
 5389                        		.dbg	line,	"include\routines_LEVELS.c", 741; player_index_fall = 0;
 5390                        		__st.umiq	0, _player_index_fall
         02:CC73  9C 1A 23   			stz	_player_index_fall
 5391                        	
 5392                        		.dbg	line,	"include\routines_LEVELS.c", 742; player_state = STATE_FALL;
 5393                        		__st.umiq	9, _player_state
         02:CC76  A9 09      			lda.l	#9
         02:CC78  8D 15 23   			sta	_player_state
 5394                        	
 5395                        		.dbg	line,	"include\routines_LEVELS.c", 743; }
 5396    02:CC7B             	.LL178	.alias		.LL174
 5397                        	
 5398                        		.dbg	line,	"include\routines_LEVELS.c", 744; }
 5399                        		__bra		.LL174
         02:CC7B  4C F3 CB   			bra	.LL174
 5400    02:CC7E             	.LL176	.alias		.LL179
 5401                        	
 5402                        		.dbg	line,	"include\routines_LEVELS.c", 745; }
 5403                        	
 5404                        		.dbg	line,	"include\routines_LEVELS.c", 747; else
 5405                        		__bra		.LL179
         02:CC7E  80 13      			bra	.LL179
 5406    02:CC80             	.LL172:
 5407                        	
 5408                        		.dbg	line,	"include\routines_LEVELS.c", 748; {
 5409                        	
 5410                        		.dbg	line,	"include\routines_LEVELS.c", 749; sgx_map_pxl_y += 2;
 5411                        		__add_st.wmiq	2, _sgx_map_pxl_y
         02:CC80  18         			clc
         02:CC81  AD 8B 26   			lda.l	_sgx_map_pxl_y
         02:CC84  69 02      			adc.l	#2
         02:CC86  8D 8B 26   			sta.l	_sgx_map_pxl_y
         02:CC89  90 03      			bcc	!+
         02:CC8B  EE 8C 26   			inc.h	_sgx_map_pxl_y
         02:CC8E             	!:
 5412                        	
 5413                        		.dbg	line,	"include\routines_LEVELS.c", 750; player_state = STATE_CLIMB_DOWN;
 5414                        		__st.umiq	12, _player_state
         02:CC8E  A9 0C      			lda.l	#12
         02:CC90  8D 15 23   			sta	_player_state
 5415                        	
 5416                        		.dbg	line,	"include\routines_LEVELS.c", 751; }
 5417    02:CC93             	.LL179:
 5418                        	
 5419                        		.dbg	line,	"include\routines_LEVELS.c", 752; }
 5420                        	
 5421                        		.dbg	line,	"include\routines_LEVELS.c", 753; }
 5422    02:CC93             	.LL169:
 5423    02:CC93             	.LL168:
 5424                        	
 5425                        		.dbg	line,	"include\routines_LEVELS.c", 754; }
 5426    02:CC93             	.LL165:
 5427    02:CC93             	.LL164:
 5428    02:CC93             	.LL152:
 5429    02:CC93             	.LL136:
 5430    02:CC93             	.LL114:
 5431                        		__return	0
         02:CC93  4C EF FF   			jmp	leave_proc
 5432                        		.dbg	clear
 5433                        		.endp
 5434               7F60     		.data
 5435               2303     		.bss
 5436    F8:2303             	__joypad_DIR_loc:
 5437    F8:2303             			ds	2
 5438    F8:2305             	__joypad_DIR_end:
 5439               E309     		.code
 5440                        		.pceas
 5441                        	
 5442                        		.dbg	line,	"include\routines_LEVELS.c", 763; void update_PLAYER()
 5443                        		.dbg	line,	"include\routines_LEVELS.c", 764; {
 5444                        	;***********************
 5445                        	;***********************
 5446                        	
 5447                        		.hucc
 5448    01:C196             		.proc		_update_PLAYER
 5449                        		__enter		_update_PLAYER
 5450                        	
 5451                        		.dbg	line,	"include\routines_LEVELS.c", 765; if(player_state == STATE_IDLE)
 5452                        		__not.um	_player_state
         01:C196  AD 15 23   			lda	_player_state
         01:C199  18         			clc
         01:C19A  D0 01      			bne	!+
         01:C19C  38         			sec
         01:C19D             	!:
 5453                        		__bfalse	.LL181
         01:C19D  B0 03 4C 65			bcc	.LL181
         01:C1A1  C2          
 5454                        	
 5455                        		.dbg	line,	"include\routines_LEVELS.c", 766; {
 5456                        	
 5457                        		.dbg	line,	"include\routines_LEVELS.c", 767; if(player_counter_anim == 1)
 5458                        		__ld.umq	_player_counter_anim
         01:C1A2  AD 18 23   			lda	_player_counter_anim
 5459                        		__equ_b.uiq	1
         01:C1A5  C9 01      			cmp	#1
         01:C1A7  F0 01      			beq	!+
         01:C1A9  18         			clc
         01:C1AA             	!:
 5460                        		__bfalse	.LL182
         01:C1AA  90 2B      			bcc	.LL182
 5461                        	
 5462                        		.dbg	line,	"include\routines_LEVELS.c", 768; {
 5463                        	
 5464                        		.dbg	line,	"include\routines_LEVELS.c", 769; set_far_base(TABLE_PLAYER_TILES_BANK[player_naked],TABLE_PLAYER_TILES_ADR[player_naked]);
 5465                        		__ldx.umq	_player_naked
         01:C1AC  AE 1B 23   			ldx	_player_naked
 5466                        		__ld.uax	_TABLE_PLAYER_TILES_BANK
         01:C1AF  BD F7 60   			lda	_TABLE_PLAYER_TILES_BANK, x
         01:C1B2  C2         			cly
 5467                        		__st.umq	_bp_bank
         01:C1B3  85 02      			sta	_bp_bank
 5468                        		__ld2x.umq	_player_naked
         01:C1B5  AD 1B 23   			lda	_player_naked
         01:C1B8  0A         			asl	a
         01:C1B9  AA         			tax
 5469                        		__ld.wax	_TABLE_PLAYER_TILES_ADR
         01:C1BA  BD F3 60   			lda.l	_TABLE_PLAYER_TILES_ADR, x
         01:C1BD  BC F4 60   			ldy.h	_TABLE_PLAYER_TILES_ADR, x
 5470                        		__st.wmq	_bp
         01:C1C0  85 EC      			sta.l	_bp
         01:C1C2  84 ED      			sty.h	_bp
 5471                        	
 5472                        		.dbg	line,	"include\routines_LEVELS.c", 770; far_load_vram(PLAYER_VRAM_ADR,TILES_16);
 5473                        		__st.wmiq	6144, _di
         01:C1C4  64 F0      			stz.l	_di
         01:C1C6  A9 18      			lda.h	#6144
         01:C1C8  85 F1      			sta.h	_di
 5474                        		__st.wmiq	256, _ax
         01:C1CA  64 F8      			stz.l	_ax
         01:C1CC  A9 01      			lda.h	#256
         01:C1CE  85 F9      			sta.h	_ax
 5475                        		 _far_load_vram.2
         01:C1D0  82         			clx				; Offset to PCE VDC.
         01:C1D1  20 63 FF   			call	load_vram_x
 5476                        	
 5477                        		.dbg	line,	"include\routines_LEVELS.c", 772; player_counter_anim = 0;
 5478                        		__st.umiq	0, _player_counter_anim
         01:C1D4  9C 18 23   			stz	_player_counter_anim
 5479                        	
 5480                        		.dbg	line,	"include\routines_LEVELS.c", 773; }
 5481                        	
 5482                        		.dbg	line,	"include\routines_LEVELS.c", 775; recenter_CAMERA();
 5483    01:C1D7             	.LL182:
 5484                        		__call		_recenter_CAMERA
         01:C1D7  20 59 FF   			call	_recenter_CAMERA
 5485                        	
 5486                        		.dbg	line,	"include\routines_LEVELS.c", 778; // CHECK COLLISION WITH LEFT FLOOR //
 5487                        	
 5488                        		.dbg	line,	"include\routines_LEVELS.c", 779; check_BG( 10 , 32 );//8
 5489                        		__ld.wi		10
         01:C1DA  A9 0A      			lda.l	#10
         01:C1DC  C2         			cly
 5490                        		__pusharg.wr
         01:C1DD  A6 8D      			ldx	<__sp
         01:C1DF  CA         			dex
         01:C1E0  CA         			dex
         01:C1E1  95 08      			sta.l	<__stack, x
         01:C1E3  94 09      			sty.h	<__stack, x
         01:C1E5  86 8D      			stx	<__sp
 5491                        		__ld.wi		32
         01:C1E7  A9 20      			lda.l	#32
         01:C1E9  C2         			cly
 5492                        		__pusharg.wr
         01:C1EA  A6 8D      			ldx	<__sp
         01:C1EC  CA         			dex
         01:C1ED  CA         			dex
         01:C1EE  95 08      			sta.l	<__stack, x
         01:C1F0  94 09      			sty.h	<__stack, x
         01:C1F2  86 8D      			stx	<__sp
 5493                        		__call		_check_BG
         01:C1F4  20 6D FF   			call	_check_BG
 5494                        	
 5495                        		.dbg	line,	"include\routines_LEVELS.c", 781; if(map_blk_flag == TILE_EMPTY)
 5496                        		__not.um	_map_blk_flag
         01:C1F7  AD AA 2B   			lda	_map_blk_flag
         01:C1FA  18         			clc
         01:C1FB  D0 01      			bne	!+
         01:C1FD  38         			sec
         01:C1FE             	!:
 5497                        		__bfalse	.LL183
         01:C1FE  B0 03 4C 9E			bcc	.LL183
         01:C202  D8          
 5498                        	
 5499                        		.dbg	line,	"include\routines_LEVELS.c", 782; {
 5500                        	
 5501                        		.dbg	line,	"include\routines_LEVELS.c", 783; // CHECK COLLISION WITH RIGHT FLOOR //
 5502                        	
 5503                        		.dbg	line,	"include\routines_LEVELS.c", 784; check_BG( 22 , 32 );//24
 5504                        		__ld.wi		22
         01:C203  A9 16      			lda.l	#22
         01:C205  C2         			cly
 5505                        		__pusharg.wr
         01:C206  A6 8D      			ldx	<__sp
         01:C208  CA         			dex
         01:C209  CA         			dex
         01:C20A  95 08      			sta.l	<__stack, x
         01:C20C  94 09      			sty.h	<__stack, x
         01:C20E  86 8D      			stx	<__sp
 5506                        		__ld.wi		32
         01:C210  A9 20      			lda.l	#32
         01:C212  C2         			cly
 5507                        		__pusharg.wr
         01:C213  A6 8D      			ldx	<__sp
         01:C215  CA         			dex
         01:C216  CA         			dex
         01:C217  95 08      			sta.l	<__stack, x
         01:C219  94 09      			sty.h	<__stack, x
         01:C21B  86 8D      			stx	<__sp
 5508                        		__call		_check_BG
         01:C21D  20 6D FF   			call	_check_BG
 5509                        	
 5510                        		.dbg	line,	"include\routines_LEVELS.c", 786; if(map_blk_flag == TILE_EMPTY)
 5511                        		__not.um	_map_blk_flag
         01:C220  AD AA 2B   			lda	_map_blk_flag
         01:C223  18         			clc
         01:C224  D0 01      			bne	!+
         01:C226  38         			sec
         01:C227             	!:
 5512                        		__bfalse	.LL184
         01:C227  B0 03 4C 9E			bcc	.LL184
         01:C22B  D8          
 5513                        	
 5514                        		.dbg	line,	"include\routines_LEVELS.c", 787; {
 5515                        	
 5516                        		.dbg	line,	"include\routines_LEVELS.c", 788; set_far_base(TABLE_PLAYER_TILES_BANK[player_naked],TABLE_PLAYER_TILES_ADR[player_naked]);
 5517                        		__ldx.umq	_player_naked
         01:C22C  AE 1B 23   			ldx	_player_naked
 5518                        		__ld.uax	_TABLE_PLAYER_TILES_BANK
         01:C22F  BD F7 60   			lda	_TABLE_PLAYER_TILES_BANK, x
         01:C232  C2         			cly
 5519                        		__st.umq	_bp_bank
         01:C233  85 02      			sta	_bp_bank
 5520                        		__ld2x.umq	_player_naked
         01:C235  AD 1B 23   			lda	_player_naked
         01:C238  0A         			asl	a
         01:C239  AA         			tax
 5521                        		__ld.wax	_TABLE_PLAYER_TILES_ADR
         01:C23A  BD F3 60   			lda.l	_TABLE_PLAYER_TILES_ADR, x
         01:C23D  BC F4 60   			ldy.h	_TABLE_PLAYER_TILES_ADR, x
 5522                        		__st.wmq	_bp
         01:C240  85 EC      			sta.l	_bp
         01:C242  84 ED      			sty.h	_bp
 5523                        	
 5524                        		.dbg	line,	"include\routines_LEVELS.c", 789; far_load_vram(PLAYER_VRAM_ADR,TILES_16);
 5525                        		__st.wmiq	6144, _di
         01:C244  64 F0      			stz.l	_di
         01:C246  A9 18      			lda.h	#6144
         01:C248  85 F1      			sta.h	_di
 5526                        		__st.wmiq	256, _ax
         01:C24A  64 F8      			stz.l	_ax
         01:C24C  A9 01      			lda.h	#256
         01:C24E  85 F9      			sta.h	_ax
 5527                        		 _far_load_vram.2
         01:C250  82         			clx				; Offset to PCE VDC.
         01:C251  20 63 FF   			call	load_vram_x
 5528                        	
 5529                        		.dbg	line,	"include\routines_LEVELS.c", 791; jump_ladder = FALSE;
 5530                        		__st.umiq	0, _jump_ladder
         01:C254  9C 1C 23   			stz	_jump_ladder
 5531                        	
 5532                        		.dbg	line,	"include\routines_LEVELS.c", 792; player_index_jump = 0;
 5533                        		__st.umiq	0, _player_index_jump
         01:C257  9C 19 23   			stz	_player_index_jump
 5534                        	
 5535                        		.dbg	line,	"include\routines_LEVELS.c", 793; player_index_fall = 0;
 5536                        		__st.umiq	0, _player_index_fall
         01:C25A  9C 1A 23   			stz	_player_index_fall
 5537                        	
 5538                        		.dbg	line,	"include\routines_LEVELS.c", 794; player_state = STATE_FALL;
 5539                        		__st.umiq	9, _player_state
         01:C25D  A9 09      			lda.l	#9
         01:C25F  8D 15 23   			sta	_player_state
 5540                        	
 5541                        		.dbg	line,	"include\routines_LEVELS.c", 795; }
 5542                        	
 5543                        		.dbg	line,	"include\routines_LEVELS.c", 796; }
 5544    01:C262             	.LL184	.alias		.LL185
 5545                        	
 5546                        		.dbg	line,	"include\routines_LEVELS.c", 797; }
 5547    01:C262             	.LL183	.alias		.LL185
 5548                        	
 5549                        		.dbg	line,	"include\routines_LEVELS.c", 800; else if(player_state == STATE_WALK)
 5550                        		__bra		.LL185
         01:C262  4C 9E D8   			bra	.LL185
 5551    01:C265             	.LL181:
 5552                        		__ld.umq	_player_state
         01:C265  AD 15 23   			lda	_player_state
 5553                        		__equ_b.uiq	1
         01:C268  C9 01      			cmp	#1
         01:C26A  F0 01      			beq	!+
         01:C26C  18         			clc
         01:C26D             	!:
 5554                        		__bfalse	.LL186
         01:C26D  B0 03 4C CB			bcc	.LL186
         01:C271  C5          
 5555                        	
 5556                        		.dbg	line,	"include\routines_LEVELS.c", 801; {
 5557                        	
 5558                        		.dbg	line,	"include\routines_LEVELS.c", 802; recenter_CAMERA();
 5559                        		__call		_recenter_CAMERA
         01:C272  20 59 FF   			call	_recenter_CAMERA
 5560                        	
 5561                        		.dbg	line,	"include\routines_LEVELS.c", 805; //--------------------------------------------------------------------------------------//
 5562                        	
 5563                        		.dbg	line,	"include\routines_LEVELS.c", 806; //                                   FLOOR COLLISION                                    //
 5564                        	
 5565                        		.dbg	line,	"include\routines_LEVELS.c", 807; //--------------------------------------------------------------------------------------//
 5566                        	
 5567                        		.dbg	line,	"include\routines_LEVELS.c", 809; // CHECK COLLISION WITH LEFT FLOOR //
 5568                        	
 5569                        		.dbg	line,	"include\routines_LEVELS.c", 810; check_BG( 10 , 32 );//8
 5570                        		__ld.wi		10
         01:C275  A9 0A      			lda.l	#10
         01:C277  C2         			cly
 5571                        		__pusharg.wr
         01:C278  A6 8D      			ldx	<__sp
         01:C27A  CA         			dex
         01:C27B  CA         			dex
         01:C27C  95 08      			sta.l	<__stack, x
         01:C27E  94 09      			sty.h	<__stack, x
         01:C280  86 8D      			stx	<__sp
 5572                        		__ld.wi		32
         01:C282  A9 20      			lda.l	#32
         01:C284  C2         			cly
 5573                        		__pusharg.wr
         01:C285  A6 8D      			ldx	<__sp
         01:C287  CA         			dex
         01:C288  CA         			dex
         01:C289  95 08      			sta.l	<__stack, x
         01:C28B  94 09      			sty.h	<__stack, x
         01:C28D  86 8D      			stx	<__sp
 5574                        		__call		_check_BG
         01:C28F  20 6D FF   			call	_check_BG
 5575                        	
 5576                        		.dbg	line,	"include\routines_LEVELS.c", 812; if(map_blk_flag == TILE_EMPTY)
 5577                        		__not.um	_map_blk_flag
         01:C292  AD AA 2B   			lda	_map_blk_flag
         01:C295  18         			clc
         01:C296  D0 01      			bne	!+
         01:C298  38         			sec
         01:C299             	!:
 5578                        		__bfalse	.LL187
         01:C299  B0 03 4C 79			bcc	.LL187
         01:C29D  C3          
 5579                        	
 5580                        		.dbg	line,	"include\routines_LEVELS.c", 813; {
 5581                        	
 5582                        		.dbg	line,	"include\routines_LEVELS.c", 814; // CHECK COLLISION WITH RIGHT FLOOR //
 5583                        	
 5584                        		.dbg	line,	"include\routines_LEVELS.c", 815; check_BG( 22 , 32 );//24
 5585                        		__ld.wi		22
         01:C29E  A9 16      			lda.l	#22
         01:C2A0  C2         			cly
 5586                        		__pusharg.wr
         01:C2A1  A6 8D      			ldx	<__sp
         01:C2A3  CA         			dex
         01:C2A4  CA         			dex
         01:C2A5  95 08      			sta.l	<__stack, x
         01:C2A7  94 09      			sty.h	<__stack, x
         01:C2A9  86 8D      			stx	<__sp
 5587                        		__ld.wi		32
         01:C2AB  A9 20      			lda.l	#32
         01:C2AD  C2         			cly
 5588                        		__pusharg.wr
         01:C2AE  A6 8D      			ldx	<__sp
         01:C2B0  CA         			dex
         01:C2B1  CA         			dex
         01:C2B2  95 08      			sta.l	<__stack, x
         01:C2B4  94 09      			sty.h	<__stack, x
         01:C2B6  86 8D      			stx	<__sp
 5589                        		__call		_check_BG
         01:C2B8  20 6D FF   			call	_check_BG
 5590                        	
 5591                        		.dbg	line,	"include\routines_LEVELS.c", 817; if(map_blk_flag == TILE_EMPTY)
 5592                        		__not.um	_map_blk_flag
         01:C2BB  AD AA 2B   			lda	_map_blk_flag
         01:C2BE  18         			clc
         01:C2BF  D0 01      			bne	!+
         01:C2C1  38         			sec
         01:C2C2             	!:
 5593                        		__bfalse	.LL188
         01:C2C2  90 39      			bcc	.LL188
 5594                        	
 5595                        		.dbg	line,	"include\routines_LEVELS.c", 818; {
 5596                        	
 5597                        		.dbg	line,	"include\routines_LEVELS.c", 819; set_far_base(TABLE_PLAYER_TILES_BANK[player_naked],TABLE_PLAYER_TILES_ADR[player_naked]);
 5598                        		__ldx.umq	_player_naked
         01:C2C4  AE 1B 23   			ldx	_player_naked
 5599                        		__ld.uax	_TABLE_PLAYER_TILES_BANK
         01:C2C7  BD F7 60   			lda	_TABLE_PLAYER_TILES_BANK, x
         01:C2CA  C2         			cly
 5600                        		__st.umq	_bp_bank
         01:C2CB  85 02      			sta	_bp_bank
 5601                        		__ld2x.umq	_player_naked
         01:C2CD  AD 1B 23   			lda	_player_naked
         01:C2D0  0A         			asl	a
         01:C2D1  AA         			tax
 5602                        		__ld.wax	_TABLE_PLAYER_TILES_ADR
         01:C2D2  BD F3 60   			lda.l	_TABLE_PLAYER_TILES_ADR, x
         01:C2D5  BC F4 60   			ldy.h	_TABLE_PLAYER_TILES_ADR, x
 5603                        		__st.wmq	_bp
         01:C2D8  85 EC      			sta.l	_bp
         01:C2DA  84 ED      			sty.h	_bp
 5604                        	
 5605                        		.dbg	line,	"include\routines_LEVELS.c", 820; far_load_vram(PLAYER_VRAM_ADR,TILES_16);
 5606                        		__st.wmiq	6144, _di
         01:C2DC  64 F0      			stz.l	_di
         01:C2DE  A9 18      			lda.h	#6144
         01:C2E0  85 F1      			sta.h	_di
 5607                        		__st.wmiq	256, _ax
         01:C2E2  64 F8      			stz.l	_ax
         01:C2E4  A9 01      			lda.h	#256
         01:C2E6  85 F9      			sta.h	_ax
 5608                        		 _far_load_vram.2
         01:C2E8  82         			clx				; Offset to PCE VDC.
         01:C2E9  20 63 FF   			call	load_vram_x
 5609                        	
 5610                        		.dbg	line,	"include\routines_LEVELS.c", 822; jump_ladder = FALSE;
 5611                        		__st.umiq	0, _jump_ladder
         01:C2EC  9C 1C 23   			stz	_jump_ladder
 5612                        	
 5613                        		.dbg	line,	"include\routines_LEVELS.c", 823; player_index_jump = 0;
 5614                        		__st.umiq	0, _player_index_jump
         01:C2EF  9C 19 23   			stz	_player_index_jump
 5615                        	
 5616                        		.dbg	line,	"include\routines_LEVELS.c", 824; player_index_fall = 0;
 5617                        		__st.umiq	0, _player_index_fall
         01:C2F2  9C 1A 23   			stz	_player_index_fall
 5618                        	
 5619                        		.dbg	line,	"include\routines_LEVELS.c", 825; player_state = STATE_FALL;
 5620                        		__st.umiq	9, _player_state
         01:C2F5  A9 09      			lda.l	#9
         01:C2F7  8D 15 23   			sta	_player_state
 5621                        	
 5622                        		.dbg	line,	"include\routines_LEVELS.c", 826; }
 5623                        	
 5624                        		.dbg	line,	"include\routines_LEVELS.c", 828; else
 5625                        		__bra		.LL189
         01:C2FA  4C EC C3   			bra	.LL189
 5626    01:C2FD             	.LL188:
 5627                        	
 5628                        		.dbg	line,	"include\routines_LEVELS.c", 829; {
 5629                        	
 5630                        		.dbg	line,	"include\routines_LEVELS.c", 830; if(player_axis == AXIS_RIGHT)
 5631                        		__not.um	_player_axis
         01:C2FD  AD 16 23   			lda	_player_axis
         01:C300  18         			clc
         01:C301  D0 01      			bne	!+
         01:C303  38         			sec
         01:C304             	!:
 5632                        		__bfalse	.LL190
         01:C304  90 3A      			bcc	.LL190
 5633                        	
 5634                        		.dbg	line,	"include\routines_LEVELS.c", 831; {
 5635                        	
 5636                        		.dbg	line,	"include\routines_LEVELS.c", 832; // CHECK COLLISION WITH RIGHT WALL //
 5637                        	
 5638                        		.dbg	line,	"include\routines_LEVELS.c", 833; check_BG( 24 , 31 ); // 24+2
 5639                        		__ld.wi		24
         01:C306  A9 18      			lda.l	#24
         01:C308  C2         			cly
 5640                        		__pusharg.wr
         01:C309  A6 8D      			ldx	<__sp
         01:C30B  CA         			dex
         01:C30C  CA         			dex
         01:C30D  95 08      			sta.l	<__stack, x
         01:C30F  94 09      			sty.h	<__stack, x
         01:C311  86 8D      			stx	<__sp
 5641                        		__ld.wi		31
         01:C313  A9 1F      			lda.l	#31
         01:C315  C2         			cly
 5642                        		__pusharg.wr
         01:C316  A6 8D      			ldx	<__sp
         01:C318  CA         			dex
         01:C319  CA         			dex
         01:C31A  95 08      			sta.l	<__stack, x
         01:C31C  94 09      			sty.h	<__stack, x
         01:C31E  86 8D      			stx	<__sp
 5643                        		__call		_check_BG
         01:C320  20 6D FF   			call	_check_BG
 5644                        	
 5645                        		.dbg	line,	"include\routines_LEVELS.c", 835; if(map_blk_flag == TILE_EMPTY)
 5646                        		__not.um	_map_blk_flag
         01:C323  AD AA 2B   			lda	_map_blk_flag
         01:C326  18         			clc
         01:C327  D0 01      			bne	!+
         01:C329  38         			sec
         01:C32A             	!:
 5647                        		__bfalse	.LL191
         01:C32A  B0 03 4C EC			bcc	.LL191
         01:C32E  C3          
 5648                        	
 5649                        		.dbg	line,	"include\routines_LEVELS.c", 836; {
 5650                        	
 5651                        		.dbg	line,	"include\routines_LEVELS.c", 837; sgx_map_pxl_x += 2;
 5652                        		__add_st.wmiq	2, _sgx_map_pxl_x
         01:C32F  18         			clc
         01:C330  AD 89 26   			lda.l	_sgx_map_pxl_x
         01:C333  69 02      			adc.l	#2
         01:C335  8D 89 26   			sta.l	_sgx_map_pxl_x
         01:C338  90 03      			bcc	!+
         01:C33A  EE 8A 26   			inc.h	_sgx_map_pxl_x
         01:C33D             	!:
 5653                        	
 5654                        		.dbg	line,	"include\routines_LEVELS.c", 838; }
 5655                        	
 5656                        		.dbg	line,	"include\routines_LEVELS.c", 839; }
 5657    01:C33D             	.LL191	.alias		.LL192
 5658                        	
 5659                        		.dbg	line,	"include\routines_LEVELS.c", 841; else
 5660                        		__bra		.LL192
         01:C33D  4C EC C3   			bra	.LL192
 5661    01:C340             	.LL190:
 5662                        	
 5663                        		.dbg	line,	"include\routines_LEVELS.c", 842; {
 5664                        	
 5665                        		.dbg	line,	"include\routines_LEVELS.c", 843; // CHECK COLLISION WITH LEFT WALL //
 5666                        	
 5667                        		.dbg	line,	"include\routines_LEVELS.c", 844; check_BG( 8 , 31 ); // 8-2
 5668                        		__ld.wi		8
         01:C340  A9 08      			lda.l	#8
         01:C342  C2         			cly
 5669                        		__pusharg.wr
         01:C343  A6 8D      			ldx	<__sp
         01:C345  CA         			dex
         01:C346  CA         			dex
         01:C347  95 08      			sta.l	<__stack, x
         01:C349  94 09      			sty.h	<__stack, x
         01:C34B  86 8D      			stx	<__sp
 5670                        		__ld.wi		31
         01:C34D  A9 1F      			lda.l	#31
         01:C34F  C2         			cly
 5671                        		__pusharg.wr
         01:C350  A6 8D      			ldx	<__sp
         01:C352  CA         			dex
         01:C353  CA         			dex
         01:C354  95 08      			sta.l	<__stack, x
         01:C356  94 09      			sty.h	<__stack, x
         01:C358  86 8D      			stx	<__sp
 5672                        		__call		_check_BG
         01:C35A  20 6D FF   			call	_check_BG
 5673                        	
 5674                        		.dbg	line,	"include\routines_LEVELS.c", 846; if(map_blk_flag == TILE_EMPTY)
 5675                        		__not.um	_map_blk_flag
         01:C35D  AD AA 2B   			lda	_map_blk_flag
         01:C360  18         			clc
         01:C361  D0 01      			bne	!+
         01:C363  38         			sec
         01:C364             	!:
 5676                        		__bfalse	.LL193
         01:C364  B0 03 4C EC			bcc	.LL193
         01:C368  C3          
 5677                        	
 5678                        		.dbg	line,	"include\routines_LEVELS.c", 847; {
 5679                        	
 5680                        		.dbg	line,	"include\routines_LEVELS.c", 848; sgx_map_pxl_x -= 2;
 5681                        		__sub_st.wmiq	2, _sgx_map_pxl_x
         01:C369  38         			sec
         01:C36A  AD 89 26   			lda.l	_sgx_map_pxl_x
         01:C36D  E9 02      			sbc.l	#2
         01:C36F  8D 89 26   			sta.l	_sgx_map_pxl_x
         01:C372  B0 03      			bcs	!+
         01:C374  CE 8A 26   			dec.h	_sgx_map_pxl_x
         01:C377             	!:
 5682                        	
 5683                        		.dbg	line,	"include\routines_LEVELS.c", 849; }
 5684                        	
 5685                        		.dbg	line,	"include\routines_LEVELS.c", 850; }
 5686    01:C377             	.LL193	.alias		.LL194
 5687    01:C377             	.LL192	.alias		.LL194
 5688                        	
 5689                        		.dbg	line,	"include\routines_LEVELS.c", 851; }
 5690    01:C377             	.LL189	.alias		.LL194
 5691                        	
 5692                        		.dbg	line,	"include\routines_LEVELS.c", 852; }
 5693                        	
 5694                        		.dbg	line,	"include\routines_LEVELS.c", 854; else
 5695                        		__bra		.LL194
         01:C377  80 73      			bra	.LL194
 5696    01:C379             	.LL187:
 5697                        	
 5698                        		.dbg	line,	"include\routines_LEVELS.c", 855; {
 5699                        	
 5700                        		.dbg	line,	"include\routines_LEVELS.c", 856; if(player_axis == AXIS_RIGHT)
 5701                        		__not.um	_player_axis
         01:C379  AD 16 23   			lda	_player_axis
         01:C37C  18         			clc
         01:C37D  D0 01      			bne	!+
         01:C37F  38         			sec
         01:C380             	!:
 5702                        		__bfalse	.LL195
         01:C380  90 36      			bcc	.LL195
 5703                        	
 5704                        		.dbg	line,	"include\routines_LEVELS.c", 857; {
 5705                        	
 5706                        		.dbg	line,	"include\routines_LEVELS.c", 858; // CHECK COLLISION WITH RIGHT WALL //
 5707                        	
 5708                        		.dbg	line,	"include\routines_LEVELS.c", 859; check_BG( 24 , 31 ); // 24+2
 5709                        		__ld.wi		24
         01:C382  A9 18      			lda.l	#24
         01:C384  C2         			cly
 5710                        		__pusharg.wr
         01:C385  A6 8D      			ldx	<__sp
         01:C387  CA         			dex
         01:C388  CA         			dex
         01:C389  95 08      			sta.l	<__stack, x
         01:C38B  94 09      			sty.h	<__stack, x
         01:C38D  86 8D      			stx	<__sp
 5711                        		__ld.wi		31
         01:C38F  A9 1F      			lda.l	#31
         01:C391  C2         			cly
 5712                        		__pusharg.wr
         01:C392  A6 8D      			ldx	<__sp
         01:C394  CA         			dex
         01:C395  CA         			dex
         01:C396  95 08      			sta.l	<__stack, x
         01:C398  94 09      			sty.h	<__stack, x
         01:C39A  86 8D      			stx	<__sp
 5713                        		__call		_check_BG
         01:C39C  20 6D FF   			call	_check_BG
 5714                        	
 5715                        		.dbg	line,	"include\routines_LEVELS.c", 861; if(map_blk_flag == TILE_EMPTY)
 5716                        		__not.um	_map_blk_flag
         01:C39F  AD AA 2B   			lda	_map_blk_flag
         01:C3A2  18         			clc
         01:C3A3  D0 01      			bne	!+
         01:C3A5  38         			sec
         01:C3A6             	!:
 5717                        		__bfalse	.LL196
         01:C3A6  90 44      			bcc	.LL196
 5718                        	
 5719                        		.dbg	line,	"include\routines_LEVELS.c", 862; {
 5720                        	
 5721                        		.dbg	line,	"include\routines_LEVELS.c", 863; sgx_map_pxl_x += 2;
 5722                        		__add_st.wmiq	2, _sgx_map_pxl_x
         01:C3A8  18         			clc
         01:C3A9  AD 89 26   			lda.l	_sgx_map_pxl_x
         01:C3AC  69 02      			adc.l	#2
         01:C3AE  8D 89 26   			sta.l	_sgx_map_pxl_x
         01:C3B1  90 03      			bcc	!+
         01:C3B3  EE 8A 26   			inc.h	_sgx_map_pxl_x
         01:C3B6             	!:
 5723                        	
 5724                        		.dbg	line,	"include\routines_LEVELS.c", 864; }
 5725                        	
 5726                        		.dbg	line,	"include\routines_LEVELS.c", 865; }
 5727    01:C3B6             	.LL196	.alias		.LL197
 5728                        	
 5729                        		.dbg	line,	"include\routines_LEVELS.c", 867; else
 5730                        		__bra		.LL197
         01:C3B6  80 34      			bra	.LL197
 5731    01:C3B8             	.LL195:
 5732                        	
 5733                        		.dbg	line,	"include\routines_LEVELS.c", 868; {
 5734                        	
 5735                        		.dbg	line,	"include\routines_LEVELS.c", 869; // CHECK COLLISION WITH LEFT WALL //
 5736                        	
 5737                        		.dbg	line,	"include\routines_LEVELS.c", 870; check_BG( 8 , 31 ); // 8-2
 5738                        		__ld.wi		8
         01:C3B8  A9 08      			lda.l	#8
         01:C3BA  C2         			cly
 5739                        		__pusharg.wr
         01:C3BB  A6 8D      			ldx	<__sp
         01:C3BD  CA         			dex
         01:C3BE  CA         			dex
         01:C3BF  95 08      			sta.l	<__stack, x
         01:C3C1  94 09      			sty.h	<__stack, x
         01:C3C3  86 8D      			stx	<__sp
 5740                        		__ld.wi		31
         01:C3C5  A9 1F      			lda.l	#31
         01:C3C7  C2         			cly
 5741                        		__pusharg.wr
         01:C3C8  A6 8D      			ldx	<__sp
         01:C3CA  CA         			dex
         01:C3CB  CA         			dex
         01:C3CC  95 08      			sta.l	<__stack, x
         01:C3CE  94 09      			sty.h	<__stack, x
         01:C3D0  86 8D      			stx	<__sp
 5742                        		__call		_check_BG
         01:C3D2  20 6D FF   			call	_check_BG
 5743                        	
 5744                        		.dbg	line,	"include\routines_LEVELS.c", 872; if(map_blk_flag == TILE_EMPTY)
 5745                        		__not.um	_map_blk_flag
         01:C3D5  AD AA 2B   			lda	_map_blk_flag
         01:C3D8  18         			clc
         01:C3D9  D0 01      			bne	!+
         01:C3DB  38         			sec
         01:C3DC             	!:
 5746                        		__bfalse	.LL198
         01:C3DC  90 0E      			bcc	.LL198
 5747                        	
 5748                        		.dbg	line,	"include\routines_LEVELS.c", 873; {
 5749                        	
 5750                        		.dbg	line,	"include\routines_LEVELS.c", 874; sgx_map_pxl_x -= 2;
 5751                        		__sub_st.wmiq	2, _sgx_map_pxl_x
         01:C3DE  38         			sec
         01:C3DF  AD 89 26   			lda.l	_sgx_map_pxl_x
         01:C3E2  E9 02      			sbc.l	#2
         01:C3E4  8D 89 26   			sta.l	_sgx_map_pxl_x
         01:C3E7  B0 03      			bcs	!+
         01:C3E9  CE 8A 26   			dec.h	_sgx_map_pxl_x
         01:C3EC             	!:
 5752                        	
 5753                        		.dbg	line,	"include\routines_LEVELS.c", 875; }
 5754                        	
 5755                        		.dbg	line,	"include\routines_LEVELS.c", 876; }
 5756    01:C3EC             	.LL198:
 5757    01:C3EC             	.LL197:
 5758                        	
 5759                        		.dbg	line,	"include\routines_LEVELS.c", 877; }
 5760    01:C3EC             	.LL194:
 5761                        	
 5762                        		.dbg	line,	"include\routines_LEVELS.c", 882; spr_set(player_id);
 5763                        		__ld.umq	_player_id
         01:C3EC  AD 14 23   			lda	_player_id
 5764                        		__call		_spr_set.1
         01:C3EF  20 DD E7   			call	_spr_set.1
 5765                        	
 5766                        		.dbg	line,	"include\routines_LEVELS.c", 885; // UPDATE PLAYER TILES //
 5767                        	
 5768                        		.dbg	line,	"include\routines_LEVELS.c", 886; if(player_counter_anim == 0)
 5769                        		__not.um	_player_counter_anim
         01:C3F2  AD 18 23   			lda	_player_counter_anim
         01:C3F5  18         			clc
         01:C3F6  D0 01      			bne	!+
         01:C3F8  38         			sec
         01:C3F9             	!:
 5770                        		__bfalse	.LL199
         01:C3F9  90 2B      			bcc	.LL199
 5771                        	
 5772                        		.dbg	line,	"include\routines_LEVELS.c", 887; {
 5773                        	
 5774                        		.dbg	line,	"include\routines_LEVELS.c", 888; set_far_base(TABLE_PLAYER_TILES_BANK[player_naked],TABLE_PLAYER_TILES_ADR[player_naked]);
 5775                        		__ldx.umq	_player_naked
         01:C3FB  AE 1B 23   			ldx	_player_naked
 5776                        		__ld.uax	_TABLE_PLAYER_TILES_BANK
         01:C3FE  BD F7 60   			lda	_TABLE_PLAYER_TILES_BANK, x
         01:C401  C2         			cly
 5777                        		__st.umq	_bp_bank
         01:C402  85 02      			sta	_bp_bank
 5778                        		__ld2x.umq	_player_naked
         01:C404  AD 1B 23   			lda	_player_naked
         01:C407  0A         			asl	a
         01:C408  AA         			tax
 5779                        		__ld.wax	_TABLE_PLAYER_TILES_ADR
         01:C409  BD F3 60   			lda.l	_TABLE_PLAYER_TILES_ADR, x
         01:C40C  BC F4 60   			ldy.h	_TABLE_PLAYER_TILES_ADR, x
 5780                        		__st.wmq	_bp
         01:C40F  85 EC      			sta.l	_bp
         01:C411  84 ED      			sty.h	_bp
 5781                        	
 5782                        		.dbg	line,	"include\routines_LEVELS.c", 889; far_load_vram(PLAYER_VRAM_ADR,TILES_16);
 5783                        		__st.wmiq	6144, _di
         01:C413  64 F0      			stz.l	_di
         01:C415  A9 18      			lda.h	#6144
         01:C417  85 F1      			sta.h	_di
 5784                        		__st.wmiq	256, _ax
         01:C419  64 F8      			stz.l	_ax
         01:C41B  A9 01      			lda.h	#256
         01:C41D  85 F9      			sta.h	_ax
 5785                        		 _far_load_vram.2
         01:C41F  82         			clx				; Offset to PCE VDC.
         01:C420  20 63 FF   			call	load_vram_x
 5786                        	
 5787                        		.dbg	line,	"include\routines_LEVELS.c", 890; }
 5788                        	
 5789                        		.dbg	line,	"include\routines_LEVELS.c", 893; else if(player_counter_anim == 2)
 5790                        		__bra		.LL200
         01:C423  4C C5 C5   			bra	.LL200
 5791    01:C426             	.LL199:
 5792                        		__ld.umq	_player_counter_anim
         01:C426  AD 18 23   			lda	_player_counter_anim
 5793                        		__equ_b.uiq	2
         01:C429  C9 02      			cmp	#2
         01:C42B  F0 01      			beq	!+
         01:C42D  18         			clc
         01:C42E             	!:
 5794                        		__bfalse	.LL201
         01:C42E  90 30      			bcc	.LL201
 5795                        	
 5796                        		.dbg	line,	"include\routines_LEVELS.c", 894; {
 5797                        	
 5798                        		.dbg	line,	"include\routines_LEVELS.c", 895; set_far_offset(OFFSET_PLAYER_WALK_1,TABLE_PLAYER_TILES_BANK[player_naked],TABLE_PLAYER_TILES_ADR[player_naked]);
 5799                        		__st.wmiq	512, _bp
         01:C430  64 EC      			stz.l	_bp
         01:C432  A9 02      			lda.h	#512
         01:C434  85 ED      			sta.h	_bp
 5800                        		__ldx.umq	_player_naked
         01:C436  AE 1B 23   			ldx	_player_naked
 5801                        		__ld.uax	_TABLE_PLAYER_TILES_BANK
         01:C439  BD F7 60   			lda	_TABLE_PLAYER_TILES_BANK, x
         01:C43C  C2         			cly
 5802                        		__st.umq	_bp_bank
         01:C43D  85 02      			sta	_bp_bank
 5803                        		__ld2x.umq	_player_naked
         01:C43F  AD 1B 23   			lda	_player_naked
         01:C442  0A         			asl	a
         01:C443  AA         			tax
 5804                        		__ld.wax	_TABLE_PLAYER_TILES_ADR
         01:C444  BD F3 60   			lda.l	_TABLE_PLAYER_TILES_ADR, x
         01:C447  BC F4 60   			ldy.h	_TABLE_PLAYER_TILES_ADR, x
 5805                        		__call		_set_far_offset.3
         01:C44A  20 8C E2   			call	_set_far_offset.3
 5806                        	
 5807                        		.dbg	line,	"include\routines_LEVELS.c", 896; far_load_vram(PLAYER_VRAM_ADR,TILES_16);            
 5808                        		__st.wmiq	6144, _di
         01:C44D  64 F0      			stz.l	_di
         01:C44F  A9 18      			lda.h	#6144
         01:C451  85 F1      			sta.h	_di
 5809                        		__st.wmiq	256, _ax
         01:C453  64 F8      			stz.l	_ax
         01:C455  A9 01      			lda.h	#256
         01:C457  85 F9      			sta.h	_ax
 5810                        		 _far_load_vram.2
         01:C459  82         			clx				; Offset to PCE VDC.
         01:C45A  20 63 FF   			call	load_vram_x
 5811                        	
 5812                        		.dbg	line,	"include\routines_LEVELS.c", 897; }
 5813                        	
 5814                        		.dbg	line,	"include\routines_LEVELS.c", 900; else if(player_counter_anim == 5)
 5815                        		__bra		.LL202
         01:C45D  4C C5 C5   			bra	.LL202
 5816    01:C460             	.LL201:
 5817                        		__ld.umq	_player_counter_anim
         01:C460  AD 18 23   			lda	_player_counter_anim
 5818                        		__equ_b.uiq	5
         01:C463  C9 05      			cmp	#5
         01:C465  F0 01      			beq	!+
         01:C467  18         			clc
         01:C468             	!:
 5819                        		__bfalse	.LL203
         01:C468  90 30      			bcc	.LL203
 5820                        	
 5821                        		.dbg	line,	"include\routines_LEVELS.c", 901; {
 5822                        	
 5823                        		.dbg	line,	"include\routines_LEVELS.c", 902; set_far_offset(OFFSET_PLAYER_WALK_2,TABLE_PLAYER_TILES_BANK[player_naked],TABLE_PLAYER_TILES_ADR[player_naked]);
 5824                        		__st.wmiq	1024, _bp
         01:C46A  64 EC      			stz.l	_bp
         01:C46C  A9 04      			lda.h	#1024
         01:C46E  85 ED      			sta.h	_bp
 5825                        		__ldx.umq	_player_naked
         01:C470  AE 1B 23   			ldx	_player_naked
 5826                        		__ld.uax	_TABLE_PLAYER_TILES_BANK
         01:C473  BD F7 60   			lda	_TABLE_PLAYER_TILES_BANK, x
         01:C476  C2         			cly
 5827                        		__st.umq	_bp_bank
         01:C477  85 02      			sta	_bp_bank
 5828                        		__ld2x.umq	_player_naked
         01:C479  AD 1B 23   			lda	_player_naked
         01:C47C  0A         			asl	a
         01:C47D  AA         			tax
 5829                        		__ld.wax	_TABLE_PLAYER_TILES_ADR
         01:C47E  BD F3 60   			lda.l	_TABLE_PLAYER_TILES_ADR, x
         01:C481  BC F4 60   			ldy.h	_TABLE_PLAYER_TILES_ADR, x
 5830                        		__call		_set_far_offset.3
         01:C484  20 8C E2   			call	_set_far_offset.3
 5831                        	
 5832                        		.dbg	line,	"include\routines_LEVELS.c", 903; far_load_vram(PLAYER_VRAM_ADR,TILES_16);             
 5833                        		__st.wmiq	6144, _di
         01:C487  64 F0      			stz.l	_di
         01:C489  A9 18      			lda.h	#6144
         01:C48B  85 F1      			sta.h	_di
 5834                        		__st.wmiq	256, _ax
         01:C48D  64 F8      			stz.l	_ax
         01:C48F  A9 01      			lda.h	#256
         01:C491  85 F9      			sta.h	_ax
 5835                        		 _far_load_vram.2
         01:C493  82         			clx				; Offset to PCE VDC.
         01:C494  20 63 FF   			call	load_vram_x
 5836                        	
 5837                        		.dbg	line,	"include\routines_LEVELS.c", 904; }
 5838                        	
 5839                        		.dbg	line,	"include\routines_LEVELS.c", 907; else if(player_counter_anim == 8)
 5840                        		__bra		.LL204
         01:C497  4C C5 C5   			bra	.LL204
 5841    01:C49A             	.LL203:
 5842                        		__ld.umq	_player_counter_anim
         01:C49A  AD 18 23   			lda	_player_counter_anim
 5843                        		__equ_b.uiq	8
         01:C49D  C9 08      			cmp	#8
         01:C49F  F0 01      			beq	!+
         01:C4A1  18         			clc
         01:C4A2             	!:
 5844                        		__bfalse	.LL205
         01:C4A2  90 30      			bcc	.LL205
 5845                        	
 5846                        		.dbg	line,	"include\routines_LEVELS.c", 908; {
 5847                        	
 5848                        		.dbg	line,	"include\routines_LEVELS.c", 909; set_far_offset(OFFSET_PLAYER_WALK_3,TABLE_PLAYER_TILES_BANK[player_naked],TABLE_PLAYER_TILES_ADR[player_naked]);
 5849                        		__st.wmiq	1536, _bp
         01:C4A4  64 EC      			stz.l	_bp
         01:C4A6  A9 06      			lda.h	#1536
         01:C4A8  85 ED      			sta.h	_bp
 5850                        		__ldx.umq	_player_naked
         01:C4AA  AE 1B 23   			ldx	_player_naked
 5851                        		__ld.uax	_TABLE_PLAYER_TILES_BANK
         01:C4AD  BD F7 60   			lda	_TABLE_PLAYER_TILES_BANK, x
         01:C4B0  C2         			cly
 5852                        		__st.umq	_bp_bank
         01:C4B1  85 02      			sta	_bp_bank
 5853                        		__ld2x.umq	_player_naked
         01:C4B3  AD 1B 23   			lda	_player_naked
         01:C4B6  0A         			asl	a
         01:C4B7  AA         			tax
 5854                        		__ld.wax	_TABLE_PLAYER_TILES_ADR
         01:C4B8  BD F3 60   			lda.l	_TABLE_PLAYER_TILES_ADR, x
         01:C4BB  BC F4 60   			ldy.h	_TABLE_PLAYER_TILES_ADR, x
 5855                        		__call		_set_far_offset.3
         01:C4BE  20 8C E2   			call	_set_far_offset.3
 5856                        	
 5857                        		.dbg	line,	"include\routines_LEVELS.c", 910; far_load_vram(PLAYER_VRAM_ADR,TILES_16);              
 5858                        		__st.wmiq	6144, _di
         01:C4C1  64 F0      			stz.l	_di
         01:C4C3  A9 18      			lda.h	#6144
         01:C4C5  85 F1      			sta.h	_di
 5859                        		__st.wmiq	256, _ax
         01:C4C7  64 F8      			stz.l	_ax
         01:C4C9  A9 01      			lda.h	#256
         01:C4CB  85 F9      			sta.h	_ax
 5860                        		 _far_load_vram.2
         01:C4CD  82         			clx				; Offset to PCE VDC.
         01:C4CE  20 63 FF   			call	load_vram_x
 5861                        	
 5862                        		.dbg	line,	"include\routines_LEVELS.c", 911; }
 5863                        	
 5864                        		.dbg	line,	"include\routines_LEVELS.c", 914; else if(player_counter_anim == 11)
 5865                        		__bra		.LL206
         01:C4D1  4C C5 C5   			bra	.LL206
 5866    01:C4D4             	.LL205:
 5867                        		__ld.umq	_player_counter_anim
         01:C4D4  AD 18 23   			lda	_player_counter_anim
 5868                        		__equ_b.uiq	11
         01:C4D7  C9 0B      			cmp	#11
         01:C4D9  F0 01      			beq	!+
         01:C4DB  18         			clc
         01:C4DC             	!:
 5869                        		__bfalse	.LL207
         01:C4DC  90 2B      			bcc	.LL207
 5870                        	
 5871                        		.dbg	line,	"include\routines_LEVELS.c", 915; {
 5872                        	
 5873                        		.dbg	line,	"include\routines_LEVELS.c", 916; set_far_base(TABLE_PLAYER_TILES_BANK[player_naked],TABLE_PLAYER_TILES_ADR[player_naked]);
 5874                        		__ldx.umq	_player_naked
         01:C4DE  AE 1B 23   			ldx	_player_naked
 5875                        		__ld.uax	_TABLE_PLAYER_TILES_BANK
         01:C4E1  BD F7 60   			lda	_TABLE_PLAYER_TILES_BANK, x
         01:C4E4  C2         			cly
 5876                        		__st.umq	_bp_bank
         01:C4E5  85 02      			sta	_bp_bank
 5877                        		__ld2x.umq	_player_naked
         01:C4E7  AD 1B 23   			lda	_player_naked
         01:C4EA  0A         			asl	a
         01:C4EB  AA         			tax
 5878                        		__ld.wax	_TABLE_PLAYER_TILES_ADR
         01:C4EC  BD F3 60   			lda.l	_TABLE_PLAYER_TILES_ADR, x
         01:C4EF  BC F4 60   			ldy.h	_TABLE_PLAYER_TILES_ADR, x
 5879                        		__st.wmq	_bp
         01:C4F2  85 EC      			sta.l	_bp
         01:C4F4  84 ED      			sty.h	_bp
 5880                        	
 5881                        		.dbg	line,	"include\routines_LEVELS.c", 917; far_load_vram(PLAYER_VRAM_ADR,TILES_16);            
 5882                        		__st.wmiq	6144, _di
         01:C4F6  64 F0      			stz.l	_di
         01:C4F8  A9 18      			lda.h	#6144
         01:C4FA  85 F1      			sta.h	_di
 5883                        		__st.wmiq	256, _ax
         01:C4FC  64 F8      			stz.l	_ax
         01:C4FE  A9 01      			lda.h	#256
         01:C500  85 F9      			sta.h	_ax
 5884                        		 _far_load_vram.2
         01:C502  82         			clx				; Offset to PCE VDC.
         01:C503  20 63 FF   			call	load_vram_x
 5885                        	
 5886                        		.dbg	line,	"include\routines_LEVELS.c", 918; }
 5887                        	
 5888                        		.dbg	line,	"include\routines_LEVELS.c", 921; else if(player_counter_anim == 14)
 5889                        		__bra		.LL208
         01:C506  4C C5 C5   			bra	.LL208
 5890    01:C509             	.LL207:
 5891                        		__ld.umq	_player_counter_anim
         01:C509  AD 18 23   			lda	_player_counter_anim
 5892                        		__equ_b.uiq	14
         01:C50C  C9 0E      			cmp	#14
         01:C50E  F0 01      			beq	!+
         01:C510  18         			clc
         01:C511             	!:
 5893                        		__bfalse	.LL209
         01:C511  90 30      			bcc	.LL209
 5894                        	
 5895                        		.dbg	line,	"include\routines_LEVELS.c", 922; {
 5896                        	
 5897                        		.dbg	line,	"include\routines_LEVELS.c", 923; set_far_offset(OFFSET_PLAYER_WALK_4,TABLE_PLAYER_TILES_BANK[player_naked],TABLE_PLAYER_TILES_ADR[player_naked]);
 5898                        		__st.wmiq	2048, _bp
         01:C513  64 EC      			stz.l	_bp
         01:C515  A9 08      			lda.h	#2048
         01:C517  85 ED      			sta.h	_bp
 5899                        		__ldx.umq	_player_naked
         01:C519  AE 1B 23   			ldx	_player_naked
 5900                        		__ld.uax	_TABLE_PLAYER_TILES_BANK
         01:C51C  BD F7 60   			lda	_TABLE_PLAYER_TILES_BANK, x
         01:C51F  C2         			cly
 5901                        		__st.umq	_bp_bank
         01:C520  85 02      			sta	_bp_bank
 5902                        		__ld2x.umq	_player_naked
         01:C522  AD 1B 23   			lda	_player_naked
         01:C525  0A         			asl	a
         01:C526  AA         			tax
 5903                        		__ld.wax	_TABLE_PLAYER_TILES_ADR
         01:C527  BD F3 60   			lda.l	_TABLE_PLAYER_TILES_ADR, x
         01:C52A  BC F4 60   			ldy.h	_TABLE_PLAYER_TILES_ADR, x
 5904                        		__call		_set_far_offset.3
         01:C52D  20 8C E2   			call	_set_far_offset.3
 5905                        	
 5906                        		.dbg	line,	"include\routines_LEVELS.c", 924; far_load_vram(PLAYER_VRAM_ADR,TILES_16);            
 5907                        		__st.wmiq	6144, _di
         01:C530  64 F0      			stz.l	_di
         01:C532  A9 18      			lda.h	#6144
         01:C534  85 F1      			sta.h	_di
 5908                        		__st.wmiq	256, _ax
         01:C536  64 F8      			stz.l	_ax
         01:C538  A9 01      			lda.h	#256
         01:C53A  85 F9      			sta.h	_ax
 5909                        		 _far_load_vram.2
         01:C53C  82         			clx				; Offset to PCE VDC.
         01:C53D  20 63 FF   			call	load_vram_x
 5910                        	
 5911                        		.dbg	line,	"include\routines_LEVELS.c", 925; }
 5912                        	
 5913                        		.dbg	line,	"include\routines_LEVELS.c", 928; else if(player_counter_anim == 17)
 5914                        		__bra		.LL210
         01:C540  4C C5 C5   			bra	.LL210
 5915    01:C543             	.LL209:
 5916                        		__ld.umq	_player_counter_anim
         01:C543  AD 18 23   			lda	_player_counter_anim
 5917                        		__equ_b.uiq	17
         01:C546  C9 11      			cmp	#17
         01:C548  F0 01      			beq	!+
         01:C54A  18         			clc
         01:C54B             	!:
 5918                        		__bfalse	.LL211
         01:C54B  90 2F      			bcc	.LL211
 5919                        	
 5920                        		.dbg	line,	"include\routines_LEVELS.c", 929; {
 5921                        	
 5922                        		.dbg	line,	"include\routines_LEVELS.c", 930; set_far_offset(OFFSET_PLAYER_WALK_5,TABLE_PLAYER_TILES_BANK[player_naked],TABLE_PLAYER_TILES_ADR[player_naked]);
 5923                        		__st.wmiq	2560, _bp
         01:C54D  64 EC      			stz.l	_bp
         01:C54F  A9 0A      			lda.h	#2560
         01:C551  85 ED      			sta.h	_bp
 5924                        		__ldx.umq	_player_naked
         01:C553  AE 1B 23   			ldx	_player_naked
 5925                        		__ld.uax	_TABLE_PLAYER_TILES_BANK
         01:C556  BD F7 60   			lda	_TABLE_PLAYER_TILES_BANK, x
         01:C559  C2         			cly
 5926                        		__st.umq	_bp_bank
         01:C55A  85 02      			sta	_bp_bank
 5927                        		__ld2x.umq	_player_naked
         01:C55C  AD 1B 23   			lda	_player_naked
         01:C55F  0A         			asl	a
         01:C560  AA         			tax
 5928                        		__ld.wax	_TABLE_PLAYER_TILES_ADR
         01:C561  BD F3 60   			lda.l	_TABLE_PLAYER_TILES_ADR, x
         01:C564  BC F4 60   			ldy.h	_TABLE_PLAYER_TILES_ADR, x
 5929                        		__call		_set_far_offset.3
         01:C567  20 8C E2   			call	_set_far_offset.3
 5930                        	
 5931                        		.dbg	line,	"include\routines_LEVELS.c", 931; far_load_vram(PLAYER_VRAM_ADR,TILES_16);
 5932                        		__st.wmiq	6144, _di
         01:C56A  64 F0      			stz.l	_di
         01:C56C  A9 18      			lda.h	#6144
         01:C56E  85 F1      			sta.h	_di
 5933                        		__st.wmiq	256, _ax
         01:C570  64 F8      			stz.l	_ax
         01:C572  A9 01      			lda.h	#256
         01:C574  85 F9      			sta.h	_ax
 5934                        		 _far_load_vram.2
         01:C576  82         			clx				; Offset to PCE VDC.
         01:C577  20 63 FF   			call	load_vram_x
 5935                        	
 5936                        		.dbg	line,	"include\routines_LEVELS.c", 932; }
 5937                        	
 5938                        		.dbg	line,	"include\routines_LEVELS.c", 935; else if(player_counter_anim == 20)
 5939                        		__bra		.LL212
         01:C57A  80 49      			bra	.LL212
 5940    01:C57C             	.LL211:
 5941                        		__ld.umq	_player_counter_anim
         01:C57C  AD 18 23   			lda	_player_counter_anim
 5942                        		__equ_b.uiq	20
         01:C57F  C9 14      			cmp	#20
         01:C581  F0 01      			beq	!+
         01:C583  18         			clc
         01:C584             	!:
 5943                        		__bfalse	.LL213
         01:C584  90 2F      			bcc	.LL213
 5944                        	
 5945                        		.dbg	line,	"include\routines_LEVELS.c", 936; {
 5946                        	
 5947                        		.dbg	line,	"include\routines_LEVELS.c", 937; set_far_offset(OFFSET_PLAYER_WALK_6,TABLE_PLAYER_TILES_BANK[player_naked],TABLE_PLAYER_TILES_ADR[player_naked]);
 5948                        		__st.wmiq	3072, _bp
         01:C586  64 EC      			stz.l	_bp
         01:C588  A9 0C      			lda.h	#3072
         01:C58A  85 ED      			sta.h	_bp
 5949                        		__ldx.umq	_player_naked
         01:C58C  AE 1B 23   			ldx	_player_naked
 5950                        		__ld.uax	_TABLE_PLAYER_TILES_BANK
         01:C58F  BD F7 60   			lda	_TABLE_PLAYER_TILES_BANK, x
         01:C592  C2         			cly
 5951                        		__st.umq	_bp_bank
         01:C593  85 02      			sta	_bp_bank
 5952                        		__ld2x.umq	_player_naked
         01:C595  AD 1B 23   			lda	_player_naked
         01:C598  0A         			asl	a
         01:C599  AA         			tax
 5953                        		__ld.wax	_TABLE_PLAYER_TILES_ADR
         01:C59A  BD F3 60   			lda.l	_TABLE_PLAYER_TILES_ADR, x
         01:C59D  BC F4 60   			ldy.h	_TABLE_PLAYER_TILES_ADR, x
 5954                        		__call		_set_far_offset.3
         01:C5A0  20 8C E2   			call	_set_far_offset.3
 5955                        	
 5956                        		.dbg	line,	"include\routines_LEVELS.c", 938; far_load_vram(PLAYER_VRAM_ADR,TILES_16);
 5957                        		__st.wmiq	6144, _di
         01:C5A3  64 F0      			stz.l	_di
         01:C5A5  A9 18      			lda.h	#6144
         01:C5A7  85 F1      			sta.h	_di
 5958                        		__st.wmiq	256, _ax
         01:C5A9  64 F8      			stz.l	_ax
         01:C5AB  A9 01      			lda.h	#256
         01:C5AD  85 F9      			sta.h	_ax
 5959                        		 _far_load_vram.2
         01:C5AF  82         			clx				; Offset to PCE VDC.
         01:C5B0  20 63 FF   			call	load_vram_x
 5960                        	
 5961                        		.dbg	line,	"include\routines_LEVELS.c", 939; }
 5962                        	
 5963                        		.dbg	line,	"include\routines_LEVELS.c", 942; else if(player_counter_anim == 22)
 5964                        		__bra		.LL214
         01:C5B3  80 10      			bra	.LL214
 5965    01:C5B5             	.LL213:
 5966                        		__ld.umq	_player_counter_anim
         01:C5B5  AD 18 23   			lda	_player_counter_anim
 5967                        		__equ_b.uiq	22
         01:C5B8  C9 16      			cmp	#22
         01:C5BA  F0 01      			beq	!+
         01:C5BC  18         			clc
         01:C5BD             	!:
 5968                        		__bfalse	.LL215
         01:C5BD  90 06      			bcc	.LL215
 5969                        	
 5970                        		.dbg	line,	"include\routines_LEVELS.c", 943; {
 5971                        	
 5972                        		.dbg	line,	"include\routines_LEVELS.c", 944; player_counter_anim = 0;
 5973                        		__st.umiq	0, _player_counter_anim
         01:C5BF  9C 18 23   			stz	_player_counter_anim
 5974                        	
 5975                        		.dbg	line,	"include\routines_LEVELS.c", 946; return;
 5976                        		__bra		.LL180
         01:C5C2  4C 9E D8   			bra	.LL180
 5977                        	
 5978                        		.dbg	line,	"include\routines_LEVELS.c", 947; }
 5979                        	
 5980                        		.dbg	line,	"include\routines_LEVELS.c", 950; player_counter_anim += 1;
 5981    01:C5C5             	.LL215:
 5982    01:C5C5             	.LL214:
 5983    01:C5C5             	.LL212:
 5984    01:C5C5             	.LL210:
 5985    01:C5C5             	.LL208:
 5986    01:C5C5             	.LL206:
 5987    01:C5C5             	.LL204:
 5988    01:C5C5             	.LL202:
 5989    01:C5C5             	.LL200:
 5990                        		__add_st.umiq	1, _player_counter_anim
         01:C5C5  EE 18 23   			inc	_player_counter_anim
 5991                        	
 5992                        		.dbg	line,	"include\routines_LEVELS.c", 952; }
 5993                        	
 5994                        		.dbg	line,	"include\routines_LEVELS.c", 955; else if(player_state == STATE_JUMP)
 5995                        		__bra		.LL216
         01:C5C8  4C 9E D8   			bra	.LL216
 5996    01:C5CB             	.LL186:
 5997                        		__ld.umq	_player_state
         01:C5CB  AD 15 23   			lda	_player_state
 5998                        		__equ_b.uiq	4
         01:C5CE  C9 04      			cmp	#4
         01:C5D0  F0 01      			beq	!+
         01:C5D2  18         			clc
         01:C5D3             	!:
 5999                        		__bfalse	.LL217
         01:C5D3  B0 03 4C F4			bcc	.LL217
         01:C5D7  C8          
 6000                        	
 6001                        		.dbg	line,	"include\routines_LEVELS.c", 956; {
 6002                        	
 6003                        		.dbg	line,	"include\routines_LEVELS.c", 957; unsigned char i;
 6004                        	
 6005                        		.dbg	line,	"include\routines_LEVELS.c", 958; i = 1;
 6006                        		__st.umiq	1, __update_PLAYER_end - 1  /* i */
         01:C5D8  A9 01      			lda.l	#1
         01:C5DA  8D 0C 23   			sta	__update_PLAYER_end - 1
 6007                        	
 6008                        		.dbg	line,	"include\routines_LEVELS.c", 961; if(player_counter_anim == 0)
 6009                        		__not.um	_player_counter_anim
         01:C5DD  AD 18 23   			lda	_player_counter_anim
         01:C5E0  18         			clc
         01:C5E1  D0 01      			bne	!+
         01:C5E3  38         			sec
         01:C5E4             	!:
 6010                        		__bfalse	.LL218
         01:C5E4  90 32      			bcc	.LL218
 6011                        	
 6012                        		.dbg	line,	"include\routines_LEVELS.c", 962; {
 6013                        	
 6014                        		.dbg	line,	"include\routines_LEVELS.c", 963; set_far_offset(OFFSET_PLAYER_JUMP,TABLE_PLAYER_TILES_BANK[player_naked],TABLE_PLAYER_TILES_ADR[player_naked]);
 6015                        		__st.wmiq	3584, _bp
         01:C5E6  64 EC      			stz.l	_bp
         01:C5E8  A9 0E      			lda.h	#3584
         01:C5EA  85 ED      			sta.h	_bp
 6016                        		__ldx.umq	_player_naked
         01:C5EC  AE 1B 23   			ldx	_player_naked
 6017                        		__ld.uax	_TABLE_PLAYER_TILES_BANK
         01:C5EF  BD F7 60   			lda	_TABLE_PLAYER_TILES_BANK, x
         01:C5F2  C2         			cly
 6018                        		__st.umq	_bp_bank
         01:C5F3  85 02      			sta	_bp_bank
 6019                        		__ld2x.umq	_player_naked
         01:C5F5  AD 1B 23   			lda	_player_naked
         01:C5F8  0A         			asl	a
         01:C5F9  AA         			tax
 6020                        		__ld.wax	_TABLE_PLAYER_TILES_ADR
         01:C5FA  BD F3 60   			lda.l	_TABLE_PLAYER_TILES_ADR, x
         01:C5FD  BC F4 60   			ldy.h	_TABLE_PLAYER_TILES_ADR, x
 6021                        		__call		_set_far_offset.3
         01:C600  20 8C E2   			call	_set_far_offset.3
 6022                        	
 6023                        		.dbg	line,	"include\routines_LEVELS.c", 964; far_load_vram(PLAYER_VRAM_ADR,TILES_16);
 6024                        		__st.wmiq	6144, _di
         01:C603  64 F0      			stz.l	_di
         01:C605  A9 18      			lda.h	#6144
         01:C607  85 F1      			sta.h	_di
 6025                        		__st.wmiq	256, _ax
         01:C609  64 F8      			stz.l	_ax
         01:C60B  A9 01      			lda.h	#256
         01:C60D  85 F9      			sta.h	_ax
 6026                        		 _far_load_vram.2
         01:C60F  82         			clx				; Offset to PCE VDC.
         01:C610  20 63 FF   			call	load_vram_x
 6027                        	
 6028                        		.dbg	line,	"include\routines_LEVELS.c", 966; player_counter_anim = 1;
 6029                        		__st.umiq	1, _player_counter_anim
         01:C613  A9 01      			lda.l	#1
         01:C615  8D 18 23   			sta	_player_counter_anim
 6030                        	
 6031                        		.dbg	line,	"include\routines_LEVELS.c", 967; }
 6032                        	
 6033                        		.dbg	line,	"include\routines_LEVELS.c", 970; player_pos_y += TABLE_PLAYER_JUMP_V[player_index_jump];
 6034    01:C618             	.LL218:
 6035                        		__ldx.umq	_player_index_jump
         01:C618  AE 19 23   			ldx	_player_index_jump
 6036                        		__ld.bax	_TABLE_PLAYER_JUMP_V
         01:C61B  BD F9 60   			lda	_TABLE_PLAYER_JUMP_V, x
         01:C61E  C2         			cly
         01:C61F  10 01      			bpl	!+
         01:C621  88         			dey
         01:C622             	!:
 6037                        		__add_st.wmq	_player_pos_y
         01:C622  18         			clc
         01:C623  6D CF 24   			adc.l	_player_pos_y
         01:C626  8D CF 24   			sta.l	_player_pos_y
         01:C629  98         			tya
         01:C62A  6D D0 24   			adc.h	_player_pos_y
         01:C62D  8D D0 24   			sta.h	_player_pos_y
 6038                        	
 6039                        		.dbg	line,	"include\routines_LEVELS.c", 972; // CHECK COLLISION WITH CEILING //
 6040                        	
 6041                        		.dbg	line,	"include\routines_LEVELS.c", 973; check_BG( 15 , 8 );
 6042                        		__ld.wi		15
         01:C630  A9 0F      			lda.l	#15
         01:C632  C2         			cly
 6043                        		__pusharg.wr
         01:C633  A6 8D      			ldx	<__sp
         01:C635  CA         			dex
         01:C636  CA         			dex
         01:C637  95 08      			sta.l	<__stack, x
         01:C639  94 09      			sty.h	<__stack, x
         01:C63B  86 8D      			stx	<__sp
 6044                        		__ld.wi		8
         01:C63D  A9 08      			lda.l	#8
         01:C63F  C2         			cly
 6045                        		__pusharg.wr
         01:C640  A6 8D      			ldx	<__sp
         01:C642  CA         			dex
         01:C643  CA         			dex
         01:C644  95 08      			sta.l	<__stack, x
         01:C646  94 09      			sty.h	<__stack, x
         01:C648  86 8D      			stx	<__sp
 6046                        		__call		_check_BG
         01:C64A  20 6D FF   			call	_check_BG
 6047                        	
 6048                        		.dbg	line,	"include\routines_LEVELS.c", 975; if(map_blk_flag == TILE_BG)
 6049                        		__ld.umq	_map_blk_flag
         01:C64D  AD AA 2B   			lda	_map_blk_flag
 6050                        		__equ_b.uiq	1
         01:C650  C9 01      			cmp	#1
         01:C652  F0 01      			beq	!+
         01:C654  18         			clc
         01:C655             	!:
 6051                        		__bfalse	.LL219
         01:C655  90 5A      			bcc	.LL219
 6052                        	
 6053                        		.dbg	line,	"include\routines_LEVELS.c", 976; {
 6054                        	
 6055                        		.dbg	line,	"include\routines_LEVELS.c", 977; for(i=1 ; i<8 ; i++)
 6056                        		__st.umiq	1, __update_PLAYER_end - 1  /* i */
         01:C657  A9 01      			lda.l	#1
         01:C659  8D 0C 23   			sta	__update_PLAYER_end - 1
 6057    01:C65C             	.LL220:
 6058                        		__ld.umq	__update_PLAYER_end - 1  /* i */
         01:C65C  AD 0C 23   			lda	__update_PLAYER_end - 1
 6059                        		__ult_b.uiq	8
         01:C65F  C9 08      			cmp	#8		; Subtract integer from A.
         01:C661  6A         			ror	a		; CC if A < integer.
         01:C662  49 80      			eor	#$80
         01:C664  2A         			rol	a
 6060                        		__btrue		.LL222
         01:C665  B0 07      			bcs	.LL222
 6061                        		__bra		.LL223
         01:C667  80 48      			bra	.LL223
 6062    01:C669             	.LL221:
 6063                        		__inc.umq	__update_PLAYER_end - 1  /* i */
         01:C669  EE 0C 23   			inc	__update_PLAYER_end - 1
 6064                        		__bra		.LL220
         01:C66C  80 EE      			bra	.LL220
 6065    01:C66E             	.LL222:
 6066                        	
 6067                        		.dbg	line,	"include\routines_LEVELS.c", 978; {
 6068                        	
 6069                        		.dbg	line,	"include\routines_LEVELS.c", 979; check_BG( 15 , 8 + i );
 6070                        		__ld.wi		15
         01:C66E  A9 0F      			lda.l	#15
         01:C670  C2         			cly
 6071                        		__pusharg.wr
         01:C671  A6 8D      			ldx	<__sp
         01:C673  CA         			dex
         01:C674  CA         			dex
         01:C675  95 08      			sta.l	<__stack, x
         01:C677  94 09      			sty.h	<__stack, x
         01:C679  86 8D      			stx	<__sp
 6072                        		__ld.wi		8
         01:C67B  A9 08      			lda.l	#8
         01:C67D  C2         			cly
 6073                        		__add.um	__update_PLAYER_end - 1  /* i */
         01:C67E  18         			clc
         01:C67F  6D 0C 23   			adc	__update_PLAYER_end - 1
         01:C682  90 01      			bcc	!+
         01:C684  C8         			iny
         01:C685             	!:
 6074                        		__pusharg.wr
         01:C685  A6 8D      			ldx	<__sp
         01:C687  CA         			dex
         01:C688  CA         			dex
         01:C689  95 08      			sta.l	<__stack, x
         01:C68B  94 09      			sty.h	<__stack, x
         01:C68D  86 8D      			stx	<__sp
 6075                        		__call		_check_BG
         01:C68F  20 6D FF   			call	_check_BG
 6076                        	
 6077                        		.dbg	line,	"include\routines_LEVELS.c", 980; {
 6078                        	
 6079                        		.dbg	line,	"include\routines_LEVELS.c", 981; if(map_blk_flag == TILE_EMPTY)
 6080                        		__not.um	_map_blk_flag
         01:C692  AD AA 2B   			lda	_map_blk_flag
         01:C695  18         			clc
         01:C696  D0 01      			bne	!+
         01:C698  38         			sec
         01:C699             	!:
 6081                        		__bfalse	.LL224
         01:C699  90 CE      			bcc	.LL224
 6082                        	
 6083                        		.dbg	line,	"include\routines_LEVELS.c", 982; {
 6084                        	
 6085                        		.dbg	line,	"include\routines_LEVELS.c", 983; player_pos_y += i;
 6086                        		__ld.um		__update_PLAYER_end - 1  /* i */
         01:C69B  AD 0C 23   			lda	__update_PLAYER_end - 1
         01:C69E  C2         			cly
 6087                        		__add_st.wmq	_player_pos_y
         01:C69F  18         			clc
         01:C6A0  6D CF 24   			adc.l	_player_pos_y
         01:C6A3  8D CF 24   			sta.l	_player_pos_y
         01:C6A6  98         			tya
         01:C6A7  6D D0 24   			adc.h	_player_pos_y
         01:C6AA  8D D0 24   			sta.h	_player_pos_y
 6088                        	
 6089                        		.dbg	line,	"include\routines_LEVELS.c", 984; break;
 6090                        		__bra		.LL223
         01:C6AD  80 02      			bra	.LL223
 6091                        	
 6092                        		.dbg	line,	"include\routines_LEVELS.c", 985; }
 6093                        	
 6094                        		.dbg	line,	"include\routines_LEVELS.c", 986; }
 6095    01:C6AF             	.LL224	.alias		.LL221
 6096                        	
 6097                        		.dbg	line,	"include\routines_LEVELS.c", 987; }
 6098                        		__bra		.LL221
         01:C6AF  80 B8      			bra	.LL221
 6099    01:C6B1             	.LL223:
 6100                        	
 6101                        		.dbg	line,	"include\routines_LEVELS.c", 988; }
 6102                        	
 6103                        		.dbg	line,	"include\routines_LEVELS.c", 990; spr_set(player_id);
 6104    01:C6B1             	.LL219:
 6105                        		__ld.umq	_player_id
         01:C6B1  AD 14 23   			lda	_player_id
 6106                        		__call		_spr_set.1
         01:C6B4  20 DD E7   			call	_spr_set.1
 6107                        	
 6108                        		.dbg	line,	"include\routines_LEVELS.c", 991; spr_y(player_pos_y);
 6109                        		__ld.wm		_player_pos_y
         01:C6B7  AD CF 24   			lda.l	_player_pos_y
         01:C6BA  AC D0 24   			ldy.h	_player_pos_y
 6110                        		__call		_spr_y.1
         01:C6BD  20 19 E8   			call	_spr_y.1
 6111                        	
 6112                        		.dbg	line,	"include\routines_LEVELS.c", 995; if(player_index_jump < 34)
 6113                        		__ld.umq	_player_index_jump
         01:C6C0  AD 19 23   			lda	_player_index_jump
 6114                        		__ult_b.uiq	34
         01:C6C3  C9 22      			cmp	#34		; Subtract integer from A.
         01:C6C5  6A         			ror	a		; CC if A < integer.
         01:C6C6  49 80      			eor	#$80
         01:C6C8  2A         			rol	a
 6115                        		__bfalse	.LL225
         01:C6C9  90 03      			bcc	.LL225
 6116                        	
 6117                        		.dbg	line,	"include\routines_LEVELS.c", 996; {
 6118                        	
 6119                        		.dbg	line,	"include\routines_LEVELS.c", 998; player_index_jump += 1;
 6120                        		__add_st.umiq	1, _player_index_jump
         01:C6CB  EE 19 23   			inc	_player_index_jump
 6121                        	
 6122                        		.dbg	line,	"include\routines_LEVELS.c", 999; }
 6123                        	
 6124                        		.dbg	line,	"include\routines_LEVELS.c", 1004; //--------------------------------------------------------------------------------------//
 6125                        	
 6126                        		.dbg	line,	"include\routines_LEVELS.c", 1005; //                                   FLOOR COLLISION                                    //
 6127                        	
 6128                        		.dbg	line,	"include\routines_LEVELS.c", 1006; //--------------------------------------------------------------------------------------//
 6129                        	
 6130                        		.dbg	line,	"include\routines_LEVELS.c", 1008; if(player_index_jump > 14)
 6131    01:C6CE             	.LL225:
 6132                        		__ld.umq	_player_index_jump
         01:C6CE  AD 19 23   			lda	_player_index_jump
 6133                        		__ugt_b.uiq	14
         01:C6D1  18         			clc			; Subtract integer+1 from A.
         01:C6D2  E9 0E      			sbc	#14		; CS if A > integer.
 6134                        		__bfalse	.LL226
         01:C6D4  B0 03 4C 67			bcc	.LL226
         01:C6D8  C8          
 6135                        	
 6136                        		.dbg	line,	"include\routines_LEVELS.c", 1009; {
 6137                        	
 6138                        		.dbg	line,	"include\routines_LEVELS.c", 1010; // CHECK COLLISION WITH LEFT FLOOR //
 6139                        	
 6140                        		.dbg	line,	"include\routines_LEVELS.c", 1011; check_BG( 10 , 32 );
 6141                        		__ld.wi		10
         01:C6D9  A9 0A      			lda.l	#10
         01:C6DB  C2         			cly
 6142                        		__pusharg.wr
         01:C6DC  A6 8D      			ldx	<__sp
         01:C6DE  CA         			dex
         01:C6DF  CA         			dex
         01:C6E0  95 08      			sta.l	<__stack, x
         01:C6E2  94 09      			sty.h	<__stack, x
         01:C6E4  86 8D      			stx	<__sp
 6143                        		__ld.wi		32
         01:C6E6  A9 20      			lda.l	#32
         01:C6E8  C2         			cly
 6144                        		__pusharg.wr
         01:C6E9  A6 8D      			ldx	<__sp
         01:C6EB  CA         			dex
         01:C6EC  CA         			dex
         01:C6ED  95 08      			sta.l	<__stack, x
         01:C6EF  94 09      			sty.h	<__stack, x
         01:C6F1  86 8D      			stx	<__sp
 6145                        		__call		_check_BG
         01:C6F3  20 6D FF   			call	_check_BG
 6146                        	
 6147                        		.dbg	line,	"include\routines_LEVELS.c", 1013; // IF PLAYER TOUCHES THE GROUND TO THE LEFT //
 6148                        	
 6149                        		.dbg	line,	"include\routines_LEVELS.c", 1014; if(map_blk_flag == TILE_BG)
 6150                        		__ld.umq	_map_blk_flag
         01:C6F6  AD AA 2B   			lda	_map_blk_flag
 6151                        		__equ_b.uiq	1
         01:C6F9  C9 01      			cmp	#1
         01:C6FB  F0 01      			beq	!+
         01:C6FD  18         			clc
         01:C6FE             	!:
 6152                        		__bfalse	.LL227
         01:C6FE  B0 03 4C A0			bcc	.LL227
         01:C702  C7          
 6153                        	
 6154                        		.dbg	line,	"include\routines_LEVELS.c", 1015; {
 6155                        	
 6156                        		.dbg	line,	"include\routines_LEVELS.c", 1016; // CALCULATE HOW MANY PIXELS THE PLAYER MOVED INTO THE GROUND //
 6157                        	
 6158                        		.dbg	line,	"include\routines_LEVELS.c", 1017; for(i=1; i<11 ; i++ )
 6159                        		__st.umiq	1, __update_PLAYER_end - 1  /* i */
         01:C703  A9 01      			lda.l	#1
         01:C705  8D 0C 23   			sta	__update_PLAYER_end - 1
 6160    01:C708             	.LL228:
 6161                        		__ld.umq	__update_PLAYER_end - 1  /* i */
         01:C708  AD 0C 23   			lda	__update_PLAYER_end - 1
 6162                        		__ult_b.uiq	11
         01:C70B  C9 0B      			cmp	#11		; Subtract integer from A.
         01:C70D  6A         			ror	a		; CC if A < integer.
         01:C70E  49 80      			eor	#$80
         01:C710  2A         			rol	a
 6163                        		__btrue		.LL230
         01:C711  B0 07      			bcs	.LL230
 6164                        		__bra		.LL231
         01:C713  80 7D      			bra	.LL231
 6165    01:C715             	.LL229:
 6166                        		__inc.umq	__update_PLAYER_end - 1  /* i */
         01:C715  EE 0C 23   			inc	__update_PLAYER_end - 1
 6167                        		__bra		.LL228
         01:C718  80 EE      			bra	.LL228
 6168    01:C71A             	.LL230:
 6169                        	
 6170                        		.dbg	line,	"include\routines_LEVELS.c", 1018; {
 6171                        	
 6172                        		.dbg	line,	"include\routines_LEVELS.c", 1019; check_TILE_DEPTH( 10 , i);
 6173                        		__ld.wi		10
         01:C71A  A9 0A      			lda.l	#10
         01:C71C  C2         			cly
 6174                        		__pusharg.wr
         01:C71D  A6 8D      			ldx	<__sp
         01:C71F  CA         			dex
         01:C720  CA         			dex
         01:C721  95 08      			sta.l	<__stack, x
         01:C723  94 09      			sty.h	<__stack, x
         01:C725  86 8D      			stx	<__sp
 6175                        		__ld.um		__update_PLAYER_end - 1  /* i */
         01:C727  AD 0C 23   			lda	__update_PLAYER_end - 1
         01:C72A  C2         			cly
 6176                        		__pusharg.wr
         01:C72B  A6 8D      			ldx	<__sp
         01:C72D  CA         			dex
         01:C72E  CA         			dex
         01:C72F  95 08      			sta.l	<__stack, x
         01:C731  94 09      			sty.h	<__stack, x
         01:C733  86 8D      			stx	<__sp
 6177                        		__call		_check_TILE_DEPTH
         01:C735  20 4F FF   			call	_check_TILE_DEPTH
 6178                        	
 6179                        		.dbg	line,	"include\routines_LEVELS.c", 1021; if(map_blk_flag == TILE_EMPTY)
 6180                        		__not.um	_map_blk_flag
         01:C738  AD AA 2B   			lda	_map_blk_flag
         01:C73B  18         			clc
         01:C73C  D0 01      			bne	!+
         01:C73E  38         			sec
         01:C73F             	!:
 6181                        		__bfalse	.LL232
         01:C73F  90 D4      			bcc	.LL232
 6182                        	
 6183                        		.dbg	line,	"include\routines_LEVELS.c", 1022; {
 6184                        	
 6185                        		.dbg	line,	"include\routines_LEVELS.c", 1023; set_far_base(TABLE_PLAYER_TILES_BANK[player_naked],TABLE_PLAYER_TILES_ADR[player_naked]);
 6186                        		__ldx.umq	_player_naked
         01:C741  AE 1B 23   			ldx	_player_naked
 6187                        		__ld.uax	_TABLE_PLAYER_TILES_BANK
         01:C744  BD F7 60   			lda	_TABLE_PLAYER_TILES_BANK, x
         01:C747  C2         			cly
 6188                        		__st.umq	_bp_bank
         01:C748  85 02      			sta	_bp_bank
 6189                        		__ld2x.umq	_player_naked
         01:C74A  AD 1B 23   			lda	_player_naked
         01:C74D  0A         			asl	a
         01:C74E  AA         			tax
 6190                        		__ld.wax	_TABLE_PLAYER_TILES_ADR
         01:C74F  BD F3 60   			lda.l	_TABLE_PLAYER_TILES_ADR, x
         01:C752  BC F4 60   			ldy.h	_TABLE_PLAYER_TILES_ADR, x
 6191                        		__st.wmq	_bp
         01:C755  85 EC      			sta.l	_bp
         01:C757  84 ED      			sty.h	_bp
 6192                        	
 6193                        		.dbg	line,	"include\routines_LEVELS.c", 1024; far_load_vram(PLAYER_VRAM_ADR,TILES_16);
 6194                        		__st.wmiq	6144, _di
         01:C759  64 F0      			stz.l	_di
         01:C75B  A9 18      			lda.h	#6144
         01:C75D  85 F1      			sta.h	_di
 6195                        		__st.wmiq	256, _ax
         01:C75F  64 F8      			stz.l	_ax
         01:C761  A9 01      			lda.h	#256
         01:C763  85 F9      			sta.h	_ax
 6196                        		 _far_load_vram.2
         01:C765  82         			clx				; Offset to PCE VDC.
         01:C766  20 63 FF   			call	load_vram_x
 6197                        	
 6198                        		.dbg	line,	"include\routines_LEVELS.c", 1026; player_pos_y -= (i - 1);
 6199                        		__ld.um		__update_PLAYER_end - 1  /* i */
         01:C769  AD 0C 23   			lda	__update_PLAYER_end - 1
         01:C76C  C2         			cly
 6200                        		__sub.wi	1
         01:C76D  38         			sec
         01:C76E  E9 01      			sbc.l	#1
         01:C770  B0 01      			bcs	!+
         01:C772  88         			dey
         01:C773             	!:
 6201                        		__isub_st.wmq	_player_pos_y
         01:C773  38         			sec
         01:C774  49 FF      			eor	#$FF
         01:C776  6D CF 24   			adc.l	_player_pos_y
         01:C779  8D CF 24   			sta.l	_player_pos_y
         01:C77C  98         			tya
         01:C77D  49 FF      			eor	#$FF
         01:C77F  6D D0 24   			adc.h	_player_pos_y
         01:C782  8D D0 24   			sta.h	_player_pos_y
 6202                        	
 6203                        		.dbg	line,	"include\routines_LEVELS.c", 1027; spr_y(player_pos_y);
 6204                        		__ld.wm		_player_pos_y
         01:C785  AD CF 24   			lda.l	_player_pos_y
         01:C788  AC D0 24   			ldy.h	_player_pos_y
 6205                        		__call		_spr_y.1
         01:C78B  20 19 E8   			call	_spr_y.1
 6206                        	
 6207                        		.dbg	line,	"include\routines_LEVELS.c", 1028; break;
 6208                        		__bra		.LL231
         01:C78E  80 02      			bra	.LL231
 6209                        	
 6210                        		.dbg	line,	"include\routines_LEVELS.c", 1029; }
 6211                        	
 6212                        		.dbg	line,	"include\routines_LEVELS.c", 1031; }
 6213    01:C790             	.LL232	.alias		.LL229
 6214                        		__bra		.LL229
         01:C790  80 83      			bra	.LL229
 6215    01:C792             	.LL231:
 6216                        	
 6217                        		.dbg	line,	"include\routines_LEVELS.c", 1033; player_counter_anim = 1;
 6218                        		__st.umiq	1, _player_counter_anim
         01:C792  A9 01      			lda.l	#1
         01:C794  8D 18 23   			sta	_player_counter_anim
 6219                        	
 6220                        		.dbg	line,	"include\routines_LEVELS.c", 1034; player_index_jump = 0;
 6221                        		__st.umiq	0, _player_index_jump
         01:C797  9C 19 23   			stz	_player_index_jump
 6222                        	
 6223                        		.dbg	line,	"include\routines_LEVELS.c", 1035; player_state = STATE_IDLE;
 6224                        		__st.umiq	0, _player_state
         01:C79A  9C 15 23   			stz	_player_state
 6225                        	
 6226                        		.dbg	line,	"include\routines_LEVELS.c", 1036; return;
 6227                        		__bra		.LL180
         01:C79D  4C 9E D8   			bra	.LL180
 6228                        	
 6229                        		.dbg	line,	"include\routines_LEVELS.c", 1037; }
 6230                        	
 6231                        		.dbg	line,	"include\routines_LEVELS.c", 1039; // IF PLAYER TOUCHES THE GROUND TO THE RIGHT //
 6232                        	
 6233                        		.dbg	line,	"include\routines_LEVELS.c", 1040; else
 6234    01:C7A0             	.LL227:
 6235                        	
 6236                        		.dbg	line,	"include\routines_LEVELS.c", 1041; {
 6237                        	
 6238                        		.dbg	line,	"include\routines_LEVELS.c", 1042; // CHECK COLLISION WITH RIGHT FLOOR //
 6239                        	
 6240                        		.dbg	line,	"include\routines_LEVELS.c", 1043; check_BG( 22 , 32 );
 6241                        		__ld.wi		22
         01:C7A0  A9 16      			lda.l	#22
         01:C7A2  C2         			cly
 6242                        		__pusharg.wr
         01:C7A3  A6 8D      			ldx	<__sp
         01:C7A5  CA         			dex
         01:C7A6  CA         			dex
         01:C7A7  95 08      			sta.l	<__stack, x
         01:C7A9  94 09      			sty.h	<__stack, x
         01:C7AB  86 8D      			stx	<__sp
 6243                        		__ld.wi		32
         01:C7AD  A9 20      			lda.l	#32
         01:C7AF  C2         			cly
 6244                        		__pusharg.wr
         01:C7B0  A6 8D      			ldx	<__sp
         01:C7B2  CA         			dex
         01:C7B3  CA         			dex
         01:C7B4  95 08      			sta.l	<__stack, x
         01:C7B6  94 09      			sty.h	<__stack, x
         01:C7B8  86 8D      			stx	<__sp
 6245                        		__call		_check_BG
         01:C7BA  20 6D FF   			call	_check_BG
 6246                        	
 6247                        		.dbg	line,	"include\routines_LEVELS.c", 1045; if(map_blk_flag == TILE_BG)
 6248                        		__ld.umq	_map_blk_flag
         01:C7BD  AD AA 2B   			lda	_map_blk_flag
 6249                        		__equ_b.uiq	1
         01:C7C0  C9 01      			cmp	#1
         01:C7C2  F0 01      			beq	!+
         01:C7C4  18         			clc
         01:C7C5             	!:
 6250                        		__bfalse	.LL234
         01:C7C5  B0 03 4C 67			bcc	.LL234
         01:C7C9  C8          
 6251                        	
 6252                        		.dbg	line,	"include\routines_LEVELS.c", 1046; {
 6253                        	
 6254                        		.dbg	line,	"include\routines_LEVELS.c", 1047; // CALCULATE HOW MANY PIXELS THE PLAYER MOVED INTO THE GROUND //
 6255                        	
 6256                        		.dbg	line,	"include\routines_LEVELS.c", 1048; for(i=1; i<11 ; i++ )
 6257                        		__st.umiq	1, __update_PLAYER_end - 1  /* i */
         01:C7CA  A9 01      			lda.l	#1
         01:C7CC  8D 0C 23   			sta	__update_PLAYER_end - 1
 6258    01:C7CF             	.LL235:
 6259                        		__ld.umq	__update_PLAYER_end - 1  /* i */
         01:C7CF  AD 0C 23   			lda	__update_PLAYER_end - 1
 6260                        		__ult_b.uiq	11
         01:C7D2  C9 0B      			cmp	#11		; Subtract integer from A.
         01:C7D4  6A         			ror	a		; CC if A < integer.
         01:C7D5  49 80      			eor	#$80
         01:C7D7  2A         			rol	a
 6261                        		__btrue		.LL237
         01:C7D8  B0 07      			bcs	.LL237
 6262                        		__bra		.LL238
         01:C7DA  80 7D      			bra	.LL238
 6263    01:C7DC             	.LL236:
 6264                        		__inc.umq	__update_PLAYER_end - 1  /* i */
         01:C7DC  EE 0C 23   			inc	__update_PLAYER_end - 1
 6265                        		__bra		.LL235
         01:C7DF  80 EE      			bra	.LL235
 6266    01:C7E1             	.LL237:
 6267                        	
 6268                        		.dbg	line,	"include\routines_LEVELS.c", 1049; {
 6269                        	
 6270                        		.dbg	line,	"include\routines_LEVELS.c", 1050; check_TILE_DEPTH( 22 , i);
 6271                        		__ld.wi		22
         01:C7E1  A9 16      			lda.l	#22
         01:C7E3  C2         			cly
 6272                        		__pusharg.wr
         01:C7E4  A6 8D      			ldx	<__sp
         01:C7E6  CA         			dex
         01:C7E7  CA         			dex
         01:C7E8  95 08      			sta.l	<__stack, x
         01:C7EA  94 09      			sty.h	<__stack, x
         01:C7EC  86 8D      			stx	<__sp
 6273                        		__ld.um		__update_PLAYER_end - 1  /* i */
         01:C7EE  AD 0C 23   			lda	__update_PLAYER_end - 1
         01:C7F1  C2         			cly
 6274                        		__pusharg.wr
         01:C7F2  A6 8D      			ldx	<__sp
         01:C7F4  CA         			dex
         01:C7F5  CA         			dex
         01:C7F6  95 08      			sta.l	<__stack, x
         01:C7F8  94 09      			sty.h	<__stack, x
         01:C7FA  86 8D      			stx	<__sp
 6275                        		__call		_check_TILE_DEPTH
         01:C7FC  20 4F FF   			call	_check_TILE_DEPTH
 6276                        	
 6277                        		.dbg	line,	"include\routines_LEVELS.c", 1052; if(map_blk_flag == TILE_EMPTY)
 6278                        		__not.um	_map_blk_flag
         01:C7FF  AD AA 2B   			lda	_map_blk_flag
         01:C802  18         			clc
         01:C803  D0 01      			bne	!+
         01:C805  38         			sec
         01:C806             	!:
 6279                        		__bfalse	.LL239
         01:C806  90 D4      			bcc	.LL239
 6280                        	
 6281                        		.dbg	line,	"include\routines_LEVELS.c", 1053; {
 6282                        	
 6283                        		.dbg	line,	"include\routines_LEVELS.c", 1054; set_far_base(TABLE_PLAYER_TILES_BANK[player_naked],TABLE_PLAYER_TILES_ADR[player_naked]);
 6284                        		__ldx.umq	_player_naked
         01:C808  AE 1B 23   			ldx	_player_naked
 6285                        		__ld.uax	_TABLE_PLAYER_TILES_BANK
         01:C80B  BD F7 60   			lda	_TABLE_PLAYER_TILES_BANK, x
         01:C80E  C2         			cly
 6286                        		__st.umq	_bp_bank
         01:C80F  85 02      			sta	_bp_bank
 6287                        		__ld2x.umq	_player_naked
         01:C811  AD 1B 23   			lda	_player_naked
         01:C814  0A         			asl	a
         01:C815  AA         			tax
 6288                        		__ld.wax	_TABLE_PLAYER_TILES_ADR
         01:C816  BD F3 60   			lda.l	_TABLE_PLAYER_TILES_ADR, x
         01:C819  BC F4 60   			ldy.h	_TABLE_PLAYER_TILES_ADR, x
 6289                        		__st.wmq	_bp
         01:C81C  85 EC      			sta.l	_bp
         01:C81E  84 ED      			sty.h	_bp
 6290                        	
 6291                        		.dbg	line,	"include\routines_LEVELS.c", 1055; far_load_vram(PLAYER_VRAM_ADR,TILES_16);
 6292                        		__st.wmiq	6144, _di
         01:C820  64 F0      			stz.l	_di
         01:C822  A9 18      			lda.h	#6144
         01:C824  85 F1      			sta.h	_di
 6293                        		__st.wmiq	256, _ax
         01:C826  64 F8      			stz.l	_ax
         01:C828  A9 01      			lda.h	#256
         01:C82A  85 F9      			sta.h	_ax
 6294                        		 _far_load_vram.2
         01:C82C  82         			clx				; Offset to PCE VDC.
         01:C82D  20 63 FF   			call	load_vram_x
 6295                        	
 6296                        		.dbg	line,	"include\routines_LEVELS.c", 1057; player_pos_y -= (i - 1);
 6297                        		__ld.um		__update_PLAYER_end - 1  /* i */
         01:C830  AD 0C 23   			lda	__update_PLAYER_end - 1
         01:C833  C2         			cly
 6298                        		__sub.wi	1
         01:C834  38         			sec
         01:C835  E9 01      			sbc.l	#1
         01:C837  B0 01      			bcs	!+
         01:C839  88         			dey
         01:C83A             	!:
 6299                        		__isub_st.wmq	_player_pos_y
         01:C83A  38         			sec
         01:C83B  49 FF      			eor	#$FF
         01:C83D  6D CF 24   			adc.l	_player_pos_y
         01:C840  8D CF 24   			sta.l	_player_pos_y
         01:C843  98         			tya
         01:C844  49 FF      			eor	#$FF
         01:C846  6D D0 24   			adc.h	_player_pos_y
         01:C849  8D D0 24   			sta.h	_player_pos_y
 6300                        	
 6301                        		.dbg	line,	"include\routines_LEVELS.c", 1058; spr_y(player_pos_y);
 6302                        		__ld.wm		_player_pos_y
         01:C84C  AD CF 24   			lda.l	_player_pos_y
         01:C84F  AC D0 24   			ldy.h	_player_pos_y
 6303                        		__call		_spr_y.1
         01:C852  20 19 E8   			call	_spr_y.1
 6304                        	
 6305                        		.dbg	line,	"include\routines_LEVELS.c", 1059; break;
 6306                        		__bra		.LL238
         01:C855  80 02      			bra	.LL238
 6307                        	
 6308                        		.dbg	line,	"include\routines_LEVELS.c", 1060; }
 6309                        	
 6310                        		.dbg	line,	"include\routines_LEVELS.c", 1062; }
 6311    01:C857             	.LL239	.alias		.LL236
 6312                        		__bra		.LL236
         01:C857  80 83      			bra	.LL236
 6313    01:C859             	.LL238:
 6314                        	
 6315                        		.dbg	line,	"include\routines_LEVELS.c", 1064; player_counter_anim = 1;
 6316                        		__st.umiq	1, _player_counter_anim
         01:C859  A9 01      			lda.l	#1
         01:C85B  8D 18 23   			sta	_player_counter_anim
 6317                        	
 6318                        		.dbg	line,	"include\routines_LEVELS.c", 1065; player_index_jump = 0;
 6319                        		__st.umiq	0, _player_index_jump
         01:C85E  9C 19 23   			stz	_player_index_jump
 6320                        	
 6321                        		.dbg	line,	"include\routines_LEVELS.c", 1066; player_state = STATE_IDLE;
 6322                        		__st.umiq	0, _player_state
         01:C861  9C 15 23   			stz	_player_state
 6323                        	
 6324                        		.dbg	line,	"include\routines_LEVELS.c", 1067; return;
 6325                        		__bra		.LL180
         01:C864  4C 9E D8   			bra	.LL180
 6326                        	
 6327                        		.dbg	line,	"include\routines_LEVELS.c", 1068; }
 6328                        	
 6329                        		.dbg	line,	"include\routines_LEVELS.c", 1069; }
 6330    01:C867             	.LL234:
 6331    01:C867             	.LL233:
 6332                        	
 6333                        		.dbg	line,	"include\routines_LEVELS.c", 1070; }
 6334                        	
 6335                        		.dbg	line,	"include\routines_LEVELS.c", 1074; // CHECK COLLISION WITH LADDERS //
 6336                        	
 6337                        		.dbg	line,	"include\routines_LEVELS.c", 1075; check_BG( 16 , 16 );
 6338    01:C867             	.LL226:
 6339                        		__ld.wi		16
         01:C867  A9 10      			lda.l	#16
         01:C869  C2         			cly
 6340                        		__pusharg.wr
         01:C86A  A6 8D      			ldx	<__sp
         01:C86C  CA         			dex
         01:C86D  CA         			dex
         01:C86E  95 08      			sta.l	<__stack, x
         01:C870  94 09      			sty.h	<__stack, x
         01:C872  86 8D      			stx	<__sp
 6341                        		__ld.wi		16
         01:C874  A9 10      			lda.l	#16
         01:C876  C2         			cly
 6342                        		__pusharg.wr
         01:C877  A6 8D      			ldx	<__sp
         01:C879  CA         			dex
         01:C87A  CA         			dex
         01:C87B  95 08      			sta.l	<__stack, x
         01:C87D  94 09      			sty.h	<__stack, x
         01:C87F  86 8D      			stx	<__sp
 6343                        		__call		_check_BG
         01:C881  20 6D FF   			call	_check_BG
 6344                        	
 6345                        		.dbg	line,	"include\routines_LEVELS.c", 1077; // IF PLAYER HITS THE LADDER //
 6346                        	
 6347                        		.dbg	line,	"include\routines_LEVELS.c", 1078; if(map_blk_flag == TILE_LADDER)
 6348                        		__ld.umq	_map_blk_flag
         01:C884  AD AA 2B   			lda	_map_blk_flag
 6349                        		__equ_b.uiq	2
         01:C887  C9 02      			cmp	#2
         01:C889  F0 01      			beq	!+
         01:C88B  18         			clc
         01:C88C             	!:
 6350                        		__bfalse	.LL240
         01:C88C  B0 03 4C 9E			bcc	.LL240
         01:C890  D8          
 6351                        	
 6352                        		.dbg	line,	"include\routines_LEVELS.c", 1079; {
 6353                        	
 6354                        		.dbg	line,	"include\routines_LEVELS.c", 1080; // CAMERA GOES 8 PX BACKWARD //
 6355                        	
 6356                        		.dbg	line,	"include\routines_LEVELS.c", 1081; sgx_map_pxl_x = ( (sgx_map_pxl_x >> 3) << 3 );
 6357                        		__ld.wm		_sgx_map_pxl_x
         01:C891  AD 89 26   			lda.l	_sgx_map_pxl_x
         01:C894  AC 8A 26   			ldy.h	_sgx_map_pxl_x
 6358                        		__lsr.wi	3
         01:C897  84 00      			sty	__temp
         01:C899  20 3A E2   			jsr	lsrw3
 6359                        		__asl.wi	3
         01:C89C  84 00      			sty	__temp
         01:C89E  20 D7 E1   			jsr	aslw3
 6360                        		__st.wmq	_sgx_map_pxl_x
         01:C8A1  8D 89 26   			sta.l	_sgx_map_pxl_x
         01:C8A4  8C 8A 26   			sty.h	_sgx_map_pxl_x
 6361                        	
 6362                        		.dbg	line,	"include\routines_LEVELS.c", 1083; // SO WE UPDATE THE MAP //
 6363                        	
 6364                        		.dbg	line,	"include\routines_LEVELS.c", 1084; sgx_scroll_map();
 6365                        		__call		_sgx_scroll_map
         01:C8A7  20 81 FF   			call	_sgx_scroll_map
 6366                        	
 6367                        		.dbg	line,	"include\routines_LEVELS.c", 1086; // CHECK IF THE PLAYER STANDS RIGHT TO THE LADDER //
 6368                        	
 6369                        		.dbg	line,	"include\routines_LEVELS.c", 1087; check_BG( 31 , 16 );
 6370                        		__ld.wi		31
         01:C8AA  A9 1F      			lda.l	#31
         01:C8AC  C2         			cly
 6371                        		__pusharg.wr
         01:C8AD  A6 8D      			ldx	<__sp
         01:C8AF  CA         			dex
         01:C8B0  CA         			dex
         01:C8B1  95 08      			sta.l	<__stack, x
         01:C8B3  94 09      			sty.h	<__stack, x
         01:C8B5  86 8D      			stx	<__sp
 6372                        		__ld.wi		16
         01:C8B7  A9 10      			lda.l	#16
         01:C8B9  C2         			cly
 6373                        		__pusharg.wr
         01:C8BA  A6 8D      			ldx	<__sp
         01:C8BC  CA         			dex
         01:C8BD  CA         			dex
         01:C8BE  95 08      			sta.l	<__stack, x
         01:C8C0  94 09      			sty.h	<__stack, x
         01:C8C2  86 8D      			stx	<__sp
 6374                        		__call		_check_BG
         01:C8C4  20 6D FF   			call	_check_BG
 6375                        	
 6376                        		.dbg	line,	"include\routines_LEVELS.c", 1089; if(map_blk_flag == TILE_LADDER)
 6377                        		__ld.umq	_map_blk_flag
         01:C8C7  AD AA 2B   			lda	_map_blk_flag
 6378                        		__equ_b.uiq	2
         01:C8CA  C9 02      			cmp	#2
         01:C8CC  F0 01      			beq	!+
         01:C8CE  18         			clc
         01:C8CF             	!:
 6379                        		__bfalse	.LL241
         01:C8CF  90 0E      			bcc	.LL241
 6380                        	
 6381                        		.dbg	line,	"include\routines_LEVELS.c", 1090; {
 6382                        	
 6383                        		.dbg	line,	"include\routines_LEVELS.c", 1091; sgx_map_pxl_x += 8;
 6384                        		__add_st.wmiq	8, _sgx_map_pxl_x
         01:C8D1  18         			clc
         01:C8D2  AD 89 26   			lda.l	_sgx_map_pxl_x
         01:C8D5  69 08      			adc.l	#8
         01:C8D7  8D 89 26   			sta.l	_sgx_map_pxl_x
         01:C8DA  90 03      			bcc	!+
         01:C8DC  EE 8A 26   			inc.h	_sgx_map_pxl_x
         01:C8DF             	!:
 6385                        	
 6386                        		.dbg	line,	"include\routines_LEVELS.c", 1092; }
 6387                        	
 6388                        		.dbg	line,	"include\routines_LEVELS.c", 1094; player_counter_anim = 1;
 6389    01:C8DF             	.LL241:
 6390                        		__st.umiq	1, _player_counter_anim
         01:C8DF  A9 01      			lda.l	#1
         01:C8E1  8D 18 23   			sta	_player_counter_anim
 6391                        	
 6392                        		.dbg	line,	"include\routines_LEVELS.c", 1095; player_index_jump = 0;
 6393                        		__st.umiq	0, _player_index_jump
         01:C8E4  9C 19 23   			stz	_player_index_jump
 6394                        	
 6395                        		.dbg	line,	"include\routines_LEVELS.c", 1096; jump_ladder = TRUE;
 6396                        		__st.umiq	1, _jump_ladder
         01:C8E7  A9 01      			lda.l	#1
         01:C8E9  8D 1C 23   			sta	_jump_ladder
 6397                        	
 6398                        		.dbg	line,	"include\routines_LEVELS.c", 1097; player_state = STATE_HANG;
 6399                        		__st.umiq	10, _player_state
         01:C8EC  A9 0A      			lda.l	#10
         01:C8EE  8D 15 23   			sta	_player_state
 6400                        	
 6401                        		.dbg	line,	"include\routines_LEVELS.c", 1098; }
 6402                        	
 6403                        		.dbg	line,	"include\routines_LEVELS.c", 1099; }
 6404    01:C8F1             	.LL240	.alias		.LL242
 6405                        	
 6406                        		.dbg	line,	"include\routines_LEVELS.c", 1102; else if(player_state == STATE_JUMP_RIGHT)
 6407                        		__bra		.LL242
         01:C8F1  4C 9E D8   			bra	.LL242
 6408    01:C8F4             	.LL217:
 6409                        		__ld.umq	_player_state
         01:C8F4  AD 15 23   			lda	_player_state
 6410                        		__equ_b.uiq	5
         01:C8F7  C9 05      			cmp	#5
         01:C8F9  F0 01      			beq	!+
         01:C8FB  18         			clc
         01:C8FC             	!:
 6411                        		__bfalse	.LL243
         01:C8FC  B0 03 4C 30			bcc	.LL243
         01:C900  CD          
 6412                        	
 6413                        		.dbg	line,	"include\routines_LEVELS.c", 1103; {
 6414                        	
 6415                        		.dbg	line,	"include\routines_LEVELS.c", 1104; unsigned char i, camera_y_move;
 6416                        	
 6417                        		.dbg	line,	"include\routines_LEVELS.c", 1105; i = 1;
 6418                        		__st.umiq	1, __update_PLAYER_end - 2  /* i */
         01:C901  A9 01      			lda.l	#1
         01:C903  8D 0B 23   			sta	__update_PLAYER_end - 2
 6419                        	
 6420                        		.dbg	line,	"include\routines_LEVELS.c", 1108; // UPDATE PLAYER TILES //
 6421                        	
 6422                        		.dbg	line,	"include\routines_LEVELS.c", 1109; if(player_counter_anim == 0)
 6423                        		__not.um	_player_counter_anim
         01:C906  AD 18 23   			lda	_player_counter_anim
         01:C909  18         			clc
         01:C90A  D0 01      			bne	!+
         01:C90C  38         			sec
         01:C90D             	!:
 6424                        		__bfalse	.LL244
         01:C90D  90 32      			bcc	.LL244
 6425                        	
 6426                        		.dbg	line,	"include\routines_LEVELS.c", 1110; {
 6427                        	
 6428                        		.dbg	line,	"include\routines_LEVELS.c", 1111; set_far_offset(OFFSET_PLAYER_JUMP,TABLE_PLAYER_TILES_BANK[player_naked],TABLE_PLAYER_TILES_ADR[player_naked]);
 6429                        		__st.wmiq	3584, _bp
         01:C90F  64 EC      			stz.l	_bp
         01:C911  A9 0E      			lda.h	#3584
         01:C913  85 ED      			sta.h	_bp
 6430                        		__ldx.umq	_player_naked
         01:C915  AE 1B 23   			ldx	_player_naked
 6431                        		__ld.uax	_TABLE_PLAYER_TILES_BANK
         01:C918  BD F7 60   			lda	_TABLE_PLAYER_TILES_BANK, x
         01:C91B  C2         			cly
 6432                        		__st.umq	_bp_bank
         01:C91C  85 02      			sta	_bp_bank
 6433                        		__ld2x.umq	_player_naked
         01:C91E  AD 1B 23   			lda	_player_naked
         01:C921  0A         			asl	a
         01:C922  AA         			tax
 6434                        		__ld.wax	_TABLE_PLAYER_TILES_ADR
         01:C923  BD F3 60   			lda.l	_TABLE_PLAYER_TILES_ADR, x
         01:C926  BC F4 60   			ldy.h	_TABLE_PLAYER_TILES_ADR, x
 6435                        		__call		_set_far_offset.3
         01:C929  20 8C E2   			call	_set_far_offset.3
 6436                        	
 6437                        		.dbg	line,	"include\routines_LEVELS.c", 1112; far_load_vram(PLAYER_VRAM_ADR,TILES_16);
 6438                        		__st.wmiq	6144, _di
         01:C92C  64 F0      			stz.l	_di
         01:C92E  A9 18      			lda.h	#6144
         01:C930  85 F1      			sta.h	_di
 6439                        		__st.wmiq	256, _ax
         01:C932  64 F8      			stz.l	_ax
         01:C934  A9 01      			lda.h	#256
         01:C936  85 F9      			sta.h	_ax
 6440                        		 _far_load_vram.2
         01:C938  82         			clx				; Offset to PCE VDC.
         01:C939  20 63 FF   			call	load_vram_x
 6441                        	
 6442                        		.dbg	line,	"include\routines_LEVELS.c", 1114; player_counter_anim = 1;
 6443                        		__st.umiq	1, _player_counter_anim
         01:C93C  A9 01      			lda.l	#1
         01:C93E  8D 18 23   			sta	_player_counter_anim
 6444                        	
 6445                        		.dbg	line,	"include\routines_LEVELS.c", 1115; }
 6446                        	
 6447                        		.dbg	line,	"include\routines_LEVELS.c", 1118; // SELECT PLAYER SPRITE //
 6448                        	
 6449                        		.dbg	line,	"include\routines_LEVELS.c", 1119; spr_set(player_id);
 6450    01:C941             	.LL244:
 6451                        		__ld.umq	_player_id
         01:C941  AD 14 23   			lda	_player_id
 6452                        		__call		_spr_set.1
         01:C944  20 DD E7   			call	_spr_set.1
 6453                        	
 6454                        		.dbg	line,	"include\routines_LEVELS.c", 1122; //**************************************************************************************//
 6455                        	
 6456                        		.dbg	line,	"include\routines_LEVELS.c", 1123; //                                        H MOVE                                        //
 6457                        	
 6458                        		.dbg	line,	"include\routines_LEVELS.c", 1124; //**************************************************************************************//
 6459                        	
 6460                        		.dbg	line,	"include\routines_LEVELS.c", 1126; //--------------------------------------------------------------------------------------//
 6461                        	
 6462                        		.dbg	line,	"include\routines_LEVELS.c", 1127; //                                    WALL COLLISION                                    //
 6463                        	
 6464                        		.dbg	line,	"include\routines_LEVELS.c", 1128; //--------------------------------------------------------------------------------------//
 6465                        	
 6466                        		.dbg	line,	"include\routines_LEVELS.c", 1130; // CHECK COLLISION WITH BOTTOM RIGHT WALL //
 6467                        	
 6468                        		.dbg	line,	"include\routines_LEVELS.c", 1131; check_BG( 24 , 31 );
 6469                        		__ld.wi		24
         01:C947  A9 18      			lda.l	#24
         01:C949  C2         			cly
 6470                        		__pusharg.wr
         01:C94A  A6 8D      			ldx	<__sp
         01:C94C  CA         			dex
         01:C94D  CA         			dex
         01:C94E  95 08      			sta.l	<__stack, x
         01:C950  94 09      			sty.h	<__stack, x
         01:C952  86 8D      			stx	<__sp
 6471                        		__ld.wi		31
         01:C954  A9 1F      			lda.l	#31
         01:C956  C2         			cly
 6472                        		__pusharg.wr
         01:C957  A6 8D      			ldx	<__sp
         01:C959  CA         			dex
         01:C95A  CA         			dex
         01:C95B  95 08      			sta.l	<__stack, x
         01:C95D  94 09      			sty.h	<__stack, x
         01:C95F  86 8D      			stx	<__sp
 6473                        		__call		_check_BG
         01:C961  20 6D FF   			call	_check_BG
 6474                        	
 6475                        		.dbg	line,	"include\routines_LEVELS.c", 1133; if(map_blk_flag != TILE_BG)
 6476                        		__ld.umq	_map_blk_flag
         01:C964  AD AA 2B   			lda	_map_blk_flag
 6477                        		__neq_b.uiq	1
         01:C967  38         			sec
         01:C968  49 01      			eor	#1
         01:C96A  D0 01      			bne	!+
         01:C96C  18         			clc
         01:C96D             	!:
 6478                        		__bfalse	.LL245
         01:C96D  90 78      			bcc	.LL245
 6479                        	
 6480                        		.dbg	line,	"include\routines_LEVELS.c", 1134; {
 6481                        	
 6482                        		.dbg	line,	"include\routines_LEVELS.c", 1135; // CHECK COLLISION WITH TOP RIGHT WALL //
 6483                        	
 6484                        		.dbg	line,	"include\routines_LEVELS.c", 1136; check_BG( 24 , 15 );
 6485                        		__ld.wi		24
         01:C96F  A9 18      			lda.l	#24
         01:C971  C2         			cly
 6486                        		__pusharg.wr
         01:C972  A6 8D      			ldx	<__sp
         01:C974  CA         			dex
         01:C975  CA         			dex
         01:C976  95 08      			sta.l	<__stack, x
         01:C978  94 09      			sty.h	<__stack, x
         01:C97A  86 8D      			stx	<__sp
 6487                        		__ld.wi		15
         01:C97C  A9 0F      			lda.l	#15
         01:C97E  C2         			cly
 6488                        		__pusharg.wr
         01:C97F  A6 8D      			ldx	<__sp
         01:C981  CA         			dex
         01:C982  CA         			dex
         01:C983  95 08      			sta.l	<__stack, x
         01:C985  94 09      			sty.h	<__stack, x
         01:C987  86 8D      			stx	<__sp
 6489                        		__call		_check_BG
         01:C989  20 6D FF   			call	_check_BG
 6490                        	
 6491                        		.dbg	line,	"include\routines_LEVELS.c", 1138; if(map_blk_flag == TILE_BG)
 6492                        		__ld.umq	_map_blk_flag
         01:C98C  AD AA 2B   			lda	_map_blk_flag
 6493                        		__equ_b.uiq	1
         01:C98F  C9 01      			cmp	#1
         01:C991  F0 01      			beq	!+
         01:C993  18         			clc
         01:C994             	!:
 6494                        		__bfalse	.LL246
         01:C994  90 41      			bcc	.LL246
 6495                        	
 6496                        		.dbg	line,	"include\routines_LEVELS.c", 1139; {
 6497                        	
 6498                        		.dbg	line,	"include\routines_LEVELS.c", 1140; check_TILE_DEPTH( 15 , -16 );
 6499                        		__ld.wi		15
         01:C996  A9 0F      			lda.l	#15
         01:C998  C2         			cly
 6500                        		__pusharg.wr
         01:C999  A6 8D      			ldx	<__sp
         01:C99B  CA         			dex
         01:C99C  CA         			dex
         01:C99D  95 08      			sta.l	<__stack, x
         01:C99F  94 09      			sty.h	<__stack, x
         01:C9A1  86 8D      			stx	<__sp
 6501                        		__ld.wi		-16
         01:C9A3  A9 F0      			lda.l	#-16
         01:C9A5  A0 FF      			ldy.h	#-16
 6502                        		__pusharg.wr
         01:C9A7  A6 8D      			ldx	<__sp
         01:C9A9  CA         			dex
         01:C9AA  CA         			dex
         01:C9AB  95 08      			sta.l	<__stack, x
         01:C9AD  94 09      			sty.h	<__stack, x
         01:C9AF  86 8D      			stx	<__sp
 6503                        		__call		_check_TILE_DEPTH
         01:C9B1  20 4F FF   			call	_check_TILE_DEPTH
 6504                        	
 6505                        		.dbg	line,	"include\routines_LEVELS.c", 1142; if(map_blk_flag == TILE_EMPTY && jump_ladder == TRUE)
 6506                        		__not.um	_map_blk_flag
         01:C9B4  AD AA 2B   			lda	_map_blk_flag
         01:C9B7  18         			clc
         01:C9B8  D0 01      			bne	!+
         01:C9BA  38         			sec
         01:C9BB             	!:
 6507                        		__bfalse	.LL248
         01:C9BB  90 08      			bcc	.LL248
 6508                        		__ld.umq	_jump_ladder
         01:C9BD  AD 1C 23   			lda	_jump_ladder
 6509                        		__equ_b.uiq	1
         01:C9C0  C9 01      			cmp	#1
         01:C9C2  F0 01      			beq	!+
         01:C9C4  18         			clc
         01:C9C5             	!:
 6510    01:C9C5             	.LL248:
 6511                        		__bfalse	.LL247
         01:C9C5  90 5F      			bcc	.LL247
 6512                        	
 6513                        		.dbg	line,	"include\routines_LEVELS.c", 1143; {
 6514                        	
 6515                        		.dbg	line,	"include\routines_LEVELS.c", 1144; jump_ladder = FALSE;
 6516                        		__st.umiq	0, _jump_ladder
         01:C9C7  9C 1C 23   			stz	_jump_ladder
 6517                        	
 6518                        		.dbg	line,	"include\routines_LEVELS.c", 1145; player_index_fall = 0;
 6519                        		__st.umiq	0, _player_index_fall
         01:C9CA  9C 1A 23   			stz	_player_index_fall
 6520                        	
 6521                        		.dbg	line,	"include\routines_LEVELS.c", 1146; player_state = STATE_FALL;
 6522                        		__st.umiq	9, _player_state
         01:C9CD  A9 09      			lda.l	#9
         01:C9CF  8D 15 23   			sta	_player_state
 6523                        	
 6524                        		.dbg	line,	"include\routines_LEVELS.c", 1147; return;
 6525                        		__bra		.LL180
         01:C9D2  4C 9E D8   			bra	.LL180
 6526                        	
 6527                        		.dbg	line,	"include\routines_LEVELS.c", 1148; }
 6528                        	
 6529                        		.dbg	line,	"include\routines_LEVELS.c", 1149; }
 6530    01:C9D5             	.LL247	.alias		.LL249
 6531                        	
 6532                        		.dbg	line,	"include\routines_LEVELS.c", 1151; else
 6533                        		__bra		.LL249
         01:C9D5  80 4F      			bra	.LL249
 6534    01:C9D7             	.LL246:
 6535                        	
 6536                        		.dbg	line,	"include\routines_LEVELS.c", 1152; {
 6537                        	
 6538                        		.dbg	line,	"include\routines_LEVELS.c", 1153; sgx_map_pxl_x += 2;
 6539                        		__add_st.wmiq	2, _sgx_map_pxl_x
         01:C9D7  18         			clc
         01:C9D8  AD 89 26   			lda.l	_sgx_map_pxl_x
         01:C9DB  69 02      			adc.l	#2
         01:C9DD  8D 89 26   			sta.l	_sgx_map_pxl_x
         01:C9E0  90 03      			bcc	!+
         01:C9E2  EE 8A 26   			inc.h	_sgx_map_pxl_x
         01:C9E5             	!:
 6540                        	
 6541                        		.dbg	line,	"include\routines_LEVELS.c", 1154; }
 6542    01:C9E5             	.LL249	.alias		.LL250
 6543                        	
 6544                        		.dbg	line,	"include\routines_LEVELS.c", 1155; }
 6545                        	
 6546                        		.dbg	line,	"include\routines_LEVELS.c", 1157; else
 6547                        		__bra		.LL250
         01:C9E5  80 3F      			bra	.LL250
 6548    01:C9E7             	.LL245:
 6549                        	
 6550                        		.dbg	line,	"include\routines_LEVELS.c", 1158; {
 6551                        	
 6552                        		.dbg	line,	"include\routines_LEVELS.c", 1159; check_TILE_DEPTH( 15 , -16 );
 6553                        		__ld.wi		15
         01:C9E7  A9 0F      			lda.l	#15
         01:C9E9  C2         			cly
 6554                        		__pusharg.wr
         01:C9EA  A6 8D      			ldx	<__sp
         01:C9EC  CA         			dex
         01:C9ED  CA         			dex
         01:C9EE  95 08      			sta.l	<__stack, x
         01:C9F0  94 09      			sty.h	<__stack, x
         01:C9F2  86 8D      			stx	<__sp
 6555                        		__ld.wi		-16
         01:C9F4  A9 F0      			lda.l	#-16
         01:C9F6  A0 FF      			ldy.h	#-16
 6556                        		__pusharg.wr
         01:C9F8  A6 8D      			ldx	<__sp
         01:C9FA  CA         			dex
         01:C9FB  CA         			dex
         01:C9FC  95 08      			sta.l	<__stack, x
         01:C9FE  94 09      			sty.h	<__stack, x
         01:CA00  86 8D      			stx	<__sp
 6557                        		__call		_check_TILE_DEPTH
         01:CA02  20 4F FF   			call	_check_TILE_DEPTH
 6558                        	
 6559                        		.dbg	line,	"include\routines_LEVELS.c", 1161; if(map_blk_flag == TILE_EMPTY && jump_ladder == TRUE)
 6560                        		__not.um	_map_blk_flag
         01:CA05  AD AA 2B   			lda	_map_blk_flag
         01:CA08  18         			clc
         01:CA09  D0 01      			bne	!+
         01:CA0B  38         			sec
         01:CA0C             	!:
 6561                        		__bfalse	.LL252
         01:CA0C  90 08      			bcc	.LL252
 6562                        		__ld.umq	_jump_ladder
         01:CA0E  AD 1C 23   			lda	_jump_ladder
 6563                        		__equ_b.uiq	1
         01:CA11  C9 01      			cmp	#1
         01:CA13  F0 01      			beq	!+
         01:CA15  18         			clc
         01:CA16             	!:
 6564    01:CA16             	.LL252:
 6565                        		__bfalse	.LL251
         01:CA16  90 0E      			bcc	.LL251
 6566                        	
 6567                        		.dbg	line,	"include\routines_LEVELS.c", 1162; {
 6568                        	
 6569                        		.dbg	line,	"include\routines_LEVELS.c", 1163; jump_ladder = FALSE;
 6570                        		__st.umiq	0, _jump_ladder
         01:CA18  9C 1C 23   			stz	_jump_ladder
 6571                        	
 6572                        		.dbg	line,	"include\routines_LEVELS.c", 1164; player_index_fall = 0;
 6573                        		__st.umiq	0, _player_index_fall
         01:CA1B  9C 1A 23   			stz	_player_index_fall
 6574                        	
 6575                        		.dbg	line,	"include\routines_LEVELS.c", 1165; player_state = STATE_FALL;
 6576                        		__st.umiq	9, _player_state
         01:CA1E  A9 09      			lda.l	#9
         01:CA20  8D 15 23   			sta	_player_state
 6577                        	
 6578                        		.dbg	line,	"include\routines_LEVELS.c", 1166; return;
 6579                        		__bra		.LL180
         01:CA23  4C 9E D8   			bra	.LL180
 6580                        	
 6581                        		.dbg	line,	"include\routines_LEVELS.c", 1167; }
 6582                        	
 6583                        		.dbg	line,	"include\routines_LEVELS.c", 1168; }
 6584    01:CA26             	.LL251:
 6585    01:CA26             	.LL250:
 6586                        	
 6587                        		.dbg	line,	"include\routines_LEVELS.c", 1173; //**************************************************************************************//
 6588                        	
 6589                        		.dbg	line,	"include\routines_LEVELS.c", 1174; //                                        V MOVE                                        //
 6590                        	
 6591                        		.dbg	line,	"include\routines_LEVELS.c", 1175; //**************************************************************************************//
 6592                        	
 6593                        		.dbg	line,	"include\routines_LEVELS.c", 1177; // UPDATE PLAYER Y POSITION //
 6594                        	
 6595                        		.dbg	line,	"include\routines_LEVELS.c", 1178; if(jump_ladder == FALSE)
 6596                        		__not.um	_jump_ladder
         01:CA26  AD 1C 23   			lda	_jump_ladder
         01:CA29  18         			clc
         01:CA2A  D0 01      			bne	!+
         01:CA2C  38         			sec
         01:CA2D             	!:
 6597                        		__bfalse	.LL253
         01:CA2D  90 1A      			bcc	.LL253
 6598                        	
 6599                        		.dbg	line,	"include\routines_LEVELS.c", 1179; {
 6600                        	
 6601                        		.dbg	line,	"include\routines_LEVELS.c", 1180; player_pos_y += TABLE_PLAYER_JUMP_V[player_index_jump];
 6602                        		__ldx.umq	_player_index_jump
         01:CA2F  AE 19 23   			ldx	_player_index_jump
 6603                        		__ld.bax	_TABLE_PLAYER_JUMP_V
         01:CA32  BD F9 60   			lda	_TABLE_PLAYER_JUMP_V, x
         01:CA35  C2         			cly
         01:CA36  10 01      			bpl	!+
         01:CA38  88         			dey
         01:CA39             	!:
 6604                        		__add_st.wmq	_player_pos_y
         01:CA39  18         			clc
         01:CA3A  6D CF 24   			adc.l	_player_pos_y
         01:CA3D  8D CF 24   			sta.l	_player_pos_y
         01:CA40  98         			tya
         01:CA41  6D D0 24   			adc.h	_player_pos_y
         01:CA44  8D D0 24   			sta.h	_player_pos_y
 6605                        	
 6606                        		.dbg	line,	"include\routines_LEVELS.c", 1181; }
 6607                        	
 6608                        		.dbg	line,	"include\routines_LEVELS.c", 1183; else
 6609                        		__bra		.LL254
         01:CA47  80 18      			bra	.LL254
 6610    01:CA49             	.LL253:
 6611                        	
 6612                        		.dbg	line,	"include\routines_LEVELS.c", 1184; {
 6613                        	
 6614                        		.dbg	line,	"include\routines_LEVELS.c", 1185; player_pos_y += TABLE_PLAYER_JUMP_LADDER[player_index_jump];
 6615                        		__ldx.umq	_player_index_jump
         01:CA49  AE 19 23   			ldx	_player_index_jump
 6616                        		__ld.bax	_TABLE_PLAYER_JUMP_LADDER
         01:CA4C  BD 31 61   			lda	_TABLE_PLAYER_JUMP_LADDER, x
         01:CA4F  C2         			cly
         01:CA50  10 01      			bpl	!+
         01:CA52  88         			dey
         01:CA53             	!:
 6617                        		__add_st.wmq	_player_pos_y
         01:CA53  18         			clc
         01:CA54  6D CF 24   			adc.l	_player_pos_y
         01:CA57  8D CF 24   			sta.l	_player_pos_y
         01:CA5A  98         			tya
         01:CA5B  6D D0 24   			adc.h	_player_pos_y
         01:CA5E  8D D0 24   			sta.h	_player_pos_y
 6618                        	
 6619                        		.dbg	line,	"include\routines_LEVELS.c", 1186; }
 6620    01:CA61             	.LL254:
 6621                        	
 6622                        		.dbg	line,	"include\routines_LEVELS.c", 1190; // IF PLAYER GOES BELOW ITS BASE Y POSITION //
 6623                        	
 6624                        		.dbg	line,	"include\routines_LEVELS.c", 1191; if(player_pos_y >= PLAYER_BASE_Y_POS)
 6625                        		__ld.wm		_player_pos_y
         01:CA61  AD CF 24   			lda.l	_player_pos_y
         01:CA64  AC D0 24   			ldy.h	_player_pos_y
 6626                        		__sge_w.wi	128
         01:CA67  C9 80      			cmp.l	#128		; Subtract integer from Y:A.
         01:CA69  98         			tya
         01:CA6A  E9 00      			sbc.h	#128
         01:CA6C  50 02      			bvc	!+
         01:CA6E  49 80      			eor	#$80		; +ve if Y:A >= integer (signed).
         01:CA70  49 80      	!:		eor	#$80
         01:CA72  0A         			asl	a
 6627                        		__bfalse	.LL255
         01:CA73  90 4E      			bcc	.LL255
 6628                        	
 6629                        		.dbg	line,	"include\routines_LEVELS.c", 1192; {
 6630                        	
 6631                        		.dbg	line,	"include\routines_LEVELS.c", 1193; // THE CAMERA MOVES //
 6632                        	
 6633                        		.dbg	line,	"include\routines_LEVELS.c", 1194; // CALCULATE HOW MANY PIXELS THE CAMERA HAS TO MOVE DOWN //
 6634                        	
 6635                        		.dbg	line,	"include\routines_LEVELS.c", 1195; camera_y_move = player_pos_y - PLAYER_BASE_Y_POS;
 6636                        		__ld.wm		_player_pos_y
         01:CA75  AD CF 24   			lda.l	_player_pos_y
         01:CA78  AC D0 24   			ldy.h	_player_pos_y
 6637                        		__sub.wi	128
         01:CA7B  38         			sec
         01:CA7C  E9 80      			sbc.l	#128
         01:CA7E  B0 01      			bcs	!+
         01:CA80  88         			dey
         01:CA81             	!:
 6638                        		__st.umq	__update_PLAYER_end - 3  /* camera_y_move */
         01:CA81  8D 0A 23   			sta	__update_PLAYER_end - 3
 6639                        	
 6640                        		.dbg	line,	"include\routines_LEVELS.c", 1196; sgx_map_pxl_y += camera_y_move;
 6641                        		__ld.um		__update_PLAYER_end - 3  /* camera_y_move */
         01:CA84  AD 0A 23   			lda	__update_PLAYER_end - 3
         01:CA87  C2         			cly
 6642                        		__add_st.wmq	_sgx_map_pxl_y
         01:CA88  18         			clc
         01:CA89  6D 8B 26   			adc.l	_sgx_map_pxl_y
         01:CA8C  8D 8B 26   			sta.l	_sgx_map_pxl_y
         01:CA8F  98         			tya
         01:CA90  6D 8C 26   			adc.h	_sgx_map_pxl_y
         01:CA93  8D 8C 26   			sta.h	_sgx_map_pxl_y
 6643                        	
 6644                        		.dbg	line,	"include\routines_LEVELS.c", 1198; // IF THE CAMERA HAS REACHED ITS MAX (LOWEST) POSITION //
 6645                        	
 6646                        		.dbg	line,	"include\routines_LEVELS.c", 1199; if(sgx_map_pxl_y > camera_max_y_position)
 6647                        		__ld.wm		_sgx_map_pxl_y
         01:CA96  AD 8B 26   			lda.l	_sgx_map_pxl_y
         01:CA99  AC 8C 26   			ldy.h	_sgx_map_pxl_y
 6648                        		__ugt_w.wm	_camera_max_y_position
         01:CA9C  18         			clc			; Subtract memory+1 from Y:A.
         01:CA9D  ED D1 24   			sbc.l	_camera_max_y_position
         01:CAA0  98         			tya
         01:CAA1  ED D2 24   			sbc.h	_camera_max_y_position		; CS if Y:A > memory.
 6649                        		__bfalse	.LL256
         01:CAA4  90 0C      			bcc	.LL256
 6650                        	
 6651                        		.dbg	line,	"include\routines_LEVELS.c", 1200; {
 6652                        	
 6653                        		.dbg	line,	"include\routines_LEVELS.c", 1201; // THE CAMERA CAN NOT MOVE LOWER //
 6654                        	
 6655                        		.dbg	line,	"include\routines_LEVELS.c", 1202; sgx_map_pxl_y = camera_max_y_position;
 6656                        		__ld.wm		_camera_max_y_position
         01:CAA6  AD D1 24   			lda.l	_camera_max_y_position
         01:CAA9  AC D2 24   			ldy.h	_camera_max_y_position
 6657                        		__st.wmq	_sgx_map_pxl_y
         01:CAAC  8D 8B 26   			sta.l	_sgx_map_pxl_y
         01:CAAF  8C 8C 26   			sty.h	_sgx_map_pxl_y
 6658                        	
 6659                        		.dbg	line,	"include\routines_LEVELS.c", 1203; }
 6660                        	
 6661                        		.dbg	line,	"include\routines_LEVELS.c", 1205; // THE PLAYER STAYS AT ITS BASE Y POSITION //
 6662                        	
 6663                        		.dbg	line,	"include\routines_LEVELS.c", 1206; player_pos_y = PLAYER_BASE_Y_POS;
 6664    01:CAB2             	.LL256:
 6665                        		__st.wmiq	128, _player_pos_y
         01:CAB2  A9 80      			lda.l	#128
         01:CAB4  8D CF 24   			sta.l	_player_pos_y
         01:CAB7  9C D0 24   			stz.h	_player_pos_y
 6666                        	
 6667                        		.dbg	line,	"include\routines_LEVELS.c", 1208; spr_y(player_pos_y);
 6668                        		__ld.wm		_player_pos_y
         01:CABA  AD CF 24   			lda.l	_player_pos_y
         01:CABD  AC D0 24   			ldy.h	_player_pos_y
 6669                        		__call		_spr_y.1
         01:CAC0  20 19 E8   			call	_spr_y.1
 6670                        	
 6671                        		.dbg	line,	"include\routines_LEVELS.c", 1209; }
 6672                        	
 6673                        		.dbg	line,	"include\routines_LEVELS.c", 1212; // UPDATE JUMP INDEX IN THE ARRAY //
 6674                        	
 6675                        		.dbg	line,	"include\routines_LEVELS.c", 1213; if(player_index_jump < jump_max_index)
 6676    01:CAC3             	.LL255:
 6677                        		__ld.umq	_player_index_jump
         01:CAC3  AD 19 23   			lda	_player_index_jump
 6678                        		__ult_b.umq	_jump_max_index
         01:CAC6  CD 1D 23   			cmp	_jump_max_index		; Subtract memory from A.
         01:CAC9  6A         			ror	a		; CC if A < memory.
         01:CACA  49 80      			eor	#$80
         01:CACC  2A         			rol	a
 6679                        		__bfalse	.LL257
         01:CACD  90 03      			bcc	.LL257
 6680                        	
 6681                        		.dbg	line,	"include\routines_LEVELS.c", 1214; {
 6682                        	
 6683                        		.dbg	line,	"include\routines_LEVELS.c", 1215; player_index_jump += 1;
 6684                        		__add_st.umiq	1, _player_index_jump
         01:CACF  EE 19 23   			inc	_player_index_jump
 6685                        	
 6686                        		.dbg	line,	"include\routines_LEVELS.c", 1216; }
 6687                        	
 6688                        		.dbg	line,	"include\routines_LEVELS.c", 1221; //--------------------------------------------------------------------------------------//
 6689                        	
 6690                        		.dbg	line,	"include\routines_LEVELS.c", 1222; //                                   FLOOR COLLISION                                    //
 6691                        	
 6692                        		.dbg	line,	"include\routines_LEVELS.c", 1223; //--------------------------------------------------------------------------------------//
 6693                        	
 6694                        		.dbg	line,	"include\routines_LEVELS.c", 1225; if(player_index_jump > 14)
 6695    01:CAD2             	.LL257:
 6696                        		__ld.umq	_player_index_jump
         01:CAD2  AD 19 23   			lda	_player_index_jump
 6697                        		__ugt_b.uiq	14
         01:CAD5  18         			clc			; Subtract integer+1 from A.
         01:CAD6  E9 0E      			sbc	#14		; CS if A > integer.
 6698                        		__bfalse	.LL258
         01:CAD8  B0 03 4C 8D			bcc	.LL258
         01:CADC  CC          
 6699                        	
 6700                        		.dbg	line,	"include\routines_LEVELS.c", 1226; {
 6701                        	
 6702                        		.dbg	line,	"include\routines_LEVELS.c", 1227; // CHECK COLLISION WITH LEFT FLOOR //
 6703                        	
 6704                        		.dbg	line,	"include\routines_LEVELS.c", 1228; check_BG( 10 , 32 );
 6705                        		__ld.wi		10
         01:CADD  A9 0A      			lda.l	#10
         01:CADF  C2         			cly
 6706                        		__pusharg.wr
         01:CAE0  A6 8D      			ldx	<__sp
         01:CAE2  CA         			dex
         01:CAE3  CA         			dex
         01:CAE4  95 08      			sta.l	<__stack, x
         01:CAE6  94 09      			sty.h	<__stack, x
         01:CAE8  86 8D      			stx	<__sp
 6707                        		__ld.wi		32
         01:CAEA  A9 20      			lda.l	#32
         01:CAEC  C2         			cly
 6708                        		__pusharg.wr
         01:CAED  A6 8D      			ldx	<__sp
         01:CAEF  CA         			dex
         01:CAF0  CA         			dex
         01:CAF1  95 08      			sta.l	<__stack, x
         01:CAF3  94 09      			sty.h	<__stack, x
         01:CAF5  86 8D      			stx	<__sp
 6709                        		__call		_check_BG
         01:CAF7  20 6D FF   			call	_check_BG
 6710                        	
 6711                        		.dbg	line,	"include\routines_LEVELS.c", 1230; // IF PLAYER TOUCHES THE GROUND TO THE LEFT //
 6712                        	
 6713                        		.dbg	line,	"include\routines_LEVELS.c", 1231; if(map_blk_flag == TILE_BG)
 6714                        		__ld.umq	_map_blk_flag
         01:CAFA  AD AA 2B   			lda	_map_blk_flag
 6715                        		__equ_b.uiq	1
         01:CAFD  C9 01      			cmp	#1
         01:CAFF  F0 01      			beq	!+
         01:CB01  18         			clc
         01:CB02             	!:
 6716                        		__bfalse	.LL259
         01:CB02  B0 03 4C B5			bcc	.LL259
         01:CB06  CB          
 6717                        	
 6718                        		.dbg	line,	"include\routines_LEVELS.c", 1232; {
 6719                        	
 6720                        		.dbg	line,	"include\routines_LEVELS.c", 1233; // CALCULATE HOW MANY PIXELS THE PLAYER MOVED INTO THE GROUND //
 6721                        	
 6722                        		.dbg	line,	"include\routines_LEVELS.c", 1234; for(i=1; i<11 ; i++)
 6723                        		__st.umiq	1, __update_PLAYER_end - 2  /* i */
         01:CB07  A9 01      			lda.l	#1
         01:CB09  8D 0B 23   			sta	__update_PLAYER_end - 2
 6724    01:CB0C             	.LL260:
 6725                        		__ld.umq	__update_PLAYER_end - 2  /* i */
         01:CB0C  AD 0B 23   			lda	__update_PLAYER_end - 2
 6726                        		__ult_b.uiq	11
         01:CB0F  C9 0B      			cmp	#11		; Subtract integer from A.
         01:CB11  6A         			ror	a		; CC if A < integer.
         01:CB12  49 80      			eor	#$80
         01:CB14  2A         			rol	a
 6727                        		__btrue		.LL262
         01:CB15  B0 07      			bcs	.LL262
 6728                        		__bra		.LL263
         01:CB17  80 7D      			bra	.LL263
 6729    01:CB19             	.LL261:
 6730                        		__inc.umq	__update_PLAYER_end - 2  /* i */
         01:CB19  EE 0B 23   			inc	__update_PLAYER_end - 2
 6731                        		__bra		.LL260
         01:CB1C  80 EE      			bra	.LL260
 6732    01:CB1E             	.LL262:
 6733                        	
 6734                        		.dbg	line,	"include\routines_LEVELS.c", 1235; {
 6735                        	
 6736                        		.dbg	line,	"include\routines_LEVELS.c", 1236; check_TILE_DEPTH( 10 , i);
 6737                        		__ld.wi		10
         01:CB1E  A9 0A      			lda.l	#10
         01:CB20  C2         			cly
 6738                        		__pusharg.wr
         01:CB21  A6 8D      			ldx	<__sp
         01:CB23  CA         			dex
         01:CB24  CA         			dex
         01:CB25  95 08      			sta.l	<__stack, x
         01:CB27  94 09      			sty.h	<__stack, x
         01:CB29  86 8D      			stx	<__sp
 6739                        		__ld.um		__update_PLAYER_end - 2  /* i */
         01:CB2B  AD 0B 23   			lda	__update_PLAYER_end - 2
         01:CB2E  C2         			cly
 6740                        		__pusharg.wr
         01:CB2F  A6 8D      			ldx	<__sp
         01:CB31  CA         			dex
         01:CB32  CA         			dex
         01:CB33  95 08      			sta.l	<__stack, x
         01:CB35  94 09      			sty.h	<__stack, x
         01:CB37  86 8D      			stx	<__sp
 6741                        		__call		_check_TILE_DEPTH
         01:CB39  20 4F FF   			call	_check_TILE_DEPTH
 6742                        	
 6743                        		.dbg	line,	"include\routines_LEVELS.c", 1238; if(map_blk_flag == TILE_EMPTY)
 6744                        		__not.um	_map_blk_flag
         01:CB3C  AD AA 2B   			lda	_map_blk_flag
         01:CB3F  18         			clc
         01:CB40  D0 01      			bne	!+
         01:CB42  38         			sec
         01:CB43             	!:
 6745                        		__bfalse	.LL264
         01:CB43  90 D4      			bcc	.LL264
 6746                        	
 6747                        		.dbg	line,	"include\routines_LEVELS.c", 1239; {
 6748                        	
 6749                        		.dbg	line,	"include\routines_LEVELS.c", 1240; if(player_pos_y != PLAYER_BASE_Y_POS)
 6750                        		__ld.wm		_player_pos_y
         01:CB45  AD CF 24   			lda.l	_player_pos_y
         01:CB48  AC D0 24   			ldy.h	_player_pos_y
 6751                        		__neq_w.wi	128
         01:CB4B  38         			sec
         01:CB4C  49 80      			eor.l	#128
         01:CB4E  D0 06      			bne	!+
         01:CB50  98         			tya
         01:CB51  49 00      			eor.h	#128
         01:CB53  D0 01      			bne	!+
         01:CB55  18         			clc
         01:CB56             	!:
 6752                        		__bfalse	.LL265
         01:CB56  90 1E      			bcc	.LL265
 6753                        	
 6754                        		.dbg	line,	"include\routines_LEVELS.c", 1241; {
 6755                        	
 6756                        		.dbg	line,	"include\routines_LEVELS.c", 1242; player_pos_y -= (i - 1);
 6757                        		__ld.um		__update_PLAYER_end - 2  /* i */
         01:CB58  AD 0B 23   			lda	__update_PLAYER_end - 2
         01:CB5B  C2         			cly
 6758                        		__sub.wi	1
         01:CB5C  38         			sec
         01:CB5D  E9 01      			sbc.l	#1
         01:CB5F  B0 01      			bcs	!+
         01:CB61  88         			dey
         01:CB62             	!:
 6759                        		__isub_st.wmq	_player_pos_y
         01:CB62  38         			sec
         01:CB63  49 FF      			eor	#$FF
         01:CB65  6D CF 24   			adc.l	_player_pos_y
         01:CB68  8D CF 24   			sta.l	_player_pos_y
         01:CB6B  98         			tya
         01:CB6C  49 FF      			eor	#$FF
         01:CB6E  6D D0 24   			adc.h	_player_pos_y
         01:CB71  8D D0 24   			sta.h	_player_pos_y
 6760                        	
 6761                        		.dbg	line,	"include\routines_LEVELS.c", 1243; }
 6762                        	
 6763                        		.dbg	line,	"include\routines_LEVELS.c", 1245; else
 6764                        		__bra		.LL266
         01:CB74  80 20      			bra	.LL266
 6765    01:CB76             	.LL265:
 6766                        	
 6767                        		.dbg	line,	"include\routines_LEVELS.c", 1246; {
 6768                        	
 6769                        		.dbg	line,	"include\routines_LEVELS.c", 1247; sgx_map_pxl_y -= (i - 1);
 6770                        		__ld.um		__update_PLAYER_end - 2  /* i */
         01:CB76  AD 0B 23   			lda	__update_PLAYER_end - 2
         01:CB79  C2         			cly
 6771                        		__sub.wi	1
         01:CB7A  38         			sec
         01:CB7B  E9 01      			sbc.l	#1
         01:CB7D  B0 01      			bcs	!+
         01:CB7F  88         			dey
         01:CB80             	!:
 6772                        		__isub_st.wmq	_sgx_map_pxl_y
         01:CB80  38         			sec
         01:CB81  49 FF      			eor	#$FF
         01:CB83  6D 8B 26   			adc.l	_sgx_map_pxl_y
         01:CB86  8D 8B 26   			sta.l	_sgx_map_pxl_y
         01:CB89  98         			tya
         01:CB8A  49 FF      			eor	#$FF
         01:CB8C  6D 8C 26   			adc.h	_sgx_map_pxl_y
         01:CB8F  8D 8C 26   			sta.h	_sgx_map_pxl_y
 6773                        	
 6774                        		.dbg	line,	"include\routines_LEVELS.c", 1248; }
 6775    01:CB92             	.LL266	.alias		.LL263
 6776                        	
 6777                        		.dbg	line,	"include\routines_LEVELS.c", 1250; break;
 6778                        		__bra		.LL263
         01:CB92  80 02      			bra	.LL263
 6779                        	
 6780                        		.dbg	line,	"include\routines_LEVELS.c", 1251; }
 6781                        	
 6782                        		.dbg	line,	"include\routines_LEVELS.c", 1252; }
 6783    01:CB94             	.LL264	.alias		.LL261
 6784                        		__bra		.LL261
         01:CB94  80 83      			bra	.LL261
 6785    01:CB96             	.LL263:
 6786                        	
 6787                        		.dbg	line,	"include\routines_LEVELS.c", 1254; // SET PLAYER SPRITE NEW POSITION //
 6788                        	
 6789                        		.dbg	line,	"include\routines_LEVELS.c", 1255; spr_y(player_pos_y);
 6790                        		__ld.wm		_player_pos_y
         01:CB96  AD CF 24   			lda.l	_player_pos_y
         01:CB99  AC D0 24   			ldy.h	_player_pos_y
 6791                        		__call		_spr_y.1
         01:CB9C  20 19 E8   			call	_spr_y.1
 6792                        	
 6793                        		.dbg	line,	"include\routines_LEVELS.c", 1257; player_counter_anim = 1;
 6794                        		__st.umiq	1, _player_counter_anim
         01:CB9F  A9 01      			lda.l	#1
         01:CBA1  8D 18 23   			sta	_player_counter_anim
 6795                        	
 6796                        		.dbg	line,	"include\routines_LEVELS.c", 1258; player_index_jump = 0;
 6797                        		__st.umiq	0, _player_index_jump
         01:CBA4  9C 19 23   			stz	_player_index_jump
 6798                        	
 6799                        		.dbg	line,	"include\routines_LEVELS.c", 1259; jump_ladder = FALSE;
 6800                        		__st.umiq	0, _jump_ladder
         01:CBA7  9C 1C 23   			stz	_jump_ladder
 6801                        	
 6802                        		.dbg	line,	"include\routines_LEVELS.c", 1260; jump_max_index = 34;
 6803                        		__st.umiq	34, _jump_max_index
         01:CBAA  A9 22      			lda.l	#34
         01:CBAC  8D 1D 23   			sta	_jump_max_index
 6804                        	
 6805                        		.dbg	line,	"include\routines_LEVELS.c", 1261; player_state = STATE_IDLE;
 6806                        		__st.umiq	0, _player_state
         01:CBAF  9C 15 23   			stz	_player_state
 6807                        	
 6808                        		.dbg	line,	"include\routines_LEVELS.c", 1262; return;
 6809                        		__bra		.LL180
         01:CBB2  4C 9E D8   			bra	.LL180
 6810                        	
 6811                        		.dbg	line,	"include\routines_LEVELS.c", 1263; }
 6812                        	
 6813                        		.dbg	line,	"include\routines_LEVELS.c", 1265; // IF PLAYER TOUCHES THE GROUND TO THE RIGHT //
 6814                        	
 6815                        		.dbg	line,	"include\routines_LEVELS.c", 1266; else
 6816    01:CBB5             	.LL259:
 6817                        	
 6818                        		.dbg	line,	"include\routines_LEVELS.c", 1267; {
 6819                        	
 6820                        		.dbg	line,	"include\routines_LEVELS.c", 1268; // CHECK COLLISION WITH RIGHT FLOOR //
 6821                        	
 6822                        		.dbg	line,	"include\routines_LEVELS.c", 1269; check_BG( 22 , 32 );
 6823                        		__ld.wi		22
         01:CBB5  A9 16      			lda.l	#22
         01:CBB7  C2         			cly
 6824                        		__pusharg.wr
         01:CBB8  A6 8D      			ldx	<__sp
         01:CBBA  CA         			dex
         01:CBBB  CA         			dex
         01:CBBC  95 08      			sta.l	<__stack, x
         01:CBBE  94 09      			sty.h	<__stack, x
         01:CBC0  86 8D      			stx	<__sp
 6825                        		__ld.wi		32
         01:CBC2  A9 20      			lda.l	#32
         01:CBC4  C2         			cly
 6826                        		__pusharg.wr
         01:CBC5  A6 8D      			ldx	<__sp
         01:CBC7  CA         			dex
         01:CBC8  CA         			dex
         01:CBC9  95 08      			sta.l	<__stack, x
         01:CBCB  94 09      			sty.h	<__stack, x
         01:CBCD  86 8D      			stx	<__sp
 6827                        		__call		_check_BG
         01:CBCF  20 6D FF   			call	_check_BG
 6828                        	
 6829                        		.dbg	line,	"include\routines_LEVELS.c", 1271; if(map_blk_flag == TILE_BG)
 6830                        		__ld.umq	_map_blk_flag
         01:CBD2  AD AA 2B   			lda	_map_blk_flag
 6831                        		__equ_b.uiq	1
         01:CBD5  C9 01      			cmp	#1
         01:CBD7  F0 01      			beq	!+
         01:CBD9  18         			clc
         01:CBDA             	!:
 6832                        		__bfalse	.LL268
         01:CBDA  B0 03 4C 8D			bcc	.LL268
         01:CBDE  CC          
 6833                        	
 6834                        		.dbg	line,	"include\routines_LEVELS.c", 1272; {
 6835                        	
 6836                        		.dbg	line,	"include\routines_LEVELS.c", 1273; // CALCULATE HOW MANY PIXELS THE PLAYER MOVED INTO THE GROUND //
 6837                        	
 6838                        		.dbg	line,	"include\routines_LEVELS.c", 1274; for(i=1; i<11 ; i++)
 6839                        		__st.umiq	1, __update_PLAYER_end - 2  /* i */
         01:CBDF  A9 01      			lda.l	#1
         01:CBE1  8D 0B 23   			sta	__update_PLAYER_end - 2
 6840    01:CBE4             	.LL269:
 6841                        		__ld.umq	__update_PLAYER_end - 2  /* i */
         01:CBE4  AD 0B 23   			lda	__update_PLAYER_end - 2
 6842                        		__ult_b.uiq	11
         01:CBE7  C9 0B      			cmp	#11		; Subtract integer from A.
         01:CBE9  6A         			ror	a		; CC if A < integer.
         01:CBEA  49 80      			eor	#$80
         01:CBEC  2A         			rol	a
 6843                        		__btrue		.LL271
         01:CBED  B0 07      			bcs	.LL271
 6844                        		__bra		.LL272
         01:CBEF  80 7D      			bra	.LL272
 6845    01:CBF1             	.LL270:
 6846                        		__inc.umq	__update_PLAYER_end - 2  /* i */
         01:CBF1  EE 0B 23   			inc	__update_PLAYER_end - 2
 6847                        		__bra		.LL269
         01:CBF4  80 EE      			bra	.LL269
 6848    01:CBF6             	.LL271:
 6849                        	
 6850                        		.dbg	line,	"include\routines_LEVELS.c", 1275; {
 6851                        	
 6852                        		.dbg	line,	"include\routines_LEVELS.c", 1276; check_TILE_DEPTH( 22 , i);
 6853                        		__ld.wi		22
         01:CBF6  A9 16      			lda.l	#22
         01:CBF8  C2         			cly
 6854                        		__pusharg.wr
         01:CBF9  A6 8D      			ldx	<__sp
         01:CBFB  CA         			dex
         01:CBFC  CA         			dex
         01:CBFD  95 08      			sta.l	<__stack, x
         01:CBFF  94 09      			sty.h	<__stack, x
         01:CC01  86 8D      			stx	<__sp
 6855                        		__ld.um		__update_PLAYER_end - 2  /* i */
         01:CC03  AD 0B 23   			lda	__update_PLAYER_end - 2
         01:CC06  C2         			cly
 6856                        		__pusharg.wr
         01:CC07  A6 8D      			ldx	<__sp
         01:CC09  CA         			dex
         01:CC0A  CA         			dex
         01:CC0B  95 08      			sta.l	<__stack, x
         01:CC0D  94 09      			sty.h	<__stack, x
         01:CC0F  86 8D      			stx	<__sp
 6857                        		__call		_check_TILE_DEPTH
         01:CC11  20 4F FF   			call	_check_TILE_DEPTH
 6858                        	
 6859                        		.dbg	line,	"include\routines_LEVELS.c", 1278; if(map_blk_flag == TILE_EMPTY)
 6860                        		__not.um	_map_blk_flag
         01:CC14  AD AA 2B   			lda	_map_blk_flag
         01:CC17  18         			clc
         01:CC18  D0 01      			bne	!+
         01:CC1A  38         			sec
         01:CC1B             	!:
 6861                        		__bfalse	.LL273
         01:CC1B  90 D4      			bcc	.LL273
 6862                        	
 6863                        		.dbg	line,	"include\routines_LEVELS.c", 1279; {
 6864                        	
 6865                        		.dbg	line,	"include\routines_LEVELS.c", 1280; if(player_pos_y != PLAYER_BASE_Y_POS)
 6866                        		__ld.wm		_player_pos_y
         01:CC1D  AD CF 24   			lda.l	_player_pos_y
         01:CC20  AC D0 24   			ldy.h	_player_pos_y
 6867                        		__neq_w.wi	128
         01:CC23  38         			sec
         01:CC24  49 80      			eor.l	#128
         01:CC26  D0 06      			bne	!+
         01:CC28  98         			tya
         01:CC29  49 00      			eor.h	#128
         01:CC2B  D0 01      			bne	!+
         01:CC2D  18         			clc
         01:CC2E             	!:
 6868                        		__bfalse	.LL274
         01:CC2E  90 1E      			bcc	.LL274
 6869                        	
 6870                        		.dbg	line,	"include\routines_LEVELS.c", 1281; {
 6871                        	
 6872                        		.dbg	line,	"include\routines_LEVELS.c", 1282; player_pos_y -= (i - 1);
 6873                        		__ld.um		__update_PLAYER_end - 2  /* i */
         01:CC30  AD 0B 23   			lda	__update_PLAYER_end - 2
         01:CC33  C2         			cly
 6874                        		__sub.wi	1
         01:CC34  38         			sec
         01:CC35  E9 01      			sbc.l	#1
         01:CC37  B0 01      			bcs	!+
         01:CC39  88         			dey
         01:CC3A             	!:
 6875                        		__isub_st.wmq	_player_pos_y
         01:CC3A  38         			sec
         01:CC3B  49 FF      			eor	#$FF
         01:CC3D  6D CF 24   			adc.l	_player_pos_y
         01:CC40  8D CF 24   			sta.l	_player_pos_y
         01:CC43  98         			tya
         01:CC44  49 FF      			eor	#$FF
         01:CC46  6D D0 24   			adc.h	_player_pos_y
         01:CC49  8D D0 24   			sta.h	_player_pos_y
 6876                        	
 6877                        		.dbg	line,	"include\routines_LEVELS.c", 1283; }
 6878                        	
 6879                        		.dbg	line,	"include\routines_LEVELS.c", 1285; else
 6880                        		__bra		.LL275
         01:CC4C  80 20      			bra	.LL275
 6881    01:CC4E             	.LL274:
 6882                        	
 6883                        		.dbg	line,	"include\routines_LEVELS.c", 1286; {
 6884                        	
 6885                        		.dbg	line,	"include\routines_LEVELS.c", 1287; sgx_map_pxl_y -= (i - 1);
 6886                        		__ld.um		__update_PLAYER_end - 2  /* i */
         01:CC4E  AD 0B 23   			lda	__update_PLAYER_end - 2
         01:CC51  C2         			cly
 6887                        		__sub.wi	1
         01:CC52  38         			sec
         01:CC53  E9 01      			sbc.l	#1
         01:CC55  B0 01      			bcs	!+
         01:CC57  88         			dey
         01:CC58             	!:
 6888                        		__isub_st.wmq	_sgx_map_pxl_y
         01:CC58  38         			sec
         01:CC59  49 FF      			eor	#$FF
         01:CC5B  6D 8B 26   			adc.l	_sgx_map_pxl_y
         01:CC5E  8D 8B 26   			sta.l	_sgx_map_pxl_y
         01:CC61  98         			tya
         01:CC62  49 FF      			eor	#$FF
         01:CC64  6D 8C 26   			adc.h	_sgx_map_pxl_y
         01:CC67  8D 8C 26   			sta.h	_sgx_map_pxl_y
 6889                        	
 6890                        		.dbg	line,	"include\routines_LEVELS.c", 1288; }
 6891    01:CC6A             	.LL275	.alias		.LL272
 6892                        	
 6893                        		.dbg	line,	"include\routines_LEVELS.c", 1290; break;
 6894                        		__bra		.LL272
         01:CC6A  80 02      			bra	.LL272
 6895                        	
 6896                        		.dbg	line,	"include\routines_LEVELS.c", 1291; }
 6897                        	
 6898                        		.dbg	line,	"include\routines_LEVELS.c", 1292; }
 6899    01:CC6C             	.LL273	.alias		.LL270
 6900                        		__bra		.LL270
         01:CC6C  80 83      			bra	.LL270
 6901    01:CC6E             	.LL272:
 6902                        	
 6903                        		.dbg	line,	"include\routines_LEVELS.c", 1294; // SET PLAYER SPRITE NEW POSITION //
 6904                        	
 6905                        		.dbg	line,	"include\routines_LEVELS.c", 1295; spr_y(player_pos_y);
 6906                        		__ld.wm		_player_pos_y
         01:CC6E  AD CF 24   			lda.l	_player_pos_y
         01:CC71  AC D0 24   			ldy.h	_player_pos_y
 6907                        		__call		_spr_y.1
         01:CC74  20 19 E8   			call	_spr_y.1
 6908                        	
 6909                        		.dbg	line,	"include\routines_LEVELS.c", 1297; player_counter_anim = 1;
 6910                        		__st.umiq	1, _player_counter_anim
         01:CC77  A9 01      			lda.l	#1
         01:CC79  8D 18 23   			sta	_player_counter_anim
 6911                        	
 6912                        		.dbg	line,	"include\routines_LEVELS.c", 1298; player_index_jump = 0;
 6913                        		__st.umiq	0, _player_index_jump
         01:CC7C  9C 19 23   			stz	_player_index_jump
 6914                        	
 6915                        		.dbg	line,	"include\routines_LEVELS.c", 1299; jump_ladder = FALSE;
 6916                        		__st.umiq	0, _jump_ladder
         01:CC7F  9C 1C 23   			stz	_jump_ladder
 6917                        	
 6918                        		.dbg	line,	"include\routines_LEVELS.c", 1300; jump_max_index = 34;
 6919                        		__st.umiq	34, _jump_max_index
         01:CC82  A9 22      			lda.l	#34
         01:CC84  8D 1D 23   			sta	_jump_max_index
 6920                        	
 6921                        		.dbg	line,	"include\routines_LEVELS.c", 1301; player_state = STATE_IDLE;
 6922                        		__st.umiq	0, _player_state
         01:CC87  9C 15 23   			stz	_player_state
 6923                        	
 6924                        		.dbg	line,	"include\routines_LEVELS.c", 1302; return;
 6925                        		__bra		.LL180
         01:CC8A  4C 9E D8   			bra	.LL180
 6926                        	
 6927                        		.dbg	line,	"include\routines_LEVELS.c", 1303; }
 6928                        	
 6929                        		.dbg	line,	"include\routines_LEVELS.c", 1304; }
 6930    01:CC8D             	.LL268:
 6931    01:CC8D             	.LL267:
 6932                        	
 6933                        		.dbg	line,	"include\routines_LEVELS.c", 1305; }
 6934                        	
 6935                        		.dbg	line,	"include\routines_LEVELS.c", 1310; //--------------------------------------------------------------------------------------//
 6936                        	
 6937                        		.dbg	line,	"include\routines_LEVELS.c", 1311; //                                   LADDER COLLISION                                   //
 6938                        	
 6939                        		.dbg	line,	"include\routines_LEVELS.c", 1312; //--------------------------------------------------------------------------------------//
 6940                        	
 6941                        		.dbg	line,	"include\routines_LEVELS.c", 1314; if(player_index_jump > 4)
 6942    01:CC8D             	.LL258:
 6943                        		__ld.umq	_player_index_jump
         01:CC8D  AD 19 23   			lda	_player_index_jump
 6944                        		__ugt_b.uiq	4
         01:CC90  18         			clc			; Subtract integer+1 from A.
         01:CC91  E9 04      			sbc	#4		; CS if A > integer.
 6945                        		__bfalse	.LL276
         01:CC93  B0 03 4C 24			bcc	.LL276
         01:CC97  CD          
 6946                        	
 6947                        		.dbg	line,	"include\routines_LEVELS.c", 1315; {
 6948                        	
 6949                        		.dbg	line,	"include\routines_LEVELS.c", 1316; check_BG( 16 , 16 );
 6950                        		__ld.wi		16
         01:CC98  A9 10      			lda.l	#16
         01:CC9A  C2         			cly
 6951                        		__pusharg.wr
         01:CC9B  A6 8D      			ldx	<__sp
         01:CC9D  CA         			dex
         01:CC9E  CA         			dex
         01:CC9F  95 08      			sta.l	<__stack, x
         01:CCA1  94 09      			sty.h	<__stack, x
         01:CCA3  86 8D      			stx	<__sp
 6952                        		__ld.wi		16
         01:CCA5  A9 10      			lda.l	#16
         01:CCA7  C2         			cly
 6953                        		__pusharg.wr
         01:CCA8  A6 8D      			ldx	<__sp
         01:CCAA  CA         			dex
         01:CCAB  CA         			dex
         01:CCAC  95 08      			sta.l	<__stack, x
         01:CCAE  94 09      			sty.h	<__stack, x
         01:CCB0  86 8D      			stx	<__sp
 6954                        		__call		_check_BG
         01:CCB2  20 6D FF   			call	_check_BG
 6955                        	
 6956                        		.dbg	line,	"include\routines_LEVELS.c", 1318; // IF PLAYER HITS THE LADDER //
 6957                        	
 6958                        		.dbg	line,	"include\routines_LEVELS.c", 1319; if(map_blk_flag == TILE_LADDER)
 6959                        		__ld.umq	_map_blk_flag
         01:CCB5  AD AA 2B   			lda	_map_blk_flag
 6960                        		__equ_b.uiq	2
         01:CCB8  C9 02      			cmp	#2
         01:CCBA  F0 01      			beq	!+
         01:CCBC  18         			clc
         01:CCBD             	!:
 6961                        		__bfalse	.LL277
         01:CCBD  90 65      			bcc	.LL277
 6962                        	
 6963                        		.dbg	line,	"include\routines_LEVELS.c", 1320; {
 6964                        	
 6965                        		.dbg	line,	"include\routines_LEVELS.c", 1321; // CAMERA GOES 8 PX BACKWARD //
 6966                        	
 6967                        		.dbg	line,	"include\routines_LEVELS.c", 1322; sgx_map_pxl_x = ( (sgx_map_pxl_x >> 3) << 3 );
 6968                        		__ld.wm		_sgx_map_pxl_x
         01:CCBF  AD 89 26   			lda.l	_sgx_map_pxl_x
         01:CCC2  AC 8A 26   			ldy.h	_sgx_map_pxl_x
 6969                        		__lsr.wi	3
         01:CCC5  84 00      			sty	__temp
         01:CCC7  20 3A E2   			jsr	lsrw3
 6970                        		__asl.wi	3
         01:CCCA  84 00      			sty	__temp
         01:CCCC  20 D7 E1   			jsr	aslw3
 6971                        		__st.wmq	_sgx_map_pxl_x
         01:CCCF  8D 89 26   			sta.l	_sgx_map_pxl_x
         01:CCD2  8C 8A 26   			sty.h	_sgx_map_pxl_x
 6972                        	
 6973                        		.dbg	line,	"include\routines_LEVELS.c", 1324; // SO WE UPDATE THE MAP //
 6974                        	
 6975                        		.dbg	line,	"include\routines_LEVELS.c", 1325; sgx_scroll_map();
 6976                        		__call		_sgx_scroll_map
         01:CCD5  20 81 FF   			call	_sgx_scroll_map
 6977                        	
 6978                        		.dbg	line,	"include\routines_LEVELS.c", 1327; // CHECK IF THE PLAYER STANDS RIGHT TO THE LADDER //
 6979                        	
 6980                        		.dbg	line,	"include\routines_LEVELS.c", 1328; check_BG( 31 , 16 );
 6981                        		__ld.wi		31
         01:CCD8  A9 1F      			lda.l	#31
         01:CCDA  C2         			cly
 6982                        		__pusharg.wr
         01:CCDB  A6 8D      			ldx	<__sp
         01:CCDD  CA         			dex
         01:CCDE  CA         			dex
         01:CCDF  95 08      			sta.l	<__stack, x
         01:CCE1  94 09      			sty.h	<__stack, x
         01:CCE3  86 8D      			stx	<__sp
 6983                        		__ld.wi		16
         01:CCE5  A9 10      			lda.l	#16
         01:CCE7  C2         			cly
 6984                        		__pusharg.wr
         01:CCE8  A6 8D      			ldx	<__sp
         01:CCEA  CA         			dex
         01:CCEB  CA         			dex
         01:CCEC  95 08      			sta.l	<__stack, x
         01:CCEE  94 09      			sty.h	<__stack, x
         01:CCF0  86 8D      			stx	<__sp
 6985                        		__call		_check_BG
         01:CCF2  20 6D FF   			call	_check_BG
 6986                        	
 6987                        		.dbg	line,	"include\routines_LEVELS.c", 1330; if(map_blk_flag == TILE_LADDER)
 6988                        		__ld.umq	_map_blk_flag
         01:CCF5  AD AA 2B   			lda	_map_blk_flag
 6989                        		__equ_b.uiq	2
         01:CCF8  C9 02      			cmp	#2
         01:CCFA  F0 01      			beq	!+
         01:CCFC  18         			clc
         01:CCFD             	!:
 6990                        		__bfalse	.LL278
         01:CCFD  90 0E      			bcc	.LL278
 6991                        	
 6992                        		.dbg	line,	"include\routines_LEVELS.c", 1331; {
 6993                        	
 6994                        		.dbg	line,	"include\routines_LEVELS.c", 1332; sgx_map_pxl_x += 8;
 6995                        		__add_st.wmiq	8, _sgx_map_pxl_x
         01:CCFF  18         			clc
         01:CD00  AD 89 26   			lda.l	_sgx_map_pxl_x
         01:CD03  69 08      			adc.l	#8
         01:CD05  8D 89 26   			sta.l	_sgx_map_pxl_x
         01:CD08  90 03      			bcc	!+
         01:CD0A  EE 8A 26   			inc.h	_sgx_map_pxl_x
         01:CD0D             	!:
 6996                        	
 6997                        		.dbg	line,	"include\routines_LEVELS.c", 1333; }
 6998                        	
 6999                        		.dbg	line,	"include\routines_LEVELS.c", 1335; player_counter_anim = 1;
 7000    01:CD0D             	.LL278:
 7001                        		__st.umiq	1, _player_counter_anim
         01:CD0D  A9 01      			lda.l	#1
         01:CD0F  8D 18 23   			sta	_player_counter_anim
 7002                        	
 7003                        		.dbg	line,	"include\routines_LEVELS.c", 1336; player_index_jump = 0;
 7004                        		__st.umiq	0, _player_index_jump
         01:CD12  9C 19 23   			stz	_player_index_jump
 7005                        	
 7006                        		.dbg	line,	"include\routines_LEVELS.c", 1337; jump_ladder = TRUE;
 7007                        		__st.umiq	1, _jump_ladder
         01:CD15  A9 01      			lda.l	#1
         01:CD17  8D 1C 23   			sta	_jump_ladder
 7008                        	
 7009                        		.dbg	line,	"include\routines_LEVELS.c", 1338; jump_max_index = 29;
 7010                        		__st.umiq	29, _jump_max_index
         01:CD1A  A9 1D      			lda.l	#29
         01:CD1C  8D 1D 23   			sta	_jump_max_index
 7011                        	
 7012                        		.dbg	line,	"include\routines_LEVELS.c", 1339; player_state = STATE_HANG;
 7013                        		__st.umiq	10, _player_state
         01:CD1F  A9 0A      			lda.l	#10
         01:CD21  8D 15 23   			sta	_player_state
 7014                        	
 7015                        		.dbg	line,	"include\routines_LEVELS.c", 1340; }
 7016                        	
 7017                        		.dbg	line,	"include\routines_LEVELS.c", 1341; }
 7018    01:CD24             	.LL277:
 7019                        	
 7020                        		.dbg	line,	"include\routines_LEVELS.c", 1344; // SET PLAYER SPRITE NEW POSITION //
 7021                        	
 7022                        		.dbg	line,	"include\routines_LEVELS.c", 1345; spr_y(player_pos_y);
 7023    01:CD24             	.LL276:
 7024                        		__ld.wm		_player_pos_y
         01:CD24  AD CF 24   			lda.l	_player_pos_y
         01:CD27  AC D0 24   			ldy.h	_player_pos_y
 7025                        		__call		_spr_y.1
         01:CD2A  20 19 E8   			call	_spr_y.1
 7026                        	
 7027                        		.dbg	line,	"include\routines_LEVELS.c", 1346; }
 7028                        	
 7029                        		.dbg	line,	"include\routines_LEVELS.c", 1349; else if(player_state == STATE_JUMP_LEFT)
 7030                        		__bra		.LL279
         01:CD2D  4C 9E D8   			bra	.LL279
 7031    01:CD30             	.LL243:
 7032                        		__ld.umq	_player_state
         01:CD30  AD 15 23   			lda	_player_state
 7033                        		__equ_b.uiq	6
         01:CD33  C9 06      			cmp	#6
         01:CD35  F0 01      			beq	!+
         01:CD37  18         			clc
         01:CD38             	!:
 7034                        		__bfalse	.LL280
         01:CD38  B0 03 4C 6C			bcc	.LL280
         01:CD3C  D1          
 7035                        	
 7036                        		.dbg	line,	"include\routines_LEVELS.c", 1350; {
 7037                        	
 7038                        		.dbg	line,	"include\routines_LEVELS.c", 1351; unsigned char i, camera_y_move;
 7039                        	
 7040                        		.dbg	line,	"include\routines_LEVELS.c", 1352; i = 1;
 7041                        		__st.umiq	1, __update_PLAYER_end - 4  /* i */
         01:CD3D  A9 01      			lda.l	#1
         01:CD3F  8D 09 23   			sta	__update_PLAYER_end - 4
 7042                        	
 7043                        		.dbg	line,	"include\routines_LEVELS.c", 1355; // UPDATE PLAYER TILES //
 7044                        	
 7045                        		.dbg	line,	"include\routines_LEVELS.c", 1356; if(player_counter_anim == 0)
 7046                        		__not.um	_player_counter_anim
         01:CD42  AD 18 23   			lda	_player_counter_anim
         01:CD45  18         			clc
         01:CD46  D0 01      			bne	!+
         01:CD48  38         			sec
         01:CD49             	!:
 7047                        		__bfalse	.LL281
         01:CD49  90 32      			bcc	.LL281
 7048                        	
 7049                        		.dbg	line,	"include\routines_LEVELS.c", 1357; {
 7050                        	
 7051                        		.dbg	line,	"include\routines_LEVELS.c", 1358; set_far_offset(OFFSET_PLAYER_JUMP,TABLE_PLAYER_TILES_BANK[player_naked],TABLE_PLAYER_TILES_ADR[player_naked]);
 7052                        		__st.wmiq	3584, _bp
         01:CD4B  64 EC      			stz.l	_bp
         01:CD4D  A9 0E      			lda.h	#3584
         01:CD4F  85 ED      			sta.h	_bp
 7053                        		__ldx.umq	_player_naked
         01:CD51  AE 1B 23   			ldx	_player_naked
 7054                        		__ld.uax	_TABLE_PLAYER_TILES_BANK
         01:CD54  BD F7 60   			lda	_TABLE_PLAYER_TILES_BANK, x
         01:CD57  C2         			cly
 7055                        		__st.umq	_bp_bank
         01:CD58  85 02      			sta	_bp_bank
 7056                        		__ld2x.umq	_player_naked
         01:CD5A  AD 1B 23   			lda	_player_naked
         01:CD5D  0A         			asl	a
         01:CD5E  AA         			tax
 7057                        		__ld.wax	_TABLE_PLAYER_TILES_ADR
         01:CD5F  BD F3 60   			lda.l	_TABLE_PLAYER_TILES_ADR, x
         01:CD62  BC F4 60   			ldy.h	_TABLE_PLAYER_TILES_ADR, x
 7058                        		__call		_set_far_offset.3
         01:CD65  20 8C E2   			call	_set_far_offset.3
 7059                        	
 7060                        		.dbg	line,	"include\routines_LEVELS.c", 1359; far_load_vram(PLAYER_VRAM_ADR,TILES_16);
 7061                        		__st.wmiq	6144, _di
         01:CD68  64 F0      			stz.l	_di
         01:CD6A  A9 18      			lda.h	#6144
         01:CD6C  85 F1      			sta.h	_di
 7062                        		__st.wmiq	256, _ax
         01:CD6E  64 F8      			stz.l	_ax
         01:CD70  A9 01      			lda.h	#256
         01:CD72  85 F9      			sta.h	_ax
 7063                        		 _far_load_vram.2
         01:CD74  82         			clx				; Offset to PCE VDC.
         01:CD75  20 63 FF   			call	load_vram_x
 7064                        	
 7065                        		.dbg	line,	"include\routines_LEVELS.c", 1361; player_counter_anim = 1;
 7066                        		__st.umiq	1, _player_counter_anim
         01:CD78  A9 01      			lda.l	#1
         01:CD7A  8D 18 23   			sta	_player_counter_anim
 7067                        	
 7068                        		.dbg	line,	"include\routines_LEVELS.c", 1362; }
 7069                        	
 7070                        		.dbg	line,	"include\routines_LEVELS.c", 1365; // SELECT PLAYER SPRITE //
 7071                        	
 7072                        		.dbg	line,	"include\routines_LEVELS.c", 1366; spr_set(player_id);
 7073    01:CD7D             	.LL281:
 7074                        		__ld.umq	_player_id
         01:CD7D  AD 14 23   			lda	_player_id
 7075                        		__call		_spr_set.1
         01:CD80  20 DD E7   			call	_spr_set.1
 7076                        	
 7077                        		.dbg	line,	"include\routines_LEVELS.c", 1369; //**************************************************************************************//
 7078                        	
 7079                        		.dbg	line,	"include\routines_LEVELS.c", 1370; //                                        H MOVE                                        //
 7080                        	
 7081                        		.dbg	line,	"include\routines_LEVELS.c", 1371; //**************************************************************************************//
 7082                        	
 7083                        		.dbg	line,	"include\routines_LEVELS.c", 1373; //--------------------------------------------------------------------------------------//
 7084                        	
 7085                        		.dbg	line,	"include\routines_LEVELS.c", 1374; //                                    WALL COLLISION                                    //
 7086                        	
 7087                        		.dbg	line,	"include\routines_LEVELS.c", 1375; //--------------------------------------------------------------------------------------//
 7088                        	
 7089                        		.dbg	line,	"include\routines_LEVELS.c", 1377; // CHECK COLLISION WITH BOTTOM LEFT WALL //
 7090                        	
 7091                        		.dbg	line,	"include\routines_LEVELS.c", 1378; check_BG( 8 , 31 );
 7092                        		__ld.wi		8
         01:CD83  A9 08      			lda.l	#8
         01:CD85  C2         			cly
 7093                        		__pusharg.wr
         01:CD86  A6 8D      			ldx	<__sp
         01:CD88  CA         			dex
         01:CD89  CA         			dex
         01:CD8A  95 08      			sta.l	<__stack, x
         01:CD8C  94 09      			sty.h	<__stack, x
         01:CD8E  86 8D      			stx	<__sp
 7094                        		__ld.wi		31
         01:CD90  A9 1F      			lda.l	#31
         01:CD92  C2         			cly
 7095                        		__pusharg.wr
         01:CD93  A6 8D      			ldx	<__sp
         01:CD95  CA         			dex
         01:CD96  CA         			dex
         01:CD97  95 08      			sta.l	<__stack, x
         01:CD99  94 09      			sty.h	<__stack, x
         01:CD9B  86 8D      			stx	<__sp
 7096                        		__call		_check_BG
         01:CD9D  20 6D FF   			call	_check_BG
 7097                        	
 7098                        		.dbg	line,	"include\routines_LEVELS.c", 1380; if(map_blk_flag != TILE_BG)
 7099                        		__ld.umq	_map_blk_flag
         01:CDA0  AD AA 2B   			lda	_map_blk_flag
 7100                        		__neq_b.uiq	1
         01:CDA3  38         			sec
         01:CDA4  49 01      			eor	#1
         01:CDA6  D0 01      			bne	!+
         01:CDA8  18         			clc
         01:CDA9             	!:
 7101                        		__bfalse	.LL282
         01:CDA9  90 78      			bcc	.LL282
 7102                        	
 7103                        		.dbg	line,	"include\routines_LEVELS.c", 1381; {
 7104                        	
 7105                        		.dbg	line,	"include\routines_LEVELS.c", 1382; // CHECK COLLISION WITH TOP RIGHT WALL //
 7106                        	
 7107                        		.dbg	line,	"include\routines_LEVELS.c", 1383; check_BG( 8 , 15 );
 7108                        		__ld.wi		8
         01:CDAB  A9 08      			lda.l	#8
         01:CDAD  C2         			cly
 7109                        		__pusharg.wr
         01:CDAE  A6 8D      			ldx	<__sp
         01:CDB0  CA         			dex
         01:CDB1  CA         			dex
         01:CDB2  95 08      			sta.l	<__stack, x
         01:CDB4  94 09      			sty.h	<__stack, x
         01:CDB6  86 8D      			stx	<__sp
 7110                        		__ld.wi		15
         01:CDB8  A9 0F      			lda.l	#15
         01:CDBA  C2         			cly
 7111                        		__pusharg.wr
         01:CDBB  A6 8D      			ldx	<__sp
         01:CDBD  CA         			dex
         01:CDBE  CA         			dex
         01:CDBF  95 08      			sta.l	<__stack, x
         01:CDC1  94 09      			sty.h	<__stack, x
         01:CDC3  86 8D      			stx	<__sp
 7112                        		__call		_check_BG
         01:CDC5  20 6D FF   			call	_check_BG
 7113                        	
 7114                        		.dbg	line,	"include\routines_LEVELS.c", 1385; if(map_blk_flag == TILE_BG)
 7115                        		__ld.umq	_map_blk_flag
         01:CDC8  AD AA 2B   			lda	_map_blk_flag
 7116                        		__equ_b.uiq	1
         01:CDCB  C9 01      			cmp	#1
         01:CDCD  F0 01      			beq	!+
         01:CDCF  18         			clc
         01:CDD0             	!:
 7117                        		__bfalse	.LL283
         01:CDD0  90 41      			bcc	.LL283
 7118                        	
 7119                        		.dbg	line,	"include\routines_LEVELS.c", 1386; {
 7120                        	
 7121                        		.dbg	line,	"include\routines_LEVELS.c", 1387; check_TILE_DEPTH( 15 , -16 );
 7122                        		__ld.wi		15
         01:CDD2  A9 0F      			lda.l	#15
         01:CDD4  C2         			cly
 7123                        		__pusharg.wr
         01:CDD5  A6 8D      			ldx	<__sp
         01:CDD7  CA         			dex
         01:CDD8  CA         			dex
         01:CDD9  95 08      			sta.l	<__stack, x
         01:CDDB  94 09      			sty.h	<__stack, x
         01:CDDD  86 8D      			stx	<__sp
 7124                        		__ld.wi		-16
         01:CDDF  A9 F0      			lda.l	#-16
         01:CDE1  A0 FF      			ldy.h	#-16
 7125                        		__pusharg.wr
         01:CDE3  A6 8D      			ldx	<__sp
         01:CDE5  CA         			dex
         01:CDE6  CA         			dex
         01:CDE7  95 08      			sta.l	<__stack, x
         01:CDE9  94 09      			sty.h	<__stack, x
         01:CDEB  86 8D      			stx	<__sp
 7126                        		__call		_check_TILE_DEPTH
         01:CDED  20 4F FF   			call	_check_TILE_DEPTH
 7127                        	
 7128                        		.dbg	line,	"include\routines_LEVELS.c", 1389; if(map_blk_flag == TILE_EMPTY && jump_ladder == TRUE)
 7129                        		__not.um	_map_blk_flag
         01:CDF0  AD AA 2B   			lda	_map_blk_flag
         01:CDF3  18         			clc
         01:CDF4  D0 01      			bne	!+
         01:CDF6  38         			sec
         01:CDF7             	!:
 7130                        		__bfalse	.LL285
         01:CDF7  90 08      			bcc	.LL285
 7131                        		__ld.umq	_jump_ladder
         01:CDF9  AD 1C 23   			lda	_jump_ladder
 7132                        		__equ_b.uiq	1
         01:CDFC  C9 01      			cmp	#1
         01:CDFE  F0 01      			beq	!+
         01:CE00  18         			clc
         01:CE01             	!:
 7133    01:CE01             	.LL285:
 7134                        		__bfalse	.LL284
         01:CE01  90 5F      			bcc	.LL284
 7135                        	
 7136                        		.dbg	line,	"include\routines_LEVELS.c", 1390; {
 7137                        	
 7138                        		.dbg	line,	"include\routines_LEVELS.c", 1391; jump_ladder = FALSE;
 7139                        		__st.umiq	0, _jump_ladder
         01:CE03  9C 1C 23   			stz	_jump_ladder
 7140                        	
 7141                        		.dbg	line,	"include\routines_LEVELS.c", 1392; player_index_fall = 0;
 7142                        		__st.umiq	0, _player_index_fall
         01:CE06  9C 1A 23   			stz	_player_index_fall
 7143                        	
 7144                        		.dbg	line,	"include\routines_LEVELS.c", 1393; player_state = STATE_FALL;
 7145                        		__st.umiq	9, _player_state
         01:CE09  A9 09      			lda.l	#9
         01:CE0B  8D 15 23   			sta	_player_state
 7146                        	
 7147                        		.dbg	line,	"include\routines_LEVELS.c", 1394; return;
 7148                        		__bra		.LL180
         01:CE0E  4C 9E D8   			bra	.LL180
 7149                        	
 7150                        		.dbg	line,	"include\routines_LEVELS.c", 1395; }
 7151                        	
 7152                        		.dbg	line,	"include\routines_LEVELS.c", 1396; }
 7153    01:CE11             	.LL284	.alias		.LL286
 7154                        	
 7155                        		.dbg	line,	"include\routines_LEVELS.c", 1398; else
 7156                        		__bra		.LL286
         01:CE11  80 4F      			bra	.LL286
 7157    01:CE13             	.LL283:
 7158                        	
 7159                        		.dbg	line,	"include\routines_LEVELS.c", 1399; {
 7160                        	
 7161                        		.dbg	line,	"include\routines_LEVELS.c", 1400; sgx_map_pxl_x -= 2;
 7162                        		__sub_st.wmiq	2, _sgx_map_pxl_x
         01:CE13  38         			sec
         01:CE14  AD 89 26   			lda.l	_sgx_map_pxl_x
         01:CE17  E9 02      			sbc.l	#2
         01:CE19  8D 89 26   			sta.l	_sgx_map_pxl_x
         01:CE1C  B0 03      			bcs	!+
         01:CE1E  CE 8A 26   			dec.h	_sgx_map_pxl_x
         01:CE21             	!:
 7163                        	
 7164                        		.dbg	line,	"include\routines_LEVELS.c", 1401; }
 7165    01:CE21             	.LL286	.alias		.LL287
 7166                        	
 7167                        		.dbg	line,	"include\routines_LEVELS.c", 1402; }
 7168                        	
 7169                        		.dbg	line,	"include\routines_LEVELS.c", 1404; else
 7170                        		__bra		.LL287
         01:CE21  80 3F      			bra	.LL287
 7171    01:CE23             	.LL282:
 7172                        	
 7173                        		.dbg	line,	"include\routines_LEVELS.c", 1405; {
 7174                        	
 7175                        		.dbg	line,	"include\routines_LEVELS.c", 1406; check_TILE_DEPTH( 15 , -16 );
 7176                        		__ld.wi		15
         01:CE23  A9 0F      			lda.l	#15
         01:CE25  C2         			cly
 7177                        		__pusharg.wr
         01:CE26  A6 8D      			ldx	<__sp
         01:CE28  CA         			dex
         01:CE29  CA         			dex
         01:CE2A  95 08      			sta.l	<__stack, x
         01:CE2C  94 09      			sty.h	<__stack, x
         01:CE2E  86 8D      			stx	<__sp
 7178                        		__ld.wi		-16
         01:CE30  A9 F0      			lda.l	#-16
         01:CE32  A0 FF      			ldy.h	#-16
 7179                        		__pusharg.wr
         01:CE34  A6 8D      			ldx	<__sp
         01:CE36  CA         			dex
         01:CE37  CA         			dex
         01:CE38  95 08      			sta.l	<__stack, x
         01:CE3A  94 09      			sty.h	<__stack, x
         01:CE3C  86 8D      			stx	<__sp
 7180                        		__call		_check_TILE_DEPTH
         01:CE3E  20 4F FF   			call	_check_TILE_DEPTH
 7181                        	
 7182                        		.dbg	line,	"include\routines_LEVELS.c", 1408; if(map_blk_flag == TILE_EMPTY && jump_ladder == TRUE)
 7183                        		__not.um	_map_blk_flag
         01:CE41  AD AA 2B   			lda	_map_blk_flag
         01:CE44  18         			clc
         01:CE45  D0 01      			bne	!+
         01:CE47  38         			sec
         01:CE48             	!:
 7184                        		__bfalse	.LL289
         01:CE48  90 08      			bcc	.LL289
 7185                        		__ld.umq	_jump_ladder
         01:CE4A  AD 1C 23   			lda	_jump_ladder
 7186                        		__equ_b.uiq	1
         01:CE4D  C9 01      			cmp	#1
         01:CE4F  F0 01      			beq	!+
         01:CE51  18         			clc
         01:CE52             	!:
 7187    01:CE52             	.LL289:
 7188                        		__bfalse	.LL288
         01:CE52  90 0E      			bcc	.LL288
 7189                        	
 7190                        		.dbg	line,	"include\routines_LEVELS.c", 1409; {
 7191                        	
 7192                        		.dbg	line,	"include\routines_LEVELS.c", 1410; jump_ladder = FALSE;
 7193                        		__st.umiq	0, _jump_ladder
         01:CE54  9C 1C 23   			stz	_jump_ladder
 7194                        	
 7195                        		.dbg	line,	"include\routines_LEVELS.c", 1411; player_index_fall = 0;
 7196                        		__st.umiq	0, _player_index_fall
         01:CE57  9C 1A 23   			stz	_player_index_fall
 7197                        	
 7198                        		.dbg	line,	"include\routines_LEVELS.c", 1412; player_state = STATE_FALL;
 7199                        		__st.umiq	9, _player_state
         01:CE5A  A9 09      			lda.l	#9
         01:CE5C  8D 15 23   			sta	_player_state
 7200                        	
 7201                        		.dbg	line,	"include\routines_LEVELS.c", 1413; return;
 7202                        		__bra		.LL180
         01:CE5F  4C 9E D8   			bra	.LL180
 7203                        	
 7204                        		.dbg	line,	"include\routines_LEVELS.c", 1414; }
 7205                        	
 7206                        		.dbg	line,	"include\routines_LEVELS.c", 1415; }
 7207    01:CE62             	.LL288:
 7208    01:CE62             	.LL287:
 7209                        	
 7210                        		.dbg	line,	"include\routines_LEVELS.c", 1420; //**************************************************************************************//
 7211                        	
 7212                        		.dbg	line,	"include\routines_LEVELS.c", 1421; //                                        V MOVE                                        //
 7213                        	
 7214                        		.dbg	line,	"include\routines_LEVELS.c", 1422; //**************************************************************************************//
 7215                        	
 7216                        		.dbg	line,	"include\routines_LEVELS.c", 1424; // UPDATE PLAYER Y POSITION //
 7217                        	
 7218                        		.dbg	line,	"include\routines_LEVELS.c", 1425; if(jump_ladder == FALSE)
 7219                        		__not.um	_jump_ladder
         01:CE62  AD 1C 23   			lda	_jump_ladder
         01:CE65  18         			clc
         01:CE66  D0 01      			bne	!+
         01:CE68  38         			sec
         01:CE69             	!:
 7220                        		__bfalse	.LL290
         01:CE69  90 1A      			bcc	.LL290
 7221                        	
 7222                        		.dbg	line,	"include\routines_LEVELS.c", 1426; {
 7223                        	
 7224                        		.dbg	line,	"include\routines_LEVELS.c", 1427; player_pos_y += TABLE_PLAYER_JUMP_V[player_index_jump];
 7225                        		__ldx.umq	_player_index_jump
         01:CE6B  AE 19 23   			ldx	_player_index_jump
 7226                        		__ld.bax	_TABLE_PLAYER_JUMP_V
         01:CE6E  BD F9 60   			lda	_TABLE_PLAYER_JUMP_V, x
         01:CE71  C2         			cly
         01:CE72  10 01      			bpl	!+
         01:CE74  88         			dey
         01:CE75             	!:
 7227                        		__add_st.wmq	_player_pos_y
         01:CE75  18         			clc
         01:CE76  6D CF 24   			adc.l	_player_pos_y
         01:CE79  8D CF 24   			sta.l	_player_pos_y
         01:CE7C  98         			tya
         01:CE7D  6D D0 24   			adc.h	_player_pos_y
         01:CE80  8D D0 24   			sta.h	_player_pos_y
 7228                        	
 7229                        		.dbg	line,	"include\routines_LEVELS.c", 1428; }
 7230                        	
 7231                        		.dbg	line,	"include\routines_LEVELS.c", 1430; else
 7232                        		__bra		.LL291
         01:CE83  80 18      			bra	.LL291
 7233    01:CE85             	.LL290:
 7234                        	
 7235                        		.dbg	line,	"include\routines_LEVELS.c", 1431; {
 7236                        	
 7237                        		.dbg	line,	"include\routines_LEVELS.c", 1432; player_pos_y += TABLE_PLAYER_JUMP_LADDER[player_index_jump];
 7238                        		__ldx.umq	_player_index_jump
         01:CE85  AE 19 23   			ldx	_player_index_jump
 7239                        		__ld.bax	_TABLE_PLAYER_JUMP_LADDER
         01:CE88  BD 31 61   			lda	_TABLE_PLAYER_JUMP_LADDER, x
         01:CE8B  C2         			cly
         01:CE8C  10 01      			bpl	!+
         01:CE8E  88         			dey
         01:CE8F             	!:
 7240                        		__add_st.wmq	_player_pos_y
         01:CE8F  18         			clc
         01:CE90  6D CF 24   			adc.l	_player_pos_y
         01:CE93  8D CF 24   			sta.l	_player_pos_y
         01:CE96  98         			tya
         01:CE97  6D D0 24   			adc.h	_player_pos_y
         01:CE9A  8D D0 24   			sta.h	_player_pos_y
 7241                        	
 7242                        		.dbg	line,	"include\routines_LEVELS.c", 1433; }
 7243    01:CE9D             	.LL291:
 7244                        	
 7245                        		.dbg	line,	"include\routines_LEVELS.c", 1436; // IF PLAYER GOES BELOW ITS BASE Y POSITION //
 7246                        	
 7247                        		.dbg	line,	"include\routines_LEVELS.c", 1437; if(player_pos_y >= PLAYER_BASE_Y_POS)
 7248                        		__ld.wm		_player_pos_y
         01:CE9D  AD CF 24   			lda.l	_player_pos_y
         01:CEA0  AC D0 24   			ldy.h	_player_pos_y
 7249                        		__sge_w.wi	128
         01:CEA3  C9 80      			cmp.l	#128		; Subtract integer from Y:A.
         01:CEA5  98         			tya
         01:CEA6  E9 00      			sbc.h	#128
         01:CEA8  50 02      			bvc	!+
         01:CEAA  49 80      			eor	#$80		; +ve if Y:A >= integer (signed).
         01:CEAC  49 80      	!:		eor	#$80
         01:CEAE  0A         			asl	a
 7250                        		__bfalse	.LL292
         01:CEAF  90 4E      			bcc	.LL292
 7251                        	
 7252                        		.dbg	line,	"include\routines_LEVELS.c", 1438; {
 7253                        	
 7254                        		.dbg	line,	"include\routines_LEVELS.c", 1439; // THE CAMERA MOVES //
 7255                        	
 7256                        		.dbg	line,	"include\routines_LEVELS.c", 1440; // CALCULATE HOW MANY PIXELS THE CAMERA HAS TO MOVE DOWN //
 7257                        	
 7258                        		.dbg	line,	"include\routines_LEVELS.c", 1441; camera_y_move = player_pos_y - PLAYER_BASE_Y_POS;
 7259                        		__ld.wm		_player_pos_y
         01:CEB1  AD CF 24   			lda.l	_player_pos_y
         01:CEB4  AC D0 24   			ldy.h	_player_pos_y
 7260                        		__sub.wi	128
         01:CEB7  38         			sec
         01:CEB8  E9 80      			sbc.l	#128
         01:CEBA  B0 01      			bcs	!+
         01:CEBC  88         			dey
         01:CEBD             	!:
 7261                        		__st.umq	__update_PLAYER_end - 5  /* camera_y_move */
         01:CEBD  8D 08 23   			sta	__update_PLAYER_end - 5
 7262                        	
 7263                        		.dbg	line,	"include\routines_LEVELS.c", 1442; sgx_map_pxl_y += camera_y_move;
 7264                        		__ld.um		__update_PLAYER_end - 5  /* camera_y_move */
         01:CEC0  AD 08 23   			lda	__update_PLAYER_end - 5
         01:CEC3  C2         			cly
 7265                        		__add_st.wmq	_sgx_map_pxl_y
         01:CEC4  18         			clc
         01:CEC5  6D 8B 26   			adc.l	_sgx_map_pxl_y
         01:CEC8  8D 8B 26   			sta.l	_sgx_map_pxl_y
         01:CECB  98         			tya
         01:CECC  6D 8C 26   			adc.h	_sgx_map_pxl_y
         01:CECF  8D 8C 26   			sta.h	_sgx_map_pxl_y
 7266                        	
 7267                        		.dbg	line,	"include\routines_LEVELS.c", 1444; // IF THE CAMERA HAS REACHED ITS MAX (LOWEST) POSITION //
 7268                        	
 7269                        		.dbg	line,	"include\routines_LEVELS.c", 1445; if(sgx_map_pxl_y > camera_max_y_position)
 7270                        		__ld.wm		_sgx_map_pxl_y
         01:CED2  AD 8B 26   			lda.l	_sgx_map_pxl_y
         01:CED5  AC 8C 26   			ldy.h	_sgx_map_pxl_y
 7271                        		__ugt_w.wm	_camera_max_y_position
         01:CED8  18         			clc			; Subtract memory+1 from Y:A.
         01:CED9  ED D1 24   			sbc.l	_camera_max_y_position
         01:CEDC  98         			tya
         01:CEDD  ED D2 24   			sbc.h	_camera_max_y_position		; CS if Y:A > memory.
 7272                        		__bfalse	.LL293
         01:CEE0  90 0C      			bcc	.LL293
 7273                        	
 7274                        		.dbg	line,	"include\routines_LEVELS.c", 1446; {
 7275                        	
 7276                        		.dbg	line,	"include\routines_LEVELS.c", 1447; // THE CAMERA CAN NOT MOVE LOWER //
 7277                        	
 7278                        		.dbg	line,	"include\routines_LEVELS.c", 1448; sgx_map_pxl_y = camera_max_y_position;
 7279                        		__ld.wm		_camera_max_y_position
         01:CEE2  AD D1 24   			lda.l	_camera_max_y_position
         01:CEE5  AC D2 24   			ldy.h	_camera_max_y_position
 7280                        		__st.wmq	_sgx_map_pxl_y
         01:CEE8  8D 8B 26   			sta.l	_sgx_map_pxl_y
         01:CEEB  8C 8C 26   			sty.h	_sgx_map_pxl_y
 7281                        	
 7282                        		.dbg	line,	"include\routines_LEVELS.c", 1449; }
 7283                        	
 7284                        		.dbg	line,	"include\routines_LEVELS.c", 1451; // THE PLAYER STAYS AT ITS BASE Y POSITION //
 7285                        	
 7286                        		.dbg	line,	"include\routines_LEVELS.c", 1452; player_pos_y = PLAYER_BASE_Y_POS;
 7287    01:CEEE             	.LL293:
 7288                        		__st.wmiq	128, _player_pos_y
         01:CEEE  A9 80      			lda.l	#128
         01:CEF0  8D CF 24   			sta.l	_player_pos_y
         01:CEF3  9C D0 24   			stz.h	_player_pos_y
 7289                        	
 7290                        		.dbg	line,	"include\routines_LEVELS.c", 1454; spr_y(player_pos_y);
 7291                        		__ld.wm		_player_pos_y
         01:CEF6  AD CF 24   			lda.l	_player_pos_y
         01:CEF9  AC D0 24   			ldy.h	_player_pos_y
 7292                        		__call		_spr_y.1
         01:CEFC  20 19 E8   			call	_spr_y.1
 7293                        	
 7294                        		.dbg	line,	"include\routines_LEVELS.c", 1455; }
 7295                        	
 7296                        		.dbg	line,	"include\routines_LEVELS.c", 1458; // UPDATE JUMP INDEX IN THE ARRAY //
 7297                        	
 7298                        		.dbg	line,	"include\routines_LEVELS.c", 1459; if(player_index_jump < jump_max_index)
 7299    01:CEFF             	.LL292:
 7300                        		__ld.umq	_player_index_jump
         01:CEFF  AD 19 23   			lda	_player_index_jump
 7301                        		__ult_b.umq	_jump_max_index
         01:CF02  CD 1D 23   			cmp	_jump_max_index		; Subtract memory from A.
         01:CF05  6A         			ror	a		; CC if A < memory.
         01:CF06  49 80      			eor	#$80
         01:CF08  2A         			rol	a
 7302                        		__bfalse	.LL294
         01:CF09  90 03      			bcc	.LL294
 7303                        	
 7304                        		.dbg	line,	"include\routines_LEVELS.c", 1460; {
 7305                        	
 7306                        		.dbg	line,	"include\routines_LEVELS.c", 1461; player_index_jump += 1;
 7307                        		__add_st.umiq	1, _player_index_jump
         01:CF0B  EE 19 23   			inc	_player_index_jump
 7308                        	
 7309                        		.dbg	line,	"include\routines_LEVELS.c", 1462; }
 7310                        	
 7311                        		.dbg	line,	"include\routines_LEVELS.c", 1467; //--------------------------------------------------------------------------------------//
 7312                        	
 7313                        		.dbg	line,	"include\routines_LEVELS.c", 1468; //                                   FLOOR COLLISION                                    //
 7314                        	
 7315                        		.dbg	line,	"include\routines_LEVELS.c", 1469; //--------------------------------------------------------------------------------------//
 7316                        	
 7317                        		.dbg	line,	"include\routines_LEVELS.c", 1471; if(player_index_jump > 14)
 7318    01:CF0E             	.LL294:
 7319                        		__ld.umq	_player_index_jump
         01:CF0E  AD 19 23   			lda	_player_index_jump
 7320                        		__ugt_b.uiq	14
         01:CF11  18         			clc			; Subtract integer+1 from A.
         01:CF12  E9 0E      			sbc	#14		; CS if A > integer.
 7321                        		__bfalse	.LL295
         01:CF14  B0 03 4C C9			bcc	.LL295
         01:CF18  D0          
 7322                        	
 7323                        		.dbg	line,	"include\routines_LEVELS.c", 1472; {
 7324                        	
 7325                        		.dbg	line,	"include\routines_LEVELS.c", 1473; // CHECK COLLISION WITH LEFT FLOOR //
 7326                        	
 7327                        		.dbg	line,	"include\routines_LEVELS.c", 1474; check_BG( 10 , 32 );
 7328                        		__ld.wi		10
         01:CF19  A9 0A      			lda.l	#10
         01:CF1B  C2         			cly
 7329                        		__pusharg.wr
         01:CF1C  A6 8D      			ldx	<__sp
         01:CF1E  CA         			dex
         01:CF1F  CA         			dex
         01:CF20  95 08      			sta.l	<__stack, x
         01:CF22  94 09      			sty.h	<__stack, x
         01:CF24  86 8D      			stx	<__sp
 7330                        		__ld.wi		32
         01:CF26  A9 20      			lda.l	#32
         01:CF28  C2         			cly
 7331                        		__pusharg.wr
         01:CF29  A6 8D      			ldx	<__sp
         01:CF2B  CA         			dex
         01:CF2C  CA         			dex
         01:CF2D  95 08      			sta.l	<__stack, x
         01:CF2F  94 09      			sty.h	<__stack, x
         01:CF31  86 8D      			stx	<__sp
 7332                        		__call		_check_BG
         01:CF33  20 6D FF   			call	_check_BG
 7333                        	
 7334                        		.dbg	line,	"include\routines_LEVELS.c", 1476; if(map_blk_flag == TILE_BG)
 7335                        		__ld.umq	_map_blk_flag
         01:CF36  AD AA 2B   			lda	_map_blk_flag
 7336                        		__equ_b.uiq	1
         01:CF39  C9 01      			cmp	#1
         01:CF3B  F0 01      			beq	!+
         01:CF3D  18         			clc
         01:CF3E             	!:
 7337                        		__bfalse	.LL296
         01:CF3E  B0 03 4C F1			bcc	.LL296
         01:CF42  CF          
 7338                        	
 7339                        		.dbg	line,	"include\routines_LEVELS.c", 1477; {
 7340                        	
 7341                        		.dbg	line,	"include\routines_LEVELS.c", 1478; // CALCULATE HOW MANY PIXELS THE PLAYER MOVED INTO THE GROUND //
 7342                        	
 7343                        		.dbg	line,	"include\routines_LEVELS.c", 1479; for(i=1; i<11 ; i++)
 7344                        		__st.umiq	1, __update_PLAYER_end - 4  /* i */
         01:CF43  A9 01      			lda.l	#1
         01:CF45  8D 09 23   			sta	__update_PLAYER_end - 4
 7345    01:CF48             	.LL297:
 7346                        		__ld.umq	__update_PLAYER_end - 4  /* i */
         01:CF48  AD 09 23   			lda	__update_PLAYER_end - 4
 7347                        		__ult_b.uiq	11
         01:CF4B  C9 0B      			cmp	#11		; Subtract integer from A.
         01:CF4D  6A         			ror	a		; CC if A < integer.
         01:CF4E  49 80      			eor	#$80
         01:CF50  2A         			rol	a
 7348                        		__btrue		.LL299
         01:CF51  B0 07      			bcs	.LL299
 7349                        		__bra		.LL300
         01:CF53  80 7D      			bra	.LL300
 7350    01:CF55             	.LL298:
 7351                        		__inc.umq	__update_PLAYER_end - 4  /* i */
         01:CF55  EE 09 23   			inc	__update_PLAYER_end - 4
 7352                        		__bra		.LL297
         01:CF58  80 EE      			bra	.LL297
 7353    01:CF5A             	.LL299:
 7354                        	
 7355                        		.dbg	line,	"include\routines_LEVELS.c", 1480; {
 7356                        	
 7357                        		.dbg	line,	"include\routines_LEVELS.c", 1481; check_TILE_DEPTH( 10 , i);
 7358                        		__ld.wi		10
         01:CF5A  A9 0A      			lda.l	#10
         01:CF5C  C2         			cly
 7359                        		__pusharg.wr
         01:CF5D  A6 8D      			ldx	<__sp
         01:CF5F  CA         			dex
         01:CF60  CA         			dex
         01:CF61  95 08      			sta.l	<__stack, x
         01:CF63  94 09      			sty.h	<__stack, x
         01:CF65  86 8D      			stx	<__sp
 7360                        		__ld.um		__update_PLAYER_end - 4  /* i */
         01:CF67  AD 09 23   			lda	__update_PLAYER_end - 4
         01:CF6A  C2         			cly
 7361                        		__pusharg.wr
         01:CF6B  A6 8D      			ldx	<__sp
         01:CF6D  CA         			dex
         01:CF6E  CA         			dex
         01:CF6F  95 08      			sta.l	<__stack, x
         01:CF71  94 09      			sty.h	<__stack, x
         01:CF73  86 8D      			stx	<__sp
 7362                        		__call		_check_TILE_DEPTH
         01:CF75  20 4F FF   			call	_check_TILE_DEPTH
 7363                        	
 7364                        		.dbg	line,	"include\routines_LEVELS.c", 1483; if(map_blk_flag == TILE_EMPTY)
 7365                        		__not.um	_map_blk_flag
         01:CF78  AD AA 2B   			lda	_map_blk_flag
         01:CF7B  18         			clc
         01:CF7C  D0 01      			bne	!+
         01:CF7E  38         			sec
         01:CF7F             	!:
 7366                        		__bfalse	.LL301
         01:CF7F  90 D4      			bcc	.LL301
 7367                        	
 7368                        		.dbg	line,	"include\routines_LEVELS.c", 1484; {
 7369                        	
 7370                        		.dbg	line,	"include\routines_LEVELS.c", 1485; if(player_pos_y != PLAYER_BASE_Y_POS)
 7371                        		__ld.wm		_player_pos_y
         01:CF81  AD CF 24   			lda.l	_player_pos_y
         01:CF84  AC D0 24   			ldy.h	_player_pos_y
 7372                        		__neq_w.wi	128
         01:CF87  38         			sec
         01:CF88  49 80      			eor.l	#128
         01:CF8A  D0 06      			bne	!+
         01:CF8C  98         			tya
         01:CF8D  49 00      			eor.h	#128
         01:CF8F  D0 01      			bne	!+
         01:CF91  18         			clc
         01:CF92             	!:
 7373                        		__bfalse	.LL302
         01:CF92  90 1E      			bcc	.LL302
 7374                        	
 7375                        		.dbg	line,	"include\routines_LEVELS.c", 1486; {
 7376                        	
 7377                        		.dbg	line,	"include\routines_LEVELS.c", 1487; player_pos_y -= (i - 1);
 7378                        		__ld.um		__update_PLAYER_end - 4  /* i */
         01:CF94  AD 09 23   			lda	__update_PLAYER_end - 4
         01:CF97  C2         			cly
 7379                        		__sub.wi	1
         01:CF98  38         			sec
         01:CF99  E9 01      			sbc.l	#1
         01:CF9B  B0 01      			bcs	!+
         01:CF9D  88         			dey
         01:CF9E             	!:
 7380                        		__isub_st.wmq	_player_pos_y
         01:CF9E  38         			sec
         01:CF9F  49 FF      			eor	#$FF
         01:CFA1  6D CF 24   			adc.l	_player_pos_y
         01:CFA4  8D CF 24   			sta.l	_player_pos_y
         01:CFA7  98         			tya
         01:CFA8  49 FF      			eor	#$FF
         01:CFAA  6D D0 24   			adc.h	_player_pos_y
         01:CFAD  8D D0 24   			sta.h	_player_pos_y
 7381                        	
 7382                        		.dbg	line,	"include\routines_LEVELS.c", 1488; }
 7383                        	
 7384                        		.dbg	line,	"include\routines_LEVELS.c", 1490; else
 7385                        		__bra		.LL303
         01:CFB0  80 20      			bra	.LL303
 7386    01:CFB2             	.LL302:
 7387                        	
 7388                        		.dbg	line,	"include\routines_LEVELS.c", 1491; {
 7389                        	
 7390                        		.dbg	line,	"include\routines_LEVELS.c", 1492; sgx_map_pxl_y -= (i - 1);
 7391                        		__ld.um		__update_PLAYER_end - 4  /* i */
         01:CFB2  AD 09 23   			lda	__update_PLAYER_end - 4
         01:CFB5  C2         			cly
 7392                        		__sub.wi	1
         01:CFB6  38         			sec
         01:CFB7  E9 01      			sbc.l	#1
         01:CFB9  B0 01      			bcs	!+
         01:CFBB  88         			dey
         01:CFBC             	!:
 7393                        		__isub_st.wmq	_sgx_map_pxl_y
         01:CFBC  38         			sec
         01:CFBD  49 FF      			eor	#$FF
         01:CFBF  6D 8B 26   			adc.l	_sgx_map_pxl_y
         01:CFC2  8D 8B 26   			sta.l	_sgx_map_pxl_y
         01:CFC5  98         			tya
         01:CFC6  49 FF      			eor	#$FF
         01:CFC8  6D 8C 26   			adc.h	_sgx_map_pxl_y
         01:CFCB  8D 8C 26   			sta.h	_sgx_map_pxl_y
 7394                        	
 7395                        		.dbg	line,	"include\routines_LEVELS.c", 1493; }
 7396    01:CFCE             	.LL303	.alias		.LL300
 7397                        	
 7398                        		.dbg	line,	"include\routines_LEVELS.c", 1495; break;
 7399                        		__bra		.LL300
         01:CFCE  80 02      			bra	.LL300
 7400                        	
 7401                        		.dbg	line,	"include\routines_LEVELS.c", 1496; }
 7402                        	
 7403                        		.dbg	line,	"include\routines_LEVELS.c", 1497; }
 7404    01:CFD0             	.LL301	.alias		.LL298
 7405                        		__bra		.LL298
         01:CFD0  80 83      			bra	.LL298
 7406    01:CFD2             	.LL300:
 7407                        	
 7408                        		.dbg	line,	"include\routines_LEVELS.c", 1499; // SET PLAYER SPRITE NEW POSITION //
 7409                        	
 7410                        		.dbg	line,	"include\routines_LEVELS.c", 1500; spr_y(player_pos_y);
 7411                        		__ld.wm		_player_pos_y
         01:CFD2  AD CF 24   			lda.l	_player_pos_y
         01:CFD5  AC D0 24   			ldy.h	_player_pos_y
 7412                        		__call		_spr_y.1
         01:CFD8  20 19 E8   			call	_spr_y.1
 7413                        	
 7414                        		.dbg	line,	"include\routines_LEVELS.c", 1502; player_counter_anim = 1;
 7415                        		__st.umiq	1, _player_counter_anim
         01:CFDB  A9 01      			lda.l	#1
         01:CFDD  8D 18 23   			sta	_player_counter_anim
 7416                        	
 7417                        		.dbg	line,	"include\routines_LEVELS.c", 1503; player_index_jump = 0;
 7418                        		__st.umiq	0, _player_index_jump
         01:CFE0  9C 19 23   			stz	_player_index_jump
 7419                        	
 7420                        		.dbg	line,	"include\routines_LEVELS.c", 1504; jump_ladder = FALSE;
 7421                        		__st.umiq	0, _jump_ladder
         01:CFE3  9C 1C 23   			stz	_jump_ladder
 7422                        	
 7423                        		.dbg	line,	"include\routines_LEVELS.c", 1505; jump_max_index = 34;
 7424                        		__st.umiq	34, _jump_max_index
         01:CFE6  A9 22      			lda.l	#34
         01:CFE8  8D 1D 23   			sta	_jump_max_index
 7425                        	
 7426                        		.dbg	line,	"include\routines_LEVELS.c", 1506; player_state = STATE_IDLE;
 7427                        		__st.umiq	0, _player_state
         01:CFEB  9C 15 23   			stz	_player_state
 7428                        	
 7429                        		.dbg	line,	"include\routines_LEVELS.c", 1507; return;
 7430                        		__bra		.LL180
         01:CFEE  4C 9E D8   			bra	.LL180
 7431                        	
 7432                        		.dbg	line,	"include\routines_LEVELS.c", 1508; }
 7433                        	
 7434                        		.dbg	line,	"include\routines_LEVELS.c", 1510; else
 7435    01:CFF1             	.LL296:
 7436                        	
 7437                        		.dbg	line,	"include\routines_LEVELS.c", 1511; {
 7438                        	
 7439                        		.dbg	line,	"include\routines_LEVELS.c", 1512; // CHECK COLLISION WITH RIGHT FLOOR //
 7440                        	
 7441                        		.dbg	line,	"include\routines_LEVELS.c", 1513; check_BG( 22 , 32 );
 7442                        		__ld.wi		22
         01:CFF1  A9 16      			lda.l	#22
         01:CFF3  C2         			cly
 7443                        		__pusharg.wr
         01:CFF4  A6 8D      			ldx	<__sp
         01:CFF6  CA         			dex
         01:CFF7  CA         			dex
         01:CFF8  95 08      			sta.l	<__stack, x
         01:CFFA  94 09      			sty.h	<__stack, x
         01:CFFC  86 8D      			stx	<__sp
 7444                        		__ld.wi		32
         01:CFFE  A9 20      			lda.l	#32
         01:D000  C2         			cly
 7445                        		__pusharg.wr
         01:D001  A6 8D      			ldx	<__sp
         01:D003  CA         			dex
         01:D004  CA         			dex
         01:D005  95 08      			sta.l	<__stack, x
         01:D007  94 09      			sty.h	<__stack, x
         01:D009  86 8D      			stx	<__sp
 7446                        		__call		_check_BG
         01:D00B  20 6D FF   			call	_check_BG
 7447                        	
 7448                        		.dbg	line,	"include\routines_LEVELS.c", 1515; if(map_blk_flag == TILE_BG)
 7449                        		__ld.umq	_map_blk_flag
         01:D00E  AD AA 2B   			lda	_map_blk_flag
 7450                        		__equ_b.uiq	1
         01:D011  C9 01      			cmp	#1
         01:D013  F0 01      			beq	!+
         01:D015  18         			clc
         01:D016             	!:
 7451                        		__bfalse	.LL305
         01:D016  B0 03 4C C9			bcc	.LL305
         01:D01A  D0          
 7452                        	
 7453                        		.dbg	line,	"include\routines_LEVELS.c", 1516; {
 7454                        	
 7455                        		.dbg	line,	"include\routines_LEVELS.c", 1517; // CALCULATE HOW MANY PIXELS THE PLAYER MOVED INTO THE GROUND //
 7456                        	
 7457                        		.dbg	line,	"include\routines_LEVELS.c", 1518; for(i=1; i<11 ; i++)
 7458                        		__st.umiq	1, __update_PLAYER_end - 4  /* i */
         01:D01B  A9 01      			lda.l	#1
         01:D01D  8D 09 23   			sta	__update_PLAYER_end - 4
 7459    01:D020             	.LL306:
 7460                        		__ld.umq	__update_PLAYER_end - 4  /* i */
         01:D020  AD 09 23   			lda	__update_PLAYER_end - 4
 7461                        		__ult_b.uiq	11
         01:D023  C9 0B      			cmp	#11		; Subtract integer from A.
         01:D025  6A         			ror	a		; CC if A < integer.
         01:D026  49 80      			eor	#$80
         01:D028  2A         			rol	a
 7462                        		__btrue		.LL308
         01:D029  B0 07      			bcs	.LL308
 7463                        		__bra		.LL309
         01:D02B  80 7D      			bra	.LL309
 7464    01:D02D             	.LL307:
 7465                        		__inc.umq	__update_PLAYER_end - 4  /* i */
         01:D02D  EE 09 23   			inc	__update_PLAYER_end - 4
 7466                        		__bra		.LL306
         01:D030  80 EE      			bra	.LL306
 7467    01:D032             	.LL308:
 7468                        	
 7469                        		.dbg	line,	"include\routines_LEVELS.c", 1519; {
 7470                        	
 7471                        		.dbg	line,	"include\routines_LEVELS.c", 1520; check_TILE_DEPTH( 22 , i);
 7472                        		__ld.wi		22
         01:D032  A9 16      			lda.l	#22
         01:D034  C2         			cly
 7473                        		__pusharg.wr
         01:D035  A6 8D      			ldx	<__sp
         01:D037  CA         			dex
         01:D038  CA         			dex
         01:D039  95 08      			sta.l	<__stack, x
         01:D03B  94 09      			sty.h	<__stack, x
         01:D03D  86 8D      			stx	<__sp
 7474                        		__ld.um		__update_PLAYER_end - 4  /* i */
         01:D03F  AD 09 23   			lda	__update_PLAYER_end - 4
         01:D042  C2         			cly
 7475                        		__pusharg.wr
         01:D043  A6 8D      			ldx	<__sp
         01:D045  CA         			dex
         01:D046  CA         			dex
         01:D047  95 08      			sta.l	<__stack, x
         01:D049  94 09      			sty.h	<__stack, x
         01:D04B  86 8D      			stx	<__sp
 7476                        		__call		_check_TILE_DEPTH
         01:D04D  20 4F FF   			call	_check_TILE_DEPTH
 7477                        	
 7478                        		.dbg	line,	"include\routines_LEVELS.c", 1522; if(map_blk_flag == TILE_EMPTY)
 7479                        		__not.um	_map_blk_flag
         01:D050  AD AA 2B   			lda	_map_blk_flag
         01:D053  18         			clc
         01:D054  D0 01      			bne	!+
         01:D056  38         			sec
         01:D057             	!:
 7480                        		__bfalse	.LL310
         01:D057  90 D4      			bcc	.LL310
 7481                        	
 7482                        		.dbg	line,	"include\routines_LEVELS.c", 1523; {
 7483                        	
 7484                        		.dbg	line,	"include\routines_LEVELS.c", 1524; if(player_pos_y != PLAYER_BASE_Y_POS)
 7485                        		__ld.wm		_player_pos_y
         01:D059  AD CF 24   			lda.l	_player_pos_y
         01:D05C  AC D0 24   			ldy.h	_player_pos_y
 7486                        		__neq_w.wi	128
         01:D05F  38         			sec
         01:D060  49 80      			eor.l	#128
         01:D062  D0 06      			bne	!+
         01:D064  98         			tya
         01:D065  49 00      			eor.h	#128
         01:D067  D0 01      			bne	!+
         01:D069  18         			clc
         01:D06A             	!:
 7487                        		__bfalse	.LL311
         01:D06A  90 1E      			bcc	.LL311
 7488                        	
 7489                        		.dbg	line,	"include\routines_LEVELS.c", 1525; {
 7490                        	
 7491                        		.dbg	line,	"include\routines_LEVELS.c", 1526; player_pos_y -= (i - 1);
 7492                        		__ld.um		__update_PLAYER_end - 4  /* i */
         01:D06C  AD 09 23   			lda	__update_PLAYER_end - 4
         01:D06F  C2         			cly
 7493                        		__sub.wi	1
         01:D070  38         			sec
         01:D071  E9 01      			sbc.l	#1
         01:D073  B0 01      			bcs	!+
         01:D075  88         			dey
         01:D076             	!:
 7494                        		__isub_st.wmq	_player_pos_y
         01:D076  38         			sec
         01:D077  49 FF      			eor	#$FF
         01:D079  6D CF 24   			adc.l	_player_pos_y
         01:D07C  8D CF 24   			sta.l	_player_pos_y
         01:D07F  98         			tya
         01:D080  49 FF      			eor	#$FF
         01:D082  6D D0 24   			adc.h	_player_pos_y
         01:D085  8D D0 24   			sta.h	_player_pos_y
 7495                        	
 7496                        		.dbg	line,	"include\routines_LEVELS.c", 1527; }
 7497                        	
 7498                        		.dbg	line,	"include\routines_LEVELS.c", 1529; else
 7499                        		__bra		.LL312
         01:D088  80 20      			bra	.LL312
 7500    01:D08A             	.LL311:
 7501                        	
 7502                        		.dbg	line,	"include\routines_LEVELS.c", 1530; {
 7503                        	
 7504                        		.dbg	line,	"include\routines_LEVELS.c", 1531; sgx_map_pxl_y -= (i - 1);
 7505                        		__ld.um		__update_PLAYER_end - 4  /* i */
         01:D08A  AD 09 23   			lda	__update_PLAYER_end - 4
         01:D08D  C2         			cly
 7506                        		__sub.wi	1
         01:D08E  38         			sec
         01:D08F  E9 01      			sbc.l	#1
         01:D091  B0 01      			bcs	!+
         01:D093  88         			dey
         01:D094             	!:
 7507                        		__isub_st.wmq	_sgx_map_pxl_y
         01:D094  38         			sec
         01:D095  49 FF      			eor	#$FF
         01:D097  6D 8B 26   			adc.l	_sgx_map_pxl_y
         01:D09A  8D 8B 26   			sta.l	_sgx_map_pxl_y
         01:D09D  98         			tya
         01:D09E  49 FF      			eor	#$FF
         01:D0A0  6D 8C 26   			adc.h	_sgx_map_pxl_y
         01:D0A3  8D 8C 26   			sta.h	_sgx_map_pxl_y
 7508                        	
 7509                        		.dbg	line,	"include\routines_LEVELS.c", 1532; }
 7510    01:D0A6             	.LL312	.alias		.LL309
 7511                        	
 7512                        		.dbg	line,	"include\routines_LEVELS.c", 1534; break;
 7513                        		__bra		.LL309
         01:D0A6  80 02      			bra	.LL309
 7514                        	
 7515                        		.dbg	line,	"include\routines_LEVELS.c", 1535; }
 7516                        	
 7517                        		.dbg	line,	"include\routines_LEVELS.c", 1536; }
 7518    01:D0A8             	.LL310	.alias		.LL307
 7519                        		__bra		.LL307
         01:D0A8  80 83      			bra	.LL307
 7520    01:D0AA             	.LL309:
 7521                        	
 7522                        		.dbg	line,	"include\routines_LEVELS.c", 1538; // SET PLAYER SPRITE NEW POSITION //
 7523                        	
 7524                        		.dbg	line,	"include\routines_LEVELS.c", 1539; spr_y(player_pos_y);
 7525                        		__ld.wm		_player_pos_y
         01:D0AA  AD CF 24   			lda.l	_player_pos_y
         01:D0AD  AC D0 24   			ldy.h	_player_pos_y
 7526                        		__call		_spr_y.1
         01:D0B0  20 19 E8   			call	_spr_y.1
 7527                        	
 7528                        		.dbg	line,	"include\routines_LEVELS.c", 1541; player_counter_anim = 1;
 7529                        		__st.umiq	1, _player_counter_anim
         01:D0B3  A9 01      			lda.l	#1
         01:D0B5  8D 18 23   			sta	_player_counter_anim
 7530                        	
 7531                        		.dbg	line,	"include\routines_LEVELS.c", 1542; player_index_jump = 0;
 7532                        		__st.umiq	0, _player_index_jump
         01:D0B8  9C 19 23   			stz	_player_index_jump
 7533                        	
 7534                        		.dbg	line,	"include\routines_LEVELS.c", 1543; jump_ladder = FALSE;
 7535                        		__st.umiq	0, _jump_ladder
         01:D0BB  9C 1C 23   			stz	_jump_ladder
 7536                        	
 7537                        		.dbg	line,	"include\routines_LEVELS.c", 1544; jump_max_index = 34;
 7538                        		__st.umiq	34, _jump_max_index
         01:D0BE  A9 22      			lda.l	#34
         01:D0C0  8D 1D 23   			sta	_jump_max_index
 7539                        	
 7540                        		.dbg	line,	"include\routines_LEVELS.c", 1545; player_state = STATE_IDLE;
 7541                        		__st.umiq	0, _player_state
         01:D0C3  9C 15 23   			stz	_player_state
 7542                        	
 7543                        		.dbg	line,	"include\routines_LEVELS.c", 1546; return;
 7544                        		__bra		.LL180
         01:D0C6  4C 9E D8   			bra	.LL180
 7545                        	
 7546                        		.dbg	line,	"include\routines_LEVELS.c", 1547; }
 7547                        	
 7548                        		.dbg	line,	"include\routines_LEVELS.c", 1548; }
 7549    01:D0C9             	.LL305:
 7550    01:D0C9             	.LL304:
 7551                        	
 7552                        		.dbg	line,	"include\routines_LEVELS.c", 1549; }
 7553                        	
 7554                        		.dbg	line,	"include\routines_LEVELS.c", 1554; //--------------------------------------------------------------------------------------//
 7555                        	
 7556                        		.dbg	line,	"include\routines_LEVELS.c", 1555; //                                   LADDER COLLISION                                   //
 7557                        	
 7558                        		.dbg	line,	"include\routines_LEVELS.c", 1556; //--------------------------------------------------------------------------------------//
 7559                        	
 7560                        		.dbg	line,	"include\routines_LEVELS.c", 1558; if(player_index_jump > 4)
 7561    01:D0C9             	.LL295:
 7562                        		__ld.umq	_player_index_jump
         01:D0C9  AD 19 23   			lda	_player_index_jump
 7563                        		__ugt_b.uiq	4
         01:D0CC  18         			clc			; Subtract integer+1 from A.
         01:D0CD  E9 04      			sbc	#4		; CS if A > integer.
 7564                        		__bfalse	.LL313
         01:D0CF  B0 03 4C 60			bcc	.LL313
         01:D0D3  D1          
 7565                        	
 7566                        		.dbg	line,	"include\routines_LEVELS.c", 1559; {
 7567                        	
 7568                        		.dbg	line,	"include\routines_LEVELS.c", 1560; check_BG( 16 , 16 );
 7569                        		__ld.wi		16
         01:D0D4  A9 10      			lda.l	#16
         01:D0D6  C2         			cly
 7570                        		__pusharg.wr
         01:D0D7  A6 8D      			ldx	<__sp
         01:D0D9  CA         			dex
         01:D0DA  CA         			dex
         01:D0DB  95 08      			sta.l	<__stack, x
         01:D0DD  94 09      			sty.h	<__stack, x
         01:D0DF  86 8D      			stx	<__sp
 7571                        		__ld.wi		16
         01:D0E1  A9 10      			lda.l	#16
         01:D0E3  C2         			cly
 7572                        		__pusharg.wr
         01:D0E4  A6 8D      			ldx	<__sp
         01:D0E6  CA         			dex
         01:D0E7  CA         			dex
         01:D0E8  95 08      			sta.l	<__stack, x
         01:D0EA  94 09      			sty.h	<__stack, x
         01:D0EC  86 8D      			stx	<__sp
 7573                        		__call		_check_BG
         01:D0EE  20 6D FF   			call	_check_BG
 7574                        	
 7575                        		.dbg	line,	"include\routines_LEVELS.c", 1562; if(map_blk_flag == TILE_LADDER)
 7576                        		__ld.umq	_map_blk_flag
         01:D0F1  AD AA 2B   			lda	_map_blk_flag
 7577                        		__equ_b.uiq	2
         01:D0F4  C9 02      			cmp	#2
         01:D0F6  F0 01      			beq	!+
         01:D0F8  18         			clc
         01:D0F9             	!:
 7578                        		__bfalse	.LL314
         01:D0F9  90 65      			bcc	.LL314
 7579                        	
 7580                        		.dbg	line,	"include\routines_LEVELS.c", 1563; {
 7581                        	
 7582                        		.dbg	line,	"include\routines_LEVELS.c", 1564; // CAMERA GOES 8 PX BACKWARD //
 7583                        	
 7584                        		.dbg	line,	"include\routines_LEVELS.c", 1565; sgx_map_pxl_x = ( (sgx_map_pxl_x >> 3) << 3 );
 7585                        		__ld.wm		_sgx_map_pxl_x
         01:D0FB  AD 89 26   			lda.l	_sgx_map_pxl_x
         01:D0FE  AC 8A 26   			ldy.h	_sgx_map_pxl_x
 7586                        		__lsr.wi	3
         01:D101  84 00      			sty	__temp
         01:D103  20 3A E2   			jsr	lsrw3
 7587                        		__asl.wi	3
         01:D106  84 00      			sty	__temp
         01:D108  20 D7 E1   			jsr	aslw3
 7588                        		__st.wmq	_sgx_map_pxl_x
         01:D10B  8D 89 26   			sta.l	_sgx_map_pxl_x
         01:D10E  8C 8A 26   			sty.h	_sgx_map_pxl_x
 7589                        	
 7590                        		.dbg	line,	"include\routines_LEVELS.c", 1567; // SO WE UPDATE THE MAP //
 7591                        	
 7592                        		.dbg	line,	"include\routines_LEVELS.c", 1568; sgx_scroll_map();
 7593                        		__call		_sgx_scroll_map
         01:D111  20 81 FF   			call	_sgx_scroll_map
 7594                        	
 7595                        		.dbg	line,	"include\routines_LEVELS.c", 1570; // CHECK IF THE PLAYER STANDS RIGHT TO THE LADDER //
 7596                        	
 7597                        		.dbg	line,	"include\routines_LEVELS.c", 1571; check_BG( 31 , 16 );
 7598                        		__ld.wi		31
         01:D114  A9 1F      			lda.l	#31
         01:D116  C2         			cly
 7599                        		__pusharg.wr
         01:D117  A6 8D      			ldx	<__sp
         01:D119  CA         			dex
         01:D11A  CA         			dex
         01:D11B  95 08      			sta.l	<__stack, x
         01:D11D  94 09      			sty.h	<__stack, x
         01:D11F  86 8D      			stx	<__sp
 7600                        		__ld.wi		16
         01:D121  A9 10      			lda.l	#16
         01:D123  C2         			cly
 7601                        		__pusharg.wr
         01:D124  A6 8D      			ldx	<__sp
         01:D126  CA         			dex
         01:D127  CA         			dex
         01:D128  95 08      			sta.l	<__stack, x
         01:D12A  94 09      			sty.h	<__stack, x
         01:D12C  86 8D      			stx	<__sp
 7602                        		__call		_check_BG
         01:D12E  20 6D FF   			call	_check_BG
 7603                        	
 7604                        		.dbg	line,	"include\routines_LEVELS.c", 1573; if(map_blk_flag == TILE_LADDER)
 7605                        		__ld.umq	_map_blk_flag
         01:D131  AD AA 2B   			lda	_map_blk_flag
 7606                        		__equ_b.uiq	2
         01:D134  C9 02      			cmp	#2
         01:D136  F0 01      			beq	!+
         01:D138  18         			clc
         01:D139             	!:
 7607                        		__bfalse	.LL315
         01:D139  90 0E      			bcc	.LL315
 7608                        	
 7609                        		.dbg	line,	"include\routines_LEVELS.c", 1574; {
 7610                        	
 7611                        		.dbg	line,	"include\routines_LEVELS.c", 1575; sgx_map_pxl_x += 8;
 7612                        		__add_st.wmiq	8, _sgx_map_pxl_x
         01:D13B  18         			clc
         01:D13C  AD 89 26   			lda.l	_sgx_map_pxl_x
         01:D13F  69 08      			adc.l	#8
         01:D141  8D 89 26   			sta.l	_sgx_map_pxl_x
         01:D144  90 03      			bcc	!+
         01:D146  EE 8A 26   			inc.h	_sgx_map_pxl_x
         01:D149             	!:
 7613                        	
 7614                        		.dbg	line,	"include\routines_LEVELS.c", 1576; }
 7615                        	
 7616                        		.dbg	line,	"include\routines_LEVELS.c", 1578; player_counter_anim = 1;
 7617    01:D149             	.LL315:
 7618                        		__st.umiq	1, _player_counter_anim
         01:D149  A9 01      			lda.l	#1
         01:D14B  8D 18 23   			sta	_player_counter_anim
 7619                        	
 7620                        		.dbg	line,	"include\routines_LEVELS.c", 1579; player_index_jump = 0;
 7621                        		__st.umiq	0, _player_index_jump
         01:D14E  9C 19 23   			stz	_player_index_jump
 7622                        	
 7623                        		.dbg	line,	"include\routines_LEVELS.c", 1580; jump_ladder = TRUE;
 7624                        		__st.umiq	1, _jump_ladder
         01:D151  A9 01      			lda.l	#1
         01:D153  8D 1C 23   			sta	_jump_ladder
 7625                        	
 7626                        		.dbg	line,	"include\routines_LEVELS.c", 1581; jump_max_index = 29;
 7627                        		__st.umiq	29, _jump_max_index
         01:D156  A9 1D      			lda.l	#29
         01:D158  8D 1D 23   			sta	_jump_max_index
 7628                        	
 7629                        		.dbg	line,	"include\routines_LEVELS.c", 1582; player_state = STATE_HANG;
 7630                        		__st.umiq	10, _player_state
         01:D15B  A9 0A      			lda.l	#10
         01:D15D  8D 15 23   			sta	_player_state
 7631                        	
 7632                        		.dbg	line,	"include\routines_LEVELS.c", 1583; }
 7633                        	
 7634                        		.dbg	line,	"include\routines_LEVELS.c", 1584; }
 7635    01:D160             	.LL314:
 7636                        	
 7637                        		.dbg	line,	"include\routines_LEVELS.c", 1587; // SET PLAYER SPRITE NEW POSITION //
 7638                        	
 7639                        		.dbg	line,	"include\routines_LEVELS.c", 1588; spr_y(player_pos_y);
 7640    01:D160             	.LL313:
 7641                        		__ld.wm		_player_pos_y
         01:D160  AD CF 24   			lda.l	_player_pos_y
         01:D163  AC D0 24   			ldy.h	_player_pos_y
 7642                        		__call		_spr_y.1
         01:D166  20 19 E8   			call	_spr_y.1
 7643                        	
 7644                        		.dbg	line,	"include\routines_LEVELS.c", 1589; }
 7645                        	
 7646                        		.dbg	line,	"include\routines_LEVELS.c", 1592; else if(player_state == STATE_CROUCH)
 7647                        		__bra		.LL316
         01:D169  4C 9E D8   			bra	.LL316
 7648    01:D16C             	.LL280:
 7649                        		__ld.umq	_player_state
         01:D16C  AD 15 23   			lda	_player_state
 7650                        		__equ_b.uiq	7
         01:D16F  C9 07      			cmp	#7
         01:D171  F0 01      			beq	!+
         01:D173  18         			clc
         01:D174             	!:
 7651                        		__bfalse	.LL317
         01:D174  90 40      			bcc	.LL317
 7652                        	
 7653                        		.dbg	line,	"include\routines_LEVELS.c", 1593; {
 7654                        	
 7655                        		.dbg	line,	"include\routines_LEVELS.c", 1594; if(player_counter_anim == 1)
 7656                        		__ld.umq	_player_counter_anim
         01:D176  AD 18 23   			lda	_player_counter_anim
 7657                        		__equ_b.uiq	1
         01:D179  C9 01      			cmp	#1
         01:D17B  F0 01      			beq	!+
         01:D17D  18         			clc
         01:D17E             	!:
 7658                        		__bfalse	.LL318
         01:D17E  90 30      			bcc	.LL318
 7659                        	
 7660                        		.dbg	line,	"include\routines_LEVELS.c", 1595; {
 7661                        	
 7662                        		.dbg	line,	"include\routines_LEVELS.c", 1596; set_far_offset(OFFSET_PLAYER_CROUCH,TABLE_PLAYER_TILES_BANK[player_naked],TABLE_PLAYER_TILES_ADR[player_naked]);
 7663                        		__st.wmiq	4096, _bp
         01:D180  64 EC      			stz.l	_bp
         01:D182  A9 10      			lda.h	#4096
         01:D184  85 ED      			sta.h	_bp
 7664                        		__ldx.umq	_player_naked
         01:D186  AE 1B 23   			ldx	_player_naked
 7665                        		__ld.uax	_TABLE_PLAYER_TILES_BANK
         01:D189  BD F7 60   			lda	_TABLE_PLAYER_TILES_BANK, x
         01:D18C  C2         			cly
 7666                        		__st.umq	_bp_bank
         01:D18D  85 02      			sta	_bp_bank
 7667                        		__ld2x.umq	_player_naked
         01:D18F  AD 1B 23   			lda	_player_naked
         01:D192  0A         			asl	a
         01:D193  AA         			tax
 7668                        		__ld.wax	_TABLE_PLAYER_TILES_ADR
         01:D194  BD F3 60   			lda.l	_TABLE_PLAYER_TILES_ADR, x
         01:D197  BC F4 60   			ldy.h	_TABLE_PLAYER_TILES_ADR, x
 7669                        		__call		_set_far_offset.3
         01:D19A  20 8C E2   			call	_set_far_offset.3
 7670                        	
 7671                        		.dbg	line,	"include\routines_LEVELS.c", 1597; far_load_vram(PLAYER_VRAM_ADR,TILES_16);
 7672                        		__st.wmiq	6144, _di
         01:D19D  64 F0      			stz.l	_di
         01:D19F  A9 18      			lda.h	#6144
         01:D1A1  85 F1      			sta.h	_di
 7673                        		__st.wmiq	256, _ax
         01:D1A3  64 F8      			stz.l	_ax
         01:D1A5  A9 01      			lda.h	#256
         01:D1A7  85 F9      			sta.h	_ax
 7674                        		 _far_load_vram.2
         01:D1A9  82         			clx				; Offset to PCE VDC.
         01:D1AA  20 63 FF   			call	load_vram_x
 7675                        	
 7676                        		.dbg	line,	"include\routines_LEVELS.c", 1599; player_counter_anim = 0;
 7677                        		__st.umiq	0, _player_counter_anim
         01:D1AD  9C 18 23   			stz	_player_counter_anim
 7678                        	
 7679                        		.dbg	line,	"include\routines_LEVELS.c", 1600; }
 7680                        	
 7681                        		.dbg	line,	"include\routines_LEVELS.c", 1602; recenter_CAMERA();
 7682    01:D1B0             	.LL318:
 7683                        		__call		_recenter_CAMERA
         01:D1B0  20 59 FF   			call	_recenter_CAMERA
 7684                        	
 7685                        		.dbg	line,	"include\routines_LEVELS.c", 1603; }
 7686                        	
 7687                        		.dbg	line,	"include\routines_LEVELS.c", 1606; else if(player_state == STATE_FALL)
 7688                        		__bra		.LL319
         01:D1B3  4C 9E D8   			bra	.LL319
 7689    01:D1B6             	.LL317:
 7690                        		__ld.umq	_player_state
         01:D1B6  AD 15 23   			lda	_player_state
 7691                        		__equ_b.uiq	9
         01:D1B9  C9 09      			cmp	#9
         01:D1BB  F0 01      			beq	!+
         01:D1BD  18         			clc
         01:D1BE             	!:
 7692                        		__bfalse	.LL320
         01:D1BE  B0 03 4C C5			bcc	.LL320
         01:D1C2  D3          
 7693                        	
 7694                        		.dbg	line,	"include\routines_LEVELS.c", 1607; {
 7695                        	
 7696                        		.dbg	line,	"include\routines_LEVELS.c", 1608; unsigned char i, camera_y_move;
 7697                        	
 7698                        		.dbg	line,	"include\routines_LEVELS.c", 1609; i = 1;
 7699                        		__st.umiq	1, __update_PLAYER_end - 6  /* i */
         01:D1C3  A9 01      			lda.l	#1
         01:D1C5  8D 07 23   			sta	__update_PLAYER_end - 6
 7700                        	
 7701                        		.dbg	line,	"include\routines_LEVELS.c", 1612; spr_set(player_id);
 7702                        		__ld.umq	_player_id
         01:D1C8  AD 14 23   			lda	_player_id
 7703                        		__call		_spr_set.1
         01:D1CB  20 DD E7   			call	_spr_set.1
 7704                        	
 7705                        		.dbg	line,	"include\routines_LEVELS.c", 1615; //--------------------------------------------------------------------------------------//
 7706                        	
 7707                        		.dbg	line,	"include\routines_LEVELS.c", 1616; //                                        V MOVE                                        //
 7708                        	
 7709                        		.dbg	line,	"include\routines_LEVELS.c", 1617; //--------------------------------------------------------------------------------------//
 7710                        	
 7711                        		.dbg	line,	"include\routines_LEVELS.c", 1619; // UPDATE PLAYER Y POSITION //
 7712                        	
 7713                        		.dbg	line,	"include\routines_LEVELS.c", 1620; player_pos_y += TABLE_PLAYER_FALL[player_index_fall];
 7714                        		__ldx.umq	_player_index_fall
         01:D1CE  AE 1A 23   			ldx	_player_index_fall
 7715                        		__ld.bax	_TABLE_PLAYER_FALL
         01:D1D1  BD 1C 61   			lda	_TABLE_PLAYER_FALL, x
         01:D1D4  C2         			cly
         01:D1D5  10 01      			bpl	!+
         01:D1D7  88         			dey
         01:D1D8             	!:
 7716                        		__add_st.wmq	_player_pos_y
         01:D1D8  18         			clc
         01:D1D9  6D CF 24   			adc.l	_player_pos_y
         01:D1DC  8D CF 24   			sta.l	_player_pos_y
         01:D1DF  98         			tya
         01:D1E0  6D D0 24   			adc.h	_player_pos_y
         01:D1E3  8D D0 24   			sta.h	_player_pos_y
 7717                        	
 7718                        		.dbg	line,	"include\routines_LEVELS.c", 1623; // IF PLAYER GOES BELOW ITS BASE Y POSITION //
 7719                        	
 7720                        		.dbg	line,	"include\routines_LEVELS.c", 1624; if(player_pos_y >= PLAYER_BASE_Y_POS)
 7721                        		__ld.wm		_player_pos_y
         01:D1E6  AD CF 24   			lda.l	_player_pos_y
         01:D1E9  AC D0 24   			ldy.h	_player_pos_y
 7722                        		__sge_w.wi	128
         01:D1EC  C9 80      			cmp.l	#128		; Subtract integer from Y:A.
         01:D1EE  98         			tya
         01:D1EF  E9 00      			sbc.h	#128
         01:D1F1  50 02      			bvc	!+
         01:D1F3  49 80      			eor	#$80		; +ve if Y:A >= integer (signed).
         01:D1F5  49 80      	!:		eor	#$80
         01:D1F7  0A         			asl	a
 7723                        		__bfalse	.LL321
         01:D1F8  90 45      			bcc	.LL321
 7724                        	
 7725                        		.dbg	line,	"include\routines_LEVELS.c", 1625; {
 7726                        	
 7727                        		.dbg	line,	"include\routines_LEVELS.c", 1626; // THE CAMERA MOVES //
 7728                        	
 7729                        		.dbg	line,	"include\routines_LEVELS.c", 1627; // CALCULATE HOW MANY PIXELS THE CAMERA HAS TO MOVE DOWN //
 7730                        	
 7731                        		.dbg	line,	"include\routines_LEVELS.c", 1628; camera_y_move = player_pos_y - PLAYER_BASE_Y_POS;
 7732                        		__ld.wm		_player_pos_y
         01:D1FA  AD CF 24   			lda.l	_player_pos_y
         01:D1FD  AC D0 24   			ldy.h	_player_pos_y
 7733                        		__sub.wi	128
         01:D200  38         			sec
         01:D201  E9 80      			sbc.l	#128
         01:D203  B0 01      			bcs	!+
         01:D205  88         			dey
         01:D206             	!:
 7734                        		__st.umq	__update_PLAYER_end - 7  /* camera_y_move */
         01:D206  8D 06 23   			sta	__update_PLAYER_end - 7
 7735                        	
 7736                        		.dbg	line,	"include\routines_LEVELS.c", 1629; sgx_map_pxl_y += camera_y_move;
 7737                        		__ld.um		__update_PLAYER_end - 7  /* camera_y_move */
         01:D209  AD 06 23   			lda	__update_PLAYER_end - 7
         01:D20C  C2         			cly
 7738                        		__add_st.wmq	_sgx_map_pxl_y
         01:D20D  18         			clc
         01:D20E  6D 8B 26   			adc.l	_sgx_map_pxl_y
         01:D211  8D 8B 26   			sta.l	_sgx_map_pxl_y
         01:D214  98         			tya
         01:D215  6D 8C 26   			adc.h	_sgx_map_pxl_y
         01:D218  8D 8C 26   			sta.h	_sgx_map_pxl_y
 7739                        	
 7740                        		.dbg	line,	"include\routines_LEVELS.c", 1631; // IF THE CAMERA HAS REACHED ITS MAX (LOWEST) POSITION //
 7741                        	
 7742                        		.dbg	line,	"include\routines_LEVELS.c", 1632; if(sgx_map_pxl_y > camera_max_y_position)
 7743                        		__ld.wm		_sgx_map_pxl_y
         01:D21B  AD 8B 26   			lda.l	_sgx_map_pxl_y
         01:D21E  AC 8C 26   			ldy.h	_sgx_map_pxl_y
 7744                        		__ugt_w.wm	_camera_max_y_position
         01:D221  18         			clc			; Subtract memory+1 from Y:A.
         01:D222  ED D1 24   			sbc.l	_camera_max_y_position
         01:D225  98         			tya
         01:D226  ED D2 24   			sbc.h	_camera_max_y_position		; CS if Y:A > memory.
 7745                        		__bfalse	.LL322
         01:D229  90 0C      			bcc	.LL322
 7746                        	
 7747                        		.dbg	line,	"include\routines_LEVELS.c", 1633; {
 7748                        	
 7749                        		.dbg	line,	"include\routines_LEVELS.c", 1634; // THE CAMERA CAN NOT MOVE LOWER //
 7750                        	
 7751                        		.dbg	line,	"include\routines_LEVELS.c", 1635; sgx_map_pxl_y = camera_max_y_position;
 7752                        		__ld.wm		_camera_max_y_position
         01:D22B  AD D1 24   			lda.l	_camera_max_y_position
         01:D22E  AC D2 24   			ldy.h	_camera_max_y_position
 7753                        		__st.wmq	_sgx_map_pxl_y
         01:D231  8D 8B 26   			sta.l	_sgx_map_pxl_y
         01:D234  8C 8C 26   			sty.h	_sgx_map_pxl_y
 7754                        	
 7755                        		.dbg	line,	"include\routines_LEVELS.c", 1636; }
 7756                        	
 7757                        		.dbg	line,	"include\routines_LEVELS.c", 1638; // THE PLAYER STAYS AT ITS BASE Y POSITION //
 7758                        	
 7759                        		.dbg	line,	"include\routines_LEVELS.c", 1639; player_pos_y = PLAYER_BASE_Y_POS;
 7760    01:D237             	.LL322:
 7761                        		__st.wmiq	128, _player_pos_y
         01:D237  A9 80      			lda.l	#128
         01:D239  8D CF 24   			sta.l	_player_pos_y
         01:D23C  9C D0 24   			stz.h	_player_pos_y
 7762                        	
 7763                        		.dbg	line,	"include\routines_LEVELS.c", 1640; }
 7764                        	
 7765                        		.dbg	line,	"include\routines_LEVELS.c", 1643; // UPDATE JUMP INDEX IN THE ARRAY //
 7766                        	
 7767                        		.dbg	line,	"include\routines_LEVELS.c", 1644; // ARRAY MAX ENTRY : 20//
 7768                        	
 7769                        		.dbg	line,	"include\routines_LEVELS.c", 1645; if(player_index_fall < 20)
 7770    01:D23F             	.LL321:
 7771                        		__ld.umq	_player_index_fall
         01:D23F  AD 1A 23   			lda	_player_index_fall
 7772                        		__ult_b.uiq	20
         01:D242  C9 14      			cmp	#20		; Subtract integer from A.
         01:D244  6A         			ror	a		; CC if A < integer.
         01:D245  49 80      			eor	#$80
         01:D247  2A         			rol	a
 7773                        		__bfalse	.LL323
         01:D248  90 03      			bcc	.LL323
 7774                        	
 7775                        		.dbg	line,	"include\routines_LEVELS.c", 1646; {
 7776                        	
 7777                        		.dbg	line,	"include\routines_LEVELS.c", 1647; player_index_fall += 1;
 7778                        		__add_st.umiq	1, _player_index_fall
         01:D24A  EE 1A 23   			inc	_player_index_fall
 7779                        	
 7780                        		.dbg	line,	"include\routines_LEVELS.c", 1648; }
 7781                        	
 7782                        		.dbg	line,	"include\routines_LEVELS.c", 1651; check_TILE_DEPTH( 15 , 0);
 7783    01:D24D             	.LL323:
 7784                        		__ld.wi		15
         01:D24D  A9 0F      			lda.l	#15
         01:D24F  C2         			cly
 7785                        		__pusharg.wr
         01:D250  A6 8D      			ldx	<__sp
         01:D252  CA         			dex
         01:D253  CA         			dex
         01:D254  95 08      			sta.l	<__stack, x
         01:D256  94 09      			sty.h	<__stack, x
         01:D258  86 8D      			stx	<__sp
 7786                        		__ld.wi		0
         01:D25A  62         			cla
         01:D25B  C2         			cly
 7787                        		__pusharg.wr
         01:D25C  A6 8D      			ldx	<__sp
         01:D25E  CA         			dex
         01:D25F  CA         			dex
         01:D260  95 08      			sta.l	<__stack, x
         01:D262  94 09      			sty.h	<__stack, x
         01:D264  86 8D      			stx	<__sp
 7788                        		__call		_check_TILE_DEPTH
         01:D266  20 4F FF   			call	_check_TILE_DEPTH
 7789                        	
 7790                        		.dbg	line,	"include\routines_LEVELS.c", 1654; if(map_blk_flag == TILE_BG)
 7791                        		__ld.umq	_map_blk_flag
         01:D269  AD AA 2B   			lda	_map_blk_flag
 7792                        		__equ_b.uiq	1
         01:D26C  C9 01      			cmp	#1
         01:D26E  F0 01      			beq	!+
         01:D270  18         			clc
         01:D271             	!:
 7793                        		__bfalse	.LL324
         01:D271  B0 03 4C 27			bcc	.LL324
         01:D275  D3          
 7794                        	
 7795                        		.dbg	line,	"include\routines_LEVELS.c", 1655; {
 7796                        	
 7797                        		.dbg	line,	"include\routines_LEVELS.c", 1656; // CALCULATE HOW MANY PIXELS THE PLAYER MOVED INTO THE GROUND //
 7798                        	
 7799                        		.dbg	line,	"include\routines_LEVELS.c", 1657; for(i=1; i<11 ; i++ )
 7800                        		__st.umiq	1, __update_PLAYER_end - 6  /* i */
         01:D276  A9 01      			lda.l	#1
         01:D278  8D 07 23   			sta	__update_PLAYER_end - 6
 7801    01:D27B             	.LL325:
 7802                        		__ld.umq	__update_PLAYER_end - 6  /* i */
         01:D27B  AD 07 23   			lda	__update_PLAYER_end - 6
 7803                        		__ult_b.uiq	11
         01:D27E  C9 0B      			cmp	#11		; Subtract integer from A.
         01:D280  6A         			ror	a		; CC if A < integer.
         01:D281  49 80      			eor	#$80
         01:D283  2A         			rol	a
 7804                        		__btrue		.LL327
         01:D284  B0 07      			bcs	.LL327
 7805                        		__bra		.LL328
         01:D286  80 7D      			bra	.LL328
 7806    01:D288             	.LL326:
 7807                        		__inc.umq	__update_PLAYER_end - 6  /* i */
         01:D288  EE 07 23   			inc	__update_PLAYER_end - 6
 7808                        		__bra		.LL325
         01:D28B  80 EE      			bra	.LL325
 7809    01:D28D             	.LL327:
 7810                        	
 7811                        		.dbg	line,	"include\routines_LEVELS.c", 1658; {
 7812                        	
 7813                        		.dbg	line,	"include\routines_LEVELS.c", 1659; //if(player_axis == AXIS_RIGHT)
 7814                        	
 7815                        		.dbg	line,	"include\routines_LEVELS.c", 1660; //{
 7816                        	
 7817                        		.dbg	line,	"include\routines_LEVELS.c", 1661; check_TILE_DEPTH( 15 , i);//20
 7818                        		__ld.wi		15
         01:D28D  A9 0F      			lda.l	#15
         01:D28F  C2         			cly
 7819                        		__pusharg.wr
         01:D290  A6 8D      			ldx	<__sp
         01:D292  CA         			dex
         01:D293  CA         			dex
         01:D294  95 08      			sta.l	<__stack, x
         01:D296  94 09      			sty.h	<__stack, x
         01:D298  86 8D      			stx	<__sp
 7820                        		__ld.um		__update_PLAYER_end - 6  /* i */
         01:D29A  AD 07 23   			lda	__update_PLAYER_end - 6
         01:D29D  C2         			cly
 7821                        		__pusharg.wr
         01:D29E  A6 8D      			ldx	<__sp
         01:D2A0  CA         			dex
         01:D2A1  CA         			dex
         01:D2A2  95 08      			sta.l	<__stack, x
         01:D2A4  94 09      			sty.h	<__stack, x
         01:D2A6  86 8D      			stx	<__sp
 7822                        		__call		_check_TILE_DEPTH
         01:D2A8  20 4F FF   			call	_check_TILE_DEPTH
 7823                        	
 7824                        		.dbg	line,	"include\routines_LEVELS.c", 1662; //}
 7825                        	
 7826                        		.dbg	line,	"include\routines_LEVELS.c", 1664; /*else
 7827                        	
 7828                        		.dbg	line,	"include\routines_LEVELS.c", 1665; {
 7829                        	
 7830                        		.dbg	line,	"include\routines_LEVELS.c", 1666; check_TILE_DEPTH( 10 , i);
 7831                        	
 7832                        		.dbg	line,	"include\routines_LEVELS.c", 1667; }*/
 7833                        	
 7834                        		.dbg	line,	"include\routines_LEVELS.c", 1670; if(map_blk_flag == TILE_EMPTY)
 7835                        		__not.um	_map_blk_flag
         01:D2AB  AD AA 2B   			lda	_map_blk_flag
         01:D2AE  18         			clc
         01:D2AF  D0 01      			bne	!+
         01:D2B1  38         			sec
         01:D2B2             	!:
 7836                        		__bfalse	.LL329
         01:D2B2  90 D4      			bcc	.LL329
 7837                        	
 7838                        		.dbg	line,	"include\routines_LEVELS.c", 1671; {
 7839                        	
 7840                        		.dbg	line,	"include\routines_LEVELS.c", 1672; if(player_pos_y != PLAYER_BASE_Y_POS)
 7841                        		__ld.wm		_player_pos_y
         01:D2B4  AD CF 24   			lda.l	_player_pos_y
         01:D2B7  AC D0 24   			ldy.h	_player_pos_y
 7842                        		__neq_w.wi	128
         01:D2BA  38         			sec
         01:D2BB  49 80      			eor.l	#128
         01:D2BD  D0 06      			bne	!+
         01:D2BF  98         			tya
         01:D2C0  49 00      			eor.h	#128
         01:D2C2  D0 01      			bne	!+
         01:D2C4  18         			clc
         01:D2C5             	!:
 7843                        		__bfalse	.LL330
         01:D2C5  90 1E      			bcc	.LL330
 7844                        	
 7845                        		.dbg	line,	"include\routines_LEVELS.c", 1673; {
 7846                        	
 7847                        		.dbg	line,	"include\routines_LEVELS.c", 1674; player_pos_y -= (i - 1);
 7848                        		__ld.um		__update_PLAYER_end - 6  /* i */
         01:D2C7  AD 07 23   			lda	__update_PLAYER_end - 6
         01:D2CA  C2         			cly
 7849                        		__sub.wi	1
         01:D2CB  38         			sec
         01:D2CC  E9 01      			sbc.l	#1
         01:D2CE  B0 01      			bcs	!+
         01:D2D0  88         			dey
         01:D2D1             	!:
 7850                        		__isub_st.wmq	_player_pos_y
         01:D2D1  38         			sec
         01:D2D2  49 FF      			eor	#$FF
         01:D2D4  6D CF 24   			adc.l	_player_pos_y
         01:D2D7  8D CF 24   			sta.l	_player_pos_y
         01:D2DA  98         			tya
         01:D2DB  49 FF      			eor	#$FF
         01:D2DD  6D D0 24   			adc.h	_player_pos_y
         01:D2E0  8D D0 24   			sta.h	_player_pos_y
 7851                        	
 7852                        		.dbg	line,	"include\routines_LEVELS.c", 1675; }
 7853                        	
 7854                        		.dbg	line,	"include\routines_LEVELS.c", 1677; else
 7855                        		__bra		.LL331
         01:D2E3  80 20      			bra	.LL331
 7856    01:D2E5             	.LL330:
 7857                        	
 7858                        		.dbg	line,	"include\routines_LEVELS.c", 1678; {
 7859                        	
 7860                        		.dbg	line,	"include\routines_LEVELS.c", 1679; sgx_map_pxl_y -= (i - 1);
 7861                        		__ld.um		__update_PLAYER_end - 6  /* i */
         01:D2E5  AD 07 23   			lda	__update_PLAYER_end - 6
         01:D2E8  C2         			cly
 7862                        		__sub.wi	1
         01:D2E9  38         			sec
         01:D2EA  E9 01      			sbc.l	#1
         01:D2EC  B0 01      			bcs	!+
         01:D2EE  88         			dey
         01:D2EF             	!:
 7863                        		__isub_st.wmq	_sgx_map_pxl_y
         01:D2EF  38         			sec
         01:D2F0  49 FF      			eor	#$FF
         01:D2F2  6D 8B 26   			adc.l	_sgx_map_pxl_y
         01:D2F5  8D 8B 26   			sta.l	_sgx_map_pxl_y
         01:D2F8  98         			tya
         01:D2F9  49 FF      			eor	#$FF
         01:D2FB  6D 8C 26   			adc.h	_sgx_map_pxl_y
         01:D2FE  8D 8C 26   			sta.h	_sgx_map_pxl_y
 7864                        	
 7865                        		.dbg	line,	"include\routines_LEVELS.c", 1680; }
 7866    01:D301             	.LL331	.alias		.LL328
 7867                        	
 7868                        		.dbg	line,	"include\routines_LEVELS.c", 1683; break;
 7869                        		__bra		.LL328
         01:D301  80 02      			bra	.LL328
 7870                        	
 7871                        		.dbg	line,	"include\routines_LEVELS.c", 1684; }
 7872                        	
 7873                        		.dbg	line,	"include\routines_LEVELS.c", 1686; }
 7874    01:D303             	.LL329	.alias		.LL326
 7875                        		__bra		.LL326
         01:D303  80 83      			bra	.LL326
 7876    01:D305             	.LL328:
 7877                        	
 7878                        		.dbg	line,	"include\routines_LEVELS.c", 1688; spr_y(player_pos_y);
 7879                        		__ld.wm		_player_pos_y
         01:D305  AD CF 24   			lda.l	_player_pos_y
         01:D308  AC D0 24   			ldy.h	_player_pos_y
 7880                        		__call		_spr_y.1
         01:D30B  20 19 E8   			call	_spr_y.1
 7881                        	
 7882                        		.dbg	line,	"include\routines_LEVELS.c", 1690; player_counter_anim = 1;
 7883                        		__st.umiq	1, _player_counter_anim
         01:D30E  A9 01      			lda.l	#1
         01:D310  8D 18 23   			sta	_player_counter_anim
 7884                        	
 7885                        		.dbg	line,	"include\routines_LEVELS.c", 1691; player_index_jump = 0;
 7886                        		__st.umiq	0, _player_index_jump
         01:D313  9C 19 23   			stz	_player_index_jump
 7887                        	
 7888                        		.dbg	line,	"include\routines_LEVELS.c", 1692; player_index_fall = 0;
 7889                        		__st.umiq	0, _player_index_fall
         01:D316  9C 1A 23   			stz	_player_index_fall
 7890                        	
 7891                        		.dbg	line,	"include\routines_LEVELS.c", 1693; jump_ladder = FALSE;
 7892                        		__st.umiq	0, _jump_ladder
         01:D319  9C 1C 23   			stz	_jump_ladder
 7893                        	
 7894                        		.dbg	line,	"include\routines_LEVELS.c", 1694; jump_max_index = 34;
 7895                        		__st.umiq	34, _jump_max_index
         01:D31C  A9 22      			lda.l	#34
         01:D31E  8D 1D 23   			sta	_jump_max_index
 7896                        	
 7897                        		.dbg	line,	"include\routines_LEVELS.c", 1695; player_state = STATE_IDLE;
 7898                        		__st.umiq	0, _player_state
         01:D321  9C 15 23   			stz	_player_state
 7899                        	
 7900                        		.dbg	line,	"include\routines_LEVELS.c", 1696; return;
 7901                        		__bra		.LL180
         01:D324  4C 9E D8   			bra	.LL180
 7902                        	
 7903                        		.dbg	line,	"include\routines_LEVELS.c", 1697; }
 7904                        	
 7905                        		.dbg	line,	"include\routines_LEVELS.c", 1700; check_BG( 16 , 16 );
 7906    01:D327             	.LL324:
 7907                        		__ld.wi		16
         01:D327  A9 10      			lda.l	#16
         01:D329  C2         			cly
 7908                        		__pusharg.wr
         01:D32A  A6 8D      			ldx	<__sp
         01:D32C  CA         			dex
         01:D32D  CA         			dex
         01:D32E  95 08      			sta.l	<__stack, x
         01:D330  94 09      			sty.h	<__stack, x
         01:D332  86 8D      			stx	<__sp
 7909                        		__ld.wi		16
         01:D334  A9 10      			lda.l	#16
         01:D336  C2         			cly
 7910                        		__pusharg.wr
         01:D337  A6 8D      			ldx	<__sp
         01:D339  CA         			dex
         01:D33A  CA         			dex
         01:D33B  95 08      			sta.l	<__stack, x
         01:D33D  94 09      			sty.h	<__stack, x
         01:D33F  86 8D      			stx	<__sp
 7911                        		__call		_check_BG
         01:D341  20 6D FF   			call	_check_BG
 7912                        	
 7913                        		.dbg	line,	"include\routines_LEVELS.c", 1702; // IF PLAYER HITS THE LADDER //
 7914                        	
 7915                        		.dbg	line,	"include\routines_LEVELS.c", 1703; if(map_blk_flag == TILE_LADDER)
 7916                        		__ld.umq	_map_blk_flag
         01:D344  AD AA 2B   			lda	_map_blk_flag
 7917                        		__equ_b.uiq	2
         01:D347  C9 02      			cmp	#2
         01:D349  F0 01      			beq	!+
         01:D34B  18         			clc
         01:D34C             	!:
 7918                        		__bfalse	.LL332
         01:D34C  90 6B      			bcc	.LL332
 7919                        	
 7920                        		.dbg	line,	"include\routines_LEVELS.c", 1704; {
 7921                        	
 7922                        		.dbg	line,	"include\routines_LEVELS.c", 1705; // CAMERA GOES 8 PX BACKWARD //
 7923                        	
 7924                        		.dbg	line,	"include\routines_LEVELS.c", 1706; sgx_map_pxl_x = ( (sgx_map_pxl_x >> 3) << 3 );
 7925                        		__ld.wm		_sgx_map_pxl_x
         01:D34E  AD 89 26   			lda.l	_sgx_map_pxl_x
         01:D351  AC 8A 26   			ldy.h	_sgx_map_pxl_x
 7926                        		__lsr.wi	3
         01:D354  84 00      			sty	__temp
         01:D356  20 3A E2   			jsr	lsrw3
 7927                        		__asl.wi	3
         01:D359  84 00      			sty	__temp
         01:D35B  20 D7 E1   			jsr	aslw3
 7928                        		__st.wmq	_sgx_map_pxl_x
         01:D35E  8D 89 26   			sta.l	_sgx_map_pxl_x
         01:D361  8C 8A 26   			sty.h	_sgx_map_pxl_x
 7929                        	
 7930                        		.dbg	line,	"include\routines_LEVELS.c", 1708; // SO WE UPDATE THE MAP //
 7931                        	
 7932                        		.dbg	line,	"include\routines_LEVELS.c", 1709; sgx_scroll_map();
 7933                        		__call		_sgx_scroll_map
         01:D364  20 81 FF   			call	_sgx_scroll_map
 7934                        	
 7935                        		.dbg	line,	"include\routines_LEVELS.c", 1711; // CHECK IF THE PLAYER STANDS RIGHT TO THE LADDER //
 7936                        	
 7937                        		.dbg	line,	"include\routines_LEVELS.c", 1712; check_BG( 31 , 16 );
 7938                        		__ld.wi		31
         01:D367  A9 1F      			lda.l	#31
         01:D369  C2         			cly
 7939                        		__pusharg.wr
         01:D36A  A6 8D      			ldx	<__sp
         01:D36C  CA         			dex
         01:D36D  CA         			dex
         01:D36E  95 08      			sta.l	<__stack, x
         01:D370  94 09      			sty.h	<__stack, x
         01:D372  86 8D      			stx	<__sp
 7940                        		__ld.wi		16
         01:D374  A9 10      			lda.l	#16
         01:D376  C2         			cly
 7941                        		__pusharg.wr
         01:D377  A6 8D      			ldx	<__sp
         01:D379  CA         			dex
         01:D37A  CA         			dex
         01:D37B  95 08      			sta.l	<__stack, x
         01:D37D  94 09      			sty.h	<__stack, x
         01:D37F  86 8D      			stx	<__sp
 7942                        		__call		_check_BG
         01:D381  20 6D FF   			call	_check_BG
 7943                        	
 7944                        		.dbg	line,	"include\routines_LEVELS.c", 1714; if(map_blk_flag == TILE_LADDER)
 7945                        		__ld.umq	_map_blk_flag
         01:D384  AD AA 2B   			lda	_map_blk_flag
 7946                        		__equ_b.uiq	2
         01:D387  C9 02      			cmp	#2
         01:D389  F0 01      			beq	!+
         01:D38B  18         			clc
         01:D38C             	!:
 7947                        		__bfalse	.LL333
         01:D38C  90 0E      			bcc	.LL333
 7948                        	
 7949                        		.dbg	line,	"include\routines_LEVELS.c", 1715; {
 7950                        	
 7951                        		.dbg	line,	"include\routines_LEVELS.c", 1716; sgx_map_pxl_x += 8;
 7952                        		__add_st.wmiq	8, _sgx_map_pxl_x
         01:D38E  18         			clc
         01:D38F  AD 89 26   			lda.l	_sgx_map_pxl_x
         01:D392  69 08      			adc.l	#8
         01:D394  8D 89 26   			sta.l	_sgx_map_pxl_x
         01:D397  90 03      			bcc	!+
         01:D399  EE 8A 26   			inc.h	_sgx_map_pxl_x
         01:D39C             	!:
 7953                        	
 7954                        		.dbg	line,	"include\routines_LEVELS.c", 1717; }
 7955                        	
 7956                        		.dbg	line,	"include\routines_LEVELS.c", 1719; player_counter_anim = 1;
 7957    01:D39C             	.LL333:
 7958                        		__st.umiq	1, _player_counter_anim
         01:D39C  A9 01      			lda.l	#1
         01:D39E  8D 18 23   			sta	_player_counter_anim
 7959                        	
 7960                        		.dbg	line,	"include\routines_LEVELS.c", 1720; player_index_jump = 0;
 7961                        		__st.umiq	0, _player_index_jump
         01:D3A1  9C 19 23   			stz	_player_index_jump
 7962                        	
 7963                        		.dbg	line,	"include\routines_LEVELS.c", 1721; player_index_fall = 0;
 7964                        		__st.umiq	0, _player_index_fall
         01:D3A4  9C 1A 23   			stz	_player_index_fall
 7965                        	
 7966                        		.dbg	line,	"include\routines_LEVELS.c", 1722; jump_ladder = TRUE;
 7967                        		__st.umiq	1, _jump_ladder
         01:D3A7  A9 01      			lda.l	#1
         01:D3A9  8D 1C 23   			sta	_jump_ladder
 7968                        	
 7969                        		.dbg	line,	"include\routines_LEVELS.c", 1723; jump_max_index = 29;
 7970                        		__st.umiq	29, _jump_max_index
         01:D3AC  A9 1D      			lda.l	#29
         01:D3AE  8D 1D 23   			sta	_jump_max_index
 7971                        	
 7972                        		.dbg	line,	"include\routines_LEVELS.c", 1724; player_state = STATE_HANG;
 7973                        		__st.umiq	10, _player_state
         01:D3B1  A9 0A      			lda.l	#10
         01:D3B3  8D 15 23   			sta	_player_state
 7974                        	
 7975                        		.dbg	line,	"include\routines_LEVELS.c", 1725; return;
 7976                        		__bra		.LL180
         01:D3B6  4C 9E D8   			bra	.LL180
 7977                        	
 7978                        		.dbg	line,	"include\routines_LEVELS.c", 1726; }
 7979                        	
 7980                        		.dbg	line,	"include\routines_LEVELS.c", 1729; spr_y(player_pos_y);
 7981    01:D3B9             	.LL332:
 7982                        		__ld.wm		_player_pos_y
         01:D3B9  AD CF 24   			lda.l	_player_pos_y
         01:D3BC  AC D0 24   			ldy.h	_player_pos_y
 7983                        		__call		_spr_y.1
         01:D3BF  20 19 E8   			call	_spr_y.1
 7984                        	
 7985                        		.dbg	line,	"include\routines_LEVELS.c", 1730; }
 7986                        	
 7987                        		.dbg	line,	"include\routines_LEVELS.c", 1733; else if(player_state == STATE_HANG)
 7988                        		__bra		.LL334
         01:D3C2  4C 9E D8   			bra	.LL334
 7989    01:D3C5             	.LL320:
 7990                        		__ld.umq	_player_state
         01:D3C5  AD 15 23   			lda	_player_state
 7991                        		__equ_b.uiq	10
         01:D3C8  C9 0A      			cmp	#10
         01:D3CA  F0 01      			beq	!+
         01:D3CC  18         			clc
         01:D3CD             	!:
 7992                        		__bfalse	.LL335
         01:D3CD  90 43      			bcc	.LL335
 7993                        	
 7994                        		.dbg	line,	"include\routines_LEVELS.c", 1734; {
 7995                        	
 7996                        		.dbg	line,	"include\routines_LEVELS.c", 1735; recenter_CAMERA();
 7997                        		__call		_recenter_CAMERA
         01:D3CF  20 59 FF   			call	_recenter_CAMERA
 7998                        	
 7999                        		.dbg	line,	"include\routines_LEVELS.c", 1737; if(player_counter_anim == 1)
 8000                        		__ld.umq	_player_counter_anim
         01:D3D2  AD 18 23   			lda	_player_counter_anim
 8001                        		__equ_b.uiq	1
         01:D3D5  C9 01      			cmp	#1
         01:D3D7  F0 01      			beq	!+
         01:D3D9  18         			clc
         01:D3DA             	!:
 8002                        		__bfalse	.LL336
         01:D3DA  B0 03 4C 9E			bcc	.LL336
         01:D3DE  D8          
 8003                        	
 8004                        		.dbg	line,	"include\routines_LEVELS.c", 1738; {
 8005                        	
 8006                        		.dbg	line,	"include\routines_LEVELS.c", 1739; set_far_offset(OFFSET_PLAYER_HANG,TABLE_PLAYER_TILES_BANK[player_naked],TABLE_PLAYER_TILES_ADR[player_naked]);
 8007                        		__st.wmiq	4608, _bp
         01:D3DF  64 EC      			stz.l	_bp
         01:D3E1  A9 12      			lda.h	#4608
         01:D3E3  85 ED      			sta.h	_bp
 8008                        		__ldx.umq	_player_naked
         01:D3E5  AE 1B 23   			ldx	_player_naked
 8009                        		__ld.uax	_TABLE_PLAYER_TILES_BANK
         01:D3E8  BD F7 60   			lda	_TABLE_PLAYER_TILES_BANK, x
         01:D3EB  C2         			cly
 8010                        		__st.umq	_bp_bank
         01:D3EC  85 02      			sta	_bp_bank
 8011                        		__ld2x.umq	_player_naked
         01:D3EE  AD 1B 23   			lda	_player_naked
         01:D3F1  0A         			asl	a
         01:D3F2  AA         			tax
 8012                        		__ld.wax	_TABLE_PLAYER_TILES_ADR
         01:D3F3  BD F3 60   			lda.l	_TABLE_PLAYER_TILES_ADR, x
         01:D3F6  BC F4 60   			ldy.h	_TABLE_PLAYER_TILES_ADR, x
 8013                        		__call		_set_far_offset.3
         01:D3F9  20 8C E2   			call	_set_far_offset.3
 8014                        	
 8015                        		.dbg	line,	"include\routines_LEVELS.c", 1740; far_load_vram(PLAYER_VRAM_ADR,TILES_16);
 8016                        		__st.wmiq	6144, _di
         01:D3FC  64 F0      			stz.l	_di
         01:D3FE  A9 18      			lda.h	#6144
         01:D400  85 F1      			sta.h	_di
 8017                        		__st.wmiq	256, _ax
         01:D402  64 F8      			stz.l	_ax
         01:D404  A9 01      			lda.h	#256
         01:D406  85 F9      			sta.h	_ax
 8018                        		 _far_load_vram.2
         01:D408  82         			clx				; Offset to PCE VDC.
         01:D409  20 63 FF   			call	load_vram_x
 8019                        	
 8020                        		.dbg	line,	"include\routines_LEVELS.c", 1742; player_counter_anim = 0;
 8021                        		__st.umiq	0, _player_counter_anim
         01:D40C  9C 18 23   			stz	_player_counter_anim
 8022                        	
 8023                        		.dbg	line,	"include\routines_LEVELS.c", 1743; }
 8024                        	
 8025                        		.dbg	line,	"include\routines_LEVELS.c", 1744; }
 8026    01:D40F             	.LL336	.alias		.LL337
 8027                        	
 8028                        		.dbg	line,	"include\routines_LEVELS.c", 1747; else if(player_state == STATE_CLIMB_UP)
 8029                        		__bra		.LL337
         01:D40F  4C 9E D8   			bra	.LL337
 8030    01:D412             	.LL335:
 8031                        		__ld.umq	_player_state
         01:D412  AD 15 23   			lda	_player_state
 8032                        		__equ_b.uiq	11
         01:D415  C9 0B      			cmp	#11
         01:D417  F0 01      			beq	!+
         01:D419  18         			clc
         01:D41A             	!:
 8033                        		__bfalse	.LL338
         01:D41A  B0 03 4C 8B			bcc	.LL338
         01:D41E  D5          
 8034                        	
 8035                        		.dbg	line,	"include\routines_LEVELS.c", 1748; {
 8036                        	
 8037                        		.dbg	line,	"include\routines_LEVELS.c", 1749; if(player_counter_anim == 0)
 8038                        		__not.um	_player_counter_anim
         01:D41F  AD 18 23   			lda	_player_counter_anim
         01:D422  18         			clc
         01:D423  D0 01      			bne	!+
         01:D425  38         			sec
         01:D426             	!:
 8039                        		__bfalse	.LL339
         01:D426  90 30      			bcc	.LL339
 8040                        	
 8041                        		.dbg	line,	"include\routines_LEVELS.c", 1750; {
 8042                        	
 8043                        		.dbg	line,	"include\routines_LEVELS.c", 1751; set_far_offset(OFFSET_PLAYER_CLIMB_1,TABLE_PLAYER_TILES_BANK[player_naked],TABLE_PLAYER_TILES_ADR[player_naked]);
 8044                        		__st.wmiq	5120, _bp
         01:D428  64 EC      			stz.l	_bp
         01:D42A  A9 14      			lda.h	#5120
         01:D42C  85 ED      			sta.h	_bp
 8045                        		__ldx.umq	_player_naked
         01:D42E  AE 1B 23   			ldx	_player_naked
 8046                        		__ld.uax	_TABLE_PLAYER_TILES_BANK
         01:D431  BD F7 60   			lda	_TABLE_PLAYER_TILES_BANK, x
         01:D434  C2         			cly
 8047                        		__st.umq	_bp_bank
         01:D435  85 02      			sta	_bp_bank
 8048                        		__ld2x.umq	_player_naked
         01:D437  AD 1B 23   			lda	_player_naked
         01:D43A  0A         			asl	a
         01:D43B  AA         			tax
 8049                        		__ld.wax	_TABLE_PLAYER_TILES_ADR
         01:D43C  BD F3 60   			lda.l	_TABLE_PLAYER_TILES_ADR, x
         01:D43F  BC F4 60   			ldy.h	_TABLE_PLAYER_TILES_ADR, x
 8050                        		__call		_set_far_offset.3
         01:D442  20 8C E2   			call	_set_far_offset.3
 8051                        	
 8052                        		.dbg	line,	"include\routines_LEVELS.c", 1752; far_load_vram(PLAYER_VRAM_ADR,TILES_16);
 8053                        		__st.wmiq	6144, _di
         01:D445  64 F0      			stz.l	_di
         01:D447  A9 18      			lda.h	#6144
         01:D449  85 F1      			sta.h	_di
 8054                        		__st.wmiq	256, _ax
         01:D44B  64 F8      			stz.l	_ax
         01:D44D  A9 01      			lda.h	#256
         01:D44F  85 F9      			sta.h	_ax
 8055                        		 _far_load_vram.2
         01:D451  82         			clx				; Offset to PCE VDC.
         01:D452  20 63 FF   			call	load_vram_x
 8056                        	
 8057                        		.dbg	line,	"include\routines_LEVELS.c", 1753; }
 8058                        	
 8059                        		.dbg	line,	"include\routines_LEVELS.c", 1755; else if(player_counter_anim == 3)
 8060                        		__bra		.LL340
         01:D455  4C 75 D5   			bra	.LL340
 8061    01:D458             	.LL339:
 8062                        		__ld.umq	_player_counter_anim
         01:D458  AD 18 23   			lda	_player_counter_anim
 8063                        		__equ_b.uiq	3
         01:D45B  C9 03      			cmp	#3
         01:D45D  F0 01      			beq	!+
         01:D45F  18         			clc
         01:D460             	!:
 8064                        		__bfalse	.LL341
         01:D460  90 30      			bcc	.LL341
 8065                        	
 8066                        		.dbg	line,	"include\routines_LEVELS.c", 1756; {
 8067                        	
 8068                        		.dbg	line,	"include\routines_LEVELS.c", 1757; set_far_offset(OFFSET_PLAYER_CLIMB_2,TABLE_PLAYER_TILES_BANK[player_naked],TABLE_PLAYER_TILES_ADR[player_naked]);
 8069                        		__st.wmiq	5632, _bp
         01:D462  64 EC      			stz.l	_bp
         01:D464  A9 16      			lda.h	#5632
         01:D466  85 ED      			sta.h	_bp
 8070                        		__ldx.umq	_player_naked
         01:D468  AE 1B 23   			ldx	_player_naked
 8071                        		__ld.uax	_TABLE_PLAYER_TILES_BANK
         01:D46B  BD F7 60   			lda	_TABLE_PLAYER_TILES_BANK, x
         01:D46E  C2         			cly
 8072                        		__st.umq	_bp_bank
         01:D46F  85 02      			sta	_bp_bank
 8073                        		__ld2x.umq	_player_naked
         01:D471  AD 1B 23   			lda	_player_naked
         01:D474  0A         			asl	a
         01:D475  AA         			tax
 8074                        		__ld.wax	_TABLE_PLAYER_TILES_ADR
         01:D476  BD F3 60   			lda.l	_TABLE_PLAYER_TILES_ADR, x
         01:D479  BC F4 60   			ldy.h	_TABLE_PLAYER_TILES_ADR, x
 8075                        		__call		_set_far_offset.3
         01:D47C  20 8C E2   			call	_set_far_offset.3
 8076                        	
 8077                        		.dbg	line,	"include\routines_LEVELS.c", 1758; far_load_vram(PLAYER_VRAM_ADR,TILES_16);
 8078                        		__st.wmiq	6144, _di
         01:D47F  64 F0      			stz.l	_di
         01:D481  A9 18      			lda.h	#6144
         01:D483  85 F1      			sta.h	_di
 8079                        		__st.wmiq	256, _ax
         01:D485  64 F8      			stz.l	_ax
         01:D487  A9 01      			lda.h	#256
         01:D489  85 F9      			sta.h	_ax
 8080                        		 _far_load_vram.2
         01:D48B  82         			clx				; Offset to PCE VDC.
         01:D48C  20 63 FF   			call	load_vram_x
 8081                        	
 8082                        		.dbg	line,	"include\routines_LEVELS.c", 1759; }
 8083                        	
 8084                        		.dbg	line,	"include\routines_LEVELS.c", 1761; else if(player_counter_anim == 6)
 8085                        		__bra		.LL342
         01:D48F  4C 75 D5   			bra	.LL342
 8086    01:D492             	.LL341:
 8087                        		__ld.umq	_player_counter_anim
         01:D492  AD 18 23   			lda	_player_counter_anim
 8088                        		__equ_b.uiq	6
         01:D495  C9 06      			cmp	#6
         01:D497  F0 01      			beq	!+
         01:D499  18         			clc
         01:D49A             	!:
 8089                        		__bfalse	.LL343
         01:D49A  90 30      			bcc	.LL343
 8090                        	
 8091                        		.dbg	line,	"include\routines_LEVELS.c", 1762; {
 8092                        	
 8093                        		.dbg	line,	"include\routines_LEVELS.c", 1763; set_far_offset(OFFSET_PLAYER_CLIMB_3,TABLE_PLAYER_TILES_BANK[player_naked],TABLE_PLAYER_TILES_ADR[player_naked]);
 8094                        		__st.wmiq	6144, _bp
         01:D49C  64 EC      			stz.l	_bp
         01:D49E  A9 18      			lda.h	#6144
         01:D4A0  85 ED      			sta.h	_bp
 8095                        		__ldx.umq	_player_naked
         01:D4A2  AE 1B 23   			ldx	_player_naked
 8096                        		__ld.uax	_TABLE_PLAYER_TILES_BANK
         01:D4A5  BD F7 60   			lda	_TABLE_PLAYER_TILES_BANK, x
         01:D4A8  C2         			cly
 8097                        		__st.umq	_bp_bank
         01:D4A9  85 02      			sta	_bp_bank
 8098                        		__ld2x.umq	_player_naked
         01:D4AB  AD 1B 23   			lda	_player_naked
         01:D4AE  0A         			asl	a
         01:D4AF  AA         			tax
 8099                        		__ld.wax	_TABLE_PLAYER_TILES_ADR
         01:D4B0  BD F3 60   			lda.l	_TABLE_PLAYER_TILES_ADR, x
         01:D4B3  BC F4 60   			ldy.h	_TABLE_PLAYER_TILES_ADR, x
 8100                        		__call		_set_far_offset.3
         01:D4B6  20 8C E2   			call	_set_far_offset.3
 8101                        	
 8102                        		.dbg	line,	"include\routines_LEVELS.c", 1764; far_load_vram(PLAYER_VRAM_ADR,TILES_16);
 8103                        		__st.wmiq	6144, _di
         01:D4B9  64 F0      			stz.l	_di
         01:D4BB  A9 18      			lda.h	#6144
         01:D4BD  85 F1      			sta.h	_di
 8104                        		__st.wmiq	256, _ax
         01:D4BF  64 F8      			stz.l	_ax
         01:D4C1  A9 01      			lda.h	#256
         01:D4C3  85 F9      			sta.h	_ax
 8105                        		 _far_load_vram.2
         01:D4C5  82         			clx				; Offset to PCE VDC.
         01:D4C6  20 63 FF   			call	load_vram_x
 8106                        	
 8107                        		.dbg	line,	"include\routines_LEVELS.c", 1765; }
 8108                        	
 8109                        		.dbg	line,	"include\routines_LEVELS.c", 1767; else if(player_counter_anim == 9)
 8110                        		__bra		.LL344
         01:D4C9  4C 75 D5   			bra	.LL344
 8111    01:D4CC             	.LL343:
 8112                        		__ld.umq	_player_counter_anim
         01:D4CC  AD 18 23   			lda	_player_counter_anim
 8113                        		__equ_b.uiq	9
         01:D4CF  C9 09      			cmp	#9
         01:D4D1  F0 01      			beq	!+
         01:D4D3  18         			clc
         01:D4D4             	!:
 8114                        		__bfalse	.LL345
         01:D4D4  90 2F      			bcc	.LL345
 8115                        	
 8116                        		.dbg	line,	"include\routines_LEVELS.c", 1768; {
 8117                        	
 8118                        		.dbg	line,	"include\routines_LEVELS.c", 1769; set_far_offset(OFFSET_PLAYER_CLIMB_4,TABLE_PLAYER_TILES_BANK[player_naked],TABLE_PLAYER_TILES_ADR[player_naked]);
 8119                        		__st.wmiq	6656, _bp
         01:D4D6  64 EC      			stz.l	_bp
         01:D4D8  A9 1A      			lda.h	#6656
         01:D4DA  85 ED      			sta.h	_bp
 8120                        		__ldx.umq	_player_naked
         01:D4DC  AE 1B 23   			ldx	_player_naked
 8121                        		__ld.uax	_TABLE_PLAYER_TILES_BANK
         01:D4DF  BD F7 60   			lda	_TABLE_PLAYER_TILES_BANK, x
         01:D4E2  C2         			cly
 8122                        		__st.umq	_bp_bank
         01:D4E3  85 02      			sta	_bp_bank
 8123                        		__ld2x.umq	_player_naked
         01:D4E5  AD 1B 23   			lda	_player_naked
         01:D4E8  0A         			asl	a
         01:D4E9  AA         			tax
 8124                        		__ld.wax	_TABLE_PLAYER_TILES_ADR
         01:D4EA  BD F3 60   			lda.l	_TABLE_PLAYER_TILES_ADR, x
         01:D4ED  BC F4 60   			ldy.h	_TABLE_PLAYER_TILES_ADR, x
 8125                        		__call		_set_far_offset.3
         01:D4F0  20 8C E2   			call	_set_far_offset.3
 8126                        	
 8127                        		.dbg	line,	"include\routines_LEVELS.c", 1770; far_load_vram(PLAYER_VRAM_ADR,TILES_16);
 8128                        		__st.wmiq	6144, _di
         01:D4F3  64 F0      			stz.l	_di
         01:D4F5  A9 18      			lda.h	#6144
         01:D4F7  85 F1      			sta.h	_di
 8129                        		__st.wmiq	256, _ax
         01:D4F9  64 F8      			stz.l	_ax
         01:D4FB  A9 01      			lda.h	#256
         01:D4FD  85 F9      			sta.h	_ax
 8130                        		 _far_load_vram.2
         01:D4FF  82         			clx				; Offset to PCE VDC.
         01:D500  20 63 FF   			call	load_vram_x
 8131                        	
 8132                        		.dbg	line,	"include\routines_LEVELS.c", 1771; }
 8133                        	
 8134                        		.dbg	line,	"include\routines_LEVELS.c", 1773; else if(player_counter_anim == 12)
 8135                        		__bra		.LL346
         01:D503  80 70      			bra	.LL346
 8136    01:D505             	.LL345:
 8137                        		__ld.umq	_player_counter_anim
         01:D505  AD 18 23   			lda	_player_counter_anim
 8138                        		__equ_b.uiq	12
         01:D508  C9 0C      			cmp	#12
         01:D50A  F0 01      			beq	!+
         01:D50C  18         			clc
         01:D50D             	!:
 8139                        		__bfalse	.LL347
         01:D50D  90 2F      			bcc	.LL347
 8140                        	
 8141                        		.dbg	line,	"include\routines_LEVELS.c", 1774; {
 8142                        	
 8143                        		.dbg	line,	"include\routines_LEVELS.c", 1775; set_far_offset(OFFSET_PLAYER_CLIMB_3,TABLE_PLAYER_TILES_BANK[player_naked],TABLE_PLAYER_TILES_ADR[player_naked]);
 8144                        		__st.wmiq	6144, _bp
         01:D50F  64 EC      			stz.l	_bp
         01:D511  A9 18      			lda.h	#6144
         01:D513  85 ED      			sta.h	_bp
 8145                        		__ldx.umq	_player_naked
         01:D515  AE 1B 23   			ldx	_player_naked
 8146                        		__ld.uax	_TABLE_PLAYER_TILES_BANK
         01:D518  BD F7 60   			lda	_TABLE_PLAYER_TILES_BANK, x
         01:D51B  C2         			cly
 8147                        		__st.umq	_bp_bank
         01:D51C  85 02      			sta	_bp_bank
 8148                        		__ld2x.umq	_player_naked
         01:D51E  AD 1B 23   			lda	_player_naked
         01:D521  0A         			asl	a
         01:D522  AA         			tax
 8149                        		__ld.wax	_TABLE_PLAYER_TILES_ADR
         01:D523  BD F3 60   			lda.l	_TABLE_PLAYER_TILES_ADR, x
         01:D526  BC F4 60   			ldy.h	_TABLE_PLAYER_TILES_ADR, x
 8150                        		__call		_set_far_offset.3
         01:D529  20 8C E2   			call	_set_far_offset.3
 8151                        	
 8152                        		.dbg	line,	"include\routines_LEVELS.c", 1776; far_load_vram(PLAYER_VRAM_ADR,TILES_16);
 8153                        		__st.wmiq	6144, _di
         01:D52C  64 F0      			stz.l	_di
         01:D52E  A9 18      			lda.h	#6144
         01:D530  85 F1      			sta.h	_di
 8154                        		__st.wmiq	256, _ax
         01:D532  64 F8      			stz.l	_ax
         01:D534  A9 01      			lda.h	#256
         01:D536  85 F9      			sta.h	_ax
 8155                        		 _far_load_vram.2
         01:D538  82         			clx				; Offset to PCE VDC.
         01:D539  20 63 FF   			call	load_vram_x
 8156                        	
 8157                        		.dbg	line,	"include\routines_LEVELS.c", 1777; }
 8158                        	
 8159                        		.dbg	line,	"include\routines_LEVELS.c", 1779; else if(player_counter_anim == 15)
 8160                        		__bra		.LL348
         01:D53C  80 37      			bra	.LL348
 8161    01:D53E             	.LL347:
 8162                        		__ld.umq	_player_counter_anim
         01:D53E  AD 18 23   			lda	_player_counter_anim
 8163                        		__equ_b.uiq	15
         01:D541  C9 0F      			cmp	#15
         01:D543  F0 01      			beq	!+
         01:D545  18         			clc
         01:D546             	!:
 8164                        		__bfalse	.LL349
         01:D546  90 2D      			bcc	.LL349
 8165                        	
 8166                        		.dbg	line,	"include\routines_LEVELS.c", 1780; {
 8167                        	
 8168                        		.dbg	line,	"include\routines_LEVELS.c", 1781; set_far_offset(OFFSET_PLAYER_CLIMB_2,TABLE_PLAYER_TILES_BANK[player_naked],TABLE_PLAYER_TILES_ADR[player_naked]);
 8169                        		__st.wmiq	5632, _bp
         01:D548  64 EC      			stz.l	_bp
         01:D54A  A9 16      			lda.h	#5632
         01:D54C  85 ED      			sta.h	_bp
 8170                        		__ldx.umq	_player_naked
         01:D54E  AE 1B 23   			ldx	_player_naked
 8171                        		__ld.uax	_TABLE_PLAYER_TILES_BANK
         01:D551  BD F7 60   			lda	_TABLE_PLAYER_TILES_BANK, x
         01:D554  C2         			cly
 8172                        		__st.umq	_bp_bank
         01:D555  85 02      			sta	_bp_bank
 8173                        		__ld2x.umq	_player_naked
         01:D557  AD 1B 23   			lda	_player_naked
         01:D55A  0A         			asl	a
         01:D55B  AA         			tax
 8174                        		__ld.wax	_TABLE_PLAYER_TILES_ADR
         01:D55C  BD F3 60   			lda.l	_TABLE_PLAYER_TILES_ADR, x
         01:D55F  BC F4 60   			ldy.h	_TABLE_PLAYER_TILES_ADR, x
 8175                        		__call		_set_far_offset.3
         01:D562  20 8C E2   			call	_set_far_offset.3
 8176                        	
 8177                        		.dbg	line,	"include\routines_LEVELS.c", 1782; far_load_vram(PLAYER_VRAM_ADR,TILES_16);
 8178                        		__st.wmiq	6144, _di
         01:D565  64 F0      			stz.l	_di
         01:D567  A9 18      			lda.h	#6144
         01:D569  85 F1      			sta.h	_di
 8179                        		__st.wmiq	256, _ax
         01:D56B  64 F8      			stz.l	_ax
         01:D56D  A9 01      			lda.h	#256
         01:D56F  85 F9      			sta.h	_ax
 8180                        		 _far_load_vram.2
         01:D571  82         			clx				; Offset to PCE VDC.
         01:D572  20 63 FF   			call	load_vram_x
 8181                        	
 8182                        		.dbg	line,	"include\routines_LEVELS.c", 1783; }
 8183                        	
 8184                        		.dbg	line,	"include\routines_LEVELS.c", 1786; player_counter_anim += 1;
 8185    01:D575             	.LL349:
 8186    01:D575             	.LL348:
 8187    01:D575             	.LL346:
 8188    01:D575             	.LL344:
 8189    01:D575             	.LL342:
 8190    01:D575             	.LL340:
 8191                        		__add_st.umiq	1, _player_counter_anim
         01:D575  EE 18 23   			inc	_player_counter_anim
 8192                        	
 8193                        		.dbg	line,	"include\routines_LEVELS.c", 1788; if(player_counter_anim == 17)
 8194                        		__ld.umq	_player_counter_anim
         01:D578  AD 18 23   			lda	_player_counter_anim
 8195                        		__equ_b.uiq	17
         01:D57B  C9 11      			cmp	#17
         01:D57D  F0 01      			beq	!+
         01:D57F  18         			clc
         01:D580             	!:
 8196                        		__bfalse	.LL350
         01:D580  90 03      			bcc	.LL350
 8197                        	
 8198                        		.dbg	line,	"include\routines_LEVELS.c", 1789; {
 8199                        	
 8200                        		.dbg	line,	"include\routines_LEVELS.c", 1790; player_counter_anim = 0;
 8201                        		__st.umiq	0, _player_counter_anim
         01:D582  9C 18 23   			stz	_player_counter_anim
 8202                        	
 8203                        		.dbg	line,	"include\routines_LEVELS.c", 1791; }
 8204                        	
 8205                        		.dbg	line,	"include\routines_LEVELS.c", 1793; recenter_CAMERA();
 8206    01:D585             	.LL350:
 8207                        		__call		_recenter_CAMERA
         01:D585  20 59 FF   			call	_recenter_CAMERA
 8208                        	
 8209                        		.dbg	line,	"include\routines_LEVELS.c", 1794; }
 8210                        	
 8211                        		.dbg	line,	"include\routines_LEVELS.c", 1797; else if(player_state == STATE_CLIMB_DOWN)
 8212                        		__bra		.LL351
         01:D588  4C 9E D8   			bra	.LL351
 8213    01:D58B             	.LL338:
 8214                        		__ld.umq	_player_state
         01:D58B  AD 15 23   			lda	_player_state
 8215                        		__equ_b.uiq	12
         01:D58E  C9 0C      			cmp	#12
         01:D590  F0 01      			beq	!+
         01:D592  18         			clc
         01:D593             	!:
 8216                        		__bfalse	.LL352
         01:D593  B0 03 4C 04			bcc	.LL352
         01:D597  D7          
 8217                        	
 8218                        		.dbg	line,	"include\routines_LEVELS.c", 1798; {
 8219                        	
 8220                        		.dbg	line,	"include\routines_LEVELS.c", 1799; if(player_counter_anim == 0)
 8221                        		__not.um	_player_counter_anim
         01:D598  AD 18 23   			lda	_player_counter_anim
         01:D59B  18         			clc
         01:D59C  D0 01      			bne	!+
         01:D59E  38         			sec
         01:D59F             	!:
 8222                        		__bfalse	.LL353
         01:D59F  90 30      			bcc	.LL353
 8223                        	
 8224                        		.dbg	line,	"include\routines_LEVELS.c", 1800; {
 8225                        	
 8226                        		.dbg	line,	"include\routines_LEVELS.c", 1801; set_far_offset(OFFSET_PLAYER_CLIMB_2,TABLE_PLAYER_TILES_BANK[player_naked],TABLE_PLAYER_TILES_ADR[player_naked]);
 8227                        		__st.wmiq	5632, _bp
         01:D5A1  64 EC      			stz.l	_bp
         01:D5A3  A9 16      			lda.h	#5632
         01:D5A5  85 ED      			sta.h	_bp
 8228                        		__ldx.umq	_player_naked
         01:D5A7  AE 1B 23   			ldx	_player_naked
 8229                        		__ld.uax	_TABLE_PLAYER_TILES_BANK
         01:D5AA  BD F7 60   			lda	_TABLE_PLAYER_TILES_BANK, x
         01:D5AD  C2         			cly
 8230                        		__st.umq	_bp_bank
         01:D5AE  85 02      			sta	_bp_bank
 8231                        		__ld2x.umq	_player_naked
         01:D5B0  AD 1B 23   			lda	_player_naked
         01:D5B3  0A         			asl	a
         01:D5B4  AA         			tax
 8232                        		__ld.wax	_TABLE_PLAYER_TILES_ADR
         01:D5B5  BD F3 60   			lda.l	_TABLE_PLAYER_TILES_ADR, x
         01:D5B8  BC F4 60   			ldy.h	_TABLE_PLAYER_TILES_ADR, x
 8233                        		__call		_set_far_offset.3
         01:D5BB  20 8C E2   			call	_set_far_offset.3
 8234                        	
 8235                        		.dbg	line,	"include\routines_LEVELS.c", 1802; far_load_vram(PLAYER_VRAM_ADR,TILES_16);
 8236                        		__st.wmiq	6144, _di
         01:D5BE  64 F0      			stz.l	_di
         01:D5C0  A9 18      			lda.h	#6144
         01:D5C2  85 F1      			sta.h	_di
 8237                        		__st.wmiq	256, _ax
         01:D5C4  64 F8      			stz.l	_ax
         01:D5C6  A9 01      			lda.h	#256
         01:D5C8  85 F9      			sta.h	_ax
 8238                        		 _far_load_vram.2
         01:D5CA  82         			clx				; Offset to PCE VDC.
         01:D5CB  20 63 FF   			call	load_vram_x
 8239                        	
 8240                        		.dbg	line,	"include\routines_LEVELS.c", 1803; }
 8241                        	
 8242                        		.dbg	line,	"include\routines_LEVELS.c", 1805; else if(player_counter_anim == 3)
 8243                        		__bra		.LL354
         01:D5CE  4C EE D6   			bra	.LL354
 8244    01:D5D1             	.LL353:
 8245                        		__ld.umq	_player_counter_anim
         01:D5D1  AD 18 23   			lda	_player_counter_anim
 8246                        		__equ_b.uiq	3
         01:D5D4  C9 03      			cmp	#3
         01:D5D6  F0 01      			beq	!+
         01:D5D8  18         			clc
         01:D5D9             	!:
 8247                        		__bfalse	.LL355
         01:D5D9  90 30      			bcc	.LL355
 8248                        	
 8249                        		.dbg	line,	"include\routines_LEVELS.c", 1806; {
 8250                        	
 8251                        		.dbg	line,	"include\routines_LEVELS.c", 1807; set_far_offset(OFFSET_PLAYER_CLIMB_3,TABLE_PLAYER_TILES_BANK[player_naked],TABLE_PLAYER_TILES_ADR[player_naked]);
 8252                        		__st.wmiq	6144, _bp
         01:D5DB  64 EC      			stz.l	_bp
         01:D5DD  A9 18      			lda.h	#6144
         01:D5DF  85 ED      			sta.h	_bp
 8253                        		__ldx.umq	_player_naked
         01:D5E1  AE 1B 23   			ldx	_player_naked
 8254                        		__ld.uax	_TABLE_PLAYER_TILES_BANK
         01:D5E4  BD F7 60   			lda	_TABLE_PLAYER_TILES_BANK, x
         01:D5E7  C2         			cly
 8255                        		__st.umq	_bp_bank
         01:D5E8  85 02      			sta	_bp_bank
 8256                        		__ld2x.umq	_player_naked
         01:D5EA  AD 1B 23   			lda	_player_naked
         01:D5ED  0A         			asl	a
         01:D5EE  AA         			tax
 8257                        		__ld.wax	_TABLE_PLAYER_TILES_ADR
         01:D5EF  BD F3 60   			lda.l	_TABLE_PLAYER_TILES_ADR, x
         01:D5F2  BC F4 60   			ldy.h	_TABLE_PLAYER_TILES_ADR, x
 8258                        		__call		_set_far_offset.3
         01:D5F5  20 8C E2   			call	_set_far_offset.3
 8259                        	
 8260                        		.dbg	line,	"include\routines_LEVELS.c", 1808; far_load_vram(PLAYER_VRAM_ADR,TILES_16);
 8261                        		__st.wmiq	6144, _di
         01:D5F8  64 F0      			stz.l	_di
         01:D5FA  A9 18      			lda.h	#6144
         01:D5FC  85 F1      			sta.h	_di
 8262                        		__st.wmiq	256, _ax
         01:D5FE  64 F8      			stz.l	_ax
         01:D600  A9 01      			lda.h	#256
         01:D602  85 F9      			sta.h	_ax
 8263                        		 _far_load_vram.2
         01:D604  82         			clx				; Offset to PCE VDC.
         01:D605  20 63 FF   			call	load_vram_x
 8264                        	
 8265                        		.dbg	line,	"include\routines_LEVELS.c", 1809; }
 8266                        	
 8267                        		.dbg	line,	"include\routines_LEVELS.c", 1811; else if(player_counter_anim == 6)
 8268                        		__bra		.LL356
         01:D608  4C EE D6   			bra	.LL356
 8269    01:D60B             	.LL355:
 8270                        		__ld.umq	_player_counter_anim
         01:D60B  AD 18 23   			lda	_player_counter_anim
 8271                        		__equ_b.uiq	6
         01:D60E  C9 06      			cmp	#6
         01:D610  F0 01      			beq	!+
         01:D612  18         			clc
         01:D613             	!:
 8272                        		__bfalse	.LL357
         01:D613  90 30      			bcc	.LL357
 8273                        	
 8274                        		.dbg	line,	"include\routines_LEVELS.c", 1812; {
 8275                        	
 8276                        		.dbg	line,	"include\routines_LEVELS.c", 1813; set_far_offset(OFFSET_PLAYER_CLIMB_4,TABLE_PLAYER_TILES_BANK[player_naked],TABLE_PLAYER_TILES_ADR[player_naked]);
 8277                        		__st.wmiq	6656, _bp
         01:D615  64 EC      			stz.l	_bp
         01:D617  A9 1A      			lda.h	#6656
         01:D619  85 ED      			sta.h	_bp
 8278                        		__ldx.umq	_player_naked
         01:D61B  AE 1B 23   			ldx	_player_naked
 8279                        		__ld.uax	_TABLE_PLAYER_TILES_BANK
         01:D61E  BD F7 60   			lda	_TABLE_PLAYER_TILES_BANK, x
         01:D621  C2         			cly
 8280                        		__st.umq	_bp_bank
         01:D622  85 02      			sta	_bp_bank
 8281                        		__ld2x.umq	_player_naked
         01:D624  AD 1B 23   			lda	_player_naked
         01:D627  0A         			asl	a
         01:D628  AA         			tax
 8282                        		__ld.wax	_TABLE_PLAYER_TILES_ADR
         01:D629  BD F3 60   			lda.l	_TABLE_PLAYER_TILES_ADR, x
         01:D62C  BC F4 60   			ldy.h	_TABLE_PLAYER_TILES_ADR, x
 8283                        		__call		_set_far_offset.3
         01:D62F  20 8C E2   			call	_set_far_offset.3
 8284                        	
 8285                        		.dbg	line,	"include\routines_LEVELS.c", 1814; far_load_vram(PLAYER_VRAM_ADR,TILES_16);
 8286                        		__st.wmiq	6144, _di
         01:D632  64 F0      			stz.l	_di
         01:D634  A9 18      			lda.h	#6144
         01:D636  85 F1      			sta.h	_di
 8287                        		__st.wmiq	256, _ax
         01:D638  64 F8      			stz.l	_ax
         01:D63A  A9 01      			lda.h	#256
         01:D63C  85 F9      			sta.h	_ax
 8288                        		 _far_load_vram.2
         01:D63E  82         			clx				; Offset to PCE VDC.
         01:D63F  20 63 FF   			call	load_vram_x
 8289                        	
 8290                        		.dbg	line,	"include\routines_LEVELS.c", 1815; }
 8291                        	
 8292                        		.dbg	line,	"include\routines_LEVELS.c", 1817; else if(player_counter_anim == 9)
 8293                        		__bra		.LL358
         01:D642  4C EE D6   			bra	.LL358
 8294    01:D645             	.LL357:
 8295                        		__ld.umq	_player_counter_anim
         01:D645  AD 18 23   			lda	_player_counter_anim
 8296                        		__equ_b.uiq	9
         01:D648  C9 09      			cmp	#9
         01:D64A  F0 01      			beq	!+
         01:D64C  18         			clc
         01:D64D             	!:
 8297                        		__bfalse	.LL359
         01:D64D  90 2F      			bcc	.LL359
 8298                        	
 8299                        		.dbg	line,	"include\routines_LEVELS.c", 1818; {
 8300                        	
 8301                        		.dbg	line,	"include\routines_LEVELS.c", 1819; set_far_offset(OFFSET_PLAYER_CLIMB_3,TABLE_PLAYER_TILES_BANK[player_naked],TABLE_PLAYER_TILES_ADR[player_naked]);
 8302                        		__st.wmiq	6144, _bp
         01:D64F  64 EC      			stz.l	_bp
         01:D651  A9 18      			lda.h	#6144
         01:D653  85 ED      			sta.h	_bp
 8303                        		__ldx.umq	_player_naked
         01:D655  AE 1B 23   			ldx	_player_naked
 8304                        		__ld.uax	_TABLE_PLAYER_TILES_BANK
         01:D658  BD F7 60   			lda	_TABLE_PLAYER_TILES_BANK, x
         01:D65B  C2         			cly
 8305                        		__st.umq	_bp_bank
         01:D65C  85 02      			sta	_bp_bank
 8306                        		__ld2x.umq	_player_naked
         01:D65E  AD 1B 23   			lda	_player_naked
         01:D661  0A         			asl	a
         01:D662  AA         			tax
 8307                        		__ld.wax	_TABLE_PLAYER_TILES_ADR
         01:D663  BD F3 60   			lda.l	_TABLE_PLAYER_TILES_ADR, x
         01:D666  BC F4 60   			ldy.h	_TABLE_PLAYER_TILES_ADR, x
 8308                        		__call		_set_far_offset.3
         01:D669  20 8C E2   			call	_set_far_offset.3
 8309                        	
 8310                        		.dbg	line,	"include\routines_LEVELS.c", 1820; far_load_vram(PLAYER_VRAM_ADR,TILES_16);
 8311                        		__st.wmiq	6144, _di
         01:D66C  64 F0      			stz.l	_di
         01:D66E  A9 18      			lda.h	#6144
         01:D670  85 F1      			sta.h	_di
 8312                        		__st.wmiq	256, _ax
         01:D672  64 F8      			stz.l	_ax
         01:D674  A9 01      			lda.h	#256
         01:D676  85 F9      			sta.h	_ax
 8313                        		 _far_load_vram.2
         01:D678  82         			clx				; Offset to PCE VDC.
         01:D679  20 63 FF   			call	load_vram_x
 8314                        	
 8315                        		.dbg	line,	"include\routines_LEVELS.c", 1821; }
 8316                        	
 8317                        		.dbg	line,	"include\routines_LEVELS.c", 1823; else if(player_counter_anim == 12)
 8318                        		__bra		.LL360
         01:D67C  80 70      			bra	.LL360
 8319    01:D67E             	.LL359:
 8320                        		__ld.umq	_player_counter_anim
         01:D67E  AD 18 23   			lda	_player_counter_anim
 8321                        		__equ_b.uiq	12
         01:D681  C9 0C      			cmp	#12
         01:D683  F0 01      			beq	!+
         01:D685  18         			clc
         01:D686             	!:
 8322                        		__bfalse	.LL361
         01:D686  90 2F      			bcc	.LL361
 8323                        	
 8324                        		.dbg	line,	"include\routines_LEVELS.c", 1824; {
 8325                        	
 8326                        		.dbg	line,	"include\routines_LEVELS.c", 1825; set_far_offset(OFFSET_PLAYER_CLIMB_2,TABLE_PLAYER_TILES_BANK[player_naked],TABLE_PLAYER_TILES_ADR[player_naked]);
 8327                        		__st.wmiq	5632, _bp
         01:D688  64 EC      			stz.l	_bp
         01:D68A  A9 16      			lda.h	#5632
         01:D68C  85 ED      			sta.h	_bp
 8328                        		__ldx.umq	_player_naked
         01:D68E  AE 1B 23   			ldx	_player_naked
 8329                        		__ld.uax	_TABLE_PLAYER_TILES_BANK
         01:D691  BD F7 60   			lda	_TABLE_PLAYER_TILES_BANK, x
         01:D694  C2         			cly
 8330                        		__st.umq	_bp_bank
         01:D695  85 02      			sta	_bp_bank
 8331                        		__ld2x.umq	_player_naked
         01:D697  AD 1B 23   			lda	_player_naked
         01:D69A  0A         			asl	a
         01:D69B  AA         			tax
 8332                        		__ld.wax	_TABLE_PLAYER_TILES_ADR
         01:D69C  BD F3 60   			lda.l	_TABLE_PLAYER_TILES_ADR, x
         01:D69F  BC F4 60   			ldy.h	_TABLE_PLAYER_TILES_ADR, x
 8333                        		__call		_set_far_offset.3
         01:D6A2  20 8C E2   			call	_set_far_offset.3
 8334                        	
 8335                        		.dbg	line,	"include\routines_LEVELS.c", 1826; far_load_vram(PLAYER_VRAM_ADR,TILES_16);
 8336                        		__st.wmiq	6144, _di
         01:D6A5  64 F0      			stz.l	_di
         01:D6A7  A9 18      			lda.h	#6144
         01:D6A9  85 F1      			sta.h	_di
 8337                        		__st.wmiq	256, _ax
         01:D6AB  64 F8      			stz.l	_ax
         01:D6AD  A9 01      			lda.h	#256
         01:D6AF  85 F9      			sta.h	_ax
 8338                        		 _far_load_vram.2
         01:D6B1  82         			clx				; Offset to PCE VDC.
         01:D6B2  20 63 FF   			call	load_vram_x
 8339                        	
 8340                        		.dbg	line,	"include\routines_LEVELS.c", 1827; }
 8341                        	
 8342                        		.dbg	line,	"include\routines_LEVELS.c", 1829; else if(player_counter_anim == 15)
 8343                        		__bra		.LL362
         01:D6B5  80 37      			bra	.LL362
 8344    01:D6B7             	.LL361:
 8345                        		__ld.umq	_player_counter_anim
         01:D6B7  AD 18 23   			lda	_player_counter_anim
 8346                        		__equ_b.uiq	15
         01:D6BA  C9 0F      			cmp	#15
         01:D6BC  F0 01      			beq	!+
         01:D6BE  18         			clc
         01:D6BF             	!:
 8347                        		__bfalse	.LL363
         01:D6BF  90 2D      			bcc	.LL363
 8348                        	
 8349                        		.dbg	line,	"include\routines_LEVELS.c", 1830; {
 8350                        	
 8351                        		.dbg	line,	"include\routines_LEVELS.c", 1831; set_far_offset(OFFSET_PLAYER_CLIMB_1,TABLE_PLAYER_TILES_BANK[player_naked],TABLE_PLAYER_TILES_ADR[player_naked]);
 8352                        		__st.wmiq	5120, _bp
         01:D6C1  64 EC      			stz.l	_bp
         01:D6C3  A9 14      			lda.h	#5120
         01:D6C5  85 ED      			sta.h	_bp
 8353                        		__ldx.umq	_player_naked
         01:D6C7  AE 1B 23   			ldx	_player_naked
 8354                        		__ld.uax	_TABLE_PLAYER_TILES_BANK
         01:D6CA  BD F7 60   			lda	_TABLE_PLAYER_TILES_BANK, x
         01:D6CD  C2         			cly
 8355                        		__st.umq	_bp_bank
         01:D6CE  85 02      			sta	_bp_bank
 8356                        		__ld2x.umq	_player_naked
         01:D6D0  AD 1B 23   			lda	_player_naked
         01:D6D3  0A         			asl	a
         01:D6D4  AA         			tax
 8357                        		__ld.wax	_TABLE_PLAYER_TILES_ADR
         01:D6D5  BD F3 60   			lda.l	_TABLE_PLAYER_TILES_ADR, x
         01:D6D8  BC F4 60   			ldy.h	_TABLE_PLAYER_TILES_ADR, x
 8358                        		__call		_set_far_offset.3
         01:D6DB  20 8C E2   			call	_set_far_offset.3
 8359                        	
 8360                        		.dbg	line,	"include\routines_LEVELS.c", 1832; far_load_vram(PLAYER_VRAM_ADR,TILES_16);
 8361                        		__st.wmiq	6144, _di
         01:D6DE  64 F0      			stz.l	_di
         01:D6E0  A9 18      			lda.h	#6144
         01:D6E2  85 F1      			sta.h	_di
 8362                        		__st.wmiq	256, _ax
         01:D6E4  64 F8      			stz.l	_ax
         01:D6E6  A9 01      			lda.h	#256
         01:D6E8  85 F9      			sta.h	_ax
 8363                        		 _far_load_vram.2
         01:D6EA  82         			clx				; Offset to PCE VDC.
         01:D6EB  20 63 FF   			call	load_vram_x
 8364                        	
 8365                        		.dbg	line,	"include\routines_LEVELS.c", 1833; }
 8366                        	
 8367                        		.dbg	line,	"include\routines_LEVELS.c", 1836; player_counter_anim += 1;
 8368    01:D6EE             	.LL363:
 8369    01:D6EE             	.LL362:
 8370    01:D6EE             	.LL360:
 8371    01:D6EE             	.LL358:
 8372    01:D6EE             	.LL356:
 8373    01:D6EE             	.LL354:
 8374                        		__add_st.umiq	1, _player_counter_anim
         01:D6EE  EE 18 23   			inc	_player_counter_anim
 8375                        	
 8376                        		.dbg	line,	"include\routines_LEVELS.c", 1838; if(player_counter_anim == 17)
 8377                        		__ld.umq	_player_counter_anim
         01:D6F1  AD 18 23   			lda	_player_counter_anim
 8378                        		__equ_b.uiq	17
         01:D6F4  C9 11      			cmp	#17
         01:D6F6  F0 01      			beq	!+
         01:D6F8  18         			clc
         01:D6F9             	!:
 8379                        		__bfalse	.LL364
         01:D6F9  90 03      			bcc	.LL364
 8380                        	
 8381                        		.dbg	line,	"include\routines_LEVELS.c", 1839; {
 8382                        	
 8383                        		.dbg	line,	"include\routines_LEVELS.c", 1840; player_counter_anim = 0;
 8384                        		__st.umiq	0, _player_counter_anim
         01:D6FB  9C 18 23   			stz	_player_counter_anim
 8385                        	
 8386                        		.dbg	line,	"include\routines_LEVELS.c", 1841; }
 8387                        	
 8388                        		.dbg	line,	"include\routines_LEVELS.c", 1843; recenter_CAMERA();
 8389    01:D6FE             	.LL364:
 8390                        		__call		_recenter_CAMERA
         01:D6FE  20 59 FF   			call	_recenter_CAMERA
 8391                        	
 8392                        		.dbg	line,	"include\routines_LEVELS.c", 1844; }
 8393                        	
 8394                        		.dbg	line,	"include\routines_LEVELS.c", 1847; else if(player_state == STATE_JUMP_LADDER)
 8395                        		__bra		.LL365
         01:D701  4C 9E D8   			bra	.LL365
 8396    01:D704             	.LL352:
 8397                        		__ld.umq	_player_state
         01:D704  AD 15 23   			lda	_player_state
 8398                        		__equ_b.uiq	13
         01:D707  C9 0D      			cmp	#13
         01:D709  F0 01      			beq	!+
         01:D70B  18         			clc
         01:D70C             	!:
 8399                        		__bfalse	.LL366
         01:D70C  B0 03 4C 9E			bcc	.LL366
         01:D710  D8          
 8400                        	
 8401                        		.dbg	line,	"include\routines_LEVELS.c", 1848; {
 8402                        	
 8403                        		.dbg	line,	"include\routines_LEVELS.c", 1849; unsigned char i;
 8404                        	
 8405                        		.dbg	line,	"include\routines_LEVELS.c", 1850; i = 1;
 8406                        		__st.umiq	1, __update_PLAYER_end - 8  /* i */
         01:D711  A9 01      			lda.l	#1
         01:D713  8D 05 23   			sta	__update_PLAYER_end - 8
 8407                        	
 8408                        		.dbg	line,	"include\routines_LEVELS.c", 1853; if(player_counter_anim == 0)
 8409                        		__not.um	_player_counter_anim
         01:D716  AD 18 23   			lda	_player_counter_anim
         01:D719  18         			clc
         01:D71A  D0 01      			bne	!+
         01:D71C  38         			sec
         01:D71D             	!:
 8410                        		__bfalse	.LL367
         01:D71D  90 32      			bcc	.LL367
 8411                        	
 8412                        		.dbg	line,	"include\routines_LEVELS.c", 1854; {
 8413                        	
 8414                        		.dbg	line,	"include\routines_LEVELS.c", 1855; set_far_offset(OFFSET_PLAYER_JUMP,TABLE_PLAYER_TILES_BANK[player_naked],TABLE_PLAYER_TILES_ADR[player_naked]);
 8415                        		__st.wmiq	3584, _bp
         01:D71F  64 EC      			stz.l	_bp
         01:D721  A9 0E      			lda.h	#3584
         01:D723  85 ED      			sta.h	_bp
 8416                        		__ldx.umq	_player_naked
         01:D725  AE 1B 23   			ldx	_player_naked
 8417                        		__ld.uax	_TABLE_PLAYER_TILES_BANK
         01:D728  BD F7 60   			lda	_TABLE_PLAYER_TILES_BANK, x
         01:D72B  C2         			cly
 8418                        		__st.umq	_bp_bank
         01:D72C  85 02      			sta	_bp_bank
 8419                        		__ld2x.umq	_player_naked
         01:D72E  AD 1B 23   			lda	_player_naked
         01:D731  0A         			asl	a
         01:D732  AA         			tax
 8420                        		__ld.wax	_TABLE_PLAYER_TILES_ADR
         01:D733  BD F3 60   			lda.l	_TABLE_PLAYER_TILES_ADR, x
         01:D736  BC F4 60   			ldy.h	_TABLE_PLAYER_TILES_ADR, x
 8421                        		__call		_set_far_offset.3
         01:D739  20 8C E2   			call	_set_far_offset.3
 8422                        	
 8423                        		.dbg	line,	"include\routines_LEVELS.c", 1856; far_load_vram(PLAYER_VRAM_ADR,TILES_16);
 8424                        		__st.wmiq	6144, _di
         01:D73C  64 F0      			stz.l	_di
         01:D73E  A9 18      			lda.h	#6144
         01:D740  85 F1      			sta.h	_di
 8425                        		__st.wmiq	256, _ax
         01:D742  64 F8      			stz.l	_ax
         01:D744  A9 01      			lda.h	#256
         01:D746  85 F9      			sta.h	_ax
 8426                        		 _far_load_vram.2
         01:D748  82         			clx				; Offset to PCE VDC.
         01:D749  20 63 FF   			call	load_vram_x
 8427                        	
 8428                        		.dbg	line,	"include\routines_LEVELS.c", 1858; player_counter_anim = 1;
 8429                        		__st.umiq	1, _player_counter_anim
         01:D74C  A9 01      			lda.l	#1
         01:D74E  8D 18 23   			sta	_player_counter_anim
 8430                        	
 8431                        		.dbg	line,	"include\routines_LEVELS.c", 1859; }
 8432                        	
 8433                        		.dbg	line,	"include\routines_LEVELS.c", 1862; player_pos_y += TABLE_PLAYER_JUMP_V[player_index_jump];
 8434    01:D751             	.LL367:
 8435                        		__ldx.umq	_player_index_jump
         01:D751  AE 19 23   			ldx	_player_index_jump
 8436                        		__ld.bax	_TABLE_PLAYER_JUMP_V
         01:D754  BD F9 60   			lda	_TABLE_PLAYER_JUMP_V, x
         01:D757  C2         			cly
         01:D758  10 01      			bpl	!+
         01:D75A  88         			dey
         01:D75B             	!:
 8437                        		__add_st.wmq	_player_pos_y
         01:D75B  18         			clc
         01:D75C  6D CF 24   			adc.l	_player_pos_y
         01:D75F  8D CF 24   			sta.l	_player_pos_y
         01:D762  98         			tya
         01:D763  6D D0 24   			adc.h	_player_pos_y
         01:D766  8D D0 24   			sta.h	_player_pos_y
 8438                        	
 8439                        		.dbg	line,	"include\routines_LEVELS.c", 1864; // CHECK COLLISION WITH CEILING //
 8440                        	
 8441                        		.dbg	line,	"include\routines_LEVELS.c", 1865; check_BG( 15 , 8 );
 8442                        		__ld.wi		15
         01:D769  A9 0F      			lda.l	#15
         01:D76B  C2         			cly
 8443                        		__pusharg.wr
         01:D76C  A6 8D      			ldx	<__sp
         01:D76E  CA         			dex
         01:D76F  CA         			dex
         01:D770  95 08      			sta.l	<__stack, x
         01:D772  94 09      			sty.h	<__stack, x
         01:D774  86 8D      			stx	<__sp
 8444                        		__ld.wi		8
         01:D776  A9 08      			lda.l	#8
         01:D778  C2         			cly
 8445                        		__pusharg.wr
         01:D779  A6 8D      			ldx	<__sp
         01:D77B  CA         			dex
         01:D77C  CA         			dex
         01:D77D  95 08      			sta.l	<__stack, x
         01:D77F  94 09      			sty.h	<__stack, x
         01:D781  86 8D      			stx	<__sp
 8446                        		__call		_check_BG
         01:D783  20 6D FF   			call	_check_BG
 8447                        	
 8448                        		.dbg	line,	"include\routines_LEVELS.c", 1867; if(map_blk_flag == TILE_BG)
 8449                        		__ld.umq	_map_blk_flag
         01:D786  AD AA 2B   			lda	_map_blk_flag
 8450                        		__equ_b.uiq	1
         01:D789  C9 01      			cmp	#1
         01:D78B  F0 01      			beq	!+
         01:D78D  18         			clc
         01:D78E             	!:
 8451                        		__bfalse	.LL368
         01:D78E  90 5A      			bcc	.LL368
 8452                        	
 8453                        		.dbg	line,	"include\routines_LEVELS.c", 1868; {
 8454                        	
 8455                        		.dbg	line,	"include\routines_LEVELS.c", 1869; for(i=1 ; i<8 ; i++)
 8456                        		__st.umiq	1, __update_PLAYER_end - 8  /* i */
         01:D790  A9 01      			lda.l	#1
         01:D792  8D 05 23   			sta	__update_PLAYER_end - 8
 8457    01:D795             	.LL369:
 8458                        		__ld.umq	__update_PLAYER_end - 8  /* i */
         01:D795  AD 05 23   			lda	__update_PLAYER_end - 8
 8459                        		__ult_b.uiq	8
         01:D798  C9 08      			cmp	#8		; Subtract integer from A.
         01:D79A  6A         			ror	a		; CC if A < integer.
         01:D79B  49 80      			eor	#$80
         01:D79D  2A         			rol	a
 8460                        		__btrue		.LL371
         01:D79E  B0 07      			bcs	.LL371
 8461                        		__bra		.LL372
         01:D7A0  80 48      			bra	.LL372
 8462    01:D7A2             	.LL370:
 8463                        		__inc.umq	__update_PLAYER_end - 8  /* i */
         01:D7A2  EE 05 23   			inc	__update_PLAYER_end - 8
 8464                        		__bra		.LL369
         01:D7A5  80 EE      			bra	.LL369
 8465    01:D7A7             	.LL371:
 8466                        	
 8467                        		.dbg	line,	"include\routines_LEVELS.c", 1870; {
 8468                        	
 8469                        		.dbg	line,	"include\routines_LEVELS.c", 1871; check_BG( 15 , 8 + i );
 8470                        		__ld.wi		15
         01:D7A7  A9 0F      			lda.l	#15
         01:D7A9  C2         			cly
 8471                        		__pusharg.wr
         01:D7AA  A6 8D      			ldx	<__sp
         01:D7AC  CA         			dex
         01:D7AD  CA         			dex
         01:D7AE  95 08      			sta.l	<__stack, x
         01:D7B0  94 09      			sty.h	<__stack, x
         01:D7B2  86 8D      			stx	<__sp
 8472                        		__ld.wi		8
         01:D7B4  A9 08      			lda.l	#8
         01:D7B6  C2         			cly
 8473                        		__add.um	__update_PLAYER_end - 8  /* i */
         01:D7B7  18         			clc
         01:D7B8  6D 05 23   			adc	__update_PLAYER_end - 8
         01:D7BB  90 01      			bcc	!+
         01:D7BD  C8         			iny
         01:D7BE             	!:
 8474                        		__pusharg.wr
         01:D7BE  A6 8D      			ldx	<__sp
         01:D7C0  CA         			dex
         01:D7C1  CA         			dex
         01:D7C2  95 08      			sta.l	<__stack, x
         01:D7C4  94 09      			sty.h	<__stack, x
         01:D7C6  86 8D      			stx	<__sp
 8475                        		__call		_check_BG
         01:D7C8  20 6D FF   			call	_check_BG
 8476                        	
 8477                        		.dbg	line,	"include\routines_LEVELS.c", 1872; {
 8478                        	
 8479                        		.dbg	line,	"include\routines_LEVELS.c", 1873; if(map_blk_flag == TILE_EMPTY)
 8480                        		__not.um	_map_blk_flag
         01:D7CB  AD AA 2B   			lda	_map_blk_flag
         01:D7CE  18         			clc
         01:D7CF  D0 01      			bne	!+
         01:D7D1  38         			sec
         01:D7D2             	!:
 8481                        		__bfalse	.LL373
         01:D7D2  90 CE      			bcc	.LL373
 8482                        	
 8483                        		.dbg	line,	"include\routines_LEVELS.c", 1874; {
 8484                        	
 8485                        		.dbg	line,	"include\routines_LEVELS.c", 1875; player_pos_y += i;
 8486                        		__ld.um		__update_PLAYER_end - 8  /* i */
         01:D7D4  AD 05 23   			lda	__update_PLAYER_end - 8
         01:D7D7  C2         			cly
 8487                        		__add_st.wmq	_player_pos_y
         01:D7D8  18         			clc
         01:D7D9  6D CF 24   			adc.l	_player_pos_y
         01:D7DC  8D CF 24   			sta.l	_player_pos_y
         01:D7DF  98         			tya
         01:D7E0  6D D0 24   			adc.h	_player_pos_y
         01:D7E3  8D D0 24   			sta.h	_player_pos_y
 8488                        	
 8489                        		.dbg	line,	"include\routines_LEVELS.c", 1876; break;
 8490                        		__bra		.LL372
         01:D7E6  80 02      			bra	.LL372
 8491                        	
 8492                        		.dbg	line,	"include\routines_LEVELS.c", 1877; }
 8493                        	
 8494                        		.dbg	line,	"include\routines_LEVELS.c", 1878; }
 8495    01:D7E8             	.LL373	.alias		.LL370
 8496                        	
 8497                        		.dbg	line,	"include\routines_LEVELS.c", 1879; }
 8498                        		__bra		.LL370
         01:D7E8  80 B8      			bra	.LL370
 8499    01:D7EA             	.LL372:
 8500                        	
 8501                        		.dbg	line,	"include\routines_LEVELS.c", 1880; }
 8502                        	
 8503                        		.dbg	line,	"include\routines_LEVELS.c", 1882; spr_set(player_id);
 8504    01:D7EA             	.LL368:
 8505                        		__ld.umq	_player_id
         01:D7EA  AD 14 23   			lda	_player_id
 8506                        		__call		_spr_set.1
         01:D7ED  20 DD E7   			call	_spr_set.1
 8507                        	
 8508                        		.dbg	line,	"include\routines_LEVELS.c", 1883; spr_y(player_pos_y);
 8509                        		__ld.wm		_player_pos_y
         01:D7F0  AD CF 24   			lda.l	_player_pos_y
         01:D7F3  AC D0 24   			ldy.h	_player_pos_y
 8510                        		__call		_spr_y.1
         01:D7F6  20 19 E8   			call	_spr_y.1
 8511                        	
 8512                        		.dbg	line,	"include\routines_LEVELS.c", 1887; if(player_index_jump < 34)
 8513                        		__ld.umq	_player_index_jump
         01:D7F9  AD 19 23   			lda	_player_index_jump
 8514                        		__ult_b.uiq	34
         01:D7FC  C9 22      			cmp	#34		; Subtract integer from A.
         01:D7FE  6A         			ror	a		; CC if A < integer.
         01:D7FF  49 80      			eor	#$80
         01:D801  2A         			rol	a
 8515                        		__bfalse	.LL374
         01:D802  90 03      			bcc	.LL374
 8516                        	
 8517                        		.dbg	line,	"include\routines_LEVELS.c", 1888; {
 8518                        	
 8519                        		.dbg	line,	"include\routines_LEVELS.c", 1889; player_index_jump += 1;
 8520                        		__add_st.umiq	1, _player_index_jump
         01:D804  EE 19 23   			inc	_player_index_jump
 8521                        	
 8522                        		.dbg	line,	"include\routines_LEVELS.c", 1890; }
 8523                        	
 8524                        		.dbg	line,	"include\routines_LEVELS.c", 1895; //--------------------------------------------------------------------------------------//
 8525                        	
 8526                        		.dbg	line,	"include\routines_LEVELS.c", 1896; //                                   LADDER COLLISION                                   //
 8527                        	
 8528                        		.dbg	line,	"include\routines_LEVELS.c", 1897; //--------------------------------------------------------------------------------------//
 8529                        	
 8530                        		.dbg	line,	"include\routines_LEVELS.c", 1899; if(player_index_jump > 18)
 8531    01:D807             	.LL374:
 8532                        		__ld.umq	_player_index_jump
         01:D807  AD 19 23   			lda	_player_index_jump
 8533                        		__ugt_b.uiq	18
         01:D80A  18         			clc			; Subtract integer+1 from A.
         01:D80B  E9 12      			sbc	#18		; CS if A > integer.
 8534                        		__bfalse	.LL375
         01:D80D  B0 03 4C 9E			bcc	.LL375
         01:D811  D8          
 8535                        	
 8536                        		.dbg	line,	"include\routines_LEVELS.c", 1900; {
 8537                        	
 8538                        		.dbg	line,	"include\routines_LEVELS.c", 1901; // CHECK COLLISION WITH LADDERS //
 8539                        	
 8540                        		.dbg	line,	"include\routines_LEVELS.c", 1902; check_BG( 16 , 8 );
 8541                        		__ld.wi		16
         01:D812  A9 10      			lda.l	#16
         01:D814  C2         			cly
 8542                        		__pusharg.wr
         01:D815  A6 8D      			ldx	<__sp
         01:D817  CA         			dex
         01:D818  CA         			dex
         01:D819  95 08      			sta.l	<__stack, x
         01:D81B  94 09      			sty.h	<__stack, x
         01:D81D  86 8D      			stx	<__sp
 8543                        		__ld.wi		8
         01:D81F  A9 08      			lda.l	#8
         01:D821  C2         			cly
 8544                        		__pusharg.wr
         01:D822  A6 8D      			ldx	<__sp
         01:D824  CA         			dex
         01:D825  CA         			dex
         01:D826  95 08      			sta.l	<__stack, x
         01:D828  94 09      			sty.h	<__stack, x
         01:D82A  86 8D      			stx	<__sp
 8545                        		__call		_check_BG
         01:D82C  20 6D FF   			call	_check_BG
 8546                        	
 8547                        		.dbg	line,	"include\routines_LEVELS.c", 1904; // IF PLAYER HITS THE LADDER //
 8548                        	
 8549                        		.dbg	line,	"include\routines_LEVELS.c", 1905; if(map_blk_flag == TILE_LADDER)
 8550                        		__ld.umq	_map_blk_flag
         01:D82F  AD AA 2B   			lda	_map_blk_flag
 8551                        		__equ_b.uiq	2
         01:D832  C9 02      			cmp	#2
         01:D834  F0 01      			beq	!+
         01:D836  18         			clc
         01:D837             	!:
 8552                        		__bfalse	.LL376
         01:D837  90 65      			bcc	.LL376
 8553                        	
 8554                        		.dbg	line,	"include\routines_LEVELS.c", 1906; {
 8555                        	
 8556                        		.dbg	line,	"include\routines_LEVELS.c", 1907; // CAMERA GOES 8 PX BACKWARD //
 8557                        	
 8558                        		.dbg	line,	"include\routines_LEVELS.c", 1908; sgx_map_pxl_x = ( (sgx_map_pxl_x >> 3) << 3 );
 8559                        		__ld.wm		_sgx_map_pxl_x
         01:D839  AD 89 26   			lda.l	_sgx_map_pxl_x
         01:D83C  AC 8A 26   			ldy.h	_sgx_map_pxl_x
 8560                        		__lsr.wi	3
         01:D83F  84 00      			sty	__temp
         01:D841  20 3A E2   			jsr	lsrw3
 8561                        		__asl.wi	3
         01:D844  84 00      			sty	__temp
         01:D846  20 D7 E1   			jsr	aslw3
 8562                        		__st.wmq	_sgx_map_pxl_x
         01:D849  8D 89 26   			sta.l	_sgx_map_pxl_x
         01:D84C  8C 8A 26   			sty.h	_sgx_map_pxl_x
 8563                        	
 8564                        		.dbg	line,	"include\routines_LEVELS.c", 1910; // SO WE UPDATE THE MAP //
 8565                        	
 8566                        		.dbg	line,	"include\routines_LEVELS.c", 1911; sgx_scroll_map();
 8567                        		__call		_sgx_scroll_map
         01:D84F  20 81 FF   			call	_sgx_scroll_map
 8568                        	
 8569                        		.dbg	line,	"include\routines_LEVELS.c", 1913; // CHECK IF THE PLAYER STANDS RIGHT TO THE LADDER //
 8570                        	
 8571                        		.dbg	line,	"include\routines_LEVELS.c", 1914; check_BG( 31 , 8 );
 8572                        		__ld.wi		31
         01:D852  A9 1F      			lda.l	#31
         01:D854  C2         			cly
 8573                        		__pusharg.wr
         01:D855  A6 8D      			ldx	<__sp
         01:D857  CA         			dex
         01:D858  CA         			dex
         01:D859  95 08      			sta.l	<__stack, x
         01:D85B  94 09      			sty.h	<__stack, x
         01:D85D  86 8D      			stx	<__sp
 8574                        		__ld.wi		8
         01:D85F  A9 08      			lda.l	#8
         01:D861  C2         			cly
 8575                        		__pusharg.wr
         01:D862  A6 8D      			ldx	<__sp
         01:D864  CA         			dex
         01:D865  CA         			dex
         01:D866  95 08      			sta.l	<__stack, x
         01:D868  94 09      			sty.h	<__stack, x
         01:D86A  86 8D      			stx	<__sp
 8576                        		__call		_check_BG
         01:D86C  20 6D FF   			call	_check_BG
 8577                        	
 8578                        		.dbg	line,	"include\routines_LEVELS.c", 1916; if(map_blk_flag == TILE_LADDER)
 8579                        		__ld.umq	_map_blk_flag
         01:D86F  AD AA 2B   			lda	_map_blk_flag
 8580                        		__equ_b.uiq	2
         01:D872  C9 02      			cmp	#2
         01:D874  F0 01      			beq	!+
         01:D876  18         			clc
         01:D877             	!:
 8581                        		__bfalse	.LL377
         01:D877  90 0E      			bcc	.LL377
 8582                        	
 8583                        		.dbg	line,	"include\routines_LEVELS.c", 1917; {
 8584                        	
 8585                        		.dbg	line,	"include\routines_LEVELS.c", 1918; sgx_map_pxl_x += 8;
 8586                        		__add_st.wmiq	8, _sgx_map_pxl_x
         01:D879  18         			clc
         01:D87A  AD 89 26   			lda.l	_sgx_map_pxl_x
         01:D87D  69 08      			adc.l	#8
         01:D87F  8D 89 26   			sta.l	_sgx_map_pxl_x
         01:D882  90 03      			bcc	!+
         01:D884  EE 8A 26   			inc.h	_sgx_map_pxl_x
         01:D887             	!:
 8587                        	
 8588                        		.dbg	line,	"include\routines_LEVELS.c", 1919; }
 8589                        	
 8590                        		.dbg	line,	"include\routines_LEVELS.c", 1921; player_counter_anim = 1;
 8591    01:D887             	.LL377:
 8592                        		__st.umiq	1, _player_counter_anim
         01:D887  A9 01      			lda.l	#1
         01:D889  8D 18 23   			sta	_player_counter_anim
 8593                        	
 8594                        		.dbg	line,	"include\routines_LEVELS.c", 1922; player_index_jump = 0;
 8595                        		__st.umiq	0, _player_index_jump
         01:D88C  9C 19 23   			stz	_player_index_jump
 8596                        	
 8597                        		.dbg	line,	"include\routines_LEVELS.c", 1923; jump_ladder = TRUE;
 8598                        		__st.umiq	1, _jump_ladder
         01:D88F  A9 01      			lda.l	#1
         01:D891  8D 1C 23   			sta	_jump_ladder
 8599                        	
 8600                        		.dbg	line,	"include\routines_LEVELS.c", 1924; jump_max_index = 29;
 8601                        		__st.umiq	29, _jump_max_index
         01:D894  A9 1D      			lda.l	#29
         01:D896  8D 1D 23   			sta	_jump_max_index
 8602                        	
 8603                        		.dbg	line,	"include\routines_LEVELS.c", 1925; player_state = STATE_HANG;
 8604                        		__st.umiq	10, _player_state
         01:D899  A9 0A      			lda.l	#10
         01:D89B  8D 15 23   			sta	_player_state
 8605                        	
 8606                        		.dbg	line,	"include\routines_LEVELS.c", 1926; }
 8607                        	
 8608                        		.dbg	line,	"include\routines_LEVELS.c", 1927; }
 8609    01:D89E             	.LL376:
 8610                        	
 8611                        		.dbg	line,	"include\routines_LEVELS.c", 1928; }
 8612    01:D89E             	.LL375:
 8613                        	
 8614                        		.dbg	line,	"include\routines_LEVELS.c", 1930; }
 8615    01:D89E             	.LL366:
 8616    01:D89E             	.LL365:
 8617    01:D89E             	.LL351:
 8618    01:D89E             	.LL337:
 8619    01:D89E             	.LL334:
 8620    01:D89E             	.LL319:
 8621    01:D89E             	.LL316:
 8622    01:D89E             	.LL279:
 8623    01:D89E             	.LL242:
 8624    01:D89E             	.LL216:
 8625    01:D89E             	.LL185:
 8626    01:D89E             	.LL180:
 8627                        		__return	0
         01:D89E  4C EF FF   			jmp	leave_proc
 8628                        		.dbg	clear
 8629                        		.endp
 8630               7F60     		.data
 8631               2305     		.bss
 8632    F8:2305             	__update_PLAYER_loc:
 8633    F8:2305             			ds	8
 8634    F8:230D             	__update_PLAYER_end:
 8635               E309     		.code
 8636                        		.pceas
 8637                        	
 8638                        		.dbg	line,	"main.c", 23; #include "include/routines_SHOP.c"
 8639                        		.dbg	line,	"include\routines_SHOP.c", 1; #include "huc.h"
 8640                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 1; #ifndef _hucc_legacy_h
 8641                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 2; #define _hucc_legacy_h
 8642                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 4; /****************************************************************************
 8643                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 5; ; ***************************************************************************
 8644                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 6; ;
 8645                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 7; ; huc.h
 8646                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 8; ;
 8647                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 9; ; HuCC wrapper file to include a default set of HuC-compatible functions.
 8648                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 10; ;
 8649                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 11; ; Copyright John Brandwood 2024.
 8650                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 12; ;
 8651                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 13; ; Distributed under the Boost Software License, Version 1.0.
 8652                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 14; ; (See accompanying file LICENSE_1_0.txt or copy at
 8653                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 15; ;  http://www.boost.org/LICENSE_1_0.txt)
 8654                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 16; ;
 8655                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 17; ; ***************************************************************************
 8656                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 18; ; ***************************************************************************
 8657                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 19; ;
 8658                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 20; ; When the HuCC compiler is invoked with the "--legacy" option to compile old
 8659                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 21; ; projects, then this "huc.h" file is automatically included.
 8660                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 22; ;
 8661                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 23; ; This file includes a set of the individual HuCC headers which correspond to
 8662                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 24; ; HuC's built-in functions and MagicKit library.
 8663                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 25; ;
 8664                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 26; ; New HuCC projects should, preferably, include the specific headers that are
 8665                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 27; ; needed, which will then allow them to replace parts of the standard library
 8666                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 28; ; with newer functions, or they can just manually include this "huc.h" file.
 8667                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 29; ;
 8668                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 30; ; ***************************************************************************
 8669                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 31; ; **************************************************************************/
 8670                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 33; #include "hucc-systemcard.h"
 8671                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 34; #include "hucc-baselib.h"
 8672                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 35; #include "hucc-gfx.h"
 8673                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 36; #include "hucc-string.h"
 8674                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 37; #include "hucc-old-scroll.h"
 8675                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 38; #include "hucc-old-spr.h"
 8676                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 39; #include "hucc-old-map.h"
 8677                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 40; #include "hucc-old-line.h"
 8678                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 42; #endif // _hucc_legacy_h
 8679                        		.dbg	line,	"include\routines_SHOP.c", 2; #include "hucc-scroll.h"
 8680                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 1; #ifndef _hucc_scroll_h
 8681                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 2; #define _hucc_scroll_h
 8682                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 4; /****************************************************************************
 8683                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 5; ; ***************************************************************************
 8684                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 6; ;
 8685                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 7; ; hucc-scroll.h
 8686                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 8; ;
 8687                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 9; ; Routines for a fast split-screen scrolling system.
 8688                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 10; ;
 8689                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 11; ; Copyright John Brandwood 2024.
 8690                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 12; ;
 8691                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 13; ; Distributed under the Boost Software License, Version 1.0.
 8692                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 14; ; (See accompanying file LICENSE_1_0.txt or copy at
 8693                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 15; ;  http://www.boost.org/LICENSE_1_0.txt)
 8694                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 16; ;
 8695                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 17; ; ***************************************************************************
 8696                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 18; ; ***************************************************************************
 8697                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 19; ;
 8698                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 20; ; The maximum number of splits for each screen layer is set in your project's
 8699                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 21; ; "hucc-config.inc" file, with the library having a limit of 128-per-layer.
 8700                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 22; ;
 8701                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 23; ; Your first active split must be defined to start at screen line 0, and then
 8702                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 24; ; the rest of the active splits must be in increasing line order to match the
 8703                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 25; ; way that the PC Engine displays the output image.
 8704                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 26; ;
 8705                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 27; ; You can have disabled splits interleaved with your active splits.
 8706                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 28; ;
 8707                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 29; ; Splits that are normally disabled can be used to create full screen effects
 8708                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 30; ; such as bouncing the screen up and down by adding blank areas at the top or
 8709                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 31; ; bottom of the screen, and then rapidly changing the height of those areas.
 8710                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 32; ;
 8711                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 33; ; ***************************************************************************
 8712                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 34; ; **************************************************************************/
 8713                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 36; // *************
 8714                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 37; // VDC bits for display_flags ...
 8715                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 38; // *************
 8716                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 40; #ifndef BKG_OFF
 8717                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 41; #define BKG_OFF 0x00
 8718                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 42; #endif
 8719                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 44; #ifndef SPR_OFF
 8720                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 45; #define SPR_OFF 0x00
 8721                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 46; #endif
 8722                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 48; #ifndef BKG_ON
 8723                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 49; #define BKG_ON 0x80
 8724                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 50; #endif
 8725                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 52; #ifndef SPR_ON
 8726                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 53; #define SPR_ON 0x40
 8727                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 54; #endif
 8728                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 56; // *************
 8729                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 57; // Functions in hucc-scroll.asm ...
 8730                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 58; // *************
 8731                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 60; #ifdef __HUCC__
 8732                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 62; #asmdef	HUCC_USES_NEW_SCROLL 1
 8733                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 64; extern void __fastcall scroll_split( unsigned char index<_al>, unsigned char screen_line<_ah>, unsigned int bat_x<_bx>, unsigned int bat_y<_cx>, unsigned char display_flags<_dl> );
 8734                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 65; extern void __fastcall sgx_scroll_split( unsigned char index<_al>, unsigned char screen_line<_ah>, unsigned int bat_x<_bx>, unsigned int bat_y<_cx>, unsigned char display_flags<_dl> );
 8735                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 67; extern void __fastcall disable_split( unsigned char index<acc> );
 8736                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 68; extern void __fastcall sgx_disable_split( unsigned char index<acc> );
 8737                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 70; extern void __fastcall __macro disable_all_splits( void );
 8738                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 71; extern void __fastcall __macro sgx_disable_all_splits( void );
 8739                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 73; #asm
 8740                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 74; .macro	_disable_all_splits
 8741                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 75; ldy	#HUCC_PCE_SPLITS - 1
 8742                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 76; !loop:		tya
 8743                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 77; call	_disable_split.1
 8744                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 78; dey
 8745                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 79; bpl	!loop-
 8746                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 80; .endm
 8747                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 82; .macro	_sgx_disable_all_splits
 8748                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 83; ldy	#HUCC_SGX_SPLITS - 1
 8749                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 84; !loop:		tya
 8750                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 85; call	_sgx_disable_split.1
 8751                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 86; dey
 8752                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 87; bpl	!loop-
 8753                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 88; .endm
 8754                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 89; #endasm
 8755                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 91; #endif // __HUCC__
 8756                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 93; #endif // _hucc_scroll_h
 8757                        		.dbg	line,	"include\routines_SHOP.c", 3; #include "hucc-chrmap.h"
 8758                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 1; #ifndef _hucc_chrmap_h
 8759                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 2; #define _hucc_chrmap_h
 8760                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 4; /****************************************************************************
 8761                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 5; ; ***************************************************************************
 8762                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 6; ;
 8763                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 7; ; hucc-chrmap.h
 8764                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 8; ;
 8765                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 9; ; A simple map system based on 8x8 characters (aka "tiles") in BAT format.
 8766                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 10; ;
 8767                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 11; ; Copyright John Brandwood 2025.
 8768                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 12; ;
 8769                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 13; ; Distributed under the Boost Software License, Version 1.0.
 8770                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 14; ; (See accompanying file LICENSE_1_0.txt or copy at
 8771                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 15; ;  http://www.boost.org/LICENSE_1_0.txt)
 8772                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 16; ;
 8773                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 17; ; ***************************************************************************
 8774                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 18; ; ***************************************************************************
 8775                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 19; ;
 8776                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 20; ; The maximum X and Y size for chrmaps is 256 characters (2048 pixels).
 8777                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 21; ;
 8778                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 22; ; The maximum total size for a chrmap is 16KBytes, which allows for maps up
 8779                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 23; ; to 256x32 tiles (2048x256 pixels).
 8780                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 24; ;
 8781                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 25; ; ***************************************************************************
 8782                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 26; ; **************************************************************************/
 8783                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 28; // *************
 8784                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 29; // This code extends the blkmap library ...
 8785                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 30; // *************
 8786                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 32; #include "hucc-blkmap.h"
 8787                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 34; // *************
 8788                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 35; // Functions in chrmap.asm ...
 8789                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 36; // *************
 8790                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 38; #ifdef __HUCC__
 8791                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 40; #asmdef	HUCC_USES_CHRMAP 1
 8792                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 42; extern void __fastcall __nop set_chrmap( unsigned char __far *chrmap<vdc_map_bank:vdc_map_addr>, unsigned char tiles_w<vdc_map_line_w> );
 8793                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 44; extern void __fastcall draw_bat( void );
 8794                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 45; extern void __fastcall scroll_bat( void );
 8795                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 47; extern void __fastcall blit_bat( unsigned char tile_x<map_bat_x>, unsigned char tile_y<map_bat_y>, unsigned char tile_w<map_draw_x>, unsigned char tile_h<map_draw_y> );
 8796                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 49; #ifdef _SGX
 8797                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 51; extern void __fastcall __nop sgx_set_chrmap( unsigned char __far *chrmap<sgx_map_bank:sgx_map_addr>, unsigned char tiles_w<sgx_map_line_w> );
 8798                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 53; extern void __fastcall sgx_draw_bat( void );
 8799                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 54; extern void __fastcall sgx_scroll_bat( void );
 8800                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 56; extern void __fastcall sgx_blit_bat( unsigned char tile_x<map_bat_x>, unsigned char tile_y<map_bat_y>, unsigned char tile_w<map_draw_x>, unsigned char tile_h<map_draw_y> );
 8801                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 58; #endif
 8802                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 60; #endif // __HUCC__
 8803                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 62; #endif // _hucc_chrmap_h
 8804                        		.dbg	line,	"include\routines_SHOP.c", 4; #include "hucc-blkmap.h"
 8805                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 1; #ifndef _hucc_blkmap_h
 8806                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 2; #define _hucc_blkmap_h
 8807                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 4; /****************************************************************************
 8808                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 5; ; ***************************************************************************
 8809                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 6; ;
 8810                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 7; ; hucc-blkmap.h
 8811                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 8; ;
 8812                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 9; ; A map system based on 16x16 meta-tiles (aka "blocks", aka CHR/BLK/MAP).
 8813                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 10; ;
 8814                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 11; ; Copyright John Brandwood 2025.
 8815                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 12; ;
 8816                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 13; ; Distributed under the Boost Software License, Version 1.0.
 8817                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 14; ; (See accompanying file LICENSE_1_0.txt or copy at
 8818                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 15; ;  http://www.boost.org/LICENSE_1_0.txt)
 8819                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 16; ;
 8820                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 17; ; ***************************************************************************
 8821                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 18; ; ***************************************************************************
 8822                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 19; ;
 8823                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 20; ; The maximum X and Y size for blkmaps is 128 blocks (2048 pixels).
 8824                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 21; ;
 8825                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 22; ; The maximum total size for a blkmap is 16KBytes, which allows for maps up
 8826                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 23; ; to 128x128 blocks (2048x2048 pixels).
 8827                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 24; ;
 8828                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 25; ; Huge multi-screen blkmaps are also supported (optionally).
 8829                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 26; ;
 8830                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 27; ; The maximum X and Y for multi-screen maps is 128 screens (32768 pixels).
 8831                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 28; ;
 8832                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 29; ; The maximum total size for a multi-screen map is 8KBytes, which allows for
 8833                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 30; ; a total of 1024 screens.
 8834                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 31; ;
 8835                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 32; ; ***************************************************************************
 8836                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 33; ; **************************************************************************/
 8837                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 35; // *************
 8838                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 36; // Functions in blkmap.asm ...
 8839                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 37; // *************
 8840                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 39; #ifdef __HUCC__
 8841                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 41; #asmdef	HUCC_USES_BLKMAP 1
 8842                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 43; // Current top-left of drawn map in pixels.
 8843                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 44; extern unsigned int   vdc_map_pxl_x;
 8844                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 45; extern unsigned int   vdc_map_pxl_y;
 8845                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 47; // Width and height to draw/scroll in characters (not tiles).
 8846                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 48; extern unsigned char  vdc_map_draw_w;
 8847                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 49; extern unsigned char  vdc_map_draw_h;
 8848                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 51; // Width of map (or multi-screen BAT) in tiles.
 8849                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 52; extern unsigned char  vdc_map_line_w;
 8850                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 54; // Width of map in screens (if multi-screen map).
 8851                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 55; extern unsigned char  vdc_map_scrn_w;
 8852                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 57; // Extra information returned by get_map_block() and sgx_get_map_block(),
 8853                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 58; // which are the collision flags and the mask/overlay sprite for the BLK.
 8854                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 59; extern unsigned char  map_blk_flag;
 8855                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 60; extern unsigned char  map_blk_mask;
 8856                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 62; extern unsigned char  vdc_scr_bank;
 8857                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 63; extern unsigned char *vdc_scr_addr;
 8858                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 65; extern unsigned char  vdc_map_bank;
 8859                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 66; extern unsigned char *vdc_map_addr;
 8860                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 68; extern unsigned char  vdc_blk_bank;
 8861                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 69; extern unsigned char *vdc_blk_addr;
 8862                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 71; extern unsigned char  vdc_tbl_bank;
 8863                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 72; extern unsigned char *vdc_tbl_addr;
 8864                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 74; extern void __fastcall set_blocks( unsigned char __far *blk_def<vdc_blk_bank:vdc_blk_addr>, unsigned char __far *flg_def<vdc_tbl_bank:vdc_tbl_addr>, unsigned char number_of_blocks<_al> );
 8865                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 75; extern void __fastcall __macro set_blkmap( unsigned char __far *blk_map<vdc_map_bank:vdc_map_addr>, unsigned char blocks_w<vdc_map_line_w> );
 8866                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 76; extern void __fastcall __macro set_multimap( unsigned char __far *multi_map<vdc_scr_bank:vdc_scr_addr>, unsigned char screens_w<vdc_map_scrn_w> );
 8867                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 78; extern void __fastcall draw_map( void );
 8868                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 79; extern void __fastcall scroll_map( void );
 8869                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 81; extern void __fastcall blit_map( unsigned char tile_x<map_bat_x>, unsigned char tile_y<map_bat_y>, unsigned char tile_w<map_draw_x>, unsigned char tile_h<map_draw_y> );
 8870                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 83; extern unsigned char __fastcall get_map_block( unsigned int x<map_pxl_x>, unsigned int y<map_pxl_y> );
 8871                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 85; #asm
 8872                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 86; .macro	_set_blkmap.2
 8873                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 87; stz	vdc_scr_bank
 8874                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 88; .endm
 8875                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 90; .macro	_set_multimap.2
 8876                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 91; lda	vdc_bat_width
 8877                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 92; lsr	a
 8878                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 93; sta	vdc_map_line_w
 8879                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 94; .endm
 8880                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 96; .macro	SCREEN
 8881                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 97; db	(((\1) & $1FFF) | $6000) >> 8, bank(\1)
 8882                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 98; db	(((\2) & $1FFF) | $4000) >> 8, bank(\2)
 8883                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 99; db	(((\3) & $1FFF) | $6000) >> 8, bank(\3)
 8884                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 100; dw	(\4)
 8885                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 101; .endm
 8886                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 102; #endasm
 8887                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 104; #ifdef _SGX
 8888                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 106; // Current top-left of drawn map in pixels.
 8889                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 107; extern unsigned int   sgx_map_pxl_x;
 8890                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 108; extern unsigned int   sgx_map_pxl_y;
 8891                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 110; // Width and height to draw/scroll in characters (not tiles).
 8892                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 111; extern unsigned char  sgx_map_draw_w;
 8893                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 112; extern unsigned char  sgx_map_draw_h;
 8894                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 114; // Width of map (or multi-screen BAT) in tiles.
 8895                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 115; extern unsigned char  sgx_map_line_w;
 8896                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 117; // Width of map in screens (if multi-screen map).
 8897                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 118; extern unsigned char  sgx_map_scrn_w;
 8898                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 120; extern unsigned char  sgx_scr_bank;
 8899                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 121; extern unsigned char *sgx_scr_addr;
 8900                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 123; extern unsigned char  sgx_map_bank;
 8901                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 124; extern unsigned char *sgx_map_addr;
 8902                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 126; extern unsigned char  sgx_blk_bank;
 8903                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 127; extern unsigned char *sgx_blk_addr;
 8904                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 129; extern unsigned char  sgx_tbl_bank;
 8905                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 130; extern unsigned char *sgx_tbl_addr;
 8906                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 132; extern void __fastcall sgx_set_blocks( unsigned char __far *blk_def<sgx_blk_bank:sgx_blk_addr>, unsigned char __far *flg_def<sgx_tbl_bank:sgx_tbl_addr>, unsigned char number_of_blocks<_al> );
 8907                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 133; extern void __fastcall __macro sgx_set_blkmap( unsigned char __far *blk_map<sgx_map_bank:sgx_map_addr>, unsigned char blocks_w<sgx_map_line_w> );
 8908                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 134; extern void __fastcall __macro sgx_set_multimap( unsigned char __far *multi_map<sgx_scr_bank:sgx_scr_addr>, unsigned char screens_w<sgx_map_scrn_w> );
 8909                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 136; extern void __fastcall sgx_draw_map( void );
 8910                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 137; extern void __fastcall sgx_scroll_map( void );
 8911                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 139; extern void __fastcall sgx_blit_map( unsigned char tile_x<map_bat_x>, unsigned char tile_y<map_bat_y>, unsigned char tile_w<map_draw_x>, unsigned char tile_h<map_draw_y> );
 8912                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 141; extern unsigned char __fastcall sgx_get_map_block( unsigned int x<map_pxl_x>, unsigned int y<map_pxl_y> );
 8913                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 143; #asm
 8914                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 144; .macro	_sgx_set_blkmap.2
 8915                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 145; stz	sgx_scr_bank
 8916                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 146; .endm
 8917                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 148; .macro	_sgx_set_multimap.2
 8918                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 149; lda	sgx_bat_width
 8919                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 150; lsr	a
 8920                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 151; sta	sgx_map_line_w
 8921                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 152; .endm
 8922                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 153; #endasm
 8923                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 155; #endif
 8924                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 157; #endif // __HUCC__
 8925                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 159; #endif // _hucc_blkmap_h
 8926                        		.dbg	line,	"include\routines_SHOP.c", 12; void display_TIME_SHOP()
 8927                        		.dbg	line,	"include\routines_SHOP.c", 13; {
 8928                        	;***********************
 8929                        	;***********************
 8930                        	
 8931                        		.hucc
 8932    11:CD71             		.proc		_display_TIME_SHOP
 8933                        		__enter		_display_TIME_SHOP
 8934                        	
 8935                        		.dbg	line,	"include\routines_SHOP.c", 14; put_number(minutes,1,1,3);
 8936                        		__ld.um		_minutes
         11:CD71  AD 23 23   			lda	_minutes
         11:CD74  C2         			cly
 8937                        		__st.wmq	_bx
         11:CD75  85 FA      			sta.l	_bx
         11:CD77  84 FB      			sty.h	_bx
 8938                        		__st.umiq	1, _cl
         11:CD79  A9 01      			lda.l	#1
         11:CD7B  85 FC      			sta	_cl
 8939                        		__st.umiq	1, _dil
         11:CD7D  A9 01      			lda.l	#1
         11:CD7F  85 F0      			sta	_dil
 8940                        		__st.umiq	3, _dih
         11:CD81  A9 03      			lda.l	#3
         11:CD83  85 F1      			sta	_dih
 8941                        		__call		_put_number.4
         11:CD85  20 9F FF   			call	_put_number.4
 8942                        	
 8943                        		.dbg	line,	"include\routines_SHOP.c", 16; if(seconds < 10)
 8944                        		__ld.umq	_seconds
         11:CD88  AD 24 23   			lda	_seconds
 8945                        		__ult_b.uiq	10
         11:CD8B  C9 0A      			cmp	#10		; Subtract integer from A.
         11:CD8D  6A         			ror	a		; CC if A < integer.
         11:CD8E  49 80      			eor	#$80
         11:CD90  2A         			rol	a
 8946                        		__bfalse	.LL379
         11:CD91  90 2C      			bcc	.LL379
 8947                        	
 8948                        		.dbg	line,	"include\routines_SHOP.c", 17; {
 8949                        	
 8950                        		.dbg	line,	"include\routines_SHOP.c", 18; put_number(0,1,3,3);
 8951                        		__st.wmiq	0, _bx
         11:CD93  64 FA      			stz.l	_bx
         11:CD95  64 FB      			stz.h	_bx
 8952                        		__st.umiq	1, _cl
         11:CD97  A9 01      			lda.l	#1
         11:CD99  85 FC      			sta	_cl
 8953                        		__st.umiq	3, _dil
         11:CD9B  A9 03      			lda.l	#3
         11:CD9D  85 F0      			sta	_dil
 8954                        		__st.umiq	3, _dih
         11:CD9F  A9 03      			lda.l	#3
         11:CDA1  85 F1      			sta	_dih
 8955                        		__call		_put_number.4
         11:CDA3  20 9F FF   			call	_put_number.4
 8956                        	
 8957                        		.dbg	line,	"include\routines_SHOP.c", 19; put_number(seconds,1,4,3);
 8958                        		__ld.um		_seconds
         11:CDA6  AD 24 23   			lda	_seconds
         11:CDA9  C2         			cly
 8959                        		__st.wmq	_bx
         11:CDAA  85 FA      			sta.l	_bx
         11:CDAC  84 FB      			sty.h	_bx
 8960                        		__st.umiq	1, _cl
         11:CDAE  A9 01      			lda.l	#1
         11:CDB0  85 FC      			sta	_cl
 8961                        		__st.umiq	4, _dil
         11:CDB2  A9 04      			lda.l	#4
         11:CDB4  85 F0      			sta	_dil
 8962                        		__st.umiq	3, _dih
         11:CDB6  A9 03      			lda.l	#3
         11:CDB8  85 F1      			sta	_dih
 8963                        		__call		_put_number.4
         11:CDBA  20 9F FF   			call	_put_number.4
 8964                        	
 8965                        		.dbg	line,	"include\routines_SHOP.c", 20; }
 8966                        	
 8967                        		.dbg	line,	"include\routines_SHOP.c", 22; else
 8968                        		__bra		.LL380
         11:CDBD  80 17      			bra	.LL380
 8969    11:CDBF             	.LL379:
 8970                        	
 8971                        		.dbg	line,	"include\routines_SHOP.c", 23; {
 8972                        	
 8973                        		.dbg	line,	"include\routines_SHOP.c", 24; put_number(seconds,2,3,3);
 8974                        		__ld.um		_seconds
         11:CDBF  AD 24 23   			lda	_seconds
         11:CDC2  C2         			cly
 8975                        		__st.wmq	_bx
         11:CDC3  85 FA      			sta.l	_bx
         11:CDC5  84 FB      			sty.h	_bx
 8976                        		__st.umiq	2, _cl
         11:CDC7  A9 02      			lda.l	#2
         11:CDC9  85 FC      			sta	_cl
 8977                        		__st.umiq	3, _dil
         11:CDCB  A9 03      			lda.l	#3
         11:CDCD  85 F0      			sta	_dil
 8978                        		__st.umiq	3, _dih
         11:CDCF  A9 03      			lda.l	#3
         11:CDD1  85 F1      			sta	_dih
 8979                        		__call		_put_number.4
         11:CDD3  20 9F FF   			call	_put_number.4
 8980                        	
 8981                        		.dbg	line,	"include\routines_SHOP.c", 25; }
 8982    11:CDD6             	.LL380:
 8983                        	
 8984                        		.dbg	line,	"include\routines_SHOP.c", 27; time_counter += 1;
 8985                        		__add_st.umiq	1, _time_counter
         11:CDD6  EE 25 23   			inc	_time_counter
 8986                        	
 8987                        		.dbg	line,	"include\routines_SHOP.c", 29; if(time_counter == 60)
 8988                        		__ld.umq	_time_counter
         11:CDD9  AD 25 23   			lda	_time_counter
 8989                        		__equ_b.uiq	60
         11:CDDC  C9 3C      			cmp	#60
         11:CDDE  F0 01      			beq	!+
         11:CDE0  18         			clc
         11:CDE1             	!:
 8990                        		__bfalse	.LL381
         11:CDE1  90 30      			bcc	.LL381
 8991                        	
 8992                        		.dbg	line,	"include\routines_SHOP.c", 30; {
 8993                        	
 8994                        		.dbg	line,	"include\routines_SHOP.c", 31; time_counter = 0;
 8995                        		__st.umiq	0, _time_counter
         11:CDE3  9C 25 23   			stz	_time_counter
 8996                        	
 8997                        		.dbg	line,	"include\routines_SHOP.c", 33; if(seconds > 0)
 8998                        		__ld.umq	_seconds
         11:CDE6  AD 24 23   			lda	_seconds
 8999                        		__ugt_b.uiq	0
         11:CDE9  18         			clc			; Subtract integer+1 from A.
         11:CDEA  E9 00      			sbc	#0		; CS if A > integer.
 9000                        		__bfalse	.LL382
         11:CDEC  90 05      			bcc	.LL382
 9001                        	
 9002                        		.dbg	line,	"include\routines_SHOP.c", 34; {
 9003                        	
 9004                        		.dbg	line,	"include\routines_SHOP.c", 35; seconds -= 1;
 9005                        		__sub_st.umiq	1, _seconds
         11:CDEE  CE 24 23   			dec	_seconds
 9006                        	
 9007                        		.dbg	line,	"include\routines_SHOP.c", 36; }
 9008                        	
 9009                        		.dbg	line,	"include\routines_SHOP.c", 38; else
 9010                        		__bra		.LL383
         11:CDF1  80 20      			bra	.LL383
 9011    11:CDF3             	.LL382:
 9012                        	
 9013                        		.dbg	line,	"include\routines_SHOP.c", 39; {
 9014                        	
 9015                        		.dbg	line,	"include\routines_SHOP.c", 40; if(minutes > 0)
 9016                        		__ld.umq	_minutes
         11:CDF3  AD 23 23   			lda	_minutes
 9017                        		__ugt_b.uiq	0
         11:CDF6  18         			clc			; Subtract integer+1 from A.
         11:CDF7  E9 00      			sbc	#0		; CS if A > integer.
 9018                        		__bfalse	.LL384
         11:CDF9  90 0A      			bcc	.LL384
 9019                        	
 9020                        		.dbg	line,	"include\routines_SHOP.c", 41; {
 9021                        	
 9022                        		.dbg	line,	"include\routines_SHOP.c", 42; seconds = 59;
 9023                        		__st.umiq	59, _seconds
         11:CDFB  A9 3B      			lda.l	#59
         11:CDFD  8D 24 23   			sta	_seconds
 9024                        	
 9025                        		.dbg	line,	"include\routines_SHOP.c", 43; minutes -= 1;
 9026                        		__sub_st.umiq	1, _minutes
         11:CE00  CE 23 23   			dec	_minutes
 9027                        	
 9028                        		.dbg	line,	"include\routines_SHOP.c", 44; }
 9029                        	
 9030                        		.dbg	line,	"include\routines_SHOP.c", 46; else
 9031                        		__bra		.LL385
         11:CE03  80 0E      			bra	.LL385
 9032    11:CE05             	.LL384:
 9033                        	
 9034                        		.dbg	line,	"include\routines_SHOP.c", 47; {
 9035                        	
 9036                        		.dbg	line,	"include\routines_SHOP.c", 48; seconds = 0;
 9037                        		__st.umiq	0, _seconds
         11:CE05  9C 24 23   			stz	_seconds
 9038                        	
 9039                        		.dbg	line,	"include\routines_SHOP.c", 49; minutes = 0;
 9040                        		__st.umiq	0, _minutes
         11:CE08  9C 23 23   			stz	_minutes
 9041                        	
 9042                        		.dbg	line,	"include\routines_SHOP.c", 50; shop_counter = 0;    
 9043                        		__st.umiq	0, _shop_counter
         11:CE0B  9C CC 23   			stz	_shop_counter
 9044                        	
 9045                        		.dbg	line,	"include\routines_SHOP.c", 51; shop_phase = SHOP_PHASE_EXIT;
 9046                        		__st.umiq	2, _shop_phase
         11:CE0E  A9 02      			lda.l	#2
         11:CE10  8D CB 23   			sta	_shop_phase
 9047                        	
 9048                        		.dbg	line,	"include\routines_SHOP.c", 52; }
 9049    11:CE13             	.LL385:
 9050                        	
 9051                        		.dbg	line,	"include\routines_SHOP.c", 53; }
 9052    11:CE13             	.LL383:
 9053                        	
 9054                        		.dbg	line,	"include\routines_SHOP.c", 54; } 
 9055                        	
 9056                        		.dbg	line,	"include\routines_SHOP.c", 55; }
 9057    11:CE13             	.LL381:
 9058    11:CE13             	.LL378:
 9059                        		__return	0
         11:CE13  4C EF FF   			jmp	leave_proc
 9060                        		.dbg	clear
 9061                        		.endp
 9062                        		.pceas
 9063                        	
 9064                        		.dbg	line,	"include\routines_SHOP.c", 59; void joypad_BUTTONS_SHOP()
 9065                        		.dbg	line,	"include\routines_SHOP.c", 60; {
 9066                        	;***********************
 9067                        	;***********************
 9068                        	
 9069                        		.hucc
 9070    01:D8A1             		.proc		_joypad_BUTTONS_SHOP
 9071                        		__enter		_joypad_BUTTONS_SHOP
 9072                        	
 9073                        		.dbg	line,	"include\routines_SHOP.c", 61; if(joytrg(JOYPAD_1) & JOY_RIGHT)
 9074                        		__ld.uiq	0
         01:D8A1  62         			cla
 9075                        		 _joytrg.1
         01:D8A2  AA         			tax
         01:D8A3  BD 2D 22   			lda	joytrg, x
         01:D8A6  BC DD 22   			ldy	joy6trg, x
 9076                        		__tand.wi	32
         01:D8A9  29 20      			and	#32
         01:D8AB  C9 01      	!:		cmp	#1
 9077                        		__bfalse	.LL387
         01:D8AD  90 59      			bcc	.LL387
 9078                        	
 9079                        		.dbg	line,	"include\routines_SHOP.c", 62; {   
 9080                        	
 9081                        		.dbg	line,	"include\routines_SHOP.c", 63; char max_index;
 9082                        	
 9083                        		.dbg	line,	"include\routines_SHOP.c", 64; 
 9084                        	
 9085                        		.dbg	line,	"include\routines_SHOP.c", 65; if(index_y == 0)
 9086                        		__not.um	_index_y
         01:D8AF  AD C9 23   			lda	_index_y
         01:D8B2  18         			clc
         01:D8B3  D0 01      			bne	!+
         01:D8B5  38         			sec
         01:D8B6             	!:
 9087                        		__bfalse	.LL388
         01:D8B6  90 07      			bcc	.LL388
 9088                        	
 9089                        		.dbg	line,	"include\routines_SHOP.c", 66; {
 9090                        	
 9091                        		.dbg	line,	"include\routines_SHOP.c", 67; max_index = 4;
 9092                        		__st.umiq	4, __joypad_BUTTONS_SHOP_end - 1  /* max_index */
         01:D8B8  A9 04      			lda.l	#4
         01:D8BA  8D 0D 23   			sta	__joypad_BUTTONS_SHOP_end - 1
 9093                        	
 9094                        		.dbg	line,	"include\routines_SHOP.c", 68; }
 9095                        	
 9096                        		.dbg	line,	"include\routines_SHOP.c", 70; else
 9097                        		__bra		.LL389
         01:D8BD  80 05      			bra	.LL389
 9098    01:D8BF             	.LL388:
 9099                        	
 9100                        		.dbg	line,	"include\routines_SHOP.c", 71; {
 9101                        	
 9102                        		.dbg	line,	"include\routines_SHOP.c", 72; max_index = 5;
 9103                        		__st.umiq	5, __joypad_BUTTONS_SHOP_end - 1  /* max_index */
         01:D8BF  A9 05      			lda.l	#5
         01:D8C1  8D 0D 23   			sta	__joypad_BUTTONS_SHOP_end - 1
 9104                        	
 9105                        		.dbg	line,	"include\routines_SHOP.c", 73; }
 9106    01:D8C4             	.LL389:
 9107                        	
 9108                        		.dbg	line,	"include\routines_SHOP.c", 75; if(index_x < max_index)
 9109                        		__ld.umq	_index_x
         01:D8C4  AD C8 23   			lda	_index_x
 9110                        		__ult_b.umq	__joypad_BUTTONS_SHOP_end - 1  /* max_index */
         01:D8C7  CD 0D 23   			cmp	__joypad_BUTTONS_SHOP_end - 1		; Subtract memory from A.
         01:D8CA  6A         			ror	a		; CC if A < memory.
         01:D8CB  49 80      			eor	#$80
         01:D8CD  2A         			rol	a
 9111                        		__bfalse	.LL390
         01:D8CE  B0 03 4C 1E			bcc	.LL390
         01:D8D2  DE          
 9112                        	
 9113                        		.dbg	line,	"include\routines_SHOP.c", 76; {
 9114                        	
 9115                        		.dbg	line,	"include\routines_SHOP.c", 77; index_x += 1;
 9116                        		__add_st.umiq	1, _index_x
         01:D8D3  EE C8 23   			inc	_index_x
 9117                        	
 9118                        		.dbg	line,	"include\routines_SHOP.c", 78; item_index = (index_x + (index_y * 5));
 9119                        		__ld.um		_index_y
         01:D8D6  AD C9 23   			lda	_index_y
         01:D8D9  C2         			cly
 9120                        		__mul.wi	5
         01:D8DA  85 00      			sta.l	__temp
         01:D8DC  84 01      			sty.h	__temp
                             		__asl.wr
         01:D8DE  0A         			asl	a
         01:D8DF  42         			say
         01:D8E0  2A         			rol	a
         01:D8E1  42         			say
                             		__asl.wr
         01:D8E2  0A         			asl	a
         01:D8E3  42         			say
         01:D8E4  2A         			rol	a
         01:D8E5  42         			say
                             		__add.wm	__temp
         01:D8E6  18         			clc
         01:D8E7  65 00      			adc.l	__temp
         01:D8E9  42         			say
         01:D8EA  65 01      			adc.h	__temp
         01:D8EC  42         			say
 9121                        		__add.um	_index_x
         01:D8ED  18         			clc
         01:D8EE  6D C8 23   			adc	_index_x
         01:D8F1  90 01      			bcc	!+
         01:D8F3  C8         			iny
         01:D8F4             	!:
 9122                        		__st.umq	_item_index
         01:D8F4  8D CA 23   			sta	_item_index
 9123                        	
 9124                        		.dbg	line,	"include\routines_SHOP.c", 80; spr_set(0);
 9125                        		__ld.uiq	0
         01:D8F7  62         			cla
 9126                        		__call		_spr_set.1
         01:D8F8  20 DD E7   			call	_spr_set.1
 9127                        	
 9128                        		.dbg	line,	"include\routines_SHOP.c", 81; spr_x(TABLE_CURSOR_POS_X[item_index]);
 9129                        		__ldx.umq	_item_index
         01:D8FB  AE CA 23   			ldx	_item_index
 9130                        		__ld.uax	_TABLE_CURSOR_POS_X
         01:D8FE  BD 8B 61   			lda	_TABLE_CURSOR_POS_X, x
         01:D901  C2         			cly
 9131                        		__call		_spr_x.1
         01:D902  20 0A E8   			call	_spr_x.1
 9132                        	
 9133                        		.dbg	line,	"include\routines_SHOP.c", 82; }
 9134                        	
 9135                        		.dbg	line,	"include\routines_SHOP.c", 83; }
 9136    01:D905             	.LL390	.alias		.LL391
 9137                        	
 9138                        		.dbg	line,	"include\routines_SHOP.c", 85; 
 9139                        	
 9140                        		.dbg	line,	"include\routines_SHOP.c", 86; else if(joytrg(JOYPAD_1) & JOY_LEFT)
 9141                        		__bra		.LL391
         01:D905  4C 1E DE   			bra	.LL391
 9142    01:D908             	.LL387:
 9143                        		__ld.uiq	0
         01:D908  62         			cla
 9144                        		 _joytrg.1
         01:D909  AA         			tax
         01:D90A  BD 2D 22   			lda	joytrg, x
         01:D90D  BC DD 22   			ldy	joy6trg, x
 9145                        		__tand.wi	128
         01:D910  29 80      			and	#128
         01:D912  C9 01      	!:		cmp	#1
 9146                        		__bfalse	.LL392
         01:D914  90 40      			bcc	.LL392
 9147                        	
 9148                        		.dbg	line,	"include\routines_SHOP.c", 87; {
 9149                        	
 9150                        		.dbg	line,	"include\routines_SHOP.c", 88; if(index_x > 0)
 9151                        		__ld.umq	_index_x
         01:D916  AD C8 23   			lda	_index_x
 9152                        		__ugt_b.uiq	0
         01:D919  18         			clc			; Subtract integer+1 from A.
         01:D91A  E9 00      			sbc	#0		; CS if A > integer.
 9153                        		__bfalse	.LL393
         01:D91C  B0 03 4C 1E			bcc	.LL393
         01:D920  DE          
 9154                        	
 9155                        		.dbg	line,	"include\routines_SHOP.c", 89; {
 9156                        	
 9157                        		.dbg	line,	"include\routines_SHOP.c", 90; index_x -= 1;
 9158                        		__sub_st.umiq	1, _index_x
         01:D921  CE C8 23   			dec	_index_x
 9159                        	
 9160                        		.dbg	line,	"include\routines_SHOP.c", 91; item_index = (index_x + (index_y * 5));
 9161                        		__ld.um		_index_y
         01:D924  AD C9 23   			lda	_index_y
         01:D927  C2         			cly
 9162                        		__mul.wi	5
         01:D928  85 00      			sta.l	__temp
         01:D92A  84 01      			sty.h	__temp
                             		__asl.wr
         01:D92C  0A         			asl	a
         01:D92D  42         			say
         01:D92E  2A         			rol	a
         01:D92F  42         			say
                             		__asl.wr
         01:D930  0A         			asl	a
         01:D931  42         			say
         01:D932  2A         			rol	a
         01:D933  42         			say
                             		__add.wm	__temp
         01:D934  18         			clc
         01:D935  65 00      			adc.l	__temp
         01:D937  42         			say
         01:D938  65 01      			adc.h	__temp
         01:D93A  42         			say
 9163                        		__add.um	_index_x
         01:D93B  18         			clc
         01:D93C  6D C8 23   			adc	_index_x
         01:D93F  90 01      			bcc	!+
         01:D941  C8         			iny
         01:D942             	!:
 9164                        		__st.umq	_item_index
         01:D942  8D CA 23   			sta	_item_index
 9165                        	
 9166                        		.dbg	line,	"include\routines_SHOP.c", 93; spr_set(0);
 9167                        		__ld.uiq	0
         01:D945  62         			cla
 9168                        		__call		_spr_set.1
         01:D946  20 DD E7   			call	_spr_set.1
 9169                        	
 9170                        		.dbg	line,	"include\routines_SHOP.c", 94; spr_x(TABLE_CURSOR_POS_X[item_index]);
 9171                        		__ldx.umq	_item_index
         01:D949  AE CA 23   			ldx	_item_index
 9172                        		__ld.uax	_TABLE_CURSOR_POS_X
         01:D94C  BD 8B 61   			lda	_TABLE_CURSOR_POS_X, x
         01:D94F  C2         			cly
 9173                        		__call		_spr_x.1
         01:D950  20 0A E8   			call	_spr_x.1
 9174                        	
 9175                        		.dbg	line,	"include\routines_SHOP.c", 95; }
 9176                        	
 9177                        		.dbg	line,	"include\routines_SHOP.c", 96; }
 9178    01:D953             	.LL393	.alias		.LL394
 9179                        	
 9180                        		.dbg	line,	"include\routines_SHOP.c", 99; else if(joytrg(JOYPAD_1) & JOY_UP)
 9181                        		__bra		.LL394
         01:D953  4C 1E DE   			bra	.LL394
 9182    01:D956             	.LL392:
 9183                        		__ld.uiq	0
         01:D956  62         			cla
 9184                        		 _joytrg.1
         01:D957  AA         			tax
         01:D958  BD 2D 22   			lda	joytrg, x
         01:D95B  BC DD 22   			ldy	joy6trg, x
 9185                        		__tand.wi	16
         01:D95E  29 10      			and	#16
         01:D960  C9 01      	!:		cmp	#1
 9186                        		__bfalse	.LL395
         01:D962  90 4A      			bcc	.LL395
 9187                        	
 9188                        		.dbg	line,	"include\routines_SHOP.c", 100; {
 9189                        	
 9190                        		.dbg	line,	"include\routines_SHOP.c", 101; if(index_y > 0)
 9191                        		__ld.umq	_index_y
         01:D964  AD C9 23   			lda	_index_y
 9192                        		__ugt_b.uiq	0
         01:D967  18         			clc			; Subtract integer+1 from A.
         01:D968  E9 00      			sbc	#0		; CS if A > integer.
 9193                        		__bfalse	.LL396
         01:D96A  B0 03 4C 1E			bcc	.LL396
         01:D96E  DE          
 9194                        	
 9195                        		.dbg	line,	"include\routines_SHOP.c", 102; {
 9196                        	
 9197                        		.dbg	line,	"include\routines_SHOP.c", 103; if(item_index != 10)
 9198                        		__ld.umq	_item_index
         01:D96F  AD CA 23   			lda	_item_index
 9199                        		__neq_b.uiq	10
         01:D972  38         			sec
         01:D973  49 0A      			eor	#10
         01:D975  D0 01      			bne	!+
         01:D977  18         			clc
         01:D978             	!:
 9200                        		__bfalse	.LL397
         01:D978  B0 03 4C 1E			bcc	.LL397
         01:D97C  DE          
 9201                        	
 9202                        		.dbg	line,	"include\routines_SHOP.c", 104; {
 9203                        	
 9204                        		.dbg	line,	"include\routines_SHOP.c", 105; index_y -= 1;
 9205                        		__sub_st.umiq	1, _index_y
         01:D97D  CE C9 23   			dec	_index_y
 9206                        	
 9207                        		.dbg	line,	"include\routines_SHOP.c", 106; item_index = (index_x + (index_y * 5));
 9208                        		__ld.um		_index_y
         01:D980  AD C9 23   			lda	_index_y
         01:D983  C2         			cly
 9209                        		__mul.wi	5
         01:D984  85 00      			sta.l	__temp
         01:D986  84 01      			sty.h	__temp
                             		__asl.wr
         01:D988  0A         			asl	a
         01:D989  42         			say
         01:D98A  2A         			rol	a
         01:D98B  42         			say
                             		__asl.wr
         01:D98C  0A         			asl	a
         01:D98D  42         			say
         01:D98E  2A         			rol	a
         01:D98F  42         			say
                             		__add.wm	__temp
         01:D990  18         			clc
         01:D991  65 00      			adc.l	__temp
         01:D993  42         			say
         01:D994  65 01      			adc.h	__temp
         01:D996  42         			say
 9210                        		__add.um	_index_x
         01:D997  18         			clc
         01:D998  6D C8 23   			adc	_index_x
         01:D99B  90 01      			bcc	!+
         01:D99D  C8         			iny
         01:D99E             	!:
 9211                        		__st.umq	_item_index
         01:D99E  8D CA 23   			sta	_item_index
 9212                        	
 9213                        		.dbg	line,	"include\routines_SHOP.c", 108; spr_set(0);
 9214                        		__ld.uiq	0
         01:D9A1  62         			cla
 9215                        		__call		_spr_set.1
         01:D9A2  20 DD E7   			call	_spr_set.1
 9216                        	
 9217                        		.dbg	line,	"include\routines_SHOP.c", 109; spr_y(144);
 9218                        		__ld.wi		144
         01:D9A5  A9 90      			lda.l	#144
         01:D9A7  C2         			cly
 9219                        		__call		_spr_y.1
         01:D9A8  20 19 E8   			call	_spr_y.1
 9220                        	
 9221                        		.dbg	line,	"include\routines_SHOP.c", 110; }
 9222                        	
 9223                        		.dbg	line,	"include\routines_SHOP.c", 111; }
 9224    01:D9AB             	.LL397	.alias		.LL398
 9225                        	
 9226                        		.dbg	line,	"include\routines_SHOP.c", 112; }
 9227    01:D9AB             	.LL396	.alias		.LL398
 9228                        	
 9229                        		.dbg	line,	"include\routines_SHOP.c", 115; else if(joytrg(JOYPAD_1) & JOY_DOWN)
 9230                        		__bra		.LL398
         01:D9AB  4C 1E DE   			bra	.LL398
 9231    01:D9AE             	.LL395:
 9232                        		__ld.uiq	0
         01:D9AE  62         			cla
 9233                        		 _joytrg.1
         01:D9AF  AA         			tax
         01:D9B0  BD 2D 22   			lda	joytrg, x
         01:D9B3  BC DD 22   			ldy	joy6trg, x
 9234                        		__tand.wi	64
         01:D9B6  29 40      			and	#64
         01:D9B8  C9 01      	!:		cmp	#1
 9235                        		__bfalse	.LL399
         01:D9BA  90 3F      			bcc	.LL399
 9236                        	
 9237                        		.dbg	line,	"include\routines_SHOP.c", 116; {
 9238                        	
 9239                        		.dbg	line,	"include\routines_SHOP.c", 117; if(index_y < 1)
 9240                        		__ld.umq	_index_y
         01:D9BC  AD C9 23   			lda	_index_y
 9241                        		__ult_b.uiq	1
         01:D9BF  C9 01      			cmp	#1		; Subtract integer from A.
         01:D9C1  6A         			ror	a		; CC if A < integer.
         01:D9C2  49 80      			eor	#$80
         01:D9C4  2A         			rol	a
 9242                        		__bfalse	.LL400
         01:D9C5  B0 03 4C 1E			bcc	.LL400
         01:D9C9  DE          
 9243                        	
 9244                        		.dbg	line,	"include\routines_SHOP.c", 118; {
 9245                        	
 9246                        		.dbg	line,	"include\routines_SHOP.c", 119; index_y += 1;
 9247                        		__add_st.umiq	1, _index_y
         01:D9CA  EE C9 23   			inc	_index_y
 9248                        	
 9249                        		.dbg	line,	"include\routines_SHOP.c", 120; item_index = (index_x + (index_y * 5));
 9250                        		__ld.um		_index_y
         01:D9CD  AD C9 23   			lda	_index_y
         01:D9D0  C2         			cly
 9251                        		__mul.wi	5
         01:D9D1  85 00      			sta.l	__temp
         01:D9D3  84 01      			sty.h	__temp
                             		__asl.wr
         01:D9D5  0A         			asl	a
         01:D9D6  42         			say
         01:D9D7  2A         			rol	a
         01:D9D8  42         			say
                             		__asl.wr
         01:D9D9  0A         			asl	a
         01:D9DA  42         			say
         01:D9DB  2A         			rol	a
         01:D9DC  42         			say
                             		__add.wm	__temp
         01:D9DD  18         			clc
         01:D9DE  65 00      			adc.l	__temp
         01:D9E0  42         			say
         01:D9E1  65 01      			adc.h	__temp
         01:D9E3  42         			say
 9252                        		__add.um	_index_x
         01:D9E4  18         			clc
         01:D9E5  6D C8 23   			adc	_index_x
         01:D9E8  90 01      			bcc	!+
         01:D9EA  C8         			iny
         01:D9EB             	!:
 9253                        		__st.umq	_item_index
         01:D9EB  8D CA 23   			sta	_item_index
 9254                        	
 9255                        		.dbg	line,	"include\routines_SHOP.c", 122; spr_set(0);
 9256                        		__ld.uiq	0
         01:D9EE  62         			cla
 9257                        		__call		_spr_set.1
         01:D9EF  20 DD E7   			call	_spr_set.1
 9258                        	
 9259                        		.dbg	line,	"include\routines_SHOP.c", 123; spr_y(168);
 9260                        		__ld.wi		168
         01:D9F2  A9 A8      			lda.l	#168
         01:D9F4  C2         			cly
 9261                        		__call		_spr_y.1
         01:D9F5  20 19 E8   			call	_spr_y.1
 9262                        	
 9263                        		.dbg	line,	"include\routines_SHOP.c", 124; }
 9264                        	
 9265                        		.dbg	line,	"include\routines_SHOP.c", 125; }
 9266    01:D9F8             	.LL400	.alias		.LL401
 9267                        	
 9268                        		.dbg	line,	"include\routines_SHOP.c", 128; else if(joytrg(JOYPAD_1) & JOY_I)
 9269                        		__bra		.LL401
         01:D9F8  4C 1E DE   			bra	.LL401
 9270    01:D9FB             	.LL399:
 9271                        		__ld.uiq	0
         01:D9FB  62         			cla
 9272                        		 _joytrg.1
         01:D9FC  AA         			tax
         01:D9FD  BD 2D 22   			lda	joytrg, x
         01:DA00  BC DD 22   			ldy	joy6trg, x
 9273                        		__tand.wi	1
         01:DA03  29 01      			and	#1
         01:DA05  C9 01      	!:		cmp	#1
 9274                        		__bfalse	.LL402
         01:DA07  B0 03 4C 1E			bcc	.LL402
         01:DA0B  DE          
 9275                        	
 9276                        		.dbg	line,	"include\routines_SHOP.c", 129; {
 9277                        	
 9278                        		.dbg	line,	"include\routines_SHOP.c", 130; switch(item_index)
 9279                        		__ld.umq	_item_index
         01:DA0C  AD CA 23   			lda	_item_index
 9280                        		__bra		.LL403
         01:DA0F  4C FB DD   			bra	.LL403
 9281                        	
 9282                        		.dbg	line,	"include\routines_SHOP.c", 131; {
 9283                        	
 9284                        		.dbg	line,	"include\routines_SHOP.c", 132; // WEAPON 2 //
 9285                        	
 9286                        		.dbg	line,	"include\routines_SHOP.c", 133; case 0:
 9287    01:DA12             	.LL405:
 9288                        		__case		0
 9289                        	
 9290                        		.dbg	line,	"include\routines_SHOP.c", 134; if(zenny_amount >= shop_prices[0])
 9291                        		__ld.wm		_zenny_amount
         01:DA12  AD 27 26   			lda.l	_zenny_amount
         01:DA15  AC 28 26   			ldy.h	_zenny_amount
 9292                        		__sge_w.wm	_shop_prices
         01:DA18  CD 2B 26   			cmp.l	_shop_prices		; Subtract memory from Y:A.
         01:DA1B  98         			tya
         01:DA1C  ED 2C 26   			sbc.h	_shop_prices
         01:DA1F  50 02      			bvc	!+
         01:DA21  49 80      			eor	#$80		; +ve if Y:A >= memory (signed).
         01:DA23  49 80      	!:		eor	#$80
         01:DA25  0A         			asl	a
 9293                        		__bfalse	.LL406
         01:DA26  B0 03 4C 1E			bcc	.LL406
         01:DA2A  DE          
 9294                        	
 9295                        		.dbg	line,	"include\routines_SHOP.c", 135; {
 9296                        	
 9297                        		.dbg	line,	"include\routines_SHOP.c", 136; if(weapon_level < 2)
 9298                        		__ld.umq	_weapon_level
         01:DA2B  AD 1F 23   			lda	_weapon_level
 9299                        		__ult_b.uiq	2
         01:DA2E  C9 02      			cmp	#2		; Subtract integer from A.
         01:DA30  6A         			ror	a		; CC if A < integer.
         01:DA31  49 80      			eor	#$80
         01:DA33  2A         			rol	a
 9300                        		__bfalse	.LL407
         01:DA34  B0 03 4C 1E			bcc	.LL407
         01:DA38  DE          
 9301                        	
 9302                        		.dbg	line,	"include\routines_SHOP.c", 137; {
 9303                        	
 9304                        		.dbg	line,	"include\routines_SHOP.c", 138; weapon_level = 2;
 9305                        		__st.umiq	2, _weapon_level
         01:DA39  A9 02      			lda.l	#2
         01:DA3B  8D 1F 23   			sta	_weapon_level
 9306                        	
 9307                        		.dbg	line,	"include\routines_SHOP.c", 139; load_vram( WEAPON_VRAM_ADR, tileset_WEAPON_2, SIZEOF(tileset_WEAPON_2) >> 1 );
 9308                        		__st.wmiq	4256, _di
         01:DA3E  A9 A0      			lda.l	#4256
         01:DA40  85 F0      			sta.l	_di
         01:DA42  A9 10      			lda.h	#4256
         01:DA44  85 F1      			sta.h	_di
 9309                        		__farptr	_tileset_WEAPON_2, _bp_bank, _bp
         01:DA46  A9 80      			lda.l	#$6000 + ($1FFF & (_tileset_WEAPON_2))
         01:DA48  85 EC      			sta.l	_bp
         01:DA4A  A9 77      			lda.h	#$6000 + ($1FFF & (_tileset_WEAPON_2))
         01:DA4C  85 ED      			sta.h	_bp
         01:DA4E  A9 03      			lda	#bank(_tileset_WEAPON_2)
         01:DA50  85 02      			sta	_bp_bank
 9310                        		__ld.wi		___sizeof__tileset_WEAPON_2
         01:DA52  A9 80      			lda.l	#___sizeof__tileset_WEAPON_2
         01:DA54  A0 00      			ldy.h	#___sizeof__tileset_WEAPON_2
 9311                        		__lsr.wi	1
         01:DA56  42         			say
         01:DA57  4A         			lsr	a
         01:DA58  42         			say
         01:DA59  6A         			ror	a
 9312                        		__st.wmq	_ax
         01:DA5A  85 F8      			sta.l	_ax
         01:DA5C  84 F9      			sty.h	_ax
 9313                        		 _load_vram.3
         01:DA5E  82         			clx				; Offset to PCE VDC.
         01:DA5F  20 63 FF   			call	load_vram_x
 9314                        	
 9315                        		.dbg	line,	"include\routines_SHOP.c", 141; zenny_amount -= shop_prices[0];
 9316                        		__ld.wm		_shop_prices
         01:DA62  AD 2B 26   			lda.l	_shop_prices
         01:DA65  AC 2C 26   			ldy.h	_shop_prices
 9317                        		__isub_st.wmq	_zenny_amount
         01:DA68  38         			sec
         01:DA69  49 FF      			eor	#$FF
         01:DA6B  6D 27 26   			adc.l	_zenny_amount
         01:DA6E  8D 27 26   			sta.l	_zenny_amount
         01:DA71  98         			tya
         01:DA72  49 FF      			eor	#$FF
         01:DA74  6D 28 26   			adc.h	_zenny_amount
         01:DA77  8D 28 26   			sta.h	_zenny_amount
 9318                        	
 9319                        		.dbg	line,	"include\routines_SHOP.c", 142; display_ZENNY();
 9320                        		__call		_display_ZENNY
         01:DA7A  20 45 FF   			call	_display_ZENNY
 9321                        	
 9322                        		.dbg	line,	"include\routines_SHOP.c", 143; }
 9323                        	
 9324                        		.dbg	line,	"include\routines_SHOP.c", 144; }
 9325    01:DA7D             	.LL407	.alias		.LL404
 9326                        	
 9327                        		.dbg	line,	"include\routines_SHOP.c", 146; break;   
 9328    01:DA7D             	.LL406	.alias		.LL404
 9329                        		__bra		.LL404
         01:DA7D  4C 1E DE   			bra	.LL404
 9330                        	
 9331                        		.dbg	line,	"include\routines_SHOP.c", 149; // WEAPON 4 //
 9332                        	
 9333                        		.dbg	line,	"include\routines_SHOP.c", 150; case 1:
 9334    01:DA80             	.LL408:
 9335                        		__case		1
 9336                        	
 9337                        		.dbg	line,	"include\routines_SHOP.c", 151; if(zenny_amount >= shop_prices[1])
 9338                        		__ld.wm		_zenny_amount
         01:DA80  AD 27 26   			lda.l	_zenny_amount
         01:DA83  AC 28 26   			ldy.h	_zenny_amount
 9339                        		__sge_w.wm	_shop_prices + 2
         01:DA86  CD 2D 26   			cmp.l	_shop_prices + 2		; Subtract memory from Y:A.
         01:DA89  98         			tya
         01:DA8A  ED 2E 26   			sbc.h	_shop_prices + 2
         01:DA8D  50 02      			bvc	!+
         01:DA8F  49 80      			eor	#$80		; +ve if Y:A >= memory (signed).
         01:DA91  49 80      	!:		eor	#$80
         01:DA93  0A         			asl	a
 9340                        		__bfalse	.LL409
         01:DA94  B0 03 4C 1E			bcc	.LL409
         01:DA98  DE          
 9341                        	
 9342                        		.dbg	line,	"include\routines_SHOP.c", 152; {
 9343                        	
 9344                        		.dbg	line,	"include\routines_SHOP.c", 153; if(weapon_level < 4)
 9345                        		__ld.umq	_weapon_level
         01:DA99  AD 1F 23   			lda	_weapon_level
 9346                        		__ult_b.uiq	4
         01:DA9C  C9 04      			cmp	#4		; Subtract integer from A.
         01:DA9E  6A         			ror	a		; CC if A < integer.
         01:DA9F  49 80      			eor	#$80
         01:DAA1  2A         			rol	a
 9347                        		__bfalse	.LL410
         01:DAA2  B0 03 4C 1E			bcc	.LL410
         01:DAA6  DE          
 9348                        	
 9349                        		.dbg	line,	"include\routines_SHOP.c", 154; {
 9350                        	
 9351                        		.dbg	line,	"include\routines_SHOP.c", 155; weapon_level = 4;
 9352                        		__st.umiq	4, _weapon_level
         01:DAA7  A9 04      			lda.l	#4
         01:DAA9  8D 1F 23   			sta	_weapon_level
 9353                        	
 9354                        		.dbg	line,	"include\routines_SHOP.c", 156; load_vram( WEAPON_VRAM_ADR, tileset_WEAPON_4, SIZEOF(tileset_WEAPON_4) >> 1 );
 9355                        		__st.wmiq	4256, _di
         01:DAAC  A9 A0      			lda.l	#4256
         01:DAAE  85 F0      			sta.l	_di
         01:DAB0  A9 10      			lda.h	#4256
         01:DAB2  85 F1      			sta.h	_di
 9356                        		__farptr	_tileset_WEAPON_4, _bp_bank, _bp
         01:DAB4  A9 00      			lda.l	#$6000 + ($1FFF & (_tileset_WEAPON_4))
         01:DAB6  85 EC      			sta.l	_bp
         01:DAB8  A9 78      			lda.h	#$6000 + ($1FFF & (_tileset_WEAPON_4))
         01:DABA  85 ED      			sta.h	_bp
         01:DABC  A9 03      			lda	#bank(_tileset_WEAPON_4)
         01:DABE  85 02      			sta	_bp_bank
 9357                        		__ld.wi		___sizeof__tileset_WEAPON_4
         01:DAC0  A9 80      			lda.l	#___sizeof__tileset_WEAPON_4
         01:DAC2  A0 00      			ldy.h	#___sizeof__tileset_WEAPON_4
 9358                        		__lsr.wi	1
         01:DAC4  42         			say
         01:DAC5  4A         			lsr	a
         01:DAC6  42         			say
         01:DAC7  6A         			ror	a
 9359                        		__st.wmq	_ax
         01:DAC8  85 F8      			sta.l	_ax
         01:DACA  84 F9      			sty.h	_ax
 9360                        		 _load_vram.3
         01:DACC  82         			clx				; Offset to PCE VDC.
         01:DACD  20 63 FF   			call	load_vram_x
 9361                        	
 9362                        		.dbg	line,	"include\routines_SHOP.c", 158; zenny_amount -= shop_prices[1];
 9363                        		__ld.wm		_shop_prices + 2
         01:DAD0  AD 2D 26   			lda.l	_shop_prices + 2
         01:DAD3  AC 2E 26   			ldy.h	_shop_prices + 2
 9364                        		__isub_st.wmq	_zenny_amount
         01:DAD6  38         			sec
         01:DAD7  49 FF      			eor	#$FF
         01:DAD9  6D 27 26   			adc.l	_zenny_amount
         01:DADC  8D 27 26   			sta.l	_zenny_amount
         01:DADF  98         			tya
         01:DAE0  49 FF      			eor	#$FF
         01:DAE2  6D 28 26   			adc.h	_zenny_amount
         01:DAE5  8D 28 26   			sta.h	_zenny_amount
 9365                        	
 9366                        		.dbg	line,	"include\routines_SHOP.c", 159; display_ZENNY();
 9367                        		__call		_display_ZENNY
         01:DAE8  20 45 FF   			call	_display_ZENNY
 9368                        	
 9369                        		.dbg	line,	"include\routines_SHOP.c", 160; }
 9370                        	
 9371                        		.dbg	line,	"include\routines_SHOP.c", 161; }
 9372    01:DAEB             	.LL410	.alias		.LL404
 9373                        	
 9374                        		.dbg	line,	"include\routines_SHOP.c", 163; break; 
 9375    01:DAEB             	.LL409	.alias		.LL404
 9376                        		__bra		.LL404
         01:DAEB  4C 1E DE   			bra	.LL404
 9377                        	
 9378                        		.dbg	line,	"include\routines_SHOP.c", 166; // WEAPON 5 //
 9379                        	
 9380                        		.dbg	line,	"include\routines_SHOP.c", 167; case 2:
 9381    01:DAEE             	.LL411:
 9382                        		__case		2
 9383                        	
 9384                        		.dbg	line,	"include\routines_SHOP.c", 168; if(zenny_amount >= shop_prices[2])
 9385                        		__ld.wm		_zenny_amount
         01:DAEE  AD 27 26   			lda.l	_zenny_amount
         01:DAF1  AC 28 26   			ldy.h	_zenny_amount
 9386                        		__sge_w.wm	_shop_prices + 4
         01:DAF4  CD 2F 26   			cmp.l	_shop_prices + 4		; Subtract memory from Y:A.
         01:DAF7  98         			tya
         01:DAF8  ED 30 26   			sbc.h	_shop_prices + 4
         01:DAFB  50 02      			bvc	!+
         01:DAFD  49 80      			eor	#$80		; +ve if Y:A >= memory (signed).
         01:DAFF  49 80      	!:		eor	#$80
         01:DB01  0A         			asl	a
 9387                        		__bfalse	.LL412
         01:DB02  B0 03 4C 1E			bcc	.LL412
         01:DB06  DE          
 9388                        	
 9389                        		.dbg	line,	"include\routines_SHOP.c", 169; {
 9390                        	
 9391                        		.dbg	line,	"include\routines_SHOP.c", 170; if(weapon_level < 5)
 9392                        		__ld.umq	_weapon_level
         01:DB07  AD 1F 23   			lda	_weapon_level
 9393                        		__ult_b.uiq	5
         01:DB0A  C9 05      			cmp	#5		; Subtract integer from A.
         01:DB0C  6A         			ror	a		; CC if A < integer.
         01:DB0D  49 80      			eor	#$80
         01:DB0F  2A         			rol	a
 9394                        		__bfalse	.LL413
         01:DB10  B0 03 4C 1E			bcc	.LL413
         01:DB14  DE          
 9395                        	
 9396                        		.dbg	line,	"include\routines_SHOP.c", 171; {
 9397                        	
 9398                        		.dbg	line,	"include\routines_SHOP.c", 172; weapon_level = 5;
 9399                        		__st.umiq	5, _weapon_level
         01:DB15  A9 05      			lda.l	#5
         01:DB17  8D 1F 23   			sta	_weapon_level
 9400                        	
 9401                        		.dbg	line,	"include\routines_SHOP.c", 173; load_vram( WEAPON_VRAM_ADR, tileset_WEAPON_5, SIZEOF(tileset_WEAPON_5) >> 1 );
 9402                        		__st.wmiq	4256, _di
         01:DB1A  A9 A0      			lda.l	#4256
         01:DB1C  85 F0      			sta.l	_di
         01:DB1E  A9 10      			lda.h	#4256
         01:DB20  85 F1      			sta.h	_di
 9403                        		__farptr	_tileset_WEAPON_5, _bp_bank, _bp
         01:DB22  A9 80      			lda.l	#$6000 + ($1FFF & (_tileset_WEAPON_5))
         01:DB24  85 EC      			sta.l	_bp
         01:DB26  A9 78      			lda.h	#$6000 + ($1FFF & (_tileset_WEAPON_5))
         01:DB28  85 ED      			sta.h	_bp
         01:DB2A  A9 03      			lda	#bank(_tileset_WEAPON_5)
         01:DB2C  85 02      			sta	_bp_bank
 9404                        		__ld.wi		___sizeof__tileset_WEAPON_5
         01:DB2E  A9 80      			lda.l	#___sizeof__tileset_WEAPON_5
         01:DB30  A0 00      			ldy.h	#___sizeof__tileset_WEAPON_5
 9405                        		__lsr.wi	1
         01:DB32  42         			say
         01:DB33  4A         			lsr	a
         01:DB34  42         			say
         01:DB35  6A         			ror	a
 9406                        		__st.wmq	_ax
         01:DB36  85 F8      			sta.l	_ax
         01:DB38  84 F9      			sty.h	_ax
 9407                        		 _load_vram.3
         01:DB3A  82         			clx				; Offset to PCE VDC.
         01:DB3B  20 63 FF   			call	load_vram_x
 9408                        	
 9409                        		.dbg	line,	"include\routines_SHOP.c", 175; zenny_amount -= shop_prices[2];
 9410                        		__ld.wm		_shop_prices + 4
         01:DB3E  AD 2F 26   			lda.l	_shop_prices + 4
         01:DB41  AC 30 26   			ldy.h	_shop_prices + 4
 9411                        		__isub_st.wmq	_zenny_amount
         01:DB44  38         			sec
         01:DB45  49 FF      			eor	#$FF
         01:DB47  6D 27 26   			adc.l	_zenny_amount
         01:DB4A  8D 27 26   			sta.l	_zenny_amount
         01:DB4D  98         			tya
         01:DB4E  49 FF      			eor	#$FF
         01:DB50  6D 28 26   			adc.h	_zenny_amount
         01:DB53  8D 28 26   			sta.h	_zenny_amount
 9412                        	
 9413                        		.dbg	line,	"include\routines_SHOP.c", 176; display_ZENNY();
 9414                        		__call		_display_ZENNY
         01:DB56  20 45 FF   			call	_display_ZENNY
 9415                        	
 9416                        		.dbg	line,	"include\routines_SHOP.c", 177; }
 9417                        	
 9418                        		.dbg	line,	"include\routines_SHOP.c", 178; }
 9419    01:DB59             	.LL413	.alias		.LL404
 9420                        	
 9421                        		.dbg	line,	"include\routines_SHOP.c", 180; break;   
 9422    01:DB59             	.LL412	.alias		.LL404
 9423                        		__bra		.LL404
         01:DB59  4C 1E DE   			bra	.LL404
 9424                        	
 9425                        		.dbg	line,	"include\routines_SHOP.c", 183; // WEAPON 8 //
 9426                        	
 9427                        		.dbg	line,	"include\routines_SHOP.c", 184; case 3:
 9428    01:DB5C             	.LL414:
 9429                        		__case		3
 9430                        	
 9431                        		.dbg	line,	"include\routines_SHOP.c", 185; if(zenny_amount >= shop_prices[3])
 9432                        		__ld.wm		_zenny_amount
         01:DB5C  AD 27 26   			lda.l	_zenny_amount
         01:DB5F  AC 28 26   			ldy.h	_zenny_amount
 9433                        		__sge_w.wm	_shop_prices + 6
         01:DB62  CD 31 26   			cmp.l	_shop_prices + 6		; Subtract memory from Y:A.
         01:DB65  98         			tya
         01:DB66  ED 32 26   			sbc.h	_shop_prices + 6
         01:DB69  50 02      			bvc	!+
         01:DB6B  49 80      			eor	#$80		; +ve if Y:A >= memory (signed).
         01:DB6D  49 80      	!:		eor	#$80
         01:DB6F  0A         			asl	a
 9434                        		__bfalse	.LL415
         01:DB70  B0 03 4C 1E			bcc	.LL415
         01:DB74  DE          
 9435                        	
 9436                        		.dbg	line,	"include\routines_SHOP.c", 186; {
 9437                        	
 9438                        		.dbg	line,	"include\routines_SHOP.c", 187; if(weapon_level < 8)
 9439                        		__ld.umq	_weapon_level
         01:DB75  AD 1F 23   			lda	_weapon_level
 9440                        		__ult_b.uiq	8
         01:DB78  C9 08      			cmp	#8		; Subtract integer from A.
         01:DB7A  6A         			ror	a		; CC if A < integer.
         01:DB7B  49 80      			eor	#$80
         01:DB7D  2A         			rol	a
 9441                        		__bfalse	.LL416
         01:DB7E  B0 03 4C 1E			bcc	.LL416
         01:DB82  DE          
 9442                        	
 9443                        		.dbg	line,	"include\routines_SHOP.c", 188; {
 9444                        	
 9445                        		.dbg	line,	"include\routines_SHOP.c", 189; weapon_level = 8;
 9446                        		__st.umiq	8, _weapon_level
         01:DB83  A9 08      			lda.l	#8
         01:DB85  8D 1F 23   			sta	_weapon_level
 9447                        	
 9448                        		.dbg	line,	"include\routines_SHOP.c", 190; load_vram( WEAPON_VRAM_ADR, tileset_WEAPON_8, SIZEOF(tileset_WEAPON_8) >> 1 );
 9449                        		__st.wmiq	4256, _di
         01:DB88  A9 A0      			lda.l	#4256
         01:DB8A  85 F0      			sta.l	_di
         01:DB8C  A9 10      			lda.h	#4256
         01:DB8E  85 F1      			sta.h	_di
 9450                        		__farptr	_tileset_WEAPON_8, _bp_bank, _bp
         01:DB90  A9 00      			lda.l	#$6000 + ($1FFF & (_tileset_WEAPON_8))
         01:DB92  85 EC      			sta.l	_bp
         01:DB94  A9 79      			lda.h	#$6000 + ($1FFF & (_tileset_WEAPON_8))
         01:DB96  85 ED      			sta.h	_bp
         01:DB98  A9 03      			lda	#bank(_tileset_WEAPON_8)
         01:DB9A  85 02      			sta	_bp_bank
 9451                        		__ld.wi		___sizeof__tileset_WEAPON_8
         01:DB9C  A9 80      			lda.l	#___sizeof__tileset_WEAPON_8
         01:DB9E  A0 00      			ldy.h	#___sizeof__tileset_WEAPON_8
 9452                        		__lsr.wi	1
         01:DBA0  42         			say
         01:DBA1  4A         			lsr	a
         01:DBA2  42         			say
         01:DBA3  6A         			ror	a
 9453                        		__st.wmq	_ax
         01:DBA4  85 F8      			sta.l	_ax
         01:DBA6  84 F9      			sty.h	_ax
 9454                        		 _load_vram.3
         01:DBA8  82         			clx				; Offset to PCE VDC.
         01:DBA9  20 63 FF   			call	load_vram_x
 9455                        	
 9456                        		.dbg	line,	"include\routines_SHOP.c", 192; zenny_amount -= shop_prices[3];
 9457                        		__ld.wm		_shop_prices + 6
         01:DBAC  AD 31 26   			lda.l	_shop_prices + 6
         01:DBAF  AC 32 26   			ldy.h	_shop_prices + 6
 9458                        		__isub_st.wmq	_zenny_amount
         01:DBB2  38         			sec
         01:DBB3  49 FF      			eor	#$FF
         01:DBB5  6D 27 26   			adc.l	_zenny_amount
         01:DBB8  8D 27 26   			sta.l	_zenny_amount
         01:DBBB  98         			tya
         01:DBBC  49 FF      			eor	#$FF
         01:DBBE  6D 28 26   			adc.h	_zenny_amount
         01:DBC1  8D 28 26   			sta.h	_zenny_amount
 9459                        	
 9460                        		.dbg	line,	"include\routines_SHOP.c", 193; display_ZENNY();
 9461                        		__call		_display_ZENNY
         01:DBC4  20 45 FF   			call	_display_ZENNY
 9462                        	
 9463                        		.dbg	line,	"include\routines_SHOP.c", 194; }
 9464                        	
 9465                        		.dbg	line,	"include\routines_SHOP.c", 195; }
 9466    01:DBC7             	.LL416	.alias		.LL404
 9467                        	
 9468                        		.dbg	line,	"include\routines_SHOP.c", 197; break;  
 9469    01:DBC7             	.LL415	.alias		.LL404
 9470                        		__bra		.LL404
         01:DBC7  4C 1E DE   			bra	.LL404
 9471                        	
 9472                        		.dbg	line,	"include\routines_SHOP.c", 200; // KEY //
 9473                        	
 9474                        		.dbg	line,	"include\routines_SHOP.c", 201; case 4:
 9475    01:DBCA             	.LL417:
 9476                        		__case		4
 9477                        	
 9478                        		.dbg	line,	"include\routines_SHOP.c", 202; if(zenny_amount >= shop_prices[4])
 9479                        		__ld.wm		_zenny_amount
         01:DBCA  AD 27 26   			lda.l	_zenny_amount
         01:DBCD  AC 28 26   			ldy.h	_zenny_amount
 9480                        		__sge_w.wm	_shop_prices + 8
         01:DBD0  CD 33 26   			cmp.l	_shop_prices + 8		; Subtract memory from Y:A.
         01:DBD3  98         			tya
         01:DBD4  ED 34 26   			sbc.h	_shop_prices + 8
         01:DBD7  50 02      			bvc	!+
         01:DBD9  49 80      			eor	#$80		; +ve if Y:A >= memory (signed).
         01:DBDB  49 80      	!:		eor	#$80
         01:DBDD  0A         			asl	a
 9481                        		__bfalse	.LL418
         01:DBDE  B0 03 4C 1E			bcc	.LL418
         01:DBE2  DE          
 9482                        	
 9483                        		.dbg	line,	"include\routines_SHOP.c", 203; {
 9484                        	
 9485                        		.dbg	line,	"include\routines_SHOP.c", 204; key_amount += 1;
 9486                        		__add_st.umiq	1, _key_amount
         01:DBE3  EE 21 23   			inc	_key_amount
 9487                        	
 9488                        		.dbg	line,	"include\routines_SHOP.c", 206; zenny_amount -= shop_prices[4];
 9489                        		__ld.wm		_shop_prices + 8
         01:DBE6  AD 33 26   			lda.l	_shop_prices + 8
         01:DBE9  AC 34 26   			ldy.h	_shop_prices + 8
 9490                        		__isub_st.wmq	_zenny_amount
         01:DBEC  38         			sec
         01:DBED  49 FF      			eor	#$FF
         01:DBEF  6D 27 26   			adc.l	_zenny_amount
         01:DBF2  8D 27 26   			sta.l	_zenny_amount
         01:DBF5  98         			tya
         01:DBF6  49 FF      			eor	#$FF
         01:DBF8  6D 28 26   			adc.h	_zenny_amount
         01:DBFB  8D 28 26   			sta.h	_zenny_amount
 9491                        	
 9492                        		.dbg	line,	"include\routines_SHOP.c", 207; display_KEY();
 9493                        		__call		_display_KEY
         01:DBFE  20 8B FF   			call	_display_KEY
 9494                        	
 9495                        		.dbg	line,	"include\routines_SHOP.c", 208; }
 9496                        	
 9497                        		.dbg	line,	"include\routines_SHOP.c", 210; break;   
 9498    01:DC01             	.LL418	.alias		.LL404
 9499                        		__bra		.LL404
         01:DC01  4C 1E DE   			bra	.LL404
 9500                        	
 9501                        		.dbg	line,	"include\routines_SHOP.c", 213; // ARMOR 1 //
 9502                        	
 9503                        		.dbg	line,	"include\routines_SHOP.c", 214; case 5:
 9504    01:DC04             	.LL419:
 9505                        		__case		5
 9506                        	
 9507                        		.dbg	line,	"include\routines_SHOP.c", 215; if(zenny_amount >= shop_prices[5])
 9508                        		__ld.wm		_zenny_amount
         01:DC04  AD 27 26   			lda.l	_zenny_amount
         01:DC07  AC 28 26   			ldy.h	_zenny_amount
 9509                        		__sge_w.wm	_shop_prices + 10
         01:DC0A  CD 35 26   			cmp.l	_shop_prices + 10		; Subtract memory from Y:A.
         01:DC0D  98         			tya
         01:DC0E  ED 36 26   			sbc.h	_shop_prices + 10
         01:DC11  50 02      			bvc	!+
         01:DC13  49 80      			eor	#$80		; +ve if Y:A >= memory (signed).
         01:DC15  49 80      	!:		eor	#$80
         01:DC17  0A         			asl	a
 9510                        		__bfalse	.LL420
         01:DC18  B0 03 4C 1E			bcc	.LL420
         01:DC1C  DE          
 9511                        	
 9512                        		.dbg	line,	"include\routines_SHOP.c", 216; {
 9513                        	
 9514                        		.dbg	line,	"include\routines_SHOP.c", 217; if(armor_level < 1)
 9515                        		__ld.umq	_armor_level
         01:DC1D  AD 1E 23   			lda	_armor_level
 9516                        		__ult_b.uiq	1
         01:DC20  C9 01      			cmp	#1		; Subtract integer from A.
         01:DC22  6A         			ror	a		; CC if A < integer.
         01:DC23  49 80      			eor	#$80
         01:DC25  2A         			rol	a
 9517                        		__bfalse	.LL421
         01:DC26  B0 03 4C 1E			bcc	.LL421
         01:DC2A  DE          
 9518                        	
 9519                        		.dbg	line,	"include\routines_SHOP.c", 218; {
 9520                        	
 9521                        		.dbg	line,	"include\routines_SHOP.c", 219; armor_level = 1;
 9522                        		__st.umiq	1, _armor_level
         01:DC2B  A9 01      			lda.l	#1
         01:DC2D  8D 1E 23   			sta	_armor_level
 9523                        	
 9524                        		.dbg	line,	"include\routines_SHOP.c", 220; load_vram( ARMOR_VRAM_ADR, tileset_ARMOR_1, SIZEOF(tileset_ARMOR_1) >> 1 );
 9525                        		__st.wmiq	4320, _di
         01:DC30  A9 E0      			lda.l	#4320
         01:DC32  85 F0      			sta.l	_di
         01:DC34  A9 10      			lda.h	#4320
         01:DC36  85 F1      			sta.h	_di
 9526                        		__farptr	_tileset_ARMOR_1, _bp_bank, _bp
         01:DC38  A9 00      			lda.l	#$6000 + ($1FFF & (_tileset_ARMOR_1))
         01:DC3A  85 EC      			sta.l	_bp
         01:DC3C  A9 75      			lda.h	#$6000 + ($1FFF & (_tileset_ARMOR_1))
         01:DC3E  85 ED      			sta.h	_bp
         01:DC40  A9 03      			lda	#bank(_tileset_ARMOR_1)
         01:DC42  85 02      			sta	_bp_bank
 9527                        		__ld.wi		___sizeof__tileset_ARMOR_1
         01:DC44  A9 80      			lda.l	#___sizeof__tileset_ARMOR_1
         01:DC46  A0 00      			ldy.h	#___sizeof__tileset_ARMOR_1
 9528                        		__lsr.wi	1
         01:DC48  42         			say
         01:DC49  4A         			lsr	a
         01:DC4A  42         			say
         01:DC4B  6A         			ror	a
 9529                        		__st.wmq	_ax
         01:DC4C  85 F8      			sta.l	_ax
         01:DC4E  84 F9      			sty.h	_ax
 9530                        		 _load_vram.3
         01:DC50  82         			clx				; Offset to PCE VDC.
         01:DC51  20 63 FF   			call	load_vram_x
 9531                        	
 9532                        		.dbg	line,	"include\routines_SHOP.c", 222; zenny_amount -= shop_prices[5];
 9533                        		__ld.wm		_shop_prices + 10
         01:DC54  AD 35 26   			lda.l	_shop_prices + 10
         01:DC57  AC 36 26   			ldy.h	_shop_prices + 10
 9534                        		__isub_st.wmq	_zenny_amount
         01:DC5A  38         			sec
         01:DC5B  49 FF      			eor	#$FF
         01:DC5D  6D 27 26   			adc.l	_zenny_amount
         01:DC60  8D 27 26   			sta.l	_zenny_amount
         01:DC63  98         			tya
         01:DC64  49 FF      			eor	#$FF
         01:DC66  6D 28 26   			adc.h	_zenny_amount
         01:DC69  8D 28 26   			sta.h	_zenny_amount
 9535                        	
 9536                        		.dbg	line,	"include\routines_SHOP.c", 223; display_ZENNY();
 9537                        		__call		_display_ZENNY
         01:DC6C  20 45 FF   			call	_display_ZENNY
 9538                        	
 9539                        		.dbg	line,	"include\routines_SHOP.c", 224; }
 9540                        	
 9541                        		.dbg	line,	"include\routines_SHOP.c", 225; }
 9542    01:DC6F             	.LL421	.alias		.LL404
 9543                        	
 9544                        		.dbg	line,	"include\routines_SHOP.c", 227; break;   
 9545    01:DC6F             	.LL420	.alias		.LL404
 9546                        		__bra		.LL404
         01:DC6F  4C 1E DE   			bra	.LL404
 9547                        	
 9548                        		.dbg	line,	"include\routines_SHOP.c", 230; // ARMOR 2 //
 9549                        	
 9550                        		.dbg	line,	"include\routines_SHOP.c", 231; case 6:
 9551    01:DC72             	.LL422:
 9552                        		__case		6
 9553                        	
 9554                        		.dbg	line,	"include\routines_SHOP.c", 232; if(zenny_amount >= shop_prices[6])
 9555                        		__ld.wm		_zenny_amount
         01:DC72  AD 27 26   			lda.l	_zenny_amount
         01:DC75  AC 28 26   			ldy.h	_zenny_amount
 9556                        		__sge_w.wm	_shop_prices + 12
         01:DC78  CD 37 26   			cmp.l	_shop_prices + 12		; Subtract memory from Y:A.
         01:DC7B  98         			tya
         01:DC7C  ED 38 26   			sbc.h	_shop_prices + 12
         01:DC7F  50 02      			bvc	!+
         01:DC81  49 80      			eor	#$80		; +ve if Y:A >= memory (signed).
         01:DC83  49 80      	!:		eor	#$80
         01:DC85  0A         			asl	a
 9557                        		__bfalse	.LL423
         01:DC86  B0 03 4C 1E			bcc	.LL423
         01:DC8A  DE          
 9558                        	
 9559                        		.dbg	line,	"include\routines_SHOP.c", 233; {
 9560                        	
 9561                        		.dbg	line,	"include\routines_SHOP.c", 234; if(armor_level < 4)
 9562                        		__ld.umq	_armor_level
         01:DC8B  AD 1E 23   			lda	_armor_level
 9563                        		__ult_b.uiq	4
         01:DC8E  C9 04      			cmp	#4		; Subtract integer from A.
         01:DC90  6A         			ror	a		; CC if A < integer.
         01:DC91  49 80      			eor	#$80
         01:DC93  2A         			rol	a
 9564                        		__bfalse	.LL424
         01:DC94  B0 03 4C 1E			bcc	.LL424
         01:DC98  DE          
 9565                        	
 9566                        		.dbg	line,	"include\routines_SHOP.c", 235; {
 9567                        	
 9568                        		.dbg	line,	"include\routines_SHOP.c", 236; armor_level = 4;
 9569                        		__st.umiq	4, _armor_level
         01:DC99  A9 04      			lda.l	#4
         01:DC9B  8D 1E 23   			sta	_armor_level
 9570                        	
 9571                        		.dbg	line,	"include\routines_SHOP.c", 237; load_vram( ARMOR_VRAM_ADR, tileset_ARMOR_2, SIZEOF(tileset_ARMOR_2) >> 1 );
 9572                        		__st.wmiq	4320, _di
         01:DC9E  A9 E0      			lda.l	#4320
         01:DCA0  85 F0      			sta.l	_di
         01:DCA2  A9 10      			lda.h	#4320
         01:DCA4  85 F1      			sta.h	_di
 9573                        		__farptr	_tileset_ARMOR_2, _bp_bank, _bp
         01:DCA6  A9 80      			lda.l	#$6000 + ($1FFF & (_tileset_ARMOR_2))
         01:DCA8  85 EC      			sta.l	_bp
         01:DCAA  A9 75      			lda.h	#$6000 + ($1FFF & (_tileset_ARMOR_2))
         01:DCAC  85 ED      			sta.h	_bp
         01:DCAE  A9 03      			lda	#bank(_tileset_ARMOR_2)
         01:DCB0  85 02      			sta	_bp_bank
 9574                        		__ld.wi		___sizeof__tileset_ARMOR_2
         01:DCB2  A9 80      			lda.l	#___sizeof__tileset_ARMOR_2
         01:DCB4  A0 00      			ldy.h	#___sizeof__tileset_ARMOR_2
 9575                        		__lsr.wi	1
         01:DCB6  42         			say
         01:DCB7  4A         			lsr	a
         01:DCB8  42         			say
         01:DCB9  6A         			ror	a
 9576                        		__st.wmq	_ax
         01:DCBA  85 F8      			sta.l	_ax
         01:DCBC  84 F9      			sty.h	_ax
 9577                        		 _load_vram.3
         01:DCBE  82         			clx				; Offset to PCE VDC.
         01:DCBF  20 63 FF   			call	load_vram_x
 9578                        	
 9579                        		.dbg	line,	"include\routines_SHOP.c", 239; zenny_amount -= shop_prices[6];
 9580                        		__ld.wm		_shop_prices + 12
         01:DCC2  AD 37 26   			lda.l	_shop_prices + 12
         01:DCC5  AC 38 26   			ldy.h	_shop_prices + 12
 9581                        		__isub_st.wmq	_zenny_amount
         01:DCC8  38         			sec
         01:DCC9  49 FF      			eor	#$FF
         01:DCCB  6D 27 26   			adc.l	_zenny_amount
         01:DCCE  8D 27 26   			sta.l	_zenny_amount
         01:DCD1  98         			tya
         01:DCD2  49 FF      			eor	#$FF
         01:DCD4  6D 28 26   			adc.h	_zenny_amount
         01:DCD7  8D 28 26   			sta.h	_zenny_amount
 9582                        	
 9583                        		.dbg	line,	"include\routines_SHOP.c", 240; display_ZENNY();
 9584                        		__call		_display_ZENNY
         01:DCDA  20 45 FF   			call	_display_ZENNY
 9585                        	
 9586                        		.dbg	line,	"include\routines_SHOP.c", 241; }
 9587                        	
 9588                        		.dbg	line,	"include\routines_SHOP.c", 242; }
 9589    01:DCDD             	.LL424	.alias		.LL404
 9590                        	
 9591                        		.dbg	line,	"include\routines_SHOP.c", 244; break;    
 9592    01:DCDD             	.LL423	.alias		.LL404
 9593                        		__bra		.LL404
         01:DCDD  4C 1E DE   			bra	.LL404
 9594                        	
 9595                        		.dbg	line,	"include\routines_SHOP.c", 247; // ARMOR 4 //
 9596                        	
 9597                        		.dbg	line,	"include\routines_SHOP.c", 248; case 7:
 9598    01:DCE0             	.LL425:
 9599                        		__case		7
 9600                        	
 9601                        		.dbg	line,	"include\routines_SHOP.c", 249; if(zenny_amount >= shop_prices[7])
 9602                        		__ld.wm		_zenny_amount
         01:DCE0  AD 27 26   			lda.l	_zenny_amount
         01:DCE3  AC 28 26   			ldy.h	_zenny_amount
 9603                        		__sge_w.wm	_shop_prices + 14
         01:DCE6  CD 39 26   			cmp.l	_shop_prices + 14		; Subtract memory from Y:A.
         01:DCE9  98         			tya
         01:DCEA  ED 3A 26   			sbc.h	_shop_prices + 14
         01:DCED  50 02      			bvc	!+
         01:DCEF  49 80      			eor	#$80		; +ve if Y:A >= memory (signed).
         01:DCF1  49 80      	!:		eor	#$80
         01:DCF3  0A         			asl	a
 9604                        		__bfalse	.LL426
         01:DCF4  B0 03 4C 1E			bcc	.LL426
         01:DCF8  DE          
 9605                        	
 9606                        		.dbg	line,	"include\routines_SHOP.c", 250; {
 9607                        	
 9608                        		.dbg	line,	"include\routines_SHOP.c", 251; if(armor_level < 5)
 9609                        		__ld.umq	_armor_level
         01:DCF9  AD 1E 23   			lda	_armor_level
 9610                        		__ult_b.uiq	5
         01:DCFC  C9 05      			cmp	#5		; Subtract integer from A.
         01:DCFE  6A         			ror	a		; CC if A < integer.
         01:DCFF  49 80      			eor	#$80
         01:DD01  2A         			rol	a
 9611                        		__bfalse	.LL427
         01:DD02  B0 03 4C 1E			bcc	.LL427
         01:DD06  DE          
 9612                        	
 9613                        		.dbg	line,	"include\routines_SHOP.c", 252; {
 9614                        	
 9615                        		.dbg	line,	"include\routines_SHOP.c", 253; armor_level = 5;
 9616                        		__st.umiq	5, _armor_level
         01:DD07  A9 05      			lda.l	#5
         01:DD09  8D 1E 23   			sta	_armor_level
 9617                        	
 9618                        		.dbg	line,	"include\routines_SHOP.c", 254; load_vram( ARMOR_VRAM_ADR, tileset_ARMOR_4, SIZEOF(tileset_ARMOR_4) >> 1 );
 9619                        		__st.wmiq	4320, _di
         01:DD0C  A9 E0      			lda.l	#4320
         01:DD0E  85 F0      			sta.l	_di
         01:DD10  A9 10      			lda.h	#4320
         01:DD12  85 F1      			sta.h	_di
 9620                        		__farptr	_tileset_ARMOR_4, _bp_bank, _bp
         01:DD14  A9 00      			lda.l	#$6000 + ($1FFF & (_tileset_ARMOR_4))
         01:DD16  85 EC      			sta.l	_bp
         01:DD18  A9 76      			lda.h	#$6000 + ($1FFF & (_tileset_ARMOR_4))
         01:DD1A  85 ED      			sta.h	_bp
         01:DD1C  A9 03      			lda	#bank(_tileset_ARMOR_4)
         01:DD1E  85 02      			sta	_bp_bank
 9621                        		__ld.wi		___sizeof__tileset_ARMOR_4
         01:DD20  A9 80      			lda.l	#___sizeof__tileset_ARMOR_4
         01:DD22  A0 00      			ldy.h	#___sizeof__tileset_ARMOR_4
 9622                        		__lsr.wi	1
         01:DD24  42         			say
         01:DD25  4A         			lsr	a
         01:DD26  42         			say
         01:DD27  6A         			ror	a
 9623                        		__st.wmq	_ax
         01:DD28  85 F8      			sta.l	_ax
         01:DD2A  84 F9      			sty.h	_ax
 9624                        		 _load_vram.3
         01:DD2C  82         			clx				; Offset to PCE VDC.
         01:DD2D  20 63 FF   			call	load_vram_x
 9625                        	
 9626                        		.dbg	line,	"include\routines_SHOP.c", 256; zenny_amount -= shop_prices[7];
 9627                        		__ld.wm		_shop_prices + 14
         01:DD30  AD 39 26   			lda.l	_shop_prices + 14
         01:DD33  AC 3A 26   			ldy.h	_shop_prices + 14
 9628                        		__isub_st.wmq	_zenny_amount
         01:DD36  38         			sec
         01:DD37  49 FF      			eor	#$FF
         01:DD39  6D 27 26   			adc.l	_zenny_amount
         01:DD3C  8D 27 26   			sta.l	_zenny_amount
         01:DD3F  98         			tya
         01:DD40  49 FF      			eor	#$FF
         01:DD42  6D 28 26   			adc.h	_zenny_amount
         01:DD45  8D 28 26   			sta.h	_zenny_amount
 9629                        	
 9630                        		.dbg	line,	"include\routines_SHOP.c", 257; display_ZENNY();
 9631                        		__call		_display_ZENNY
         01:DD48  20 45 FF   			call	_display_ZENNY
 9632                        	
 9633                        		.dbg	line,	"include\routines_SHOP.c", 258; }
 9634                        	
 9635                        		.dbg	line,	"include\routines_SHOP.c", 259; }
 9636    01:DD4B             	.LL427	.alias		.LL404
 9637                        	
 9638                        		.dbg	line,	"include\routines_SHOP.c", 261; break;   
 9639    01:DD4B             	.LL426	.alias		.LL404
 9640                        		__bra		.LL404
         01:DD4B  4C 1E DE   			bra	.LL404
 9641                        	
 9642                        		.dbg	line,	"include\routines_SHOP.c", 264; // ARMOR 8 //
 9643                        	
 9644                        		.dbg	line,	"include\routines_SHOP.c", 265; case 8:
 9645    01:DD4E             	.LL428:
 9646                        		__case		8
 9647                        	
 9648                        		.dbg	line,	"include\routines_SHOP.c", 266; if(zenny_amount >= shop_prices[8])
 9649                        		__ld.wm		_zenny_amount
         01:DD4E  AD 27 26   			lda.l	_zenny_amount
         01:DD51  AC 28 26   			ldy.h	_zenny_amount
 9650                        		__sge_w.wm	_shop_prices + 16
         01:DD54  CD 3B 26   			cmp.l	_shop_prices + 16		; Subtract memory from Y:A.
         01:DD57  98         			tya
         01:DD58  ED 3C 26   			sbc.h	_shop_prices + 16
         01:DD5B  50 02      			bvc	!+
         01:DD5D  49 80      			eor	#$80		; +ve if Y:A >= memory (signed).
         01:DD5F  49 80      	!:		eor	#$80
         01:DD61  0A         			asl	a
 9651                        		__bfalse	.LL429
         01:DD62  B0 03 4C 1E			bcc	.LL429
         01:DD66  DE          
 9652                        	
 9653                        		.dbg	line,	"include\routines_SHOP.c", 267; {
 9654                        	
 9655                        		.dbg	line,	"include\routines_SHOP.c", 268; if(armor_level < 8)
 9656                        		__ld.umq	_armor_level
         01:DD67  AD 1E 23   			lda	_armor_level
 9657                        		__ult_b.uiq	8
         01:DD6A  C9 08      			cmp	#8		; Subtract integer from A.
         01:DD6C  6A         			ror	a		; CC if A < integer.
         01:DD6D  49 80      			eor	#$80
         01:DD6F  2A         			rol	a
 9658                        		__bfalse	.LL430
         01:DD70  B0 03 4C 1E			bcc	.LL430
         01:DD74  DE          
 9659                        	
 9660                        		.dbg	line,	"include\routines_SHOP.c", 269; {
 9661                        	
 9662                        		.dbg	line,	"include\routines_SHOP.c", 270; armor_level = 8;
 9663                        		__st.umiq	8, _armor_level
         01:DD75  A9 08      			lda.l	#8
         01:DD77  8D 1E 23   			sta	_armor_level
 9664                        	
 9665                        		.dbg	line,	"include\routines_SHOP.c", 271; load_vram( ARMOR_VRAM_ADR, tileset_ARMOR_8, SIZEOF(tileset_ARMOR_8) >> 1 );
 9666                        		__st.wmiq	4320, _di
         01:DD7A  A9 E0      			lda.l	#4320
         01:DD7C  85 F0      			sta.l	_di
         01:DD7E  A9 10      			lda.h	#4320
         01:DD80  85 F1      			sta.h	_di
 9667                        		__farptr	_tileset_ARMOR_8, _bp_bank, _bp
         01:DD82  A9 80      			lda.l	#$6000 + ($1FFF & (_tileset_ARMOR_8))
         01:DD84  85 EC      			sta.l	_bp
         01:DD86  A9 76      			lda.h	#$6000 + ($1FFF & (_tileset_ARMOR_8))
         01:DD88  85 ED      			sta.h	_bp
         01:DD8A  A9 03      			lda	#bank(_tileset_ARMOR_8)
         01:DD8C  85 02      			sta	_bp_bank
 9668                        		__ld.wi		___sizeof__tileset_ARMOR_8
         01:DD8E  A9 80      			lda.l	#___sizeof__tileset_ARMOR_8
         01:DD90  A0 00      			ldy.h	#___sizeof__tileset_ARMOR_8
 9669                        		__lsr.wi	1
         01:DD92  42         			say
         01:DD93  4A         			lsr	a
         01:DD94  42         			say
         01:DD95  6A         			ror	a
 9670                        		__st.wmq	_ax
         01:DD96  85 F8      			sta.l	_ax
         01:DD98  84 F9      			sty.h	_ax
 9671                        		 _load_vram.3
         01:DD9A  82         			clx				; Offset to PCE VDC.
         01:DD9B  20 63 FF   			call	load_vram_x
 9672                        	
 9673                        		.dbg	line,	"include\routines_SHOP.c", 273; zenny_amount -= shop_prices[8];
 9674                        		__ld.wm		_shop_prices + 16
         01:DD9E  AD 3B 26   			lda.l	_shop_prices + 16
         01:DDA1  AC 3C 26   			ldy.h	_shop_prices + 16
 9675                        		__isub_st.wmq	_zenny_amount
         01:DDA4  38         			sec
         01:DDA5  49 FF      			eor	#$FF
         01:DDA7  6D 27 26   			adc.l	_zenny_amount
         01:DDAA  8D 27 26   			sta.l	_zenny_amount
         01:DDAD  98         			tya
         01:DDAE  49 FF      			eor	#$FF
         01:DDB0  6D 28 26   			adc.h	_zenny_amount
         01:DDB3  8D 28 26   			sta.h	_zenny_amount
 9676                        	
 9677                        		.dbg	line,	"include\routines_SHOP.c", 274; display_ZENNY();
 9678                        		__call		_display_ZENNY
         01:DDB6  20 45 FF   			call	_display_ZENNY
 9679                        	
 9680                        		.dbg	line,	"include\routines_SHOP.c", 275; }
 9681                        	
 9682                        		.dbg	line,	"include\routines_SHOP.c", 276; }
 9683    01:DDB9             	.LL430	.alias		.LL404
 9684                        	
 9685                        		.dbg	line,	"include\routines_SHOP.c", 278; break;   
 9686    01:DDB9             	.LL429	.alias		.LL404
 9687                        		__bra		.LL404
         01:DDB9  80 63      			bra	.LL404
 9688                        	
 9689                        		.dbg	line,	"include\routines_SHOP.c", 281; // POTION //
 9690                        	
 9691                        		.dbg	line,	"include\routines_SHOP.c", 282; case 9:
 9692    01:DDBB             	.LL431:
 9693                        		__case		9
 9694                        	
 9695                        		.dbg	line,	"include\routines_SHOP.c", 283; if(zenny_amount >= shop_prices[9])
 9696                        		__ld.wm		_zenny_amount
         01:DDBB  AD 27 26   			lda.l	_zenny_amount
         01:DDBE  AC 28 26   			ldy.h	_zenny_amount
 9697                        		__sge_w.wm	_shop_prices + 18
         01:DDC1  CD 3D 26   			cmp.l	_shop_prices + 18		; Subtract memory from Y:A.
         01:DDC4  98         			tya
         01:DDC5  ED 3E 26   			sbc.h	_shop_prices + 18
         01:DDC8  50 02      			bvc	!+
         01:DDCA  49 80      			eor	#$80		; +ve if Y:A >= memory (signed).
         01:DDCC  49 80      	!:		eor	#$80
         01:DDCE  0A         			asl	a
 9698                        		__bfalse	.LL432
         01:DDCF  90 4D      			bcc	.LL432
 9699                        	
 9700                        		.dbg	line,	"include\routines_SHOP.c", 284; {
 9701                        	
 9702                        		.dbg	line,	"include\routines_SHOP.c", 285; potion_amount += 1;
 9703                        		__add_st.umiq	1, _potion_amount
         01:DDD1  EE 22 23   			inc	_potion_amount
 9704                        	
 9705                        		.dbg	line,	"include\routines_SHOP.c", 287; zenny_amount -= shop_prices[9];
 9706                        		__ld.wm		_shop_prices + 18
         01:DDD4  AD 3D 26   			lda.l	_shop_prices + 18
         01:DDD7  AC 3E 26   			ldy.h	_shop_prices + 18
 9707                        		__isub_st.wmq	_zenny_amount
         01:DDDA  38         			sec
         01:DDDB  49 FF      			eor	#$FF
         01:DDDD  6D 27 26   			adc.l	_zenny_amount
         01:DDE0  8D 27 26   			sta.l	_zenny_amount
         01:DDE3  98         			tya
         01:DDE4  49 FF      			eor	#$FF
         01:DDE6  6D 28 26   			adc.h	_zenny_amount
         01:DDE9  8D 28 26   			sta.h	_zenny_amount
 9708                        	
 9709                        		.dbg	line,	"include\routines_SHOP.c", 288; display_POTION();
 9710                        		__call		_display_POTION
         01:DDEC  20 3B FF   			call	_display_POTION
 9711                        	
 9712                        		.dbg	line,	"include\routines_SHOP.c", 289; }
 9713                        	
 9714                        		.dbg	line,	"include\routines_SHOP.c", 291; break;   
 9715    01:DDEF             	.LL432	.alias		.LL404
 9716                        		__bra		.LL404
         01:DDEF  80 2D      			bra	.LL404
 9717                        	
 9718                        		.dbg	line,	"include\routines_SHOP.c", 294; // EXIT //
 9719                        	
 9720                        		.dbg	line,	"include\routines_SHOP.c", 295; case 10:
 9721    01:DDF1             	.LL433:
 9722                        		__case		10
 9723                        	
 9724                        		.dbg	line,	"include\routines_SHOP.c", 296; shop_counter = 0;    
 9725                        		__st.umiq	0, _shop_counter
         01:DDF1  9C CC 23   			stz	_shop_counter
 9726                        	
 9727                        		.dbg	line,	"include\routines_SHOP.c", 297; shop_phase = SHOP_PHASE_EXIT;
 9728                        		__st.umiq	2, _shop_phase
         01:DDF4  A9 02      			lda.l	#2
         01:DDF6  8D CB 23   			sta	_shop_phase
 9729                        	
 9730                        		.dbg	line,	"include\routines_SHOP.c", 299; break;                  
 9731                        		__bra		.LL404
         01:DDF9  80 23      			bra	.LL404
 9732                        	
 9733                        		.dbg	line,	"include\routines_SHOP.c", 300; }
 9734    01:DDFB             	.LL403:
 9735                        		__switch_r.ur	0, 10
         01:DDFB  C9 0B      			cmp	#(10 - 0) + 1
         01:DDFD  90 02      			bcc	!found+
         01:DDFF  A9 0B      	!default:	lda	#(10 - 0) + 1
         01:DE01  0A         	!found:		asl	a
         01:DE02  AA         			tax
         01:DE03  7C 06 DE   			jmp	[!table+, x]
 9736                        	
 9737    01:DE06  12 DA      	!table:		dw	.LL405, .LL408, .LL411, .LL414, .LL417, .LL419, .LL422, .LL425
         01:DE08  80 DA       
         01:DE0A  EE DA       
         01:DE0C  5C DB       
         01:DE0E  CA DB       
         01:DE10  04 DC       
         01:DE12  72 DC       
         01:DE14  E0 DC       
 9738    01:DE16  4E DD      			dw	.LL428, .LL431, .LL433
         01:DE18  BB DD       
         01:DE1A  F1 DD       
 9739    01:DE1C  1E DE      			dw	.LL404
 9740    01:DE1E             	.LL404:
 9741                        	
 9742                        		.dbg	line,	"include\routines_SHOP.c", 301; }
 9743                        	
 9744                        		.dbg	line,	"include\routines_SHOP.c", 302; }
 9745    01:DE1E             	.LL402:
 9746    01:DE1E             	.LL401:
 9747    01:DE1E             	.LL398:
 9748    01:DE1E             	.LL394:
 9749    01:DE1E             	.LL391:
 9750    01:DE1E             	.LL386:
 9751                        		__return	0
         01:DE1E  4C EF FF   			jmp	leave_proc
 9752                        		.dbg	clear
 9753                        		.endp
 9754               7F60     		.data
 9755               230D     		.bss
 9756    F8:230D             	__joypad_BUTTONS_SHOP_loc:
 9757    F8:230D             			ds	1
 9758    F8:230E             	__joypad_BUTTONS_SHOP_end:
 9759               E309     		.code
 9760                        		.pceas
 9761                        	
 9762                        		.dbg	line,	"main.c", 24; #include "include/init.c"
 9763                        		.dbg	line,	"include\init.c", 1; #include "huc.h"
 9764                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 1; #ifndef _hucc_legacy_h
 9765                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 2; #define _hucc_legacy_h
 9766                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 4; /****************************************************************************
 9767                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 5; ; ***************************************************************************
 9768                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 6; ;
 9769                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 7; ; huc.h
 9770                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 8; ;
 9771                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 9; ; HuCC wrapper file to include a default set of HuC-compatible functions.
 9772                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 10; ;
 9773                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 11; ; Copyright John Brandwood 2024.
 9774                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 12; ;
 9775                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 13; ; Distributed under the Boost Software License, Version 1.0.
 9776                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 14; ; (See accompanying file LICENSE_1_0.txt or copy at
 9777                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 15; ;  http://www.boost.org/LICENSE_1_0.txt)
 9778                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 16; ;
 9779                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 17; ; ***************************************************************************
 9780                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 18; ; ***************************************************************************
 9781                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 19; ;
 9782                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 20; ; When the HuCC compiler is invoked with the "--legacy" option to compile old
 9783                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 21; ; projects, then this "huc.h" file is automatically included.
 9784                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 22; ;
 9785                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 23; ; This file includes a set of the individual HuCC headers which correspond to
 9786                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 24; ; HuC's built-in functions and MagicKit library.
 9787                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 25; ;
 9788                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 26; ; New HuCC projects should, preferably, include the specific headers that are
 9789                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 27; ; needed, which will then allow them to replace parts of the standard library
 9790                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 28; ; with newer functions, or they can just manually include this "huc.h" file.
 9791                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 29; ;
 9792                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 30; ; ***************************************************************************
 9793                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 31; ; **************************************************************************/
 9794                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 33; #include "hucc-systemcard.h"
 9795                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 34; #include "hucc-baselib.h"
 9796                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 35; #include "hucc-gfx.h"
 9797                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 36; #include "hucc-string.h"
 9798                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 37; #include "hucc-old-scroll.h"
 9799                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 38; #include "hucc-old-spr.h"
 9800                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 39; #include "hucc-old-map.h"
 9801                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 40; #include "hucc-old-line.h"
 9802                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 42; #endif // _hucc_legacy_h
 9803                        		.dbg	line,	"include\init.c", 2; #include "hucc-scroll.h"
 9804                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 1; #ifndef _hucc_scroll_h
 9805                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 2; #define _hucc_scroll_h
 9806                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 4; /****************************************************************************
 9807                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 5; ; ***************************************************************************
 9808                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 6; ;
 9809                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 7; ; hucc-scroll.h
 9810                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 8; ;
 9811                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 9; ; Routines for a fast split-screen scrolling system.
 9812                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 10; ;
 9813                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 11; ; Copyright John Brandwood 2024.
 9814                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 12; ;
 9815                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 13; ; Distributed under the Boost Software License, Version 1.0.
 9816                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 14; ; (See accompanying file LICENSE_1_0.txt or copy at
 9817                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 15; ;  http://www.boost.org/LICENSE_1_0.txt)
 9818                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 16; ;
 9819                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 17; ; ***************************************************************************
 9820                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 18; ; ***************************************************************************
 9821                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 19; ;
 9822                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 20; ; The maximum number of splits for each screen layer is set in your project's
 9823                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 21; ; "hucc-config.inc" file, with the library having a limit of 128-per-layer.
 9824                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 22; ;
 9825                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 23; ; Your first active split must be defined to start at screen line 0, and then
 9826                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 24; ; the rest of the active splits must be in increasing line order to match the
 9827                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 25; ; way that the PC Engine displays the output image.
 9828                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 26; ;
 9829                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 27; ; You can have disabled splits interleaved with your active splits.
 9830                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 28; ;
 9831                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 29; ; Splits that are normally disabled can be used to create full screen effects
 9832                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 30; ; such as bouncing the screen up and down by adding blank areas at the top or
 9833                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 31; ; bottom of the screen, and then rapidly changing the height of those areas.
 9834                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 32; ;
 9835                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 33; ; ***************************************************************************
 9836                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 34; ; **************************************************************************/
 9837                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 36; // *************
 9838                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 37; // VDC bits for display_flags ...
 9839                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 38; // *************
 9840                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 40; #ifndef BKG_OFF
 9841                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 41; #define BKG_OFF 0x00
 9842                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 42; #endif
 9843                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 44; #ifndef SPR_OFF
 9844                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 45; #define SPR_OFF 0x00
 9845                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 46; #endif
 9846                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 48; #ifndef BKG_ON
 9847                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 49; #define BKG_ON 0x80
 9848                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 50; #endif
 9849                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 52; #ifndef SPR_ON
 9850                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 53; #define SPR_ON 0x40
 9851                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 54; #endif
 9852                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 56; // *************
 9853                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 57; // Functions in hucc-scroll.asm ...
 9854                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 58; // *************
 9855                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 60; #ifdef __HUCC__
 9856                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 62; #asmdef	HUCC_USES_NEW_SCROLL 1
 9857                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 64; extern void __fastcall scroll_split( unsigned char index<_al>, unsigned char screen_line<_ah>, unsigned int bat_x<_bx>, unsigned int bat_y<_cx>, unsigned char display_flags<_dl> );
 9858                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 65; extern void __fastcall sgx_scroll_split( unsigned char index<_al>, unsigned char screen_line<_ah>, unsigned int bat_x<_bx>, unsigned int bat_y<_cx>, unsigned char display_flags<_dl> );
 9859                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 67; extern void __fastcall disable_split( unsigned char index<acc> );
 9860                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 68; extern void __fastcall sgx_disable_split( unsigned char index<acc> );
 9861                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 70; extern void __fastcall __macro disable_all_splits( void );
 9862                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 71; extern void __fastcall __macro sgx_disable_all_splits( void );
 9863                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 73; #asm
 9864                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 74; .macro	_disable_all_splits
 9865                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 75; ldy	#HUCC_PCE_SPLITS - 1
 9866                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 76; !loop:		tya
 9867                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 77; call	_disable_split.1
 9868                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 78; dey
 9869                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 79; bpl	!loop-
 9870                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 80; .endm
 9871                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 82; .macro	_sgx_disable_all_splits
 9872                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 83; ldy	#HUCC_SGX_SPLITS - 1
 9873                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 84; !loop:		tya
 9874                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 85; call	_sgx_disable_split.1
 9875                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 86; dey
 9876                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 87; bpl	!loop-
 9877                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 88; .endm
 9878                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 89; #endasm
 9879                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 91; #endif // __HUCC__
 9880                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 93; #endif // _hucc_scroll_h
 9881                        		.dbg	line,	"include\init.c", 3; #include "hucc-chrmap.h"
 9882                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 1; #ifndef _hucc_chrmap_h
 9883                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 2; #define _hucc_chrmap_h
 9884                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 4; /****************************************************************************
 9885                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 5; ; ***************************************************************************
 9886                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 6; ;
 9887                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 7; ; hucc-chrmap.h
 9888                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 8; ;
 9889                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 9; ; A simple map system based on 8x8 characters (aka "tiles") in BAT format.
 9890                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 10; ;
 9891                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 11; ; Copyright John Brandwood 2025.
 9892                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 12; ;
 9893                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 13; ; Distributed under the Boost Software License, Version 1.0.
 9894                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 14; ; (See accompanying file LICENSE_1_0.txt or copy at
 9895                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 15; ;  http://www.boost.org/LICENSE_1_0.txt)
 9896                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 16; ;
 9897                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 17; ; ***************************************************************************
 9898                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 18; ; ***************************************************************************
 9899                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 19; ;
 9900                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 20; ; The maximum X and Y size for chrmaps is 256 characters (2048 pixels).
 9901                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 21; ;
 9902                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 22; ; The maximum total size for a chrmap is 16KBytes, which allows for maps up
 9903                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 23; ; to 256x32 tiles (2048x256 pixels).
 9904                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 24; ;
 9905                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 25; ; ***************************************************************************
 9906                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 26; ; **************************************************************************/
 9907                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 28; // *************
 9908                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 29; // This code extends the blkmap library ...
 9909                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 30; // *************
 9910                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 32; #include "hucc-blkmap.h"
 9911                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 34; // *************
 9912                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 35; // Functions in chrmap.asm ...
 9913                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 36; // *************
 9914                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 38; #ifdef __HUCC__
 9915                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 40; #asmdef	HUCC_USES_CHRMAP 1
 9916                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 42; extern void __fastcall __nop set_chrmap( unsigned char __far *chrmap<vdc_map_bank:vdc_map_addr>, unsigned char tiles_w<vdc_map_line_w> );
 9917                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 44; extern void __fastcall draw_bat( void );
 9918                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 45; extern void __fastcall scroll_bat( void );
 9919                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 47; extern void __fastcall blit_bat( unsigned char tile_x<map_bat_x>, unsigned char tile_y<map_bat_y>, unsigned char tile_w<map_draw_x>, unsigned char tile_h<map_draw_y> );
 9920                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 49; #ifdef _SGX
 9921                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 51; extern void __fastcall __nop sgx_set_chrmap( unsigned char __far *chrmap<sgx_map_bank:sgx_map_addr>, unsigned char tiles_w<sgx_map_line_w> );
 9922                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 53; extern void __fastcall sgx_draw_bat( void );
 9923                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 54; extern void __fastcall sgx_scroll_bat( void );
 9924                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 56; extern void __fastcall sgx_blit_bat( unsigned char tile_x<map_bat_x>, unsigned char tile_y<map_bat_y>, unsigned char tile_w<map_draw_x>, unsigned char tile_h<map_draw_y> );
 9925                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 58; #endif
 9926                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 60; #endif // __HUCC__
 9927                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 62; #endif // _hucc_chrmap_h
 9928                        		.dbg	line,	"include\init.c", 4; #include "hucc-blkmap.h"
 9929                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 1; #ifndef _hucc_blkmap_h
 9930                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 2; #define _hucc_blkmap_h
 9931                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 4; /****************************************************************************
 9932                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 5; ; ***************************************************************************
 9933                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 6; ;
 9934                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 7; ; hucc-blkmap.h
 9935                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 8; ;
 9936                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 9; ; A map system based on 16x16 meta-tiles (aka "blocks", aka CHR/BLK/MAP).
 9937                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 10; ;
 9938                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 11; ; Copyright John Brandwood 2025.
 9939                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 12; ;
 9940                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 13; ; Distributed under the Boost Software License, Version 1.0.
 9941                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 14; ; (See accompanying file LICENSE_1_0.txt or copy at
 9942                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 15; ;  http://www.boost.org/LICENSE_1_0.txt)
 9943                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 16; ;
 9944                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 17; ; ***************************************************************************
 9945                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 18; ; ***************************************************************************
 9946                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 19; ;
 9947                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 20; ; The maximum X and Y size for blkmaps is 128 blocks (2048 pixels).
 9948                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 21; ;
 9949                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 22; ; The maximum total size for a blkmap is 16KBytes, which allows for maps up
 9950                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 23; ; to 128x128 blocks (2048x2048 pixels).
 9951                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 24; ;
 9952                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 25; ; Huge multi-screen blkmaps are also supported (optionally).
 9953                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 26; ;
 9954                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 27; ; The maximum X and Y for multi-screen maps is 128 screens (32768 pixels).
 9955                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 28; ;
 9956                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 29; ; The maximum total size for a multi-screen map is 8KBytes, which allows for
 9957                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 30; ; a total of 1024 screens.
 9958                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 31; ;
 9959                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 32; ; ***************************************************************************
 9960                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 33; ; **************************************************************************/
 9961                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 35; // *************
 9962                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 36; // Functions in blkmap.asm ...
 9963                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 37; // *************
 9964                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 39; #ifdef __HUCC__
 9965                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 41; #asmdef	HUCC_USES_BLKMAP 1
 9966                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 43; // Current top-left of drawn map in pixels.
 9967                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 44; extern unsigned int   vdc_map_pxl_x;
 9968                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 45; extern unsigned int   vdc_map_pxl_y;
 9969                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 47; // Width and height to draw/scroll in characters (not tiles).
 9970                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 48; extern unsigned char  vdc_map_draw_w;
 9971                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 49; extern unsigned char  vdc_map_draw_h;
 9972                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 51; // Width of map (or multi-screen BAT) in tiles.
 9973                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 52; extern unsigned char  vdc_map_line_w;
 9974                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 54; // Width of map in screens (if multi-screen map).
 9975                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 55; extern unsigned char  vdc_map_scrn_w;
 9976                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 57; // Extra information returned by get_map_block() and sgx_get_map_block(),
 9977                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 58; // which are the collision flags and the mask/overlay sprite for the BLK.
 9978                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 59; extern unsigned char  map_blk_flag;
 9979                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 60; extern unsigned char  map_blk_mask;
 9980                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 62; extern unsigned char  vdc_scr_bank;
 9981                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 63; extern unsigned char *vdc_scr_addr;
 9982                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 65; extern unsigned char  vdc_map_bank;
 9983                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 66; extern unsigned char *vdc_map_addr;
 9984                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 68; extern unsigned char  vdc_blk_bank;
 9985                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 69; extern unsigned char *vdc_blk_addr;
 9986                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 71; extern unsigned char  vdc_tbl_bank;
 9987                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 72; extern unsigned char *vdc_tbl_addr;
 9988                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 74; extern void __fastcall set_blocks( unsigned char __far *blk_def<vdc_blk_bank:vdc_blk_addr>, unsigned char __far *flg_def<vdc_tbl_bank:vdc_tbl_addr>, unsigned char number_of_blocks<_al> );
 9989                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 75; extern void __fastcall __macro set_blkmap( unsigned char __far *blk_map<vdc_map_bank:vdc_map_addr>, unsigned char blocks_w<vdc_map_line_w> );
 9990                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 76; extern void __fastcall __macro set_multimap( unsigned char __far *multi_map<vdc_scr_bank:vdc_scr_addr>, unsigned char screens_w<vdc_map_scrn_w> );
 9991                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 78; extern void __fastcall draw_map( void );
 9992                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 79; extern void __fastcall scroll_map( void );
 9993                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 81; extern void __fastcall blit_map( unsigned char tile_x<map_bat_x>, unsigned char tile_y<map_bat_y>, unsigned char tile_w<map_draw_x>, unsigned char tile_h<map_draw_y> );
 9994                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 83; extern unsigned char __fastcall get_map_block( unsigned int x<map_pxl_x>, unsigned int y<map_pxl_y> );
 9995                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 85; #asm
 9996                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 86; .macro	_set_blkmap.2
 9997                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 87; stz	vdc_scr_bank
 9998                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 88; .endm
 9999                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 90; .macro	_set_multimap.2
10000                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 91; lda	vdc_bat_width
10001                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 92; lsr	a
10002                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 93; sta	vdc_map_line_w
10003                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 94; .endm
10004                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 96; .macro	SCREEN
10005                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 97; db	(((\1) & $1FFF) | $6000) >> 8, bank(\1)
10006                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 98; db	(((\2) & $1FFF) | $4000) >> 8, bank(\2)
10007                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 99; db	(((\3) & $1FFF) | $6000) >> 8, bank(\3)
10008                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 100; dw	(\4)
10009                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 101; .endm
10010                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 102; #endasm
10011                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 104; #ifdef _SGX
10012                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 106; // Current top-left of drawn map in pixels.
10013                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 107; extern unsigned int   sgx_map_pxl_x;
10014                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 108; extern unsigned int   sgx_map_pxl_y;
10015                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 110; // Width and height to draw/scroll in characters (not tiles).
10016                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 111; extern unsigned char  sgx_map_draw_w;
10017                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 112; extern unsigned char  sgx_map_draw_h;
10018                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 114; // Width of map (or multi-screen BAT) in tiles.
10019                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 115; extern unsigned char  sgx_map_line_w;
10020                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 117; // Width of map in screens (if multi-screen map).
10021                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 118; extern unsigned char  sgx_map_scrn_w;
10022                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 120; extern unsigned char  sgx_scr_bank;
10023                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 121; extern unsigned char *sgx_scr_addr;
10024                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 123; extern unsigned char  sgx_map_bank;
10025                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 124; extern unsigned char *sgx_map_addr;
10026                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 126; extern unsigned char  sgx_blk_bank;
10027                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 127; extern unsigned char *sgx_blk_addr;
10028                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 129; extern unsigned char  sgx_tbl_bank;
10029                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 130; extern unsigned char *sgx_tbl_addr;
10030                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 132; extern void __fastcall sgx_set_blocks( unsigned char __far *blk_def<sgx_blk_bank:sgx_blk_addr>, unsigned char __far *flg_def<sgx_tbl_bank:sgx_tbl_addr>, unsigned char number_of_blocks<_al> );
10031                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 133; extern void __fastcall __macro sgx_set_blkmap( unsigned char __far *blk_map<sgx_map_bank:sgx_map_addr>, unsigned char blocks_w<sgx_map_line_w> );
10032                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 134; extern void __fastcall __macro sgx_set_multimap( unsigned char __far *multi_map<sgx_scr_bank:sgx_scr_addr>, unsigned char screens_w<sgx_map_scrn_w> );
10033                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 136; extern void __fastcall sgx_draw_map( void );
10034                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 137; extern void __fastcall sgx_scroll_map( void );
10035                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 139; extern void __fastcall sgx_blit_map( unsigned char tile_x<map_bat_x>, unsigned char tile_y<map_bat_y>, unsigned char tile_w<map_draw_x>, unsigned char tile_h<map_draw_y> );
10036                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 141; extern unsigned char __fastcall sgx_get_map_block( unsigned int x<map_pxl_x>, unsigned int y<map_pxl_y> );
10037                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 143; #asm
10038                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 144; .macro	_sgx_set_blkmap.2
10039                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 145; stz	sgx_scr_bank
10040                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 146; .endm
10041                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 148; .macro	_sgx_set_multimap.2
10042                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 149; lda	sgx_bat_width
10043                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 150; lsr	a
10044                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 151; sta	sgx_map_line_w
10045                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 152; .endm
10046                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 153; #endasm
10047                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 155; #endif
10048                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 157; #endif // __HUCC__
10049                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 159; #endif // _hucc_blkmap_h
10050                        		.dbg	line,	"include\init.c", 13; void init_SYSTEM()
10051                        		.dbg	line,	"include\init.c", 14; {
10052                        	;***********************
10053                        	;***********************
10054                        	
10055                        		.hucc
10056    11:D4A3             		.proc		_init_SYSTEM
10057                        		__enter		_init_SYSTEM
10058                        	
10059                        		.dbg	line,	"include\init.c", 15; // DISABLE DISPLAY //
10060                        	
10061                        		.dbg	line,	"include\init.c", 16; disp_off();
10062                        		__call		_disp_off
         11:D4A3  20 29 E4   			call	_disp_off
10063                        	
10064                        		.dbg	line,	"include\init.c", 18; // VSYNC //
10065                        	
10066                        		.dbg	line,	"include\init.c", 19; vsync();
10067                        		__call		_vsync
         11:D4A6  20 09 E3   			call	_vsync
10068                        	
10069                        		.dbg	line,	"include\init.c", 21; // LOAD DEFAULT FONT //
10070                        	
10071                        		.dbg	line,	"include\init.c", 22; load_default_font();
10072                        		 _load_default_font
         11:D4A9  82         			clx				; Offset to PCE VDC.
         11:D4AA  20 C7 FF   			call	huc_monofont_x
10073                        	
10074                        		.dbg	line,	"include\init.c", 25; // SET VDC 1 SCREEN SIZE (IN TILES) - 32x32 = 256 PIXELS
10075                        	
10076                        		.dbg	line,	"include\init.c", 26; set_screen_size(SCR_SIZE_32x32);
10077                        		__st.umiq	0, _al
         11:D4AD  64 F8      			stz	_al
10078                        		__call		_set_screen_size.1
         11:D4AF  20 31 FF   			call	_set_screen_size.1
10079                        	
10080                        		.dbg	line,	"include\init.c", 29; // SET VDC 2 SCREEN SIZE (IN TILES) - 32x32 = 256 PIXELS
10081                        	
10082                        		.dbg	line,	"include\init.c", 30; sgx_set_screen_size(SCR_SIZE_32x32);
10083                        		__st.umiq	0, _al
         11:D4B2  64 F8      			stz	_al
10084                        		__call		_sgx_set_screen_size.1
         11:D4B4  20 27 FF   			call	_sgx_set_screen_size.1
10085                        	
10086                        		.dbg	line,	"include\init.c", 33; // INIT SPRITE ATTRIBUTE TABLE //
10087                        	
10088                        		.dbg	line,	"include\init.c", 34; init_satb();
10089                        		__call		_init_satb
         11:D4B7  20 B7 E7   			call	_init_satb
10090                        	
10091                        		.dbg	line,	"include\init.c", 37; // ENABLE DISPLAY //
10092                        	
10093                        		.dbg	line,	"include\init.c", 38; //disp_on();
10094                        	
10095                        		.dbg	line,	"include\init.c", 39; }
10096    11:D4BA             	.LL434:
10097                        		__return	0
         11:D4BA  4C EF FF   			jmp	leave_proc
10098                        		.dbg	clear
10099                        		.endp
10100                        		.pceas
10101                        	
10102                        		.dbg	line,	"include\init.c", 42; void init_VARIABLES()
10103                        		.dbg	line,	"include\init.c", 43; {
10104                        	;***********************
10105                        	;***********************
10106                        	
10107                        		.hucc
10108    11:D312             		.proc		_init_VARIABLES
10109                        		__enter		_init_VARIABLES
10110                        	
10111                        		.dbg	line,	"include\init.c", 44; sequence_id = SEQUENCE_GAME; //SEQUENCE_GAME | SEQUENCE_SHOP
10112                        		__st.umiq	2, _sequence_id
         11:D312  A9 02      			lda.l	#2
         11:D314  8D 10 23   			sta	_sequence_id
10113                        	
10114                        		.dbg	line,	"include\init.c", 46; level_id = 1;
10115                        		__st.umiq	1, _level_id
         11:D317  A9 01      			lda.l	#1
         11:D319  8D 12 23   			sta	_level_id
10116                        	
10117                        		.dbg	line,	"include\init.c", 48; key_amount = 0;
10118                        		__st.umiq	0, _key_amount
         11:D31C  9C 21 23   			stz	_key_amount
10119                        	
10120                        		.dbg	line,	"include\init.c", 49; potion_amount = 0;
10121                        		__st.umiq	0, _potion_amount
         11:D31F  9C 22 23   			stz	_potion_amount
10122                        	
10123                        		.dbg	line,	"include\init.c", 50; zenny_amount = 25000;
10124                        		__st.wmiq	25000, _zenny_amount
         11:D322  A9 A8      			lda.l	#25000
         11:D324  8D 27 26   			sta.l	_zenny_amount
         11:D327  A9 61      			lda.h	#25000
         11:D329  8D 28 26   			sta.h	_zenny_amount
10125                        	
10126                        		.dbg	line,	"include\init.c", 52; weapon_level = 1;
10127                        		__st.umiq	1, _weapon_level
         11:D32C  A9 01      			lda.l	#1
         11:D32E  8D 1F 23   			sta	_weapon_level
10128                        	
10129                        		.dbg	line,	"include\init.c", 53; armor_level = 2;
10130                        		__st.umiq	2, _armor_level
         11:D331  A9 02      			lda.l	#2
         11:D333  8D 1E 23   			sta	_armor_level
10131                        	
10132                        		.dbg	line,	"include\init.c", 55; shop_counter = 0;
10133                        		__st.umiq	0, _shop_counter
         11:D336  9C CC 23   			stz	_shop_counter
10134                        	
10135                        		.dbg	line,	"include\init.c", 56; shop_phase = SHOP_PHASE_ENTER;
10136                        		__st.umiq	0, _shop_phase
         11:D339  9C CB 23   			stz	_shop_phase
10137                        	
10138                        		.dbg	line,	"include\init.c", 58; respawn = FALSE;
10139                        		__st.umiq	0, _respawn
         11:D33C  9C 13 23   			stz	_respawn
10140                        	
10141                        		.dbg	line,	"include\init.c", 60; sequence_loaded = FALSE;
10142                        		__st.umiq	0, _sequence_loaded
         11:D33F  9C 11 23   			stz	_sequence_loaded
10143                        	
10144                        		.dbg	line,	"include\init.c", 61; }
10145    11:D342             	.LL435:
10146                        		__return	0
         11:D342  4C EF FF   			jmp	leave_proc
10147                        		.dbg	clear
10148                        		.endp
10149                        		.pceas
10150                        	
10151                        		.dbg	line,	"include\init.c", 64; void init_PLAYER()
10152                        		.dbg	line,	"include\init.c", 65; {
10153                        	;***********************
10154                        	;***********************
10155                        	
10156                        		.hucc
10157    11:D373             		.proc		_init_PLAYER
10158                        		__enter		_init_PLAYER
10159                        	
10160                        		.dbg	line,	"include\init.c", 66; if(player_naked != RESPAWN_SHOP)
10161                        		__ld.umq	_player_naked
         11:D373  AD 1B 23   			lda	_player_naked
10162                        		__neq_b.uiq	2
         11:D376  38         			sec
         11:D377  49 02      			eor	#2
         11:D379  D0 01      			bne	!+
         11:D37B  18         			clc
         11:D37C             	!:
10163                        		__bfalse	.LL437
         11:D37C  90 03      			bcc	.LL437
10164                        	
10165                        		.dbg	line,	"include\init.c", 67; {
10166                        	
10167                        		.dbg	line,	"include\init.c", 68; player_naked = FALSE;
10168                        		__st.umiq	0, _player_naked
         11:D37E  9C 1B 23   			stz	_player_naked
10169                        	
10170                        		.dbg	line,	"include\init.c", 69; }
10171                        	
10172                        		.dbg	line,	"include\init.c", 70; 
10173                        	
10174                        		.dbg	line,	"include\init.c", 71; player_id = 2;
10175    11:D381             	.LL437:
10176                        		__st.umiq	2, _player_id
         11:D381  A9 02      			lda.l	#2
         11:D383  8D 14 23   			sta	_player_id
10177                        	
10178                        		.dbg	line,	"include\init.c", 72; player_axis = AXIS_RIGHT;
10179                        		__st.umiq	0, _player_axis
         11:D386  9C 16 23   			stz	_player_axis
10180                        	
10181                        		.dbg	line,	"include\init.c", 73; player_previous_axis = player_axis;
10182                        		__ld.um		_player_axis
         11:D389  AD 16 23   			lda	_player_axis
         11:D38C  C2         			cly
10183                        		__st.umq	_player_previous_axis
         11:D38D  8D 17 23   			sta	_player_previous_axis
10184                        	
10185                        		.dbg	line,	"include\init.c", 74; player_counter_anim = 0;
10186                        		__st.umiq	0, _player_counter_anim
         11:D390  9C 18 23   			stz	_player_counter_anim
10187                        	
10188                        		.dbg	line,	"include\init.c", 75; player_index_jump = 0;
10189                        		__st.umiq	0, _player_index_jump
         11:D393  9C 19 23   			stz	_player_index_jump
10190                        	
10191                        		.dbg	line,	"include\init.c", 76; player_index_fall = 0;
10192                        		__st.umiq	0, _player_index_fall
         11:D396  9C 1A 23   			stz	_player_index_fall
10193                        	
10194                        		.dbg	line,	"include\init.c", 77; player_state = STATE_IDLE;
10195                        		__st.umiq	0, _player_state
         11:D399  9C 15 23   			stz	_player_state
10196                        	
10197                        		.dbg	line,	"include\init.c", 78; }
10198    11:D39C             	.LL436:
10199                        		__return	0
         11:D39C  4C EF FF   			jmp	leave_proc
10200                        		.dbg	clear
10201                        		.endp
10202                        		.pceas
10203                        	
10204                        		.dbg	line,	"include\init.c", 85; void load_OBJECT_TILES()
10205                        		.dbg	line,	"include\init.c", 86; {
10206                        	;***********************
10207                        	;***********************
10208                        	
10209                        		.hucc
10210    02:D9C5             		.proc		_load_OBJECT_TILES
10211                        		__enter		_load_OBJECT_TILES
10212                        	
10213                        		.dbg	line,	"include\init.c", 87; load_vram(POT1_VRAM_ADR, tiles_SPR_POT , SIZEOF(tiles_SPR_POT) >> 1);
10214                        		__st.wmiq	7168, _di
         02:D9C5  64 F0      			stz.l	_di
         02:D9C7  A9 1C      			lda.h	#7168
         02:D9C9  85 F1      			sta.h	_di
10215                        		__farptr	_tiles_SPR_POT, _bp_bank, _bp
         02:D9CB  A9 60      			lda.l	#$6000 + ($1FFF & (_tiles_SPR_POT))
         02:D9CD  85 EC      			sta.l	_bp
         02:D9CF  A9 65      			lda.h	#$6000 + ($1FFF & (_tiles_SPR_POT))
         02:D9D1  85 ED      			sta.h	_bp
         02:D9D3  A9 10      			lda	#bank(_tiles_SPR_POT)
         02:D9D5  85 02      			sta	_bp_bank
10216                        		__ld.wi		___sizeof__tiles_SPR_POT
         02:D9D7  A9 00      			lda.l	#___sizeof__tiles_SPR_POT
         02:D9D9  A0 04      			ldy.h	#___sizeof__tiles_SPR_POT
10217                        		__lsr.wi	1
         02:D9DB  42         			say
         02:D9DC  4A         			lsr	a
         02:D9DD  42         			say
         02:D9DE  6A         			ror	a
10218                        		__st.wmq	_ax
         02:D9DF  85 F8      			sta.l	_ax
         02:D9E1  84 F9      			sty.h	_ax
10219                        		 _load_vram.3
         02:D9E3  82         			clx				; Offset to PCE VDC.
         02:D9E4  20 63 FF   			call	load_vram_x
10220                        	
10221                        		.dbg	line,	"include\init.c", 88; load_vram(POW_VRAM_ADR, tiles_SPR_POW , TILES_4);
10222                        		__st.wmiq	7680, _di
         02:D9E7  64 F0      			stz.l	_di
         02:D9E9  A9 1E      			lda.h	#7680
         02:D9EB  85 F1      			sta.h	_di
10223                        		__farptr	_tiles_SPR_POW, _bp_bank, _bp
         02:D9ED  A9 60      			lda.l	#$6000 + ($1FFF & (_tiles_SPR_POW))
         02:D9EF  85 EC      			sta.l	_bp
         02:D9F1  A9 69      			lda.h	#$6000 + ($1FFF & (_tiles_SPR_POW))
         02:D9F3  85 ED      			sta.h	_bp
         02:D9F5  A9 10      			lda	#bank(_tiles_SPR_POW)
         02:D9F7  85 02      			sta	_bp_bank
10224                        		__st.wmiq	64, _ax
         02:D9F9  A9 40      			lda.l	#64
         02:D9FB  85 F8      			sta.l	_ax
         02:D9FD  64 F9      			stz.h	_ax
10225                        		 _load_vram.3
         02:D9FF  82         			clx				; Offset to PCE VDC.
         02:DA00  20 63 FF   			call	load_vram_x
10226                        	
10227                        		.dbg	line,	"include\init.c", 89; load_vram(GRAY_KEY_VRAM_ADR, tiles_SPR_GRAY_KEY , TILES_4);
10228                        		__st.wmiq	7744, _di
         02:DA03  A9 40      			lda.l	#7744
         02:DA05  85 F0      			sta.l	_di
         02:DA07  A9 1E      			lda.h	#7744
         02:DA09  85 F1      			sta.h	_di
10229                        		__farptr	_tiles_SPR_GRAY_KEY, _bp_bank, _bp
         02:DA0B  A9 E0      			lda.l	#$6000 + ($1FFF & (_tiles_SPR_GRAY_KEY))
         02:DA0D  85 EC      			sta.l	_bp
         02:DA0F  A9 62      			lda.h	#$6000 + ($1FFF & (_tiles_SPR_GRAY_KEY))
         02:DA11  85 ED      			sta.h	_bp
         02:DA13  A9 10      			lda	#bank(_tiles_SPR_GRAY_KEY)
         02:DA15  85 02      			sta	_bp_bank
10230                        		__st.wmiq	64, _ax
         02:DA17  A9 40      			lda.l	#64
         02:DA19  85 F8      			sta.l	_ax
         02:DA1B  64 F9      			stz.h	_ax
10231                        		 _load_vram.3
         02:DA1D  82         			clx				; Offset to PCE VDC.
         02:DA1E  20 63 FF   			call	load_vram_x
10232                        	
10233                        		.dbg	line,	"include\init.c", 90; load_vram(GOLD_KEY_VRAM_ADR, tiles_SPR_GOLD_KEY , TILES_4);
10234                        		__st.wmiq	7808, _di
         02:DA21  A9 80      			lda.l	#7808
         02:DA23  85 F0      			sta.l	_di
         02:DA25  A9 1E      			lda.h	#7808
         02:DA27  85 F1      			sta.h	_di
10235                        		__farptr	_tiles_SPR_GOLD_KEY, _bp_bank, _bp
         02:DA29  A9 60      			lda.l	#$6000 + ($1FFF & (_tiles_SPR_GOLD_KEY))
         02:DA2B  85 EC      			sta.l	_bp
         02:DA2D  A9 63      			lda.h	#$6000 + ($1FFF & (_tiles_SPR_GOLD_KEY))
         02:DA2F  85 ED      			sta.h	_bp
         02:DA31  A9 10      			lda	#bank(_tiles_SPR_GOLD_KEY)
         02:DA33  85 02      			sta	_bp_bank
10236                        		__st.wmiq	64, _ax
         02:DA35  A9 40      			lda.l	#64
         02:DA37  85 F8      			sta.l	_ax
         02:DA39  64 F9      			stz.h	_ax
10237                        		 _load_vram.3
         02:DA3B  82         			clx				; Offset to PCE VDC.
         02:DA3C  20 63 FF   			call	load_vram_x
10238                        	
10239                        		.dbg	line,	"include\init.c", 91; load_vram(LIFE_VRAM_ADR, tiles_SPR_LIFE , TILES_4);
10240                        		__st.wmiq	7872, _di
         02:DA3F  A9 C0      			lda.l	#7872
         02:DA41  85 F0      			sta.l	_di
         02:DA43  A9 1E      			lda.h	#7872
         02:DA45  85 F1      			sta.h	_di
10241                        		__farptr	_tiles_SPR_LIFE, _bp_bank, _bp
         02:DA47  A9 60      			lda.l	#$6000 + ($1FFF & (_tiles_SPR_LIFE))
         02:DA49  85 EC      			sta.l	_bp
         02:DA4B  A9 64      			lda.h	#$6000 + ($1FFF & (_tiles_SPR_LIFE))
         02:DA4D  85 ED      			sta.h	_bp
         02:DA4F  A9 10      			lda	#bank(_tiles_SPR_LIFE)
         02:DA51  85 02      			sta	_bp_bank
10242                        		__st.wmiq	64, _ax
         02:DA53  A9 40      			lda.l	#64
         02:DA55  85 F8      			sta.l	_ax
         02:DA57  64 F9      			stz.h	_ax
10243                        		 _load_vram.3
         02:DA59  82         			clx				; Offset to PCE VDC.
         02:DA5A  20 63 FF   			call	load_vram_x
10244                        	
10245                        		.dbg	line,	"include\init.c", 92; load_vram(COIN_1_VRAM_ADR, tiles_SPR_COIN_1 , TILES_4);
10246                        		__st.wmiq	7936, _di
         02:DA5D  64 F0      			stz.l	_di
         02:DA5F  A9 1F      			lda.h	#7936
         02:DA61  85 F1      			sta.h	_di
10247                        		__farptr	_tiles_SPR_COIN_1, _bp_bank, _bp
         02:DA63  A9 E0      			lda.l	#$6000 + ($1FFF & (_tiles_SPR_COIN_1))
         02:DA65  85 EC      			sta.l	_bp
         02:DA67  A9 7E      			lda.h	#$6000 + ($1FFF & (_tiles_SPR_COIN_1))
         02:DA69  85 ED      			sta.h	_bp
         02:DA6B  A9 0F      			lda	#bank(_tiles_SPR_COIN_1)
         02:DA6D  85 02      			sta	_bp_bank
10248                        		__st.wmiq	64, _ax
         02:DA6F  A9 40      			lda.l	#64
         02:DA71  85 F8      			sta.l	_ax
         02:DA73  64 F9      			stz.h	_ax
10249                        		 _load_vram.3
         02:DA75  82         			clx				; Offset to PCE VDC.
         02:DA76  20 63 FF   			call	load_vram_x
10250                        	
10251                        		.dbg	line,	"include\init.c", 93; load_vram(COIN_5_VRAM_ADR, tiles_SPR_COIN_5 , TILES_4);
10252                        		__st.wmiq	8000, _di
         02:DA79  A9 40      			lda.l	#8000
         02:DA7B  85 F0      			sta.l	_di
         02:DA7D  A9 1F      			lda.h	#8000
         02:DA7F  85 F1      			sta.h	_di
10253                        		__farptr	_tiles_SPR_COIN_5, _bp_bank, _bp
         02:DA81  A9 60      			lda.l	#$6000 + ($1FFF & (_tiles_SPR_COIN_5))
         02:DA83  85 EC      			sta.l	_bp
         02:DA85  A9 7F      			lda.h	#$6000 + ($1FFF & (_tiles_SPR_COIN_5))
         02:DA87  85 ED      			sta.h	_bp
         02:DA89  A9 0F      			lda	#bank(_tiles_SPR_COIN_5)
         02:DA8B  85 02      			sta	_bp_bank
10254                        		__st.wmiq	64, _ax
         02:DA8D  A9 40      			lda.l	#64
         02:DA8F  85 F8      			sta.l	_ax
         02:DA91  64 F9      			stz.h	_ax
10255                        		 _load_vram.3
         02:DA93  82         			clx				; Offset to PCE VDC.
         02:DA94  20 63 FF   			call	load_vram_x
10256                        	
10257                        		.dbg	line,	"include\init.c", 94; load_vram(COIN_10_VRAM_ADR, tiles_SPR_COIN_10 , TILES_4);
10258                        		__st.wmiq	8064, _di
         02:DA97  A9 80      			lda.l	#8064
         02:DA99  85 F0      			sta.l	_di
         02:DA9B  A9 1F      			lda.h	#8064
         02:DA9D  85 F1      			sta.h	_di
10259                        		__farptr	_tiles_SPR_COIN_10, _bp_bank, _bp
         02:DA9F  A9 E0      			lda.l	#$6000 + ($1FFF & (_tiles_SPR_COIN_10))
         02:DAA1  85 EC      			sta.l	_bp
         02:DAA3  A9 7F      			lda.h	#$6000 + ($1FFF & (_tiles_SPR_COIN_10))
         02:DAA5  85 ED      			sta.h	_bp
         02:DAA7  A9 0F      			lda	#bank(_tiles_SPR_COIN_10)
         02:DAA9  85 02      			sta	_bp_bank
10260                        		__st.wmiq	64, _ax
         02:DAAB  A9 40      			lda.l	#64
         02:DAAD  85 F8      			sta.l	_ax
         02:DAAF  64 F9      			stz.h	_ax
10261                        		 _load_vram.3
         02:DAB1  82         			clx				; Offset to PCE VDC.
         02:DAB2  20 63 FF   			call	load_vram_x
10262                        	
10263                        		.dbg	line,	"include\init.c", 95; load_vram(COIN_50_VRAM_ADR, tiles_SPR_COIN_50 , TILES_4);
10264                        		__st.wmiq	8128, _di
         02:DAB5  A9 C0      			lda.l	#8128
         02:DAB7  85 F0      			sta.l	_di
         02:DAB9  A9 1F      			lda.h	#8128
         02:DABB  85 F1      			sta.h	_di
10265                        		__farptr	_tiles_SPR_COIN_50, _bp_bank, _bp
         02:DABD  A9 60      			lda.l	#$6000 + ($1FFF & (_tiles_SPR_COIN_50))
         02:DABF  85 EC      			sta.l	_bp
         02:DAC1  A9 60      			lda.h	#$6000 + ($1FFF & (_tiles_SPR_COIN_50))
         02:DAC3  85 ED      			sta.h	_bp
         02:DAC5  A9 10      			lda	#bank(_tiles_SPR_COIN_50)
         02:DAC7  85 02      			sta	_bp_bank
10266                        		__st.wmiq	64, _ax
         02:DAC9  A9 40      			lda.l	#64
         02:DACB  85 F8      			sta.l	_ax
         02:DACD  64 F9      			stz.h	_ax
10267                        		 _load_vram.3
         02:DACF  82         			clx				; Offset to PCE VDC.
         02:DAD0  20 63 FF   			call	load_vram_x
10268                        	
10269                        		.dbg	line,	"include\init.c", 96; load_vram(COIN_100_VRAM_ADR, tiles_SPR_COIN_100 , TILES_4);
10270                        		__st.wmiq	8192, _di
         02:DAD3  64 F0      			stz.l	_di
         02:DAD5  A9 20      			lda.h	#8192
         02:DAD7  85 F1      			sta.h	_di
10271                        		__farptr	_tiles_SPR_COIN_100, _bp_bank, _bp
         02:DAD9  A9 E0      			lda.l	#$6000 + ($1FFF & (_tiles_SPR_COIN_100))
         02:DADB  85 EC      			sta.l	_bp
         02:DADD  A9 60      			lda.h	#$6000 + ($1FFF & (_tiles_SPR_COIN_100))
         02:DADF  85 ED      			sta.h	_bp
         02:DAE1  A9 10      			lda	#bank(_tiles_SPR_COIN_100)
         02:DAE3  85 02      			sta	_bp_bank
10272                        		__st.wmiq	64, _ax
         02:DAE5  A9 40      			lda.l	#64
         02:DAE7  85 F8      			sta.l	_ax
         02:DAE9  64 F9      			stz.h	_ax
10273                        		 _load_vram.3
         02:DAEB  82         			clx				; Offset to PCE VDC.
         02:DAEC  20 63 FF   			call	load_vram_x
10274                        	
10275                        		.dbg	line,	"include\init.c", 97; load_vram(COIN_500_VRAM_ADR, tiles_SPR_COIN_500 , TILES_4);
10276                        		__st.wmiq	8256, _di
         02:DAEF  A9 40      			lda.l	#8256
         02:DAF1  85 F0      			sta.l	_di
         02:DAF3  A9 20      			lda.h	#8256
         02:DAF5  85 F1      			sta.h	_di
10277                        		__farptr	_tiles_SPR_COIN_500, _bp_bank, _bp
         02:DAF7  A9 60      			lda.l	#$6000 + ($1FFF & (_tiles_SPR_COIN_500))
         02:DAF9  85 EC      			sta.l	_bp
         02:DAFB  A9 61      			lda.h	#$6000 + ($1FFF & (_tiles_SPR_COIN_500))
         02:DAFD  85 ED      			sta.h	_bp
         02:DAFF  A9 10      			lda	#bank(_tiles_SPR_COIN_500)
         02:DB01  85 02      			sta	_bp_bank
10278                        		__st.wmiq	64, _ax
         02:DB03  A9 40      			lda.l	#64
         02:DB05  85 F8      			sta.l	_ax
         02:DB07  64 F9      			stz.h	_ax
10279                        		 _load_vram.3
         02:DB09  82         			clx				; Offset to PCE VDC.
         02:DB0A  20 63 FF   			call	load_vram_x
10280                        	
10281                        		.dbg	line,	"include\init.c", 98; load_vram(COIN_1000_VRAM_ADR, tiles_SPR_COIN_1000 , TILES_4);
10282                        		__st.wmiq	8320, _di
         02:DB0D  A9 80      			lda.l	#8320
         02:DB0F  85 F0      			sta.l	_di
         02:DB11  A9 20      			lda.h	#8320
         02:DB13  85 F1      			sta.h	_di
10283                        		__farptr	_tiles_SPR_COIN_1000, _bp_bank, _bp
         02:DB15  A9 E0      			lda.l	#$6000 + ($1FFF & (_tiles_SPR_COIN_1000))
         02:DB17  85 EC      			sta.l	_bp
         02:DB19  A9 61      			lda.h	#$6000 + ($1FFF & (_tiles_SPR_COIN_1000))
         02:DB1B  85 ED      			sta.h	_bp
         02:DB1D  A9 10      			lda	#bank(_tiles_SPR_COIN_1000)
         02:DB1F  85 02      			sta	_bp_bank
10284                        		__st.wmiq	64, _ax
         02:DB21  A9 40      			lda.l	#64
         02:DB23  85 F8      			sta.l	_ax
         02:DB25  64 F9      			stz.h	_ax
10285                        		 _load_vram.3
         02:DB27  82         			clx				; Offset to PCE VDC.
         02:DB28  20 63 FF   			call	load_vram_x
10286                        	
10287                        		.dbg	line,	"include\init.c", 99; load_vram(STAR_VRAM_ADR, tiles_SPR_STAR , TILES_4);
10288                        		__st.wmiq	8384, _di
         02:DB2B  A9 C0      			lda.l	#8384
         02:DB2D  85 F0      			sta.l	_di
         02:DB2F  A9 20      			lda.h	#8384
         02:DB31  85 F1      			sta.h	_di
10289                        		__farptr	_tiles_SPR_STAR, _bp_bank, _bp
         02:DB33  A9 E0      			lda.l	#$6000 + ($1FFF & (_tiles_SPR_STAR))
         02:DB35  85 EC      			sta.l	_bp
         02:DB37  A9 69      			lda.h	#$6000 + ($1FFF & (_tiles_SPR_STAR))
         02:DB39  85 ED      			sta.h	_bp
         02:DB3B  A9 10      			lda	#bank(_tiles_SPR_STAR)
         02:DB3D  85 02      			sta	_bp_bank
10290                        		__st.wmiq	64, _ax
         02:DB3F  A9 40      			lda.l	#64
         02:DB41  85 F8      			sta.l	_ax
         02:DB43  64 F9      			stz.h	_ax
10291                        		 _load_vram.3
         02:DB45  82         			clx				; Offset to PCE VDC.
         02:DB46  20 63 FF   			call	load_vram_x
10292                        	
10293                        		.dbg	line,	"include\init.c", 100; load_vram(OCTOPUS_VRAM_ADR, tiles_SPR_OCTOPUS , TILES_4);
10294                        		__st.wmiq	8448, _di
         02:DB49  64 F0      			stz.l	_di
         02:DB4B  A9 21      			lda.h	#8448
         02:DB4D  85 F1      			sta.h	_di
10295                        		__farptr	_tiles_SPR_OCTOPUS, _bp_bank, _bp
         02:DB4F  A9 E0      			lda.l	#$6000 + ($1FFF & (_tiles_SPR_OCTOPUS))
         02:DB51  85 EC      			sta.l	_bp
         02:DB53  A9 64      			lda.h	#$6000 + ($1FFF & (_tiles_SPR_OCTOPUS))
         02:DB55  85 ED      			sta.h	_bp
         02:DB57  A9 10      			lda	#bank(_tiles_SPR_OCTOPUS)
         02:DB59  85 02      			sta	_bp_bank
10296                        		__st.wmiq	64, _ax
         02:DB5B  A9 40      			lda.l	#64
         02:DB5D  85 F8      			sta.l	_ax
         02:DB5F  64 F9      			stz.h	_ax
10297                        		 _load_vram.3
         02:DB61  82         			clx				; Offset to PCE VDC.
         02:DB62  20 63 FF   			call	load_vram_x
10298                        	
10299                        		.dbg	line,	"include\init.c", 101; load_vram(FRUIT_VRAM_ADR, tiles_SPR_FRUIT , TILES_4);
10300                        		__st.wmiq	8512, _di
         02:DB65  A9 40      			lda.l	#8512
         02:DB67  85 F0      			sta.l	_di
         02:DB69  A9 21      			lda.h	#8512
         02:DB6B  85 F1      			sta.h	_di
10301                        		__farptr	_tiles_SPR_FRUIT, _bp_bank, _bp
         02:DB6D  A9 60      			lda.l	#$6000 + ($1FFF & (_tiles_SPR_FRUIT))
         02:DB6F  85 EC      			sta.l	_bp
         02:DB71  A9 62      			lda.h	#$6000 + ($1FFF & (_tiles_SPR_FRUIT))
         02:DB73  85 ED      			sta.h	_bp
         02:DB75  A9 10      			lda	#bank(_tiles_SPR_FRUIT)
         02:DB77  85 02      			sta	_bp_bank
10302                        		__st.wmiq	64, _ax
         02:DB79  A9 40      			lda.l	#64
         02:DB7B  85 F8      			sta.l	_ax
         02:DB7D  64 F9      			stz.h	_ax
10303                        		 _load_vram.3
         02:DB7F  82         			clx				; Offset to PCE VDC.
         02:DB80  20 63 FF   			call	load_vram_x
10304                        	
10305                        		.dbg	line,	"include\init.c", 102; load_vram(BARREL_VRAM_ADR, tiles_SPR_BARREL , TILES_4);
10306                        		__st.wmiq	8576, _di
         02:DB83  A9 80      			lda.l	#8576
         02:DB85  85 F0      			sta.l	_di
         02:DB87  A9 21      			lda.h	#8576
         02:DB89  85 F1      			sta.h	_di
10307                        		__farptr	_tiles_SPR_BARREL, _bp_bank, _bp
         02:DB8B  A9 60      			lda.l	#$6000 + ($1FFF & (_tiles_SPR_BARREL))
         02:DB8D  85 EC      			sta.l	_bp
         02:DB8F  A9 72      			lda.h	#$6000 + ($1FFF & (_tiles_SPR_BARREL))
         02:DB91  85 ED      			sta.h	_bp
         02:DB93  A9 0F      			lda	#bank(_tiles_SPR_BARREL)
         02:DB95  85 02      			sta	_bp_bank
10308                        		__st.wmiq	64, _ax
         02:DB97  A9 40      			lda.l	#64
         02:DB99  85 F8      			sta.l	_ax
         02:DB9B  64 F9      			stz.h	_ax
10309                        		 _load_vram.3
         02:DB9D  82         			clx				; Offset to PCE VDC.
         02:DB9E  20 63 FF   			call	load_vram_x
10310                        	
10311                        		.dbg	line,	"include\init.c", 103; load_vram(HOURGLASS_VRAM_ADR, tiles_SPR_HOURGLASS , TILES_4);
10312                        		__st.wmiq	8640, _di
         02:DBA1  A9 C0      			lda.l	#8640
         02:DBA3  85 F0      			sta.l	_di
         02:DBA5  A9 21      			lda.h	#8640
         02:DBA7  85 F1      			sta.h	_di
10313                        		__farptr	_tiles_SPR_HOURGLASS, _bp_bank, _bp
         02:DBA9  A9 E0      			lda.l	#$6000 + ($1FFF & (_tiles_SPR_HOURGLASS))
         02:DBAB  85 EC      			sta.l	_bp
         02:DBAD  A9 63      			lda.h	#$6000 + ($1FFF & (_tiles_SPR_HOURGLASS))
         02:DBAF  85 ED      			sta.h	_bp
         02:DBB1  A9 10      			lda	#bank(_tiles_SPR_HOURGLASS)
         02:DBB3  85 02      			sta	_bp_bank
10314                        		__st.wmiq	64, _ax
         02:DBB5  A9 40      			lda.l	#64
         02:DBB7  85 F8      			sta.l	_ax
         02:DBB9  64 F9      			stz.h	_ax
10315                        		 _load_vram.3
         02:DBBB  82         			clx				; Offset to PCE VDC.
         02:DBBC  20 63 FF   			call	load_vram_x
10316                        	
10317                        		.dbg	line,	"include\init.c", 104; load_vram(BAMBOO_VRAM_ADR, tiles_SPR_BAMBOO , TILES_4);
10318                        		__st.wmiq	8704, _di
         02:DBBF  64 F0      			stz.l	_di
         02:DBC1  A9 22      			lda.h	#8704
         02:DBC3  85 F1      			sta.h	_di
10319                        		__farptr	_tiles_SPR_BAMBOO, _bp_bank, _bp
         02:DBC5  A9 60      			lda.l	#$6000 + ($1FFF & (_tiles_SPR_BAMBOO))
         02:DBC7  85 EC      			sta.l	_bp
         02:DBC9  A9 6A      			lda.h	#$6000 + ($1FFF & (_tiles_SPR_BAMBOO))
         02:DBCB  85 ED      			sta.h	_bp
         02:DBCD  A9 10      			lda	#bank(_tiles_SPR_BAMBOO)
         02:DBCF  85 02      			sta	_bp_bank
10320                        		__st.wmiq	64, _ax
         02:DBD1  A9 40      			lda.l	#64
         02:DBD3  85 F8      			sta.l	_ax
         02:DBD5  64 F9      			stz.h	_ax
10321                        		 _load_vram.3
         02:DBD7  82         			clx				; Offset to PCE VDC.
         02:DBD8  20 63 FF   			call	load_vram_x
10322                        	
10323                        		.dbg	line,	"include\init.c", 105; load_vram(YASHICHI_VRAM_ADR, tiles_SPR_YASHICHI , TILES_4);
10324                        		__st.wmiq	8768, _di
         02:DBDB  A9 40      			lda.l	#8768
         02:DBDD  85 F0      			sta.l	_di
         02:DBDF  A9 22      			lda.h	#8768
         02:DBE1  85 F1      			sta.h	_di
10325                        		__farptr	_tiles_SPR_YASHICHI, _bp_bank, _bp
         02:DBE3  A9 E0      			lda.l	#$6000 + ($1FFF & (_tiles_SPR_YASHICHI))
         02:DBE5  85 EC      			sta.l	_bp
         02:DBE7  A9 6A      			lda.h	#$6000 + ($1FFF & (_tiles_SPR_YASHICHI))
         02:DBE9  85 ED      			sta.h	_bp
         02:DBEB  A9 10      			lda	#bank(_tiles_SPR_YASHICHI)
         02:DBED  85 02      			sta	_bp_bank
10326                        		__st.wmiq	64, _ax
         02:DBEF  A9 40      			lda.l	#64
         02:DBF1  85 F8      			sta.l	_ax
         02:DBF3  64 F9      			stz.h	_ax
10327                        		 _load_vram.3
         02:DBF5  82         			clx				; Offset to PCE VDC.
         02:DBF6  20 63 FF   			call	load_vram_x
10328                        	
10329                        		.dbg	line,	"include\init.c", 106; load_vram(ELEPHANT_VRAM_ADR, tiles_SPR_ELEPHANT , TILES_4);
10330                        		__st.wmiq	8832, _di
         02:DBF9  A9 80      			lda.l	#8832
         02:DBFB  85 F0      			sta.l	_di
         02:DBFD  A9 22      			lda.h	#8832
         02:DBFF  85 F1      			sta.h	_di
10331                        		__farptr	_tiles_SPR_ELEPHANT, _bp_bank, _bp
         02:DC01  A9 60      			lda.l	#$6000 + ($1FFF & (_tiles_SPR_ELEPHANT))
         02:DC03  85 EC      			sta.l	_bp
         02:DC05  A9 6B      			lda.h	#$6000 + ($1FFF & (_tiles_SPR_ELEPHANT))
         02:DC07  85 ED      			sta.h	_bp
         02:DC09  A9 10      			lda	#bank(_tiles_SPR_ELEPHANT)
         02:DC0B  85 02      			sta	_bp_bank
10332                        		__st.wmiq	64, _ax
         02:DC0D  A9 40      			lda.l	#64
         02:DC0F  85 F8      			sta.l	_ax
         02:DC11  64 F9      			stz.h	_ax
10333                        		 _load_vram.3
         02:DC13  82         			clx				; Offset to PCE VDC.
         02:DC14  20 63 FF   			call	load_vram_x
10334                        	
10335                        		.dbg	line,	"include\init.c", 107; load_vram(DRAGONFLY_VRAM_ADR, tiles_SPR_DRAGONFLY , TILES_4);
10336                        		__st.wmiq	8896, _di
         02:DC17  A9 C0      			lda.l	#8896
         02:DC19  85 F0      			sta.l	_di
         02:DC1B  A9 22      			lda.h	#8896
         02:DC1D  85 F1      			sta.h	_di
10337                        		__farptr	_tiles_SPR_DRAGONFLY, _bp_bank, _bp
         02:DC1F  A9 E0      			lda.l	#$6000 + ($1FFF & (_tiles_SPR_DRAGONFLY))
         02:DC21  85 EC      			sta.l	_bp
         02:DC23  A9 6B      			lda.h	#$6000 + ($1FFF & (_tiles_SPR_DRAGONFLY))
         02:DC25  85 ED      			sta.h	_bp
         02:DC27  A9 10      			lda	#bank(_tiles_SPR_DRAGONFLY)
         02:DC29  85 02      			sta	_bp_bank
10338                        		__st.wmiq	64, _ax
         02:DC2B  A9 40      			lda.l	#64
         02:DC2D  85 F8      			sta.l	_ax
         02:DC2F  64 F9      			stz.h	_ax
10339                        		 _load_vram.3
         02:DC31  82         			clx				; Offset to PCE VDC.
         02:DC32  20 63 FF   			call	load_vram_x
10340                        	
10341                        		.dbg	line,	"include\init.c", 108; load_vram(COW_VRAM_ADR, tiles_SPR_COW , TILES_4);
10342                        		__st.wmiq	8960, _di
         02:DC35  64 F0      			stz.l	_di
         02:DC37  A9 23      			lda.h	#8960
         02:DC39  85 F1      			sta.h	_di
10343                        		__farptr	_tiles_SPR_COW, _bp_bank, _bp
         02:DC3B  A9 60      			lda.l	#$6000 + ($1FFF & (_tiles_SPR_COW))
         02:DC3D  85 EC      			sta.l	_bp
         02:DC3F  A9 6C      			lda.h	#$6000 + ($1FFF & (_tiles_SPR_COW))
         02:DC41  85 ED      			sta.h	_bp
         02:DC43  A9 10      			lda	#bank(_tiles_SPR_COW)
         02:DC45  85 02      			sta	_bp_bank
10344                        		__st.wmiq	64, _ax
         02:DC47  A9 40      			lda.l	#64
         02:DC49  85 F8      			sta.l	_ax
         02:DC4B  64 F9      			stz.h	_ax
10345                        		 _load_vram.3
         02:DC4D  82         			clx				; Offset to PCE VDC.
         02:DC4E  20 63 FF   			call	load_vram_x
10346                        	
10347                        		.dbg	line,	"include\init.c", 109; load_vram(MOBICHAN_VRAM_ADR, tiles_SPR_MOBICHAN , TILES_4);
10348                        		__st.wmiq	9024, _di
         02:DC51  A9 40      			lda.l	#9024
         02:DC53  85 F0      			sta.l	_di
         02:DC55  A9 23      			lda.h	#9024
         02:DC57  85 F1      			sta.h	_di
10349                        		__farptr	_tiles_SPR_MOBICHAN, _bp_bank, _bp
         02:DC59  A9 E0      			lda.l	#$6000 + ($1FFF & (_tiles_SPR_MOBICHAN))
         02:DC5B  85 EC      			sta.l	_bp
         02:DC5D  A9 6C      			lda.h	#$6000 + ($1FFF & (_tiles_SPR_MOBICHAN))
         02:DC5F  85 ED      			sta.h	_bp
         02:DC61  A9 10      			lda	#bank(_tiles_SPR_MOBICHAN)
         02:DC63  85 02      			sta	_bp_bank
10350                        		__st.wmiq	64, _ax
         02:DC65  A9 40      			lda.l	#64
         02:DC67  85 F8      			sta.l	_ax
         02:DC69  64 F9      			stz.h	_ax
10351                        		 _load_vram.3
         02:DC6B  82         			clx				; Offset to PCE VDC.
         02:DC6C  20 63 FF   			call	load_vram_x
10352                        	
10353                        		.dbg	line,	"include\init.c", 110; }
10354    02:DC6F             	.LL438:
10355                        		__return	0
         02:DC6F  4C EF FF   			jmp	leave_proc
10356                        		.dbg	clear
10357                        		.endp
10358                        		.pceas
10359                        	
10360                        		.dbg	line,	"include\init.c", 113; void load_CHEST_TILES()
10361                        		.dbg	line,	"include\init.c", 114; {
10362                        	;***********************
10363                        	;***********************
10364                        	
10365                        		.hucc
10366    11:D3CA             		.proc		_load_CHEST_TILES
10367                        		__enter		_load_CHEST_TILES
10368                        	
10369                        		.dbg	line,	"include\init.c", 115; load_vram(CHEST_VRAM_ADR, tiles_SPR_CHEST , SIZEOF(tiles_SPR_CHEST) >> 1);
10370                        		__st.wmiq	9216, _di
         11:D3CA  64 F0      			stz.l	_di
         11:D3CC  A9 24      			lda.h	#9216
         11:D3CE  85 F1      			sta.h	_di
10371                        		__farptr	_tiles_SPR_CHEST, _bp_bank, _bp
         11:D3D0  A9 E0      			lda.l	#$6000 + ($1FFF & (_tiles_SPR_CHEST))
         11:D3D2  85 EC      			sta.l	_bp
         11:D3D4  A9 72      			lda.h	#$6000 + ($1FFF & (_tiles_SPR_CHEST))
         11:D3D6  85 ED      			sta.h	_bp
         11:D3D8  A9 0F      			lda	#bank(_tiles_SPR_CHEST)
         11:D3DA  85 02      			sta	_bp_bank
10372                        		__ld.wi		___sizeof__tiles_SPR_CHEST
         11:D3DC  A9 00      			lda.l	#___sizeof__tiles_SPR_CHEST
         11:D3DE  A0 0C      			ldy.h	#___sizeof__tiles_SPR_CHEST
10373                        		__lsr.wi	1
         11:D3E0  42         			say
         11:D3E1  4A         			lsr	a
         11:D3E2  42         			say
         11:D3E3  6A         			ror	a
10374                        		__st.wmq	_ax
         11:D3E4  85 F8      			sta.l	_ax
         11:D3E6  84 F9      			sty.h	_ax
10375                        		 _load_vram.3
         11:D3E8  82         			clx				; Offset to PCE VDC.
         11:D3E9  20 63 FF   			call	load_vram_x
10376                        	
10377                        		.dbg	line,	"include\init.c", 116; }
10378    11:D3EC             	.LL439:
10379                        		__return	0
         11:D3EC  4C EF FF   			jmp	leave_proc
10380                        		.dbg	clear
10381                        		.endp
10382                        		.pceas
10383                        	
10384                        		.dbg	line,	"include\init.c", 119; void load_NPC_TILES()
10385                        		.dbg	line,	"include\init.c", 120; {
10386                        	;***********************
10387                        	;***********************
10388                        	
10389                        		.hucc
10390    11:D3EF             		.proc		_load_NPC_TILES
10391                        		__enter		_load_NPC_TILES
10392                        	
10393                        		.dbg	line,	"include\init.c", 121; load_vram(NPC_VRAM_ADR, tiles_SPR_NPC , SIZEOF(tiles_SPR_NPC) >> 1);
10394                        		__st.wmiq	10752, _di
         11:D3EF  64 F0      			stz.l	_di
         11:D3F1  A9 2A      			lda.h	#10752
         11:D3F3  85 F1      			sta.h	_di
10395                        		__farptr	_tiles_SPR_NPC, _bp_bank, _bp
         11:D3F5  A9 60      			lda.l	#$6000 + ($1FFF & (_tiles_SPR_NPC))
         11:D3F7  85 EC      			sta.l	_bp
         11:D3F9  A9 71      			lda.h	#$6000 + ($1FFF & (_tiles_SPR_NPC))
         11:D3FB  85 ED      			sta.h	_bp
         11:D3FD  A9 10      			lda	#bank(_tiles_SPR_NPC)
         11:D3FF  85 02      			sta	_bp_bank
10396                        		__ld.wi		___sizeof__tiles_SPR_NPC
         11:D401  A9 00      			lda.l	#___sizeof__tiles_SPR_NPC
         11:D403  A0 0C      			ldy.h	#___sizeof__tiles_SPR_NPC
10397                        		__lsr.wi	1
         11:D405  42         			say
         11:D406  4A         			lsr	a
         11:D407  42         			say
         11:D408  6A         			ror	a
10398                        		__st.wmq	_ax
         11:D409  85 F8      			sta.l	_ax
         11:D40B  84 F9      			sty.h	_ax
10399                        		 _load_vram.3
         11:D40D  82         			clx				; Offset to PCE VDC.
         11:D40E  20 63 FF   			call	load_vram_x
10400                        	
10401                        		.dbg	line,	"include\init.c", 122; }
10402    11:D411             	.LL440:
10403                        		__return	0
         11:D411  4C EF FF   			jmp	leave_proc
10404                        		.dbg	clear
10405                        		.endp
10406                        		.pceas
10407                        	
10408                        		.dbg	line,	"include\init.c", 125; void init_OBJECT_LV1()
10409                        		.dbg	line,	"include\init.c", 126; {
10410                        	;***********************
10411                        	;***********************
10412                        	
10413                        		.hucc
10414    11:C6F7             		.proc		_init_OBJECT_LV1
10415                        		__enter		_init_OBJECT_LV1
10416                        	
10417                        		.dbg	line,	"include\init.c", 127; signed char i;
10418                        	
10419                        		.dbg	line,	"include\init.c", 129; for(i=0 ; i<level_object_number ; i++)
10420                        		__st.umiq	0, __init_OBJECT_LV1_end - 1  /* i */
         11:C6F7  9C 44 26   			stz	__init_OBJECT_LV1_end - 1
10421    11:C6FA             	.LL442:
10422                        		__ld.bm		__init_OBJECT_LV1_end - 1  /* i */
         11:C6FA  AD 44 26   			lda	__init_OBJECT_LV1_end - 1
         11:C6FD  C2         			cly
         11:C6FE  10 01      			bpl	!+
         11:C700  88         			dey
         11:C701             	!:
10423                        		__slt_w.um	_level_object_number
         11:C701  CD 29 23   			cmp	_level_object_number		; Subtract memory from Y:A.
         11:C704  98         			tya
         11:C705  E9 00      			sbc	#0
         11:C707  50 02      			bvc	!+
         11:C709  49 80      			eor	#$80		; -ve if Y:A < memory (signed).
         11:C70B  0A         	!:		asl	a
10424                        		__btrue		.LL444
         11:C70C  B0 08      			bcs	.LL444
10425                        		__bra		.LL445
         11:C70E  4C 31 C8   			bra	.LL445
10426    11:C711             	.LL443:
10427                        		__inc.umq	__init_OBJECT_LV1_end - 1  /* i */
         11:C711  EE 44 26   			inc	__init_OBJECT_LV1_end - 1
10428                        		__bra		.LL442
         11:C714  80 E4      			bra	.LL442
10429    11:C716             	.LL444:
10430                        	
10431                        		.dbg	line,	"include\init.c", 130; {
10432                        	
10433                        		.dbg	line,	"include\init.c", 131; // SET OBJECT PROPERTIES //
10434                        	
10435                        		.dbg	line,	"include\init.c", 132; list_object_type[i] = TABLE_OBJECT_TYPE_LV1[i];
10436                        		__ldx.bmq	__init_OBJECT_LV1_end - 1  /* i */
         11:C716  AE 44 26   			ldx	__init_OBJECT_LV1_end - 1
10437                        		__ld.uax	_TABLE_OBJECT_TYPE_LV1
         11:C719  BD 78 60   			lda	_TABLE_OBJECT_TYPE_LV1, x
         11:C71C  C2         			cly
10438                        		__ldx.bmq	__init_OBJECT_LV1_end - 1  /* i */
         11:C71D  AE 44 26   			ldx	__init_OBJECT_LV1_end - 1
10439                        		__st.uaxq	_list_object_type
         11:C720  9D 2B 23   			sta	_list_object_type, x
10440                        	
10441                        		.dbg	line,	"include\init.c", 133; list_object_x_pos_ref[i] = TABLE_OBJECT_X_POS_REF_LV1[i];
10442                        		__ld2x.bmq	__init_OBJECT_LV1_end - 1  /* i */
         11:C723  AD 44 26   			lda	__init_OBJECT_LV1_end - 1
         11:C726  0A         			asl	a
         11:C727  AA         			tax
10443                        		__ld.wax	_TABLE_OBJECT_X_POS_REF_LV1
         11:C728  BD 8F 60   			lda.l	_TABLE_OBJECT_X_POS_REF_LV1, x
         11:C72B  BC 90 60   			ldy.h	_TABLE_OBJECT_X_POS_REF_LV1, x
10444                        		__ld2x.bm	__init_OBJECT_LV1_end - 1  /* i */
         11:C72E  AA         			tax
         11:C72F  AD 44 26   			lda	__init_OBJECT_LV1_end - 1
         11:C732  0A         			asl	a
         11:C733  22         			sax
10445                        		__st.waxq	_list_object_x_pos_ref
         11:C734  9D 3B 25   			sta.l	_list_object_x_pos_ref, x
         11:C737  98         			tya
         11:C738  9D 3C 25   			sta.h	_list_object_x_pos_ref, x
10446                        	
10447                        		.dbg	line,	"include\init.c", 134; list_object_y_pos_ref[i] = TABLE_OBJECT_Y_POS_REF_LV1[i];
10448                        		__ld2x.bmq	__init_OBJECT_LV1_end - 1  /* i */
         11:C73B  AD 44 26   			lda	__init_OBJECT_LV1_end - 1
         11:C73E  0A         			asl	a
         11:C73F  AA         			tax
10449                        		__ld.wax	_TABLE_OBJECT_Y_POS_REF_LV1
         11:C740  BD BD 60   			lda.l	_TABLE_OBJECT_Y_POS_REF_LV1, x
         11:C743  BC BE 60   			ldy.h	_TABLE_OBJECT_Y_POS_REF_LV1, x
10450                        		__ld2x.bm	__init_OBJECT_LV1_end - 1  /* i */
         11:C746  AA         			tax
         11:C747  AD 44 26   			lda	__init_OBJECT_LV1_end - 1
         11:C74A  0A         			asl	a
         11:C74B  22         			sax
10451                        		__st.waxq	_list_object_y_pos_ref
         11:C74C  9D 6D 25   			sta.l	_list_object_y_pos_ref, x
         11:C74F  98         			tya
         11:C750  9D 6E 25   			sta.h	_list_object_y_pos_ref, x
10452                        	
10453                        		.dbg	line,	"include\init.c", 135; list_object_x_pos[i] = -16;
10454                        		__ld2x.bmq	__init_OBJECT_LV1_end - 1  /* i */
         11:C753  AD 44 26   			lda	__init_OBJECT_LV1_end - 1
         11:C756  0A         			asl	a
         11:C757  AA         			tax
10455                        		__st.waxiq	-16, _list_object_x_pos
         11:C758  A9 F0      			lda.l	#-16
         11:C75A  9D D7 24   			sta.l	_list_object_x_pos, x
         11:C75D  A9 FF      			lda.h	#-16
         11:C75F  9D D8 24   			sta.h	_list_object_x_pos, x
10456                        	
10457                        		.dbg	line,	"include\init.c", 136; list_object_y_pos[i] = -16;
10458                        		__ld2x.bmq	__init_OBJECT_LV1_end - 1  /* i */
         11:C762  AD 44 26   			lda	__init_OBJECT_LV1_end - 1
         11:C765  0A         			asl	a
         11:C766  AA         			tax
10459                        		__st.waxiq	-16, _list_object_y_pos
         11:C767  A9 F0      			lda.l	#-16
         11:C769  9D 09 25   			sta.l	_list_object_y_pos, x
         11:C76C  A9 FF      			lda.h	#-16
         11:C76E  9D 0A 25   			sta.h	_list_object_y_pos, x
10460                        	
10461                        		.dbg	line,	"include\init.c", 137; 
10462                        	
10463                        		.dbg	line,	"include\init.c", 138; // IF THE PLAYERS ENTERS THE LEVEL FOR THE 1RST TIME //
10464                        	
10465                        		.dbg	line,	"include\init.c", 139; // ALL OBJECTS ARE ACTIVE //
10466                        	
10467                        		.dbg	line,	"include\init.c", 140; if(respawn == FALSE)
10468                        		__not.um	_respawn
         11:C771  AD 13 23   			lda	_respawn
         11:C774  18         			clc
         11:C775  D0 01      			bne	!+
         11:C777  38         			sec
         11:C778             	!:
10469                        		__bfalse	.LL446
         11:C778  90 06      			bcc	.LL446
10470                        	
10471                        		.dbg	line,	"include\init.c", 141; {
10472                        	
10473                        		.dbg	line,	"include\init.c", 142; list_object_state[i] = STATE_ACTIVE;
10474                        		__ldx.bmq	__init_OBJECT_LV1_end - 1  /* i */
         11:C77A  AE 44 26   			ldx	__init_OBJECT_LV1_end - 1
10475                        		__st.uaxiq	0, _list_object_state
         11:C77D  9E 44 23   			stz	_list_object_state, x
10476                        	
10477                        		.dbg	line,	"include\init.c", 143; }
10478                        	
10479                        		.dbg	line,	"include\init.c", 146; // SET OBJECT SPRITE //
10480                        	
10481                        		.dbg	line,	"include\init.c", 147; spr_set(i + object_start_index);
10482    11:C780             	.LL446:
10483                        		__ld.bm		__init_OBJECT_LV1_end - 1  /* i */
         11:C780  AD 44 26   			lda	__init_OBJECT_LV1_end - 1
         11:C783  C2         			cly
         11:C784  10 01      			bpl	!+
         11:C786  88         			dey
         11:C787             	!:
10484                        		__add.um	_object_start_index
         11:C787  18         			clc
         11:C788  6D 28 23   			adc	_object_start_index
         11:C78B  90 01      			bcc	!+
         11:C78D  C8         			iny
         11:C78E             	!:
10485                        		__call		_spr_set.1
         11:C78E  20 DD E7   			call	_spr_set.1
10486                        	
10487                        		.dbg	line,	"include\init.c", 148; spr_x(list_object_x_pos[i]);
10488                        		__ld2x.bmq	__init_OBJECT_LV1_end - 1  /* i */
         11:C791  AD 44 26   			lda	__init_OBJECT_LV1_end - 1
         11:C794  0A         			asl	a
         11:C795  AA         			tax
10489                        		__ld.wax	_list_object_x_pos
         11:C796  BD D7 24   			lda.l	_list_object_x_pos, x
         11:C799  BC D8 24   			ldy.h	_list_object_x_pos, x
10490                        		__call		_spr_x.1
         11:C79C  20 0A E8   			call	_spr_x.1
10491                        	
10492                        		.dbg	line,	"include\init.c", 149; spr_y(list_object_y_pos[i]);
10493                        		__ld2x.bmq	__init_OBJECT_LV1_end - 1  /* i */
         11:C79F  AD 44 26   			lda	__init_OBJECT_LV1_end - 1
         11:C7A2  0A         			asl	a
         11:C7A3  AA         			tax
10494                        		__ld.wax	_list_object_y_pos
         11:C7A4  BD 09 25   			lda.l	_list_object_y_pos, x
         11:C7A7  BC 0A 25   			ldy.h	_list_object_y_pos, x
10495                        		__call		_spr_y.1
         11:C7AA  20 19 E8   			call	_spr_y.1
10496                        	
10497                        		.dbg	line,	"include\init.c", 150; spr_pri(FALSE);
10498                        		__ld.uiq	0
         11:C7AD  62         			cla
10499                        		__call		_spr_pri.1
         11:C7AE  20 5C E8   			call	_spr_pri.1
10500                        	
10501                        		.dbg	line,	"include\init.c", 153; if(list_object_type[i] == TYPE_HOURGLASS)
10502                        		__ldx.bmq	__init_OBJECT_LV1_end - 1  /* i */
         11:C7B1  AE 44 26   			ldx	__init_OBJECT_LV1_end - 1
10503                        		__not.uax	_list_object_type
         11:C7B4  BD 2B 23   			lda	_list_object_type, x
         11:C7B7  18         			clc
         11:C7B8  D0 01      			bne	!+
         11:C7BA  38         			sec
         11:C7BB             	!:
10504                        		__bfalse	.LL447
         11:C7BB  90 1D      			bcc	.LL447
10505                        	
10506                        		.dbg	line,	"include\init.c", 154; {
10507                        	
10508                        		.dbg	line,	"include\init.c", 155; list_object_energy[i] = 0;
10509                        		__ldx.bmq	__init_OBJECT_LV1_end - 1  /* i */
         11:C7BD  AE 44 26   			ldx	__init_OBJECT_LV1_end - 1
10510                        		__st.uaxiq	0, _list_object_energy
         11:C7C0  9E 5D 23   			stz	_list_object_energy, x
10511                        	
10512                        		.dbg	line,	"include\init.c", 156; spr_pal(18);
10513                        		__ld.uiq	18
         11:C7C3  A9 12      			lda	#18
10514                        		__call		_spr_pal.1
         11:C7C5  20 4D E8   			call	_spr_pal.1
10515                        	
10516                        		.dbg	line,	"include\init.c", 157; spr_pattern(HOURGLASS_VRAM_ADR);
10517                        		__ld.wi		8640
         11:C7C8  A9 C0      			lda.l	#8640
         11:C7CA  A0 21      			ldy.h	#8640
10518                        		__call		_spr_pattern.1
         11:C7CC  20 26 E8   			call	_spr_pattern.1
10519                        	
10520                        		.dbg	line,	"include\init.c", 158; spr_ctrl(FLIP_MAS|SIZE_MAS, NO_FLIP|SZ_16x16);
10521                        		__st.umiq	185, _al
         11:C7CF  A9 B9      			lda.l	#185
         11:C7D1  85 F8      			sta	_al
10522                        		__ld.uiq	0
         11:C7D3  62         			cla
10523                        		__call		_spr_ctrl.2
         11:C7D4  20 3C E8   			call	_spr_ctrl.2
10524                        	
10525                        		.dbg	line,	"include\init.c", 159; }
10526                        	
10527                        		.dbg	line,	"include\init.c", 161; else if(list_object_type[i] == TYPE_POT)
10528                        		__bra		.LL448
         11:C7D7  4C 11 C7   			bra	.LL448
10529    11:C7DA             	.LL447:
10530                        		__ldx.bmq	__init_OBJECT_LV1_end - 1  /* i */
         11:C7DA  AE 44 26   			ldx	__init_OBJECT_LV1_end - 1
10531                        		__ld.uaxq	_list_object_type
         11:C7DD  BD 2B 23   			lda	_list_object_type, x
10532                        		__equ_b.uiq	1
         11:C7E0  C9 01      			cmp	#1
         11:C7E2  F0 01      			beq	!+
         11:C7E4  18         			clc
         11:C7E5             	!:
10533                        		__bfalse	.LL449
         11:C7E5  90 1E      			bcc	.LL449
10534                        	
10535                        		.dbg	line,	"include\init.c", 162; {
10536                        	
10537                        		.dbg	line,	"include\init.c", 163; list_object_energy[i] = 2;
10538                        		__ldx.bmq	__init_OBJECT_LV1_end - 1  /* i */
         11:C7E7  AE 44 26   			ldx	__init_OBJECT_LV1_end - 1
10539                        		__st.uaxiq	2, _list_object_energy
         11:C7EA  A9 02      			lda.l	#2
         11:C7EC  9D 5D 23   			sta	_list_object_energy, x
10540                        	
10541                        		.dbg	line,	"include\init.c", 164; spr_pal(17);
10542                        		__ld.uiq	17
         11:C7EF  A9 11      			lda	#17
10543                        		__call		_spr_pal.1
         11:C7F1  20 4D E8   			call	_spr_pal.1
10544                        	
10545                        		.dbg	line,	"include\init.c", 165; spr_pattern(POT1_VRAM_ADR);
10546                        		__ld.wi		7168
         11:C7F4  62         			cla
         11:C7F5  A0 1C      			ldy.h	#7168
10547                        		__call		_spr_pattern.1
         11:C7F7  20 26 E8   			call	_spr_pattern.1
10548                        	
10549                        		.dbg	line,	"include\init.c", 166; spr_ctrl(FLIP_MAS|SIZE_MAS, NO_FLIP|SZ_16x16);
10550                        		__st.umiq	185, _al
         11:C7FA  A9 B9      			lda.l	#185
         11:C7FC  85 F8      			sta	_al
10551                        		__ld.uiq	0
         11:C7FE  62         			cla
10552                        		__call		_spr_ctrl.2
         11:C7FF  20 3C E8   			call	_spr_ctrl.2
10553                        	
10554                        		.dbg	line,	"include\init.c", 167; }
10555                        	
10556                        		.dbg	line,	"include\init.c", 169; else if(list_object_type[i] == TYPE_POW)
10557                        		__bra		.LL450
         11:C802  4C 11 C7   			bra	.LL450
10558    11:C805             	.LL449:
10559                        		__ldx.bmq	__init_OBJECT_LV1_end - 1  /* i */
         11:C805  AE 44 26   			ldx	__init_OBJECT_LV1_end - 1
10560                        		__ld.uaxq	_list_object_type
         11:C808  BD 2B 23   			lda	_list_object_type, x
10561                        		__equ_b.uiq	2
         11:C80B  C9 02      			cmp	#2
         11:C80D  F0 01      			beq	!+
         11:C80F  18         			clc
         11:C810             	!:
10562                        		__bfalse	.LL451
         11:C810  B0 03 4C 11			bcc	.LL451
         11:C814  C7          
10563                        	
10564                        		.dbg	line,	"include\init.c", 170; {
10565                        	
10566                        		.dbg	line,	"include\init.c", 171; list_object_energy[i] = 0;
10567                        		__ldx.bmq	__init_OBJECT_LV1_end - 1  /* i */
         11:C815  AE 44 26   			ldx	__init_OBJECT_LV1_end - 1
10568                        		__st.uaxiq	0, _list_object_energy
         11:C818  9E 5D 23   			stz	_list_object_energy, x
10569                        	
10570                        		.dbg	line,	"include\init.c", 172; spr_pal(18);
10571                        		__ld.uiq	18
         11:C81B  A9 12      			lda	#18
10572                        		__call		_spr_pal.1
         11:C81D  20 4D E8   			call	_spr_pal.1
10573                        	
10574                        		.dbg	line,	"include\init.c", 173; spr_pattern(POW_VRAM_ADR);
10575                        		__ld.wi		7680
         11:C820  62         			cla
         11:C821  A0 1E      			ldy.h	#7680
10576                        		__call		_spr_pattern.1
         11:C823  20 26 E8   			call	_spr_pattern.1
10577                        	
10578                        		.dbg	line,	"include\init.c", 174; spr_ctrl(FLIP_MAS|SIZE_MAS, NO_FLIP|SZ_16x16);
10579                        		__st.umiq	185, _al
         11:C826  A9 B9      			lda.l	#185
         11:C828  85 F8      			sta	_al
10580                        		__ld.uiq	0
         11:C82A  62         			cla
10581                        		__call		_spr_ctrl.2
         11:C82B  20 3C E8   			call	_spr_ctrl.2
10582                        	
10583                        		.dbg	line,	"include\init.c", 175; }
10584                        	
10585                        		.dbg	line,	"include\init.c", 176; }
10586    11:C82E             	.LL451	.alias		.LL443
10587    11:C82E             	.LL450	.alias		.LL443
10588    11:C82E             	.LL448	.alias		.LL443
10589                        		__bra		.LL443
         11:C82E  4C 11 C7   			bra	.LL443
10590    11:C831             	.LL445:
10591                        	
10592                        		.dbg	line,	"include\init.c", 177; }
10593    11:C831             	.LL441:
10594                        		__return	0
         11:C831  4C EF FF   			jmp	leave_proc
10595                        		.dbg	clear
10596                        		.endp
10597                        		.pceas
10598                        	
10599                        		.dbg	line,	"include\init.c", 180; void init_CHEST_LV1()
10600                        		.dbg	line,	"include\init.c", 181; {
10601                        	;***********************
10602                        	;***********************
10603                        	
10604                        		.hucc
10605    11:CBEB             		.proc		_init_CHEST_LV1
10606                        		__enter		_init_CHEST_LV1
10607                        	
10608                        		.dbg	line,	"include\init.c", 182; signed char i;
10609                        	
10610                        		.dbg	line,	"include\init.c", 184; for(i=0 ; i<level_chest_number ; i++)
10611                        		__st.umiq	0, __init_CHEST_LV1_end - 1  /* i */
         11:CBEB  9C 44 26   			stz	__init_CHEST_LV1_end - 1
10612    11:CBEE             	.LL453:
10613                        		__ld.bm		__init_CHEST_LV1_end - 1  /* i */
         11:CBEE  AD 44 26   			lda	__init_CHEST_LV1_end - 1
         11:CBF1  C2         			cly
         11:CBF2  10 01      			bpl	!+
         11:CBF4  88         			dey
         11:CBF5             	!:
10614                        		__slt_w.um	_level_chest_number
         11:CBF5  CD 98 23   			cmp	_level_chest_number		; Subtract memory from Y:A.
         11:CBF8  98         			tya
         11:CBF9  E9 00      			sbc	#0
         11:CBFB  50 02      			bvc	!+
         11:CBFD  49 80      			eor	#$80		; -ve if Y:A < memory (signed).
         11:CBFF  0A         	!:		asl	a
10615                        		__btrue		.LL455
         11:CC00  B0 08      			bcs	.LL455
10616                        		__bra		.LL456
         11:CC02  4C AF CC   			bra	.LL456
10617    11:CC05             	.LL454:
10618                        		__inc.umq	__init_CHEST_LV1_end - 1  /* i */
         11:CC05  EE 44 26   			inc	__init_CHEST_LV1_end - 1
10619                        		__bra		.LL453
         11:CC08  80 E4      			bra	.LL453
10620    11:CC0A             	.LL455:
10621                        	
10622                        		.dbg	line,	"include\init.c", 185; {
10623                        	
10624                        		.dbg	line,	"include\init.c", 186; // SET CHEST PROPERTIES //
10625                        	
10626                        		.dbg	line,	"include\init.c", 187; list_chest_x_pos_ref[i] = TABLE_CHEST_X_POS_REF_LV1[i];
10627                        		__ld2x.bmq	__init_CHEST_LV1_end - 1  /* i */
         11:CC0A  AD 44 26   			lda	__init_CHEST_LV1_end - 1
         11:CC0D  0A         			asl	a
         11:CC0E  AA         			tax
10628                        		__ld.wax	_TABLE_CHEST_X_POS_REF_LV1
         11:CC0F  BD EB 60   			lda.l	_TABLE_CHEST_X_POS_REF_LV1, x
         11:CC12  BC EC 60   			ldy.h	_TABLE_CHEST_X_POS_REF_LV1, x
10629                        		__ld2x.bm	__init_CHEST_LV1_end - 1  /* i */
         11:CC15  AA         			tax
         11:CC16  AD 44 26   			lda	__init_CHEST_LV1_end - 1
         11:CC19  0A         			asl	a
         11:CC1A  22         			sax
10630                        		__st.waxq	_list_chest_x_pos_ref
         11:CC1B  9D BF 25   			sta.l	_list_chest_x_pos_ref, x
         11:CC1E  98         			tya
         11:CC1F  9D C0 25   			sta.h	_list_chest_x_pos_ref, x
10631                        	
10632                        		.dbg	line,	"include\init.c", 188; list_chest_y_pos_ref[i] = TABLE_CHEST_Y_POS_REF_LV1[i];
10633                        		__ld2x.bmq	__init_CHEST_LV1_end - 1  /* i */
         11:CC22  AD 44 26   			lda	__init_CHEST_LV1_end - 1
         11:CC25  0A         			asl	a
         11:CC26  AA         			tax
10634                        		__ld.wax	_TABLE_CHEST_Y_POS_REF_LV1
         11:CC27  BD EF 60   			lda.l	_TABLE_CHEST_Y_POS_REF_LV1, x
         11:CC2A  BC F0 60   			ldy.h	_TABLE_CHEST_Y_POS_REF_LV1, x
10635                        		__ld2x.bm	__init_CHEST_LV1_end - 1  /* i */
         11:CC2D  AA         			tax
         11:CC2E  AD 44 26   			lda	__init_CHEST_LV1_end - 1
         11:CC31  0A         			asl	a
         11:CC32  22         			sax
10636                        		__st.waxq	_list_chest_y_pos_ref
         11:CC33  9D CF 25   			sta.l	_list_chest_y_pos_ref, x
         11:CC36  98         			tya
         11:CC37  9D D0 25   			sta.h	_list_chest_y_pos_ref, x
10637                        	
10638                        		.dbg	line,	"include\init.c", 189; list_chest_x_pos[i] = -32;
10639                        		__ld2x.bmq	__init_CHEST_LV1_end - 1  /* i */
         11:CC3A  AD 44 26   			lda	__init_CHEST_LV1_end - 1
         11:CC3D  0A         			asl	a
         11:CC3E  AA         			tax
10640                        		__st.waxiq	-32, _list_chest_x_pos
         11:CC3F  A9 E0      			lda.l	#-32
         11:CC41  9D 9F 25   			sta.l	_list_chest_x_pos, x
         11:CC44  A9 FF      			lda.h	#-32
         11:CC46  9D A0 25   			sta.h	_list_chest_x_pos, x
10641                        	
10642                        		.dbg	line,	"include\init.c", 190; list_chest_y_pos[i] = -32;
10643                        		__ld2x.bmq	__init_CHEST_LV1_end - 1  /* i */
         11:CC49  AD 44 26   			lda	__init_CHEST_LV1_end - 1
         11:CC4C  0A         			asl	a
         11:CC4D  AA         			tax
10644                        		__st.waxiq	-32, _list_chest_y_pos
         11:CC4E  A9 E0      			lda.l	#-32
         11:CC50  9D AF 25   			sta.l	_list_chest_y_pos, x
         11:CC53  A9 FF      			lda.h	#-32
         11:CC55  9D B0 25   			sta.h	_list_chest_y_pos, x
10645                        	
10646                        		.dbg	line,	"include\init.c", 192; if(respawn == FALSE)
10647                        		__not.um	_respawn
         11:CC58  AD 13 23   			lda	_respawn
         11:CC5B  18         			clc
         11:CC5C  D0 01      			bne	!+
         11:CC5E  38         			sec
         11:CC5F             	!:
10648                        		__bfalse	.LL457
         11:CC5F  90 06      			bcc	.LL457
10649                        	
10650                        		.dbg	line,	"include\init.c", 193; {
10651                        	
10652                        		.dbg	line,	"include\init.c", 194; list_chest_state[i] = STATE_ACTIVE;
10653                        		__ldx.bmq	__init_CHEST_LV1_end - 1  /* i */
         11:CC61  AE 44 26   			ldx	__init_CHEST_LV1_end - 1
10654                        		__st.uaxiq	0, _list_chest_state
         11:CC64  9E 9A 23   			stz	_list_chest_state, x
10655                        	
10656                        		.dbg	line,	"include\init.c", 195; }
10657                        	
10658                        		.dbg	line,	"include\init.c", 198; // SET CHEST SPRITE //
10659                        	
10660                        		.dbg	line,	"include\init.c", 199; spr_set(i + chest_start_index);
10661    11:CC67             	.LL457:
10662                        		__ld.bm		__init_CHEST_LV1_end - 1  /* i */
         11:CC67  AD 44 26   			lda	__init_CHEST_LV1_end - 1
         11:CC6A  C2         			cly
         11:CC6B  10 01      			bpl	!+
         11:CC6D  88         			dey
         11:CC6E             	!:
10663                        		__add.um	_chest_start_index
         11:CC6E  18         			clc
         11:CC6F  6D 97 23   			adc	_chest_start_index
         11:CC72  90 01      			bcc	!+
         11:CC74  C8         			iny
         11:CC75             	!:
10664                        		__call		_spr_set.1
         11:CC75  20 DD E7   			call	_spr_set.1
10665                        	
10666                        		.dbg	line,	"include\init.c", 200; spr_x(list_chest_x_pos[i]);
10667                        		__ld2x.bmq	__init_CHEST_LV1_end - 1  /* i */
         11:CC78  AD 44 26   			lda	__init_CHEST_LV1_end - 1
         11:CC7B  0A         			asl	a
         11:CC7C  AA         			tax
10668                        		__ld.wax	_list_chest_x_pos
         11:CC7D  BD 9F 25   			lda.l	_list_chest_x_pos, x
         11:CC80  BC A0 25   			ldy.h	_list_chest_x_pos, x
10669                        		__call		_spr_x.1
         11:CC83  20 0A E8   			call	_spr_x.1
10670                        	
10671                        		.dbg	line,	"include\init.c", 201; spr_y(list_chest_y_pos[i]);
10672                        		__ld2x.bmq	__init_CHEST_LV1_end - 1  /* i */
         11:CC86  AD 44 26   			lda	__init_CHEST_LV1_end - 1
         11:CC89  0A         			asl	a
         11:CC8A  AA         			tax
10673                        		__ld.wax	_list_chest_y_pos
         11:CC8B  BD AF 25   			lda.l	_list_chest_y_pos, x
         11:CC8E  BC B0 25   			ldy.h	_list_chest_y_pos, x
10674                        		__call		_spr_y.1
         11:CC91  20 19 E8   			call	_spr_y.1
10675                        	
10676                        		.dbg	line,	"include\init.c", 202; spr_pri(FALSE);
10677                        		__ld.uiq	0
         11:CC94  62         			cla
10678                        		__call		_spr_pri.1
         11:CC95  20 5C E8   			call	_spr_pri.1
10679                        	
10680                        		.dbg	line,	"include\init.c", 205; spr_pal(18);
10681                        		__ld.uiq	18
         11:CC98  A9 12      			lda	#18
10682                        		__call		_spr_pal.1
         11:CC9A  20 4D E8   			call	_spr_pal.1
10683                        	
10684                        		.dbg	line,	"include\init.c", 206; spr_pattern(CHEST_VRAM_ADR);
10685                        		__ld.wi		9216
         11:CC9D  62         			cla
         11:CC9E  A0 24      			ldy.h	#9216
10686                        		__call		_spr_pattern.1
         11:CCA0  20 26 E8   			call	_spr_pattern.1
10687                        	
10688                        		.dbg	line,	"include\init.c", 207; spr_ctrl(FLIP_MAS|SIZE_MAS, NO_FLIP|SZ_32x32);
10689                        		__st.umiq	185, _al
         11:CCA3  A9 B9      			lda.l	#185
         11:CCA5  85 F8      			sta	_al
10690                        		__ld.uiq	17
         11:CCA7  A9 11      			lda	#17
10691                        		__call		_spr_ctrl.2
         11:CCA9  20 3C E8   			call	_spr_ctrl.2
10692                        	
10693                        		.dbg	line,	"include\init.c", 208; }
10694                        		__bra		.LL454
         11:CCAC  4C 05 CC   			bra	.LL454
10695    11:CCAF             	.LL456:
10696                        	
10697                        		.dbg	line,	"include\init.c", 209; }
10698    11:CCAF             	.LL452:
10699                        		__return	0
         11:CCAF  4C EF FF   			jmp	leave_proc
10700                        		.dbg	clear
10701                        		.endp
10702                        		.pceas
10703                        	
10704                        		.dbg	line,	"include\init.c", 212; void init_NPC_LV1()
10705                        		.dbg	line,	"include\init.c", 213; {
10706                        	;***********************
10707                        	;***********************
10708                        	
10709                        		.hucc
10710    11:CB17             		.proc		_init_NPC_LV1
10711                        		__enter		_init_NPC_LV1
10712                        	
10713                        		.dbg	line,	"include\init.c", 214; signed char i;
10714                        	
10715                        		.dbg	line,	"include\init.c", 216; for(i=0 ; i<level_npc_number ; i++)
10716                        		__st.umiq	0, __init_NPC_LV1_end - 1  /* i */
         11:CB17  9C 44 26   			stz	__init_NPC_LV1_end - 1
10717    11:CB1A             	.LL459:
10718                        		__ld.bm		__init_NPC_LV1_end - 1  /* i */
         11:CB1A  AD 44 26   			lda	__init_NPC_LV1_end - 1
         11:CB1D  C2         			cly
         11:CB1E  10 01      			bpl	!+
         11:CB20  88         			dey
         11:CB21             	!:
10719                        		__slt_w.um	_level_npc_number
         11:CB21  CD AB 23   			cmp	_level_npc_number		; Subtract memory from Y:A.
         11:CB24  98         			tya
         11:CB25  E9 00      			sbc	#0
         11:CB27  50 02      			bvc	!+
         11:CB29  49 80      			eor	#$80		; -ve if Y:A < memory (signed).
         11:CB2B  0A         	!:		asl	a
10720                        		__btrue		.LL461
         11:CB2C  B0 08      			bcs	.LL461
10721                        		__bra		.LL462
         11:CB2E  4C E8 CB   			bra	.LL462
10722    11:CB31             	.LL460:
10723                        		__inc.umq	__init_NPC_LV1_end - 1  /* i */
         11:CB31  EE 44 26   			inc	__init_NPC_LV1_end - 1
10724                        		__bra		.LL459
         11:CB34  80 E4      			bra	.LL459
10725    11:CB36             	.LL461:
10726                        	
10727                        		.dbg	line,	"include\init.c", 217; {
10728                        	
10729                        		.dbg	line,	"include\init.c", 218; // SET NPC PROPERTIES //
10730                        	
10731                        		.dbg	line,	"include\init.c", 219; list_npc_type[i] = TABLE_NPC_TYPE_LV1[i];
10732                        		__ldx.bmq	__init_NPC_LV1_end - 1  /* i */
         11:CB36  AE 44 26   			ldx	__init_NPC_LV1_end - 1
10733                        		__ld.uax	_TABLE_NPC_TYPE_LV1
         11:CB39  BD 6E 60   			lda	_TABLE_NPC_TYPE_LV1, x
         11:CB3C  C2         			cly
10734                        		__ldx.bmq	__init_NPC_LV1_end - 1  /* i */
         11:CB3D  AE 44 26   			ldx	__init_NPC_LV1_end - 1
10735                        		__st.uaxq	_list_npc_type
         11:CB40  9D AD 23   			sta	_list_npc_type, x
10736                        	
10737                        		.dbg	line,	"include\init.c", 220; list_npc_x_pos_ref[i] = TABLE_NPC_X_POS_REF_LV1[i];
10738                        		__ld2x.bmq	__init_NPC_LV1_end - 1  /* i */
         11:CB43  AD 44 26   			lda	__init_NPC_LV1_end - 1
         11:CB46  0A         			asl	a
         11:CB47  AA         			tax
10739                        		__ld.wax	_TABLE_NPC_X_POS_REF_LV1
         11:CB48  BD 70 60   			lda.l	_TABLE_NPC_X_POS_REF_LV1, x
         11:CB4B  BC 71 60   			ldy.h	_TABLE_NPC_X_POS_REF_LV1, x
10740                        		__ld2x.bm	__init_NPC_LV1_end - 1  /* i */
         11:CB4E  AA         			tax
         11:CB4F  AD 44 26   			lda	__init_NPC_LV1_end - 1
         11:CB52  0A         			asl	a
         11:CB53  22         			sax
10741                        		__st.waxq	_list_npc_x_pos_ref
         11:CB54  9D 03 26   			sta.l	_list_npc_x_pos_ref, x
         11:CB57  98         			tya
         11:CB58  9D 04 26   			sta.h	_list_npc_x_pos_ref, x
10742                        	
10743                        		.dbg	line,	"include\init.c", 221; list_npc_y_pos_ref[i] = TABLE_NPC_Y_POS_REF_LV1[i];
10744                        		__ld2x.bmq	__init_NPC_LV1_end - 1  /* i */
         11:CB5B  AD 44 26   			lda	__init_NPC_LV1_end - 1
         11:CB5E  0A         			asl	a
         11:CB5F  AA         			tax
10745                        		__ld.wax	_TABLE_NPC_Y_POS_REF_LV1
         11:CB60  BD 74 60   			lda.l	_TABLE_NPC_Y_POS_REF_LV1, x
         11:CB63  BC 75 60   			ldy.h	_TABLE_NPC_Y_POS_REF_LV1, x
10746                        		__ld2x.bm	__init_NPC_LV1_end - 1  /* i */
         11:CB66  AA         			tax
         11:CB67  AD 44 26   			lda	__init_NPC_LV1_end - 1
         11:CB6A  0A         			asl	a
         11:CB6B  22         			sax
10747                        		__st.waxq	_list_npc_y_pos_ref
         11:CB6C  9D 15 26   			sta.l	_list_npc_y_pos_ref, x
         11:CB6F  98         			tya
         11:CB70  9D 16 26   			sta.h	_list_npc_y_pos_ref, x
10748                        	
10749                        		.dbg	line,	"include\init.c", 222; list_npc_x_pos[i] = -32;
10750                        		__ld2x.bmq	__init_NPC_LV1_end - 1  /* i */
         11:CB73  AD 44 26   			lda	__init_NPC_LV1_end - 1
         11:CB76  0A         			asl	a
         11:CB77  AA         			tax
10751                        		__st.waxiq	-32, _list_npc_x_pos
         11:CB78  A9 E0      			lda.l	#-32
         11:CB7A  9D DF 25   			sta.l	_list_npc_x_pos, x
         11:CB7D  A9 FF      			lda.h	#-32
         11:CB7F  9D E0 25   			sta.h	_list_npc_x_pos, x
10752                        	
10753                        		.dbg	line,	"include\init.c", 223; list_npc_y_pos[i] = -32;
10754                        		__ld2x.bmq	__init_NPC_LV1_end - 1  /* i */
         11:CB82  AD 44 26   			lda	__init_NPC_LV1_end - 1
         11:CB85  0A         			asl	a
         11:CB86  AA         			tax
10755                        		__st.waxiq	-32, _list_npc_y_pos
         11:CB87  A9 E0      			lda.l	#-32
         11:CB89  9D F1 25   			sta.l	_list_npc_y_pos, x
         11:CB8C  A9 FF      			lda.h	#-32
         11:CB8E  9D F2 25   			sta.h	_list_npc_y_pos, x
10756                        	
10757                        		.dbg	line,	"include\init.c", 225; if(respawn == FALSE)
10758                        		__not.um	_respawn
         11:CB91  AD 13 23   			lda	_respawn
         11:CB94  18         			clc
         11:CB95  D0 01      			bne	!+
         11:CB97  38         			sec
         11:CB98             	!:
10759                        		__bfalse	.LL463
         11:CB98  90 06      			bcc	.LL463
10760                        	
10761                        		.dbg	line,	"include\init.c", 226; {
10762                        	
10763                        		.dbg	line,	"include\init.c", 227; list_npc_state[i] = STATE_ACTIVE;
10764                        		__ldx.bmq	__init_NPC_LV1_end - 1  /* i */
         11:CB9A  AE 44 26   			ldx	__init_NPC_LV1_end - 1
10765                        		__st.uaxiq	0, _list_npc_state
         11:CB9D  9E B6 23   			stz	_list_npc_state, x
10766                        	
10767                        		.dbg	line,	"include\init.c", 228; }
10768                        	
10769                        		.dbg	line,	"include\init.c", 231; // SET NPC SPRITE //
10770                        	
10771                        		.dbg	line,	"include\init.c", 232; spr_set(i + npc_start_index);
10772    11:CBA0             	.LL463:
10773                        		__ld.bm		__init_NPC_LV1_end - 1  /* i */
         11:CBA0  AD 44 26   			lda	__init_NPC_LV1_end - 1
         11:CBA3  C2         			cly
         11:CBA4  10 01      			bpl	!+
         11:CBA6  88         			dey
         11:CBA7             	!:
10774                        		__add.um	_npc_start_index
         11:CBA7  18         			clc
         11:CBA8  6D AA 23   			adc	_npc_start_index
         11:CBAB  90 01      			bcc	!+
         11:CBAD  C8         			iny
         11:CBAE             	!:
10775                        		__call		_spr_set.1
         11:CBAE  20 DD E7   			call	_spr_set.1
10776                        	
10777                        		.dbg	line,	"include\init.c", 233; spr_x(list_npc_x_pos[i]);
10778                        		__ld2x.bmq	__init_NPC_LV1_end - 1  /* i */
         11:CBB1  AD 44 26   			lda	__init_NPC_LV1_end - 1
         11:CBB4  0A         			asl	a
         11:CBB5  AA         			tax
10779                        		__ld.wax	_list_npc_x_pos
         11:CBB6  BD DF 25   			lda.l	_list_npc_x_pos, x
         11:CBB9  BC E0 25   			ldy.h	_list_npc_x_pos, x
10780                        		__call		_spr_x.1
         11:CBBC  20 0A E8   			call	_spr_x.1
10781                        	
10782                        		.dbg	line,	"include\init.c", 234; spr_y(list_npc_y_pos[i]);
10783                        		__ld2x.bmq	__init_NPC_LV1_end - 1  /* i */
         11:CBBF  AD 44 26   			lda	__init_NPC_LV1_end - 1
         11:CBC2  0A         			asl	a
         11:CBC3  AA         			tax
10784                        		__ld.wax	_list_npc_y_pos
         11:CBC4  BD F1 25   			lda.l	_list_npc_y_pos, x
         11:CBC7  BC F2 25   			ldy.h	_list_npc_y_pos, x
10785                        		__call		_spr_y.1
         11:CBCA  20 19 E8   			call	_spr_y.1
10786                        	
10787                        		.dbg	line,	"include\init.c", 235; spr_pri(FALSE);
10788                        		__ld.uiq	0
         11:CBCD  62         			cla
10789                        		__call		_spr_pri.1
         11:CBCE  20 5C E8   			call	_spr_pri.1
10790                        	
10791                        		.dbg	line,	"include\init.c", 238; spr_pal(17);
10792                        		__ld.uiq	17
         11:CBD1  A9 11      			lda	#17
10793                        		__call		_spr_pal.1
         11:CBD3  20 4D E8   			call	_spr_pal.1
10794                        	
10795                        		.dbg	line,	"include\init.c", 239; spr_pattern(NPC_VRAM_ADR);
10796                        		__ld.wi		10752
         11:CBD6  62         			cla
         11:CBD7  A0 2A      			ldy.h	#10752
10797                        		__call		_spr_pattern.1
         11:CBD9  20 26 E8   			call	_spr_pattern.1
10798                        	
10799                        		.dbg	line,	"include\init.c", 240; spr_ctrl(FLIP_MAS|SIZE_MAS, NO_FLIP|SZ_32x32);
10800                        		__st.umiq	185, _al
         11:CBDC  A9 B9      			lda.l	#185
         11:CBDE  85 F8      			sta	_al
10801                        		__ld.uiq	17
         11:CBE0  A9 11      			lda	#17
10802                        		__call		_spr_ctrl.2
         11:CBE2  20 3C E8   			call	_spr_ctrl.2
10803                        	
10804                        		.dbg	line,	"include\init.c", 241; }
10805                        		__bra		.LL460
         11:CBE5  4C 31 CB   			bra	.LL460
10806    11:CBE8             	.LL462:
10807                        	
10808                        		.dbg	line,	"include\init.c", 242; }
10809    11:CBE8             	.LL458:
10810                        		__return	0
         11:CBE8  4C EF FF   			jmp	leave_proc
10811                        		.dbg	clear
10812                        		.endp
10813                        		.pceas
10814                        	
10815                        		.dbg	line,	"include\init.c", 249; void init_HUD()
10816                        		.dbg	line,	"include\init.c", 250; {
10817                        	;***********************
10818                        	;***********************
10819                        	
10820                        		.hucc
10821    02:D40E             		.proc		_init_HUD
10822                        		__enter		_init_HUD
10823                        	
10824                        		.dbg	line,	"include\init.c", 251; //**************************************************************************************//
10825                        	
10826                        		.dbg	line,	"include\init.c", 252; //                                                                                      //
10827                        	
10828                        		.dbg	line,	"include\init.c", 253; //                                        VDC 1                                         //
10829                        	
10830                        		.dbg	line,	"include\init.c", 254; //                                                                                      //
10831                        	
10832                        		.dbg	line,	"include\init.c", 255; //**************************************************************************************//
10833                        	
10834                        		.dbg	line,	"include\init.c", 257; //--------------------------------------------------------------------------------------//
10835                        	
10836                        		.dbg	line,	"include\init.c", 258; //                                      LOAD FONT                                       //
10837                        	
10838                        		.dbg	line,	"include\init.c", 259; //--------------------------------------------------------------------------------------//
10839                        	
10840                        		.dbg	line,	"include\init.c", 261; load_vram( 0x0800, tileset_FONT, SIZEOF(tileset_FONT) >> 1 );
10841                        		__st.wmiq	2048, _di
         02:D40E  64 F0      			stz.l	_di
         02:D410  A9 08      			lda.h	#2048
         02:D412  85 F1      			sta.h	_di
10842                        		__farptr	_tileset_FONT, _bp_bank, _bp
         02:D414  A9 00      			lda.l	#$6000 + ($1FFF & (_tileset_FONT))
         02:D416  85 EC      			sta.l	_bp
         02:D418  A9 60      			lda.h	#$6000 + ($1FFF & (_tileset_FONT))
         02:D41A  85 ED      			sta.h	_bp
         02:D41C  A9 03      			lda	#bank(_tileset_FONT)
         02:D41E  85 02      			sta	_bp_bank
10843                        		__ld.wi		___sizeof__tileset_FONT
         02:D420  A9 00      			lda.l	#___sizeof__tileset_FONT
         02:D422  A0 0C      			ldy.h	#___sizeof__tileset_FONT
10844                        		__lsr.wi	1
         02:D424  42         			say
         02:D425  4A         			lsr	a
         02:D426  42         			say
         02:D427  6A         			ror	a
10845                        		__st.wmq	_ax
         02:D428  85 F8      			sta.l	_ax
         02:D42A  84 F9      			sty.h	_ax
10846                        		 _load_vram.3
         02:D42C  82         			clx				; Offset to PCE VDC.
         02:D42D  20 63 FF   			call	load_vram_x
10847                        	
10848                        		.dbg	line,	"include\init.c", 263; set_font_pal(15);
10849                        		__ld.uiq	15
         02:D430  A9 0F      			lda	#15
10850                        		__call		_set_font_pal.1
         02:D432  20 09 E6   			call	_set_font_pal.1
10851                        	
10852                        		.dbg	line,	"include\init.c", 266; //--------------------------------------------------------------------------------------//
10853                        	
10854                        		.dbg	line,	"include\init.c", 267; //                                    LOAD TILESET                                      //
10855                        	
10856                        		.dbg	line,	"include\init.c", 268; //--------------------------------------------------------------------------------------//
10857                        	
10858                        		.dbg	line,	"include\init.c", 270; load_vram( 0x1000, tileset_HUD, SIZEOF(tileset_HUD) >> 1 );
10859                        		__st.wmiq	4096, _di
         02:D435  64 F0      			stz.l	_di
         02:D437  A9 10      			lda.h	#4096
         02:D439  85 F1      			sta.h	_di
10860                        		__farptr	_tileset_HUD, _bp_bank, _bp
         02:D43B  A9 A0      			lda.l	#$6000 + ($1FFF & (_tileset_HUD))
         02:D43D  85 EC      			sta.l	_bp
         02:D43F  A9 79      			lda.h	#$6000 + ($1FFF & (_tileset_HUD))
         02:D441  85 ED      			sta.h	_bp
         02:D443  A9 09      			lda	#bank(_tileset_HUD)
         02:D445  85 02      			sta	_bp_bank
10861                        		__ld.wi		___sizeof__tileset_HUD
         02:D447  A9 60      			lda.l	#___sizeof__tileset_HUD
         02:D449  A0 06      			ldy.h	#___sizeof__tileset_HUD
10862                        		__lsr.wi	1
         02:D44B  42         			say
         02:D44C  4A         			lsr	a
         02:D44D  42         			say
         02:D44E  6A         			ror	a
10863                        		__st.wmq	_ax
         02:D44F  85 F8      			sta.l	_ax
         02:D451  84 F9      			sty.h	_ax
10864                        		 _load_vram.3
         02:D453  82         			clx				; Offset to PCE VDC.
         02:D454  20 63 FF   			call	load_vram_x
10865                        	
10866                        		.dbg	line,	"include\init.c", 273; //--------------------------------------------------------------------------------------//
10867                        	
10868                        		.dbg	line,	"include\init.c", 274; //                                 LOAD LIFEBAR TILES                                   //
10869                        	
10870                        		.dbg	line,	"include\init.c", 275; //--------------------------------------------------------------------------------------//
10871                        	
10872                        		.dbg	line,	"include\init.c", 277; load_vram( LIFEBAR_1_VRAM_ADR, tileset_LIFE_RED, SIZEOF(tileset_LIFE_RED) >> 1 );
10873                        		__st.wmiq	4096, _di
         02:D457  64 F0      			stz.l	_di
         02:D459  A9 10      			lda.h	#4096
         02:D45B  85 F1      			sta.h	_di
10874                        		__farptr	_tileset_LIFE_RED, _bp_bank, _bp
         02:D45D  A9 00      			lda.l	#$6000 + ($1FFF & (_tileset_LIFE_RED))
         02:D45F  85 EC      			sta.l	_bp
         02:D461  A9 74      			lda.h	#$6000 + ($1FFF & (_tileset_LIFE_RED))
         02:D463  85 ED      			sta.h	_bp
         02:D465  A9 03      			lda	#bank(_tileset_LIFE_RED)
         02:D467  85 02      			sta	_bp_bank
10875                        		__ld.wi		___sizeof__tileset_LIFE_RED
         02:D469  A9 40      			lda.l	#___sizeof__tileset_LIFE_RED
         02:D46B  A0 00      			ldy.h	#___sizeof__tileset_LIFE_RED
10876                        		__lsr.wi	1
         02:D46D  42         			say
         02:D46E  4A         			lsr	a
         02:D46F  42         			say
         02:D470  6A         			ror	a
10877                        		__st.wmq	_ax
         02:D471  85 F8      			sta.l	_ax
         02:D473  84 F9      			sty.h	_ax
10878                        		 _load_vram.3
         02:D475  82         			clx				; Offset to PCE VDC.
         02:D476  20 63 FF   			call	load_vram_x
10879                        	
10880                        		.dbg	line,	"include\init.c", 278; load_vram( LIFEBAR_2_VRAM_ADR, tileset_LIFE_ORANGE, SIZEOF(tileset_LIFE_ORANGE) >> 1 );
10881                        		__st.wmiq	4128, _di
         02:D479  A9 20      			lda.l	#4128
         02:D47B  85 F0      			sta.l	_di
         02:D47D  A9 10      			lda.h	#4128
         02:D47F  85 F1      			sta.h	_di
10882                        		__farptr	_tileset_LIFE_ORANGE, _bp_bank, _bp
         02:D481  A9 40      			lda.l	#$6000 + ($1FFF & (_tileset_LIFE_ORANGE))
         02:D483  85 EC      			sta.l	_bp
         02:D485  A9 74      			lda.h	#$6000 + ($1FFF & (_tileset_LIFE_ORANGE))
         02:D487  85 ED      			sta.h	_bp
         02:D489  A9 03      			lda	#bank(_tileset_LIFE_ORANGE)
         02:D48B  85 02      			sta	_bp_bank
10883                        		__ld.wi		___sizeof__tileset_LIFE_ORANGE
         02:D48D  A9 40      			lda.l	#___sizeof__tileset_LIFE_ORANGE
         02:D48F  A0 00      			ldy.h	#___sizeof__tileset_LIFE_ORANGE
10884                        		__lsr.wi	1
         02:D491  42         			say
         02:D492  4A         			lsr	a
         02:D493  42         			say
         02:D494  6A         			ror	a
10885                        		__st.wmq	_ax
         02:D495  85 F8      			sta.l	_ax
         02:D497  84 F9      			sty.h	_ax
10886                        		 _load_vram.3
         02:D499  82         			clx				; Offset to PCE VDC.
         02:D49A  20 63 FF   			call	load_vram_x
10887                        	
10888                        		.dbg	line,	"include\init.c", 279; load_vram( LIFEBAR_3_VRAM_ADR, tileset_LIFE_YELLOW, SIZEOF(tileset_LIFE_YELLOW) >> 1 );
10889                        		__st.wmiq	4160, _di
         02:D49D  A9 40      			lda.l	#4160
         02:D49F  85 F0      			sta.l	_di
         02:D4A1  A9 10      			lda.h	#4160
         02:D4A3  85 F1      			sta.h	_di
10890                        		__farptr	_tileset_LIFE_YELLOW, _bp_bank, _bp
         02:D4A5  A9 80      			lda.l	#$6000 + ($1FFF & (_tileset_LIFE_YELLOW))
         02:D4A7  85 EC      			sta.l	_bp
         02:D4A9  A9 74      			lda.h	#$6000 + ($1FFF & (_tileset_LIFE_YELLOW))
         02:D4AB  85 ED      			sta.h	_bp
         02:D4AD  A9 03      			lda	#bank(_tileset_LIFE_YELLOW)
         02:D4AF  85 02      			sta	_bp_bank
10891                        		__ld.wi		___sizeof__tileset_LIFE_YELLOW
         02:D4B1  A9 40      			lda.l	#___sizeof__tileset_LIFE_YELLOW
         02:D4B3  A0 00      			ldy.h	#___sizeof__tileset_LIFE_YELLOW
10892                        		__lsr.wi	1
         02:D4B5  42         			say
         02:D4B6  4A         			lsr	a
         02:D4B7  42         			say
         02:D4B8  6A         			ror	a
10893                        		__st.wmq	_ax
         02:D4B9  85 F8      			sta.l	_ax
         02:D4BB  84 F9      			sty.h	_ax
10894                        		 _load_vram.3
         02:D4BD  82         			clx				; Offset to PCE VDC.
         02:D4BE  20 63 FF   			call	load_vram_x
10895                        	
10896                        		.dbg	line,	"include\init.c", 280; load_vram( LIFEBAR_4_VRAM_ADR, tileset_LIFE_YELLOW, SIZEOF(tileset_LIFE_YELLOW) >> 1 );
10897                        		__st.wmiq	4192, _di
         02:D4C1  A9 60      			lda.l	#4192
         02:D4C3  85 F0      			sta.l	_di
         02:D4C5  A9 10      			lda.h	#4192
         02:D4C7  85 F1      			sta.h	_di
10898                        		__farptr	_tileset_LIFE_YELLOW, _bp_bank, _bp
         02:D4C9  A9 80      			lda.l	#$6000 + ($1FFF & (_tileset_LIFE_YELLOW))
         02:D4CB  85 EC      			sta.l	_bp
         02:D4CD  A9 74      			lda.h	#$6000 + ($1FFF & (_tileset_LIFE_YELLOW))
         02:D4CF  85 ED      			sta.h	_bp
         02:D4D1  A9 03      			lda	#bank(_tileset_LIFE_YELLOW)
         02:D4D3  85 02      			sta	_bp_bank
10899                        		__ld.wi		___sizeof__tileset_LIFE_YELLOW
         02:D4D5  A9 40      			lda.l	#___sizeof__tileset_LIFE_YELLOW
         02:D4D7  A0 00      			ldy.h	#___sizeof__tileset_LIFE_YELLOW
10900                        		__lsr.wi	1
         02:D4D9  42         			say
         02:D4DA  4A         			lsr	a
         02:D4DB  42         			say
         02:D4DC  6A         			ror	a
10901                        		__st.wmq	_ax
         02:D4DD  85 F8      			sta.l	_ax
         02:D4DF  84 F9      			sty.h	_ax
10902                        		 _load_vram.3
         02:D4E1  82         			clx				; Offset to PCE VDC.
         02:D4E2  20 63 FF   			call	load_vram_x
10903                        	
10904                        		.dbg	line,	"include\init.c", 281; load_vram( LIFEBAR_5_VRAM_ADR, tileset_LIFE_EMPTY, SIZEOF(tileset_LIFE_EMPTY) >> 1 );
10905                        		__st.wmiq	4224, _di
         02:D4E5  A9 80      			lda.l	#4224
         02:D4E7  85 F0      			sta.l	_di
         02:D4E9  A9 10      			lda.h	#4224
         02:D4EB  85 F1      			sta.h	_di
10906                        		__farptr	_tileset_LIFE_EMPTY, _bp_bank, _bp
         02:D4ED  A9 C0      			lda.l	#$6000 + ($1FFF & (_tileset_LIFE_EMPTY))
         02:D4EF  85 EC      			sta.l	_bp
         02:D4F1  A9 74      			lda.h	#$6000 + ($1FFF & (_tileset_LIFE_EMPTY))
         02:D4F3  85 ED      			sta.h	_bp
         02:D4F5  A9 03      			lda	#bank(_tileset_LIFE_EMPTY)
         02:D4F7  85 02      			sta	_bp_bank
10907                        		__ld.wi		___sizeof__tileset_LIFE_EMPTY
         02:D4F9  A9 40      			lda.l	#___sizeof__tileset_LIFE_EMPTY
         02:D4FB  A0 00      			ldy.h	#___sizeof__tileset_LIFE_EMPTY
10908                        		__lsr.wi	1
         02:D4FD  42         			say
         02:D4FE  4A         			lsr	a
         02:D4FF  42         			say
         02:D500  6A         			ror	a
10909                        		__st.wmq	_ax
         02:D501  85 F8      			sta.l	_ax
         02:D503  84 F9      			sty.h	_ax
10910                        		 _load_vram.3
         02:D505  82         			clx				; Offset to PCE VDC.
         02:D506  20 63 FF   			call	load_vram_x
10911                        	
10912                        		.dbg	line,	"include\init.c", 284; //--------------------------------------------------------------------------------------//
10913                        	
10914                        		.dbg	line,	"include\init.c", 285; //                               LOAD WEAPON + ARMOR TILES                              //
10915                        	
10916                        		.dbg	line,	"include\init.c", 286; //--------------------------------------------------------------------------------------//
10917                        	
10918                        		.dbg	line,	"include\init.c", 288; if(weapon_level == 1)
10919                        		__ld.umq	_weapon_level
         02:D509  AD 1F 23   			lda	_weapon_level
10920                        		__equ_b.uiq	1
         02:D50C  C9 01      			cmp	#1
         02:D50E  F0 01      			beq	!+
         02:D510  18         			clc
         02:D511             	!:
10921                        		__bfalse	.LL465
         02:D511  90 27      			bcc	.LL465
10922                        	
10923                        		.dbg	line,	"include\init.c", 289; {
10924                        	
10925                        		.dbg	line,	"include\init.c", 290; load_vram( WEAPON_VRAM_ADR, tileset_WEAPON_1, SIZEOF(tileset_WEAPON_1) >> 1 );
10926                        		__st.wmiq	4256, _di
         02:D513  A9 A0      			lda.l	#4256
         02:D515  85 F0      			sta.l	_di
         02:D517  A9 10      			lda.h	#4256
         02:D519  85 F1      			sta.h	_di
10927                        		__farptr	_tileset_WEAPON_1, _bp_bank, _bp
         02:D51B  A9 00      			lda.l	#$6000 + ($1FFF & (_tileset_WEAPON_1))
         02:D51D  85 EC      			sta.l	_bp
         02:D51F  A9 77      			lda.h	#$6000 + ($1FFF & (_tileset_WEAPON_1))
         02:D521  85 ED      			sta.h	_bp
         02:D523  A9 03      			lda	#bank(_tileset_WEAPON_1)
         02:D525  85 02      			sta	_bp_bank
10928                        		__ld.wi		___sizeof__tileset_WEAPON_1
         02:D527  A9 80      			lda.l	#___sizeof__tileset_WEAPON_1
         02:D529  A0 00      			ldy.h	#___sizeof__tileset_WEAPON_1
10929                        		__lsr.wi	1
         02:D52B  42         			say
         02:D52C  4A         			lsr	a
         02:D52D  42         			say
         02:D52E  6A         			ror	a
10930                        		__st.wmq	_ax
         02:D52F  85 F8      			sta.l	_ax
         02:D531  84 F9      			sty.h	_ax
10931                        		 _load_vram.3
         02:D533  82         			clx				; Offset to PCE VDC.
         02:D534  20 63 FF   			call	load_vram_x
10932                        	
10933                        		.dbg	line,	"include\init.c", 291; }
10934                        	
10935                        		.dbg	line,	"include\init.c", 293; else if(weapon_level == 2)
10936                        		__bra		.LL466
         02:D537  4C F9 D5   			bra	.LL466
10937    02:D53A             	.LL465:
10938                        		__ld.umq	_weapon_level
         02:D53A  AD 1F 23   			lda	_weapon_level
10939                        		__equ_b.uiq	2
         02:D53D  C9 02      			cmp	#2
         02:D53F  F0 01      			beq	!+
         02:D541  18         			clc
         02:D542             	!:
10940                        		__bfalse	.LL467
         02:D542  90 27      			bcc	.LL467
10941                        	
10942                        		.dbg	line,	"include\init.c", 294; {
10943                        	
10944                        		.dbg	line,	"include\init.c", 295; load_vram( WEAPON_VRAM_ADR, tileset_WEAPON_2, SIZEOF(tileset_WEAPON_2) >> 1 );
10945                        		__st.wmiq	4256, _di
         02:D544  A9 A0      			lda.l	#4256
         02:D546  85 F0      			sta.l	_di
         02:D548  A9 10      			lda.h	#4256
         02:D54A  85 F1      			sta.h	_di
10946                        		__farptr	_tileset_WEAPON_2, _bp_bank, _bp
         02:D54C  A9 80      			lda.l	#$6000 + ($1FFF & (_tileset_WEAPON_2))
         02:D54E  85 EC      			sta.l	_bp
         02:D550  A9 77      			lda.h	#$6000 + ($1FFF & (_tileset_WEAPON_2))
         02:D552  85 ED      			sta.h	_bp
         02:D554  A9 03      			lda	#bank(_tileset_WEAPON_2)
         02:D556  85 02      			sta	_bp_bank
10947                        		__ld.wi		___sizeof__tileset_WEAPON_2
         02:D558  A9 80      			lda.l	#___sizeof__tileset_WEAPON_2
         02:D55A  A0 00      			ldy.h	#___sizeof__tileset_WEAPON_2
10948                        		__lsr.wi	1
         02:D55C  42         			say
         02:D55D  4A         			lsr	a
         02:D55E  42         			say
         02:D55F  6A         			ror	a
10949                        		__st.wmq	_ax
         02:D560  85 F8      			sta.l	_ax
         02:D562  84 F9      			sty.h	_ax
10950                        		 _load_vram.3
         02:D564  82         			clx				; Offset to PCE VDC.
         02:D565  20 63 FF   			call	load_vram_x
10951                        	
10952                        		.dbg	line,	"include\init.c", 296; }
10953                        	
10954                        		.dbg	line,	"include\init.c", 298; else if(weapon_level == 3)
10955                        		__bra		.LL468
         02:D568  4C F9 D5   			bra	.LL468
10956    02:D56B             	.LL467:
10957                        		__ld.umq	_weapon_level
         02:D56B  AD 1F 23   			lda	_weapon_level
10958                        		__equ_b.uiq	3
         02:D56E  C9 03      			cmp	#3
         02:D570  F0 01      			beq	!+
         02:D572  18         			clc
         02:D573             	!:
10959                        		__bfalse	.LL469
         02:D573  90 26      			bcc	.LL469
10960                        	
10961                        		.dbg	line,	"include\init.c", 299; {
10962                        	
10963                        		.dbg	line,	"include\init.c", 300; load_vram( WEAPON_VRAM_ADR, tileset_WEAPON_4, SIZEOF(tileset_WEAPON_4) >> 1 );
10964                        		__st.wmiq	4256, _di
         02:D575  A9 A0      			lda.l	#4256
         02:D577  85 F0      			sta.l	_di
         02:D579  A9 10      			lda.h	#4256
         02:D57B  85 F1      			sta.h	_di
10965                        		__farptr	_tileset_WEAPON_4, _bp_bank, _bp
         02:D57D  A9 00      			lda.l	#$6000 + ($1FFF & (_tileset_WEAPON_4))
         02:D57F  85 EC      			sta.l	_bp
         02:D581  A9 78      			lda.h	#$6000 + ($1FFF & (_tileset_WEAPON_4))
         02:D583  85 ED      			sta.h	_bp
         02:D585  A9 03      			lda	#bank(_tileset_WEAPON_4)
         02:D587  85 02      			sta	_bp_bank
10966                        		__ld.wi		___sizeof__tileset_WEAPON_4
         02:D589  A9 80      			lda.l	#___sizeof__tileset_WEAPON_4
         02:D58B  A0 00      			ldy.h	#___sizeof__tileset_WEAPON_4
10967                        		__lsr.wi	1
         02:D58D  42         			say
         02:D58E  4A         			lsr	a
         02:D58F  42         			say
         02:D590  6A         			ror	a
10968                        		__st.wmq	_ax
         02:D591  85 F8      			sta.l	_ax
         02:D593  84 F9      			sty.h	_ax
10969                        		 _load_vram.3
         02:D595  82         			clx				; Offset to PCE VDC.
         02:D596  20 63 FF   			call	load_vram_x
10970                        	
10971                        		.dbg	line,	"include\init.c", 301; }
10972                        	
10973                        		.dbg	line,	"include\init.c", 303; else if(weapon_level == 4)
10974                        		__bra		.LL470
         02:D599  80 5E      			bra	.LL470
10975    02:D59B             	.LL469:
10976                        		__ld.umq	_weapon_level
         02:D59B  AD 1F 23   			lda	_weapon_level
10977                        		__equ_b.uiq	4
         02:D59E  C9 04      			cmp	#4
         02:D5A0  F0 01      			beq	!+
         02:D5A2  18         			clc
         02:D5A3             	!:
10978                        		__bfalse	.LL471
         02:D5A3  90 26      			bcc	.LL471
10979                        	
10980                        		.dbg	line,	"include\init.c", 304; {
10981                        	
10982                        		.dbg	line,	"include\init.c", 305; load_vram( WEAPON_VRAM_ADR, tileset_WEAPON_5, SIZEOF(tileset_WEAPON_5) >> 1 );
10983                        		__st.wmiq	4256, _di
         02:D5A5  A9 A0      			lda.l	#4256
         02:D5A7  85 F0      			sta.l	_di
         02:D5A9  A9 10      			lda.h	#4256
         02:D5AB  85 F1      			sta.h	_di
10984                        		__farptr	_tileset_WEAPON_5, _bp_bank, _bp
         02:D5AD  A9 80      			lda.l	#$6000 + ($1FFF & (_tileset_WEAPON_5))
         02:D5AF  85 EC      			sta.l	_bp
         02:D5B1  A9 78      			lda.h	#$6000 + ($1FFF & (_tileset_WEAPON_5))
         02:D5B3  85 ED      			sta.h	_bp
         02:D5B5  A9 03      			lda	#bank(_tileset_WEAPON_5)
         02:D5B7  85 02      			sta	_bp_bank
10985                        		__ld.wi		___sizeof__tileset_WEAPON_5
         02:D5B9  A9 80      			lda.l	#___sizeof__tileset_WEAPON_5
         02:D5BB  A0 00      			ldy.h	#___sizeof__tileset_WEAPON_5
10986                        		__lsr.wi	1
         02:D5BD  42         			say
         02:D5BE  4A         			lsr	a
         02:D5BF  42         			say
         02:D5C0  6A         			ror	a
10987                        		__st.wmq	_ax
         02:D5C1  85 F8      			sta.l	_ax
         02:D5C3  84 F9      			sty.h	_ax
10988                        		 _load_vram.3
         02:D5C5  82         			clx				; Offset to PCE VDC.
         02:D5C6  20 63 FF   			call	load_vram_x
10989                        	
10990                        		.dbg	line,	"include\init.c", 306; }
10991                        	
10992                        		.dbg	line,	"include\init.c", 308; else if(weapon_level == 5)
10993                        		__bra		.LL472
         02:D5C9  80 2E      			bra	.LL472
10994    02:D5CB             	.LL471:
10995                        		__ld.umq	_weapon_level
         02:D5CB  AD 1F 23   			lda	_weapon_level
10996                        		__equ_b.uiq	5
         02:D5CE  C9 05      			cmp	#5
         02:D5D0  F0 01      			beq	!+
         02:D5D2  18         			clc
         02:D5D3             	!:
10997                        		__bfalse	.LL473
         02:D5D3  90 24      			bcc	.LL473
10998                        	
10999                        		.dbg	line,	"include\init.c", 309; {
11000                        	
11001                        		.dbg	line,	"include\init.c", 310; load_vram( WEAPON_VRAM_ADR, tileset_WEAPON_8, SIZEOF(tileset_WEAPON_8) >> 1 );
11002                        		__st.wmiq	4256, _di
         02:D5D5  A9 A0      			lda.l	#4256
         02:D5D7  85 F0      			sta.l	_di
         02:D5D9  A9 10      			lda.h	#4256
         02:D5DB  85 F1      			sta.h	_di
11003                        		__farptr	_tileset_WEAPON_8, _bp_bank, _bp
         02:D5DD  A9 00      			lda.l	#$6000 + ($1FFF & (_tileset_WEAPON_8))
         02:D5DF  85 EC      			sta.l	_bp
         02:D5E1  A9 79      			lda.h	#$6000 + ($1FFF & (_tileset_WEAPON_8))
         02:D5E3  85 ED      			sta.h	_bp
         02:D5E5  A9 03      			lda	#bank(_tileset_WEAPON_8)
         02:D5E7  85 02      			sta	_bp_bank
11004                        		__ld.wi		___sizeof__tileset_WEAPON_8
         02:D5E9  A9 80      			lda.l	#___sizeof__tileset_WEAPON_8
         02:D5EB  A0 00      			ldy.h	#___sizeof__tileset_WEAPON_8
11005                        		__lsr.wi	1
         02:D5ED  42         			say
         02:D5EE  4A         			lsr	a
         02:D5EF  42         			say
         02:D5F0  6A         			ror	a
11006                        		__st.wmq	_ax
         02:D5F1  85 F8      			sta.l	_ax
         02:D5F3  84 F9      			sty.h	_ax
11007                        		 _load_vram.3
         02:D5F5  82         			clx				; Offset to PCE VDC.
         02:D5F6  20 63 FF   			call	load_vram_x
11008                        	
11009                        		.dbg	line,	"include\init.c", 311; }
11010                        	
11011                        		.dbg	line,	"include\init.c", 316; if(armor_level == 1)
11012    02:D5F9             	.LL473:
11013    02:D5F9             	.LL472:
11014    02:D5F9             	.LL470:
11015    02:D5F9             	.LL468:
11016    02:D5F9             	.LL466:
11017                        		__ld.umq	_armor_level
         02:D5F9  AD 1E 23   			lda	_armor_level
11018                        		__equ_b.uiq	1
         02:D5FC  C9 01      			cmp	#1
         02:D5FE  F0 01      			beq	!+
         02:D600  18         			clc
         02:D601             	!:
11019                        		__bfalse	.LL474
         02:D601  90 27      			bcc	.LL474
11020                        	
11021                        		.dbg	line,	"include\init.c", 317; {
11022                        	
11023                        		.dbg	line,	"include\init.c", 318; load_vram( ARMOR_VRAM_ADR, tileset_ARMOR_1, SIZEOF(tileset_ARMOR_1) >> 1 );
11024                        		__st.wmiq	4320, _di
         02:D603  A9 E0      			lda.l	#4320
         02:D605  85 F0      			sta.l	_di
         02:D607  A9 10      			lda.h	#4320
         02:D609  85 F1      			sta.h	_di
11025                        		__farptr	_tileset_ARMOR_1, _bp_bank, _bp
         02:D60B  A9 00      			lda.l	#$6000 + ($1FFF & (_tileset_ARMOR_1))
         02:D60D  85 EC      			sta.l	_bp
         02:D60F  A9 75      			lda.h	#$6000 + ($1FFF & (_tileset_ARMOR_1))
         02:D611  85 ED      			sta.h	_bp
         02:D613  A9 03      			lda	#bank(_tileset_ARMOR_1)
         02:D615  85 02      			sta	_bp_bank
11026                        		__ld.wi		___sizeof__tileset_ARMOR_1
         02:D617  A9 80      			lda.l	#___sizeof__tileset_ARMOR_1
         02:D619  A0 00      			ldy.h	#___sizeof__tileset_ARMOR_1
11027                        		__lsr.wi	1
         02:D61B  42         			say
         02:D61C  4A         			lsr	a
         02:D61D  42         			say
         02:D61E  6A         			ror	a
11028                        		__st.wmq	_ax
         02:D61F  85 F8      			sta.l	_ax
         02:D621  84 F9      			sty.h	_ax
11029                        		 _load_vram.3
         02:D623  82         			clx				; Offset to PCE VDC.
         02:D624  20 63 FF   			call	load_vram_x
11030                        	
11031                        		.dbg	line,	"include\init.c", 319; }
11032                        	
11033                        		.dbg	line,	"include\init.c", 321; else if(armor_level == 2)
11034                        		__bra		.LL475
         02:D627  4C B8 D6   			bra	.LL475
11035    02:D62A             	.LL474:
11036                        		__ld.umq	_armor_level
         02:D62A  AD 1E 23   			lda	_armor_level
11037                        		__equ_b.uiq	2
         02:D62D  C9 02      			cmp	#2
         02:D62F  F0 01      			beq	!+
         02:D631  18         			clc
         02:D632             	!:
11038                        		__bfalse	.LL476
         02:D632  90 26      			bcc	.LL476
11039                        	
11040                        		.dbg	line,	"include\init.c", 322; {
11041                        	
11042                        		.dbg	line,	"include\init.c", 323; load_vram( ARMOR_VRAM_ADR, tileset_ARMOR_2, SIZEOF(tileset_ARMOR_2) >> 1 );
11043                        		__st.wmiq	4320, _di
         02:D634  A9 E0      			lda.l	#4320
         02:D636  85 F0      			sta.l	_di
         02:D638  A9 10      			lda.h	#4320
         02:D63A  85 F1      			sta.h	_di
11044                        		__farptr	_tileset_ARMOR_2, _bp_bank, _bp
         02:D63C  A9 80      			lda.l	#$6000 + ($1FFF & (_tileset_ARMOR_2))
         02:D63E  85 EC      			sta.l	_bp
         02:D640  A9 75      			lda.h	#$6000 + ($1FFF & (_tileset_ARMOR_2))
         02:D642  85 ED      			sta.h	_bp
         02:D644  A9 03      			lda	#bank(_tileset_ARMOR_2)
         02:D646  85 02      			sta	_bp_bank
11045                        		__ld.wi		___sizeof__tileset_ARMOR_2
         02:D648  A9 80      			lda.l	#___sizeof__tileset_ARMOR_2
         02:D64A  A0 00      			ldy.h	#___sizeof__tileset_ARMOR_2
11046                        		__lsr.wi	1
         02:D64C  42         			say
         02:D64D  4A         			lsr	a
         02:D64E  42         			say
         02:D64F  6A         			ror	a
11047                        		__st.wmq	_ax
         02:D650  85 F8      			sta.l	_ax
         02:D652  84 F9      			sty.h	_ax
11048                        		 _load_vram.3
         02:D654  82         			clx				; Offset to PCE VDC.
         02:D655  20 63 FF   			call	load_vram_x
11049                        	
11050                        		.dbg	line,	"include\init.c", 324; }
11051                        	
11052                        		.dbg	line,	"include\init.c", 326; else if(armor_level == 3)
11053                        		__bra		.LL477
         02:D658  80 5E      			bra	.LL477
11054    02:D65A             	.LL476:
11055                        		__ld.umq	_armor_level
         02:D65A  AD 1E 23   			lda	_armor_level
11056                        		__equ_b.uiq	3
         02:D65D  C9 03      			cmp	#3
         02:D65F  F0 01      			beq	!+
         02:D661  18         			clc
         02:D662             	!:
11057                        		__bfalse	.LL478
         02:D662  90 26      			bcc	.LL478
11058                        	
11059                        		.dbg	line,	"include\init.c", 327; {
11060                        	
11061                        		.dbg	line,	"include\init.c", 328; load_vram( ARMOR_VRAM_ADR, tileset_ARMOR_4, SIZEOF(tileset_ARMOR_4) >> 1 );
11062                        		__st.wmiq	4320, _di
         02:D664  A9 E0      			lda.l	#4320
         02:D666  85 F0      			sta.l	_di
         02:D668  A9 10      			lda.h	#4320
         02:D66A  85 F1      			sta.h	_di
11063                        		__farptr	_tileset_ARMOR_4, _bp_bank, _bp
         02:D66C  A9 00      			lda.l	#$6000 + ($1FFF & (_tileset_ARMOR_4))
         02:D66E  85 EC      			sta.l	_bp
         02:D670  A9 76      			lda.h	#$6000 + ($1FFF & (_tileset_ARMOR_4))
         02:D672  85 ED      			sta.h	_bp
         02:D674  A9 03      			lda	#bank(_tileset_ARMOR_4)
         02:D676  85 02      			sta	_bp_bank
11064                        		__ld.wi		___sizeof__tileset_ARMOR_4
         02:D678  A9 80      			lda.l	#___sizeof__tileset_ARMOR_4
         02:D67A  A0 00      			ldy.h	#___sizeof__tileset_ARMOR_4
11065                        		__lsr.wi	1
         02:D67C  42         			say
         02:D67D  4A         			lsr	a
         02:D67E  42         			say
         02:D67F  6A         			ror	a
11066                        		__st.wmq	_ax
         02:D680  85 F8      			sta.l	_ax
         02:D682  84 F9      			sty.h	_ax
11067                        		 _load_vram.3
         02:D684  82         			clx				; Offset to PCE VDC.
         02:D685  20 63 FF   			call	load_vram_x
11068                        	
11069                        		.dbg	line,	"include\init.c", 329; }
11070                        	
11071                        		.dbg	line,	"include\init.c", 331; else if(armor_level == 4)
11072                        		__bra		.LL479
         02:D688  80 2E      			bra	.LL479
11073    02:D68A             	.LL478:
11074                        		__ld.umq	_armor_level
         02:D68A  AD 1E 23   			lda	_armor_level
11075                        		__equ_b.uiq	4
         02:D68D  C9 04      			cmp	#4
         02:D68F  F0 01      			beq	!+
         02:D691  18         			clc
         02:D692             	!:
11076                        		__bfalse	.LL480
         02:D692  90 24      			bcc	.LL480
11077                        	
11078                        		.dbg	line,	"include\init.c", 332; {
11079                        	
11080                        		.dbg	line,	"include\init.c", 333; load_vram( ARMOR_VRAM_ADR, tileset_ARMOR_8, SIZEOF(tileset_ARMOR_8) >> 1 );
11081                        		__st.wmiq	4320, _di
         02:D694  A9 E0      			lda.l	#4320
         02:D696  85 F0      			sta.l	_di
         02:D698  A9 10      			lda.h	#4320
         02:D69A  85 F1      			sta.h	_di
11082                        		__farptr	_tileset_ARMOR_8, _bp_bank, _bp
         02:D69C  A9 80      			lda.l	#$6000 + ($1FFF & (_tileset_ARMOR_8))
         02:D69E  85 EC      			sta.l	_bp
         02:D6A0  A9 76      			lda.h	#$6000 + ($1FFF & (_tileset_ARMOR_8))
         02:D6A2  85 ED      			sta.h	_bp
         02:D6A4  A9 03      			lda	#bank(_tileset_ARMOR_8)
         02:D6A6  85 02      			sta	_bp_bank
11083                        		__ld.wi		___sizeof__tileset_ARMOR_8
         02:D6A8  A9 80      			lda.l	#___sizeof__tileset_ARMOR_8
         02:D6AA  A0 00      			ldy.h	#___sizeof__tileset_ARMOR_8
11084                        		__lsr.wi	1
         02:D6AC  42         			say
         02:D6AD  4A         			lsr	a
         02:D6AE  42         			say
         02:D6AF  6A         			ror	a
11085                        		__st.wmq	_ax
         02:D6B0  85 F8      			sta.l	_ax
         02:D6B2  84 F9      			sty.h	_ax
11086                        		 _load_vram.3
         02:D6B4  82         			clx				; Offset to PCE VDC.
         02:D6B5  20 63 FF   			call	load_vram_x
11087                        	
11088                        		.dbg	line,	"include\init.c", 334; }
11089                        	
11090                        		.dbg	line,	"include\init.c", 339; //--------------------------------------------------------------------------------------//
11091                        	
11092                        		.dbg	line,	"include\init.c", 340; //                                     SET MULTIMAP                                     //
11093                        	
11094                        		.dbg	line,	"include\init.c", 341; //--------------------------------------------------------------------------------------//
11095                        	
11096                        		.dbg	line,	"include\init.c", 343; // multimap is 2 screens wide //
11097                        	
11098                        		.dbg	line,	"include\init.c", 344; set_multimap( multimap_LV1_BG_A , 5 );
11099    02:D6B8             	.LL480:
11100    02:D6B8             	.LL479:
11101    02:D6B8             	.LL477:
11102    02:D6B8             	.LL475:
11103                        		__farptr	_multimap_LV1_BG_A, vdc_scr_bank, vdc_scr_addr
         02:D6B8  A9 00      			lda.l	#$6000 + ($1FFF & (_multimap_LV1_BG_A))
         02:D6BA  8D B7 2B   			sta.l	vdc_scr_addr
         02:D6BD  A9 78      			lda.h	#$6000 + ($1FFF & (_multimap_LV1_BG_A))
         02:D6BF  8D B8 2B   			sta.h	vdc_scr_addr
         02:D6C2  A9 0B      			lda	#bank(_multimap_LV1_BG_A)
         02:D6C4  8D B9 2B   			sta	vdc_scr_bank
11104                        		__st.umiq	5, vdc_map_scrn_w
         02:D6C7  A9 05      			lda.l	#5
         02:D6C9  8D 78 26   			sta	vdc_map_scrn_w
11105                        		 _set_multimap.2
         02:D6CC  AD 70 26   			lda	vdc_bat_width
         02:D6CF  4A         			lsr	a
         02:D6D0  8D 77 26   			sta	vdc_map_line_w
11106                        	
11107                        		.dbg	line,	"include\init.c", 347; //--------------------------------------------------------------------------------------//
11108                        	
11109                        		.dbg	line,	"include\init.c", 348; //                                    DRAW TILEMAP                                      //
11110                        	
11111                        		.dbg	line,	"include\init.c", 349; //--------------------------------------------------------------------------------------//
11112                        	
11113                        		.dbg	line,	"include\init.c", 351; // The blkmap is drawn using global variables for the top-left coordinate
11114                        	
11115                        		.dbg	line,	"include\init.c", 352; // in pixels, and the draw width and height in terms of 8x8 characters.
11116                        	
11117                        		.dbg	line,	"include\init.c", 354; vdc_map_pxl_x = 0;
11118                        		__st.wmiq	0, _vdc_map_pxl_x
         02:D6D3  9C 79 26   			stz.l	_vdc_map_pxl_x
         02:D6D6  9C 7A 26   			stz.h	_vdc_map_pxl_x
11119                        	
11120                        		.dbg	line,	"include\init.c", 355; vdc_map_pxl_y = 0;
11121                        		__st.wmiq	0, _vdc_map_pxl_y
         02:D6D9  9C 7B 26   			stz.l	_vdc_map_pxl_y
         02:D6DC  9C 7C 26   			stz.h	_vdc_map_pxl_y
11122                        	
11123                        		.dbg	line,	"include\init.c", 357; vdc_map_draw_w = 32;
11124                        		__st.umiq	32, _vdc_map_draw_w
         02:D6DF  A9 20      			lda.l	#32
         02:D6E1  8D 75 26   			sta	_vdc_map_draw_w
11125                        	
11126                        		.dbg	line,	"include\init.c", 358; vdc_map_draw_h = 28;
11127                        		__st.umiq	28, _vdc_map_draw_h
         02:D6E4  A9 1C      			lda.l	#28
         02:D6E6  8D 76 26   			sta	_vdc_map_draw_h
11128                        	
11129                        		.dbg	line,	"include\init.c", 360; draw_map();
11130                        		__call		_draw_map
         02:D6E9  20 1D FF   			call	_draw_map
11131                        	
11132                        		.dbg	line,	"include\init.c", 362; display_SCORE();
11133                        		__call		_display_SCORE
         02:D6EC  20 13 FF   			call	_display_SCORE
11134                        	
11135                        		.dbg	line,	"include\init.c", 363; display_TIME_LEVEL();
11136                        		__call		_display_TIME_LEVEL
         02:D6EF  20 09 FF   			call	_display_TIME_LEVEL
11137                        	
11138                        		.dbg	line,	"include\init.c", 364; display_KEY();
11139                        		__call		_display_KEY
         02:D6F2  20 8B FF   			call	_display_KEY
11140                        	
11141                        		.dbg	line,	"include\init.c", 365; display_POTION();
11142                        		__call		_display_POTION
         02:D6F5  20 3B FF   			call	_display_POTION
11143                        	
11144                        		.dbg	line,	"include\init.c", 366; display_ZENNY();
11145                        		__call		_display_ZENNY
         02:D6F8  20 45 FF   			call	_display_ZENNY
11146                        	
11147                        		.dbg	line,	"include\init.c", 367; }
11148    02:D6FB             	.LL464:
11149                        		__return	0
         02:D6FB  4C EF FF   			jmp	leave_proc
11150                        		.dbg	clear
11151                        		.endp
11152                        		.pceas
11153                        	
11154                        		.dbg	line,	"include\init.c", 370; void init_LEVEL()
11155                        		.dbg	line,	"include\init.c", 371; {
11156                        	;***********************
11157                        	;***********************
11158                        	
11159                        		.hucc
11160    02:D6FE             		.proc		_init_LEVEL
11161                        		__enter		_init_LEVEL
11162                        	
11163                        		.dbg	line,	"include\init.c", 372; if(level_id == 1)
11164                        		__ld.umq	_level_id
         02:D6FE  AD 12 23   			lda	_level_id
11165                        		__equ_b.uiq	1
         02:D701  C9 01      			cmp	#1
         02:D703  F0 01      			beq	!+
         02:D705  18         			clc
         02:D706             	!:
11166                        		__bfalse	.LL482
         02:D706  B0 03 4C C2			bcc	.LL482
         02:D70A  D9          
11167                        	
11168                        		.dbg	line,	"include\init.c", 373; {
11169                        	
11170                        		.dbg	line,	"include\init.c", 374; // VSYNC //
11171                        	
11172                        		.dbg	line,	"include\init.c", 375; vsync();
11173                        		__call		_vsync
         02:D70B  20 09 E3   			call	_vsync
11174                        	
11175                        		.dbg	line,	"include\init.c", 378; // DISABLE DISPLAY //
11176                        	
11177                        		.dbg	line,	"include\init.c", 379; disp_off();
11178                        		__call		_disp_off
         02:D70E  20 29 E4   			call	_disp_off
11179                        	
11180                        		.dbg	line,	"include\init.c", 382; // SET VDC 1 SCREEN SIZE (IN TILES) - 64x32 = 512x256 PIXELS
11181                        	
11182                        		.dbg	line,	"include\init.c", 383; set_screen_size(SCR_SIZE_64x32);
11183                        		__st.umiq	1, _al
         02:D711  A9 01      			lda.l	#1
         02:D713  85 F8      			sta	_al
11184                        		__call		_set_screen_size.1
         02:D715  20 31 FF   			call	_set_screen_size.1
11185                        	
11186                        		.dbg	line,	"include\init.c", 386; // SET VDC 2 SCREEN SIZE (IN TILES) - 64x32 = 512x256 PIXELS
11187                        	
11188                        		.dbg	line,	"include\init.c", 387; sgx_set_screen_size(SCR_SIZE_64x32);
11189                        		__st.umiq	1, _al
         02:D718  A9 01      			lda.l	#1
         02:D71A  85 F8      			sta	_al
11190                        		__call		_sgx_set_screen_size.1
         02:D71C  20 27 FF   			call	_sgx_set_screen_size.1
11191                        	
11192                        		.dbg	line,	"include\init.c", 390; // INIT SPRITE ATTRIBUTE TABLE //
11193                        	
11194                        		.dbg	line,	"include\init.c", 391; //init_satb();
11195                        	
11196                        		.dbg	line,	"include\init.c", 396; //**************************************************************************************//
11197                        	
11198                        		.dbg	line,	"include\init.c", 397; //                                                                                      //
11199                        	
11200                        		.dbg	line,	"include\init.c", 398; //                                      VARIABLES                                       //
11201                        	
11202                        		.dbg	line,	"include\init.c", 399; //                                                                                      //
11203                        	
11204                        		.dbg	line,	"include\init.c", 400; //**************************************************************************************//
11205                        	
11206                        		.dbg	line,	"include\init.c", 402; time_counter = 0;
11207                        		__st.umiq	0, _time_counter
         02:D71F  9C 25 23   			stz	_time_counter
11208                        	
11209                        		.dbg	line,	"include\init.c", 403; 
11210                        	
11211                        		.dbg	line,	"include\init.c", 404; if(respawn == RESPAWN_SHOP)
11212                        		__ld.umq	_respawn
         02:D722  AD 13 23   			lda	_respawn
11213                        		__equ_b.uiq	2
         02:D725  C9 02      			cmp	#2
         02:D727  F0 01      			beq	!+
         02:D729  18         			clc
         02:D72A             	!:
11214                        		__bfalse	.LL483
         02:D72A  90 10      			bcc	.LL483
11215                        	
11216                        		.dbg	line,	"include\init.c", 405; {
11217                        	
11218                        		.dbg	line,	"include\init.c", 406; minutes = minutes_backup;
11219                        		__ld.um		_minutes_backup
         02:D72C  AD 26 23   			lda	_minutes_backup
         02:D72F  C2         			cly
11220                        		__st.umq	_minutes
         02:D730  8D 23 23   			sta	_minutes
11221                        	
11222                        		.dbg	line,	"include\init.c", 407; seconds = seconds_backup;
11223                        		__ld.um		_seconds_backup
         02:D733  AD 27 23   			lda	_seconds_backup
         02:D736  C2         			cly
11224                        		__st.umq	_seconds
         02:D737  8D 24 23   			sta	_seconds
11225                        	
11226                        		.dbg	line,	"include\init.c", 408; }
11227                        	
11228                        		.dbg	line,	"include\init.c", 410; else
11229                        		__bra		.LL484
         02:D73A  80 0A      			bra	.LL484
11230    02:D73C             	.LL483:
11231                        	
11232                        		.dbg	line,	"include\init.c", 411; {
11233                        	
11234                        		.dbg	line,	"include\init.c", 412; minutes = 1;
11235                        		__st.umiq	1, _minutes
         02:D73C  A9 01      			lda.l	#1
         02:D73E  8D 23 23   			sta	_minutes
11236                        	
11237                        		.dbg	line,	"include\init.c", 413; seconds = 59;
11238                        		__st.umiq	59, _seconds
         02:D741  A9 3B      			lda.l	#59
         02:D743  8D 24 23   			sta	_seconds
11239                        	
11240                        		.dbg	line,	"include\init.c", 414; }
11241    02:D746             	.LL484:
11242                        	
11243                        		.dbg	line,	"include\init.c", 416; camera_max_y_position = 768;
11244                        		__st.wmiq	768, _camera_max_y_position
         02:D746  9C D1 24   			stz.l	_camera_max_y_position
         02:D749  A9 03      			lda.h	#768
         02:D74B  8D D2 24   			sta.h	_camera_max_y_position
11245                        	
11246                        		.dbg	line,	"include\init.c", 417; jump_max_index = 34;
11247                        		__st.umiq	34, _jump_max_index
         02:D74E  A9 22      			lda.l	#34
         02:D750  8D 1D 23   			sta	_jump_max_index
11248                        	
11249                        		.dbg	line,	"include\init.c", 418; score = 0;
11250                        		__st.wmiq	0, _score
         02:D753  9C 29 26   			stz.l	_score
         02:D756  9C 2A 26   			stz.h	_score
11251                        	
11252                        		.dbg	line,	"include\init.c", 419; level_object_number = OBJECT_NUMBER_LV1;
11253                        		__st.umiq	23, _level_object_number
         02:D759  A9 17      			lda.l	#23
         02:D75B  8D 29 23   			sta	_level_object_number
11254                        	
11255                        		.dbg	line,	"include\init.c", 420; level_chest_number = CHEST_NUMBER_LV1;
11256                        		__st.umiq	2, _level_chest_number
         02:D75E  A9 02      			lda.l	#2
         02:D760  8D 98 23   			sta	_level_chest_number
11257                        	
11258                        		.dbg	line,	"include\init.c", 421; level_npc_number = NPC_NUMBER_LV1;
11259                        		__st.umiq	2, _level_npc_number
         02:D763  A9 02      			lda.l	#2
         02:D765  8D AB 23   			sta	_level_npc_number
11260                        	
11261                        		.dbg	line,	"include\init.c", 422; object_start_index = OBJECT_START_INDEX_LV1;
11262                        		__st.umiq	3, _object_start_index
         02:D768  A9 03      			lda.l	#3
         02:D76A  8D 28 23   			sta	_object_start_index
11263                        	
11264                        		.dbg	line,	"include\init.c", 423; chest_start_index = CHEST_START_INDEX_LV1;
11265                        		__st.umiq	26, _chest_start_index
         02:D76D  A9 1A      			lda.l	#26
         02:D76F  8D 97 23   			sta	_chest_start_index
11266                        	
11267                        		.dbg	line,	"include\init.c", 424; npc_start_index = NPC_START_INDEX_LV1;
11268                        		__st.umiq	28, _npc_start_index
         02:D772  A9 1C      			lda.l	#28
         02:D774  8D AA 23   			sta	_npc_start_index
11269                        	
11270                        		.dbg	line,	"include\init.c", 425; jump_ladder = FALSE;
11271                        		__st.umiq	0, _jump_ladder
         02:D777  9C 1C 23   			stz	_jump_ladder
11272                        	
11273                        		.dbg	line,	"include\init.c", 430; //**************************************************************************************//
11274                        	
11275                        		.dbg	line,	"include\init.c", 431; //                                                                                      //
11276                        	
11277                        		.dbg	line,	"include\init.c", 432; //                                        VDC 2                                         //
11278                        	
11279                        		.dbg	line,	"include\init.c", 433; //                                                                                      //
11280                        	
11281                        		.dbg	line,	"include\init.c", 434; //**************************************************************************************//
11282                        	
11283                        		.dbg	line,	"include\init.c", 436; //--------------------------------------------------------------------------------------//
11284                        	
11285                        		.dbg	line,	"include\init.c", 437; //                                    LOAD TILESET                                      //
11286                        	
11287                        		.dbg	line,	"include\init.c", 438; //--------------------------------------------------------------------------------------//
11288                        	
11289                        		.dbg	line,	"include\init.c", 440; sgx_load_vram( 0x1000, tileset_LV1_BG_B, SIZEOF(tileset_LV1_BG_B) >> 1 );
11290                        		__st.wmiq	4096, _di
         02:D77A  64 F0      			stz.l	_di
         02:D77C  A9 10      			lda.h	#4096
         02:D77E  85 F1      			sta.h	_di
11291                        		__farptr	_tileset_LV1_BG_B, _bp_bank, _bp
         02:D780  A9 80      			lda.l	#$6000 + ($1FFF & (_tileset_LV1_BG_B))
         02:D782  85 EC      			sta.l	_bp
         02:D784  A9 79      			lda.h	#$6000 + ($1FFF & (_tileset_LV1_BG_B))
         02:D786  85 ED      			sta.h	_bp
         02:D788  A9 03      			lda	#bank(_tileset_LV1_BG_B)
         02:D78A  85 02      			sta	_bp_bank
11292                        		__ld.wi		___sizeof__tileset_LV1_BG_B
         02:D78C  A9 E0      			lda.l	#___sizeof__tileset_LV1_BG_B
         02:D78E  A0 72      			ldy.h	#___sizeof__tileset_LV1_BG_B
11293                        		__lsr.wi	1
         02:D790  42         			say
         02:D791  4A         			lsr	a
         02:D792  42         			say
         02:D793  6A         			ror	a
11294                        		__st.wmq	_ax
         02:D794  85 F8      			sta.l	_ax
         02:D796  84 F9      			sty.h	_ax
11295                        		 _sgx_load_vram.3
         02:D798  A2 10      			ldx	#SGX_VDC_OFFSET		; Offset to SGX VDC.
         02:D79A  20 63 FF   			call	load_vram_x
11296                        	
11297                        		.dbg	line,	"include\init.c", 443; //--------------------------------------------------------------------------------------//
11298                        	
11299                        		.dbg	line,	"include\init.c", 444; //                               LOAD WALL & DOOR TILES                                 //
11300                        	
11301                        		.dbg	line,	"include\init.c", 445; //--------------------------------------------------------------------------------------//
11302                        	
11303                        		.dbg	line,	"include\init.c", 447; sgx_load_vram( LV1_WALL_VRAM_ADR, tileset_LV1_WALL, SIZEOF(tileset_LV1_WALL) >> 1 );
11304                        		__st.wmiq	4096, _di
         02:D79D  64 F0      			stz.l	_di
         02:D79F  A9 10      			lda.h	#4096
         02:D7A1  85 F1      			sta.h	_di
11305                        		__farptr	_tileset_LV1_WALL, _bp_bank, _bp
         02:D7A3  A9 00      			lda.l	#$6000 + ($1FFF & (_tileset_LV1_WALL))
         02:D7A5  85 EC      			sta.l	_bp
         02:D7A7  A9 6C      			lda.h	#$6000 + ($1FFF & (_tileset_LV1_WALL))
         02:D7A9  85 ED      			sta.h	_bp
         02:D7AB  A9 03      			lda	#bank(_tileset_LV1_WALL)
         02:D7AD  85 02      			sta	_bp_bank
11306                        		__ld.wi		___sizeof__tileset_LV1_WALL
         02:D7AF  A9 00      			lda.l	#___sizeof__tileset_LV1_WALL
         02:D7B1  A0 02      			ldy.h	#___sizeof__tileset_LV1_WALL
11307                        		__lsr.wi	1
         02:D7B3  42         			say
         02:D7B4  4A         			lsr	a
         02:D7B5  42         			say
         02:D7B6  6A         			ror	a
11308                        		__st.wmq	_ax
         02:D7B7  85 F8      			sta.l	_ax
         02:D7B9  84 F9      			sty.h	_ax
11309                        		 _sgx_load_vram.3
         02:D7BB  A2 10      			ldx	#SGX_VDC_OFFSET		; Offset to SGX VDC.
         02:D7BD  20 63 FF   			call	load_vram_x
11310                        	
11311                        		.dbg	line,	"include\init.c", 448; sgx_load_vram( LV1_DOOR_VRAM_ADR, tileset_LV1_DOOR_OPEN, SIZEOF(tileset_LV1_DOOR_OPEN) >> 1 );
11312                        		__st.wmiq	4352, _di
         02:D7C0  64 F0      			stz.l	_di
         02:D7C2  A9 11      			lda.h	#4352
         02:D7C4  85 F1      			sta.h	_di
11313                        		__farptr	_tileset_LV1_DOOR_OPEN, _bp_bank, _bp
         02:D7C6  A9 00      			lda.l	#$6000 + ($1FFF & (_tileset_LV1_DOOR_OPEN))
         02:D7C8  85 EC      			sta.l	_bp
         02:D7CA  A9 6E      			lda.h	#$6000 + ($1FFF & (_tileset_LV1_DOOR_OPEN))
         02:D7CC  85 ED      			sta.h	_bp
         02:D7CE  A9 03      			lda	#bank(_tileset_LV1_DOOR_OPEN)
         02:D7D0  85 02      			sta	_bp_bank
11314                        		__ld.wi		___sizeof__tileset_LV1_DOOR_OPEN
         02:D7D2  A9 00      			lda.l	#___sizeof__tileset_LV1_DOOR_OPEN
         02:D7D4  A0 03      			ldy.h	#___sizeof__tileset_LV1_DOOR_OPEN
11315                        		__lsr.wi	1
         02:D7D6  42         			say
         02:D7D7  4A         			lsr	a
         02:D7D8  42         			say
         02:D7D9  6A         			ror	a
11316                        		__st.wmq	_ax
         02:D7DA  85 F8      			sta.l	_ax
         02:D7DC  84 F9      			sty.h	_ax
11317                        		 _sgx_load_vram.3
         02:D7DE  A2 10      			ldx	#SGX_VDC_OFFSET		; Offset to SGX VDC.
         02:D7E0  20 63 FF   			call	load_vram_x
11318                        	
11319                        		.dbg	line,	"include\init.c", 451; //--------------------------------------------------------------------------------------//
11320                        	
11321                        		.dbg	line,	"include\init.c", 452; //                                     SET MULTIMAP                                     //
11322                        	
11323                        		.dbg	line,	"include\init.c", 453; //--------------------------------------------------------------------------------------//
11324                        	
11325                        		.dbg	line,	"include\init.c", 455; // multimap is 5 screens wide //
11326                        	
11327                        		.dbg	line,	"include\init.c", 456; sgx_set_multimap( multimap_LV1_BG_B , 5 );
11328                        		__farptr	_multimap_LV1_BG_B, sgx_scr_bank, sgx_scr_addr
         02:D7E3  A9 00      			lda.l	#$6000 + ($1FFF & (_multimap_LV1_BG_B))
         02:D7E5  8D C7 2B   			sta.l	sgx_scr_addr
         02:D7E8  A9 79      			lda.h	#$6000 + ($1FFF & (_multimap_LV1_BG_B))
         02:D7EA  8D C8 2B   			sta.h	sgx_scr_addr
         02:D7ED  A9 09      			lda	#bank(_multimap_LV1_BG_B)
         02:D7EF  8D C9 2B   			sta	sgx_scr_bank
11329                        		__st.umiq	5, sgx_map_scrn_w
         02:D7F2  A9 05      			lda.l	#5
         02:D7F4  8D 88 26   			sta	sgx_map_scrn_w
11330                        		 _sgx_set_multimap.2
         02:D7F7  AD 80 26   			lda	sgx_bat_width
         02:D7FA  4A         			lsr	a
         02:D7FB  8D 87 26   			sta	sgx_map_line_w
11331                        	
11332                        		.dbg	line,	"include\init.c", 459; //--------------------------------------------------------------------------------------//
11333                        	
11334                        		.dbg	line,	"include\init.c", 460; //                                    DRAW TILEMAP                                      //
11335                        	
11336                        		.dbg	line,	"include\init.c", 461; //--------------------------------------------------------------------------------------//
11337                        	
11338                        		.dbg	line,	"include\init.c", 463; // The blkmap is drawn using global variables for the top-left coordinate
11339                        	
11340                        		.dbg	line,	"include\init.c", 464; // in pixels, and the draw width and height in terms of 8x8 characters.
11341                        	
11342                        		.dbg	line,	"include\init.c", 466; if(respawn == FALSE)
11343                        		__not.um	_respawn
         02:D7FE  AD 13 23   			lda	_respawn
         02:D801  18         			clc
         02:D802  D0 01      			bne	!+
         02:D804  38         			sec
         02:D805             	!:
11344                        		__bfalse	.LL485
         02:D805  90 12      			bcc	.LL485
11345                        	
11346                        		.dbg	line,	"include\init.c", 467; {
11347                        	
11348                        		.dbg	line,	"include\init.c", 468; sgx_map_pxl_x = 96;
11349                        		__st.wmiq	96, _sgx_map_pxl_x
         02:D807  A9 60      			lda.l	#96
         02:D809  8D 89 26   			sta.l	_sgx_map_pxl_x
         02:D80C  9C 8A 26   			stz.h	_sgx_map_pxl_x
11350                        	
11351                        		.dbg	line,	"include\init.c", 469; sgx_map_pxl_y = 768;
11352                        		__st.wmiq	768, _sgx_map_pxl_y
         02:D80F  9C 8B 26   			stz.l	_sgx_map_pxl_y
         02:D812  A9 03      			lda.h	#768
         02:D814  8D 8C 26   			sta.h	_sgx_map_pxl_y
11353                        	
11354                        		.dbg	line,	"include\init.c", 470; }
11355                        	
11356                        		.dbg	line,	"include\init.c", 472; else if(respawn == RESPAWN_SHOP)
11357                        		__bra		.LL486
         02:D817  80 22      			bra	.LL486
11358    02:D819             	.LL485:
11359                        		__ld.umq	_respawn
         02:D819  AD 13 23   			lda	_respawn
11360                        		__equ_b.uiq	2
         02:D81C  C9 02      			cmp	#2
         02:D81E  F0 01      			beq	!+
         02:D820  18         			clc
         02:D821             	!:
11361                        		__bfalse	.LL487
         02:D821  90 18      			bcc	.LL487
11362                        	
11363                        		.dbg	line,	"include\init.c", 473; {
11364                        	
11365                        		.dbg	line,	"include\init.c", 474; sgx_map_pxl_x = camera_pos_x_backup;
11366                        		__ld.wm		_camera_pos_x_backup
         02:D823  AD D3 24   			lda.l	_camera_pos_x_backup
         02:D826  AC D4 24   			ldy.h	_camera_pos_x_backup
11367                        		__st.wmq	_sgx_map_pxl_x
         02:D829  8D 89 26   			sta.l	_sgx_map_pxl_x
         02:D82C  8C 8A 26   			sty.h	_sgx_map_pxl_x
11368                        	
11369                        		.dbg	line,	"include\init.c", 475; sgx_map_pxl_y = camera_pos_y_backup;
11370                        		__ld.wm		_camera_pos_y_backup
         02:D82F  AD D5 24   			lda.l	_camera_pos_y_backup
         02:D832  AC D6 24   			ldy.h	_camera_pos_y_backup
11371                        		__st.wmq	_sgx_map_pxl_y
         02:D835  8D 8B 26   			sta.l	_sgx_map_pxl_y
         02:D838  8C 8C 26   			sty.h	_sgx_map_pxl_y
11372                        	
11373                        		.dbg	line,	"include\init.c", 476; }
11374                        	
11375                        		.dbg	line,	"include\init.c", 479; sgx_map_draw_w = 63;
11376    02:D83B             	.LL487:
11377    02:D83B             	.LL486:
11378                        		__st.umiq	63, _sgx_map_draw_w
         02:D83B  A9 3F      			lda.l	#63
         02:D83D  8D 85 26   			sta	_sgx_map_draw_w
11379                        	
11380                        		.dbg	line,	"include\init.c", 480; sgx_map_draw_h = 29;
11381                        		__st.umiq	29, _sgx_map_draw_h
         02:D840  A9 1D      			lda.l	#29
         02:D842  8D 86 26   			sta	_sgx_map_draw_h
11382                        	
11383                        		.dbg	line,	"include\init.c", 482; sgx_draw_map();
11384                        		__call		_sgx_draw_map
         02:D845  20 FF FE   			call	_sgx_draw_map
11385                        	
11386                        		.dbg	line,	"include\init.c", 487; //**************************************************************************************//
11387                        	
11388                        		.dbg	line,	"include\init.c", 488; //                                                                                      //
11389                        	
11390                        		.dbg	line,	"include\init.c", 489; //                                         HUD                                          //
11391                        	
11392                        		.dbg	line,	"include\init.c", 490; //                                                                                      //
11393                        	
11394                        		.dbg	line,	"include\init.c", 491; //**************************************************************************************//
11395                        	
11396                        		.dbg	line,	"include\init.c", 493; init_HUD();
11397                        		__call		_init_HUD
         02:D848  20 F5 FE   			call	_init_HUD
11398                        	
11399                        		.dbg	line,	"include\init.c", 498; //**************************************************************************************//
11400                        	
11401                        		.dbg	line,	"include\init.c", 499; //                                                                                      //
11402                        	
11403                        		.dbg	line,	"include\init.c", 500; //                                  SETUP SCROLL_SPLIT                                  //
11404                        	
11405                        		.dbg	line,	"include\init.c", 501; //                                                                                      //
11406                        	
11407                        		.dbg	line,	"include\init.c", 502; //**************************************************************************************//
11408                        	
11409                        		.dbg	line,	"include\init.c", 504; //--------------------------------------------------------------------------------------//
11410                        	
11411                        		.dbg	line,	"include\init.c", 505; //                                        VDC 2                                         //
11412                        	
11413                        		.dbg	line,	"include\init.c", 506; //--------------------------------------------------------------------------------------//
11414                        	
11415                        		.dbg	line,	"include\init.c", 508; sgx_scroll_map();
11416                        		__call		_sgx_scroll_map
         02:D84B  20 81 FF   			call	_sgx_scroll_map
11417                        	
11418                        		.dbg	line,	"include\init.c", 510; sgx_scroll_split(0,   0, sgx_map_pxl_x & (BAT_SIZE_W - 1), sgx_map_pxl_y & (BAT_SIZE_H - 1), BKG_ON | SPR_ON);
11419                        		__st.umiq	0, _al
         02:D84E  64 F8      			stz	_al
11420                        		__st.umiq	0, _ah
         02:D850  64 F9      			stz	_ah
11421                        		__ld.wm		_sgx_map_pxl_x
         02:D852  AD 89 26   			lda.l	_sgx_map_pxl_x
         02:D855  AC 8A 26   			ldy.h	_sgx_map_pxl_x
11422                        		__and.wi	2047
         02:D858  29 FF      			and.l	#2047
         02:D85A  42         			say
         02:D85B  29 07      			and.h	#2047
         02:D85D  42         			say
11423                        		__st.wmq	_bx
         02:D85E  85 FA      			sta.l	_bx
         02:D860  84 FB      			sty.h	_bx
11424                        		__ld.wm		_sgx_map_pxl_y
         02:D862  AD 8B 26   			lda.l	_sgx_map_pxl_y
         02:D865  AC 8C 26   			ldy.h	_sgx_map_pxl_y
11425                        		__and.wi	255
         02:D868  29 FF      			and	#255
         02:D86A  C2         			cly
11426                        		__st.wmq	_cx
         02:D86B  85 FC      			sta.l	_cx
         02:D86D  84 FD      			sty.h	_cx
11427                        		__st.umiq	192, _dl
         02:D86F  A9 C0      			lda.l	#192
         02:D871  85 FE      			sta	_dl
11428                        		__call		_sgx_scroll_split.5
         02:D873  20 77 FF   			call	_sgx_scroll_split.5
11429                        	
11430                        		.dbg	line,	"include\init.c", 515; //--------------------------------------------------------------------------------------//
11431                        	
11432                        		.dbg	line,	"include\init.c", 516; //                                   LOAD BG PALETTES                                   //
11433                        	
11434                        		.dbg	line,	"include\init.c", 517; //--------------------------------------------------------------------------------------//
11435                        	
11436                        		.dbg	line,	"include\init.c", 519; // LOAD ALL PALETTES AT BG PALETTE 0 //
11437                        	
11438                        		.dbg	line,	"include\init.c", 520; load_palette( 0, palette_LV1, 16 );
11439                        		__st.umiq	0, _al
         02:D876  64 F8      			stz	_al
11440                        		__farptr	_palette_LV1, _bp_bank, _bp
         02:D878  A9 A0      			lda.l	#$6000 + ($1FFF & (_palette_LV1))
         02:D87A  85 EC      			sta.l	_bp
         02:D87C  A9 78      			lda.h	#$6000 + ($1FFF & (_palette_LV1))
         02:D87E  85 ED      			sta.h	_bp
         02:D880  A9 0B      			lda	#bank(_palette_LV1)
         02:D882  85 02      			sta	_bp_bank
11441                        		__st.umiq	16, _ah
         02:D884  A9 10      			lda.l	#16
         02:D886  85 F9      			sta	_ah
11442                        		__call		_load_palette.3
         02:D888  20 EB FE   			call	_load_palette.3
11443                        	
11444                        		.dbg	line,	"include\init.c", 525; //**************************************************************************************//
11445                        	
11446                        		.dbg	line,	"include\init.c", 526; //                                                                                      //
11447                        	
11448                        		.dbg	line,	"include\init.c", 527; //                                       SPRITES                                        //
11449                        	
11450                        		.dbg	line,	"include\init.c", 528; //                                                                                      //
11451                        	
11452                        		.dbg	line,	"include\init.c", 529; //**************************************************************************************//
11453                        	
11454                        		.dbg	line,	"include\init.c", 531; //--------------------------------------------------------------------------------------//
11455                        	
11456                        		.dbg	line,	"include\init.c", 532; //                                        PLAYER                                        //
11457                        	
11458                        		.dbg	line,	"include\init.c", 533; //--------------------------------------------------------------------------------------//
11459                        	
11460                        		.dbg	line,	"include\init.c", 535; // LOAD PLAYER TILES //
11461                        	
11462                        		.dbg	line,	"include\init.c", 536; // 0x2000
11463                        	
11464                        		.dbg	line,	"include\init.c", 537; // 32 TILES = 512 //
11465                        	
11466                        		.dbg	line,	"include\init.c", 538; // LOAD PLAYER FIRST FRAME OF ANIMATION (IDLE)
11467                        	
11468                        		.dbg	line,	"include\init.c", 539; set_far_base(TABLE_PLAYER_TILES_BANK[player_naked],TABLE_PLAYER_TILES_ADR[player_naked]);
11469                        		__ldx.umq	_player_naked
         02:D88B  AE 1B 23   			ldx	_player_naked
11470                        		__ld.uax	_TABLE_PLAYER_TILES_BANK
         02:D88E  BD F7 60   			lda	_TABLE_PLAYER_TILES_BANK, x
         02:D891  C2         			cly
11471                        		__st.umq	_bp_bank
         02:D892  85 02      			sta	_bp_bank
11472                        		__ld2x.umq	_player_naked
         02:D894  AD 1B 23   			lda	_player_naked
         02:D897  0A         			asl	a
         02:D898  AA         			tax
11473                        		__ld.wax	_TABLE_PLAYER_TILES_ADR
         02:D899  BD F3 60   			lda.l	_TABLE_PLAYER_TILES_ADR, x
         02:D89C  BC F4 60   			ldy.h	_TABLE_PLAYER_TILES_ADR, x
11474                        		__st.wmq	_bp
         02:D89F  85 EC      			sta.l	_bp
         02:D8A1  84 ED      			sty.h	_bp
11475                        	
11476                        		.dbg	line,	"include\init.c", 540; far_load_vram(PLAYER_VRAM_ADR,TILES_16);
11477                        		__st.wmiq	6144, _di
         02:D8A3  64 F0      			stz.l	_di
         02:D8A5  A9 18      			lda.h	#6144
         02:D8A7  85 F1      			sta.h	_di
11478                        		__st.wmiq	256, _ax
         02:D8A9  64 F8      			stz.l	_ax
         02:D8AB  A9 01      			lda.h	#256
         02:D8AD  85 F9      			sta.h	_ax
11479                        		 _far_load_vram.2
         02:D8AF  82         			clx				; Offset to PCE VDC.
         02:D8B0  20 63 FF   			call	load_vram_x
11480                        	
11481                        		.dbg	line,	"include\init.c", 541; //load_vram(PLAYER_VRAM_ADR, tiles_SPR_PLAYER_ARMOR , TILES_16);
11482                        	
11483                        		.dbg	line,	"include\init.c", 544; // SELECT PLAYER CORE SPRITE //
11484                        	
11485                        		.dbg	line,	"include\init.c", 545; spr_set(player_id); // ID : 2
11486                        		__ld.umq	_player_id
         02:D8B3  AD 14 23   			lda	_player_id
11487                        		__call		_spr_set.1
         02:D8B6  20 DD E7   			call	_spr_set.1
11488                        	
11489                        		.dbg	line,	"include\init.c", 548; player_pos_x = 112;
11490                        		__st.wmiq	112, _player_pos_x
         02:D8B9  A9 70      			lda.l	#112
         02:D8BB  8D CD 24   			sta.l	_player_pos_x
         02:D8BE  9C CE 24   			stz.h	_player_pos_x
11491                        	
11492                        		.dbg	line,	"include\init.c", 549; player_pos_y = PLAYER_BASE_Y_POS;
11493                        		__st.wmiq	128, _player_pos_y
         02:D8C1  A9 80      			lda.l	#128
         02:D8C3  8D CF 24   			sta.l	_player_pos_y
         02:D8C6  9C D0 24   			stz.h	_player_pos_y
11494                        	
11495                        		.dbg	line,	"include\init.c", 552; spr_x(player_pos_x);
11496                        		__ld.wm		_player_pos_x
         02:D8C9  AD CD 24   			lda.l	_player_pos_x
         02:D8CC  AC CE 24   			ldy.h	_player_pos_x
11497                        		__call		_spr_x.1
         02:D8CF  20 0A E8   			call	_spr_x.1
11498                        	
11499                        		.dbg	line,	"include\init.c", 553; spr_y(player_pos_y);
11500                        		__ld.wm		_player_pos_y
         02:D8D2  AD CF 24   			lda.l	_player_pos_y
         02:D8D5  AC D0 24   			ldy.h	_player_pos_y
11501                        		__call		_spr_y.1
         02:D8D8  20 19 E8   			call	_spr_y.1
11502                        	
11503                        		.dbg	line,	"include\init.c", 555; // SET TILES DATA FOR THE PLAYER //
11504                        	
11505                        		.dbg	line,	"include\init.c", 556; spr_pattern(PLAYER_VRAM_ADR);
11506                        		__ld.wi		6144
         02:D8DB  62         			cla
         02:D8DC  A0 18      			ldy.h	#6144
11507                        		__call		_spr_pattern.1
         02:D8DE  20 26 E8   			call	_spr_pattern.1
11508                        	
11509                        		.dbg	line,	"include\init.c", 558; // SET SPRITE FLIP //
11510                        	
11511                        		.dbg	line,	"include\init.c", 559; spr_ctrl(FLIP_MAS|SIZE_MAS, NO_FLIP|SZ_32x32);
11512                        		__st.umiq	185, _al
         02:D8E1  A9 B9      			lda.l	#185
         02:D8E3  85 F8      			sta	_al
11513                        		__ld.uiq	17
         02:D8E5  A9 11      			lda	#17
11514                        		__call		_spr_ctrl.2
         02:D8E7  20 3C E8   			call	_spr_ctrl.2
11515                        	
11516                        		.dbg	line,	"include\init.c", 561; 
11517                        	
11518                        		.dbg	line,	"include\init.c", 564; spr_pal(0);
11519                        		__ld.uiq	0
         02:D8EA  62         			cla
11520                        		__call		_spr_pal.1
         02:D8EB  20 4D E8   			call	_spr_pal.1
11521                        	
11522                        		.dbg	line,	"include\init.c", 565; spr_pri(TRUE);
11523                        		__ld.uiq	1
         02:D8EE  A9 01      			lda	#1
11524                        		__call		_spr_pri.1
         02:D8F0  20 5C E8   			call	_spr_pri.1
11525                        	
11526                        		.dbg	line,	"include\init.c", 568; //--------------------------------------------------------------------------------------//
11527                        	
11528                        		.dbg	line,	"include\init.c", 569; //                                       OBJECTS                                        //
11529                        	
11530                        		.dbg	line,	"include\init.c", 570; //--------------------------------------------------------------------------------------//
11531                        	
11532                        		.dbg	line,	"include\init.c", 572; load_OBJECT_TILES();
11533                        		__call		_load_OBJECT_TILES
         02:D8F3  20 E1 FE   			call	_load_OBJECT_TILES
11534                        	
11535                        		.dbg	line,	"include\init.c", 573; init_OBJECT_LV1();
11536                        		__call		_init_OBJECT_LV1
         02:D8F6  20 D7 FE   			call	_init_OBJECT_LV1
11537                        	
11538                        		.dbg	line,	"include\init.c", 574; scroll_object();
11539                        		__call		_scroll_object
         02:D8F9  20 CD FE   			call	_scroll_object
11540                        	
11541                        		.dbg	line,	"include\init.c", 577; //--------------------------------------------------------------------------------------//
11542                        	
11543                        		.dbg	line,	"include\init.c", 578; //                                        CHESTS                                        //
11544                        	
11545                        		.dbg	line,	"include\init.c", 579; //--------------------------------------------------------------------------------------//
11546                        	
11547                        		.dbg	line,	"include\init.c", 581; load_CHEST_TILES();
11548                        		__call		_load_CHEST_TILES
         02:D8FC  20 C3 FE   			call	_load_CHEST_TILES
11549                        	
11550                        		.dbg	line,	"include\init.c", 582; init_CHEST_LV1();
11551                        		__call		_init_CHEST_LV1
         02:D8FF  20 B9 FE   			call	_init_CHEST_LV1
11552                        	
11553                        		.dbg	line,	"include\init.c", 583; scroll_chest();
11554                        		__call		_scroll_chest
         02:D902  20 AF FE   			call	_scroll_chest
11555                        	
11556                        		.dbg	line,	"include\init.c", 586; //--------------------------------------------------------------------------------------//
11557                        	
11558                        		.dbg	line,	"include\init.c", 587; //                                         NPCS                                         //
11559                        	
11560                        		.dbg	line,	"include\init.c", 588; //--------------------------------------------------------------------------------------//
11561                        	
11562                        		.dbg	line,	"include\init.c", 590; load_NPC_TILES();
11563                        		__call		_load_NPC_TILES
         02:D905  20 A5 FE   			call	_load_NPC_TILES
11564                        	
11565                        		.dbg	line,	"include\init.c", 591; init_NPC_LV1();
11566                        		__call		_init_NPC_LV1
         02:D908  20 9B FE   			call	_init_NPC_LV1
11567                        	
11568                        		.dbg	line,	"include\init.c", 597; // UPDATE PCE SAT //
11569                        	
11570                        		.dbg	line,	"include\init.c", 598; satb_update();
11571                        		__call		_satb_update
         02:D90B  20 91 FE   			call	_satb_update
11572                        	
11573                        		.dbg	line,	"include\init.c", 603; //--------------------------------------------------------------------------------------//
11574                        	
11575                        		.dbg	line,	"include\init.c", 604; //                                LOAD SPRITES PALETTES                                 //
11576                        	
11577                        		.dbg	line,	"include\init.c", 605; //--------------------------------------------------------------------------------------//
11578                        	
11579                        		.dbg	line,	"include\init.c", 607; if(armor_level == 8)
11580                        		__ld.umq	_armor_level
         02:D90E  AD 1E 23   			lda	_armor_level
11581                        		__equ_b.uiq	8
         02:D911  C9 08      			cmp	#8
         02:D913  F0 01      			beq	!+
         02:D915  18         			clc
         02:D916             	!:
11582                        		__bfalse	.LL488
         02:D916  90 19      			bcc	.LL488
11583                        	
11584                        		.dbg	line,	"include\init.c", 608; {
11585                        	
11586                        		.dbg	line,	"include\init.c", 609; load_palette( 16, palette_PLAYER_8, 1 );
11587                        		__st.umiq	16, _al
         02:D918  A9 10      			lda.l	#16
         02:D91A  85 F8      			sta	_al
11588                        		__farptr	_palette_PLAYER_8, _bp_bank, _bp
         02:D91C  A9 E0      			lda.l	#$6000 + ($1FFF & (_palette_PLAYER_8))
         02:D91E  85 EC      			sta.l	_bp
         02:D920  A9 6F      			lda.h	#$6000 + ($1FFF & (_palette_PLAYER_8))
         02:D922  85 ED      			sta.h	_bp
         02:D924  A9 0F      			lda	#bank(_palette_PLAYER_8)
         02:D926  85 02      			sta	_bp_bank
11589                        		__st.umiq	1, _ah
         02:D928  A9 01      			lda.l	#1
         02:D92A  85 F9      			sta	_ah
11590                        		__call		_load_palette.3
         02:D92C  20 EB FE   			call	_load_palette.3
11591                        	
11592                        		.dbg	line,	"include\init.c", 610; }
11593                        	
11594                        		.dbg	line,	"include\init.c", 612; else if(armor_level == 5)
11595                        		__bra		.LL489
         02:D92F  80 5D      			bra	.LL489
11596    02:D931             	.LL488:
11597                        		__ld.umq	_armor_level
         02:D931  AD 1E 23   			lda	_armor_level
11598                        		__equ_b.uiq	5
         02:D934  C9 05      			cmp	#5
         02:D936  F0 01      			beq	!+
         02:D938  18         			clc
         02:D939             	!:
11599                        		__bfalse	.LL490
         02:D939  90 19      			bcc	.LL490
11600                        	
11601                        		.dbg	line,	"include\init.c", 613; {
11602                        	
11603                        		.dbg	line,	"include\init.c", 614; load_palette( 16, palette_PLAYER_5, 1 );
11604                        		__st.umiq	16, _al
         02:D93B  A9 10      			lda.l	#16
         02:D93D  85 F8      			sta	_al
11605                        		__farptr	_palette_PLAYER_5, _bp_bank, _bp
         02:D93F  A9 E0      			lda.l	#$6000 + ($1FFF & (_palette_PLAYER_5))
         02:D941  85 EC      			sta.l	_bp
         02:D943  A9 6D      			lda.h	#$6000 + ($1FFF & (_palette_PLAYER_5))
         02:D945  85 ED      			sta.h	_bp
         02:D947  A9 0F      			lda	#bank(_palette_PLAYER_5)
         02:D949  85 02      			sta	_bp_bank
11606                        		__st.umiq	1, _ah
         02:D94B  A9 01      			lda.l	#1
         02:D94D  85 F9      			sta	_ah
11607                        		__call		_load_palette.3
         02:D94F  20 EB FE   			call	_load_palette.3
11608                        	
11609                        		.dbg	line,	"include\init.c", 615; }
11610                        	
11611                        		.dbg	line,	"include\init.c", 617; else if(armor_level == 4)
11612                        		__bra		.LL491
         02:D952  80 3A      			bra	.LL491
11613    02:D954             	.LL490:
11614                        		__ld.umq	_armor_level
         02:D954  AD 1E 23   			lda	_armor_level
11615                        		__equ_b.uiq	4
         02:D957  C9 04      			cmp	#4
         02:D959  F0 01      			beq	!+
         02:D95B  18         			clc
         02:D95C             	!:
11616                        		__bfalse	.LL492
         02:D95C  90 19      			bcc	.LL492
11617                        	
11618                        		.dbg	line,	"include\init.c", 618; {
11619                        	
11620                        		.dbg	line,	"include\init.c", 619; load_palette( 16, palette_PLAYER_4, 1 );
11621                        		__st.umiq	16, _al
         02:D95E  A9 10      			lda.l	#16
         02:D960  85 F8      			sta	_al
11622                        		__farptr	_palette_PLAYER_4, _bp_bank, _bp
         02:D962  A9 E0      			lda.l	#$6000 + ($1FFF & (_palette_PLAYER_4))
         02:D964  85 EC      			sta.l	_bp
         02:D966  A9 6B      			lda.h	#$6000 + ($1FFF & (_palette_PLAYER_4))
         02:D968  85 ED      			sta.h	_bp
         02:D96A  A9 0F      			lda	#bank(_palette_PLAYER_4)
         02:D96C  85 02      			sta	_bp_bank
11623                        		__st.umiq	1, _ah
         02:D96E  A9 01      			lda.l	#1
         02:D970  85 F9      			sta	_ah
11624                        		__call		_load_palette.3
         02:D972  20 EB FE   			call	_load_palette.3
11625                        	
11626                        		.dbg	line,	"include\init.c", 620; }
11627                        	
11628                        		.dbg	line,	"include\init.c", 622; else
11629                        		__bra		.LL493
         02:D975  80 17      			bra	.LL493
11630    02:D977             	.LL492:
11631                        	
11632                        		.dbg	line,	"include\init.c", 623; {
11633                        	
11634                        		.dbg	line,	"include\init.c", 624; load_palette( 16, palette_PLAYER_1, 1 );
11635                        		__st.umiq	16, _al
         02:D977  A9 10      			lda.l	#16
         02:D979  85 F8      			sta	_al
11636                        		__farptr	_palette_PLAYER_1, _bp_bank, _bp
         02:D97B  A9 E0      			lda.l	#$6000 + ($1FFF & (_palette_PLAYER_1))
         02:D97D  85 EC      			sta.l	_bp
         02:D97F  A9 69      			lda.h	#$6000 + ($1FFF & (_palette_PLAYER_1))
         02:D981  85 ED      			sta.h	_bp
         02:D983  A9 0F      			lda	#bank(_palette_PLAYER_1)
         02:D985  85 02      			sta	_bp_bank
11637                        		__st.umiq	1, _ah
         02:D987  A9 01      			lda.l	#1
         02:D989  85 F9      			sta	_ah
11638                        		__call		_load_palette.3
         02:D98B  20 EB FE   			call	_load_palette.3
11639                        	
11640                        		.dbg	line,	"include\init.c", 625; }
11641    02:D98E             	.LL493:
11642    02:D98E             	.LL491:
11643    02:D98E             	.LL489:
11644                        	
11645                        		.dbg	line,	"include\init.c", 628; load_palette( 17, palette_objects_1, 1 );
11646                        		__st.umiq	17, _al
         02:D98E  A9 11      			lda.l	#17
         02:D990  85 F8      			sta	_al
11647                        		__farptr	_palette_objects_1, _bp_bank, _bp
         02:D992  A9 60      			lda.l	#$6000 + ($1FFF & (_palette_objects_1))
         02:D994  85 EC      			sta.l	_bp
         02:D996  A9 6D      			lda.h	#$6000 + ($1FFF & (_palette_objects_1))
         02:D998  85 ED      			sta.h	_bp
         02:D99A  A9 10      			lda	#bank(_palette_objects_1)
         02:D99C  85 02      			sta	_bp_bank
11648                        		__st.umiq	1, _ah
         02:D99E  A9 01      			lda.l	#1
         02:D9A0  85 F9      			sta	_ah
11649                        		__call		_load_palette.3
         02:D9A2  20 EB FE   			call	_load_palette.3
11650                        	
11651                        		.dbg	line,	"include\init.c", 629; load_palette( 18, palette_objects_2, 1 );
11652                        		__st.umiq	18, _al
         02:D9A5  A9 12      			lda.l	#18
         02:D9A7  85 F8      			sta	_al
11653                        		__farptr	_palette_objects_2, _bp_bank, _bp
         02:D9A9  A9 60      			lda.l	#$6000 + ($1FFF & (_palette_objects_2))
         02:D9AB  85 EC      			sta.l	_bp
         02:D9AD  A9 6F      			lda.h	#$6000 + ($1FFF & (_palette_objects_2))
         02:D9AF  85 ED      			sta.h	_bp
         02:D9B1  A9 10      			lda	#bank(_palette_objects_2)
         02:D9B3  85 02      			sta	_bp_bank
11654                        		__st.umiq	1, _ah
         02:D9B5  A9 01      			lda.l	#1
         02:D9B7  85 F9      			sta	_ah
11655                        		__call		_load_palette.3
         02:D9B9  20 EB FE   			call	_load_palette.3
11656                        	
11657                        		.dbg	line,	"include\init.c", 637; // VSYNC //
11658                        	
11659                        		.dbg	line,	"include\init.c", 638; vsync();
11660                        		__call		_vsync
         02:D9BC  20 09 E3   			call	_vsync
11661                        	
11662                        		.dbg	line,	"include\init.c", 640; // ENABLE DISPLAY //
11663                        	
11664                        		.dbg	line,	"include\init.c", 641; disp_on();
11665                        		__call		_disp_on
         02:D9BF  20 16 E4   			call	_disp_on
11666                        	
11667                        		.dbg	line,	"include\init.c", 642; }
11668                        	
11669                        		.dbg	line,	"include\init.c", 643; }
11670    02:D9C2             	.LL482:
11671    02:D9C2             	.LL481:
11672                        		__return	0
         02:D9C2  4C EF FF   			jmp	leave_proc
11673                        		.dbg	clear
11674                        		.endp
11675                        		.pceas
11676                        	
11677                        		.dbg	line,	"include\init.c", 646; void init_SHOP()
11678                        		.dbg	line,	"include\init.c", 647; {
11679                        	;***********************
11680                        	;***********************
11681                        	
11682                        		.hucc
11683    02:CC96             		.proc		_init_SHOP
11684                        		__enter		_init_SHOP
11685                        	
11686                        		.dbg	line,	"include\init.c", 648; char i;
11687                        	
11688                        		.dbg	line,	"include\init.c", 649; char item_id;
11689                        	
11690                        		.dbg	line,	"include\init.c", 652; // DISABLE DISPLAY //
11691                        	
11692                        		.dbg	line,	"include\init.c", 653; disp_off();
11693                        		__call		_disp_off
         02:CC96  20 29 E4   			call	_disp_off
11694                        	
11695                        		.dbg	line,	"include\init.c", 654; 
11696                        	
11697                        		.dbg	line,	"include\init.c", 656; // VSYNC //
11698                        	
11699                        		.dbg	line,	"include\init.c", 657; vsync();
11700                        		__call		_vsync
         02:CC99  20 09 E3   			call	_vsync
11701                        	
11702                        		.dbg	line,	"include\init.c", 660; // HIDE ALL LEVEL SPRITES //
11703                        	
11704                        		.dbg	line,	"include\init.c", 661; hide_LEVEL_SPRITES();
11705                        		__call		_hide_LEVEL_SPRITES
         02:CC9C  20 87 FE   			call	_hide_LEVEL_SPRITES
11706                        	
11707                        		.dbg	line,	"include\init.c", 664; // SET VDC 1 SCREEN SIZE (IN TILES) - 32x32 = 256 PIXELS
11708                        	
11709                        		.dbg	line,	"include\init.c", 665; set_screen_size(SCR_SIZE_64x32);
11710                        		__st.umiq	1, _al
         02:CC9F  A9 01      			lda.l	#1
         02:CCA1  85 F8      			sta	_al
11711                        		__call		_set_screen_size.1
         02:CCA3  20 31 FF   			call	_set_screen_size.1
11712                        	
11713                        		.dbg	line,	"include\init.c", 668; // SET VDC 2 SCREEN SIZE (IN TILES) - 32x32 = 256 PIXELS
11714                        	
11715                        		.dbg	line,	"include\init.c", 669; sgx_set_screen_size(SCR_SIZE_32x32);
11716                        		__st.umiq	0, _al
         02:CCA6  64 F8      			stz	_al
11717                        		__call		_sgx_set_screen_size.1
         02:CCA8  20 27 FF   			call	_sgx_set_screen_size.1
11718                        	
11719                        		.dbg	line,	"include\init.c", 674; //**************************************************************************************//
11720                        	
11721                        		.dbg	line,	"include\init.c", 675; //                                                                                      //
11722                        	
11723                        		.dbg	line,	"include\init.c", 676; //                                      VARIABLES                                       //
11724                        	
11725                        		.dbg	line,	"include\init.c", 677; //                                                                                      //
11726                        	
11727                        		.dbg	line,	"include\init.c", 678; //**************************************************************************************//
11728                        	
11729                        		.dbg	line,	"include\init.c", 680; index_x = 0;
11730                        		__st.umiq	0, _index_x
         02:CCAB  9C C8 23   			stz	_index_x
11731                        	
11732                        		.dbg	line,	"include\init.c", 681; index_y = 0;
11733                        		__st.umiq	0, _index_y
         02:CCAE  9C C9 23   			stz	_index_y
11734                        	
11735                        		.dbg	line,	"include\init.c", 682; item_index = 0;
11736                        		__st.umiq	0, _item_index
         02:CCB1  9C CA 23   			stz	_item_index
11737                        	
11738                        		.dbg	line,	"include\init.c", 684; minutes = 0;
11739                        		__st.umiq	0, _minutes
         02:CCB4  9C 23 23   			stz	_minutes
11740                        	
11741                        		.dbg	line,	"include\init.c", 685; seconds = 30;
11742                        		__st.umiq	30, _seconds
         02:CCB7  A9 1E      			lda.l	#30
         02:CCB9  8D 24 23   			sta	_seconds
11743                        	
11744                        		.dbg	line,	"include\init.c", 687; shop_counter = 0;
11745                        		__st.umiq	0, _shop_counter
         02:CCBC  9C CC 23   			stz	_shop_counter
11746                        	
11747                        		.dbg	line,	"include\init.c", 688; shop_phase = SHOP_PHASE_ENTER;
11748                        		__st.umiq	0, _shop_phase
         02:CCBF  9C CB 23   			stz	_shop_phase
11749                        	
11750                        		.dbg	line,	"include\init.c", 690; if(level_id == 1)
11751                        		__ld.umq	_level_id
         02:CCC2  AD 12 23   			lda	_level_id
11752                        		__equ_b.uiq	1
         02:CCC5  C9 01      			cmp	#1
         02:CCC7  F0 01      			beq	!+
         02:CCC9  18         			clc
         02:CCCA             	!:
11753                        		__bfalse	.LL495
         02:CCCA  90 0A      			bcc	.LL495
11754                        	
11755                        		.dbg	line,	"include\init.c", 691; {
11756                        	
11757                        		.dbg	line,	"include\init.c", 692; ptr_SHOP_ITEM_PRICES = &TABLE_SHOP_PRICES_LV1[0];
11758                        		__ld.wi		_TABLE_SHOP_PRICES_LV1
         02:CCCC  A9 59      			lda.l	#_TABLE_SHOP_PRICES_LV1
         02:CCCE  A0 61      			ldy.h	#_TABLE_SHOP_PRICES_LV1
11759                        		__st.wmq	_ptr_SHOP_ITEM_PRICES
         02:CCD0  8D 3F 26   			sta.l	_ptr_SHOP_ITEM_PRICES
         02:CCD3  8C 40 26   			sty.h	_ptr_SHOP_ITEM_PRICES
11760                        	
11761                        		.dbg	line,	"include\init.c", 693; }
11762                        	
11763                        		.dbg	line,	"include\init.c", 694; 
11764                        	
11765                        		.dbg	line,	"include\init.c", 699; //**************************************************************************************//
11766                        	
11767                        		.dbg	line,	"include\init.c", 700; //                                                                                      //
11768                        	
11769                        		.dbg	line,	"include\init.c", 701; //                                        VDC 2                                         //
11770                        	
11771                        		.dbg	line,	"include\init.c", 702; //                                                                                      //
11772                        	
11773                        		.dbg	line,	"include\init.c", 703; //**************************************************************************************//
11774                        	
11775                        		.dbg	line,	"include\init.c", 705; //--------------------------------------------------------------------------------------//
11776                        	
11777                        		.dbg	line,	"include\init.c", 706; //                                      LOAD FONT                                       //
11778                        	
11779                        		.dbg	line,	"include\init.c", 707; //--------------------------------------------------------------------------------------//
11780                        	
11781                        		.dbg	line,	"include\init.c", 709; load_vram( 0x0800, tileset_FONT, SIZEOF(tileset_FONT) >> 1 );
11782    02:CCD6             	.LL495:
11783                        		__st.wmiq	2048, _di
         02:CCD6  64 F0      			stz.l	_di
         02:CCD8  A9 08      			lda.h	#2048
         02:CCDA  85 F1      			sta.h	_di
11784                        		__farptr	_tileset_FONT, _bp_bank, _bp
         02:CCDC  A9 00      			lda.l	#$6000 + ($1FFF & (_tileset_FONT))
         02:CCDE  85 EC      			sta.l	_bp
         02:CCE0  A9 60      			lda.h	#$6000 + ($1FFF & (_tileset_FONT))
         02:CCE2  85 ED      			sta.h	_bp
         02:CCE4  A9 03      			lda	#bank(_tileset_FONT)
         02:CCE6  85 02      			sta	_bp_bank
11785                        		__ld.wi		___sizeof__tileset_FONT
         02:CCE8  A9 00      			lda.l	#___sizeof__tileset_FONT
         02:CCEA  A0 0C      			ldy.h	#___sizeof__tileset_FONT
11786                        		__lsr.wi	1
         02:CCEC  42         			say
         02:CCED  4A         			lsr	a
         02:CCEE  42         			say
         02:CCEF  6A         			ror	a
11787                        		__st.wmq	_ax
         02:CCF0  85 F8      			sta.l	_ax
         02:CCF2  84 F9      			sty.h	_ax
11788                        		 _load_vram.3
         02:CCF4  82         			clx				; Offset to PCE VDC.
         02:CCF5  20 63 FF   			call	load_vram_x
11789                        	
11790                        		.dbg	line,	"include\init.c", 711; set_font_pal(15);
11791                        		__ld.uiq	15
         02:CCF8  A9 0F      			lda	#15
11792                        		__call		_set_font_pal.1
         02:CCFA  20 09 E6   			call	_set_font_pal.1
11793                        	
11794                        		.dbg	line,	"include\init.c", 714; //--------------------------------------------------------------------------------------//
11795                        	
11796                        		.dbg	line,	"include\init.c", 715; //                                    LOAD TILESET                                      //
11797                        	
11798                        		.dbg	line,	"include\init.c", 716; //--------------------------------------------------------------------------------------//
11799                        	
11800                        		.dbg	line,	"include\init.c", 718; sgx_load_vram( 0x1000, tileset_SHOP_BG_B, SIZEOF(tileset_SHOP_BG_B) >> 1 );
11801                        		__st.wmiq	4096, _di
         02:CCFD  64 F0      			stz.l	_di
         02:CCFF  A9 10      			lda.h	#4096
         02:CD01  85 F1      			sta.h	_di
11802                        		__farptr	_tileset_SHOP_BG_B, _bp_bank, _bp
         02:CD03  A9 A0      			lda.l	#$6000 + ($1FFF & (_tileset_SHOP_BG_B))
         02:CD05  85 EC      			sta.l	_bp
         02:CD07  A9 7A      			lda.h	#$6000 + ($1FFF & (_tileset_SHOP_BG_B))
         02:CD09  85 ED      			sta.h	_bp
         02:CD0B  A9 0B      			lda	#bank(_tileset_SHOP_BG_B)
         02:CD0D  85 02      			sta	_bp_bank
11803                        		__ld.wi		___sizeof__tileset_SHOP_BG_B
         02:CD0F  A9 60      			lda.l	#___sizeof__tileset_SHOP_BG_B
         02:CD11  A0 39      			ldy.h	#___sizeof__tileset_SHOP_BG_B
11804                        		__lsr.wi	1
         02:CD13  42         			say
         02:CD14  4A         			lsr	a
         02:CD15  42         			say
         02:CD16  6A         			ror	a
11805                        		__st.wmq	_ax
         02:CD17  85 F8      			sta.l	_ax
         02:CD19  84 F9      			sty.h	_ax
11806                        		 _sgx_load_vram.3
         02:CD1B  A2 10      			ldx	#SGX_VDC_OFFSET		; Offset to SGX VDC.
         02:CD1D  20 63 FF   			call	load_vram_x
11807                        	
11808                        		.dbg	line,	"include\init.c", 721; //--------------------------------------------------------------------------------------//
11809                        	
11810                        		.dbg	line,	"include\init.c", 722; //                                      LOAD ITEMS                                      //
11811                        	
11812                        		.dbg	line,	"include\init.c", 723; //--------------------------------------------------------------------------------------//
11813                        	
11814                        		.dbg	line,	"include\init.c", 725; for(i=0 ; i<10 ; i++)
11815                        		__st.umiq	0, __init_SHOP_end - 1  /* i */
         02:CD20  9C 0F 23   			stz	__init_SHOP_end - 1
11816    02:CD23             	.LL496:
11817                        		__ld.umq	__init_SHOP_end - 1  /* i */
         02:CD23  AD 0F 23   			lda	__init_SHOP_end - 1
11818                        		__ult_b.uiq	10
         02:CD26  C9 0A      			cmp	#10		; Subtract integer from A.
         02:CD28  6A         			ror	a		; CC if A < integer.
         02:CD29  49 80      			eor	#$80
         02:CD2B  2A         			rol	a
11819                        		__btrue		.LL498
         02:CD2C  B0 07      			bcs	.LL498
11820                        		__bra		.LL499
         02:CD2E  80 42      			bra	.LL499
11821    02:CD30             	.LL497:
11822                        		__inc.umq	__init_SHOP_end - 1  /* i */
         02:CD30  EE 0F 23   			inc	__init_SHOP_end - 1
11823                        		__bra		.LL496
         02:CD33  80 EE      			bra	.LL496
11824    02:CD35             	.LL498:
11825                        	
11826                        		.dbg	line,	"include\init.c", 726; {
11827                        	
11828                        		.dbg	line,	"include\init.c", 727; set_far_base(TABLE_SHOP_ITEMS_TILES_BANK[i],TABLE_SHOP_ITEMS_TILES_ADR[i]);
11829                        		__ldx.umq	__init_SHOP_end - 1  /* i */
         02:CD35  AE 0F 23   			ldx	__init_SHOP_end - 1
11830                        		__ld.uax	_TABLE_SHOP_ITEMS_TILES_BANK
         02:CD38  BD 81 61   			lda	_TABLE_SHOP_ITEMS_TILES_BANK, x
         02:CD3B  C2         			cly
11831                        		__st.umq	_bp_bank
         02:CD3C  85 02      			sta	_bp_bank
11832                        		__ld2x.umq	__init_SHOP_end - 1  /* i */
         02:CD3E  AD 0F 23   			lda	__init_SHOP_end - 1
         02:CD41  0A         			asl	a
         02:CD42  AA         			tax
11833                        		__ld.wax	_TABLE_SHOP_ITEMS_TILES_ADR
         02:CD43  BD 6D 61   			lda.l	_TABLE_SHOP_ITEMS_TILES_ADR, x
         02:CD46  BC 6E 61   			ldy.h	_TABLE_SHOP_ITEMS_TILES_ADR, x
11834                        		__st.wmq	_bp
         02:CD49  85 EC      			sta.l	_bp
         02:CD4B  84 ED      			sty.h	_bp
11835                        	
11836                        		.dbg	line,	"include\init.c", 728; sgx_far_load_vram( 0x1000 + (i * TILES_4), TILES_4 );
11837                        		__ld.um		__init_SHOP_end - 1  /* i */
         02:CD4D  AD 0F 23   			lda	__init_SHOP_end - 1
         02:CD50  C2         			cly
11838                        		__asl.wi	6
         02:CD51  85 00      			sta	__temp
         02:CD53  98         			tya
         02:CD54  4A         			lsr	a
         02:CD55  20 CB E1   			jsr	aslw6
         02:CD58  29 C0      			and.l	#$FF << 6
11839                        		__add.wi	4096
         02:CD5A  18         			clc
         02:CD5B  69 00      			adc.l	#4096
         02:CD5D  42         			say
         02:CD5E  69 10      			adc.h	#4096
         02:CD60  42         			say
11840                        		__st.wmq	_di
         02:CD61  85 F0      			sta.l	_di
         02:CD63  84 F1      			sty.h	_di
11841                        		__st.wmiq	64, _ax
         02:CD65  A9 40      			lda.l	#64
         02:CD67  85 F8      			sta.l	_ax
         02:CD69  64 F9      			stz.h	_ax
11842                        		 _sgx_far_load_vram.2
         02:CD6B  A2 10      			ldx	#SGX_VDC_OFFSET		; Offset to SGX VDC.
         02:CD6D  20 63 FF   			call	load_vram_x
11843                        	
11844                        		.dbg	line,	"include\init.c", 729; }
11845                        		__bra		.LL497
         02:CD70  80 BE      			bra	.LL497
11846    02:CD72             	.LL499:
11847                        	
11848                        		.dbg	line,	"include\init.c", 732; //--------------------------------------------------------------------------------------//
11849                        	
11850                        		.dbg	line,	"include\init.c", 733; //                                      SET BLOCKS                                      //
11851                        	
11852                        		.dbg	line,	"include\init.c", 734; //--------------------------------------------------------------------------------------//
11853                        	
11854                        		.dbg	line,	"include\init.c", 736; sgx_set_blocks( blocks_SHOP_BG_B , tilemap_mask , 256 );
11855                        		__farptr	_blocks_SHOP_BG_B, sgx_blk_bank, sgx_blk_addr
         02:CD72  A9 00      			lda.l	#$6000 + ($1FFF & (_blocks_SHOP_BG_B))
         02:CD74  8D C1 2B   			sta.l	sgx_blk_addr
         02:CD77  A9 78      			lda.h	#$6000 + ($1FFF & (_blocks_SHOP_BG_B))
         02:CD79  8D C2 2B   			sta.h	sgx_blk_addr
         02:CD7C  A9 0D      			lda	#bank(_blocks_SHOP_BG_B)
         02:CD7E  8D C3 2B   			sta	sgx_blk_bank
11856                        		__farptr	_tilemap_mask, sgx_tbl_bank, sgx_tbl_addr
         02:CD81  A9 CD      			lda.l	#$6000 + ($1FFF & (_tilemap_mask))
         02:CD83  8D BE 2B   			sta.l	sgx_tbl_addr
         02:CD86  A9 63      			lda.h	#$6000 + ($1FFF & (_tilemap_mask))
         02:CD88  8D BF 2B   			sta.h	sgx_tbl_addr
         02:CD8B  A9 F8      			lda	#bank(_tilemap_mask)
         02:CD8D  8D C0 2B   			sta	sgx_tbl_bank
11857                        		__st.umiq	256, _al
         02:CD90  A9 00      			lda.l	#256
         02:CD92  85 F8      			sta	_al
11858                        		__call		_sgx_set_blocks.3
         02:CD94  20 7D FE   			call	_sgx_set_blocks.3
11859                        	
11860                        		.dbg	line,	"include\init.c", 740; //--------------------------------------------------------------------------------------//
11861                        	
11862                        		.dbg	line,	"include\init.c", 741; //                                       SET MAP                                        //
11863                        	
11864                        		.dbg	line,	"include\init.c", 742; //--------------------------------------------------------------------------------------//
11865                        	
11866                        		.dbg	line,	"include\init.c", 744; sgx_set_blkmap( map_SHOP_BG_B, COUNTOF(map_SHOP_BG_B) );
11867                        		__farptr	_map_SHOP_BG_B, sgx_map_bank, sgx_map_addr
         02:CD97  A9 00      			lda.l	#$6000 + ($1FFF & (_map_SHOP_BG_B))
         02:CD99  8D C4 2B   			sta.l	sgx_map_addr
         02:CD9C  A9 60      			lda.h	#$6000 + ($1FFF & (_map_SHOP_BG_B))
         02:CD9E  8D C5 2B   			sta.h	sgx_map_addr
         02:CDA1  A9 0E      			lda	#bank(_map_SHOP_BG_B)
         02:CDA3  8D C6 2B   			sta	sgx_map_bank
11868                        		__ld.wi		___countof__map_SHOP_BG_B
         02:CDA6  A9 10      			lda.l	#___countof__map_SHOP_BG_B
         02:CDA8  A0 00      			ldy.h	#___countof__map_SHOP_BG_B
11869                        		__st.umq	sgx_map_line_w
         02:CDAA  8D 87 26   			sta	sgx_map_line_w
11870                        		 _sgx_set_blkmap.2
         02:CDAD  9C C9 2B   			stz	sgx_scr_bank
11871                        	
11872                        		.dbg	line,	"include\init.c", 747; //--------------------------------------------------------------------------------------//
11873                        	
11874                        		.dbg	line,	"include\init.c", 748; //                                    DRAW TILEMAP                                      //
11875                        	
11876                        		.dbg	line,	"include\init.c", 749; //--------------------------------------------------------------------------------------//
11877                        	
11878                        		.dbg	line,	"include\init.c", 751; // The blkmap is drawn using global variables for the top-left coordinate
11879                        	
11880                        		.dbg	line,	"include\init.c", 752; // in pixels, and the draw width and height in terms of 8x8 characters.
11881                        	
11882                        		.dbg	line,	"include\init.c", 754; sgx_map_pxl_x = 0;
11883                        		__st.wmiq	0, _sgx_map_pxl_x
         02:CDB0  9C 89 26   			stz.l	_sgx_map_pxl_x
         02:CDB3  9C 8A 26   			stz.h	_sgx_map_pxl_x
11884                        	
11885                        		.dbg	line,	"include\init.c", 755; sgx_map_pxl_y = 0;
11886                        		__st.wmiq	0, _sgx_map_pxl_y
         02:CDB6  9C 8B 26   			stz.l	_sgx_map_pxl_y
         02:CDB9  9C 8C 26   			stz.h	_sgx_map_pxl_y
11887                        	
11888                        		.dbg	line,	"include\init.c", 757; sgx_map_draw_w = 32;
11889                        		__st.umiq	32, _sgx_map_draw_w
         02:CDBC  A9 20      			lda.l	#32
         02:CDBE  8D 85 26   			sta	_sgx_map_draw_w
11890                        	
11891                        		.dbg	line,	"include\init.c", 758; sgx_map_draw_h = 28;
11892                        		__st.umiq	28, _sgx_map_draw_h
         02:CDC1  A9 1C      			lda.l	#28
         02:CDC3  8D 86 26   			sta	_sgx_map_draw_h
11893                        	
11894                        		.dbg	line,	"include\init.c", 761; //**************************************************************************************//
11895                        	
11896                        		.dbg	line,	"include\init.c", 762; //                                                                                      //
11897                        	
11898                        		.dbg	line,	"include\init.c", 763; //                                  SETUP SCROLL_SPLIT                                  //
11899                        	
11900                        		.dbg	line,	"include\init.c", 764; //                                                                                      //
11901                        	
11902                        		.dbg	line,	"include\init.c", 765; //**************************************************************************************//
11903                        	
11904                        		.dbg	line,	"include\init.c", 767; sgx_draw_map();
11905                        		__call		_sgx_draw_map
         02:CDC6  20 FF FE   			call	_sgx_draw_map
11906                        	
11907                        		.dbg	line,	"include\init.c", 769; sgx_scroll_split(0,   0, sgx_map_pxl_x & (BAT_SIZE_W - 1), sgx_map_pxl_y & (BAT_SIZE_H - 1), BKG_ON | SPR_ON);
11908                        		__st.umiq	0, _al
         02:CDC9  64 F8      			stz	_al
11909                        		__st.umiq	0, _ah
         02:CDCB  64 F9      			stz	_ah
11910                        		__ld.wm		_sgx_map_pxl_x
         02:CDCD  AD 89 26   			lda.l	_sgx_map_pxl_x
         02:CDD0  AC 8A 26   			ldy.h	_sgx_map_pxl_x
11911                        		__and.wi	2047
         02:CDD3  29 FF      			and.l	#2047
         02:CDD5  42         			say
         02:CDD6  29 07      			and.h	#2047
         02:CDD8  42         			say
11912                        		__st.wmq	_bx
         02:CDD9  85 FA      			sta.l	_bx
         02:CDDB  84 FB      			sty.h	_bx
11913                        		__ld.wm		_sgx_map_pxl_y
         02:CDDD  AD 8B 26   			lda.l	_sgx_map_pxl_y
         02:CDE0  AC 8C 26   			ldy.h	_sgx_map_pxl_y
11914                        		__and.wi	255
         02:CDE3  29 FF      			and	#255
         02:CDE5  C2         			cly
11915                        		__st.wmq	_cx
         02:CDE6  85 FC      			sta.l	_cx
         02:CDE8  84 FD      			sty.h	_cx
11916                        		__st.umiq	192, _dl
         02:CDEA  A9 C0      			lda.l	#192
         02:CDEC  85 FE      			sta	_dl
11917                        		__call		_sgx_scroll_split.5
         02:CDEE  20 77 FF   			call	_sgx_scroll_split.5
11918                        	
11919                        		.dbg	line,	"include\init.c", 774; //**************************************************************************************//
11920                        	
11921                        		.dbg	line,	"include\init.c", 775; //                                                                                      //
11922                        	
11923                        		.dbg	line,	"include\init.c", 776; //                                         HUD                                          //
11924                        	
11925                        		.dbg	line,	"include\init.c", 777; //                                                                                      //
11926                        	
11927                        		.dbg	line,	"include\init.c", 778; //**************************************************************************************//
11928                        	
11929                        		.dbg	line,	"include\init.c", 780; init_HUD();
11930                        		__call		_init_HUD
         02:CDF1  20 F5 FE   			call	_init_HUD
11931                        	
11932                        		.dbg	line,	"include\init.c", 783; //--------------------------------------------------------------------------------------//
11933                        	
11934                        		.dbg	line,	"include\init.c", 784; //                                     DRAW PRICES                                      //
11935                        	
11936                        		.dbg	line,	"include\init.c", 785; //--------------------------------------------------------------------------------------//
11937                        	
11938                        		.dbg	line,	"include\init.c", 787; shop_prices[0] = *(ptr_SHOP_ITEM_PRICES);
11939                        		__ld.wm		_ptr_SHOP_ITEM_PRICES
         02:CDF4  AD 3F 26   			lda.l	_ptr_SHOP_ITEM_PRICES
         02:CDF7  AC 40 26   			ldy.h	_ptr_SHOP_ITEM_PRICES
11940                        		__st.wm		__ptr
         02:CDFA  85 88      			sta.l	__ptr
         02:CDFC  84 89      			sty.h	__ptr
11941                        		__ld.wp		__ptr
         02:CDFE  A0 01      			ldy	#1
         02:CE00  B1 88      			lda	[__ptr], y
         02:CE02  A8         			tay
         02:CE03  B2 88      			lda	[__ptr]
11942                        		__st.wmq	_shop_prices
         02:CE05  8D 2B 26   			sta.l	_shop_prices
         02:CE08  8C 2C 26   			sty.h	_shop_prices
11943                        	
11944                        		.dbg	line,	"include\init.c", 788; shop_prices[1] = *(ptr_SHOP_ITEM_PRICES+1);
11945                        		__ld.wm		_ptr_SHOP_ITEM_PRICES
         02:CE0B  AD 3F 26   			lda.l	_ptr_SHOP_ITEM_PRICES
         02:CE0E  AC 40 26   			ldy.h	_ptr_SHOP_ITEM_PRICES
11946                        		__add.wi	2
         02:CE11  18         			clc
         02:CE12  69 02      			adc.l	#2
         02:CE14  90 01      			bcc	!+
         02:CE16  C8         			iny
         02:CE17             	!:
11947                        		__st.wm		__ptr
         02:CE17  85 88      			sta.l	__ptr
         02:CE19  84 89      			sty.h	__ptr
11948                        		__ld.wp		__ptr
         02:CE1B  A0 01      			ldy	#1
         02:CE1D  B1 88      			lda	[__ptr], y
         02:CE1F  A8         			tay
         02:CE20  B2 88      			lda	[__ptr]
11949                        		__st.wmq	_shop_prices + 2
         02:CE22  8D 2D 26   			sta.l	_shop_prices + 2
         02:CE25  8C 2E 26   			sty.h	_shop_prices + 2
11950                        	
11951                        		.dbg	line,	"include\init.c", 789; shop_prices[2] = *(ptr_SHOP_ITEM_PRICES+2);
11952                        		__ld.wm		_ptr_SHOP_ITEM_PRICES
         02:CE28  AD 3F 26   			lda.l	_ptr_SHOP_ITEM_PRICES
         02:CE2B  AC 40 26   			ldy.h	_ptr_SHOP_ITEM_PRICES
11953                        		__add.wi	4
         02:CE2E  18         			clc
         02:CE2F  69 04      			adc.l	#4
         02:CE31  90 01      			bcc	!+
         02:CE33  C8         			iny
         02:CE34             	!:
11954                        		__st.wm		__ptr
         02:CE34  85 88      			sta.l	__ptr
         02:CE36  84 89      			sty.h	__ptr
11955                        		__ld.wp		__ptr
         02:CE38  A0 01      			ldy	#1
         02:CE3A  B1 88      			lda	[__ptr], y
         02:CE3C  A8         			tay
         02:CE3D  B2 88      			lda	[__ptr]
11956                        		__st.wmq	_shop_prices + 4
         02:CE3F  8D 2F 26   			sta.l	_shop_prices + 4
         02:CE42  8C 30 26   			sty.h	_shop_prices + 4
11957                        	
11958                        		.dbg	line,	"include\init.c", 790; shop_prices[3] = *(ptr_SHOP_ITEM_PRICES+3);
11959                        		__ld.wm		_ptr_SHOP_ITEM_PRICES
         02:CE45  AD 3F 26   			lda.l	_ptr_SHOP_ITEM_PRICES
         02:CE48  AC 40 26   			ldy.h	_ptr_SHOP_ITEM_PRICES
11960                        		__add.wi	6
         02:CE4B  18         			clc
         02:CE4C  69 06      			adc.l	#6
         02:CE4E  90 01      			bcc	!+
         02:CE50  C8         			iny
         02:CE51             	!:
11961                        		__st.wm		__ptr
         02:CE51  85 88      			sta.l	__ptr
         02:CE53  84 89      			sty.h	__ptr
11962                        		__ld.wp		__ptr
         02:CE55  A0 01      			ldy	#1
         02:CE57  B1 88      			lda	[__ptr], y
         02:CE59  A8         			tay
         02:CE5A  B2 88      			lda	[__ptr]
11963                        		__st.wmq	_shop_prices + 6
         02:CE5C  8D 31 26   			sta.l	_shop_prices + 6
         02:CE5F  8C 32 26   			sty.h	_shop_prices + 6
11964                        	
11965                        		.dbg	line,	"include\init.c", 791; shop_prices[4] = *(ptr_SHOP_ITEM_PRICES+4);
11966                        		__ld.wm		_ptr_SHOP_ITEM_PRICES
         02:CE62  AD 3F 26   			lda.l	_ptr_SHOP_ITEM_PRICES
         02:CE65  AC 40 26   			ldy.h	_ptr_SHOP_ITEM_PRICES
11967                        		__add.wi	8
         02:CE68  18         			clc
         02:CE69  69 08      			adc.l	#8
         02:CE6B  90 01      			bcc	!+
         02:CE6D  C8         			iny
         02:CE6E             	!:
11968                        		__st.wm		__ptr
         02:CE6E  85 88      			sta.l	__ptr
         02:CE70  84 89      			sty.h	__ptr
11969                        		__ld.wp		__ptr
         02:CE72  A0 01      			ldy	#1
         02:CE74  B1 88      			lda	[__ptr], y
         02:CE76  A8         			tay
         02:CE77  B2 88      			lda	[__ptr]
11970                        		__st.wmq	_shop_prices + 8
         02:CE79  8D 33 26   			sta.l	_shop_prices + 8
         02:CE7C  8C 34 26   			sty.h	_shop_prices + 8
11971                        	
11972                        		.dbg	line,	"include\init.c", 792; 
11973                        	
11974                        		.dbg	line,	"include\init.c", 793; shop_prices[5] = *(ptr_SHOP_ITEM_PRICES+5);
11975                        		__ld.wm		_ptr_SHOP_ITEM_PRICES
         02:CE7F  AD 3F 26   			lda.l	_ptr_SHOP_ITEM_PRICES
         02:CE82  AC 40 26   			ldy.h	_ptr_SHOP_ITEM_PRICES
11976                        		__add.wi	10
         02:CE85  18         			clc
         02:CE86  69 0A      			adc.l	#10
         02:CE88  90 01      			bcc	!+
         02:CE8A  C8         			iny
         02:CE8B             	!:
11977                        		__st.wm		__ptr
         02:CE8B  85 88      			sta.l	__ptr
         02:CE8D  84 89      			sty.h	__ptr
11978                        		__ld.wp		__ptr
         02:CE8F  A0 01      			ldy	#1
         02:CE91  B1 88      			lda	[__ptr], y
         02:CE93  A8         			tay
         02:CE94  B2 88      			lda	[__ptr]
11979                        		__st.wmq	_shop_prices + 10
         02:CE96  8D 35 26   			sta.l	_shop_prices + 10
         02:CE99  8C 36 26   			sty.h	_shop_prices + 10
11980                        	
11981                        		.dbg	line,	"include\init.c", 794; shop_prices[6] = *(ptr_SHOP_ITEM_PRICES+6);
11982                        		__ld.wm		_ptr_SHOP_ITEM_PRICES
         02:CE9C  AD 3F 26   			lda.l	_ptr_SHOP_ITEM_PRICES
         02:CE9F  AC 40 26   			ldy.h	_ptr_SHOP_ITEM_PRICES
11983                        		__add.wi	12
         02:CEA2  18         			clc
         02:CEA3  69 0C      			adc.l	#12
         02:CEA5  90 01      			bcc	!+
         02:CEA7  C8         			iny
         02:CEA8             	!:
11984                        		__st.wm		__ptr
         02:CEA8  85 88      			sta.l	__ptr
         02:CEAA  84 89      			sty.h	__ptr
11985                        		__ld.wp		__ptr
         02:CEAC  A0 01      			ldy	#1
         02:CEAE  B1 88      			lda	[__ptr], y
         02:CEB0  A8         			tay
         02:CEB1  B2 88      			lda	[__ptr]
11986                        		__st.wmq	_shop_prices + 12
         02:CEB3  8D 37 26   			sta.l	_shop_prices + 12
         02:CEB6  8C 38 26   			sty.h	_shop_prices + 12
11987                        	
11988                        		.dbg	line,	"include\init.c", 795; shop_prices[7] = *(ptr_SHOP_ITEM_PRICES+7);
11989                        		__ld.wm		_ptr_SHOP_ITEM_PRICES
         02:CEB9  AD 3F 26   			lda.l	_ptr_SHOP_ITEM_PRICES
         02:CEBC  AC 40 26   			ldy.h	_ptr_SHOP_ITEM_PRICES
11990                        		__add.wi	14
         02:CEBF  18         			clc
         02:CEC0  69 0E      			adc.l	#14
         02:CEC2  90 01      			bcc	!+
         02:CEC4  C8         			iny
         02:CEC5             	!:
11991                        		__st.wm		__ptr
         02:CEC5  85 88      			sta.l	__ptr
         02:CEC7  84 89      			sty.h	__ptr
11992                        		__ld.wp		__ptr
         02:CEC9  A0 01      			ldy	#1
         02:CECB  B1 88      			lda	[__ptr], y
         02:CECD  A8         			tay
         02:CECE  B2 88      			lda	[__ptr]
11993                        		__st.wmq	_shop_prices + 14
         02:CED0  8D 39 26   			sta.l	_shop_prices + 14
         02:CED3  8C 3A 26   			sty.h	_shop_prices + 14
11994                        	
11995                        		.dbg	line,	"include\init.c", 796; shop_prices[8] = *(ptr_SHOP_ITEM_PRICES+8);
11996                        		__ld.wm		_ptr_SHOP_ITEM_PRICES
         02:CED6  AD 3F 26   			lda.l	_ptr_SHOP_ITEM_PRICES
         02:CED9  AC 40 26   			ldy.h	_ptr_SHOP_ITEM_PRICES
11997                        		__add.wi	16
         02:CEDC  18         			clc
         02:CEDD  69 10      			adc.l	#16
         02:CEDF  90 01      			bcc	!+
         02:CEE1  C8         			iny
         02:CEE2             	!:
11998                        		__st.wm		__ptr
         02:CEE2  85 88      			sta.l	__ptr
         02:CEE4  84 89      			sty.h	__ptr
11999                        		__ld.wp		__ptr
         02:CEE6  A0 01      			ldy	#1
         02:CEE8  B1 88      			lda	[__ptr], y
         02:CEEA  A8         			tay
         02:CEEB  B2 88      			lda	[__ptr]
12000                        		__st.wmq	_shop_prices + 16
         02:CEED  8D 3B 26   			sta.l	_shop_prices + 16
         02:CEF0  8C 3C 26   			sty.h	_shop_prices + 16
12001                        	
12002                        		.dbg	line,	"include\init.c", 797; shop_prices[9] = *(ptr_SHOP_ITEM_PRICES+9);
12003                        		__ld.wm		_ptr_SHOP_ITEM_PRICES
         02:CEF3  AD 3F 26   			lda.l	_ptr_SHOP_ITEM_PRICES
         02:CEF6  AC 40 26   			ldy.h	_ptr_SHOP_ITEM_PRICES
12004                        		__add.wi	18
         02:CEF9  18         			clc
         02:CEFA  69 12      			adc.l	#18
         02:CEFC  90 01      			bcc	!+
         02:CEFE  C8         			iny
         02:CEFF             	!:
12005                        		__st.wm		__ptr
         02:CEFF  85 88      			sta.l	__ptr
         02:CF01  84 89      			sty.h	__ptr
12006                        		__ld.wp		__ptr
         02:CF03  A0 01      			ldy	#1
         02:CF05  B1 88      			lda	[__ptr], y
         02:CF07  A8         			tay
         02:CF08  B2 88      			lda	[__ptr]
12007                        		__st.wmq	_shop_prices + 18
         02:CF0A  8D 3D 26   			sta.l	_shop_prices + 18
         02:CF0D  8C 3E 26   			sty.h	_shop_prices + 18
12008                        	
12009                        		.dbg	line,	"include\init.c", 800; put_number(shop_prices[0],4,2,20);
12010                        		__ld.wm		_shop_prices
         02:CF10  AD 2B 26   			lda.l	_shop_prices
         02:CF13  AC 2C 26   			ldy.h	_shop_prices
12011                        		__st.wmq	_bx
         02:CF16  85 FA      			sta.l	_bx
         02:CF18  84 FB      			sty.h	_bx
12012                        		__st.umiq	4, _cl
         02:CF1A  A9 04      			lda.l	#4
         02:CF1C  85 FC      			sta	_cl
12013                        		__st.umiq	2, _dil
         02:CF1E  A9 02      			lda.l	#2
         02:CF20  85 F0      			sta	_dil
12014                        		__st.umiq	20, _dih
         02:CF22  A9 14      			lda.l	#20
         02:CF24  85 F1      			sta	_dih
12015                        		__call		_put_number.4
         02:CF26  20 9F FF   			call	_put_number.4
12016                        	
12017                        		.dbg	line,	"include\init.c", 801; put_number(shop_prices[1],4,7,20);
12018                        		__ld.wm		_shop_prices + 2
         02:CF29  AD 2D 26   			lda.l	_shop_prices + 2
         02:CF2C  AC 2E 26   			ldy.h	_shop_prices + 2
12019                        		__st.wmq	_bx
         02:CF2F  85 FA      			sta.l	_bx
         02:CF31  84 FB      			sty.h	_bx
12020                        		__st.umiq	4, _cl
         02:CF33  A9 04      			lda.l	#4
         02:CF35  85 FC      			sta	_cl
12021                        		__st.umiq	7, _dil
         02:CF37  A9 07      			lda.l	#7
         02:CF39  85 F0      			sta	_dil
12022                        		__st.umiq	20, _dih
         02:CF3B  A9 14      			lda.l	#20
         02:CF3D  85 F1      			sta	_dih
12023                        		__call		_put_number.4
         02:CF3F  20 9F FF   			call	_put_number.4
12024                        	
12025                        		.dbg	line,	"include\init.c", 802; put_number(shop_prices[2],4,12,20);
12026                        		__ld.wm		_shop_prices + 4
         02:CF42  AD 2F 26   			lda.l	_shop_prices + 4
         02:CF45  AC 30 26   			ldy.h	_shop_prices + 4
12027                        		__st.wmq	_bx
         02:CF48  85 FA      			sta.l	_bx
         02:CF4A  84 FB      			sty.h	_bx
12028                        		__st.umiq	4, _cl
         02:CF4C  A9 04      			lda.l	#4
         02:CF4E  85 FC      			sta	_cl
12029                        		__st.umiq	12, _dil
         02:CF50  A9 0C      			lda.l	#12
         02:CF52  85 F0      			sta	_dil
12030                        		__st.umiq	20, _dih
         02:CF54  A9 14      			lda.l	#20
         02:CF56  85 F1      			sta	_dih
12031                        		__call		_put_number.4
         02:CF58  20 9F FF   			call	_put_number.4
12032                        	
12033                        		.dbg	line,	"include\init.c", 803; put_number(shop_prices[3],4,17,20);
12034                        		__ld.wm		_shop_prices + 6
         02:CF5B  AD 31 26   			lda.l	_shop_prices + 6
         02:CF5E  AC 32 26   			ldy.h	_shop_prices + 6
12035                        		__st.wmq	_bx
         02:CF61  85 FA      			sta.l	_bx
         02:CF63  84 FB      			sty.h	_bx
12036                        		__st.umiq	4, _cl
         02:CF65  A9 04      			lda.l	#4
         02:CF67  85 FC      			sta	_cl
12037                        		__st.umiq	17, _dil
         02:CF69  A9 11      			lda.l	#17
         02:CF6B  85 F0      			sta	_dil
12038                        		__st.umiq	20, _dih
         02:CF6D  A9 14      			lda.l	#20
         02:CF6F  85 F1      			sta	_dih
12039                        		__call		_put_number.4
         02:CF71  20 9F FF   			call	_put_number.4
12040                        	
12041                        		.dbg	line,	"include\init.c", 804; put_number(shop_prices[4],4,22,20);
12042                        		__ld.wm		_shop_prices + 8
         02:CF74  AD 33 26   			lda.l	_shop_prices + 8
         02:CF77  AC 34 26   			ldy.h	_shop_prices + 8
12043                        		__st.wmq	_bx
         02:CF7A  85 FA      			sta.l	_bx
         02:CF7C  84 FB      			sty.h	_bx
12044                        		__st.umiq	4, _cl
         02:CF7E  A9 04      			lda.l	#4
         02:CF80  85 FC      			sta	_cl
12045                        		__st.umiq	22, _dil
         02:CF82  A9 16      			lda.l	#22
         02:CF84  85 F0      			sta	_dil
12046                        		__st.umiq	20, _dih
         02:CF86  A9 14      			lda.l	#20
         02:CF88  85 F1      			sta	_dih
12047                        		__call		_put_number.4
         02:CF8A  20 9F FF   			call	_put_number.4
12048                        	
12049                        		.dbg	line,	"include\init.c", 806; put_number(shop_prices[5],4,2,23);
12050                        		__ld.wm		_shop_prices + 10
         02:CF8D  AD 35 26   			lda.l	_shop_prices + 10
         02:CF90  AC 36 26   			ldy.h	_shop_prices + 10
12051                        		__st.wmq	_bx
         02:CF93  85 FA      			sta.l	_bx
         02:CF95  84 FB      			sty.h	_bx
12052                        		__st.umiq	4, _cl
         02:CF97  A9 04      			lda.l	#4
         02:CF99  85 FC      			sta	_cl
12053                        		__st.umiq	2, _dil
         02:CF9B  A9 02      			lda.l	#2
         02:CF9D  85 F0      			sta	_dil
12054                        		__st.umiq	23, _dih
         02:CF9F  A9 17      			lda.l	#23
         02:CFA1  85 F1      			sta	_dih
12055                        		__call		_put_number.4
         02:CFA3  20 9F FF   			call	_put_number.4
12056                        	
12057                        		.dbg	line,	"include\init.c", 807; put_number(shop_prices[6],4,7,23);
12058                        		__ld.wm		_shop_prices + 12
         02:CFA6  AD 37 26   			lda.l	_shop_prices + 12
         02:CFA9  AC 38 26   			ldy.h	_shop_prices + 12
12059                        		__st.wmq	_bx
         02:CFAC  85 FA      			sta.l	_bx
         02:CFAE  84 FB      			sty.h	_bx
12060                        		__st.umiq	4, _cl
         02:CFB0  A9 04      			lda.l	#4
         02:CFB2  85 FC      			sta	_cl
12061                        		__st.umiq	7, _dil
         02:CFB4  A9 07      			lda.l	#7
         02:CFB6  85 F0      			sta	_dil
12062                        		__st.umiq	23, _dih
         02:CFB8  A9 17      			lda.l	#23
         02:CFBA  85 F1      			sta	_dih
12063                        		__call		_put_number.4
         02:CFBC  20 9F FF   			call	_put_number.4
12064                        	
12065                        		.dbg	line,	"include\init.c", 808; put_number(shop_prices[7],4,12,23);
12066                        		__ld.wm		_shop_prices + 14
         02:CFBF  AD 39 26   			lda.l	_shop_prices + 14
         02:CFC2  AC 3A 26   			ldy.h	_shop_prices + 14
12067                        		__st.wmq	_bx
         02:CFC5  85 FA      			sta.l	_bx
         02:CFC7  84 FB      			sty.h	_bx
12068                        		__st.umiq	4, _cl
         02:CFC9  A9 04      			lda.l	#4
         02:CFCB  85 FC      			sta	_cl
12069                        		__st.umiq	12, _dil
         02:CFCD  A9 0C      			lda.l	#12
         02:CFCF  85 F0      			sta	_dil
12070                        		__st.umiq	23, _dih
         02:CFD1  A9 17      			lda.l	#23
         02:CFD3  85 F1      			sta	_dih
12071                        		__call		_put_number.4
         02:CFD5  20 9F FF   			call	_put_number.4
12072                        	
12073                        		.dbg	line,	"include\init.c", 809; put_number(shop_prices[8],4,17,23);
12074                        		__ld.wm		_shop_prices + 16
         02:CFD8  AD 3B 26   			lda.l	_shop_prices + 16
         02:CFDB  AC 3C 26   			ldy.h	_shop_prices + 16
12075                        		__st.wmq	_bx
         02:CFDE  85 FA      			sta.l	_bx
         02:CFE0  84 FB      			sty.h	_bx
12076                        		__st.umiq	4, _cl
         02:CFE2  A9 04      			lda.l	#4
         02:CFE4  85 FC      			sta	_cl
12077                        		__st.umiq	17, _dil
         02:CFE6  A9 11      			lda.l	#17
         02:CFE8  85 F0      			sta	_dil
12078                        		__st.umiq	23, _dih
         02:CFEA  A9 17      			lda.l	#23
         02:CFEC  85 F1      			sta	_dih
12079                        		__call		_put_number.4
         02:CFEE  20 9F FF   			call	_put_number.4
12080                        	
12081                        		.dbg	line,	"include\init.c", 810; put_number(shop_prices[9],4,22,23);
12082                        		__ld.wm		_shop_prices + 18
         02:CFF1  AD 3D 26   			lda.l	_shop_prices + 18
         02:CFF4  AC 3E 26   			ldy.h	_shop_prices + 18
12083                        		__st.wmq	_bx
         02:CFF7  85 FA      			sta.l	_bx
         02:CFF9  84 FB      			sty.h	_bx
12084                        		__st.umiq	4, _cl
         02:CFFB  A9 04      			lda.l	#4
         02:CFFD  85 FC      			sta	_cl
12085                        		__st.umiq	22, _dil
         02:CFFF  A9 16      			lda.l	#22
         02:D001  85 F0      			sta	_dil
12086                        		__st.umiq	23, _dih
         02:D003  A9 17      			lda.l	#23
         02:D005  85 F1      			sta	_dih
12087                        		__call		_put_number.4
         02:D007  20 9F FF   			call	_put_number.4
12088                        	
12089                        		.dbg	line,	"include\init.c", 815; //--------------------------------------------------------------------------------------//
12090                        	
12091                        		.dbg	line,	"include\init.c", 816; //                                   LOAD BG PALETTES                                   //
12092                        	
12093                        		.dbg	line,	"include\init.c", 817; //--------------------------------------------------------------------------------------//
12094                        	
12095                        		.dbg	line,	"include\init.c", 819; load_palette( 0, palette_SHOP, 16 );
12096                        		__st.umiq	0, _al
         02:D00A  64 F8      			stz	_al
12097                        		__farptr	_palette_SHOP, _bp_bank, _bp
         02:D00C  A9 E0      			lda.l	#$6000 + ($1FFF & (_palette_SHOP))
         02:D00E  85 EC      			sta.l	_bp
         02:D010  A9 65      			lda.h	#$6000 + ($1FFF & (_palette_SHOP))
         02:D012  85 ED      			sta.h	_bp
         02:D014  A9 0E      			lda	#bank(_palette_SHOP)
         02:D016  85 02      			sta	_bp_bank
12098                        		__st.umiq	16, _ah
         02:D018  A9 10      			lda.l	#16
         02:D01A  85 F9      			sta	_ah
12099                        		__call		_load_palette.3
         02:D01C  20 EB FE   			call	_load_palette.3
12100                        	
12101                        		.dbg	line,	"include\init.c", 824; //**************************************************************************************//
12102                        	
12103                        		.dbg	line,	"include\init.c", 825; //                                                                                      //
12104                        	
12105                        		.dbg	line,	"include\init.c", 826; //                                       SPRITES                                        //
12106                        	
12107                        		.dbg	line,	"include\init.c", 827; //                                                                                      //
12108                        	
12109                        		.dbg	line,	"include\init.c", 828; //**************************************************************************************//
12110                        	
12111                        		.dbg	line,	"include\init.c", 830; //--------------------------------------------------------------------------------------//
12112                        	
12113                        		.dbg	line,	"include\init.c", 831; //                                        CURSOR                                        //
12114                        	
12115                        		.dbg	line,	"include\init.c", 832; //--------------------------------------------------------------------------------------//
12116                        	
12117                        		.dbg	line,	"include\init.c", 834; // LOAD CURSOR TILES //
12118                        	
12119                        		.dbg	line,	"include\init.c", 835; load_vram(0x2000, tiles_SPR_CURSOR , TILES_16);
12120                        		__st.wmiq	8192, _di
         02:D01F  64 F0      			stz.l	_di
         02:D021  A9 20      			lda.h	#8192
         02:D023  85 F1      			sta.h	_di
12121                        		__farptr	_tiles_SPR_CURSOR, _bp_bank, _bp
         02:D025  A9 60      			lda.l	#$6000 + ($1FFF & (_tiles_SPR_CURSOR))
         02:D027  85 EC      			sta.l	_bp
         02:D029  A9 7D      			lda.h	#$6000 + ($1FFF & (_tiles_SPR_CURSOR))
         02:D02B  85 ED      			sta.h	_bp
         02:D02D  A9 10      			lda	#bank(_tiles_SPR_CURSOR)
         02:D02F  85 02      			sta	_bp_bank
12122                        		__st.wmiq	256, _ax
         02:D031  64 F8      			stz.l	_ax
         02:D033  A9 01      			lda.h	#256
         02:D035  85 F9      			sta.h	_ax
12123                        		 _load_vram.3
         02:D037  82         			clx				; Offset to PCE VDC.
         02:D038  20 63 FF   			call	load_vram_x
12124                        	
12125                        		.dbg	line,	"include\init.c", 838; // SELECT CURSOR SPRITE //
12126                        	
12127                        		.dbg	line,	"include\init.c", 839; spr_set(0);
12128                        		__ld.uiq	0
         02:D03B  62         			cla
12129                        		__call		_spr_set.1
         02:D03C  20 DD E7   			call	_spr_set.1
12130                        	
12131                        		.dbg	line,	"include\init.c", 840; spr_hide();
12132                        		__call		_spr_hide
         02:D03F  20 F8 E7   			call	_spr_hide
12133                        	
12134                        		.dbg	line,	"include\init.c", 843; //spr_x(24);
12135                        	
12136                        		.dbg	line,	"include\init.c", 844; //spr_y(144);
12137                        	
12138                        		.dbg	line,	"include\init.c", 846; // SET TILES DATA FOR THE CURSOR //
12139                        	
12140                        		.dbg	line,	"include\init.c", 847; spr_pattern(0x2000);
12141                        		__ld.wi		8192
         02:D042  62         			cla
         02:D043  A0 20      			ldy.h	#8192
12142                        		__call		_spr_pattern.1
         02:D045  20 26 E8   			call	_spr_pattern.1
12143                        	
12144                        		.dbg	line,	"include\init.c", 850; spr_ctrl(FLIP_MAS|SIZE_MAS, NO_FLIP|SZ_32x32);
12145                        		__st.umiq	185, _al
         02:D048  A9 B9      			lda.l	#185
         02:D04A  85 F8      			sta	_al
12146                        		__ld.uiq	17
         02:D04C  A9 11      			lda	#17
12147                        		__call		_spr_ctrl.2
         02:D04E  20 3C E8   			call	_spr_ctrl.2
12148                        	
12149                        		.dbg	line,	"include\init.c", 853; spr_pal(16);
12150                        		__ld.uiq	16
         02:D051  A9 10      			lda	#16
12151                        		__call		_spr_pal.1
         02:D053  20 4D E8   			call	_spr_pal.1
12152                        	
12153                        		.dbg	line,	"include\init.c", 854; spr_pri(TRUE);
12154                        		__ld.uiq	1
         02:D056  A9 01      			lda	#1
12155                        		__call		_spr_pri.1
         02:D058  20 5C E8   			call	_spr_pri.1
12156                        	
12157                        		.dbg	line,	"include\init.c", 857; // UPDATE PCE SAT //
12158                        	
12159                        		.dbg	line,	"include\init.c", 858; satb_update();
12160                        		__call		_satb_update
         02:D05B  20 91 FE   			call	_satb_update
12161                        	
12162                        		.dbg	line,	"include\init.c", 862; //--------------------------------------------------------------------------------------//
12163                        	
12164                        		.dbg	line,	"include\init.c", 863; //                                LOAD SPRITES PALETTES                                 //
12165                        	
12166                        		.dbg	line,	"include\init.c", 864; //--------------------------------------------------------------------------------------//
12167                        	
12168                        		.dbg	line,	"include\init.c", 866; load_palette( 16, palette_objects_2, 1 );
12169                        		__st.umiq	16, _al
         02:D05E  A9 10      			lda.l	#16
         02:D060  85 F8      			sta	_al
12170                        		__farptr	_palette_objects_2, _bp_bank, _bp
         02:D062  A9 60      			lda.l	#$6000 + ($1FFF & (_palette_objects_2))
         02:D064  85 EC      			sta.l	_bp
         02:D066  A9 6F      			lda.h	#$6000 + ($1FFF & (_palette_objects_2))
         02:D068  85 ED      			sta.h	_bp
         02:D06A  A9 10      			lda	#bank(_palette_objects_2)
         02:D06C  85 02      			sta	_bp_bank
12171                        		__st.umiq	1, _ah
         02:D06E  A9 01      			lda.l	#1
         02:D070  85 F9      			sta	_ah
12172                        		__call		_load_palette.3
         02:D072  20 EB FE   			call	_load_palette.3
12173                        	
12174                        		.dbg	line,	"include\init.c", 870; // VSYNC //
12175                        	
12176                        		.dbg	line,	"include\init.c", 871; vsync();
12177                        		__call		_vsync
         02:D075  20 09 E3   			call	_vsync
12178                        	
12179                        		.dbg	line,	"include\init.c", 873; // ENABLE DISPLAY //
12180                        	
12181                        		.dbg	line,	"include\init.c", 874; disp_on();
12182                        		__call		_disp_on
         02:D078  20 16 E4   			call	_disp_on
12183                        	
12184                        		.dbg	line,	"include\init.c", 875; }
12185    02:D07B             	.LL494:
12186                        		__return	0
         02:D07B  4C EF FF   			jmp	leave_proc
12187                        		.dbg	clear
12188                        		.endp
12189               7F60     		.data
12190               230E     		.bss
12191    F8:230E             	__init_SHOP_loc:
12192    F8:230E             			ds	2
12193    F8:2310             	__init_SHOP_end:
12194               E309     		.code
12195                        		.pceas
12196                        	
12197                        		.dbg	line,	"main.c", 31; main()
12198                        		.dbg	line,	"main.c", 32; {
12199                        	;***********************
12200                        	;***********************
12201                        	
12202                        		.hucc
12203    01:DE21             		.proc		_main
12204                        		__enter		_main
12205                        	
12206                        		.dbg	line,	"main.c", 33; if(!sgx_detect())
12207                        		 _sgx_detect
         01:DE21  AD E8 22   			lda	sgx_detected
         01:DE24  C2         			cly
12208                        		__not.wr
         01:DE25  84 00      			sty	__temp
         01:DE27  05 00      			ora	__temp
         01:DE29  18         			clc
         01:DE2A  D0 01      			bne	!+
         01:DE2C  38         			sec
         01:DE2D             	!:
12209                        		__bfalse	.LL501
         01:DE2D  90 14      			bcc	.LL501
12210                        	
12211                        		.dbg	line,	"main.c", 34; {
12212                        	
12213                        		.dbg	line,	"main.c", 35; put_string("Halt: SGX hardware not found", 2, 13);
12214                        		__ld.wi		__const1+0
         01:DE2F  62         			cla
         01:DE30  A0 60      			ldy.h	#__const1+0
12215                        		__st.wmq	_bp
         01:DE32  85 EC      			sta.l	_bp
         01:DE34  84 ED      			sty.h	_bp
12216                        		__st.umiq	2, _dil
         01:DE36  A9 02      			lda.l	#2
         01:DE38  85 F0      			sta	_dil
12217                        		__st.umiq	13, _dih
         01:DE3A  A9 0D      			lda.l	#13
         01:DE3C  85 F1      			sta	_dih
12218                        		__call		_put_string.3
         01:DE3E  20 68 E6   			call	_put_string.3
12219                        	
12220                        		.dbg	line,	"main.c", 37; for(;;)
12221    01:DE41             	.LL502	.alias		.LL504
12222    01:DE41             	.LL503	.alias		.LL504
12223    01:DE41             	.LL504:
12224                        	
12225                        		.dbg	line,	"main.c", 38; {
12226                        	
12227                        		.dbg	line,	"main.c", 39; // INFINITE LOOP //
12228                        	
12229                        		.dbg	line,	"main.c", 40; }
12230                        		__bra		.LL504
         01:DE41  80 FE      			bra	.LL504
12231    01:DE43             	.LL505:
12232                        	
12233                        		.dbg	line,	"main.c", 41; }
12234                        	
12235                        		.dbg	line,	"main.c", 46; init_SYSTEM();
12236    01:DE43             	.LL501:
12237                        		__call		_init_SYSTEM
         01:DE43  20 73 FE   			call	_init_SYSTEM
12238                        	
12239                        		.dbg	line,	"main.c", 47; 
12240                        	
12241                        		.dbg	line,	"main.c", 48; 
12242                        	
12243                        		.dbg	line,	"main.c", 49; init_VARIABLES();
12244                        		__call		_init_VARIABLES
         01:DE46  20 69 FE   			call	_init_VARIABLES
12245                        	
12246                        		.dbg	line,	"main.c", 52; init_PLAYER();
12247                        		__call		_init_PLAYER
         01:DE49  20 5F FE   			call	_init_PLAYER
12248                        	
12249                        		.dbg	line,	"main.c", 57; //**************************************************************************************//
12250                        	
12251                        		.dbg	line,	"main.c", 58; //                                                                                      //
12252                        	
12253                        		.dbg	line,	"main.c", 59; //                                         MAIN                                         //
12254                        	
12255                        		.dbg	line,	"main.c", 60; //                                                                                      //
12256                        	
12257                        		.dbg	line,	"main.c", 61; //**************************************************************************************//
12258                        	
12259                        		.dbg	line,	"main.c", 62; for(;;)
12260    01:DE4C             	.LL506:
12261    01:DE4C             	.LL507:
12262    01:DE4C             	.LL508:
12263                        	
12264                        		.dbg	line,	"main.c", 63; {
12265                        	
12266                        		.dbg	line,	"main.c", 64; switch(sequence_id)
12267                        		__ld.umq	_sequence_id
         01:DE4C  AD 10 23   			lda	_sequence_id
12268                        		__bra		.LL510
         01:DE4F  4C D5 DF   			bra	.LL510
12269                        	
12270                        		.dbg	line,	"main.c", 65; {
12271                        	
12272                        		.dbg	line,	"main.c", 66; //-----------------------------------------------------------------------------//
12273                        	
12274                        		.dbg	line,	"main.c", 67; //                                    TITLE                                    //
12275                        	
12276                        		.dbg	line,	"main.c", 68; //-----------------------------------------------------------------------------//
12277                        	
12278                        		.dbg	line,	"main.c", 69; case SEQUENCE_TITLE:
12279    01:DE52             	.LL512:
12280                        		__case		0
12281                        	
12282                        		.dbg	line,	"main.c", 70; break;
12283                        		__bra		.LL511
         01:DE52  80 F8      			bra	.LL511
12284                        	
12285                        		.dbg	line,	"main.c", 73; //-----------------------------------------------------------------------------//
12286                        	
12287                        		.dbg	line,	"main.c", 74; //                                    INTRO                                    //
12288                        	
12289                        		.dbg	line,	"main.c", 75; //-----------------------------------------------------------------------------//
12290                        	
12291                        		.dbg	line,	"main.c", 76; case SEQUENCE_INTRO:
12292    01:DE54             	.LL513:
12293                        		__case		1
12294                        	
12295                        		.dbg	line,	"main.c", 77; break;
12296                        		__bra		.LL511
         01:DE54  80 F6      			bra	.LL511
12297                        	
12298                        		.dbg	line,	"main.c", 80; //-----------------------------------------------------------------------------//
12299                        	
12300                        		.dbg	line,	"main.c", 81; //                                    GAME                                     //
12301                        	
12302                        		.dbg	line,	"main.c", 82; //-----------------------------------------------------------------------------//
12303                        	
12304                        		.dbg	line,	"main.c", 83; case SEQUENCE_GAME:
12305    01:DE56             	.LL514:
12306                        		__case		2
12307                        	
12308                        		.dbg	line,	"main.c", 84; if(sequence_loaded == FALSE)
12309                        		__not.um	_sequence_loaded
         01:DE56  AD 11 23   			lda	_sequence_loaded
         01:DE59  18         			clc
         01:DE5A  D0 01      			bne	!+
         01:DE5C  38         			sec
         01:DE5D             	!:
12310                        		__bfalse	.LL515
         01:DE5D  90 0A      			bcc	.LL515
12311                        	
12312                        		.dbg	line,	"main.c", 85; {
12313                        	
12314                        		.dbg	line,	"main.c", 86; init_LEVEL();
12315                        		__call		_init_LEVEL
         01:DE5F  20 55 FE   			call	_init_LEVEL
12316                        	
12317                        		.dbg	line,	"main.c", 88; sequence_loaded = TRUE;
12318                        		__st.umiq	1, _sequence_loaded
         01:DE62  A9 01      			lda.l	#1
         01:DE64  8D 11 23   			sta	_sequence_loaded
12319                        	
12320                        		.dbg	line,	"main.c", 89; }
12321                        	
12322                        		.dbg	line,	"main.c", 92; else
12323                        		__bra		.LL516
         01:DE67  80 E3      			bra	.LL516
12324    01:DE69             	.LL515:
12325                        	
12326                        		.dbg	line,	"main.c", 93; {
12327                        	
12328                        		.dbg	line,	"main.c", 94; switch(level_id)
12329                        		__ld.umq	_level_id
         01:DE69  AD 12 23   			lda	_level_id
12330                        		__bra		.LL517
         01:DE6C  80 3A      			bra	.LL517
12331                        	
12332                        		.dbg	line,	"main.c", 95; {
12333                        	
12334                        		.dbg	line,	"main.c", 96; case 1:
12335    01:DE6E             	.LL519:
12336                        		__case		1
12337                        	
12338                        		.dbg	line,	"main.c", 97; vsync();
12339                        		__call		_vsync
         01:DE6E  20 09 E3   			call	_vsync
12340                        	
12341                        		.dbg	line,	"main.c", 99; update_PLAYER();
12342                        		__call		_update_PLAYER
         01:DE71  20 4B FE   			call	_update_PLAYER
12343                        	
12344                        		.dbg	line,	"main.c", 100; 
12345                        	
12346                        		.dbg	line,	"main.c", 101; //put_number(player_state,1,0,0);
12347                        	
12348                        		.dbg	line,	"main.c", 103; joypad_DIR();
12349                        		__call		_joypad_DIR
         01:DE74  20 41 FE   			call	_joypad_DIR
12350                        	
12351                        		.dbg	line,	"main.c", 104; joypad_BUTTONS();
12352                        		__call		_joypad_BUTTONS
         01:DE77  20 37 FE   			call	_joypad_BUTTONS
12353                        	
12354                        		.dbg	line,	"main.c", 106; scroll_object();
12355                        		__call		_scroll_object
         01:DE7A  20 CD FE   			call	_scroll_object
12356                        	
12357                        		.dbg	line,	"main.c", 107; scroll_chest();
12358                        		__call		_scroll_chest
         01:DE7D  20 AF FE   			call	_scroll_chest
12359                        	
12360                        		.dbg	line,	"main.c", 108; scroll_npc();
12361                        		__call		_scroll_npc
         01:DE80  20 2D FE   			call	_scroll_npc
12362                        	
12363                        		.dbg	line,	"main.c", 110; check_OBJECT();
12364                        		__call		_check_OBJECT
         01:DE83  20 23 FE   			call	_check_OBJECT
12365                        	
12366                        		.dbg	line,	"main.c", 111; check_NPC();
12367                        		__call		_check_NPC
         01:DE86  20 19 FE   			call	_check_NPC
12368                        	
12369                        		.dbg	line,	"main.c", 113; display_TIME_LEVEL();
12370                        		__call		_display_TIME_LEVEL
         01:DE89  20 09 FF   			call	_display_TIME_LEVEL
12371                        	
12372                        		.dbg	line,	"main.c", 115; satb_update();
12373                        		__call		_satb_update
         01:DE8C  20 91 FE   			call	_satb_update
12374                        	
12375                        		.dbg	line,	"main.c", 117; scroll_BG();
12376                        		__call		_scroll_BG
         01:DE8F  20 0F FE   			call	_scroll_BG
12377                        	
12378                        		.dbg	line,	"main.c", 118; break;
12379                        		__bra		.LL518
         01:DE92  80 B8      			bra	.LL518
12380                        	
12381                        		.dbg	line,	"main.c", 121; case 2:
12382    01:DE94             	.LL520:
12383                        		__case		2
12384                        	
12385                        		.dbg	line,	"main.c", 122; vsync();
12386                        		__call		_vsync
         01:DE94  20 09 E3   			call	_vsync
12387                        	
12388                        		.dbg	line,	"main.c", 123; break;
12389                        		__bra		.LL518
         01:DE97  80 B3      			bra	.LL518
12390                        	
12391                        		.dbg	line,	"main.c", 126; case 3:
12392    01:DE99             	.LL521:
12393                        		__case		3
12394                        	
12395                        		.dbg	line,	"main.c", 127; vsync();
12396                        		__call		_vsync
         01:DE99  20 09 E3   			call	_vsync
12397                        	
12398                        		.dbg	line,	"main.c", 128; break;
12399                        		__bra		.LL518
         01:DE9C  80 AE      			bra	.LL518
12400                        	
12401                        		.dbg	line,	"main.c", 131; case 4:
12402    01:DE9E             	.LL522:
12403                        		__case		4
12404                        	
12405                        		.dbg	line,	"main.c", 132; vsync();
12406                        		__call		_vsync
         01:DE9E  20 09 E3   			call	_vsync
12407                        	
12408                        		.dbg	line,	"main.c", 133; break;
12409                        		__bra		.LL518
         01:DEA1  80 A9      			bra	.LL518
12410                        	
12411                        		.dbg	line,	"main.c", 136; case 5:
12412    01:DEA3             	.LL523:
12413                        		__case		5
12414                        	
12415                        		.dbg	line,	"main.c", 137; vsync();
12416                        		__call		_vsync
         01:DEA3  20 09 E3   			call	_vsync
12417                        	
12418                        		.dbg	line,	"main.c", 138; break;
12419                        		__bra		.LL518
         01:DEA6  80 A4      			bra	.LL518
12420                        	
12421                        		.dbg	line,	"main.c", 140; }
12422    01:DEA8             	.LL517:
12423                        		__switch_r.ur	0, 5
         01:DEA8  C9 06      			cmp	#(5 - 0) + 1
         01:DEAA  90 02      			bcc	!found+
         01:DEAC  A9 06      	!default:	lda	#(5 - 0) + 1
         01:DEAE  0A         	!found:		asl	a
         01:DEAF  AA         			tax
         01:DEB0  7C B3 DE   			jmp	[!table+, x]
12424                        	
12425    01:DEB3  4C DE      	!table:		dw	.LL518, .LL519, .LL520, .LL521, .LL522, .LL523
         01:DEB5  6E DE       
         01:DEB7  94 DE       
         01:DEB9  99 DE       
         01:DEBB  9E DE       
         01:DEBD  A3 DE       
12426    01:DEBF  4C DE      			dw	.LL518
12427    01:DEC1             	.LL518	.alias		.LL511
12428                        	
12429                        		.dbg	line,	"main.c", 141; }
12430    01:DEC1             	.LL516	.alias		.LL511
12431                        	
12432                        		.dbg	line,	"main.c", 143; break;
12433                        		__bra		.LL511
         01:DEC1  80 89      			bra	.LL511
12434                        	
12435                        		.dbg	line,	"main.c", 146; //-----------------------------------------------------------------------------//
12436                        	
12437                        		.dbg	line,	"main.c", 147; //                                     NPC                                     //
12438                        	
12439                        		.dbg	line,	"main.c", 148; //-----------------------------------------------------------------------------//
12440                        	
12441                        		.dbg	line,	"main.c", 149; case SEQUENCE_NPC:
12442    01:DEC3             	.LL524:
12443                        		__case		3
12444                        	
12445                        		.dbg	line,	"main.c", 150; break;
12446                        		__bra		.LL511
         01:DEC3  80 87      			bra	.LL511
12447                        	
12448                        		.dbg	line,	"main.c", 153; //-----------------------------------------------------------------------------//
12449                        	
12450                        		.dbg	line,	"main.c", 154; //                                    SHOP                                     //
12451                        	
12452                        		.dbg	line,	"main.c", 155; //-----------------------------------------------------------------------------//
12453                        	
12454                        		.dbg	line,	"main.c", 156; case SEQUENCE_SHOP:
12455    01:DEC5             	.LL525:
12456                        		__case		4
12457                        	
12458                        		.dbg	line,	"main.c", 157; if(sequence_loaded == FALSE)
12459                        		__not.um	_sequence_loaded
         01:DEC5  AD 11 23   			lda	_sequence_loaded
         01:DEC8  18         			clc
         01:DEC9  D0 01      			bne	!+
         01:DECB  38         			sec
         01:DECC             	!:
12460                        		__bfalse	.LL526
         01:DECC  90 0B      			bcc	.LL526
12461                        	
12462                        		.dbg	line,	"main.c", 158; {
12463                        	
12464                        		.dbg	line,	"main.c", 159; init_SHOP();
12465                        		__call		_init_SHOP
         01:DECE  20 05 FE   			call	_init_SHOP
12466                        	
12467                        		.dbg	line,	"main.c", 161; sequence_loaded = TRUE;
12468                        		__st.umiq	1, _sequence_loaded
         01:DED1  A9 01      			lda.l	#1
         01:DED3  8D 11 23   			sta	_sequence_loaded
12469                        	
12470                        		.dbg	line,	"main.c", 162; }
12471                        	
12472                        		.dbg	line,	"main.c", 163; 
12473                        	
12474                        		.dbg	line,	"main.c", 164; else
12475                        		__bra		.LL527
         01:DED6  4C 4C DE   			bra	.LL527
12476    01:DED9             	.LL526:
12477                        	
12478                        		.dbg	line,	"main.c", 165; {
12479                        	
12480                        		.dbg	line,	"main.c", 166; switch(shop_phase)
12481                        		__ld.umq	_shop_phase
         01:DED9  AD CB 23   			lda	_shop_phase
12482                        		__bra		.LL528
         01:DEDC  4C BF DF   			bra	.LL528
12483                        	
12484                        		.dbg	line,	"main.c", 167; {
12485                        	
12486                        		.dbg	line,	"main.c", 168; case SHOP_PHASE_ENTER:
12487    01:DEDF             	.LL530:
12488                        		__case		0
12489                        	
12490                        		.dbg	line,	"main.c", 169; vsync();
12491                        		__call		_vsync
         01:DEDF  20 09 E3   			call	_vsync
12492                        	
12493                        		.dbg	line,	"main.c", 171; if(shop_counter == 0)
12494                        		__not.um	_shop_counter
         01:DEE2  AD CC 23   			lda	_shop_counter
         01:DEE5  18         			clc
         01:DEE6  D0 01      			bne	!+
         01:DEE8  38         			sec
         01:DEE9             	!:
12495                        		__bfalse	.LL531
         01:DEE9  90 28      			bcc	.LL531
12496                        	
12497                        		.dbg	line,	"main.c", 172; {
12498                        	
12499                        		.dbg	line,	"main.c", 173; put_string("Maybe, i can sell you" ,  2 , 15);
12500                        		__ld.wi		__const1+29
         01:DEEB  A9 1D      			lda.l	#__const1+29
         01:DEED  A0 60      			ldy.h	#__const1+29
12501                        		__st.wmq	_bp
         01:DEEF  85 EC      			sta.l	_bp
         01:DEF1  84 ED      			sty.h	_bp
12502                        		__st.umiq	2, _dil
         01:DEF3  A9 02      			lda.l	#2
         01:DEF5  85 F0      			sta	_dil
12503                        		__st.umiq	15, _dih
         01:DEF7  A9 0F      			lda.l	#15
         01:DEF9  85 F1      			sta	_dih
12504                        		__call		_put_string.3
         01:DEFB  20 68 E6   			call	_put_string.3
12505                        	
12506                        		.dbg	line,	"main.c", 174; put_string("something..." , 18 , 16);
12507                        		__ld.wi		__const1+51
         01:DEFE  A9 33      			lda.l	#__const1+51
         01:DF00  A0 60      			ldy.h	#__const1+51
12508                        		__st.wmq	_bp
         01:DF02  85 EC      			sta.l	_bp
         01:DF04  84 ED      			sty.h	_bp
12509                        		__st.umiq	18, _dil
         01:DF06  A9 12      			lda.l	#18
         01:DF08  85 F0      			sta	_dil
12510                        		__st.umiq	16, _dih
         01:DF0A  A9 10      			lda.l	#16
         01:DF0C  85 F1      			sta	_dih
12511                        		__call		_put_string.3
         01:DF0E  20 68 E6   			call	_put_string.3
12512                        	
12513                        		.dbg	line,	"main.c", 175; }
12514                        	
12515                        		.dbg	line,	"main.c", 177; else if(shop_counter == 120)
12516                        		__bra		.LL532
         01:DF11  80 44      			bra	.LL532
12517    01:DF13             	.LL531:
12518                        		__ld.umq	_shop_counter
         01:DF13  AD CC 23   			lda	_shop_counter
12519                        		__equ_b.uiq	120
         01:DF16  C9 78      			cmp	#120
         01:DF18  F0 01      			beq	!+
         01:DF1A  18         			clc
         01:DF1B             	!:
12520                        		__bfalse	.LL533
         01:DF1B  90 3A      			bcc	.LL533
12521                        	
12522                        		.dbg	line,	"main.c", 178; {
12523                        	
12524                        		.dbg	line,	"main.c", 179; put_string("                     " ,  2 , 15);
12525                        		__ld.wi		__const1+64
         01:DF1D  A9 40      			lda.l	#__const1+64
         01:DF1F  A0 60      			ldy.h	#__const1+64
12526                        		__st.wmq	_bp
         01:DF21  85 EC      			sta.l	_bp
         01:DF23  84 ED      			sty.h	_bp
12527                        		__st.umiq	2, _dil
         01:DF25  A9 02      			lda.l	#2
         01:DF27  85 F0      			sta	_dil
12528                        		__st.umiq	15, _dih
         01:DF29  A9 0F      			lda.l	#15
         01:DF2B  85 F1      			sta	_dih
12529                        		__call		_put_string.3
         01:DF2D  20 68 E6   			call	_put_string.3
12530                        	
12531                        		.dbg	line,	"main.c", 180; put_string("            " , 18 , 16);
12532                        		__ld.wi		__const1+86
         01:DF30  A9 56      			lda.l	#__const1+86
         01:DF32  A0 60      			ldy.h	#__const1+86
12533                        		__st.wmq	_bp
         01:DF34  85 EC      			sta.l	_bp
         01:DF36  84 ED      			sty.h	_bp
12534                        		__st.umiq	18, _dil
         01:DF38  A9 12      			lda.l	#18
         01:DF3A  85 F0      			sta	_dil
12535                        		__st.umiq	16, _dih
         01:DF3C  A9 10      			lda.l	#16
         01:DF3E  85 F1      			sta	_dih
12536                        		__call		_put_string.3
         01:DF40  20 68 E6   			call	_put_string.3
12537                        	
12538                        		.dbg	line,	"main.c", 182; spr_x(24);
12539                        		__ld.wi		24
         01:DF43  A9 18      			lda.l	#24
         01:DF45  C2         			cly
12540                        		__call		_spr_x.1
         01:DF46  20 0A E8   			call	_spr_x.1
12541                        	
12542                        		.dbg	line,	"main.c", 183; spr_y(144);
12543                        		__ld.wi		144
         01:DF49  A9 90      			lda.l	#144
         01:DF4B  C2         			cly
12544                        		__call		_spr_y.1
         01:DF4C  20 19 E8   			call	_spr_y.1
12545                        	
12546                        		.dbg	line,	"main.c", 184; satb_update();
12547                        		__call		_satb_update
         01:DF4F  20 91 FE   			call	_satb_update
12548                        	
12549                        		.dbg	line,	"main.c", 186; shop_phase = SHOP_PHASE_BUY;
12550                        		__st.umiq	1, _shop_phase
         01:DF52  A9 01      			lda.l	#1
         01:DF54  8D CB 23   			sta	_shop_phase
12551                        	
12552                        		.dbg	line,	"main.c", 187; }
12553                        	
12554                        		.dbg	line,	"main.c", 189; shop_counter++;
12555    01:DF57             	.LL533:
12556    01:DF57             	.LL532:
12557                        		__inc.umq	_shop_counter
         01:DF57  EE CC 23   			inc	_shop_counter
12558                        	
12559                        		.dbg	line,	"main.c", 191; break;
12560                        		__bra		.LL529
         01:DF5A  4C 4C DE   			bra	.LL529
12561                        	
12562                        		.dbg	line,	"main.c", 192; 
12563                        	
12564                        		.dbg	line,	"main.c", 194; case SHOP_PHASE_BUY:
12565    01:DF5D             	.LL534:
12566                        		__case		1
12567                        	
12568                        		.dbg	line,	"main.c", 195; vsync();
12569                        		__call		_vsync
         01:DF5D  20 09 E3   			call	_vsync
12570                        	
12571                        		.dbg	line,	"main.c", 197; joypad_BUTTONS_SHOP();
12572                        		__call		_joypad_BUTTONS_SHOP
         01:DF60  20 FB FD   			call	_joypad_BUTTONS_SHOP
12573                        	
12574                        		.dbg	line,	"main.c", 198; display_TIME_SHOP();
12575                        		__call		_display_TIME_SHOP
         01:DF63  20 F1 FD   			call	_display_TIME_SHOP
12576                        	
12577                        		.dbg	line,	"main.c", 199; satb_update();
12578                        		__call		_satb_update
         01:DF66  20 91 FE   			call	_satb_update
12579                        	
12580                        		.dbg	line,	"main.c", 201; break;
12581                        		__bra		.LL529
         01:DF69  4C 4C DE   			bra	.LL529
12582                        	
12583                        		.dbg	line,	"main.c", 204; case SHOP_PHASE_EXIT:
12584    01:DF6C             	.LL535:
12585                        		__case		2
12586                        	
12587                        		.dbg	line,	"main.c", 205; vsync();
12588                        		__call		_vsync
         01:DF6C  20 09 E3   			call	_vsync
12589                        	
12590                        		.dbg	line,	"main.c", 207; if(shop_counter == 0)
12591                        		__not.um	_shop_counter
         01:DF6F  AD CC 23   			lda	_shop_counter
         01:DF72  18         			clc
         01:DF73  D0 01      			bne	!+
         01:DF75  38         			sec
         01:DF76             	!:
12592                        		__bfalse	.LL536
         01:DF76  90 1F      			bcc	.LL536
12593                        	
12594                        		.dbg	line,	"main.c", 208; {
12595                        	
12596                        		.dbg	line,	"main.c", 209; put_string("GOOD LUCK!" , 11 , 16);
12597                        		__ld.wi		__const1+99
         01:DF78  A9 63      			lda.l	#__const1+99
         01:DF7A  A0 60      			ldy.h	#__const1+99
12598                        		__st.wmq	_bp
         01:DF7C  85 EC      			sta.l	_bp
         01:DF7E  84 ED      			sty.h	_bp
12599                        		__st.umiq	11, _dil
         01:DF80  A9 0B      			lda.l	#11
         01:DF82  85 F0      			sta	_dil
12600                        		__st.umiq	16, _dih
         01:DF84  A9 10      			lda.l	#16
         01:DF86  85 F1      			sta	_dih
12601                        		__call		_put_string.3
         01:DF88  20 68 E6   			call	_put_string.3
12602                        	
12603                        		.dbg	line,	"main.c", 211; // HIDE CURSOR //
12604                        	
12605                        		.dbg	line,	"main.c", 212; spr_set(0);
12606                        		__ld.uiq	0
         01:DF8B  62         			cla
12607                        		__call		_spr_set.1
         01:DF8C  20 DD E7   			call	_spr_set.1
12608                        	
12609                        		.dbg	line,	"main.c", 213; spr_hide();
12610                        		__call		_spr_hide
         01:DF8F  20 F8 E7   			call	_spr_hide
12611                        	
12612                        		.dbg	line,	"main.c", 214; satb_update();
12613                        		__call		_satb_update
         01:DF92  20 91 FE   			call	_satb_update
12614                        	
12615                        		.dbg	line,	"main.c", 215; }
12616                        	
12617                        		.dbg	line,	"main.c", 217; else if(shop_counter == 120)
12618                        		__bra		.LL537
         01:DF95  80 22      			bra	.LL537
12619    01:DF97             	.LL536:
12620                        		__ld.umq	_shop_counter
         01:DF97  AD CC 23   			lda	_shop_counter
12621                        		__equ_b.uiq	120
         01:DF9A  C9 78      			cmp	#120
         01:DF9C  F0 01      			beq	!+
         01:DF9E  18         			clc
         01:DF9F             	!:
12622                        		__bfalse	.LL538
         01:DF9F  90 18      			bcc	.LL538
12623                        	
12624                        		.dbg	line,	"main.c", 218; {
12625                        	
12626                        		.dbg	line,	"main.c", 219; disp_off();
12627                        		__call		_disp_off
         01:DFA1  20 29 E4   			call	_disp_off
12628                        	
12629                        		.dbg	line,	"main.c", 221; // REINIT PLAYER //
12630                        	
12631                        		.dbg	line,	"main.c", 222; init_PLAYER();
12632                        		__call		_init_PLAYER
         01:DFA4  20 5F FE   			call	_init_PLAYER
12633                        	
12634                        		.dbg	line,	"main.c", 224; shop_phase = SHOP_PHASE_EXIT;
12635                        		__st.umiq	2, _shop_phase
         01:DFA7  A9 02      			lda.l	#2
         01:DFA9  8D CB 23   			sta	_shop_phase
12636                        	
12637                        		.dbg	line,	"main.c", 225; respawn = RESPAWN_SHOP;
12638                        		__st.umiq	2, _respawn
         01:DFAC  A9 02      			lda.l	#2
         01:DFAE  8D 13 23   			sta	_respawn
12639                        	
12640                        		.dbg	line,	"main.c", 226; sequence_loaded = FALSE;
12641                        		__st.umiq	0, _sequence_loaded
         01:DFB1  9C 11 23   			stz	_sequence_loaded
12642                        	
12643                        		.dbg	line,	"main.c", 227; sequence_id = SEQUENCE_GAME;
12644                        		__st.umiq	2, _sequence_id
         01:DFB4  A9 02      			lda.l	#2
         01:DFB6  8D 10 23   			sta	_sequence_id
12645                        	
12646                        		.dbg	line,	"main.c", 228; }
12647                        	
12648                        		.dbg	line,	"main.c", 230; shop_counter++;
12649    01:DFB9             	.LL538:
12650    01:DFB9             	.LL537:
12651                        		__inc.umq	_shop_counter
         01:DFB9  EE CC 23   			inc	_shop_counter
12652                        	
12653                        		.dbg	line,	"main.c", 232; break;
12654                        		__bra		.LL529
         01:DFBC  4C 4C DE   			bra	.LL529
12655                        	
12656                        		.dbg	line,	"main.c", 233; }
12657    01:DFBF             	.LL528:
12658                        		__switch_r.ur	0, 2
         01:DFBF  C9 03      			cmp	#(2 - 0) + 1
         01:DFC1  90 02      			bcc	!found+
         01:DFC3  A9 03      	!default:	lda	#(2 - 0) + 1
         01:DFC5  0A         	!found:		asl	a
         01:DFC6  AA         			tax
         01:DFC7  7C CA DF   			jmp	[!table+, x]
12659                        	
12660    01:DFCA  DF DE      	!table:		dw	.LL530, .LL534, .LL535
         01:DFCC  5D DF       
         01:DFCE  6C DF       
12661    01:DFD0  4C DE      			dw	.LL529
12662    01:DFD2             	.LL529	.alias		.LL511
12663                        	
12664                        		.dbg	line,	"main.c", 234; }
12665    01:DFD2             	.LL527	.alias		.LL511
12666                        	
12667                        		.dbg	line,	"main.c", 236; break;
12668                        		__bra		.LL511
         01:DFD2  4C 4C DE   			bra	.LL511
12669                        	
12670                        		.dbg	line,	"main.c", 237; }
12671    01:DFD5             	.LL510:
12672                        		__switch_r.ur	0, 4
         01:DFD5  C9 05      			cmp	#(4 - 0) + 1
         01:DFD7  90 02      			bcc	!found+
         01:DFD9  A9 05      	!default:	lda	#(4 - 0) + 1
         01:DFDB  0A         	!found:		asl	a
         01:DFDC  AA         			tax
         01:DFDD  7C E0 DF   			jmp	[!table+, x]
12673                        	
12674    01:DFE0  52 DE      	!table:		dw	.LL512, .LL513, .LL514, .LL524, .LL525
         01:DFE2  54 DE       
         01:DFE4  56 DE       
         01:DFE6  C3 DE       
         01:DFE8  C5 DE       
12675    01:DFEA  4C DE      			dw	.LL511
12676    01:DFEC             	.LL511	.alias		.LL508
12677                        	
12678                        		.dbg	line,	"main.c", 238; }
12679                        		__bra		.LL508
         01:DFEC  4C 4C DE   			bra	.LL508
12680    01:DFEF             	.LL509:
12681                        	
12682                        		.dbg	line,	"main.c", 239; }
12683    01:DFEF             	.LL500:
12684                        		__return	1
         01:DFEF  AA         			tax
         01:DFF0  4C EF FF   			jmp	leave_proc
12685                        		.dbg	clear
12686                        		.endp
12687                        		.pceas
12688                        	
12689                        		.dbg	clear
12690               6000     		.rodata
12691    01:6000             	__const1:
12692    01:6000  48 61 6C 74			db	'H','a','l','t',':',' ','S','G'
         01:6004  3A 20 53 47 
12693    01:6008  58 20 68 61			db	'X',' ','h','a','r','d','w','a'
         01:600C  72 64 77 61 
12694    01:6010  72 65 20 6E			db	'r','e',' ','n','o','t',' ','f'
         01:6014  6F 74 20 66 
12695    01:6018  6F 75 6E 64			db	'o','u','n','d',$00,'M','a','y'
         01:601C  00 4D 61 79 
12696    01:6020  62 65 2C 20			db	'b','e',',',' ','i',' ','c','a'
         01:6024  69 20 63 61 
12697    01:6028  6E 20 73 65			db	'n',' ','s','e','l','l',' ','y'
         01:602C  6C 6C 20 79 
12698    01:6030  6F 75 00 73			db	'o','u',$00,'s','o','m','e','t'
         01:6034  6F 6D 65 74 
12699    01:6038  68 69 6E 67			db	'h','i','n','g','.','.','.',$00
         01:603C  2E 2E 2E 00 
12700    01:6040  20 20 20 20			db	' ',' ',' ',' ',' ',' ',' ',' '
         01:6044  20 20 20 20 
12701    01:6048  20 20 20 20			db	' ',' ',' ',' ',' ',' ',' ',' '
         01:604C  20 20 20 20 
12702    01:6050  20 20 20 20			db	' ',' ',' ',' ',' ',$00,' ',' '
         01:6054  20 00 20 20 
12703    01:6058  20 20 20 20			db	' ',' ',' ',' ',' ',' ',' ',' '
         01:605C  20 20 20 20 
12704    01:6060  20 20 00 47			db	' ',' ',$00,'G','O','O','D',' '
         01:6064  4F 4F 44 20 
12705    01:6068  4C 55 43 4B			db	'L','U','C','K','!',$00
         01:606C  21 00       
12706    01:606E             	_TABLE_NPC_TYPE_LV1:
12707    01:606E  01         			db	1
12708    01:606F  00         			db	0
12709    01:6070             	_TABLE_NPC_X_POS_REF_LV1:
12710    01:6070  90 03      			dw	912
12711    01:6072  D0 04      			dw	1232
12712    01:6074             	_TABLE_NPC_Y_POS_REF_LV1:
12713    01:6074  40 02      			dw	576
12714    01:6076  90 01      			dw	400
12715    01:6078             	_TABLE_OBJECT_TYPE_LV1:
12716    01:6078  00         			db	0
12717    01:6079  01         			db	1
12718    01:607A  01         			db	1
12719    01:607B  01         			db	1
12720    01:607C  01         			db	1
12721    01:607D  01         			db	1
12722    01:607E  01         			db	1
12723    01:607F  02         			db	2
12724    01:6080  01         			db	1
12725    01:6081  01         			db	1
12726    01:6082  01         			db	1
12727    01:6083  01         			db	1
12728    01:6084  01         			db	1
12729    01:6085  01         			db	1
12730    01:6086  01         			db	1
12731    01:6087  01         			db	1
12732    01:6088  01         			db	1
12733    01:6089  01         			db	1
12734    01:608A  01         			db	1
12735    01:608B  01         			db	1
12736    01:608C  01         			db	1
12737    01:608D  01         			db	1
12738    01:608E  01         			db	1
12739    01:608F             	_TABLE_OBJECT_X_POS_REF_LV1:
12740    01:608F  90 06      			dw	1680
12741    01:6091  00 05      			dw	1280
12742    01:6093  C0 05      			dw	1472
12743    01:6095  A0 05      			dw	1440
12744    01:6097  90 04      			dw	1168
12745    01:6099  B0 04      			dw	1200
12746    01:609B  C0 03      			dw	960
12747    01:609D  D8 03      			dw	984
12748    01:609F  50 05      			dw	1360
12749    01:60A1  70 05      			dw	1392
12750    01:60A3  10 06      			dw	1552
12751    01:60A5  90 06      			dw	1680
12752    01:60A7  B0 06      			dw	1712
12753    01:60A9  D0 06      			dw	1744
12754    01:60AB  E0 04      			dw	1248
12755    01:60AD  00 05      			dw	1280
12756    01:60AF  90 04      			dw	1168
12757    01:60B1  10 04      			dw	1040
12758    01:60B3  80 02      			dw	640
12759    01:60B5  A0 02      			dw	672
12760    01:60B7  50 01      			dw	336
12761    01:60B9  70 01      			dw	368
12762    01:60BB  A0 01      			dw	416
12763    01:60BD             	_TABLE_OBJECT_Y_POS_REF_LV1:
12764    01:60BD  80 01      			dw	384
12765    01:60BF  A0 01      			dw	416
12766    01:60C1  E0 01      			dw	480
12767    01:60C3  F0 01      			dw	496
12768    01:60C5  30 02      			dw	560
12769    01:60C7  30 02      			dw	560
12770    01:60C9  50 02      			dw	592
12771    01:60CB  50 02      			dw	592
12772    01:60CD  50 02      			dw	592
12773    01:60CF  50 02      			dw	592
12774    01:60D1  C0 02      			dw	704
12775    01:60D3  D0 02      			dw	720
12776    01:60D5  D0 02      			dw	720
12777    01:60D7  D0 02      			dw	720
12778    01:60D9  E0 02      			dw	736
12779    01:60DB  E0 02      			dw	736
12780    01:60DD  F0 02      			dw	752
12781    01:60DF  50 03      			dw	848
12782    01:60E1  70 03      			dw	880
12783    01:60E3  70 03      			dw	880
12784    01:60E5  80 03      			dw	896
12785    01:60E7  80 03      			dw	896
12786    01:60E9  80 03      			dw	896
12787    01:60EB             	_TABLE_CHEST_X_POS_REF_LV1:
12788    01:60EB  30 04      			dw	1072
12789    01:60ED  30 03      			dw	816
12790    01:60EF             	_TABLE_CHEST_Y_POS_REF_LV1:
12791    01:60EF  40 03      			dw	832
12792    01:60F1  50 03      			dw	848
12793    01:60F3             	_TABLE_PLAYER_TILES_ADR:
12794    01:60F3  E0 69      			dw	_tiles_SPR_PLAYER_ARMOR
12795    01:60F5  E0 69      			dw	_tiles_SPR_PLAYER_ARMOR
12796    01:60F7             	_TABLE_PLAYER_TILES_BANK:
12797    01:60F7  0E         			db	^_tiles_SPR_PLAYER_ARMOR
12798    01:60F8  0E         			db	^_tiles_SPR_PLAYER_ARMOR
12799    01:60F9             	_TABLE_PLAYER_JUMP_V:
12800    01:60F9  FC         			db	-4
12801    01:60FA  FB         			db	-5
12802    01:60FB  F6         			db	-10
12803    01:60FC  FC         			db	-4
12804    01:60FD  FC         			db	-4
12805    01:60FE  F9         			db	-7
12806    01:60FF  FA         			db	-6
12807    01:6100  FD         			db	-3
12808    01:6101  FB         			db	-5
12809    01:6102  FE         			db	-2
12810    01:6103  FC         			db	-4
12811    01:6104  FF         			db	-1
12812    01:6105  FF         			db	-1
12813    01:6106  FF         			db	-1
12814    01:6107  FF         			db	-1
12815    01:6108  00         			db	0
12816    01:6109  00         			db	0
12817    01:610A  00         			db	0
12818    01:610B  00         			db	0
12819    01:610C  01         			db	1
12820    01:610D  01         			db	1
12821    01:610E  01         			db	1
12822    01:610F  01         			db	1
12823    01:6110  04         			db	4
12824    01:6111  02         			db	2
12825    01:6112  05         			db	5
12826    01:6113  03         			db	3
12827    01:6114  06         			db	6
12828    01:6115  07         			db	7
12829    01:6116  04         			db	4
12830    01:6117  04         			db	4
12831    01:6118  0A         			db	10
12832    01:6119  04         			db	4
12833    01:611A  04         			db	4
12834    01:611B  05         			db	5
12835    01:611C             	_TABLE_PLAYER_FALL:
12836    01:611C  00         			db	0
12837    01:611D  00         			db	0
12838    01:611E  00         			db	0
12839    01:611F  00         			db	0
12840    01:6120  01         			db	1
12841    01:6121  01         			db	1
12842    01:6122  01         			db	1
12843    01:6123  01         			db	1
12844    01:6124  02         			db	2
12845    01:6125  02         			db	2
12846    01:6126  02         			db	2
12847    01:6127  02         			db	2
12848    01:6128  03         			db	3
12849    01:6129  03         			db	3
12850    01:612A  03         			db	3
12851    01:612B  04         			db	4
12852    01:612C  04         			db	4
12853    01:612D  04         			db	4
12854    01:612E  04         			db	4
12855    01:612F  04         			db	4
12856    01:6130  05         			db	5
12857    01:6131             	_TABLE_PLAYER_JUMP_LADDER:
12858    01:6131  FC         			db	-4
12859    01:6132  FC         			db	-4
12860    01:6133  FD         			db	-3
12861    01:6134  FD         			db	-3
12862    01:6135  FD         			db	-3
12863    01:6136  FE         			db	-2
12864    01:6137  FE         			db	-2
12865    01:6138  FE         			db	-2
12866    01:6139  FF         			db	-1
12867    01:613A  FF         			db	-1
12868    01:613B  FF         			db	-1
12869    01:613C  FF         			db	-1
12870    01:613D  FF         			db	-1
12871    01:613E  00         			db	0
12872    01:613F  00         			db	0
12873    01:6140  00         			db	0
12874    01:6141  00         			db	0
12875    01:6142  01         			db	1
12876    01:6143  01         			db	1
12877    01:6144  01         			db	1
12878    01:6145  01         			db	1
12879    01:6146  01         			db	1
12880    01:6147  02         			db	2
12881    01:6148  02         			db	2
12882    01:6149  02         			db	2
12883    01:614A  03         			db	3
12884    01:614B  03         			db	3
12885    01:614C  03         			db	3
12886    01:614D  04         			db	4
12887    01:614E  04         			db	4
12888    01:614F             	_TABLE_SHOP_ITEMS_LV1:
12889    01:614F  00         			db	0
12890    01:6150  01         			db	1
12891    01:6151  02         			db	2
12892    01:6152  03         			db	3
12893    01:6153  04         			db	4
12894    01:6154  05         			db	5
12895    01:6155  06         			db	6
12896    01:6156  07         			db	7
12897    01:6157  08         			db	8
12898    01:6158  09         			db	9
12899    01:6159             	_TABLE_SHOP_PRICES_LV1:
12900    01:6159  64 00      			dw	100
12901    01:615B  E8 03      			dw	1000
12902    01:615D  60 09      			dw	2400
12903    01:615F  80 25      			dw	9600
12904    01:6161  1E 00      			dw	30
12905    01:6163  50 00      			dw	80
12906    01:6165  2C 01      			dw	300
12907    01:6167  20 03      			dw	800
12908    01:6169  40 06      			dw	1600
12909    01:616B  96 00      			dw	150
12910    01:616D             	_TABLE_SHOP_ITEMS_TILES_ADR:
12911    01:616D  E0 60      			dw	_tiles_ITEM_WEAPON_2
12912    01:616F  60 61      			dw	_tiles_ITEM_WEAPON_3
12913    01:6171  E0 61      			dw	_tiles_ITEM_WEAPON_4
12914    01:6173  60 62      			dw	_tiles_ITEM_WEAPON_5
12915    01:6175  E0 62      			dw	_tiles_ITEM_KEY
12916    01:6177  60 63      			dw	_tiles_ITEM_ARMOR_2
12917    01:6179  E0 63      			dw	_tiles_ITEM_ARMOR_3
12918    01:617B  60 64      			dw	_tiles_ITEM_ARMOR_4
12919    01:617D  E0 64      			dw	_tiles_ITEM_ARMOR_5
12920    01:617F  60 65      			dw	_tiles_ITEM_POTION
12921    01:6181             	_TABLE_SHOP_ITEMS_TILES_BANK:
12922    01:6181  0E         			db	^_tiles_ITEM_WEAPON_2
12923    01:6182  0E         			db	^_tiles_ITEM_WEAPON_3
12924    01:6183  0E         			db	^_tiles_ITEM_WEAPON_4
12925    01:6184  0E         			db	^_tiles_ITEM_WEAPON_5
12926    01:6185  0E         			db	^_tiles_ITEM_KEY
12927    01:6186  0E         			db	^_tiles_ITEM_ARMOR_2
12928    01:6187  0E         			db	^_tiles_ITEM_ARMOR_3
12929    01:6188  0E         			db	^_tiles_ITEM_ARMOR_4
12930    01:6189  0E         			db	^_tiles_ITEM_ARMOR_5
12931    01:618A  0E         			db	^_tiles_ITEM_POTION
12932    01:618B             	_TABLE_CURSOR_POS_X:
12933    01:618B  18         			db	24
12934    01:618C  38         			db	56
12935    01:618D  60         			db	96
12936    01:618E  88         			db	136
12937    01:618F  B0         			db	176
12938    01:6190  18         			db	24
12939    01:6191  38         			db	56
12940    01:6192  60         			db	96
12941    01:6193  88         			db	136
12942    01:6194  B0         			db	176
12943    01:6195  D4         			db	212
12944                        	
12945               2310     		.bss
12946    F8:2310             	_sequence_id:
12947    F8:2310             			ds	1
12948    F8:2311             	_sequence_loaded:
12949    F8:2311             			ds	1
12950    F8:2312             	_level_id:
12951    F8:2312             			ds	1
12952    F8:2313             	_respawn:
12953    F8:2313             			ds	1
12954    F8:2314             	_player_id:
12955    F8:2314             			ds	1
12956    F8:2315             	_player_state:
12957    F8:2315             			ds	1
12958    F8:2316             	_player_axis:
12959    F8:2316             			ds	1
12960    F8:2317             	_player_previous_axis:
12961    F8:2317             			ds	1
12962    F8:2318             	_player_counter_anim:
12963    F8:2318             			ds	1
12964    F8:2319             	_player_index_jump:
12965    F8:2319             			ds	1
12966    F8:231A             	_player_index_fall:
12967    F8:231A             			ds	1
12968    F8:231B             	_player_naked:
12969    F8:231B             			ds	1
12970    F8:231C             	_jump_ladder:
12971    F8:231C             			ds	1
12972    F8:231D             	_jump_max_index:
12973    F8:231D             			ds	1
12974    F8:231E             	_armor_level:
12975    F8:231E             			ds	1
12976    F8:231F             	_weapon_level:
12977    F8:231F             			ds	1
12978    F8:2320             	_life_amount:
12979    F8:2320             			ds	1
12980    F8:2321             	_key_amount:
12981    F8:2321             			ds	1
12982    F8:2322             	_potion_amount:
12983    F8:2322             			ds	1
12984    F8:2323             	_minutes:
12985    F8:2323             			ds	1
12986    F8:2324             	_seconds:
12987    F8:2324             			ds	1
12988    F8:2325             	_time_counter:
12989    F8:2325             			ds	1
12990    F8:2326             	_minutes_backup:
12991    F8:2326             			ds	1
12992    F8:2327             	_seconds_backup:
12993    F8:2327             			ds	1
12994    F8:2328             	_object_start_index:
12995    F8:2328             			ds	1
12996    F8:2329             	_level_object_number:
12997    F8:2329             			ds	1
12998    F8:232A             	_onscreen_object_number:
12999    F8:232A             			ds	1
13000    F8:232B             	_list_object_type:
13001    F8:232B             			ds	25
13002    F8:2344             	_list_object_state:
13003    F8:2344             			ds	25
13004    F8:235D             	_list_object_energy:
13005    F8:235D             			ds	25
13006    F8:2376             	_list_reward_type:
13007    F8:2376             			ds	25
13008    F8:238F             	_list_onscreen_object:
13009    F8:238F             			ds	8
13010    F8:2397             	_chest_start_index:
13011    F8:2397             			ds	1
13012    F8:2398             	_level_chest_number:
13013    F8:2398             			ds	1
13014    F8:2399             	_onscreen_chest_number:
13015    F8:2399             			ds	1
13016    F8:239A             	_list_chest_state:
13017    F8:239A             			ds	8
13018    F8:23A2             	_list_onscreen_chest:
13019    F8:23A2             			ds	8
13020    F8:23AA             	_npc_start_index:
13021    F8:23AA             			ds	1
13022    F8:23AB             	_level_npc_number:
13023    F8:23AB             			ds	1
13024    F8:23AC             	_onscreen_npc_number:
13025    F8:23AC             			ds	1
13026    F8:23AD             	_list_npc_type:
13027    F8:23AD             			ds	9
13028    F8:23B6             	_list_npc_state:
13029    F8:23B6             			ds	9
13030    F8:23BF             	_list_onscreen_npc:
13031    F8:23BF             			ds	9
13032    F8:23C8             	_index_x:
13033    F8:23C8             			ds	1
13034    F8:23C9             	_index_y:
13035    F8:23C9             			ds	1
13036    F8:23CA             	_item_index:
13037    F8:23CA             			ds	1
13038    F8:23CB             	_shop_phase:
13039    F8:23CB             			ds	1
13040    F8:23CC             	_shop_counter:
13041    F8:23CC             			ds	1
13042    F8:23CD             	_tilemap_mask:
13043    F8:23CD             			ds	256
13044    F8:24CD             	_player_pos_x:
13045    F8:24CD             			ds	2
13046    F8:24CF             	_player_pos_y:
13047    F8:24CF             			ds	2
13048    F8:24D1             	_camera_max_y_position:
13049    F8:24D1             			ds	2
13050    F8:24D3             	_camera_pos_x_backup:
13051    F8:24D3             			ds	2
13052    F8:24D5             	_camera_pos_y_backup:
13053    F8:24D5             			ds	2
13054    F8:24D7             	_list_object_x_pos:
13055    F8:24D7             			ds	50
13056    F8:2509             	_list_object_y_pos:
13057    F8:2509             			ds	50
13058    F8:253B             	_list_object_x_pos_ref:
13059    F8:253B             			ds	50
13060    F8:256D             	_list_object_y_pos_ref:
13061    F8:256D             			ds	50
13062    F8:259F             	_list_chest_x_pos:
13063    F8:259F             			ds	16
13064    F8:25AF             	_list_chest_y_pos:
13065    F8:25AF             			ds	16
13066    F8:25BF             	_list_chest_x_pos_ref:
13067    F8:25BF             			ds	16
13068    F8:25CF             	_list_chest_y_pos_ref:
13069    F8:25CF             			ds	16
13070    F8:25DF             	_list_npc_x_pos:
13071    F8:25DF             			ds	18
13072    F8:25F1             	_list_npc_y_pos:
13073    F8:25F1             			ds	18
13074    F8:2603             	_list_npc_x_pos_ref:
13075    F8:2603             			ds	18
13076    F8:2615             	_list_npc_y_pos_ref:
13077    F8:2615             			ds	18
13078    F8:2627             	_zenny_amount:
13079    F8:2627             			ds	2
13080    F8:2629             	_score:
13081    F8:2629             			ds	2
13082    F8:262B             	_shop_prices:
13083    F8:262B             			ds	20
13084    F8:263F             	_ptr_SHOP_ITEM_PRICES:
13085    F8:263F             			ds	2
13086                        	
13087                        	
13088                        	;0 error(s) in compilation
13089                        	;	literal pool:110
13090                        	;	constant pool:296
13091                        	;	global pool:512
13092                        	;	Macro pool:267
13093    F8:2641             	leaf_loc:
13094    F8:2641             			ds	4
13095    F8:2645             	__hide_LEVEL_SPRITES_end:
13096    F8:2645             	__scroll_object_end:
13097    F8:2645             	__scroll_chest_end:
13098    F8:2645             	__scroll_npc_end:
13099    F8:2645             	__check_TILE_DEPTH_end:
13100    F8:2645             	__check_BG_end:
13101    F8:2645             	__check_NPC_end:
13102    F8:2645             	__recenter_CAMERA_end:
13103    F8:2645             	__init_OBJECT_LV1_end:
13104    F8:2645             	__init_CHEST_LV1_end:
13105    F8:2645             	__init_NPC_LV1_end:
13106                        	
13107    F8:2645             	__bss_init:
13108                        	
13109    F8:2645             	__heap_start:
                             #[2]   "..\..\..\include\hucc\hucc-final.asm"
    1                        	; ***************************************************************************
    2                        	; ***************************************************************************
    3                        	;
    4                        	; hucc-final.asm
    5                        	;
    6                        	; PCEAS auto-includes this file at the end of every pass in HuCC or SDCC.
    7                        	;
    8                        	; Copyright John Brandwood 2024.
    9                        	;
   10                        	; Distributed under the Boost Software License, Version 1.0.
   11                        	; (See accompanying file LICENSE_1_0.txt or copy at
   12                        	;  http://www.boost.org/LICENSE_1_0.txt)
   13                        	;
   14                        	; ***************************************************************************
   15                        	; ***************************************************************************
   16                        	;
   17                        	; This is used to select which assembly-language library files to include in
   18                        	; a HuCC project, using labels defined in the compiler's header files.
   19                        	;
   20                        	; ***************************************************************************
   21                        	; ***************************************************************************
   22                        	
   23                        			; Allow projects to customize what is included at the end
   24                        			; of a pass without replacing the entire "hucc-final.asm".
   25                        	
   26               E309     			.code
   27               0000     			.bank	CORE_BANK
   28               E309     			.page	CORE_PAGE
   29                        	
                             #[3]   "..\..\..\include\hucc\hucc-final-extra.asm"
   30                        			include	"hucc-final-extra.asm"
    1                        	; ***************************************************************************
    2                        	; ***************************************************************************
    3                        	;
    4                        	; hucc-final-extra.asm
    5                        	;
    6                        	; hucc-final.asm includes this file at the end of every pass in HuCC or SDCC.
    7                        	;
    8                        	; Copyright John Brandwood 2024.
    9                        	;
   10                        	; Distributed under the Boost Software License, Version 1.0.
   11                        	; (See accompanying file LICENSE_1_0.txt or copy at
   12                        	;  http://www.boost.org/LICENSE_1_0.txt)
   13                        	;
   14                        	; ***************************************************************************
   15                        	; ***************************************************************************
   16                        	;
   17                        	; This is used to select which assembly-language library files to include in
   18                        	; a HuCC project, using labels defined in the compiler's header files.
   19                        	;
   20                        	; ***************************************************************************
   21                        	; ***************************************************************************
                             #[2]   "..\..\..\include\hucc\hucc-final.asm"
   31                        	
   32                        			; Libraries required for basic functionality.
   33                        	
   34               E309     			.code
   35               0000     			.bank	CORE_BANK
   36               E309     			.page	CORE_PAGE
   37                        	
                             #[3]   "..\..\..\include\hucc\common.asm"
   38                        			include	"common.asm"		; Common helpers.
    1                        	; ***************************************************************************
    2                        	; ***************************************************************************
    3                        	;
    4                        	; common.asm
    5                        	;
    6                        	; Small, generic, PCE subroutines that are commonly useful when developing.
    7                        	;
    8                        	; These should be located in permanently-accessible memory!
    9                        	;
   10                        	; Copyright John Brandwood 2021-2024.
   11                        	;
   12                        	; Distributed under the Boost Software License, Version 1.0.
   13                        	; (See accompanying file LICENSE_1_0.txt or copy at
   14                        	;  http://www.boost.org/LICENSE_1_0.txt)
   15                        	;
   16                        	; ***************************************************************************
   17                        	; ***************************************************************************
   18                        	
   19                        	
   20                        	
   21                        	; ***************************************************************************
   22                        	; ***************************************************************************
   23                        	;
   24                        	; Wait for the next VBLANK IRQ.
   25                        	;
   26                        	
   27    00:E309  AD 41 22   	wait_vsync:	lda	irq_cnt			; System Card variable, changed
   28    00:E30C  CD 41 22   	.loop:		cmp	irq_cnt			; every VBLANK interrupt.
   29    00:E30F  F0 FB      			beq	.loop
   30               0001     		.ifdef	HUCC
   31    00:E311  8D EB 22   			sta	old_cnt			; Remember the frame count.
   32                        		.endif
   33    00:E314  60         			rts
   34                        	
   35                        	
   36                        	
   37                        	; ***************************************************************************
   38                        	; ***************************************************************************
   39                        	;
   40                        	; Delay for the next Y VBLANK IRQs.
   41                        	;
   42                        	
   43               0001     		.ifdef	HUCC
   44    00:E315             	_vsync		.alias	wait_vsync
   45                        	
   46    00:E315  AD 41 22   	_vsync.1:	lda	irq_cnt			; HuCC's vsync(n) was defined
   47    00:E318  38         			sec				; as frames from the previous
   48    00:E319  ED EB 22   			sbc	old_cnt			; vsync() call, 1 to 255.
   49    00:E31C  38         			sec
   50    00:E31D  E5 F8      			sbc	<_al
   51    00:E31F  90 02      			bcc	!+
   52    00:E321  A9 FF      			lda	#$FF
   53    00:E323  49 FF      	!:		eor	#$FF
   54    00:E325  1A         			inc	a
   55    00:E326  A8         			tay
   56                        		.endif
   57                        	
   58    00:E327  44 E0      	wait_nvsync:	bsr	wait_vsync		; # of VBLANK IRQs to wait in
   59    00:E329  88         			dey				; the Y register.
   60    00:E32A  D0 FB      			bne	wait_nvsync
   61    00:E32C  60         			rts
   62                        	
   63                        	
   64                        	
   65               0000     		.ifndef	HUCC
  101                        		.endif
  102                        	
  103                        	
  104                        	
  105                        	; ***************************************************************************
  106                        	; ***************************************************************************
  107                        	;
  108                        	; Map the _bp data far-pointer into MPR3 (& MPR4).
  109                        	;
  110                        	; Because the 16KB RAM region at $2000-$5FFF is composed of two separate
  111                        	; banks, with the 2nd bank having no specific relation to the 1st, there
  112                        	; is no way to deal with a bank-increment, so do not map that region.
  113                        	;
  114                        	; N.B. Library code relies on this preserving X and V!
  115                        	;
  116                        	
  117    00:E32D  98         	map_bp_to_mpr3:	tya				; Put bank into MPR3.
  118    00:E32E  F0 0A      			beq	!+
  119    00:E330  53 08      			tam3
  120    00:E332  A5 ED      			lda.h	<_bp			; Do not remap a ptr to RAM,
  121    00:E334  29 1F      			and	#$1F			; Remap ptr to MPR3.
  122    00:E336  09 60      			ora	#$60
  123    00:E338  85 ED      			sta.h	<_bp
  124    00:E33A  60         	!:		rts
  125                        	
  126    00:E33B  98         	map_bp_to_mpr34:tya				; Put bank into MPR3.
  127    00:E33C  F0 0D      			beq	!+
  128    00:E33E  53 08      			tam3
  129    00:E340  1A         			inc	a			; Put next into MPR4.
  130    00:E341  53 10      			tam4
  131    00:E343  A5 ED      			lda.h	<_bp			; Do not remap a ptr to RAM,
  132    00:E345  29 1F      			and	#$1F			; Remap ptr to MPR3.
  133    00:E347  09 60      			ora	#$60
  134    00:E349  85 ED      			sta.h	<_bp
  135    00:E34B  60         	!:		rts
  136                        	
  137                        	
  138                        	
  139                        	; ***************************************************************************
  140                        	; ***************************************************************************
  141                        	;
  142                        	; Increment the hi-byte of _bp and change TMA3 if necessary.
  143                        	;
  144                        	; N.B. Library code relies on this preserving A,X,Y and V!
  145                        	;
  146                        	
  147    00:E34C  E6 ED      	inc.h_bp_mpr3:	inc.h	<_bp			; Increment hi-byte of _bp.
  148    00:E34E  10 0B      			bpl	!+			; OK if within MPR0-MPR3.
  149    00:E350  48         			pha				; Increment the bank in MPR3,
  150    00:E351  43 08      			tma3				; usually when pointer moves
  151    00:E353  1A         			inc	a			; from $7FFF -> $8000.
  152    00:E354  53 08      			tam3
  153    00:E356  A9 60      			lda	#$60
  154    00:E358  85 ED      			sta.h	<_bp
  155    00:E35A  68         			pla
  156    00:E35B  60         	!:		rts
  157                        	
  158                        	
  159                        	
  160                        	; ***************************************************************************
  161                        	; ***************************************************************************
  162                        	;
  163                        	; Increment the hi-byte of _bp and change TMA3 and TMA4 if necessary.
  164                        	;
  165                        	; N.B. Library code relies on this preserving A,X,Y and V!
  166                        	;
  167                        	
  168    00:E35C  E6 ED      	inc.h_bp_mpr34:	inc.h	<_bp			; Increment hi-byte of _bp.
  169    00:E35E  10 0D      			bpl	!+			; OK if within MPR0-MPR3.
  170    00:E360  48         			pha				; Increment the bank in MPR3,
  171    00:E361  43 10      			tma4				; usually when pointer moves
  172    00:E363  53 08      			tam3				; from $7FFF -> $8000.
  173    00:E365  1A         			inc	a
  174    00:E366  53 10      			tam4
  175    00:E368  A9 60      			lda	#$60
  176    00:E36A  85 ED      			sta.h	<_bp
  177    00:E36C  68         			pla
  178    00:E36D  60         	!:		rts
  179                        	
  180                        	
  181                        	
  182                        	; ***************************************************************************
  183                        	; ***************************************************************************
  184                        	;
  185                        	; Put the _di data pointer into the VDC's MARR or MAWR register.
  186                        	;
  187                        	; N.B. Library code relies on this preserving Y!
  188                        	;
  189                        	
  190               0001     		.if	SUPPORT_SGX
  191    00:E36E  A2 10      	sgx_di_to_marr:	ldx	#SGX_VDC_OFFSET		; Offset to SGX VDC.
  192    00:E370  F0         			db	$F0			; Turn "clx" into a "beq".
  193                        		.endif
  194                        	
  195    00:E371  82         	vdc_di_to_marr:	clx				; Offset to PCE VDC.
  196                        	
  197    00:E372  A9 01      	set_di_to_marr	lda	#VDC_MARR		; Set VDC or SGX destination
  198    00:E374  95 F7      			sta	<vdc_reg, x		; address.
  199    00:E376  9D 00 02   			sta	VDC_AR, x
  200    00:E379  80 09      			bra	!+
  201                        	
  202               0001     		.if	SUPPORT_SGX
  203    00:E37B  A2 10      	sgx_di_to_mawr:	ldx	#SGX_VDC_OFFSET		; Offset to SGX VDC.
  204    00:E37D  F0         			db	$F0			; Turn "clx" into a "beq".
  205                        		.endif
  206                        	
  207    00:E37E  82         	vdc_di_to_mawr:	clx				; Offset to PCE VDC.
  208                        	
  209    00:E37F             	set_di_to_mawr;	lda	#VDC_MAWR		; Set VDC or SGX destination
  210    00:E37F  74 F7      			stz	<vdc_reg, x		; address.
  211    00:E381  9E 00 02   			stz	VDC_AR, x
  212                        	
  213    00:E384  A5 F0      	!:		lda	<_di + 0
  214    00:E386  9D 02 02   			sta	VDC_DL, x
  215    00:E389  A5 F1      			lda	<_di + 1
  216    00:E38B  9D 03 02   			sta	VDC_DH, x
  217                        	
  218    00:E38E  A9 02      			lda	#VDC_VWR		; Select the VRR/VWR data
  219    00:E390  95 F7      			sta	<vdc_reg, x		; register.
  220    00:E392  9D 00 02   			sta	VDC_AR, x
  221    00:E395  60         			rts
  222                        	
  223                        	
  224                        	
  225                        	; ***************************************************************************
  226                        	; ***************************************************************************
  227                        	;
  228                        	; Increment the hi-byte of _di and change TMA4 if necessary.
  229                        	;
  230                        	
  231               0000     		.if	0				; Save memory, for now.
  250                        		.endif
  251                        	
  252                        	
  253                        	
  254                        	; ***************************************************************************
  255                        	; ***************************************************************************
  256                        	;
  257                        	; Far-call a function in another bank.
  258                        	;
  259                        	; This is a potential alternative procedure call trampoline that uses only 10
  260                        	; bytes of common memory per bank of procedures, instead of 10 bytes for each
  261                        	; individual procedure call, BUT it uses the X register as a procedure-index,
  262                        	; and it needs a table of addresses at the end of every procedure bank.
  263                        	;
  264                        	; To use this ...
  265                        	;
  266                        	;  ldx #procedure-index
  267                        	;  jsr far_call_nn
  268                        	;
  269                        	; The called .PROC routine must exit with "jmp leave_proc" and not "rts".
  270                        	;
  271                        	; leave_proc:	pla
  272                        	;		tam6
  273                        	;		tya
  274                        	;		rts
  275                        	;
  276                        	; N.B. This costs 21 cycles vs 18 for the .newproc trampoline code (when you
  277                        	;      exclude preserving YA in zero-page).
  278                        	;
  279                        	; N.B. This was written as an excerise, and definitely not for HuC!
  280                        	;
  281                        	
  282               0000     		.if	0
  295                        		.endif					; 21
                             #[2]   "..\..\..\include\hucc\hucc-final.asm"
                             #[3]   "..\..\..\include\hucc\vce.asm"
   39                        			include	"vce.asm"		; Useful VCE routines.
    1                        	; ***************************************************************************
    2                        	; ***************************************************************************
    3                        	;
    4                        	; vce.asm
    5                        	;
    6                        	; Useful routines for operating the HuC6260 Video Color Encoder
    7                        	;
    8                        	; These should be located in permanently-accessible memory!
    9                        	;
   10                        	; Copyright John Brandwood 2021-2025.
   11                        	;
   12                        	; Distributed under the Boost Software License, Version 1.0.
   13                        	; (See accompanying file LICENSE_1_0.txt or copy at
   14                        	;  http://www.boost.org/LICENSE_1_0.txt)
   15                        	;
   16                        	; ***************************************************************************
   17                        	; ***************************************************************************
   18                        	
   19                        	;
   20                        	; Configure Library ...
   21                        	;
   22                        	
   23               0000     		.ifndef VCE_SPLIT_CROSS
   25                        		.endif
   26                        	
   27                        	
   28                        	
   29                        	; ***************************************************************************
   30                        	; ***************************************************************************
   31                        	;
   32                        	; xfer_palettes - Update the VCE with the queued palettes changes.
   33                        	;
   34                        	; This is normally called in a developer's vsync_hook handler, but it can
   35                        	; be called manually as long as it will not also be called in an interrupt.
   36                        	;
   37                        	; The queued transfers are split into 32-byte chunks so that an HSYNC and/or
   38                        	; TIMER IRQ is not delayed for too long during the VBLANK.
   39                        	;
   40                        	
   41    00:E396  A9 80      	xfer_palettes:	lda	#$80			; Acquire color mutex to avoid
   42    00:E398  0C 45 26   			tsb	color_mutex		; conflict with a delayed VBL.
   43    00:E39B  30 5F      			bmi	.busy
   44                        	
   45    00:E39D  AC 46 26   			ldy	color_queue_r		; Are there any palette xfers
   46    00:E3A0  CC 47 26   			cpy	color_queue_w		; queued up?
   47    00:E3A3  F0 54      			beq	.exit
   48                        	
   49    00:E3A5  08         			php				; Enable interrupts so that an
   50    00:E3A6  58         			cli				; HSYNC or TIMER IRQ can occur.
   51                        	
   52    00:E3A7  43 08      			tma3				; Preserve MPR3 & MPR4 because
   53    00:E3A9  48         			pha				; this normally runs in the
   54    00:E3AA  43 10      			tma4				; VBLANK IRQ.
   55    00:E3AC  48         			pha
   56                        	
   57               0001     		.if	!CDROM
   58    00:E3AD  73 02 E4 86			tii	.tia_func, color_tia, 8 ; Copy TIA to RAM.
         00:E3B1  22 08 00    
   59                        		.endif
   60                        	
   61    00:E3B4  B9 48 26   	.next_item:	lda	color_index, y		; Get the next set of palettes
   62    00:E3B7  0A         			asl	a			; from the queue.
   63    00:E3B8  0A         			asl	a
   64    00:E3B9  0A         			asl	a
   65    00:E3BA  0A         			asl	a
   66    00:E3BB  8D 02 04   			sta	VCE_CTA + 0
   67    00:E3BE  62         			cla
   68    00:E3BF  2A         			rol	a
   69    00:E3C0  8D 03 04   			sta	VCE_CTA + 1
   70                        	
   71    00:E3C3  BE 50 26   			ldx	color_count,y		; How many palettes to xfer?
   72                        	
   73    00:E3C6  B9 68 26   			lda	color_bank, y		; Map data into MPR3 & MPR4.
   74    00:E3C9  53 08      			tam3
   75    00:E3CB  1A         			inc	a
   76    00:E3CC  53 10      			tam4
   77    00:E3CE  B9 60 26   			lda	color_addr_h, y
   78    00:E3D1  8D 88 22   			sta	.ram_tia + 2
   79    00:E3D4  B9 58 26   			lda	color_addr_l, y
   80    00:E3D7  8D 87 22   	.palette_loop:	sta	.ram_tia + 1
   81                        	
   82               0000     		.if	CDROM
   84                        		.else
   85    00:E3DA  20 86 22   			jsr	.ram_tia		; Copy 32-bytes to the VCE.
   86                        		.endif
   87                        	
   88    00:E3DD  18         			clc				; Increment the data ptr to
   89    00:E3DE  69 20      			adc	#32			; the next 32-byte palette.
   90    00:E3E0  B0 1B      			bcs	.next_page
   91                        	
   92    00:E3E2  CA         	.next_palette:	dex				; Any palettes left to xfer?
   93    00:E3E3  D0 F2      			bne	.palette_loop
   94                        	
   95    00:E3E5  C8         			iny				; Increment the queue index.
   96    00:E3E6  98         			tya
   97    00:E3E7  29 07      			and	#7
   98    00:E3E9  A8         			tay
   99                        	
  100    00:E3EA  CC 47 26   			cpy	color_queue_w		; Any more items in the queue?
  101    00:E3ED  D0 C5      			bne	.next_item
  102    00:E3EF  8C 46 26   			sty	color_queue_r		; Signal the queue is empty.
  103                        	
  104    00:E3F2  68         			pla				; Restore MPR3 & MPR4.
  105    00:E3F3  53 10      			tam4
  106    00:E3F5  68         			pla
  107    00:E3F6  53 08      			tam3
  108                        	
  109    00:E3F8  28         			plp				; Restore interrupt state.
  110                        	
  111    00:E3F9  9C 45 26   	.exit:		stz	color_mutex		; Release color mutex.
  112                        	
  113    00:E3FC  60         	.busy:		rts
  114                        	
  115    00:E3FD  EE 88 22   	.next_page:	inc	.ram_tia + 2
  116    00:E400  80 E0      			bra	.next_palette
  117                        	
  118               0001     		.if	!CDROM
  119               2286     	.ram_tia	=	color_tia		; Use a TIA in RAM.
  120                        	
  121    00:E402  E3 00 00 04	.tia_func:	tia	0, VCE_CTW, 32
         00:E406  04 20 00    
  122    00:E409  60         			rts
  123                        		.endif	!CDROM
  124                        	
  125               2645     			.bss
  126                        	
  127    F8:2645             	color_mutex:	ds	1			; Mutex for VCE changes.
  128    F8:2646             	color_queue_r:	ds	1			; Ring buffer read index.
  129    F8:2647             	color_queue_w:	ds	1			; Ring buffer write index.
  130    F8:2648             	color_index:	ds	8			; Ring buffer - Palette index.
  131    F8:2650             	color_count:	ds	8			; Ring buffer - Palette count.
  132    F8:2658             	color_addr_l:	ds	8			; Ring buffer - Data Ptr (lo).
  133    F8:2660             	color_addr_h:	ds	8			; Ring buffer - Data Ptr (hi).
  134    F8:2668             	color_bank:	ds	8			; Ring buffer - Data Ptr (bank).
  135                        	
  136               E40A     			.code
  137                        	
  138                        	
  139                        	
  140                        	; ***************************************************************************
  141                        	; ***************************************************************************
  142                        	;
  143                        	; load_palettes - Queue a set of palettes to upload to the VCE next VBLANK.
  144                        	;
  145                        	; Args: _al = Palette index (0..15 for BG, 16..31 for SPR).
  146                        	; Args: _ah = Palette count (1..32).
  147                        	; Args: _bp = Pointer to palette data.
  148                        	; Args:   Y = Bank to map into MPR3 & MPR4, or zero to leave unchanged.
  149                        	;
  150                        	; N.B. Y==0 is only useful if the palette data is permanently mapped!
  151                        	;
  152                        	
  153                        	load_palettes	.proc
  179                        			.endp
  180                        	
  181                        	
  182                        	
  183                        	; ***************************************************************************
  184                        	; ***************************************************************************
  185                        	;
  186                        	; clear_vce - Clear all 512 of the VCE's palette entries.
  187                        	;
  188                        	
  189    11:D453             	clear_vce	.proc
  190                        	
  191    11:D453  08         			php				; Disable interrupts to avoid
  192    11:D454  78         			sei				; VBLANK palette upload.
  193    11:D455  C2         			cly
  194    11:D456  9C 02 04   			stz	VCE_CTA+0		; Set VCE write address.
  195    11:D459  9C 03 04   			stz	VCE_CTA+1
  196    11:D45C  9C 04 04   	.loop:		stz	VCE_CTW+0		; Set lo-byte of color.
  197    11:D45F  9C 05 04   			stz	VCE_CTW+1		; Write 1 color value.
  198    11:D462  9C 04 04   			stz	VCE_CTW+0		; Set lo-byte of color.
  199    11:D465  9C 05 04   			stz	VCE_CTW+1		; Write 1 color value.
  200    11:D468  88         			dey
  201    11:D469  D0 F1      			bne	.loop
  202    11:D46B  28         			plp
  203                        	
  204                        			leave				; All done, phew!
         11:D46C  4C EF FF   			jmp	leave_proc
  205                        	
  206                        			.endp
  207                        	
  208               0001     		.ifdef	HUCC
  209    00:E40A             			.alias	_clear_palette		= clear_vce
  210                        		.endif
  211                        	
  212                        	
  213                        	
  214                        	; ***************************************************************************
  215                        	; ***************************************************************************
  216                        	;
  217                        	; read_palettes - Read palettes from the VCE into a buffer in RAM.
  218                        	;
  219                        	; Args: _al = Palette index (0..15 for BG, 16..31 for SPR).
  220                        	; Args: _ah = Palette count (1..32).
  221                        	; Args: _di = Pointer to palette data destination in RAM.
  222                        	;
  223                        	; The transfer is split into 32-byte chunks so that an HSYNC and/or TIMER
  224                        	; IRQ is not delayed for too long while executing.
  225                        	;
  226                        	
  227                        	read_palettes	.proc
  281                        			.endp
  282                        	
  283               0001     		.ifdef	HUCC
  284    00:E40A             			.alias	_read_palette.3		= read_palettes
  285                        		.endif
  286                        	
  287                        	
  288                        	
  289                        	vce_fade_funcs	.procgroup
  516                        			.endprocgroup
  517                        	
  518                        	
  519                        	
  520                        	; ***************************************************************************
  521                        	; ***************************************************************************
  522                        	;
  523                        	; cross_fade_to - Cross fade a palette in RAM towards a reference palette.
  524                        	;
  525                        	; Args: _al = Number of colors (1..256).
  526                        	; Args: _di = Pointer to faded palette destination in RAM.
  527                        	; Args: _bp = Pointer to reference palette data.
  528                        	; Args:   Y = Bank to map into MPR3 & MPR4, or zero to leave unchanged.
  529                        	;
  530                        	; N.B. Y==0 is only useful if the reference palette data is already mapped!
  531                        	;
  532                        	; N.B. This only updates the palette in RAM by 1 RGB step, so it will need
  533                        	;      to be called 7 times to guarantee that you've reached the target.
  534                        	;
  535                        	
  536                        	cross_fade_to	.proc
  658                        			.endp
                             #[2]   "..\..\..\include\hucc\hucc-final.asm"
                             #[3]   "..\..\..\include\hucc\vdc.asm"
   40                        			include	"vdc.asm"		; Useful VDC routines.
    1                        	; ***************************************************************************
    2                        	; ***************************************************************************
    3                        	;
    4                        	; vdc.asm
    5                        	;
    6                        	; Useful routines for operating the HuC6270 Video Display Controller.
    7                        	;
    8                        	; These should be located in permanently-accessible memory!
    9                        	;
   10                        	; Copyright John Brandwood 2021-2025.
   11                        	;
   12                        	; Distributed under the Boost Software License, Version 1.0.
   13                        	; (See accompanying file LICENSE_1_0.txt or copy at
   14                        	;  http://www.boost.org/LICENSE_1_0.txt)
   15                        	;
   16                        	; ***************************************************************************
   17                        	; ***************************************************************************
   18                        	
   19                        	;
   20                        	; Include dependancies ...
   21                        	;
   22                        	
   23                        			include "common.asm"		; Common helpers.
   24                        			include "vce.asm"		; Useful VCE routines.
   25                        	
   26                        	;
   27                        	; Choose how much to transfer to VRAM in a single chunk, normally 16-bytes.
   28                        	;
   29                        	; The cycle timings for a TIA-to-VRAM depend upon how the VDC's MWR CPU slots
   30                        	; line up to the CPU's writes, and how long the VDC has to halt the CPU while
   31                        	; it fetches the next scanline's sprite data.
   32                        	;
   33                        	; These cycle timings are for 0 sprites (best) and 16 sprites (worst) ...
   34                        	;
   35                        	; 32-byte TIA takes 270..364 cycles in 5MHz, 242..312 cycles in 7MHz. (8.44 cycles-per-byte best-case at 5MHz.)
   36                        	; 24-byte TIA takes 210..298 cycles in 5MHz, 186..256 cycles in 7MHz. (8.75 cycles-per-byte best-case at 5MHz.)
   37                        	; 16-byte TIA takes 142..234 cycles in 5MHz, 128..200 cycles in 7MHz. (8.88 cycles-per-byte best-case at 5MHz.)
   38                        	;
   39                        	; If a user wishes to be able to put RCR interrupts one-line-after-another,
   40                        	; then it is only safe to use 32-byte chunks if there are no TIMER or IRQ2
   41                        	; interrupts ... which is almost-impossible to rely on in library code!
   42                        	;
   43                        	
   44               0000     		.ifndef	VRAM_XFER_SIZE
   46                        		.endif
   47                        	
   48                        	;
   49                        	; Enable BG & SPR layers, and RCR interrupt.
   50                        	;
   51                        	
   52    00:E40A  A9 04      	set_rcron:	lda	#$04			; Enable RCR interrupt.
   53    00:E40C  80 0A      			bra	!+
   54                        	
   55    00:E40E  A9 80      	set_bgon:	lda	#$80			; Enable BG layer.
   56    00:E410  80 06      			bra	!+
   57                        	
   58    00:E412  A9 40      	set_spron:	lda	#$40			; Enable SPR layer.
   59    00:E414  80 02      			bra	!+
   60                        	
   61    00:E416  A9 C0      	set_dspon:	lda	#$C0			; Enable BG & SPR layers.
   62                        	
   63    00:E418  04 F3      	!:		tsb	<vdc_crl		; These take effect when
   64               0001     		.if	SUPPORT_SGX			; the next VBLANK occurs.
   65    00:E41A  04 03      			tsb	<sgx_crl
   66                        		.endif
   67    00:E41C  60         			rts
   68                        	
   69                        	;
   70                        	; Disable BG & SPR layers, and RCR interrupt.
   71                        	;
   72                        	
   73    00:E41D  A9 04      	set_rcroff:	lda	#$04			; Disable RCR interrupt.
   74    00:E41F  80 0A      			bra	!+
   75                        	
   76    00:E421  A9 80      	set_bgoff:	lda	#$80			; Disable BG layer.
   77    00:E423  80 06      			bra	!+
   78                        	
   79    00:E425  A9 40      	set_sproff:	lda	#$40			; Disable SPR layer.
   80    00:E427  80 02      			bra	!+
   81                        	
   82    00:E429  A9 C0      	set_dspoff:	lda	#$C0			; Disable BG & SPR layers.
   83                        	
   84    00:E42B  14 F3      	!:		trb	<vdc_crl		; These take effect when
   85               0001     		.if	SUPPORT_SGX			; the next VBLANK occurs.
   86    00:E42D  14 03      			trb	<sgx_crl
   87                        		.endif
   88    00:E42F  60         			rts
   89                        	
   90                        	
   91                        	
   92                        	; ***************************************************************************
   93                        	; ***************************************************************************
   94                        	;
   95                        	; Put the _di data pointer into the VDC's MARR or MAWR register.
   96                        	;
   97                        	; N.B. Library code relies on this preserving Y!
   98                        	;
   99                        	; Args: _di + 0 = BAT X coordinate.
  100                        	; Args: _di + 1 = BAT Y coordinate.
  101                        	;
  102                        	; Here because it relies on the "vdc_bat_width" that is defined in this file.
  103                        	;
  104                        	
  105               0001     		.if	SUPPORT_SGX
  106    00:E430  A2 10      	sgx_di_xy_marr:	ldx	#SGX_VDC_OFFSET		; Offset to SGX VDC.
  107    00:E432  F0         			db	$F0			; Turn "clx" into a "beq".
  108                        		.endif
  109                        	
  110    00:E433  82         	vdc_di_xy_marr:	clx				; Offset to PCE VDC.
  111                        	
  112    00:E434  62         	set_di_xy_mawr:	cla
  113    00:E435  3C 70 26   			bit	vdc_bat_width, x	; Set by set_bat_size().
  114    00:E438  30 08      			bmi	.w128
  115    00:E43A  70 03      			bvs	.w64
  116    00:E43C  46 F1      	.w32:		lsr.h	<_di
  117    00:E43E  6A         			ror	a
  118    00:E43F  46 F1      	.w64:		lsr.h	<_di
  119    00:E441  6A         			ror	a
  120    00:E442  46 F1      	.w128:		lsr.h	<_di
  121    00:E444  6A         			ror	a
  122    00:E445  05 F0      			ora.l	<_di
  123    00:E447  85 F0      			sta.l	<_di
  124    00:E449  4C 7F E3   			jmp	set_di_to_mawr		; In "common.asm".
  125                        	
  126                        	
  127                        	
  128    11:D1D4             	vdc_clear_vram	.procgroup			; These routines share code!
  129                        	
  130                        	; ***************************************************************************
  131                        	; ***************************************************************************
  132                        	;
  133                        	; clear_vram_sgx - Clear all of VRAM in the SGX VDC.
  134                        	; clear_vram_vdc - Clear all of VRAM in the PCE VDC.
  135                        	;
  136                        	; Args: _ax = word value to write to the BAT.
  137                        	; Args: _bl = hi-byte of size of BAT (# of words).
  138                        	;
  139                        	
  140               0001     		.if	SUPPORT_SGX
  141    11:D1D4             	clear_vram_sgx	.proc
  142                        	
  143    11:D1D4  A2 10      			ldx	#SGX_VDC_OFFSET		; Offset to SGX VDC.
  144    11:D1D6  F0         			db	$F0			; Turn "clx" into a "beq".
  145                        	
  146    11:D1D7             			.ref	clear_vram_vdc		; Need clear_vram_vdc
  147                        			.endp
  148                        		.endif
  149                        	
  150    11:D1D7             	clear_vram_vdc	.proc
  151                        	
  152    11:D1D7  82         			clx				; Offset to PCE VDC.
  153                        	
  154    11:D1D8  20 DD FD   	clear_vram_x:	call	clear_bat_x		; Clear the BAT.
  155                        	
  156    11:D1DB  A9 80      			lda	#$80			; Xvert hi-byte of # words
  157    11:D1DD  38         			sec				; in screen to loop count.
  158    11:D1DE  E5 FA      			sbc	<_bl
  159    11:D1E0  4A         			lsr	a
  160                        	
  161                        	;		cly				; Clear the rest of VRAM.
  162    11:D1E1  9E 02 02   			stz	VDC_DL, x
  163    11:D1E4  9E 03 02   	.clr_loop:	stz	VDC_DH, x		; Seperate writes to minimize
  164    11:D1E7  88         			dey				; VDC MWR penalty.
  165    11:D1E8  9E 03 02   			stz	VDC_DH, x
  166    11:D1EB  D0 F7      			bne	.clr_loop
  167    11:D1ED  3A         			dec	a
  168    11:D1EE  D0 F4      			bne	.clr_loop
  169                        	
  170                        			leave				; All done, phew!
         11:D1F0  4C EF FF   			jmp	leave_proc
  171                        	
  172                        			.endp
  173                        	
  174                        	
  175                        	
  176                        	; ***************************************************************************
  177                        	; ***************************************************************************
  178                        	;
  179                        	; clear_bat_sgx - Clear the BAT in the SGX VDC.
  180                        	; clear_bat_vdc - Clear the BAT in the PCE VDC.
  181                        	;
  182                        	; Args: _ax = word value to write to the BAT.
  183                        	; Args: _bl = hi-byte of size of BAT (# of words).
  184                        	;
  185                        	
  186               0001     		.if	SUPPORT_SGX
  187                        	clear_bat_sgx	.proc
  193                        			.endp
  194                        		.endif
  195                        	
  196    11:D1F3             	clear_bat_vdc	.proc
  197                        	
  198    11:D1F3  82         			clx				; Offset to PCE VDC.
  199                        	
  200    11:D1F4             			.ref	clear_bat_x		; Need clear_bat_x
  201                        			.endp
  202                        	
  203    11:D1F4             	clear_bat_x	.proc				; HuCC uses this entry point.
  204                        	
  205    11:D1F4  64 F0      			stz	<_di + 0		; Set VDC or SGX destination
  206    11:D1F6  64 F1      			stz	<_di + 1		; address.
  207    11:D1F8  20 7F E3   			jsr	set_di_to_mawr
  208                        	
  209    11:D1FB  A5 FA      			lda	<_bl			; Xvert hi-byte of # words
  210    11:D1FD  4A         			lsr	a			; in screen to loop count.
  211                        	
  212    11:D1FE  C2         			cly
  213    11:D1FF  48         	.bat_loop:	pha
  214    11:D200  A5 F8      			lda	<_ax + 0
  215    11:D202  9D 02 02   			sta	VDC_DL, x
  216    11:D205  A5 F9      			lda	<_ax + 1
  217    11:D207  9D 03 02   	.bat_pair:	sta	VDC_DH, x		; Seperate writes to minimize
  218    11:D20A  88         			dey				; VDC MWR penalty.
  219    11:D20B  9D 03 02   			sta	VDC_DH, x
  220    11:D20E  D0 F7      			bne	.bat_pair
  221                        	
  222    11:D210  68         			pla
  223    11:D211  3A         			dec	a
  224    11:D212  D0 EB      			bne	.bat_loop
  225                        	
  226                        			leave
         11:D214  4C EF FF   			jmp	leave_proc
  227                        	
  228                        			.endp
  229                        	
  230                        			.endprocgroup
  231                        	
  232                        	;
  233                        	;
  234                        	;
  235                        	
  236    02:DF04             	vdc_set_mode	.procgroup			; These routines share code!
  237                        	
  238                        	; ***************************************************************************
  239                        	; ***************************************************************************
  240                        	;
  241                        	; set_mode_sgx - Set video hardware registers from a data table.
  242                        	; set_mode_vdc - Set video hardware registers from a data table.
  243                        	;
  244                        	; Args: _bp, Y = _farptr to data table mapped into MPR3 & MPR4.
  245                        	;
  246                        	
  247               0001     		.if	SUPPORT_SGX
  248    02:DF04             	set_mode_sgx	.proc
  249                        	
  250    02:DF04  A2 10      			ldx	#SGX_VDC_OFFSET		; Offset to SGX VDC.
  251    02:DF06  F0         			db	$F0			; Turn "clx" into a "beq".
  252                        	
  253                        			.endp
  254                        		.endif
  255                        	
  256    02:DF07             	set_mode_vdc	.proc
  257                        	
  258    02:DF07  82         			clx				; Offset to PCE VDC.
  259                        	
  260    02:DF08  F7 F8      			smb7	<_al			; Signal no set_bat_size() yet.
  261                        	
  262    02:DF0A  43 08      			tma3				; Preserve MPR3.
  263    02:DF0C  48         			pha
  264    02:DF0D  43 10      			tma4				; Preserve MPR4.
  265    02:DF0F  48         			pha
  266                        	
  267    02:DF10  20 3B E3   			jsr	map_bp_to_mpr34		; Map data to MPR3 & MPR4.
  268                        	
  269    02:DF13  08         			php				; Disable interrupts.
  270    02:DF14  78         			sei
  271                        	
  272    02:DF15  C2         			cly				; Table size is < 256 bytes.
  273                        	
  274    02:DF16  B1 EC      	.loop:		lda	[_bp], y		; Get the register #, +ve for
  275    02:DF18  F0 46      			beq	.done			; VDC, -128 for VCE_CR.
  276    02:DF1A  10 0C      			bpl	.set_vdc_reg
  277                        	
  278                        			; Set the VCE_CR register.
  279                        	
  280    02:DF1C  C8         	.set_vce_cr:	iny
  281                        	
  282    02:DF1D  B1 EC      			lda	[_bp], y		; Get lo-byte of register.
  283    02:DF1F  C8         			iny
  284    02:DF20  8D 44 22   			sta	vce_cr			; No SGX shadow for this!
  285    02:DF23  8D 00 04   			sta	VCE_CR			; Set the VCE clock speed.
  286    02:DF26  80 EE      			bra	.loop			; Do not set VDC_MWR reg bits!
  287                        	
  288                        			; Set a VDC register.
  289                        	
  290    02:DF28  C8         	.set_vdc_reg:	iny
  291    02:DF29  9D 00 02   			sta	VDC_AR, x		; Set which VDC register.
  292                        	
  293    02:DF2C  C9 05      			cmp	#VDC_CR			; CS if VDC_CR or higher.
  294    02:DF2E  F0 14      			beq	.skip_cc
  295    02:DF30  18         			clc				; CC if not VDC_CR.
  296                        	
  297    02:DF31  49 09      			eor	#VDC_MWR		; Check if this the VDC_MWR
  298    02:DF33  D0 0F      			bne	.skip_cc		; without changing CC.
  299                        	
  300    02:DF35  B1 EC      			lda	[_bp], y		; Remember the BAT size so that
  301    02:DF37  8D 42 22   			sta	vdc_mwr			; set_bat_size() can be called.
  302    02:DF3A  4A         			lsr	a
  303    02:DF3B  4A         			lsr	a
  304    02:DF3C  4A         			lsr	a
  305    02:DF3D  4A         			lsr	a
  306    02:DF3E  85 F8      			sta	<_al
  307    02:DF40  C8         			iny
  308    02:DF41  C8         			iny
  309    02:DF42  80 D2      			bra	.loop
  310                        	
  311    02:DF44  B1 EC      	.skip_cc:	lda	[_bp], y		; Get lo-byte of register.
  312    02:DF46  C8         			iny
  313    02:DF47  90 08      			bcc	.not_vdc_cr
  314                        	
  315               0001     		.if	SUPPORT_SGX
  316    02:DF49  E0 00      			cpx	#0			; Writing to the VDC or SGX?
  317    02:DF4B  F0 02      			beq	.save_crl
  318    02:DF4D  29 F7      			and	#$F7			; We only need 1 vblank IRQ!
  319                        		.endif
  320                        	
  321    02:DF4F  95 F3      	.save_crl:	sta	<vdc_crl, x		; Save VDC_CR shadow register.
  322                        	
  323    02:DF51  9D 02 02   	.not_vdc_cr:	sta	VDC_DL, x		; Write to VDC.
  324                        	
  325    02:DF54  B1 EC      			lda	[_bp], y		; Get hi-byte of register.
  326    02:DF56  C8         			iny
  327    02:DF57  9D 03 02   			sta	VDC_DH, x
  328    02:DF5A  90 BA      			bcc	.loop			; Next register, please!
  329                        	
  330    02:DF5C  95 F4      			sta	<vdc_crh, x		; Save VDC_CR shadow register.
  331                        	
  332    02:DF5E  80 B6      			bra	.loop			; Next register, please!
  333                        	
  334                        			; All registers set!
  335                        	
  336    02:DF60  A9 02      	.done:		lda	#VDC_VWR		; Leave with VDC_VWR set.
  337    02:DF62  95 F7      			sta	<vdc_reg, x
  338                        	;		lda	<vdc_reg, x		; Restore previous VDC_AR from
  339    02:DF64  9D 00 02   			sta	VDC_AR, x		; the shadow variable.
  340                        	
  341    02:DF67  28         			plp				; Restore interrupts.
  342                        	
  343    02:DF68  68         			pla				; Restore MPR4.
  344    02:DF69  53 10      			tam4
  345    02:DF6B  68         			pla				; Restore MPR3.
  346    02:DF6C  53 08      			tam3
  347                        	
  348    02:DF6E  7F F8 07   			bbr7	<_al, set_bat_size	; Update if BAT size changed.
  349                        	
  350                        			leave				; All done, phew!
         02:DF71  4C EF FF   			jmp	leave_proc
  351                        	
  352    02:DF74             			.ref	set_bat_vdc
  353                        			.endp
  354                        	
  355                        	
  356                        	
  357                        	; ***************************************************************************
  358                        	; ***************************************************************************
  359                        	;
  360                        	; set_bat_sgx - Change the SGX BAT size and initialize variables based on it.
  361                        	; set_bat_vdc - Change the PCE BAT size and initialize variables based on it.
  362                        	;
  363                        	; Args: _al = new size (0-7).
  364                        	;
  365                        	; (VDC_MWR_32x32  >> 4) or in HuCC, SCR_SIZE_32x32.
  366                        	; (VDC_MWR_32x64  >> 4) or in HuCC, SCR_SIZE_32x64.
  367                        	; (VDC_MWR_64x32  >> 4) or in HuCC, SCR_SIZE_64x32.
  368                        	; (VDC_MWR_64x64  >> 4) or in HuCC, SCR_SIZE_64x64.
  369                        	; (VDC_MWR_128x32 >> 4) or in HuCC, SCR_SIZE_128x32.
  370                        	; (VDC_MWR_128x64 >> 4) or in HuCC, SCR_SIZE_128x64.
  371                        	;
  372                        	
  373               0001     		.if	SUPPORT_SGX
  374    02:DF74             	set_bat_sgx	.proc
  375                        	
  376    02:DF74  A2 10      			ldx	#SGX_VDC_OFFSET		; Offset to SGX VDC.
  377    02:DF76  F0         			db	$F0			; Turn "clx" into a "beq".
  378                        	
  379    02:DF77             			.ref	set_bat_vdc
  380                        			.endp
  381                        		.endif
  382                        	
  383    02:DF77             	set_bat_vdc	.proc
  384                        	
  385    02:DF77  82         			clx				; Offset to PCE VDC.
  386                        	
  387    02:DF78  A5 F8      	set_bat_size:	lda	<_al			; Get BAT size value.
  388    02:DF7A  29 07      			and	#7			; Sanitize screen size value.
  389    02:DF7C  A8         			tay
  390    02:DF7D  0A         			asl	a			; Put it in bits 4..6.
  391    02:DF7E  0A         			asl	a
  392    02:DF7F  0A         			asl	a
  393    02:DF80  0A         			asl	a
  394    02:DF81  85 00      			sta	<__temp
  395                        	
  396    02:DF83  B9 C3 DF   			lda	.width, y
  397    02:DF86  9D 70 26   			sta	vdc_bat_width, x
  398    02:DF89  3A         			dec	a
  399    02:DF8A  9D 72 26   			sta	vdc_bat_x_mask, x
  400                        	
  401    02:DF8D  B9 CB DF   			lda	.height, y
  402    02:DF90  9D 71 26   			sta	vdc_bat_height, x
  403    02:DF93  3A         			dec	a
  404    02:DF94  9D 73 26   			sta	vdc_bat_y_mask, x
  405                        	
  406    02:DF97  B9 D3 DF   			lda	.limit, y
  407    02:DF9A  9D 74 26   			sta	vdc_bat_limit, x
  408                        	
  409    02:DF9D  B9 DB DF   			lda	.increment, y		; Put the VRAM increment for a
  410    02:DFA0  95 F4      			sta	<vdc_crh, x		; line into vdc_crh for later.
  411                        	
  412    02:DFA2  08         			php
  413    02:DFA3  78         			sei
  414                        	
  415    02:DFA4  A9 09      			lda	#VDC_MWR
  416    02:DFA6  9D 00 02   			sta	VDC_AR, x
  417                        	
  418    02:DFA9  AD 42 22   			lda	vdc_mwr			; Get the MWR access width bits.
  419    02:DFAC  29 8F      			and	#%10001111
  420    02:DFAE  05 00      			ora	<__temp
  421               0001     		.if	SUPPORT_SGX
  422    02:DFB0  E0 00      			cpx	#PCE_VDC_OFFSET		; This has no SGX shadow!
  423    02:DFB2  D0 03      			bne	!+
  424                        		.endif
  425    02:DFB4  8D 42 22   			sta	vdc_mwr
  426    02:DFB7  9D 02 02   	!:		sta	VDC_DL, x
  427                        	
  428    02:DFBA  B5 F7      			lda	<vdc_reg, x		; Restore previous VDC_AR from
  429    02:DFBC  9D 00 02   			sta	VDC_AR, x		; the shadow variable.
  430                        	
  431    02:DFBF  28         			plp
  432                        	
  433                        			leave
         02:DFC0  4C EF FF   			jmp	leave_proc
  434                        	
  435    02:DFC3  20 40 80 80	.width:		db	$20,$40,$80,$80,$20,$40,$80,$80
         02:DFC7  20 40 80 80 
  436    02:DFCB  20 20 20 20	.height:	db	$20,$20,$20,$20,$40,$40,$40,$40
         02:DFCF  40 40 40 40 
  437    02:DFD3  03 07 0F 0F	.limit:		db	$03,$07,$0F,$0F,$07,$0F,$1F,$1F
         02:DFD7  07 0F 1F 1F 
  438    02:DFDB  08 10 18 18	.increment	db	$08,$10,$18,$18,$08,$10,$18,$18
         02:DFDF  08 10 18 18 
  439                        	
  440               2670     			.bss
  441                        	
  442                        	; **************
  443                        	; 16-bytes of VDC BAT information.
  444                        	;
  445                        	; N.B. MUST be 16-bytes before the SGX versions to use PCE_VDC_OFFSET.
  446                        	;
  447                        	; N.B. Declared inside this .proc so that they can be stripped if unused.
  448                        	
  449                        	; Initialized by set_bat_vdc.
  450    F8:2670             	vdc_bat_width:	ds	1	; $20, $40, $80
  451    F8:2671             	vdc_bat_height:	ds	1	; $20, $40
  452    F8:2672             	vdc_bat_x_mask:	ds	1	; $1F, $3F, $7F
  453    F8:2673             	vdc_bat_y_mask:	ds	1	; $1F, $3F
  454    F8:2674             	vdc_bat_limit:	ds	1	; (>$03FF), (>$07FF), (>$0FFF), (>$1FFF)
  455                        	
  456                        	; From blkmap.asm just to avoid wasting .bss space with padding.
  457    F8:2675             	vdc_map_draw_w:	ds	1	; (SCR_WIDTH / 8) + 1
  458    F8:2676             	vdc_map_draw_h:	ds	1	; (SCR_HEIGHT / 8) + 1
  459    F8:2677             	vdc_map_line_w:	ds	1	; Line width of map data in tiles.
  460    F8:2678             	vdc_map_scrn_w:	ds	1	; Line width of map data in screens.
  461    F8:2679             	vdc_map_pxl_x:	ds	2	; Current top-left X in pixels.
  462    F8:267B             	vdc_map_pxl_y:	ds	2	; Current top-left Y in pixels.
  463    F8:267D             	vdc_map_option:	ds	1	; Flags to disable BAT alignment.
  464                        	
  465                        	; From hucc-old-spr.asm just to avoid wasting .bss space with padding.
  466    F8:267E             	spr_max:	ds	1
  467    F8:267F             	spr_clr:	ds	1
  468                        	
  469               0001     		.if	SUPPORT_SGX
  470                        	
  471                        	; **************
  472                        	; 16-bytes of SGX BAT information.
  473                        	;
  474                        	; N.B. MUST be 16-bytes after the VDC versions to use SGX_VDC_OFFSET.
  475                        	;
  476                        	; N.B. Declared inside this .proc so that they can be stripped if unused.
  477                        	
  478                        	; Initialized by set_bat_sgx.
  479    F8:2680             	sgx_bat_width:	ds	1	; $20, $40, $80
  480    F8:2681             	sgx_bat_height:	ds	1	; $20, $40
  481    F8:2682             	sgx_bat_x_mask:	ds	1	; $1F, $3F, $7F
  482    F8:2683             	sgx_bat_y_mask:	ds	1	; $1F, $3F
  483    F8:2684             	sgx_bat_limit:	ds	1	; (>$03FF), (>$07FF), (>$0FFF), (>$1FFF)
  484                        	
  485                        	; From blkmap.asm just to avoid wasting .bss space with padding.
  486    F8:2685             	sgx_map_draw_w:	ds	1	; (SCR_WIDTH / 8) + 1
  487    F8:2686             	sgx_map_draw_h:	ds	1	; (SCR_HEIGHT / 8) + 1
  488    F8:2687             	sgx_map_line_w:	ds	1	; Line width of map data in tiles.
  489    F8:2688             	sgx_map_scrn_w:	ds	1	; Line width of map data in screens.
  490    F8:2689             	sgx_map_pxl_x:	ds	2	; Current top-left X in pixels.
  491    F8:268B             	sgx_map_pxl_y:	ds	2	; Current top-left Y in pixels.
  492    F8:268D             	sgx_map_option:	ds	1	; Flags to disable BAT alignment.
  493                        	
  494                        	; From hucc-old-spr.asm just to avoid wasting .bss space with padding.
  495    F8:268E             	sgx_spr_max:	ds	1
  496    F8:268F             	sgx_spr_clr:	ds	1
  497                        	
  498                        		.endif
  499                        	
  500               DFE3     			.code
  501                        	
  502                        			.endp
  503                        	
  504                        			.endprocgroup
  505                        	
  506                        	
  507                        	
  508                        	; ***************************************************************************
  509                        	; ***************************************************************************
  510                        	;
  511                        	; sgx_detect - Detect whether we're running on a SuperGrafx (and init VPC).
  512                        	;
  513                        	; Returns: X,C-flag, and "sgx_detected" = NZ, CS if detected.
  514                        	;
  515                        	; ***************************************************************************
  516                        	;
  517                        	; https://web.archive.org/web/20161129055659/http://cgfm2.emuviews.com/txt/sgxtech.txt
  518                        	;
  519                        	; ***************************************************************************
  520                        	;
  521                        	; HuC6202 VIDEO PRIORITY CONTROLLER (huge thanks to Charles MacDonald!)
  522                        	;
  523                        	; The VPC has no access to sprite priority data, it can only sort pixels
  524                        	; based upon which VDC and whether they are "sprite" or "background".
  525                        	;
  526                        	; This can sometimes lead to unexpected results with low-priority sprites.
  527                        	;
  528                        	; VPC registers $0008 and $0009 make up four 4-bit values that define the
  529                        	; enabled layers and priority setting for the four possible window areas.
  530                        	;
  531                        	; Bits 3-0 of $0008 are for the region where Window 1 and 2 overlap
  532                        	; Bits 7-4 of $0008 are for the region occupied by only Window 2
  533                        	; Bits 3-0 of $0009 are for the region occupied by only Window 1
  534                        	; Bits 7-4 of $0009 are for the region where no Window is present
  535                        	;
  536                        	;  Each 4-bit value has the same format:
  537                        	;
  538                        	;  Bit 0: VDC #1 graphics are 0=disabled, 1=enabled
  539                        	;  Bit 1: VDC #2 graphics are 0=disabled, 1=enabled
  540                        	;  Bit 2: Bit 0 of priority setting
  541                        	;  Bit 3: Bit 1 of priority setting
  542                        	;
  543                        	;   Priority Setting 0b00xx: (useful when VDC #1 is a fullscreen HUD)
  544                        	;
  545                        	;    FRONT
  546                        	;     SP1 = VDC #1 (pce) sprite pixels
  547                        	;     BG1 = VDC #1 (pce) background pixels
  548                        	;     SP2 = VDC #2 (sgx) sprite pixels
  549                        	;     BG2 = VDC #2 (sgx) background pixels
  550                        	;    BACK
  551                        	;
  552                        	;   Priority Setting 0b01xx: (useful for parallax backgrounds)
  553                        	;
  554                        	;    FRONT
  555                        	;     SP1 = VDC #1 (pce) sprite pixels
  556                        	;     SP2 = VDC #2 (sgx) sprite pixels
  557                        	;     BG1 = VDC #1 (pce) background pixels
  558                        	;     BG2 = VDC #2 (sgx) background pixels
  559                        	;    BACK
  560                        	;
  561                        	;   Priority Setting 0b10xx: (only useful for special effects)
  562                        	;
  563                        	;    FRONT
  564                        	;     BG1 = VDC #1 (pce) background pixels (transparent where sprites)
  565                        	;     BG2 = VDC #2 (sgx) background pixels
  566                        	;     SP1 = VDC #1 (pce) sprite pixels
  567                        	;     SP2 = VDC #2 (sgx) sprite pixels
  568                        	;    BACK
  569                        	
  570               0001     		.if	SUPPORT_SGX
  571               0001     		.if	1
  572    11:D217             	sgx_detect	.proc
  573                        	
  574    11:D217  A0 7F      			ldy	#$7F			; Use VRAM address $7F7F
  575    11:D219  84 F0      			sty.l	<_di			; because it won't cause
  576    11:D21B  84 F1      			sty.h	<_di			; a screen glitch.
  577                        	
  578    11:D21D  20 7B E3   			jsr	sgx_di_to_mawr		; Write $0001 to SGX VRAM.
  579    11:D220  A0 01      			ldy	#$01
  580    11:D222  8C 12 02   			sty	SGX_DL
  581    11:D225  9C 13 02   			stz	SGX_DH
  582                        	
  583    11:D228  20 7E E3   			jsr	vdc_di_to_mawr		; Write $0000 to VDC VRAM.
  584    11:D22B  9C 02 02   			stz	VDC_DL
  585    11:D22E  9C 03 02   			stz	VDC_DH
  586                        	
  587    11:D231  20 6E E3   			jsr	sgx_di_to_marr		; Check value in SGX VRAM.
  588    11:D234  AC 12 02   			ldy	SGX_DL			; $01 if found, $00 if not.
  589    11:D237  8C E8 22   			sty	sgx_detected
  590    11:D23A  F0 10      			beq	!+			; Skip the rest if not SGX.
  591                        	
  592    11:D23C  20 7B E3   			jsr	sgx_di_to_mawr		; Write $0000 to SGX VRAM
  593    11:D23F  9C 12 02   			stz	SGX_DL			; to clean VRAM contents.
  594    11:D242  9C 13 02   			stz	SGX_DH
  595                        	
  596    11:D245  73 52 D2 08			tii	.vpc_mode, VPC_CR, 8	; Initialize the HuC6202 VPC.
         11:D249  02 08 00    
  597                        	
  598    11:D24C  98         	!:		tya
  599    11:D24D  AA         			tax				; "leave" copies X back to A.
  600    11:D24E  4A         			lsr	a			; Also CC if PCE, CS if SGX.
  601                        	
  602                        			leave				; All done, phew!
         11:D24F  4C EF FF   			jmp	leave_proc
  603                        		.else
  618                        		.endif
  619                        	
  620               0000     		.ifndef	SGX_PARALLAX
  622                        		.endif
  623                        	
  624               0001     		.if	SGX_PARALLAX
  625    11:D252  00 70      	.vpc_mode:	dw	$7000			; Use SGX as a parallax layer
  626    11:D254  00 00      			dw	$0000			; behind a VDC background.
  627    11:D256  00 00      			dw	$0000
  628    11:D258  00 00      			dw	$0000
  629                        		.else
  634                        		.endif	SGX_PARALLAX
  635                        	
  636                        			.endp
  637                        	
  638               0000     		.ifndef	CORE_VERSION			; CORE has this in the kernel.
  642                        		.endif	CORE_VERSION
  643                        	
  644                        		.endif	SUPPORT_SGX
  645                        	
  646                        	
  647                        	
  648                        	
  649                        	vdc_copy_to	.procgroup			; These routines share code!
  799                        			.endprocgroup
  800                        	
  801                        	
  802                        	
  803                        	; ***************************************************************************
  804                        	; ***************************************************************************
  805                        	;
  806                        	; init_240x208 - An example of initializing screen and VRAM.
  807                        	;
  808                        	; This can be used as-is, or copied to your own program and modified.
  809                        	;
  810                        	
  811                        	init_240x208	.proc
  892                        			.endp
  893                        	
  894                        	
  895                        	
  896                        	; ***************************************************************************
  897                        	; ***************************************************************************
  898                        	;
  899                        	; init_256x224 - An example of initializing screen and VRAM.
  900                        	;
  901                        	; This can be used as-is, or copied to your own program and modified.
  902                        	;
  903                        	
  904                        	init_256x224	.proc
  985                        			.endp
  986                        	
  987                        	
  988                        	
  989                        	; ***************************************************************************
  990                        	; ***************************************************************************
  991                        	;
  992                        	; init_352x224 - An example of initializing screen and VRAM.
  993                        	;
  994                        	; This can be used as-is, or copied to your own program and modified.
  995                        	;
  996                        	
  997                        	init_352x224	.proc
 1078                        			.endp
 1079                        	
 1080                        	
 1081                        	
 1082                        	; ***************************************************************************
 1083                        	; ***************************************************************************
 1084                        	;
 1085                        	; init_512x224 - An example of initializing screen and VRAM.
 1086                        	;
 1087                        	; This can be used as-is, or copied to your own program and modified.
 1088                        	;
 1089                        	
 1090                        	init_512x224	.proc
 1171                        			.endp
 1172                        	
 1173                        	
 1174                        	
 1175                        	; ***************************************************************************
 1176                        	; ***************************************************************************
 1177                        	;
 1178                        	; init_320x208 - An example of initializing screen and VRAM.
 1179                        	;
 1180                        	; This can be used as-is, or copied to your own program and modified.
 1181                        	;
 1182                        	; This resolution is rarely-seen, but it has no overscan, so it has a use.
 1183                        	;
 1184                        	
 1185                        	init_320x208	.proc
 1266                        			.endp
                             #[2]   "..\..\..\include\hucc\hucc-final.asm"
   41                        	
                             #[3]   "..\..\..\include\hucc\hucc-math.asm"
   42                        			include	"hucc-math.asm"		; HuCC multiply and divide.
    1                        	; ***************************************************************************
    2                        	; ***************************************************************************
    3                        	;
    4                        	; hucc-math.asm
    5                        	;
    6                        	; Basic (i.e. very slow) 8-bit and 16-bit multiply and divide routines.
    7                        	;
    8                        	; Copyright John Brandwood 2021-2024.
    9                        	;
   10                        	; Distributed under the Boost Software License, Version 1.0.
   11                        	; (See accompanying file LICENSE_1_0.txt or copy at
   12                        	;  http://www.boost.org/LICENSE_1_0.txt)
   13                        	;
   14                        	; ***************************************************************************
   15                        	; ***************************************************************************
   16                        	;
   17                        	; This is basically a set of SDCC-compatible routines, but using Y:A for the
   18                        	; primary register instead of X:A.
   19                        	;
   20                        	; Using Y:A makes the routines instantly usable with HuCC, and it also makes
   21                        	; them usable with SDCC with just an "sxy" before and after the call.
   22                        	;
   23                        	; ***************************************************************************
   24                        	; ***************************************************************************
   25                        	
   26               E44C     			.code
   27                        	
   28               2000     	multiplier	=	__temp
   29               2094     	multiplicand	=	___SDCC_m6502_ret0
   30               2094     	product		=	multiplicand
   31                        	
   32               2000     	__mulint_PARM_2	=	multiplier
   33                        	
   34               2000     	divisor		=	__temp
   35               2094     	dividend	=	___SDCC_m6502_ret0
   36               2094     	quotient	=	dividend
   37               2096     	remainder	=	___SDCC_m6502_ret2
   38                        	
   39               2000     	__moduint_PARM_2 =	divisor
   40               2000     	__modsint_PARM_2 =	divisor
   41               2000     	__divuint_PARM_2 =	divisor
   42               2000     	__divsint_PARM_2 =	divisor
   43                        	
   44                        	
   45                        	
   46                        	; ***************************************************************************
   47                        	; int
   48                        	; _mulint (int a, int b)
   49                        	;
   50                        	; 1st parameter in Y:A (multiplicand)
   51                        	; 2nd parameter in __mulint_PARM_2 (multiplier)
   52                        	; result in Y:A
   53                        	;
   54                        	; N.B. signed and unsigned multiply only differ in the top 16 of the 32bits!
   55                        	
   56    00:E44C  85 94      	__mulint:	sta	<multiplicand + 0
   57    00:E44E  84 95      			sty	<multiplicand + 1
   58                        	
   59    00:E450  A2 10      			ldx	#16			; Loop 16 times.
   60                        	
   61    00:E452  46 95      			lsr	<multiplicand + 1	; Divide multiplicand by 2
   62    00:E454  66 94      			ror	<multiplicand + 0	; and clear the 16th bit.
   63                        	
   64    00:E456  62         			cla				; Clear top word of product.
   65    00:E457  85 96      			sta.l	<multiplicand + 2
   66    00:E459  90 0B      			bcc	.rotate
   67                        	
   68    00:E45B  A8         	.add:		tay				; Add the 16-bit multiplier to
   69    00:E45C  18         			clc				; top 16-bits of the product.
   70    00:E45D  A5 96      			lda	<multiplicand + 2
   71    00:E45F  65 00      			adc.l	<multiplier
   72    00:E461  85 96      			sta	<multiplicand + 2
   73    00:E463  98         			tya
   74    00:E464  65 01      			adc.h	<multiplier
   75                        	
   76    00:E466  6A         	.rotate:	ror	a			; Rotate product into the top
   77    00:E467  66 96      			ror	<multiplicand + 2	; bits of the multiplicand ...
   78    00:E469  66 95      			ror	<multiplicand + 1	; and divide multiplicand by 2.
   79    00:E46B  66 94      			ror	<multiplicand + 0
   80                        	
   81    00:E46D  CA         			dex
   82    00:E46E  B0 EB      			bcs	.add			; Add multiplier to top word?
   83    00:E470  D0 F4      			bne	.rotate			; Completed 16 bits?
   84                        	
   85    00:E472  85 97      			sta	<multiplicand + 3	; Save top byte of product.
   86                        	
   87    00:E474  A5 94      			lda.l	<multiplicand		; Return the bottom 16-bits of
   88    00:E476  A4 95      			ldy.h	<multiplicand		; the 32-bit product.
   89                        	
   90    00:E478  60         			rts
   91                        	
   92                        	
   93                        	
   94                        	; ***************************************************************************
   95                        	; unsigned int
   96                        	; _divuint (unsigned int x, unsigned int y)
   97                        	;
   98                        	; 1st parameter in Y:A (unsigned dividend)
   99                        	; 2nd parameter in __divuint_PARM_2 (unsigned divisor)
  100                        	; result in Y:A
  101                        	
  102    00:E479  20 81 E4   	__divuint:	jsr	__moduint		; Call the basic uint division.
  103                        	
  104    00:E47C  A5 94      			lda.l	<quotient		; Then get the result from where
  105    00:E47E  A4 95      			ldy.h	<quotient		; it was calculated.
  106    00:E480  60         			rts
  107                        	
  108                        	
  109                        	
  110                        	; ***************************************************************************
  111                        	; unsigned int
  112                        	; _moduint (unsigned int x, unsigned int y)
  113                        	;
  114                        	; 1st parameter in Y:A (unsigned dividend)
  115                        	; 2nd parameter in __moduint_PARM_2 (unsigned divisor)
  116                        	; result in Y:A
  117                        	;
  118                        	; If the dividend has more bits than the divisor, then we need to check the
  119                        	; 17th bit of the remainder!
  120                        	
  121               0000     		.if	0
  176                        		.else
  177                        	
  178    00:E481  85 94      	__moduint:	sta.l	<dividend		; 1st SDCC parameter in Y:A.
  179    00:E483  84 95      			sty.h	<dividend
  180                        	
  181    00:E485  A5 00      	divmoduint:	lda.l	<divisor		; Check for a divide-by-zero.
  182    00:E487  05 01      			ora.h	<divisor
  183    00:E489  F0 FE      	.zero:		beq	.zero
  184                        	
  185    00:E48B  A2 11      			ldx	#16 + 1
  186                        	
  187    00:E48D  C2         			cly				; Clear remainder.
  188    00:E48E  84 97      			sty.h	<remainder
  189                        	
  190    00:E490  98         	.skip:		tya				; Restore remainder lo-byte.
  191                        	
  192    00:E491  26 94      	.loop:		rol.l	<dividend		; Quotient bit -> dividend LSB.
  193    00:E493  26 95      			rol.h	<dividend		; Rotate dividend, MSB -> C.
  194                        	
  195    00:E495  CA         			dex
  196    00:E496  F0 14      			beq	.finished
  197                        	
  198    00:E498  2A         			rol	a			; Rotate C into remainder.
  199    00:E499  26 97      			rol.h	<remainder
  200                        	;		php				; Preserve remainder 17th bit.
  201                        	
  202    00:E49B  A8         			tay				; Preserve remainder lo-byte.
  203                        	
  204    00:E49C  C5 00      			cmp.l	<divisor		; Test divisor.
  205    00:E49E  A5 97      			lda.h	<remainder
  206    00:E4A0  E5 01      			sbc.h	<divisor
  207    00:E4A2  90 EC      			bcc	.skip			; CC if divisor > remainder.
  208                        	
  209                        	;		cmp.l	<divisor		; If the dividend has more bits
  210                        	;		lda.h	<remainder		; than the divisor then we need
  211                        	;		sbc.h	<divisor		; to check the remainder hi-bit.
  212                        	;		bcs	.subtract		; CS if divisor <= remainder.
  213                        	;		plp				; Restore remainder 17th bit.
  214                        	;		bcc	.skip			; CC if divisor > remainder.
  215                        	;		db	$90			; Turn "plp" into "bcc" to skip.
  216                        	;.subtract:	plp				; Discard remainder 17th bit.
  217                        	;		sec
  218                        	
  219    00:E4A4  85 97      			sta.h	<remainder		; Subtract divisor.
  220    00:E4A6  98         			tya
  221    00:E4A7  E5 00      			sbc.l	<divisor
  222    00:E4A9  38         			sec				
  223    00:E4AA  80 E5      			bra	.loop
  224                        	
  225    00:E4AC  A4 97      	.finished:	ldy.h	<remainder		; Get the remainder hi-byte.
  226                        	
  227    00:E4AE  60         			rts
  228                        	
  229                        		.endif
  230                        	
  231                        	
  232                        	
  233                        	; ***************************************************************************
  234                        	; int
  235                        	; _divsint (int x, int y)
  236                        	;
  237                        	; 1st parameter in Y:A (signed dividend)
  238                        	; 2nd parameter in __divsint_PARM_2 (signed divisor)
  239                        	; result in Y:A
  240                        	
  241    00:E4AF  20 B7 E4   	__divsint:	jsr	__modsint		; Call the basic sint division.
  242                        	
  243    00:E4B2  A5 94      			lda.l	<quotient		; Then get the result from where
  244    00:E4B4  A4 95      			ldy.h	<quotient		; it was calculated.
  245    00:E4B6  60         			rts
  246                        	
  247                        	
  248                        	
  249                        	; ***************************************************************************
  250                        	; int
  251                        	; _modsint (int x, int y)
  252                        	;
  253                        	; 1st parameter in Y:A (signed dividend)
  254                        	; 2nd parameter in __modsint_PARM_2 (signed divisor)
  255                        	; result in Y:A
  256                        	
  257    00:E4B7  84 95      	__modsint:	sty.h	<dividend
  258                        	
  259    00:E4B9  C0 80      			cpy	#$80			; Remainder -ve if dividend
  260    00:E4BB  08         			php				; was -ve.
  261    00:E4BC  90 03      			bcc	!+
  262    00:E4BE  20 0E E5   			jsr	neg_yacs		; Negate the dividend.
  263                        	
  264    00:E4C1  85 94      	!:		sta.l	<dividend		; Store the dividend.
  265    00:E4C3  A5 95      			lda.h	<dividend
  266    00:E4C5  84 95      			sty.h	<dividend
  267                        	
  268    00:E4C7  45 01      			eor.h	<divisor		; Quotient is -ve if divisor
  269    00:E4C9  08         			php				; and dividend signs differ.
  270                        	
  271    00:E4CA  A5 01      			lda.h	<divisor		; Is the divisor -ve?
  272    00:E4CC  10 0B      			bpl	!+
  273                        	
  274    00:E4CE  38         			sec				; Negate the divisor.
  275    00:E4CF  62         			cla
  276    00:E4D0  E5 00      			sbc.l	<divisor
  277    00:E4D2  85 00      			sta.l	<divisor
  278    00:E4D4  62         			cla
  279    00:E4D5  E5 01      			sbc.h	<divisor
  280    00:E4D7  85 01      			sta.h	<divisor
  281                        	
  282    00:E4D9  20 85 E4   	!:		jsr	divmoduint		; Do the unsigned division.
  283                        	
  284    00:E4DC  28         	.result:	plp				; Should the quotient be -ve?
  285    00:E4DD  10 0D      			bpl	.remainder
  286                        	
  287    00:E4DF  AA         			tax				; Preserve remainder lo-byte.
  288                        	
  289    00:E4E0  38         			sec				; Then negate the quotient.
  290    00:E4E1  62         			cla
  291    00:E4E2  E5 94      			sbc.l	<dividend
  292    00:E4E4  85 94      			sta.l	<dividend
  293    00:E4E6  62         			cla
  294    00:E4E7  E5 95      			sbc.h	<dividend
  295    00:E4E9  85 95      			sta.h	<dividend
  296                        	
  297    00:E4EB  8A         			txa				; Restore remainder lo-byte.
  298                        	
  299    00:E4EC  28         	.remainder:	plp				; Was the dividend -ve?
  300    00:E4ED  B0 1F      			bcs	neg_yacs		; Then negate the remainder.
  301    00:E4EF  60         			rts
  302                        	
  303                        	
  304                        	
  305                        	; ***************************************************************************
  306                        	; unsigned int
  307                        	; _muluchar (unsigned char x, unsigned char y)
  308                        	;
  309                        	; 1st parameter in A (unsigned multiplicand)
  310                        	; 2nd parameter in Y (unsigned multiplier)
  311                        	; result in Y:A
  312                        	
  313    00:E4F0  84 00      	__muluchar:	sty	<multiplier
  314                        	
  315    00:E4F2  A0 08      	muluchar_a:	ldy	#8			; Loop 8 times.
  316                        	
  317    00:E4F4  4A         			lsr	a			; Divide multiplicand by 2
  318    00:E4F5  85 94      			sta	<multiplicand		; and clear the 8th bit.
  319                        	
  320    00:E4F7  62         			cla				; Clear top byte of product.
  321    00:E4F8  90 03      			bcc	.rotate
  322                        	
  323    00:E4FA  18         	.add:		clc				; Add the 8-bit multiplier to
  324    00:E4FB  65 00      			adc	<multiplier		; top 8-bits of the product.
  325                        	
  326    00:E4FD  6A         	.rotate:	ror	a			; Rotate product into the top
  327    00:E4FE  66 94      			ror	<multiplicand		; bits of the multiplicand.
  328                        	
  329    00:E500  88         			dey
  330    00:E501  B0 F7      			bcs	.add			; Add multiplier to top byte?
  331    00:E503  D0 F8      			bne	.rotate			; Completed 8 bits?
  332                        	
  333    00:E505  A8         			tay				; Return the 16-bit product.
  334    00:E506  A5 94      			lda	<multiplicand
  335                        	
  336    00:E508  60         			rts
  337                        	
  338                        	
  339                        	
  340                        	; ***************************************************************************
  341                        	; signed int
  342                        	; abs (signed int x)
  343                        	;
  344                        	; 1st parameter in Y:A (signed)
  345                        	; result in Y:A
  346                        	
  347    00:E509  C0 80      	_abs:		cpy	#$80			; Is the hi-byte -ve?
  348    00:E50B  90 0B      			bcc	!+
  349                        	
  350    00:E50D  38         	neg_ya:		sec
  351    00:E50E  49 FF      	neg_yacs:	eor	#$FF
  352    00:E510  69 00      			adc	#0
  353    00:E512  42         			say
  354    00:E513  49 FF      			eor	#$FF
  355    00:E515  69 00      			adc	#0
  356    00:E517  42         			say
  357    00:E518  60         	!:		rts
  358                        	
  359    00:E519             	_abs.1		.alias	_abs
  360                        	
  361                        	
  362                        	
  363                        	; ***************************************************************************
  364                        	; signed int
  365                        	; _mulschar (signed char x, signed char y)
  366                        	;
  367                        	; 1st parameter in A (signed multiplicand)
  368                        	; 2nd parameter in Y (signed multiplier)
  369                        	; result in Y:A
  370                        	;
  371                        	; N.B. Y and A get swapped to make the code shorter.
  372                        	
  373    00:E519  85 94      	__mulschar:	sta	<multiplicand		; Remember multiplicand sign.
  374                        	
  375    00:E51B  C9 80      			cmp	#$80			; Is the multiplicand -ve?
  376    00:E51D  90 03      			bcc	!+
  377    00:E51F  49 FF      			eor	#$FF			; Negate the multiplicand.
  378    00:E521  1A         			inc	a
  379    00:E522  85 00      	!:		sta	<multiplier		; Then save it as multiplier.
  380                        	
  381    00:E524  98         			tya				; Product -ve if multiplicand
  382    00:E525  45 94      			eor	<multiplicand		; and multiplier signs differ.
  383    00:E527  08         			php				; Remember product sign.
  384                        	
  385    00:E528  98         			tya				; Is the multiplicand -ve?
  386    00:E529  10 03      			bpl	!+
  387    00:E52B  49 FF      			eor	#$FF			; Negate the multiplicand.
  388    00:E52D  1A         			inc	a
  389                        	
  390    00:E52E  20 F2 E4   	!:		jsr	muluchar_a		; Multiplier already saved.
  391                        	
  392    00:E531  28         			plp				; Is the product -ve?
  393    00:E532  30 D9      			bmi	neg_ya
  394    00:E534  60         			rts
  395                        	
  396                        	
  397                        	
  398                        	; ***************************************************************************
  399                        	; unsigned int
  400                        	; _mulsuchar (signed char x, signed char y)
  401                        	;
  402                        	; 1st parameter in A (unsigned multiplicand)
  403                        	; 2nd parameter in Y (signed multiplier)
  404                        	; result in Y:A
  405                        	;
  406                        	; N.B. Y and A get swapped to make the code shorter.
  407                        	
  408    00:E535  42         	__mulsuchar:	say				; Put the signed param in A.
  409                        			; drop through to __muluschar
  410                        	
  411                        	
  412                        	
  413                        	; ***************************************************************************
  414                        	; signed int
  415                        	; _muluschar (unsigned char x, unsigned char y)
  416                        	;
  417                        	; 1st parameter in A (signed multiplicand)
  418                        	; 2nd parameter in Y (unsigned multiplier)
  419                        	; result in Y:A
  420                        	
  421    00:E536  C9 80      	__muluschar:	cmp	#$80			; Is multiplicand -ve?
  422    00:E538  08         			php				; Remember the sign.
  423    00:E539  90 03      			bcc	!+
  424    00:E53B  49 FF      			eor	#$FF			; Negate multiplicand.
  425    00:E53D  1A         			inc	a
  426                        	
  427    00:E53E  20 F0 E4   	!:		jsr	__muluchar		; Do the unsigned multiply.
  428                        	
  429    00:E541  28         			plp				; Was multiplicand -ve?
  430    00:E542  B0 CA      			bcs	neg_yacs		; Then negate the product.
  431    00:E544  60         			rts
  432                        	
  433                        	
  434                        	
  435                        	; ***************************************************************************
  436                        	; unsigned int
  437                        	; _moduchar (unsigned char x, unsigned char y)
  438                        	;
  439                        	; 1st parameter in A (unsigned dividend)
  440                        	; 2nd parameter in Y (unsigned divisor)
  441                        	; result in Y:A
  442                        	
  443    00:E545  84 00      	__moduchar:	sty.l	<divisor
  444                        	
  445    00:E547  0A         	divmodu8_a:	asl	a			; Rotate dividend, MSB -> C.
  446    00:E548  85 94      			sta.l	<dividend
  447    00:E54A  64 95      			stz.h	<dividend		; Clear quotient hi-byte.
  448                        	
  449    00:E54C  A0 08      			ldy	#8
  450    00:E54E  62         			cla				; Clear remainder.
  451    00:E54F  2A         	.loop:		rol	a			; Rotate C into remainder.
  452    00:E550  C5 00      			cmp	<divisor		; Test divisor.
  453    00:E552  90 02      			bcc	.skip			; CC if divisor > remainder.
  454    00:E554  E5 00      			sbc	<divisor		; Subtract divisor.
  455    00:E556  26 94      	.skip:		rol	<dividend		; Quotient bit -> dividend LSB.
  456    00:E558  88         			dey
  457    00:E559  D0 F4      			bne	.loop
  458                        	
  459    00:E55B  C2         			cly				; Clear hi-byte of return.
  460    00:E55C  60         			rts				; Return the 16-bit remainder.
  461                        	
  462                        	
  463                        	
  464                        	; ***************************************************************************
  465                        	; unsigned int
  466                        	; _divuchar (unsigned char x, unsigned char y)
  467                        	;
  468                        	; 1st parameter in A (unsigned dividend)
  469                        	; 2nd parameter in Y (unsigned divisor)
  470                        	; result in Y:A
  471                        	
  472    00:E55D  20 45 E5   	__divuchar:	jsr	__moduchar
  473                        	
  474    00:E560  A5 94      			lda	<dividend		; Get the dividend lo-byte.
  475    00:E562  60         			rts				; Return the 16-bit dividend.
  476                        	
  477                        	
  478                        	
  479                        	; ***************************************************************************
  480                        	; signed int
  481                        	; _modschar (signed char x, signed char y)
  482                        	;
  483                        	; 1st parameter in A (signed dividend)
  484                        	; 2nd parameter in Y (signed divisor)
  485                        	; result in Y:A
  486                        	
  487    00:E563  AA         	__modschar:	tax				; Preserve the dividend.
  488    00:E564  08         			php				; Remember remainder sign.
  489                        	
  490    00:E565  84 00      			sty	<divisor		; Quotient negative if divisor
  491    00:E567  45 00      			eor	<divisor		; and dividend signs differ.
  492    00:E569  08         			php				; Remember the quotient sign.
  493                        	
  494    00:E56A  98         			tya				; Is the divisor -ve?
  495    00:E56B  10 05      			bpl	!+
  496    00:E56D  49 FF      			eor	#$FF			; Negate the divisor.
  497    00:E56F  1A         			inc	a
  498    00:E570  85 00      			sta	<divisor
  499                        	
  500    00:E572  8A         	!:		txa				; Is the dividend -ve?
  501    00:E573  10 03      			bpl	divmods8_a
  502                        	
  503    00:E575  49 FF      	divmods8_neg:	eor	#$FF			; Negate the dividend.
  504    00:E577  1A         			inc	a
  505                        	
  506    00:E578  20 47 E5   	divmods8_a:	jsr	divmodu8_a		; Do the unsigned division.
  507                        	
  508    00:E57B  28         			plp				; Should the quotient be -ve?
  509    00:E57C  10 0C      			bpl	!+
  510                        	
  511    00:E57E  AA         			tax				; Preserve remainder lo-byte.
  512                        	
  513    00:E57F  38         			sec				; Negate the quotient.
  514    00:E580  62         			cla
  515    00:E581  E5 94      			sbc.l	<dividend
  516    00:E583  85 94      			sta.l	<dividend
  517    00:E585  A9 FF      			lda	#$FF
  518    00:E587  85 95      			sta.h	<dividend
  519                        	
  520    00:E589  8A         			txa				; Restore remainder lo-byte.
  521                        	
  522    00:E58A  28         	!:		plp				; Was the dividend -ve?
  523    00:E58B  10 05      			bpl	!+
  524                        	
  525    00:E58D  49 FF      			eor	#$FF			; Then negate the remainder.
  526    00:E58F  1A         			inc	a
  527    00:E590  A0 FF      			ldy	#$FF
  528                        	
  529    00:E592  60         	!:		rts
  530                        	
  531                        	
  532                        	
  533                        	; ***************************************************************************
  534                        	; signed int
  535                        	; _moduschar (unsigned char x, unsigned char y)
  536                        	;
  537                        	; 1st parameter in A (signed dividend)
  538                        	; 2nd parameter in Y (unsigned divisor)
  539                        	; result in Y:A
  540                        	
  541    00:E593  84 00      	__moduschar:	sty.l	<divisor
  542                        	
  543    00:E595  A8         			tay				; Is the dividend -ve?
  544    00:E596  08         			php				; Remember remainder sign.
  545    00:E597  08         			php				; Remember quotient sign.
  546    00:E598  30 DB      			bmi	divmods8_neg
  547    00:E59A  80 DC      			bra	divmods8_a
  548                        	
  549                        	
  550                        	
  551                        	; ***************************************************************************
  552                        	; unsigned int
  553                        	; _modsuchar (signed char x, signed char y)
  554                        	;
  555                        	; 1st parameter in A (unsigned dividend)
  556                        	; 2nd parameter in Y (signed divisor)
  557                        	; result in Y:A
  558                        	
  559    00:E59C  AA         	__modsuchar:	tax				; Preserve the dividend.
  560    00:E59D  08         			php				; Remember remainder sign.
  561                        	
  562    00:E59E  98         			tya				; Check the divisor sign.
  563    00:E59F  08         			php				; Remember quotient sign.
  564    00:E5A0  10 03      			bpl	!+
  565    00:E5A2  49 FF      			eor	#$FF			; Negate the divisor.
  566    00:E5A4  1A         			inc	a
  567    00:E5A5  85 00      	!:		sta.l	<divisor
  568                        	
  569    00:E5A7  8A         			txa				; Restore the dividend.
  570    00:E5A8  80 CE      			bra	divmods8_a
  571                        	
  572                        	
  573                        	
  574                        	; ***************************************************************************
  575                        	; signed int
  576                        	; _divschar (signed char x, signed char y)
  577                        	;
  578                        	; 1st parameter in A (signed dividend)
  579                        	; 2nd parameter in Y (signed divisor)
  580                        	; result in Y:A
  581                        	
  582    00:E5AA  20 63 E5   	__divschar:	jsr	__modschar
  583                        	
  584    00:E5AD  A5 94      			lda.l	<dividend
  585    00:E5AF  A4 95      			ldy.h	<dividend
  586    00:E5B1  60         			rts
  587                        	
  588                        	
  589                        	
  590                        	; ***************************************************************************
  591                        	; signed int
  592                        	; _divuschar (unsigned char x, unsigned char y)
  593                        	;
  594                        	; 1st parameter in A (signed dividend)
  595                        	; 2nd parameter in Y (unsigned divisor)
  596                        	; result in Y:A
  597                        	
  598    00:E5B2  20 93 E5   	__divuschar:	jsr	__moduschar
  599                        	
  600    00:E5B5  A5 94      			lda.l	<dividend
  601    00:E5B7  A4 95      			ldy.h	<dividend
  602    00:E5B9  60         			rts
  603                        	
  604                        	
  605                        	
  606                        	; ***************************************************************************
  607                        	; unsigned int
  608                        	; _divsuchar (signed char x, signed char y)
  609                        	;
  610                        	; 1st parameter in A (unsigned dividend)
  611                        	; 2nd parameter in Y (signed divisor)
  612                        	; result in Y:A
  613                        	
  614    00:E5BA  20 9C E5   	__divsuchar:	jsr	__modsuchar
  615                        	
  616    00:E5BD  A5 94      			lda.l	<dividend
  617    00:E5BF  A4 95      			ldy.h	<dividend
  618    00:E5C1  60         			rts
                             #[2]   "..\..\..\include\hucc\hucc-final.asm"
   43                        	
   44                        			; Define in hucc-config.inc to remove this.
   45                        	
   46               0001     		.ifndef	HUCC_NO_DEFAULT_RANDOM
                             #[3]   "..\..\..\include\hucc\random.asm"
   47                        			include	"random.asm"		; Random number generator.
    1                        	; ***************************************************************************
    2                        	; ***************************************************************************
    3                        	;
    4                        	; random.asm
    5                        	;
    6                        	; Pseudo-random number generator (https://github.com/bbbradsmith/prng_6502)
    7                        	;
    8                        	; Copyright Brad Smith 2019.
    9                        	;
   10                        	; License:
   11                        	;
   12                        	; This code and may be used, reused, and modified for any purpose, commercial
   13                        	; or non-commercial.
   14                        	;
   15                        	; Attribution in released binaries or documentation is appreciated but not
   16                        	; required.
   17                        	;
   18                        	; ***************************************************************************
   19                        	; ***************************************************************************
   20                        	;
   21                        	; This is a linear feedback shift register (LFSR) in Galois form, which is
   22                        	; iterated 8 times to produce an 8-bit pseudo-random number.
   23                        	;
   24                        	; Two widths of LFSR are provided:
   25                        	;
   26                        	;  24-bit requires 3 bytes, and repeats after 16777215 calls.
   27                        	;  32-bit requires 4 bytes, and repeats after 4294967295 calls.
   28                        	;
   29                        	; Usage:
   30                        	;
   31                        	;  Initialize the zero-page "random" variable to any value other than 0.
   32                        	;  The size of "random" is 3 or 4 bytes, depending on the width of LFSR
   33                        	;  chosen.
   34                        	;
   35                        	;  Call one of the RNG functions and an 8-bit result will be returned in the
   36                        	;  A-register (with flags), and the Y-register will be clobbered.
   37                        	;
   38                        	;  Do not mix RNGs of different width in the same program, unless you can
   39                        	;  give them each separate "random" state storage.
   40                        	;
   41                        	; ***************************************************************************
   42                        	; ***************************************************************************
   43                        	
   44                        	
   45               0001     		.ifndef	_KICKC				; Variables defined in C?
   46               2098     			.zp
   47    F8:2098             	random:		.ds	4			; Seed is 3 or 4 bytes.
   48               E5C2     			.code
   49                        		.endif	_KICKC
   50                        	
   51                        	
   52                        	
   53                        	; ***************************************************************************
   54                        	; ***************************************************************************
   55                        	;
   56                        	; init_random - Initialize a 32-bit LFSR using an 8-bit seed value in Y.
   57                        	;
   58                        	; The LFSR is initialized to n'th entry of a standard CRC-32 lookup-table,
   59                        	; which gives it a decent distribution of bits.
   60                        	;
   61                        	; Since seed is an 8-bit value, there are 255 (256-1) possible starting
   62                        	; states for the LFSR, because 0 would generate a 0 state.
   63                        	;
   64                        	; CRC-32 code by Paul Guertin. See http://6502.org/source/integers/crc.htm
   65                        	;
   66                        	
   67    11:D2D7             	init_random	.proc
   68                        	
   69    11:D2D7  A9 01      			lda	#1			; Init CRC-32 table value.
   70    11:D2D9  85 98      			sta	<random + 0
   71    11:D2DB  98         			tya				; Get and check the seed value.
   72    11:D2DC  D0 01      			bne	.reverse_seed
   73    11:D2DE  3A         			dec	a			; Which must be non-zero!
   74    11:D2DF  4A         	.reverse_seed:	lsr	a			; Reverse the bits so that small changes
   75    11:D2E0  26 98      			rol	<random + 0		; in the seed make larger differences in
   76    11:D2E2  90 FB      			bcc	.reverse_seed		; the initial state.
   77                        	
   78    11:D2E4  64 99      			stz	<random + 1		; A contains the high byte of the CRC-32.
   79    11:D2E6  64 9A      			stz	<random + 2		; The other three bytes are in memory.
   80    11:D2E8  62         			cla
   81                        	
   82    11:D2E9  A0 08      			ldy	#8			; Y counts bits in a byte.
   83    11:D2EB  4A         	.bit_loop:	lsr	a			; The CRC-32 algorithm is similar to CRC-16
   84    11:D2EC  66 9A      			ror	<random + 2		; except that it is reversed (originally for
   85    11:D2EE  66 99      			ror	<random + 1		; hardware reasons). This is why we shift
   86    11:D2F0  66 98      			ror	<random + 0		; right instead of left here.
   87    11:D2F2  90 16      			bcc	.no_add			; Do nothing if no overflow,
   88    11:D2F4  49 ED      			eor	#$ED			; else add CRC-32 polynomial $EDB88320.
   89                        	
   90    11:D2F6  48         			pha				; Save high byte while we do others.
   91    11:D2F7  A5 9A      			lda	<random + 2
   92    11:D2F9  49 B8      			eor	#$B8			; Most reference books give the CRC-32 poly
   93    11:D2FB  85 9A      			sta	<random + 2		; as $04C11DB7. This is actually the same if
   94    11:D2FD  A5 99      			lda	<random + 1		; you write it in binary and read it right-
   95    11:D2FF  49 83      			eor	#$83			; to-left instead of left-to-right. Doing it
   96    11:D301  85 99      			sta	<random + 1		; this way means we won't have to explicitly
   97    11:D303  A5 98      			lda	<random + 0		; reverse things afterwards.
   98    11:D305  49 20      			eor	#$20
   99    11:D307  85 98      			sta	<random + 0
  100    11:D309  68         			pla				; Restore high byte.
  101                        	
  102    11:D30A  88         	.no_add:	dey				; Do next bit.
  103    11:D30B  D0 DE      			bne	.bit_loop
  104                        	
  105    11:D30D  85 9B      			sta	<random + 3		; Save CRC-32 high-byte.
  106                        	
  107                        			leave				; All done!
         11:D30F  4C EF FF   			jmp	leave_proc
  108                        	
  109                        			.endp
  110                        	
  111                        	
  112                        	
  113                        	; ***************************************************************************
  114                        	; ***************************************************************************
  115                        	;
  116                        	; get_random - 8-bit LFSR pseudo-random number with a 24-bit cycle.
  117                        	;
  118                        	; The pseudo-random sequence repeats after (2^24)-1 calls.
  119                        	;
  120                        	; Written by Wim Couwenberg, see ...
  121                        	;
  122                        	; "https://wimcouwenberg.wordpress.com/2020/11/15/ ...
  123                        	;  a-fast-24-bit-prng-algorithm-for-the-6502-processor/"
  124                        	;
  125                        	; Takes 68 cycles on the HuC6280, incl JSR & RTS.
  126                        	;
  127                        	; N.B. HuCC library code relies on this preserving X and Y!
  128                        	;
  129                        	
  130    00:E5C2  C2         	_rand8:		cly				; Entry point for HuCC.
  131                        	
  132    00:E5C3  A5 98      	get_random:	lda	<random + 0		; Operation 7 (with carry clear).
  133    00:E5C5  0A         			asl	a
  134    00:E5C6  45 99      			eor	<random + 1
  135    00:E5C8  85 99      			sta	<random + 1
  136    00:E5CA  2A         			rol	a             		; Operation 9.
  137    00:E5CB  45 9A      			eor	<random + 2
  138    00:E5CD  85 9A      			sta	<random + 2
  139    00:E5CF  45 98      			eor	<random + 0		; Operation 5.
  140    00:E5D1  85 98      			sta	<random + 0
  141    00:E5D3  A5 99      			lda	<random + 1		; Operation 15.
  142    00:E5D5  6A         			ror	a
  143    00:E5D6  45 9A      			eor	<random + 2
  144    00:E5D8  85 9A      			sta	<random + 2
  145    00:E5DA  45 99      			eor	<random + 1		; Operation 6.
  146    00:E5DC  85 99      			sta	<random + 1
  147    00:E5DE  60         			rts
  148                        	
  149                        	
  150                        	
  151               0000     		.if	0
  316                        		.endif
                             #[2]   "..\..\..\include\hucc\hucc-final.asm"
   48                        		.endif
   49                        	
   50                        			; Optional libraries that get used when their header files
   51                        			; are included in a HuCC project.
   52                        			;
   53                        			; When the HuCC compiler is invoked with the "--legacy"
   54                        			; option to compile old projects, then the "huc.h" file
   55                        			; is automatically included, which then includes a list
   56                        			; of specific headers corresponding to HuC's library.
   57                        	
   58               0001     		.ifdef	HUCC_USES_GFX
                             #[3]   "..\..\..\include\hucc\hucc-gfx.asm"
   59                        			include	"hucc-gfx.asm"		; Set in hucc_gfx.h
    1                        	; ***************************************************************************
    2                        	; ***************************************************************************
    3                        	;
    4                        	; huc-gfx.asm
    5                        	;
    6                        	; Based on the original HuC and MagicKit functions by David Michel and the
    7                        	; other original HuC developers.
    8                        	;
    9                        	; Modifications copyright John Brandwood 2024-2025.
   10                        	;
   11                        	; Distributed under the Boost Software License, Version 1.0.
   12                        	; (See accompanying file LICENSE_1_0.txt or copy at
   13                        	;  http://www.boost.org/LICENSE_1_0.txt)
   14                        	;
   15                        	; ***************************************************************************
   16                        	; ***************************************************************************
   17                        	
   18                        	;
   19                        	; Include dependancies ...
   20                        	;
   21                        	
   22                        			include "common.asm"		; Common helpers.
   23                        			include "vce.asm"		; Useful VCE routines.
   24                        			include "vdc.asm"		; Useful VCE routines.
   25                        	
   26                        	
   27                        	
   28                        	; ***************************************************************************
   29                        	; ***************************************************************************
   30                        	;
   31                        	; void __fastcall disp_on( void );
   32                        	; void __fastcall disp_off( void );
   33                        	
   34    00:E5DF             			.alias	_disp_on		= set_dspon
   35    00:E5DF             			.alias	_disp_off		= set_dspoff
   36                        	
   37                        	
   38                        	
   39                        	; ***************************************************************************
   40                        	; ***************************************************************************
   41                        	;
   42                        	; void __fastcall set_screen_size( unsigned char value<_al> );
   43                        	; void __fastcall sgx_set_screen_size( unsigned char value<_al> );
   44                        	;
   45                        	
   46    00:E5DF             			.alias	_set_screen_size.1	= set_bat_vdc
   47    00:E5DF             			.alias	_sgx_set_screen_size.1	= set_bat_sgx
   48                        	
   49                        	
   50                        	
   51                        	; ***************************************************************************
   52                        	; ***************************************************************************
   53                        	;
   54                        	; void __fastcall init_256x224( void );
   55                        	
   56    11:D0DC             	_init_256x224	.proc
   57                        	
   58               0800     	.BAT_SIZE	=	64 * 32
   59               0080     	.CHR_0x20	=	.BAT_SIZE / 16		; 1st tile # after the BAT.
   60               7F00     	.SAT_ADDR	=	$7F00			; SAT takes 16 tiles of VRAM.
   61                        	
   62    11:D0DC  08         			php				; Disable interrupts.
   63    11:D0DD  78         			sei
   64                        	
   65    11:D0DE  20 D3 FD   			call	clear_vce		; Clear all palettes.
   66                        	
   67    11:D0E1  A9 80      			lda.l	#.CHR_0x20		; CHR # of ASCII ' '.
   68    11:D0E3  85 F8      			sta.l	<_ax
   69    11:D0E5  A9 00      			lda.h	#.CHR_0x20
   70    11:D0E7  85 F9      			sta.h	<_ax
   71                        	
   72    11:D0E9  A9 08      			lda	#>.BAT_SIZE		; Size of BAT in words.
   73    11:D0EB  85 FA      			sta	<_bl
   74                        	
   75    11:D0ED  20 E7 FD   			call	clear_vram_vdc		; Clear VRAM.
   76               0001     		.if	SUPPORT_SGX
   77    11:D0F0  20 C9 FD   			call	clear_vram_sgx
   78                        		.endif
   79                        	
   80    11:D0F3  A9 17      			lda	#<.mode_256x224		; Disable BKG & SPR layers but
   81    11:D0F5  85 EC      			sta.l	<_bp			; enable RCR & VBLANK IRQ.
   82    11:D0F7  A9 D1      			lda	#>.mode_256x224
   83    11:D0F9  85 ED      			sta.h	<_bp
   84                        	
   85               0001     		.if	SUPPORT_SGX
   86    11:D0FB  20 BF FD   			call	sgx_detect		; Are we really on an SGX?
   87    11:D0FE  90 05      			bcc	!+
   88    11:D100  A0 11      			ldy	#^.mode_256x224		; Set SGX 1st, with no VBL.
   89    11:D102  20 B5 FD   			call	set_mode_sgx
   90                        		.endif
   91    11:D105  A0 11      	!:		ldy	#^.mode_256x224		; Set VDC 2nd, VBL allowed.
   92    11:D107  20 AB FD   			call	set_mode_vdc
   93                        	
   94               0001     		.if	SUPPORT_SGX
   95    11:D10A  2C 10 02   			bit	SGX_SR			; Purge any overdue RCR.
   96                        		.endif
   97    11:D10D  2C 00 02   			bit	VDC_SR			; Purge any overdue VBL.
   98    11:D110  28         			plp				; Restore interrupts.
   99                        	
  100    11:D111  20 09 E3   			call	wait_vsync		; Wait for the next VBLANK.
  101                        	
  102                        			leave				; All done, phew!
         11:D114  4C EF FF   			jmp	leave_proc
  103                        	
  104                        			; A standard 256x224 screen with overscan.
  105                        	
  106    11:D117  80         	.mode_256x224:	db	$80			; VCE Control Register.
  107    11:D118  04         			db	VCE_CR_5MHz + XRES_SOFT	;   Video Clock + Artifact Reduction
  108                        	
  109    11:D119  09         			db	VDC_MWR			; Memory-access Width Register
  110    11:D11A  10 00      			dw	VDC_MWR_64x32 + VDC_MWR_1CYCLE
  111    11:D11C  0A         			db	VDC_HSR			; Horizontal Sync Register
  112    11:D11D  02 02      			dw	VDC_HSR_256
  113    11:D11F  0B         			db	VDC_HDR			; Horizontal Display Register
  114    11:D120  1F 04      			dw	VDC_HDR_256
  115    11:D122  0C         			db	VDC_VPR			; Vertical Sync Register
  116    11:D123  02 17      			dw	VDC_VPR_224
  117    11:D125  0D         			db	VDC_VDW			; Vertical Display Register
  118    11:D126  DF 00      			dw	VDC_VDW_224
  119    11:D128  0E         			db	VDC_VCR			; Vertical Display END position Register
  120    11:D129  FF 00      			dw	VDC_VCR_224
  121    11:D12B  0F         			db	VDC_DCR			; DMA Control Register
  122    11:D12C  10 00      			dw	$0010			;   Enable automatic VRAM->SATB
  123    11:D12E  13         			db	VDC_DVSSR		; VRAM->SATB address $7F00
  124    11:D12F  00 7F      			dw	.SAT_ADDR
  125    11:D131  07         			db	VDC_BXR			; Background X-Scroll Register
  126    11:D132  00 00      			dw	$0000
  127    11:D134  08         			db	VDC_BYR			; Background Y-Scroll Register
  128    11:D135  00 00      			dw	$0000
  129    11:D137  06         			db	VDC_RCR			; Raster Counter Register
  130    11:D138  00 00      			dw	$0000			;   Never occurs!
  131    11:D13A  05         			db	VDC_CR			; Control Register
  132    11:D13B  0C 00      			dw	$000C			;   Enable VSYNC & RCR IRQ
  133    11:D13D  00         			db	0
  134                        	
  135                        			.endp
  136                        	
  137                        	
  138                        	
  139                        	; ***************************************************************************
  140                        	; ***************************************************************************
  141                        	;
  142                        	; void __fastcall init_240x208( void );
  143                        	
  144                        	_init_240x208	.proc
  223                        			.endp
  224                        	
  225                        	
  226                        	
  227                        	; ***************************************************************************
  228                        	; ***************************************************************************
  229                        	;
  230                        	; void __fastcall _macro set_xres( unsigned int x_pixels<_ax> );
  231                        	; void __fastcall _macro sgx_set_xres( unsigned int x_pixels<_ax> );
  232                        	;
  233                        	; void __fastcall set_xres( unsigned int x_pixels<_ax>, unsigned char blur_flag<_bl> );
  234                        	; void __fastcall sgx_set_xres( unsigned int x_pixels<_ax>, unsigned char blur_flag<_bl> );
  235                        	;
  236                        	; blur_flag = XRES_SOFT (default if not specified), XRES_SHARP or XRES_KEEP
  237                        	
  238                        	set_xres_group	.procgroup			; These routines share code!
  337                        			.endprocgroup	; set_xres_group
  338                        	
  339                        	
  340                        	
  341                        	; ***************************************************************************
  342                        	; ***************************************************************************
  343                        	;
  344                        	; HuC VRAM Functions
  345                        	;
  346                        	; ***************************************************************************
  347                        	; ***************************************************************************
  348                        	
  349                        	
  350    11:D00E             	load_vram_group	.procgroup			; These routines share code!
  351                        	
  352                        	; ***************************************************************************
  353                        	; ***************************************************************************
  354                        	;
  355                        	; void __fastcall load_vram( unsigned int vram<_di>, unsigned char __far *data<_bp_bank:_bp>, unsigned int num_words<_ax> );
  356                        	; void __fastcall sgx_load_vram( unsigned int vram<_di>, unsigned char __far *data<_bp_bank:_bp>, unsigned int num_words<_ax> );
  357                        	;
  358                        	; void __fastcall far_load_vram( unsigned int vram<_di>, unsigned int num_words<_ax> );
  359                        	; void __fastcall sgx_far_load_vram( unsigned int vram<_di>, unsigned int num_words<_ax> );
  360                        	;
  361                        	; load_vram_sgx -  copy a block of memory to VRAM
  362                        	; load_vram_vdc -  copy a block of memory to VRAM
  363                        	;
  364                        	; _bp		= BAT memory location
  365                        	; _bp_bank	= BAT bank
  366                        	; _di		= VRAM base address
  367                        	; _ax		= nb of words to copy
  368                        	; ----
  369                        	; N.B. BAT data *must* be word-aligned!
  370                        	
  371               0000     		.ifndef	VRAM_XFER_SIZE
  373                        		.endif
  374                        	
  375    11:D00E             	load_vram_x	.proc
  376                        	
  377    11:D00E  43 08      			tma3
  378    11:D010  48         			pha
  379    11:D011  43 10      			tma4
  380    11:D013  48         			pha
  381                        	
  382    11:D014  A4 02      			ldy	<_bp_bank
  383    11:D016  20 3B E3   			jsr	map_bp_to_mpr34		; Map data to MPR3 & MPR4.
  384                        	
  385    11:D019  20 7F E3   			jsr	set_di_to_mawr
  386                        	
  387                        	;		tii	.vdc_tai, ram_tia, 8
  388                        	
  389               0001     		.if	SUPPORT_SGX
  390    11:D01C  8A         			txa				; Select which VDC to write
  391    11:D01D  1A         			inc	a			; to.
  392    11:D01E  1A         			inc	a
  393    11:D01F  8D F3 22   			sta.l	ram_tia_dst
  394                        		.endif
  395                        	
  396    11:D022  A9 10      			lda	#VRAM_XFER_SIZE		; Split into 16-byte chunks
  397    11:D024  8D F5 22   			sta.l	ram_tia_len		; for stable IRQ response.
  398                        	
  399    11:D027  A6 EC      			ldx.l	<_bp
  400    11:D029  8E F1 22   			stx.l	ram_tia_src
  401    11:D02C  A4 ED      			ldy.h	<_bp
  402    11:D02E  8C F2 22   			sty.h	ram_tia_src
  403                        	
  404    11:D031  A5 F8      			lda.l	<_ax			; Length in words.
  405    11:D033  48         			pha				; Preserve length.l
  406                        	
  407    11:D034  46 F9      			lsr.h	<_ax
  408    11:D036  6A         			ror	a
  409    11:D037  46 F9      			lsr.h	<_ax
  410    11:D039  6A         			ror	a
  411    11:D03A  46 F9      			lsr.h	<_ax
  412    11:D03C  6A         			ror	a
  413               0000     		.if	VRAM_XFER_SIZE == 32
  416                        		.endif
  417                        	
  418    11:D03D  22         			sax				; x=chunks-lo
  419    11:D03E  F0 1F      			beq	.next_block		; a=source-lo, y=source-hi
  420                        	
  421    11:D040  20 F0 22   	.chunk_loop:	jsr	ram_tia			; transfer 16-bytes
  422                        	
  423    11:D043  18         			clc				; increment source
  424    11:D044  69 10      			adc	#VRAM_XFER_SIZE
  425    11:D046  8D F1 22   			sta.l	ram_tia_src
  426    11:D049  90 11      			bcc	.same_page
  427    11:D04B  C8         			iny
  428    11:D04C  10 0B      			bpl	.same_bank		; remap_data
  429                        	
  430    11:D04E  42         			say
  431    11:D04F  43 10      			tma4
  432    11:D051  53 08      			tam3
  433    11:D053  1A         			inc	a
  434    11:D054  53 10      			tam4
  435    11:D056  A9 60      			lda	#$60
  436    11:D058  42         			say
  437                        	
  438    11:D059  8C F2 22   	.same_bank:	sty.h	ram_tia_src
  439                        	
  440    11:D05C  CA         	.same_page:	dex
  441    11:D05D  D0 E1      			bne	.chunk_loop
  442                        	
  443    11:D05F  C6 F9      	.next_block:	dec.h	<_ax
  444    11:D061  10 DD      			bpl	.chunk_loop
  445                        	
  446    11:D063  68         			pla				; Restore length.l
  447    11:D064  29 07      			and	#VRAM_XFER_SIZE / 2 - 1
  448    11:D066  F0 07      			beq	.done
  449                        	
  450    11:D068  0A         			asl	a			; Convert words to bytes.
  451    11:D069  8D F5 22   			sta.l	ram_tia_len
  452                        	
  453    11:D06C  20 F0 22   			jsr	ram_tia			; transfer remainder
  454                        	
  455    11:D06F  68         	.done:		pla
  456    11:D070  53 10      			tam4
  457    11:D072  68         			pla
  458    11:D073  53 08      			tam3
  459                        	
  460                        			leave
         11:D075  4C EF FF   			jmp	leave_proc
  461                        	
  462                        			.endp
  463                        	
  464                        			.endprocgroup	; load_vram_group
  465                        	
  466                        	
  467                        	
  468                        	; ***************************************************************************
  469                        	; ***************************************************************************
  470                        	;
  471                        	; void __fastcall load_bat( unsigned int vram<_di>, unsigned char __far *data<_bp_bank:_bp>, unsigned char tiles_w<_al>, unsigned char tiles_h<_ah> );
  472                        	; void __fastcall sgx_load_bat( unsigned int vram<_di>, unsigned char __far *data<_bp_bank:_bp>, unsigned char tiles_w<_al>, unsigned char tiles_h<_ah> );
  473                        	;
  474                        	; void __fastcall far_load_bat( unsigned int vram<_di>, unsigned char tiles_w<_al>, unsigned char tiles_h<_ah> );
  475                        	; void __fastcall sgx_far_load_bat( unsigned int vram<_di>, unsigned char tiles_w<_al>, unsigned char tiles_h<_ah> );
  476                        	;
  477                        	; load_bat_sgx - transfer a BAT to VRAM
  478                        	; load_bat_vdc - transfer a BAT to VRAM
  479                        	;
  480                        	; transfer a BAT to VRAM
  481                        	; ----
  482                        	; _bp		= BAT memory location
  483                        	; _bp_bank	= BAT bank
  484                        	; _di		= VRAM base address
  485                        	; _al		= nb of column to copy
  486                        	; _ah		= nb of row
  487                        	; ----
  488                        	; N.B. BAT data *must* be word-aligned!
  489                        	
  490               20EC     	_gfx_load_bat_PARM_2	=	_bp
  491               20F0     	_gfx_load_bat_PARM_3	=	_di
  492               20F8     	_gfx_load_bat_PARM_4	=	_al
  493               20F9     	_gfx_load_bat_PARM_5	=	_ah
  494                        	
  495    11:D25A             	load_bat_group	.procgroup			; These routines share code!
  496                        	
  497               0001     		.if	SUPPORT_SGX
  498                        			.proc	_sgx_load_bat.4
  505                        			.endp
  506                        		.endif
  507                        	
  508    11:D25A             			.proc	_load_bat.4
  509    11:D25A             			.alias	_far_load_bat.3		= _load_bat.4
  510                        	
  511    11:D25A  82         			clx				; Offset to PCE VDC.
  512                        	
  513    11:D25B  43 08      			tma3
  514    11:D25D  48         			pha
  515                        	
  516    11:D25E  A4 02      			ldy	<_bp_bank
  517    11:D260  20 2D E3   			jsr	map_bp_to_mpr3		; Map data to MPR3.
  518                        	
  519    11:D263  A4 EC      			ldy.l	<_bp
  520    11:D265  64 EC      			stz.l	<_bp
  521                        	
  522    11:D267  20 7F E3   	.line_loop:	jsr	set_di_to_mawr
  523                        	
  524    11:D26A  A5 F8      			lda	<_al
  525    11:D26C  85 00      			sta	<__temp
  526    11:D26E  B1 EC      	.tile_loop:	lda	[_bp], y
  527    11:D270  9D 02 02   			sta	VDC_DL, x
  528    11:D273  C8         			iny
  529    11:D274  B1 EC      			lda	[_bp], y
  530    11:D276  9D 03 02   			sta	VDC_DH, x
  531    11:D279  C8         			iny
  532    11:D27A  D0 03      			bne	!+
  533    11:D27C  20 4C E3   			jsr	inc.h_bp_mpr3
  534    11:D27F  C6 00      	!:		dec	<__temp
  535    11:D281  D0 EB      			bne	.tile_loop
  536                        	
  537    11:D283  BD 70 26   			lda	vdc_bat_width, x
  538    11:D286  18         			clc
  539    11:D287  65 F0      			adc.l	<_di
  540    11:D289  85 F0      			sta.l	<_di
  541    11:D28B  90 02      			bcc	!+
  542    11:D28D  E6 F1      			inc.h	<_di
  543                        	
  544    11:D28F  C6 F9      	!:		dec	<_ah
  545    11:D291  D0 D4      			bne	.line_loop
  546                        	
  547    11:D293  68         			pla
  548    11:D294  53 08      			tam3
  549                        	
  550                        			leave
         11:D296  4C EF FF   			jmp	leave_proc
  551                        	
  552                        			.endp
  553                        	
  554                        			.endprocgroup	; load_bat_group
  555                        	
  556                        	
  557                        	
  558                        	; ***************************************************************************
  559                        	; ***************************************************************************
  560                        	;
  561                        	; void __fastcall load_palette( unsigned char palette<_al>, unsigned char __far *data<_bp_bank:_bp>, unsigned char num_palettes<_ah> );
  562                        	;
  563                        	; void __fastcall far_load_palette( unsigned char palette<_al>, unsigned char num_palettes<_ah> );
  564                        	
  565    11:D39F             			.proc	_load_palette.3
  566    11:D39F             			.alias	_far_load_palette.2	= _load_palette.3
  567                        	
  568    11:D39F  AC 47 26   			ldy	color_queue_w		; Get the queue's write index.
  569                        	
  570    11:D3A2  A5 EC      			lda.l	<_bp			; Add this set of palettes to
  571    11:D3A4  99 58 26   			sta	color_addr_l, y		; the queue.
  572    11:D3A7  A5 ED      			lda.h	<_bp
  573    11:D3A9  99 60 26   			sta	color_addr_h, y
  574    11:D3AC  A5 02      			lda	<_bp_bank
  575    11:D3AE  99 68 26   			sta	color_bank, y
  576    11:D3B1  A5 F8      			lda	<_al
  577    11:D3B3  99 48 26   			sta	color_index, y
  578    11:D3B6  A5 F9      			lda	<_ah
  579    11:D3B8  99 50 26   			sta	color_count, y
  580                        	
  581    11:D3BB  C8         			iny				; Increment the queue index.
  582    11:D3BC  98         			tya
  583    11:D3BD  29 07      			and	#7
  584                        	
  585    11:D3BF  CD 46 26   	.wait:		cmp	color_queue_r		; If the queue is full, wait
  586    11:D3C2  F0 FB      			beq	.wait			; for the next VBLANK.
  587                        	
  588    11:D3C4  8D 47 26   			sta	color_queue_w		; Signal item is in the queue.
  589                        	
  590                        			leave				; All done, phew!
         11:D3C7  4C EF FF   			jmp	leave_proc
  591                        	
  592                        			.endp
  593                        	
  594                        	
  595                        	
  596               0000     		.if	0
  620                        		.endif
  621                        	
  622                        	
  623                        	
  624                        	; ***************************************************************************
  625                        	; ***************************************************************************
  626                        	;
  627                        	; void __fastcall load_background( unsigned char __far *tiles<_bp_bank:_bp>, unsigned char __far *palettes<__fbank:__fptr>, unsigned char __far *bat<_cl:_bx>, unsigned char w<_dl>, unsigned char w<_dh> );
  628                        	
  629                        			.proc	_load_background.5
  667                        			.endp
  668                        	
  669                        	
  670                        	
  671                        	; ***************************************************************************
  672                        	; ***************************************************************************
  673                        	;
  674                        	; void __fastcall vram2vram( unsigned int vram_dst<_ax>, unsigned int vram_src<_bx>, unsigned int word_len<_cx> );
  675                        	; void __fastcall sgx_vram2vram( unsigned int vram_dst<_ax>, unsigned int vram_src<_bx>, unsigned int word_len<_cx> );
  676                        	;
  677                        	
  678               0001     		.if	SUPPORT_SGX
  679                        			.proc	_sgx_vram2vram.3
  685                        			.endp
  686                        		.endif
  687                        	
  688    11:D299             			.proc	_vram2vram.3
  689                        	
  690    11:D299  82         			clx				; Offset to PCE VDC.
  691                        	
  692    11:D29A  08         			php
  693    11:D29B  78         			sei
  694    11:D29C  A9 11      			lda	#VDC_DESR
  695    11:D29E  9D 00 02   			sta	VDC_AR, x
  696    11:D2A1  A5 F8      			lda.l	<_ax
  697    11:D2A3  9D 02 02   			sta	VDC_DL, x
  698    11:D2A6  A5 F9      			lda.h	<_ax
  699    11:D2A8  9D 03 02   			sta	VDC_DH, x
  700                        	
  701    11:D2AB  A9 10      			lda	#VDC_SOUR
  702    11:D2AD  9D 00 02   			sta	VDC_AR, x
  703    11:D2B0  A5 FA      			lda.l	<_bx
  704    11:D2B2  9D 02 02   			sta	VDC_DL, x
  705    11:D2B5  A5 FB      			lda.h	<_bx
  706    11:D2B7  9D 03 02   			sta	VDC_DH, x
  707                        	
  708    11:D2BA  A9 12      			lda	#VDC_LENR
  709    11:D2BC  9D 00 02   			sta	VDC_AR, x
  710    11:D2BF  18         			clc
  711    11:D2C0  A5 FC      			lda.l	<_cx
  712    11:D2C2  69 FF      			adc	#$FF
  713    11:D2C4  9D 02 02   			sta	VDC_DL, x
  714    11:D2C7  A5 FD      			lda.h	<_cx
  715    11:D2C9  69 FF      			adc	#$FF
  716    11:D2CB  9D 03 02   			sta	VDC_DH, x
  717                        	
  718    11:D2CE  B5 F7      			lda	<vdc_reg, x
  719    11:D2D0  8D 00 02   			sta	VDC_AR
  720    11:D2D3  28         			plp
  721                        	
  722                        			leave
         11:D2D4  4C EF FF   			jmp	leave_proc
  723                        	
  724                        			.endp
  725                        	
  726                        	
  727                        	
  728                        	; ***************************************************************************
  729                        	; ***************************************************************************
  730                        	;
  731                        	; HuC Font Functions
  732                        	;
  733                        	; ***************************************************************************
  734                        	; ***************************************************************************
  735                        	
  736                        	
  737                        	
  738               2690     			.bss
  739                        	
  740                        	; **************
  741                        	; 16-bytes of VDC BAT information.
  742                        	;
  743                        	; N.B. MUST be 16-bytes before the SGX versions to use PCE_VDC_OFFSET.
  744                        	
  745    F8:2690             	_vdc_font_base:	ds	2	; Tile number of ASCII '\0'.
  746                        	
  747                        	; From hucc-printf.asm just to avoid wasting .bss space with padding.
  748    F8:2692             	_vdc_tty_x_lhs:	ds	1	; TTY minimum X position.
  749    F8:2693             	_vdc_tty_y_top:	ds	1	; TTY minimum Y position.
  750    F8:2694             	_vdc_tty_x:	ds	1	; TTY current X position.
  751    F8:2695             	_vdc_tty_y:	ds	1	; TTY current Y position.
  752                        	
  753               0001     		.if	SUPPORT_SGX
  754                        	
  755                        	; **************
  756                        	; 16-bytes of SGX BAT information.
  757                        	;
  758                        	; N.B. MUST be 16-bytes after the VDC versions to use SGX_VDC_OFFSET.
  759                        	
  760    F8:2696             			ds	10	; Padding to ensure the 16-byte delta.
  761                        	
  762    F8:26A0             	_sgx_font_base:	ds	2	; Tile number of ASCII '\0'.
  763                        	
  764                        	; From hucc-printf.asm just to avoid wasting .bss space with padding.
  765    F8:26A2             	_sgx_tty_x_lhs:	ds	1	; TTY minimum X position.
  766    F8:26A3             	_sgx_tty_y_top:	ds	1	; TTY minimum Y position.
  767    F8:26A4             	_sgx_tty_x:	ds	1	; TTY current X position.
  768    F8:26A5             	_sgx_tty_y:	ds	1	; TTY current Y position.
  769                        	
  770                        		.endif
  771                        	
  772                        	;_font_base	.alias	vdc_font_base
  773                        	
  774               E5DF     			.code
  775                        	
  776                        	
  777                        	
  778                        	; ***************************************************************************
  779                        	; ***************************************************************************
  780                        	;
  781                        	; void __fastcall set_font_addr( unsigned int vram<acc> );
  782                        	; void __fastcall sgx_set_font_addr( unsigned int vram<acc> );
  783                        	
  784               0001     		.if	SUPPORT_SGX
  785    00:E5DF             	_sgx_set_font_addr.1:
  786    00:E5DF  A2 10      			ldx	#SGX_VDC_OFFSET		; Offset to SGX VDC.
  787    00:E5E1  F0         			db	$F0			; Turn "clx" into a "beq".
  788                        		.endif
  789                        	
  790    00:E5E2             	_set_font_addr.1:
  791    00:E5E2  82         			clx				; Offset to PCE VDC.
  792                        	
  793    00:E5E3  84 00      	set_font_addr:	sty	<__temp
  794    00:E5E5  46 00      			lsr	<__temp
  795    00:E5E7  6A         			ror	a
  796    00:E5E8  46 00      			lsr	<__temp
  797    00:E5EA  6A         			ror	a
  798    00:E5EB  46 00      			lsr	<__temp
  799    00:E5ED  6A         			ror	a
  800    00:E5EE  46 00      			lsr	<__temp
  801    00:E5F0  6A         			ror	a
  802    00:E5F1  38         			sec
  803    00:E5F2  E9 20      			sbc	#$20
  804    00:E5F4  9D 90 26   			sta.l	_vdc_font_base,x
  805    00:E5F7  B0 02      			bcs	!+
  806    00:E5F9  C6 00      			dec	<__temp
  807                        	
  808    00:E5FB  BD 91 26   	!:		lda.h	_vdc_font_base, x
  809    00:E5FE  29 F0      			and	#$F0
  810    00:E600  05 00      			ora	<__temp
  811    00:E602  9D 91 26   			sta.h	_vdc_font_base, x
  812    00:E605  60         			rts
  813                        	
  814                        	
  815                        	
  816                        	; ***************************************************************************
  817                        	; ***************************************************************************
  818                        	;
  819                        	; void __fastcall set_font_pal( unsigned char palette<acc> );
  820                        	; void __fastcall sgx_set_font_pal( unsigned char palette<acc> );
  821                        	
  822               0001     		.if	SUPPORT_SGX
  823    00:E606             	_sgx_set_font_pal.1:
  824    00:E606  A2 10      			ldx	#SGX_VDC_OFFSET		; Offset to SGX VDC.
  825    00:E608  F0         			db	$F0			; Turn "clx" into a "beq".
  826                        		.endif
  827                        	
  828    00:E609             	_set_font_pal:					; For compatibility with HuC.
  829    00:E609             	_set_font_pal.1:
  830    00:E609  82         			clx				; Offset to PCE VDC.
  831    00:E60A  0A         			asl	a
  832    00:E60B  0A         			asl	a
  833    00:E60C  0A         			asl	a
  834    00:E60D  0A         			asl	a
  835    00:E60E  85 00      			sta	<__temp
  836                        	
  837    00:E610  BD 91 26   			lda.h	_vdc_font_base, x
  838    00:E613  29 0F      			and	#$0F
  839    00:E615  05 00      			ora	<__temp
  840    00:E617  9D 91 26   			sta.h	_vdc_font_base, x
  841    00:E61A  60         			rts
  842                        	
  843                        	
  844                        	
  845                        	; ***************************************************************************
  846                        	; ***************************************************************************
  847                        	;
  848                        	; void __fastcall load_font( char far *font<_bp_bank:_bp>, unsigned char count<_al> );
  849                        	;
  850                        	; void __fastcall load_font( char far *font<_bp_bank:_bp>, unsigned char count<_al>, unsigned int vram<acc> );
  851                        	; void __fastcall sgx_load_font( char far *font<_bp_bank:_bp>, unsigned char count<_al>, unsigned int vram<acc> );
  852                        	;
  853                        	; void __fastcall far_load_font( unsigned char count<_al>, unsigned int vram<acc> );
  854                        	; void __fastcall sgx_far_load_font( unsigned char count<_al>, unsigned int vram<acc> );
  855                        	
  856    00:E61B  AC 74 26   	_load_font.2:	ldy	vdc_bat_limit		; Load the font directly
  857    00:E61E  C8         			iny				; after the BAT (stupid!).
  858    00:E61F  62         			cla
  859    00:E620  80 03      			bra	_load_font.3
  860                        	
  861               0001     		.if	SUPPORT_SGX
  862    00:E622             	_sgx_load_font.3:
  863    00:E622  A2 10      			ldx	#SGX_VDC_OFFSET		; Offset to SGX VDC.
  864    00:E624  F0         			db	$F0			; Turn "clx" into a "beq".
  865                        		.endif
  866                        	
  867    00:E625  82         	_load_font.3:	clx				; Offset to PCE VDC.
  868                        	
  869    00:E626  85 F0      			sta.l	<_di			; Load the font directly
  870    00:E628  84 F1      			sty.h	<_di			; after the BAT (stupid!).
  871                        	
  872    00:E62A  20 E3 E5   			jsr	set_font_addr		; Set xxx_font_base from addr.
  873                        	
  874    00:E62D  A5 F8      			lda	<__al			; Convert #tiles into #words.
  875    00:E62F  64 F9      			stz	<__ah
  876    00:E631  0A         			asl	a
  877    00:E632  26 F9      			rol	<__ah
  878    00:E634  0A         			asl	a
  879    00:E635  26 F9      			rol	<__ah
  880    00:E637  0A         			asl	a
  881    00:E638  26 F9      			rol	<__ah
  882    00:E63A  0A         			asl	a
  883    00:E63B  26 F9      			rol	<__ah
  884    00:E63D  85 F8      			sta	<__al
  885    00:E63F  4C 63 FF   			jmp	load_vram_x
  886                        	
  887    00:E642             			.alias	_far_load_font.2	= _load_font.3
  888    00:E642             			.alias	_sgx_far_load_font.2	= _sgx_load_font.3
  889                        	
  890                        	
  891                        	
  892                        	; ***************************************************************************
  893                        	; ***************************************************************************
  894                        	;
  895                        	; void __fastcall cls();
  896                        	; void __fastcall sgx_cls();
  897                        	;
  898                        	; void __fastcall cls( int tile<acc> );
  899                        	; void __fastcall sgx_cls( int tile<acc> );
  900                        	
  901               0001     		.if	SUPPORT_SGX
  902    00:E642  A2 10      	_sgx_cls:	ldx	#SGX_VDC_OFFSET		; Offset to SGX VDC.
  903    00:E644  F0         			db	$F0			; Turn "clx" into a "beq".
  904                        		.endif
  905                        	
  906    00:E645  82         	_cls:		clx				; Offset to PCE VDC.
  907                        	
  908    00:E646  BD 90 26   	clear_tty_x:	lda.l	_vdc_font_base, x
  909    00:E649  BC 91 26   			ldy.h	_vdc_font_base, x
  910    00:E64C  18         			clc
  911    00:E64D  69 20      			adc	#' '
  912    00:E64F  90 07      			bcc	!+
  913    00:E651  C8         			iny
  914    00:E652  80 04      			bra	!+
  915                        	
  916               0001     		.if	SUPPORT_SGX
  917    00:E654  A2 10      	_sgx_cls.1:	ldx	#SGX_VDC_OFFSET		; Offset to SGX VDC.
  918    00:E656  F0         			db	$F0			; Turn "clx" into a "beq".
  919                        		.endif
  920                        	
  921    00:E657  82         	_cls.1:		clx
  922                        	
  923    00:E658  85 F8      	!:		sta.l	<_ax			; VRAM word to write.
  924    00:E65A  84 F9      			sty.h	<_ax
  925    00:E65C  BD 74 26   			lda	vdc_bat_limit, x	; BAT size hi-byte.
  926    00:E65F  1A         			inc	a
  927    00:E660  85 FA      			sta	<_bl
  928    00:E662  4C DD FD   			jmp	clear_bat_x
  929                        	
  930                        	
  931                        	
  932                        	; ***************************************************************************
  933                        	; ***************************************************************************
  934                        	;
  935                        	; void __fastcall __macro load_default_font( void );
  936                        	; void __fastcall __macro sgx_load_default_font( void );
  937                        	;
  938                        	; Args: _bp, _bp_bank = _farptr to font data mapped into MPR3 & MPR4.
  939                        	; Args: _di = VRAM destination address.
  940                        	; Args: monofont_fg = font color (0..15)
  941                        	; Args: monofont_bg = background color (0..15)
  942                        	; Args: _al = number of tiles (aka characters) 0==256
  943                        	
  944    02:D07E             	huc_monofont_x	.proc
  945                        	
  946               26A6     			.bss
  947    F8:26A6             	monofont_fg:	.ds	1
  948    F8:26A7             	monofont_bg:	.ds	1
  949               D07E     			.code
  950                        	
  951    02:D07E  BC 74 26   			ldy	vdc_bat_limit, x	; BAT limit mask hi-byte.
  952    02:D081  C8         			iny
  953    02:D082  62         			cla
  954    02:D083  85 F0      			sta.l	<_di			; Load the font directly
  955    02:D085  84 F1      			sty.h	<_di			; after the BAT (stupid!).
  956                        	
  957    02:D087  20 E3 E5   			jsr	set_font_addr		; Set xxx_font_base from addr.
  958                        	
  959    02:D08A  A9 0E      			lda.l	#.font
  960    02:D08C  85 EC      			sta.l	<_bp
  961    02:D08E  A9 D1      			lda.h	#.font
  962    02:D090  85 ED      			sta.h	<_bp
  963                        	
  964    02:D092  A9 60      			lda	#$60			; #characters.
  965    02:D094  85 F8      			sta	<_al
  966                        	
  967    02:D096  20 7F E3   			jsr	set_di_to_mawr
  968                        	
  969    02:D099  AD A6 26   			lda	monofont_fg		; Foreground pixel color.
  970    02:D09C  85 00      			sta	<__temp
  971    02:D09E  AD A7 26   			lda	monofont_bg		; Background pixel color.
  972    02:D0A1  DA         			phx
  973    02:D0A2  A2 FC      			ldx.l	#_cx			; Create a bit mask for each
  974    02:D0A4  9E 00 20   	.bg_loop:	stz	$2000, x		; plane of the background.
  975    02:D0A7  4A         			lsr	a
  976    02:D0A8  90 03      			bcc	.bg_plane
  977    02:D0AA  DE 00 20   			dec	$2000, x
  978    02:D0AD  E8         	.bg_plane:	inx
  979    02:D0AE  D0 F4      			bne	.bg_loop
  980    02:D0B0  FA         			plx
  981                        	
  982    02:D0B1  C2         	.tile_loop:	cly
  983                        	
  984    02:D0B2  B1 EC      	.plane01:	lda	[_bp], y		; Get font byte.
  985    02:D0B4  8F 00 06   			bbs0	<__temp, .set_plane0
  986    02:D0B7  49 FF      	.clr_plane0:	eor	#$FF			; Clr font bits in background.
  987    02:D0B9  25 FC      			and	<_cx + 0
  988    02:D0BB  80 02      			bra	.put_plane0
  989    02:D0BD  05 FC      	.set_plane0:	ora	<_cx + 0		; Set font bits in background.
  990    02:D0BF  9D 02 02   	.put_plane0:	sta	VDC_DL, x
  991                        	
  992    02:D0C2  B1 EC      			lda	[_bp], y		; Get font byte.
  993    02:D0C4  9F 00 06   			bbs1	<__temp, .set_plane1
  994    02:D0C7  49 FF      	.clr_plane1:	eor	#$FF			; Clr font bits in background.
  995    02:D0C9  25 FD      			and	<_cx + 1
  996    02:D0CB  80 02      			bra	.put_plane1
  997    02:D0CD  05 FD      	.set_plane1:	ora	<_cx + 1		; Set font bits in background.
  998    02:D0CF  9D 03 02   	.put_plane1:	sta	VDC_DH, x
  999                        	
 1000    02:D0D2  C8         			iny
 1001    02:D0D3  C0 08      			cpy	#8
 1002    02:D0D5  90 DB      			bcc	.plane01
 1003                        	
 1004    02:D0D7  C2         			cly
 1005                        	
 1006    02:D0D8  B1 EC      	.plane23:	lda	[_bp], y		; Get font byte.
 1007    02:D0DA  AF 00 06   			bbs2	<__temp, .set_plane2
 1008    02:D0DD  49 FF      	.clr_plane2:	eor	#$FF			; Clr font bits in background.
 1009    02:D0DF  25 FE      			and	<_cx + 2
 1010    02:D0E1  80 02      			bra	.put_plane2
 1011    02:D0E3  05 FE      	.set_plane2:	ora	<_cx + 2		; Set font bits in background.
 1012    02:D0E5  9D 02 02   	.put_plane2:	sta	VDC_DL, x
 1013                        	
 1014    02:D0E8  B1 EC      			lda	[_bp], y		; Get font byte.
 1015    02:D0EA  BF 00 06   			bbs3	<__temp, .set_plane3
 1016    02:D0ED  49 FF      	.clr_plane3:	eor	#$FF			; Clr font bits in background.
 1017    02:D0EF  25 FF      			and	<_cx + 3
 1018    02:D0F1  80 02      			bra	.put_plane3
 1019    02:D0F3  05 FF      	.set_plane3:	ora	<_cx + 3		; Set font bits in background.
 1020    02:D0F5  9D 03 02   	.put_plane3:	sta	VDC_DH, x
 1021                        	
 1022    02:D0F8  C8         			iny
 1023    02:D0F9  C0 08      			cpy	#8
 1024    02:D0FB  90 DB      			bcc	.plane23
 1025                        	
 1026    02:D0FD  A5 EC      			lda.l	<_bp
 1027    02:D0FF  69 07      			adc	#8-1
 1028    02:D101  85 EC      			sta.l	<_bp
 1029    02:D103  90 02      			bcc	!+
 1030    02:D105  E6 ED      			inc.h	<_bp
 1031                        	
 1032    02:D107  C6 F8      	!:		dec	<_al
 1033    02:D109  D0 A6      			bne	.tile_loop
 1034                        	
 1035                        			leave				; All done, phew!
         02:D10B  4C EF FF   			jmp	leave_proc
 1036                        	
 1037    02:D10E             	.font:		incbin	"data/font8x8-bold-short-iso646-fr.dat", 128
 1038                        	
 1039                        			.endp
 1040                        	
 1041                        	
 1042                        	
 1043                        	; ***************************************************************************
 1044                        	; ***************************************************************************
 1045                        	;
 1046                        	; HuC Text Output
 1047                        	;
 1048                        	; ***************************************************************************
 1049                        	; ***************************************************************************
 1050                        	
 1051                        	
 1052                        	
 1053    11:CCB2             	vdc_tty_out	.procgroup			; These routines share code!
 1054                        	
 1055                        	; ***************************************************************************
 1056                        	; ***************************************************************************
 1057                        	;
 1058                        	; void __fastcall put_char( unsigned char digit<_bl>, unsigned char bat_x<_dil>, unsigned char bat_y<_dih> );
 1059                        	
 1060               0001     		.if	SUPPORT_SGX
 1061                        	put_char_sgx	.proc
 1067                        			.endp
 1068                        		.endif
 1069                        	
 1070    11:CCB2             	put_char_vdc	.proc
 1071                        	
 1072    11:CCB2  82         			clx				; Offset to PCE VDC.
 1073                        	
 1074    11:CCB3  20 34 E4   			jsr	set_di_xy_mawr
 1075                        	
 1076    11:CCB6  62         			cla				; Push EOL marker.
 1077    11:CCB7  48         			pha
 1078                        	
 1079    11:CCB8  A5 FA      			lda	<_bl
 1080    11:CCBA  48         			pha				; Push character to output.
 1081    11:CCBB  80 58      			bra	!output+
 1082                        	
 1083    11:CCBD             			.ref	put_hex_vdc		; Need put_number_vdc
 1084                        			.endp
 1085                        	
 1086    11:CCBD             			.alias	_put_char.3		= put_char_vdc
 1087                        	
 1088                        	
 1089                        	
 1090                        	; ***************************************************************************
 1091                        	; ***************************************************************************
 1092                        	;
 1093                        	; void __fastcall put_digit( unsigned char digit<_bl>, unsigned char bat_x<_dil>, unsigned char bat_y<_dih> );
 1094                        	
 1095               0001     		.if	SUPPORT_SGX
 1096                        	put_digit_sgx	.proc
 1102                        			.endp
 1103                        		.endif
 1104                        	
 1105    11:CCBD             	put_digit_vdc	.proc
 1106                        	
 1107    11:CCBD  82         			clx				; Offset to PCE VDC.
 1108                        	
 1109    11:CCBE  20 34 E4   			jsr	set_di_xy_mawr
 1110                        	
 1111    11:CCC1  62         			cla				; Push EOL marker.
 1112    11:CCC2  48         			pha
 1113                        	
 1114    11:CCC3  A5 FA      			lda	<_bl			; Convert hex digit to ASCII.
 1115    11:CCC5  29 0F      			and	#$0F
 1116    11:CCC7  C9 0A      			cmp	#10
 1117    11:CCC9  90 02      			bcc	!+
 1118    11:CCCB  69 06      			adc	#6
 1119    11:CCCD  69 30      	!:		adc	#'0'
 1120    11:CCCF  48         			pha				; Push character to output.
 1121    11:CCD0  80 43      			bra	!output+
 1122                        	
 1123    11:CCD2             			.ref	put_hex_vdc		; Need put_number_vdc
 1124                        			.endp
 1125                        	
 1126    11:CCD2             			.alias	_put_digit.3		= put_digit_vdc
 1127                        	
 1128                        	
 1129                        	
 1130                        	; ***************************************************************************
 1131                        	; ***************************************************************************
 1132                        	;
 1133                        	; void __fastcall put_hex( unsigned int number<_bx>, unsigned char length<_cl>, unsigned char bat_x<_dil>, unsigned char bat_y<_dih> );
 1134                        	
 1135               0001     		.if	SUPPORT_SGX
 1136                        	put_hex_sgx	.proc
 1141                        			.endp
 1142                        		.endif
 1143                        	
 1144    11:CCD2             	put_hex_vdc	.proc
 1145                        	
 1146    11:CCD2  82         			clx				; Offset to PCE VDC.
 1147                        	
 1148    11:CCD3  20 34 E4   			jsr	set_di_xy_mawr
 1149                        	
 1150    11:CCD6  A4 FC      			ldy	<_cl			; Total #characters to print,
 1151    11:CCD8  F0 3E      			beq	!exit+			; NOT minimum #characters!
 1152                        	
 1153    11:CCDA  86 00      			stx	<__temp			; Preserve which VDC.
 1154                        	
 1155    11:CCDC  82         			clx				; Push EOL marker.
 1156    11:CCDD  DA         			phx
 1157                        	
 1158    11:CCDE  B5 FA      	.hex_byte:	lda.l	<_bx, x			; Convert hex digit to ASCII.
 1159    11:CCE0  29 0F      			and	#$0F
 1160    11:CCE2  C9 0A      			cmp	#10
 1161    11:CCE4  90 02      			bcc	!+
 1162    11:CCE6  69 06      			adc	#6
 1163    11:CCE8  69 30      	!:		adc	#'0'
 1164    11:CCEA  48         			pha				; Push character to output.
 1165    11:CCEB  88         			dey
 1166    11:CCEC  F0 15      			beq	.hex_done
 1167                        	
 1168    11:CCEE  B5 FA      			lda.l	<_bx, x			; Convert hex digit to ASCII.
 1169    11:CCF0  4A         			lsr	a
 1170    11:CCF1  4A         			lsr	a
 1171    11:CCF2  4A         			lsr	a
 1172    11:CCF3  4A         			lsr	a
 1173    11:CCF4  C9 0A      			cmp	#10
 1174    11:CCF6  90 02      			bcc	!+
 1175    11:CCF8  69 06      			adc	#6
 1176    11:CCFA  69 30      	!:		adc	#'0'
 1177    11:CCFC  48         			pha				; Push character to output.
 1178    11:CCFD  88         			dey
 1179    11:CCFE  F0 03      			beq	.hex_done
 1180                        	
 1181    11:CD00  E8         			inx
 1182    11:CD01  80 DB      			bra	.hex_byte
 1183                        	
 1184    11:CD03  A6 00      	.hex_done:	ldx	<__temp			; Restore which VDC.
 1185    11:CD05  80 0E      			bra	!output+
 1186                        	
 1187    11:CD07  18         	.write:		clc
 1188    11:CD08  7D 90 26   			adc.l	_vdc_font_base, x
 1189    11:CD0B  9D 02 02   			sta	VDC_DL, x
 1190    11:CD0E  62         			cla
 1191    11:CD0F  7D 91 26   			adc.h	_vdc_font_base, x
 1192    11:CD12  9D 03 02   			sta	VDC_DH, x
 1193                        	
 1194    11:CD15  68         	!output:	pla				; Pop the digits and output.
 1195    11:CD16  D0 EF      			bne	.write
 1196                        	
 1197                        	!exit:		leave				; All done!
         11:CD18  4C EF FF   			jmp	leave_proc
 1198                        	
 1199                        			.endp
 1200                        	
 1201    11:CD1B             			.alias	_put_hex.4 = put_hex_vdc
 1202                        	
 1203                        	
 1204                        	
 1205                        	; ***************************************************************************
 1206                        	; ***************************************************************************
 1207                        	;
 1208                        	; void __fastcall put_number( unsigned int number<_bx>, unsigned char length<_cl>, unsigned char bat_x<_dil>, unsigned char bat_y<_dih> );
 1209                        	
 1210               0001     		.if	SUPPORT_SGX
 1211                        	put_number_sgx	.proc
 1216                        			.endp
 1217                        		.endif
 1218                        	
 1219    11:CD1B             	put_number_vdc	.proc
 1220                        	
 1221    11:CD1B  82         			clx				; Offset to PCE VDC.
 1222                        	
 1223    11:CD1C  20 34 E4   			jsr	set_di_xy_mawr
 1224                        	
 1225    11:CD1F  A4 FC      			ldy	<_cl			; Total #characters to print,
 1226    11:CD21  F0 F5      			beq	!exit-			; NOT minimum #characters!
 1227                        	
 1228    11:CD23  86 00      			stx	<__temp			; Preserve which VDC.
 1229                        	
 1230    11:CD25  82         			clx				; Push EOL marker.
 1231    11:CD26  DA         			phx
 1232                        	
 1233    11:CD27  A6 FB      			ldx.h	<_bx			; Is the number -ve?
 1234    11:CD29  86 FC      			stx	<_cl			; Remember this.
 1235    11:CD2B  10 10      			bpl	.divide_by_ten
 1236                        	
 1237    11:CD2D  38         			sec				; Make the number +ve.
 1238    11:CD2E  A5 FA      			lda.l	<_bx
 1239    11:CD30  49 FF      			eor	#$FF
 1240    11:CD32  69 00      			adc	#0
 1241    11:CD34  85 FA      			sta.l	<_bx
 1242    11:CD36  8A         			txa
 1243    11:CD37  49 FF      			eor	#$FF
 1244    11:CD39  69 00      			adc	#0
 1245    11:CD3B  85 FB      			sta.h	<_bx
 1246                        	
 1247    11:CD3D  A2 10      	.divide_by_ten:	ldx	#16
 1248    11:CD3F  62         			cla				; Clear Remainder.
 1249    11:CD40  06 FA      			asl.l	<_bx			; Rotate Dividend, MSB -> C.
 1250    11:CD42  26 FB      			rol.h	<_bx
 1251    11:CD44  2A         	.divide_loop:	rol	a			; Rotate C into Remainder.
 1252    11:CD45  C9 0A      			cmp	#10			; Test Divisor.
 1253    11:CD47  90 02      			bcc	.divide_less		; CC if Divisor > Remainder.
 1254    11:CD49  E9 0A      			sbc	#10			; Subtract Divisor.
 1255    11:CD4B  26 FA      	.divide_less:	rol.l	<_bx			; Quotient bit -> Dividend LSB.
 1256    11:CD4D  26 FB      			rol.h	<_bx			; Rotate Dividend, MSB -> C.
 1257    11:CD4F  CA         			dex
 1258    11:CD50  D0 F2      			bne	.divide_loop
 1259                        	
 1260    11:CD52  18         			clc
 1261    11:CD53  69 30      			adc	#'0'			; Always leaves C clr.
 1262    11:CD55  48         			pha				; Push character to output.
 1263    11:CD56  88         			dey
 1264    11:CD57  F0 10      			beq	!pad+
 1265    11:CD59  A5 FA      			lda.l	<_bx			; Repeat while non-zero.
 1266    11:CD5B  05 FB      			ora.h	<_bx
 1267    11:CD5D  D0 DE      			bne	.divide_by_ten
 1268                        	
 1269    11:CD5F  A6 00      			ldx	<__temp			; Restore which VDC.
 1270                        	
 1271    11:CD61  A5 FC      			lda	<_cl			; Was the number -ve?
 1272    11:CD63  10 04      			bpl	!pad+
 1273    11:CD65  A9 2D      			lda	#'-'			; Output a leading '-'.
 1274    11:CD67  48         			pha
 1275    11:CD68  88         			dey
 1276                        	
 1277    11:CD69  A9 20      	!pad:		lda	#' '			; Add padding characters.
 1278    11:CD6B  88         	.loop:		dey
 1279    11:CD6C  30 A7      			bmi	!output-
 1280    11:CD6E  48         			pha
 1281    11:CD6F  80 FA      			bra	.loop
 1282                        	
 1283    11:CD71             			.ref	put_hex_vdc		; Need put_number_vdc
 1284                        	
 1285                        			.endp
 1286                        	
 1287    11:CD71             			.alias	_put_number.4 = put_number_vdc
 1288                        	
 1289                        	
 1290                        	
 1291                        	; ***************************************************************************
 1292                        	; ***************************************************************************
 1293                        	;
 1294                        	; void __fastcall put_raw( unsigned int data<_bx>, unsigned char bat_x<_dil>, unsigned char bat_y<_dih> );
 1295                        	
 1296               0001     		.if	SUPPORT_SGX
 1297                        	put_raw_sgx	.proc
 1302                        			.endp
 1303                        		.endif
 1304                        	
 1305                        	put_raw_vdc	.proc
 1318                        			.endp
 1319                        	
 1320    11:CD71             			.alias	_put_raw.3		= put_raw_vdc
 1321                        	
 1322                        			.endprocgroup			; vdc_tty_out
 1323                        	
 1324                        	
 1325                        	
 1326                        	; ***************************************************************************
 1327                        	; ***************************************************************************
 1328                        	;
 1329                        	; void __fastcall put_string( unsigned char *string<_bp>, unsigned char bat_x<_dil>, unsigned char bat_y<_dih> );
 1330                        	;
 1331                        	; N.B. This is not a .proc right now because it is called from procedures
 1332                        	; that contain embedded strings, and the string aren't banked in before
 1333                        	; printing (yet).
 1334                        	
 1335               0001     		.if	SUPPORT_SGX
 1336    00:E665             	_sgx_put_string.3:
 1337    00:E665  A2 10      			ldx	#SGX_VDC_OFFSET		; Offset to SGX VDC.
 1338    00:E667  F0         			db	$F0			; Turn "clx" into a "beq".
 1339                        		.endif
 1340                        	
 1341    00:E668  82         	_put_string.3:	clx				; Offset to PCE VDC.
 1342                        	
 1343    00:E669  20 34 E4   			jsr	set_di_xy_mawr
 1344                        	
 1345    00:E66C  C2         			cly
 1346    00:E66D  B1 EC      	.chr_loop:	lda	[_bp], y
 1347    00:E66F  F0 15      			beq	.done
 1348                        	
 1349    00:E671  18         			clc
 1350    00:E672  7D 90 26   			adc.l	_vdc_font_base, x
 1351    00:E675  9D 02 02   			sta	VDC_DL, x
 1352    00:E678  62         			cla
 1353    00:E679  7D 91 26   			adc.h	_vdc_font_base, x
 1354    00:E67C  9D 03 02   			sta	VDC_DH, x
 1355                        	
 1356    00:E67F  C8         			iny
 1357    00:E680  D0 EB      			bne	.chr_loop
 1358    00:E682  E6 ED      			inc.h	<_bp
 1359    00:E684  80 E7      			bra	.chr_loop
 1360                        	
 1361    00:E686  60         	.done:		rts
 1362                        	
 1363                        	
 1364                        	
 1365                        	; ***************************************************************************
 1366                        	; ***************************************************************************
 1367                        	;
 1368                        	; void __fastcall set_color_rgb( unsigned int index<VCE_CTA>, unsigned char r<_al>, unsigned char g<_ah>, unsigned char b<acc> );
 1369                        	;
 1370                        	; r:	red	RED:	bit 3-5
 1371                        	; g:	green	GREEN:	bit 6-8
 1372                        	; b:	blue	BLUE:	bit 0-2
 1373                        	
 1374    00:E687             	_set_color_rgb.4:
 1375                        	;		and	#7
 1376    00:E687  85 00      			sta	<__temp
 1377    00:E689  A5 F8      			lda	<_al
 1378                        	;		and	#7
 1379    00:E68B  0A         			asl	a
 1380    00:E68C  0A         			asl	a
 1381    00:E68D  0A         			asl	a
 1382    00:E68E  05 00      			ora	<__temp
 1383    00:E690  0A         			asl	a
 1384    00:E691  0A         			asl	a
 1385    00:E692  85 00      			sta	<__temp
 1386    00:E694  A5 F9      			lda	<_ah
 1387                        	;		and	#7
 1388    00:E696  4A         			lsr	a
 1389    00:E697  66 00      			ror	<__temp
 1390    00:E699  4A         			lsr	a
 1391    00:E69A  66 00      			ror	<__temp
 1392    00:E69C  A8         			tay
 1393    00:E69D  A5 00      			lda	<__temp
 1394    00:E69F  8D 04 04   			sta.l	VCE_CTW
 1395    00:E6A2  8C 05 04   			sty.h	VCE_CTW
 1396    00:E6A5  60         			rts
                             #[2]   "..\..\..\include\hucc\hucc-final.asm"
   60                        		.endif
   61                        	
   62               0001     		.ifdef	HUCC_USES_STRING		; Set in hucc_string.h
                             #[3]   "..\..\..\include\hucc\hucc-string.asm"
   63                        			include	"hucc-string.asm"
    1                        	; ***************************************************************************
    2                        	; ***************************************************************************
    3                        	;
    4                        	; hucc-string.asm
    5                        	;
    6                        	; Not-quite-standard, but fast, replacements for <string.h>.
    7                        	;
    8                        	; Copyright John Brandwood 2024.
    9                        	;
   10                        	; Distributed under the Boost Software License, Version 1.0.
   11                        	; (See accompanying file LICENSE_1_0.txt or copy at
   12                        	;  http://www.boost.org/LICENSE_1_0.txt)
   13                        	;
   14                        	; ***************************************************************************
   15                        	; ***************************************************************************
   16                        	;
   17                        	; !!! WARNING : non-standard return values !!!
   18                        	;
   19                        	; Strings are limited to a maximum of 255 characters (+ the terminator)!
   20                        	;
   21                        	; The memcpy(), strcpy() and strcat() functions do NOT return the destination
   22                        	; address, and they are declared "void" to check that the value is not used.
   23                        	;
   24                        	; mempcpy() is provided which returns the end address instead of the starting
   25                        	; address, because this is typically more useful.
   26                        	;
   27                        	; Please note that both memcpy() and memset() are implemented using a TII for
   28                        	; speed, and so the length should be < 16 bytes if used in time-critical bits
   29                        	; of code (such as when using a split screen) because they delay interrupts.
   30                        	;
   31                        	; strncpy() and strncat() are not provided, because strncpy() was not created
   32                        	; for the purpose of avoiding string overruns, and strncat() is just a poorly
   33                        	; designed function.
   34                        	;
   35                        	; POSIX strlcpy() and strlcat() are provided instead, but once again they are
   36                        	; slightly non-standard in that the return value when there is an overflow is
   37                        	; the buffer size (so that the overflow can be detected), instead of the full
   38                        	; size of the destination string that was too big to fit in the buffer.
   39                        	;
   40                        	; ***************************************************************************
   41                        	; ***************************************************************************
   42                        	
   43                        	
   44                        	
   45                        	; ***************************************************************************
   46                        	; ***************************************************************************
   47                        	;
   48                        	; void __fastcall strcpy( char *destination<_di>, char *source<_bp> );
   49                        	; void __fastcall strcat( char *destination<_di>, char *source<_bp> );
   50                        	;
   51                        	; unsigned int __fastcall strlcpy( char *destination<_di>, char *source<_bp>, unsigned char size<acc> );
   52                        	; unsigned int __fastcall strlcat( char *destination<_di>, char *source<_bp>, unsigned char size<acc> );
   53                        	; unsigned int __fastcall strlen( char *source<_bp> );
   54                        	;
   55                        	; NOT WORKING YET (needs compiler changes) ...
   56                        	;
   57                        	; void __fastcall strcpy( char *destination<_di>, char __far *source<_bp_bank:_bp> );
   58                        	; void __fastcall strcat( char *destination<_di>, char __far *source<_bp_bank:_bp> );
   59                        	;
   60                        	; unsigned int __fastcall strlcpy( char *destination<_di>, char __far *source<_bp_bank:_bp>, unsigned char size<acc> );
   61                        	; unsigned int __fastcall strlcat( char *destination<_di>, char __far *source<_bp_bank:_bp>, unsigned char size<acc> );
   62                        	; unsigned int __fastcall strlen( char __far *source<_bp_bank:_bp> );
   63                        	
   64    00:E6A6  62         	_strcat:	cla				; Max string length == 256!
   65    00:E6A7  A0 01      			ldy.h	#256
   66                        	
   67    00:E6A9  AA         	_strlcat:	tax				; X = buffer length (1..256).
   68                        	
   69               0000     		.ifdef	_DEBUG
   74                        		.endif
   75                        	
   76    00:E6AA  43 08      			tma3				; Preserve MPR3 and MPR4.
   77    00:E6AC  48         			pha
   78    00:E6AD  43 10      			tma4
   79    00:E6AF  48         			pha
   80                        	
   81                        	;		ldy	<_bp_bank		; Map the source string.
   82                        	;		beq	.no_bank
   83                        	;		jsr	map_bp_to_mpr34
   84                        	
   85    00:E6B0  C2         	.no_bank:	cly
   86                        	
   87    00:E6B1  B1 F0      	.find:		lda	[_di], y		; Find the end of the string.
   88    00:E6B3  F0 08      			beq	.adjust
   89    00:E6B5  C8         			iny
   90    00:E6B6  CA         			dex
   91    00:E6B7  D0 F8      			bne	.find
   92    00:E6B9  98         			tya				; A:Y = buffer length.
   93    00:E6BA  62         			cla
   94    00:E6BB  80 28      			bra	str_overflow
   95                        	
   96    00:E6BD  98         	.adjust:	tya				; Subtract Y from _bp so that
   97    00:E6BE  49 FF      			eor	#$FF			; _bp and _di use the same Y.
   98    00:E6C0  38         			sec
   99    00:E6C1  65 EC      			adc.l	<_bp
  100    00:E6C3  85 EC      			sta.l	<_bp
  101    00:E6C5  B0 0F      			bcs	str_copy
  102    00:E6C7  C6 ED      			dec.h	<_bp
  103    00:E6C9  80 0B      			bra	str_copy
  104                        	
  105                        			;
  106                        	
  107    00:E6CB  62         	_strcpy:	cla				; Max string length == 256!
  108    00:E6CC  A0 01      			ldy.h	#256
  109                        	
  110    00:E6CE  AA         	_strlcpy:	tax				; X = buffer length (1..256).
  111                        	
  112               0000     		.ifdef	_DEBUG
  117                        		.endif
  118                        	
  119    00:E6CF  43 08      			tma3				; Preserve MPR3 and MPR4.
  120    00:E6D1  48         			pha
  121    00:E6D2  43 10      			tma4
  122    00:E6D4  48         			pha
  123                        	
  124                        	;		ldy	<_bp_bank		; Map the source string.
  125                        	;		beq	.no_bank
  126                        	;		jsr	map_bp_to_mpr34
  127                        	
  128    00:E6D5  C2         	.no_bank:	cly
  129                        	
  130    00:E6D6  B1 EC      	str_copy:	lda	[_bp], y
  131    00:E6D8  91 F0      			sta	[_di], y
  132    00:E6DA  F0 1E      			beq	str_exit		; A:Y = string length.
  133    00:E6DC  C8         			iny
  134    00:E6DD  CA         			dex
  135    00:E6DE  D0 F6      			bne	str_copy
  136                        	
  137    00:E6E0  88         			dey
  138    00:E6E1  62         			cla
  139    00:E6E2  91 F0      			sta	[_di], y
  140    00:E6E4  C8         			iny				; A:Y = buffer length.
  141    00:E6E5  D0 13      	str_overflow:	bne	str_exit
  142    00:E6E7  1A         			inc	a			; A:Y = buffer length = 256.
  143    00:E6E8  80 10      			bra	str_exit
  144                        	
  145                        			;
  146                        	
  147    00:E6EA  43 08      	_strlen:	tma3
  148    00:E6EC  48         			pha
  149    00:E6ED  43 10      			tma4
  150    00:E6EF  48         			pha
  151                        	
  152                        	;		ldy	<_bp_bank
  153                        	;		beq	.no_bank
  154                        	;		jsr	map_bp_to_mpr34
  155                        	
  156    00:E6F0  C2         	.no_bank:	cly
  157                        	
  158    00:E6F1  B1 EC      	.find:		lda	[_bp], y
  159    00:E6F3  F0 05      			beq	str_exit
  160    00:E6F5  C8         			iny
  161    00:E6F6  D0 F9      			bne	.find
  162    00:E6F8  A9 01      			lda.h	#256			; A:Y = overflow length = 256.
  163                        	
  164    00:E6FA  AA         	str_exit:	tax				; X:Y = string or buffer length.
  165                        	
  166    00:E6FB  68         			pla				; Restore MPR3 and MPR4.
  167    00:E6FC  53 10      			tam4
  168    00:E6FE  68         			pla
  169    00:E6FF  53 08      			tam3
  170                        	
  171    00:E701  8A         			txa				; A:Y = string or buffer length.
  172    00:E702  42         			say				; Y:A = string or buffer length.
  173                        	
  174    00:E703  60         			rts
  175                        	
  176    00:E704             			.alias	_strlen.1		= _strlen
  177    00:E704             			.alias	_strcpy.2		= _strcpy
  178    00:E704             			.alias	_strcat.2		= _strcat
  179    00:E704             			.alias	_strlcpy.3		= _strlcpy
  180    00:E704             			.alias	_strlcat.3		= _strlcat
  181                        	
  182                        	
  183                        	
  184                        	; ***************************************************************************
  185                        	; ***************************************************************************
  186                        	;
  187                        	; void __fastcall memcpy( unsigned char *destination<ram_tii_dst>, unsigned char  *source<ram_tii_src>, unsigned int count<acc> );
  188                        	; unsigned char * __fastcall mempcpy( unsigned char *destination<ram_tii_dst>, unsigned char  *source<ram_tii_src>, unsigned int count<acc> );
  189                        	;
  190                        	; void __fastcall farmemcpy( unsigned char *destination<ram_tii_dst>, unsigned char __far *source<_bp_bank:ram_tii_src>, unsigned int count<acc> );
  191                        	; unsigned char * __fastcall farmempcpy( unsigned char *destination<ram_tii_dst>, unsigned char __far *source<_bp_bank:ram_tii_src>, unsigned int count<acc> );
  192                        	;
  193                        	; void __fastcall far_memcpy( unsigned char *destination<ram_tii_dst>, unsigned int count<acc> );
  194                        	; unsigned char * __fastcall far_mempcpy( unsigned char *destination<ram_tii_dst>, unsigned int count<acc> );
  195                        	;
  196                        	
  197    00:E704             	_memcpy.3:
  198    00:E704  64 02      	_mempcpy.3:	stz	<_bp_bank		; Map the source memory.
  199                        	
  200    00:E706             	_farmemcpy.3:
  201    00:E706  8C FE 22   	_farmempcpy.3:	sty.h	ram_tii_len		; Check for zero length.
  202    00:E709  8D FD 22   			sta.l	ram_tii_len
  203    00:E70C  0D FE 22   			ora.h	ram_tii_len
  204    00:E70F  F0 18      			beq	.zero_length
  205                        	
  206    00:E711  43 08      			tma3				; Preserve MPR3 and MPR4.
  207    00:E713  48         			pha
  208    00:E714  43 10      			tma4
  209    00:E716  48         			pha
  210                        	
  211    00:E717  A5 02      			lda	<_bp_bank		; Map the source memory.
  212    00:E719  F0 05      			beq	.no_bank
  213                        	
  214    00:E71B  53 08      			tam3				; Put bank into MPR3.
  215    00:E71D  1A         			inc	a
  216    00:E71E  53 10      			tam4				; Put next into MPR4.
  217                        	
  218                        	;		lda.h	ram_tii_src		; Remap ptr to MPR3.
  219                        	;		and	#$1F
  220                        	;		ora	#$60
  221                        	;		sta.h	ram_tii_src
  222                        	
  223    00:E720  20 F8 22   	.no_bank:	jsr	ram_tii			; Copy the memory.
  224                        	
  225    00:E723  68         			pla				; Restore MPR3 and MPR4.
  226    00:E724  53 10      			tam4
  227    00:E726  68         			pla
  228    00:E727  53 08      			tam3
  229                        	
  230    00:E729  18         	.zero_length:	clc				; Return the end address
  231    00:E72A  AD FB 22   			lda.l	ram_tii_dst		; like mempcpy().
  232    00:E72D  6D FD 22   			adc.l	ram_tii_len
  233    00:E730  A8         			tay
  234    00:E731  AD FC 22   			lda.h	ram_tii_dst
  235    00:E734  6D FE 22   			adc.h	ram_tii_len
  236    00:E737  42         			say
  237                        	
  238    00:E738  60         			rts
  239                        	
  240    00:E739             			.alias	_far_memcpy.2		= _farmemcpy.3
  241    00:E739             			.alias	_far_mempcpy.2		= _farmempcpy.3
  242                        	
  243                        	
  244                        	
  245                        	; ***************************************************************************
  246                        	; ***************************************************************************
  247                        	;
  248                        	; void __fastcall memset( unsigned char *destination<ram_tii_src>, unsigned char value<_al>, unsigned int count<acc> );
  249                        	
  250    00:E739  C9 00      	_memset:	cmp	#0			; Decrement the length, check
  251    00:E73B  D0 05      			bne	!+			; for zero and set C. 
  252    00:E73D  C0 00      			cpy	#0
  253    00:E73F  F0 23      			beq	.zero_length
  254    00:E741  88         			dey
  255    00:E742  3A         	!:		dec	a
  256    00:E743  8D FD 22   			sta.l	ram_tii_len
  257    00:E746  8C FE 22   			sty.h	ram_tii_len
  258                        	
  259    00:E749  AD F9 22   			lda.l	ram_tii_src		; ram_tii_dst = ram_tii_src + 1
  260    00:E74C  85 88      			sta.l	<__ptr
  261    00:E74E  69 00      			adc	#0
  262    00:E750  8D FB 22   			sta.l	ram_tii_dst
  263    00:E753  AD FA 22   			lda.h	ram_tii_src
  264    00:E756  85 89      			sta.h	<__ptr
  265    00:E758  69 00      			adc	#0
  266    00:E75A  8D FC 22   			sta.h	ram_tii_dst
  267                        	
  268    00:E75D  A5 F8      			lda	<_al			; Set the fill value.
  269    00:E75F  92 88      			sta	[__ptr]
  270                        	
  271    00:E761  4C F8 22   			jmp	ram_tii			; Copy the memory.
  272                        	
  273    00:E764  60         	.zero_length:	rts
  274                        	
  275    00:E765             			.alias	_memset.3		= _memset
  276                        	
  277                        	
  278                        	
  279                        	; ***************************************************************************
  280                        	; ***************************************************************************
  281                        	;
  282                        	; int __fastcall strcmp( char *string1<_di>, char *string2<_bp> );
  283                        	; int __fastcall strncmp( char *string1<_di>, char *string2<_bp>, unsigned int count<_ax> );
  284                        	;
  285                        	; int __fastcall __macro memcmp( unsigned char *string1<_di>, unsigned char *string2<_bp>, unsigned int count<_ax> );
  286                        	; int __fastcall farmemcmp( unsigned char *string1<_di>, unsigned char __far *string2<_bp_bank:_bp>, unsigned int count<_ax> );
  287                        	; int __fastcall far_memcmp( unsigned char *string1<_di>, unsigned int count<_ax> );
  288                        	;
  289                        	;  0 	if strings are equal
  290                        	;  1 	if the first non-matching character in string1 > string2 (in ASCII).
  291                        	; -1 	if the first non-matching character in string1 < string2 (in ASCII).
  292                        	
  293    11:D13E             	hucc_memcmp	.procgroup
  294                        	
  295                        	_strcmp.2	.proc
  300                        			.endp				; Fall through.
  301                        	
  302    11:D13E             	_strncmp.3	.proc
  303    11:D13E  64 02      			stz	<_bp_bank		; Assume strings are mapped.
  304    11:D140  89 40      			bit	#$40			; Set the V bit for strcmp.
  305    11:D142  50         			db	$50			; Turn "clv" into "bvc".
  306    11:D143             			.ref	_farmemcmp.3		; Don't strip _farmemcmp.3!
  307                        			.endp				; Fall through.
  308                        	
  309    11:D143             	_farmemcmp.3	.proc
  310    11:D143  B8         			clv				; Clr the V bit for memcmp.
  311                        	
  312    11:D144  43 08      			tma3				; Preserve MPR3 and MPR4.
  313    11:D146  48         			pha
  314    11:D147  43 10      			tma4
  315    11:D149  48         			pha
  316                        	
  317    11:D14A  A4 02      			ldy	<_bp_bank		; Map string2.
  318    11:D14C  F0 03      			beq	.no_bank
  319                        	
  320    11:D14E  20 3B E3   			jsr	map_bp_to_mpr34
  321                        	
  322    11:D151  C2         	.no_bank:	cly
  323                        	
  324    11:D152  A6 F8      			ldx.l	<_ax			; Increment length.l
  325    11:D154  E8         			inx
  326    11:D155  CA         	.loop:		dex				; Decrement length.l
  327    11:D156  F0 17      			beq	.page
  328    11:D158  B1 F0      	.test:		lda	[_di], y		; string1 - string2
  329    11:D15A  D1 EC      			cmp	[_bp], y
  330    11:D15C  90 1E      			bcc	.return_neg		; string1 < string2 
  331    11:D15E  D0 17      			bne	.return_pos		; string1 > string2
  332    11:D160  50 04      			bvc	!+			; Only check for end-of-string
  333    11:D162  C9 00      			cmp	#0			; if the V flag is set.
  334    11:D164  F0 0D      			beq	.return_same
  335    11:D166  C8         	!:		iny
  336    11:D167  D0 EC      			bne	.loop
  337    11:D169  E6 F1      			inc.h	<_di
  338    11:D16B  E6 ED      			inc.h	<_bp			; Limited to 8KB maximum!
  339                        	;		jsr	inc.h_bp_mpr34
  340    11:D16D  80 E6      			bra	.loop
  341                        	
  342    11:D16F  C6 F9      	.page:		dec.h	<_ax			; Decrement length.h 
  343    11:D171  10 E5      			bpl	.test			; Limit comparison to 32KB.
  344                        	;		bra	cmp_same
  345                        	
  346    11:D173  82         	.return_same:	clx				; Return code in Y:X, X -> A.
  347    11:D174  C2         			cly
  348    11:D175  80 09      			bra	!+
  349                        	
  350    11:D177  A2 01      	.return_pos:	ldx	#$01			; Return code in Y:X, X -> A.
  351    11:D179  C2         			cly
  352    11:D17A  80 04      			bra	!+
  353                        	
  354    11:D17C  A2 FF      	.return_neg:	ldx	#$FF			; Return code in Y:X, X -> A.
  355    11:D17E  A0 FF      			ldy	#$FF
  356                        	
  357    11:D180  68         	!:		pla				; Restore MPR3 and MPR4.
  358    11:D181  53 10      			tam4
  359    11:D183  68         			pla
  360    11:D184  53 08      			tam3
  361                        	
  362                        			leave				; Return and copy X -> A.
         11:D186  4C EF FF   			jmp	leave_proc
  363                        	
  364                        			.endp
  365                        	
  366                        			.endprocgroup			; hucc_memcmp
  367                        	
  368    00:E765             			.alias	_far_memcmp.2		= _farmemcmp.3
                             #[2]   "..\..\..\include\hucc\hucc-final.asm"
   64                        		.endif
   65                        	
   66               0001     		.ifdef	HUCC_USES_NEW_SCROLL		; Set in hucc_scroll.h
                             #[3]   "..\..\..\include\hucc\hucc-scroll.asm"
   67                        			include	"hucc-scroll.asm"
    1                        	; ***************************************************************************
    2                        	; ***************************************************************************
    3                        	;
    4                        	; hucc-scroll.asm
    5                        	;
    6                        	; Routines for a fast split-screen scrolling system.
    7                        	;
    8                        	; Copyright John Brandwood 2024.
    9                        	;
   10                        	; Distributed under the Boost Software License, Version 1.0.
   11                        	; (See accompanying file LICENSE_1_0.txt or copy at
   12                        	;  http://www.boost.org/LICENSE_1_0.txt)
   13                        	;
   14                        	; ***************************************************************************
   15                        	; ***************************************************************************
   16                        	;
   17                        	; The maximum number of splits for each screen layer is set in your project's
   18                        	; "hucc-config.inc" file, with the library having a limit of 128-per-layer.
   19                        	;
   20                        	; Your first active split must be defined to start at screen line 0, and then
   21                        	; the rest of the active splits must be in increasing line order to match the
   22                        	; way that the PC Engine displays the output image.
   23                        	;
   24                        	; You can have disabled splits interleaved with your active splits.
   25                        	;
   26                        	; Splits that are normally disabled can be used to create full screen effects
   27                        	; such as bouncing the screen up and down by adding blank areas at the top or
   28                        	; bottom of the screen, and then rapidly changing the height of those areas.
   29                        	;
   30                        	; ***************************************************************************
   31                        	; ***************************************************************************
   32                        	
   33                        	
   34                        	
   35               0000     		.ifndef	HUCC_PCE_SPLITS
   37                        		.endif
   38                        	
   39               0000     		.ifndef	HUCC_SGX_SPLITS
   41                        		.endif
   42                        	
   43               0000     		.if	(HUCC_PCE_SPLITS < 2) || (HUCC_PCE_SPLITS > 128)
   45                        		.endif
   46                        	
   47               0000     		.if	(HUCC_SGX_SPLITS < 2) || (HUCC_SGX_SPLITS > 128)
   49                        		.endif
   50                        	
   51               0144     	HUCC_1ST_RCR	=	$144
   52               00E0     	HUCC_SCR_HEIGHT	=	224
   53                        	
   54               E765     			.code
   55                        	
   56                        	
   57                        	
   58                        	; ***************************************************************************
   59                        	; ***************************************************************************
   60                        	;
   61                        	; void __fastcall scroll_split( unsigned char index<_al>, unsigned char screen_line<_ah>, unsigned int bat_x<_bx>, unsigned int bat_y<_cx>, unsigned char display_flags<_dl> );
   62                        	; void __fastcall sgx_scroll_split( unsigned char index<_al>, unsigned char screen_line<_ah>, unsigned int bat_x<_bx>, unsigned int bat_y<_cx>, unsigned char display_flags<_dl> );
   63                        	;
   64                        	; set screen scrolling
   65                        	
   66                        			.proc	_scroll_split.5
  143                        			.endp
  144                        	
  145               0001     		.if	SUPPORT_SGX
  146                        	
  147    11:CE16             			.proc	_sgx_scroll_split.5
  148                        	
  149    11:CE16  08         			php				; Disable interrupts while
  150    11:CE17  78         			sei				; updating this structure.
  151                        	
  152    11:CE18  A6 F8      			ldx	<_al			; Region number.
  153    11:CE1A  E0 08      			cpx	#HUCC_SGX_SPLITS
  154    11:CE1C  B0 FE      	.hang:		bcs	.hang			; Better a hang than a crash!
  155                        	
  156    11:CE1E  BD 29 27   			lda	sgx_region_sel, x	; Update the parameter copy
  157    11:CE21  5D 31 27   			eor	sgx_region_new, x	; that is not displayed now.
  158    11:CE24  D0 3B      			bne	.regionA
  159                        	
  160    11:CE26  A5 F9      	.regionB:	lda	<_ah			; Scanline (i.e. top).
  161    11:CE28  C9 E0      			cmp	#HUCC_SCR_HEIGHT	; Skip if offscreen.
  162    11:CE2A  B0 31      			bcs	!done+
  163    11:CE2C  9D 51 27   			sta	sgx_regionB_rcr, x
  164                        	
  165    11:CE2F  C9 00      			cmp	#0			; Either Y at top of the frame
  166    11:CE31  F0 01      			beq	!+			; or Y-1 because the RCR code
  167    11:CE33  18         			clc				; sets it on the line before.
  168    11:CE34  A5 FC      	!:		lda.l	<_cx
  169    11:CE36  E9 00      			sbc	#0
  170    11:CE38  9D 81 27   			sta	sgx_regionB_yl, x
  171    11:CE3B  A5 FD      			lda.h	<_cx
  172    11:CE3D  E9 00      			sbc	#0
  173    11:CE3F  9D 91 27   			sta	sgx_regionB_yh, x
  174                        	
  175    11:CE42  A5 FA      			lda.l	<_bx
  176    11:CE44  9D 61 27   			sta	sgx_regionB_xl, x
  177    11:CE47  A5 FB      			lda.h	<_bx
  178    11:CE49  9D 71 27   			sta	sgx_regionB_xh, x
  179                        	
  180    11:CE4C  A5 FE      			lda	<_dl
  181    11:CE4E  29 C0      			and	#$C0			; Flags (mark it as enabled).
  182    11:CE50  09 0C      			ora	#$0C
  183    11:CE52  9D 41 27   			sta	sgx_regionB_crl, x
  184                        	
  185    11:CE55  A9 01      			lda	#1			; Mark that we've changed the
  186    11:CE57  9D 31 27   			sta	sgx_region_new, x	; selected region.
  187    11:CE5A  9D 29 27   			sta	sgx_region_sel, x
  188                        	
  189    11:CE5D  28         	!done:		plp				; Restore interrupts.
  190                        			leave				; All done!
         11:CE5E  4C EF FF   			jmp	leave_proc
  191                        	
  192    11:CE61  A5 F9      	.regionA:	lda	<_ah			; Scanline (i.e. top).
  193    11:CE63  C9 E0      			cmp	#HUCC_SCR_HEIGHT	; Skip if offscreen.
  194    11:CE65  B0 31      			bcs	!done+
  195    11:CE67  9D 49 27   			sta	sgx_regionA_rcr, x
  196                        	
  197    11:CE6A  C9 00      			cmp	#0			; Either Y at top of the frame
  198    11:CE6C  F0 01      			beq	!+			; or Y-1 because the RCR code
  199    11:CE6E  18         			clc				; sets it on the line before.
  200    11:CE6F  A5 FC      	!:		lda.l	<_cx
  201    11:CE71  E9 00      			sbc	#0
  202    11:CE73  9D 79 27   			sta	sgx_regionA_yl, x
  203    11:CE76  A5 FD      			lda.h	<_cx
  204    11:CE78  E9 00      			sbc	#0
  205    11:CE7A  9D 89 27   			sta	sgx_regionA_yh, x
  206                        	
  207    11:CE7D  A5 FA      			lda.l	<_bx
  208    11:CE7F  9D 59 27   			sta	sgx_regionA_xl, x
  209    11:CE82  A5 FB      			lda.h	<_bx
  210    11:CE84  9D 69 27   			sta	sgx_regionA_xh, x
  211                        	
  212    11:CE87  A5 FE      			lda	<_dl
  213    11:CE89  29 C0      			and	#$C0			; Flags (mark it as enabled).
  214    11:CE8B  09 0C      			ora	#$0C
  215    11:CE8D  9D 39 27   			sta	sgx_regionA_crl, x
  216                        	
  217    11:CE90  A9 01      			lda	#1			; Mark that we've changed the
  218    11:CE92  9D 31 27   			sta	sgx_region_new, x	; selected region.
  219    11:CE95  9E 29 27   			stz	sgx_region_sel, x
  220                        	
  221    11:CE98  28         	!done:		plp				; Restore interrupts.
  222                        			leave				; All done!
         11:CE99  4C EF FF   			jmp	leave_proc
  223                        	
  224                        			.endp
  225                        	
  226                        		.endif	SUPPORT_SGX
  227                        	
  228                        	
  229                        	
  230                        	; ***************************************************************************
  231                        	; ***************************************************************************
  232                        	;
  233                        	; void __fastcall disable_split( unsigned char index<acc> );
  234                        	; void __fastcall sgx_disable_split( unsigned char index<acc> );
  235                        	;
  236                        	; disable screen scrolling for a scroll region
  237                        	
  238    00:E765             	_disable_split.1:
  239    00:E765  08         			php				; Disable interrupts while
  240    00:E766  78         			sei				; updating this structure.
  241                        	
  242    00:E767  C9 08      			cmp	#HUCC_PCE_SPLITS	; Better a hang than a crash!
  243    00:E769  B0 FE      	.hang:		bcs	.hang
  244    00:E76B  AA         			tax
  245                        	
  246    00:E76C  BD A8 26   			lda	vdc_region_sel, x	; Update the parameter copy
  247    00:E76F  5D B0 26   			eor	vdc_region_new, x	; that is not displayed now.
  248    00:E772  D0 0D      			bne	.regionA
  249                        	
  250    00:E774  9E C0 26   	.regionB:	stz	vdc_regionB_crl, x	; Region disabled if $00.
  251                        	
  252    00:E777  A9 01      			lda	#1			; Mark that we've changed the
  253    00:E779  9D B0 26   			sta	vdc_region_new, x	; selected region.
  254    00:E77C  9D A8 26   			sta	vdc_region_sel, x
  255                        	
  256    00:E77F  28         			plp				; Restore interrupts.
  257    00:E780  60         			rts
  258                        	
  259    00:E781  9E B8 26   	.regionA:	stz	vdc_regionA_crl, x	; Region disabled if $00.
  260                        	
  261    00:E784  A9 01      			lda	#1			; Mark that we've changed the
  262    00:E786  9D B0 26   			sta	vdc_region_new, x	; selected region.
  263    00:E789  9E A8 26   			stz	vdc_region_sel, x
  264                        	
  265    00:E78C  28         			plp				; Restore interrupts.
  266    00:E78D  60         			rts
  267                        	
  268               0001     		.if	SUPPORT_SGX
  269                        	
  270    00:E78E             	_sgx_disable_split.1:
  271    00:E78E  08         			php				; Disable interrupts while
  272    00:E78F  78         			sei				; updating this structure.
  273                        	
  274    00:E790  C9 08      			cmp	#HUCC_SGX_SPLITS	; Better a hang than a crash!
  275    00:E792  B0 FE      	.hang:		bcs	.hang
  276    00:E794  AA         			tax
  277                        	
  278    00:E795  BD 29 27   			lda	sgx_region_sel, x	; Update the parameter copy
  279    00:E798  5D 31 27   			eor	sgx_region_new, x	; that is not displayed now.
  280    00:E79B  D0 0D      			bne	.regionA
  281                        	
  282    00:E79D  9E 41 27   	.regionB:	stz	sgx_regionB_crl, x	; Region disabled if $00.
  283                        	
  284    00:E7A0  A9 01      			lda	#1			; Mark that we've changed the
  285    00:E7A2  9D 31 27   			sta	sgx_region_new, x	; selected region.
  286    00:E7A5  9D 29 27   			sta	sgx_region_sel, x
  287                        	
  288    00:E7A8  28         			plp				; Restore interrupts.
  289    00:E7A9  60         			rts
  290                        	
  291    00:E7AA  9E 39 27   	.regionA:	stz	sgx_regionA_crl, x	; Region disabled if $00.
  292                        	
  293    00:E7AD  A9 01      			lda	#1			; Mark that we've changed the
  294    00:E7AF  9D 31 27   			sta	sgx_region_new, x	; selected region.
  295    00:E7B2  9E 29 27   			stz	sgx_region_sel, x
  296                        	
  297    00:E7B5  28         			plp				; Restore interrupts.
  298    00:E7B6  60         			rts
  299                        	
  300                        		.endif	SUPPORT_SGX
  301                        	
  302                        	
  303                        	
  304                        	; ***************************************************************************
  305                        	; ***************************************************************************
  306                        	;
  307                        	; vbl_init_scroll
  308                        	;
  309                        	; From Charles MacDonald's pcetech.txt ...
  310                        	;
  311                        	;  Raster Compare Register (RCR):
  312                        	;
  313                        	;  The range of the RCR is 263 lines, relative to the start of the active
  314                        	;  display period. (defined by VSW, VDS, and VCR) The VDC treats the first
  315                        	;  scanline of the active display period as $0040, so the valid ranges for
  316                        	;  the RCR register are $0040 to $0146.
  317                        	;
  318                        	;  For example, assume VSW=$02, VDS=$17. This positions the first line of
  319                        	;  the active display period at line 25 of the frame. An RCR value of $0040
  320                        	;  (zero) causes an interrupt at line 25, and a value of $0146 (262) causes an
  321                        	;  interrupt at line 24 of the next frame.
  322                        	;
  323                        	;  Any other RCR values that are out of range ($00-$3F, $147-$3FF) will never
  324                        	;  result in a successful line compare.
  325                        	;
  326                        	; Processing time:
  327                        	;
  328                        	; Old HuC rcr_init: 2148 cycles if all 8 regions pre-sorted
  329                        	; Old HuC rcr_init: 4346 cycles if all 8 regions need sorting
  330                        	;
  331                        	; New HuCC vbl_init_scroll:   8 disabled splits:  290 cycles
  332                        	; New HuCC vbl_init_scroll:   8  enabled splits:  384 cycles
  333                        	;
  334                        	; New HuCC vbl_init_scroll:  16 disabled splits:  506 cycles
  335                        	; New HuCC vbl_init_scroll:  16  enabled splits:  672 cycles
  336                        	;
  337                        	; New HuCC vbl_init_scroll:  32 disabled splits:  953 cycles
  338                        	; New HuCC vbl_init_scroll:  32  enabled splits: 1263 cycles
  339                        	;
  340                        	; New HuCC vbl_init_scroll:  64 disabled splits: 1802 cycles
  341                        	; New HuCC vbl_init_scroll:  64  enabled splits: 2400 cycles
  342                        	;
  343                        	; New HuCC vbl_init_scroll: 128 disabled splits: 3530 cycles
  344                        	; New HuCC vbl_init_scroll: 128  enabled splits: 4704 cycles
  345                        	;
  346                        	; Memory used is 16 bytes per scroll per VDC!
  347                        	
  348               26A8     			.bss
  349                        	
  350    F8:26A8             	vdc_region_sel:	.ds	HUCC_PCE_SPLITS		; Use A or B region next frame?
  351    F8:26B0             	vdc_region_new:	.ds	HUCC_PCE_SPLITS		; 1 if vdc_region_sel modified.
  352                        	
  353    F8:26B8             	vdc_regionA_crl:.ds	HUCC_PCE_SPLITS		; Two copies of each setting
  354    F8:26C0             	vdc_regionB_crl:.ds	HUCC_PCE_SPLITS		; HUCC_PCE_SPLITS bytes apart,
  355    F8:26C8             	vdc_regionA_rcr:.ds	HUCC_PCE_SPLITS		; one setting for the current
  356    F8:26D0             	vdc_regionB_rcr:.ds	HUCC_PCE_SPLITS		; frame, and one setting that
  357    F8:26D8             	vdc_regionA_xl:	.ds	HUCC_PCE_SPLITS		; gets modified and then used
  358    F8:26E0             	vdc_regionB_xl:	.ds	HUCC_PCE_SPLITS		; on the next frame after the
  359    F8:26E8             	vdc_regionA_xh:	.ds	HUCC_PCE_SPLITS		; change is made.
  360    F8:26F0             	vdc_regionB_xh:	.ds	HUCC_PCE_SPLITS		; Regions will have different
  361    F8:26F8             	vdc_regionA_yl:	.ds	HUCC_PCE_SPLITS		; A or B currently active!
  362    F8:2700             	vdc_regionB_yl:	.ds	HUCC_PCE_SPLITS
  363    F8:2708             	vdc_regionA_yh:	.ds	HUCC_PCE_SPLITS
  364    F8:2710             	vdc_regionB_yh:	.ds	HUCC_PCE_SPLITS
  365                        	
  366    F8:2718             	vdc_next_region:.ds	1			; Linked list of region indexes
  367    F8:2719             	vdc_regionA_nxt:.ds	HUCC_PCE_SPLITS		; for the current frame.
  368    F8:2721             	vdc_regionB_nxt:.ds	HUCC_PCE_SPLITS
  369                        	
  370               0001     		.if	SUPPORT_SGX
  371                        	
  372    F8:2729             	sgx_region_sel:	.ds	HUCC_SGX_SPLITS		; Use A or B region next frame?
  373    F8:2731             	sgx_region_new:	.ds	HUCC_SGX_SPLITS		; 1 if sgx_region_sel modified.
  374                        	
  375    F8:2739             	sgx_regionA_crl:.ds	HUCC_SGX_SPLITS		; Two copies of each setting
  376    F8:2741             	sgx_regionB_crl:.ds	HUCC_SGX_SPLITS		; HUCC_SGX_SPLITS bytes apart,
  377    F8:2749             	sgx_regionA_rcr:.ds	HUCC_SGX_SPLITS		; one setting for the current
  378    F8:2751             	sgx_regionB_rcr:.ds	HUCC_SGX_SPLITS		; frame, and one setting that
  379    F8:2759             	sgx_regionA_xl:	.ds	HUCC_SGX_SPLITS		; gets modified and then used
  380    F8:2761             	sgx_regionB_xl:	.ds	HUCC_SGX_SPLITS		; on the next frame after the
  381    F8:2769             	sgx_regionA_xh:	.ds	HUCC_SGX_SPLITS		; change is made.
  382    F8:2771             	sgx_regionB_xh:	.ds	HUCC_SGX_SPLITS		; Regions will have different
  383    F8:2779             	sgx_regionA_yl:	.ds	HUCC_SGX_SPLITS		; A or B currently active!
  384    F8:2781             	sgx_regionB_yl:	.ds	HUCC_SGX_SPLITS
  385    F8:2789             	sgx_regionA_yh:	.ds	HUCC_SGX_SPLITS
  386    F8:2791             	sgx_regionB_yh:	.ds	HUCC_SGX_SPLITS
  387                        	
  388    F8:2799             	sgx_next_region:.ds	1			; Linked list of region indexes
  389    F8:279A             	sgx_regionA_nxt:.ds	HUCC_SGX_SPLITS		; for the current frame.
  390    F8:27A2             	sgx_regionB_nxt:.ds	HUCC_SGX_SPLITS
  391                        	
  392                        		.endif
  393                        	
  394               E7B7     			.code
  395                        	
  396    11:CE9C             	vbl_init_scroll	.proc
  397                        	
  398    11:CE9C  62         			cla				; A = previous active index
  399    11:CE9D  A2 08      			ldx	#HUCC_PCE_SPLITS	; so $00 for end-of-screen.
  400                        	
  401    11:CE9F  18         			clc				; For regionB indexes.
  402                        	
  403    11:CEA0  CA         	!next_region:	dex				; All regions updated?
  404    11:CEA1  30 20      			bmi	!save_first+
  405                        	
  406    11:CEA3  9E B0 26   			stz	vdc_region_new, x	; Clear region modified flag.
  407                        	
  408    11:CEA6  BC A8 26   			ldy	vdc_region_sel, x	; 0=regionA or 1=regionB.
  409    11:CEA9  F0 0D      			beq	!use_regionA+
  410                        	
  411    11:CEAB  BC C0 26   	!use_regionB:	ldy	vdc_regionB_crl, x	; Region disabled if $00.
  412    11:CEAE  F0 F0      			beq	!next_region-
  413    11:CEB0  9D 21 27   			sta	vdc_regionB_nxt, x	; Save index of next region.
  414    11:CEB3  8A         			txa				; A = current region index.
  415    11:CEB4  69 08      			adc	#HUCC_PCE_SPLITS	; Always leaves CC!
  416    11:CEB6  80 E8      			bra	!next_region-
  417                        	
  418    11:CEB8  BC B8 26   	!use_regionA:	ldy	vdc_regionA_crl, x	; Region disabled if $00.
  419    11:CEBB  F0 E3      			beq	!next_region-
  420    11:CEBD  9D 19 27   			sta	vdc_regionA_nxt, x	; Save index of next region.
  421    11:CEC0  8A         			txa				; A = current region index.
  422    11:CEC1  80 DD      			bra	!next_region-
  423                        	
  424    11:CEC3  8D 18 27   	!save_first:	sta	vdc_next_region		; Save index of 1st region.
  425                        	
  426    11:CEC6  AA         			tax				; NZ if first active region
  427    11:CEC7  D0 03      			bne	!init_first+		; is not region 0.
  428    11:CEC9  98         			tya				; NZ if region 0 is active.
  429    11:CECA  F0 0F      			beq	!+			; If no active leave RCR=0.
  430                        	
  431    11:CECC  A9 06      	!init_first:	lda	#VDC_RCR		; 1st RCR always happens just
  432    11:CECE  8D 00 02   			sta	VDC_AR			; before the display starts.
  433    11:CED1  A9 44      			lda.l	#HUCC_1ST_RCR
  434    11:CED3  8D 02 02   			sta	VDC_DL
  435    11:CED6  A9 01      			lda.h	#HUCC_1ST_RCR
  436    11:CED8  8D 03 02   			sta	VDC_DH
  437                        	
  438               0001     		.if	SUPPORT_SGX
  439                        	
  440    11:CEDB  62         	!:		cla				; A = previous active index
  441    11:CEDC  A2 08      			ldx	#HUCC_SGX_SPLITS	; so $00 for end-of-screen.
  442                        	
  443    11:CEDE  18         			clc				; For regionB indexes.
  444                        	
  445    11:CEDF  CA         	!next_region:	dex				; All regions updated?
  446    11:CEE0  30 20      			bmi	!save_first+
  447                        	
  448    11:CEE2  9E 31 27   			stz	sgx_region_new, x	; Clear region modified flag.
  449                        	
  450    11:CEE5  BC 29 27   			ldy	sgx_region_sel, x	; 0=regionA or 1=regionB.
  451    11:CEE8  F0 0D      			beq	!use_regionA+
  452                        	
  453    11:CEEA  BC 41 27   	!use_regionB:	ldy	sgx_regionB_crl, x	; Region disabled if $00.
  454    11:CEED  F0 F0      			beq	!next_region-
  455    11:CEEF  9D A2 27   			sta	sgx_regionB_nxt, x	; Save index of next region.
  456    11:CEF2  8A         			txa				; A = current region index.
  457    11:CEF3  69 08      			adc	#HUCC_SGX_SPLITS	; Always leaves CC!
  458    11:CEF5  80 E8      			bra	!next_region-
  459                        	
  460    11:CEF7  BC 39 27   	!use_regionA:	ldy	sgx_regionA_crl, x	; Region disabled if $00.
  461    11:CEFA  F0 E3      			beq	!next_region-
  462    11:CEFC  9D 9A 27   			sta	sgx_regionA_nxt, x	; Save index of next region.
  463    11:CEFF  8A         			txa				; A = current region index.
  464    11:CF00  80 DD      			bra	!next_region-
  465                        	
  466    11:CF02  8D 99 27   	!save_first:	sta	sgx_next_region		; Save index of 1st region.
  467                        	
  468    11:CF05  AA         			tax				; NZ if first active region
  469    11:CF06  D0 03      			bne	!init_first+		; is not region 0.
  470    11:CF08  98         			tya				; NZ if region 0 is active.
  471    11:CF09  F0 0F      			beq	!+			; If no active leave RCR=0.
  472                        	
  473    11:CF0B  A9 06      	!init_first:	lda	#VDC_RCR		; 1st RCR always happens just
  474    11:CF0D  8D 10 02   			sta	SGX_AR			; before the display starts.
  475    11:CF10  A9 44      			lda.l	#HUCC_1ST_RCR
  476    11:CF12  8D 12 02   			sta	SGX_DL
  477    11:CF15  A9 01      			lda.h	#HUCC_1ST_RCR
  478    11:CF17  8D 13 02   			sta	SGX_DH
  479                        	
  480                        		.endif	SUPPORT_SGX
  481                        	
  482                        	!:		leave				; All done!
         11:CF1A  4C EF FF   			jmp	leave_proc
  483                        	
  484                        			.endp
  485                        	
  486                        	
  487                        	
  488               0001     		.if	SUPPORT_SGX
  489                        	
  490                        	; ***************************************************************************
  491                        	; ***************************************************************************
  492                        	;
  493                        	; VDC_RCR_MACRO and SGX_RCR_MACRO
  494                        	;
  495                        	; A 16-byte TIA takes 142..234 cycles in 5MHz, 128..200 cycles in 7MHz.
  496                        	; A 32-byte TIA takes 270..364 cycles in 5MHz, 242..312 cycles in 7MHz. (527 DUO)
  497                        	;
  498                        	; You need to write the last RCR setting within 540 cycles in order to catch
  499                        	; the next line (at 256/336/512 resolution).
  500                        	;
  501                        	; That gives 305 cycles from the RCR to write the last setting, or there
  502                        	; will be a visible glitch on the screen.
  503                        	
  504               0000     		.ifndef	USING_RCR_MACROS
  506                        		.endif
  507                        	
  508                        	;		;;;				; 8 (cycles for the INT)
  509                        	;		bbs1	<irq_vec, .hook		; 8
  510                        	;		jmp	[irq1_hook]		; 7
  511                        	
  512                        	;		;;;				; 8 (cycles for the INT)
  513                        	;		jmp	irq1_handler		; 4
  514                        	
  515                        	;irq1_handler:	pha				; 3 Save all registers.
  516                        	;		phx				; 3
  517                        	;		phy				; 3
  518                        	;
  519                        	;		lda	VDC_SR			; 6 Acknowledge the VDC's IRQ.
  520                        	;		sta	<vdc_sr			; 4 Remember what caused it.
  521                        	;
  522                        	;		ldx	SGX_SR			; 6 Read SGX_SR after VDC_SR in
  523                        	;		stx	<sgx_sr			; 4 case this is not an SGX!
  524                        	;
  525                        	;!:		and	#$04			; 2 Is this an HSYNC interrupt?
  526                        	;		beq	!+			; 2
  527                        	
  528                        			.macro	VDC_RCR_MACRO
  529                        	
  530                        			st0	#VDC_RCR		; 5
  531                        	
  532                        			ldx	vdc_next_region		; 5 X and Y can be greater than
  533                        			ldy	vdc_regionA_nxt, x	; 5 HUCC_PCE_SPLITS if regionB!
  534                        			clc				; 2
  535                        			bne	!set_next_rcr+		; 4 Stop RCR if next line is 0.
  536                        	
  537                        			and	const_0000		; 5 A=$00 with the same #cycles
  538                        			bra	!clr_next_rcr+		; 4 as if the branch were taken.
  539                        	
  540                        	!set_next_rcr:	lda	vdc_regionA_rcr, y	; 5 Set next RCR 1 line before
  541                        			adc	#64-1			; 2 the region begins, or 0 to
  542                        	!clr_next_rcr:	sta	VDC_DL			; 6 disable.
  543                        			cla				; 2
  544                        			rol	a			; 2
  545                        			sta	VDC_DH			; 6
  546                        	
  547                        			st0	#VDC_BYR		; 5 Do BYR first to mitigate the
  548                        			lda	vdc_regionA_yl, x	; 5 glitch if the IRQ is delayed.
  549                        			sta	VDC_DL			; 6 = 105 cycles from RCR on SGX
  550                        			lda	vdc_regionA_yh, x	; 5
  551                        			sta	VDC_DH			; 6
  552                        	
  553                        			st0	#VDC_CR			; 5
  554                        			lda	vdc_regionA_crl, x	; 5
  555                        	;		asl	a
  556                        			sta	VDC_DL			; 6
  557                        	
  558                        			st0	#VDC_BXR		; 2
  559                        			lda	vdc_regionA_xl, x	; 5
  560                        			sta	VDC_DL			; 6
  561                        			lda	vdc_regionA_xh, x	; 5
  562                        			sta	VDC_DH			; 6 = 156 cycles from RCR if DUO
  563                        	
  564                        	;		bcc	!+
  565                        	;		lda	vdc_regionA_yh, x	; 5
  566                        	;		sta.l	VCE_CTW			; 6
  567                        	
  568                        			sty	vdc_next_region		; 5
  569                        	
  570                        			.endm
  571                        	
  572                        	;!:		bbr2	<sgx_sr, !+		; 6 Is this an HSYNC interrupt?
  573                        	
  574                        			.macro	SGX_RCR_MACRO
  575                        	
  576                        			lda	#VDC_RCR		; 2
  577                        			sta	SGX_AR			; 6
  578                        	
  579                        			ldx	sgx_next_region		; 5 X and Y can be greater than
  580                        			ldy	sgx_regionA_nxt, x	; 5 HUCC_SGX_SPLITS if regionB!
  581                        			clc				; 2
  582                        			bne	!set_next_rcr+		; 4 Stop RCR if next line is 0.
  583                        	
  584                        			and	const_0000		; 5 A=$00 with the same #cycles
  585                        			bra	!clr_next_rcr+		; 4 as if the branch were taken.
  586                        	
  587                        	!set_next_rcr:	lda	sgx_regionA_rcr, y	; 5 Set next RCR 1 line before
  588                        			adc	#64-1			; 2 the region begins, or 0 to
  589                        	!clr_next_rcr:	sta	SGX_DL			; 6 disable.
  590                        			cla				; 2
  591                        			rol	a			; 2
  592                        			sta	SGX_DH			; 6
  593                        	
  594                        			lda	#VDC_BYR		; 2 Do BYR first to mitigate the
  595                        			sta	SGX_AR			; 6 glitch if the IRQ is delayed.
  596                        			lda	sgx_regionA_yl, x	; 5
  597                        			sta	SGX_DL			; 6
  598                        			lda	sgx_regionA_yh, x	; 5
  599                        			sta	SGX_DH			; 6
  600                        	
  601                        			lda	#VDC_CR			; 2
  602                        			sta	SGX_AR			; 6
  603                        			lda	sgx_regionA_crl, x	; 5
  604                        			sta	SGX_DL			; 6
  605                        	
  606                        			lda	#VDC_BXR		; 2
  607                        			sta	SGX_AR			; 6
  608                        			lda	sgx_regionA_xl, x	; 5
  609                        			sta	SGX_DL			; 6
  610                        			lda	sgx_regionA_xh, x	; 5
  611                        			sta	SGX_DH			; 6 = 293 cycles (282 if no YH)
  612                        	
  613                        			sty	sgx_next_region		; 5
  614                        	
  615                        			.endm
  616                        	
  617                        		.else	SUPPORT_SGX
  697                        		.endif	SUPPORT_SGX
                             #[2]   "..\..\..\include\hucc\hucc-final.asm"
   68                        		.else
   72                        		.endif	HUCC_USES_NEW_SCROLL
   73                        	
   74               0001     		.ifdef	HUCC_USES_OLD_SPR		; Set in hucc_old_spr.h
                             #[3]   "..\..\..\include\hucc\hucc-old-spr.asm"
   75                        			include	"hucc-old-spr.asm"
    1                        	; ***************************************************************************
    2                        	; ***************************************************************************
    3                        	;
    4                        	; hucc-old-spr.asm
    5                        	;
    6                        	; Based on the original HuC and MagicKit functions by David Michel and the
    7                        	; other original HuC developers.
    8                        	;
    9                        	; Modifications copyright John Brandwood 2024.
   10                        	;
   11                        	; Distributed under the Boost Software License, Version 1.0.
   12                        	; (See accompanying file LICENSE_1_0.txt or copy at
   13                        	;  http://www.boost.org/LICENSE_1_0.txt)
   14                        	;
   15                        	; ***************************************************************************
   16                        	; ***************************************************************************
   17                        	
   18                        	;
   19                        	; Include dependancies ...
   20                        	;
   21                        	
   22                        			include "common.asm"		; Common helpers.
   23                        			include "vce.asm"		; Useful VCE routines.
   24                        			include "vdc.asm"		; Useful VCE routines.
   25                        	
   26                        	
   27                        	
   28                        	; ***************************************************************************
   29                        	; ***************************************************************************
   30                        	;
   31                        	; HuC Sprite Functions
   32                        	;
   33                        	; ***************************************************************************
   34                        	; ***************************************************************************
   35                        	
   36               209C     			.zp
   37    F8:209C             	spr_ptr:	ds	2
   38               27AA     			.bss
   39    F8:27AA             	spr_sat:	ds	512
   40               E7B7     			.code
   41                        	
   42               0001     		.if	SUPPORT_SGX
   43               209E     			.zp
   44    F8:209E             	sgx_spr_ptr:	ds	2
   45               29AA     			.bss
   46    F8:29AA             	sgx_spr_sat:	ds	512	; N.B. Directly after spr_sat!
   47               E7B7     			.code
   48                        		.endif
   49                        	
   50                        	; Moved to hucc-old-map.asm just to save space. This NEEDS to be changed!
   51                        	;
   52                        	;		.bss
   53                        	;spr_max:	ds	1
   54                        	;spr_clr:	ds	1
   55                        	;	.if	SUPPORT_SGX
   56                        	;sgx_spr_max:	ds	1
   57                        	;sgx_spr_clr:	ds	1
   58                        	;	.endif
   59                        	;		.code
   60                        	
   61                        	
   62                        	
   63                        	; ***************************************************************************
   64                        	; ***************************************************************************
   65                        	;
   66                        	; void __fastcall init_satb( void );
   67                        	; void __fastcall reset_satb( void );
   68                        	;
   69                        	; void __fastcall sgx_init_satb( void );
   70                        	; void __fastcall sgx_reset_satb( void );
   71                        	
   72    00:E7B7             	_reset_satb:
   73    00:E7B7  C2         	_init_satb:	cly
   74    00:E7B8  62         			cla
   75    00:E7B9  99 AA 27   	!:		sta	spr_sat + $0000, y
   76    00:E7BC  99 AA 28   			sta	spr_sat + $0100, y
   77    00:E7BF  C8         			iny
   78    00:E7C0  D0 F7      			bne	!-
   79    00:E7C2  8C 7E 26   			sty	spr_max
   80    00:E7C5  C8         			iny
   81    00:E7C6  8C 7F 26   			sty	spr_clr
   82    00:E7C9  60         			rts
   83                        	
   84               0001     		.if	SUPPORT_SGX
   85    00:E7CA             	_sgx_reset_satb:
   86    00:E7CA  C2         	_sgx_init_satb:	cly
   87    00:E7CB  62         			cla
   88    00:E7CC  99 AA 29   	!:		sta	sgx_spr_sat + $0000, y
   89    00:E7CF  99 AA 2A   			sta	sgx_spr_sat + $0100, y
   90    00:E7D2  C8         			iny
   91    00:E7D3  D0 F7      			bne	!-
   92    00:E7D5  8C 8E 26   			sty	sgx_spr_max
   93    00:E7D8  C8         			iny
   94    00:E7D9  8C 8F 26   			sty	sgx_spr_clr
   95    00:E7DC  60         			rts
   96                        		.endif
   97                        	
   98                        	
   99                        	
  100                        	; ***************************************************************************
  101                        	; ***************************************************************************
  102                        	;
  103                        	; void __fastcall satb_update( void );
  104                        	; void __fastcall sgx_satb_update( void );
  105                        	
  106    11:D189             	old_satb_group	.procgroup
  107                        	
  108               0001     		.if	SUPPORT_SGX
  109                        			.proc	_sgx_satb_update
  115                        			.endp
  116                        		.endif
  117                        	
  118    11:D189             			.proc	_satb_update
  119                        	
  120    11:D189  82         			clx				; Offset to PCE VDC.
  121                        	
  122    11:D18A  A9 7F      			lda.h	#$7F00			; HuC puts the SAT here in VRAM
  123                        	;		lda.h	#$0800			; but we put it here instead
  124    11:D18C  64 F0      			stz.l	<_di
  125    11:D18E  85 F1      			sta.h	<_di
  126    11:D190  20 7F E3   			jsr	set_di_to_mawr
  127                        	
  128               0001     		.if	SUPPORT_SGX
  129    11:D193  8A         			txa				; Select which VDC to write
  130    11:D194  1A         			inc	a			; to.
  131    11:D195  1A         			inc	a
  132    11:D196  8D F3 22   			sta.l	ram_tia_dst
  133                        		.endif
  134                        	
  135    11:D199  A9 10      			lda	#VRAM_XFER_SIZE		; Split into 16-byte chunks
  136    11:D19B  8D F5 22   			sta.l	ram_tia_len		; for stable IRQ response.
  137                        	
  138    11:D19E  BC 7E 26   			ldy	spr_max, x		; Highest sprite that was set.
  139    11:D1A1  C8         			iny
  140                        	
  141    11:D1A2  BD 7F 26   			lda	spr_clr, x
  142    11:D1A5  F0 05      			beq	!+
  143    11:D1A7  9E 7F 26   			stz	spr_clr, x
  144    11:D1AA  A0 40      			ldy	#64
  145                        	
  146    11:D1AC  98         	!:		tya
  147    11:D1AD  F0 22      			beq	.exit
  148                        	
  149    11:D1AF  3A         			dec	a			; round up to the next group of 2 sprites
  150    11:D1B0  4A         			lsr	a
  151               0000     		.if	VRAM_XFER_SIZE == 32
  153                        		.endif
  154    11:D1B1  1A         			inc	a
  155    11:D1B2  A8         			tay
  156                        	
  157    11:D1B3  A9 27      			lda.h	#spr_sat
  158                        	
  159               0001     		.if	SUPPORT_SGX
  160    11:D1B5  E0 00      			cpx	#0
  161    11:D1B7  F0 02      			beq	!+
  162                        	
  163    11:D1B9  A9 29      			lda.h	#sgx_spr_sat
  164                        		.endif
  165                        	
  166    11:D1BB  8D F2 22   	!:		sta.h	ram_tia_src
  167                        	
  168    11:D1BE  A9 AA      			lda.l	#spr_sat		; Same for SGX and PCE!
  169    11:D1C0  8D F1 22   	.chunk_loop:	sta.l	ram_tia_src
  170                        	
  171    11:D1C3  20 F0 22   			jsr	ram_tia			; transfer 16-bytes
  172                        	
  173    11:D1C6  18         			clc				; increment source
  174    11:D1C7  69 10      			adc	#VRAM_XFER_SIZE
  175    11:D1C9  90 03      			bcc	.same_page
  176    11:D1CB  EE F2 22   			inc.h	ram_tia_src
  177                        	
  178    11:D1CE  88         	.same_page:	dey
  179    11:D1CF  D0 EF      			bne	.chunk_loop
  180                        	
  181                        	.exit:		leave
         11:D1D1  4C EF FF   			jmp	leave_proc
  182                        	
  183                        			.endp
  184                        	
  185                        			.endprocgroup	; old_satb_group
  186                        	
  187                        	
  188                        	
  189                        	; ***************************************************************************
  190                        	; ***************************************************************************
  191                        	;
  192                        	; void __fastcall spr_set( unsigned char num<acc> );
  193                        	
  194    00:E7DD  CD 7E 26   	_spr_set.1:	cmp	spr_max
  195    00:E7E0  90 03      			bcc	!+
  196    00:E7E2  8D 7E 26   			sta	spr_max
  197    00:E7E5  A0 27      	!:		ldy.h	#spr_sat
  198    00:E7E7  0A         			asl	a
  199    00:E7E8  0A         			asl	a
  200    00:E7E9  0A         			asl	a
  201    00:E7EA  90 02      			bcc	!+
  202    00:E7EC  C8         			iny
  203    00:E7ED  18         			clc
  204    00:E7EE  69 AA      	!:		adc.l	#spr_sat
  205    00:E7F0  85 9C      			sta.l	<spr_ptr
  206    00:E7F2  90 01      			bcc	!+
  207    00:E7F4  C8         			iny
  208    00:E7F5  84 9D      	!:		sty.h	<spr_ptr
  209    00:E7F7  60         			rts
  210                        	
  211                        	
  212                        	
  213                        	; ***************************************************************************
  214                        	; ***************************************************************************
  215                        	;
  216                        	; void __fastcall spr_hide( void );
  217                        	
  218    00:E7F8  A0 01      	_spr_hide:	ldy	#1
  219    00:E7FA  B1 9C      			lda	[spr_ptr], y
  220    00:E7FC  09 02      			ora	#2
  221    00:E7FE  91 9C      			sta	[spr_ptr], y
  222    00:E800  60         			rts
  223                        	
  224                        	
  225                        	
  226                        	; ***************************************************************************
  227                        	; ***************************************************************************
  228                        	;
  229                        	; void __fastcall spr_show( void );
  230                        	
  231    00:E801  A0 01      	_spr_show:	ldy	#1
  232    00:E803  B1 9C      			lda	[spr_ptr], y
  233    00:E805  29 01      			and	#1
  234    00:E807  91 9C      			sta	[spr_ptr], y
  235    00:E809  60         			rts
  236                        	
  237                        	
  238                        	
  239                        	; ***************************************************************************
  240                        	; ***************************************************************************
  241                        	;
  242                        	; void __fastcall spr_x( unsigned int value<acc> );
  243                        	
  244    00:E80A  02         	_spr_x.1:	sxy
  245    00:E80B  18         			clc
  246    00:E80C  69 20      			adc	#32
  247    00:E80E  A0 02      			ldy	#2
  248    00:E810  91 9C      			sta	[spr_ptr], y
  249    00:E812  8A         			txa
  250    00:E813  69 00      			adc	#0
  251    00:E815  C8         			iny
  252    00:E816  91 9C      			sta	[spr_ptr], y
  253    00:E818  60         			rts
  254                        	
  255                        	
  256                        	
  257                        	; ***************************************************************************
  258                        	; ***************************************************************************
  259                        	;
  260                        	; void __fastcall spr_y( unsigned int value<acc> );
  261                        	
  262    00:E819  18         	_spr_y.1:	clc
  263    00:E81A  69 40      			adc	#64
  264    00:E81C  92 9C      			sta	[spr_ptr]
  265    00:E81E  98         			tya
  266    00:E81F  69 00      			adc	#0
  267    00:E821  A0 01      			ldy	#1
  268    00:E823  91 9C      			sta	[spr_ptr], y
  269    00:E825  60         			rts
  270                        			
  271                        	
  272                        	
  273                        	; ***************************************************************************
  274                        	; ***************************************************************************
  275                        	;
  276                        	; void __fastcall spr_pattern( unsigned int vaddr<acc> );
  277                        	
  278    00:E826  84 00      	_spr_pattern.1:	sty	<__temp		;     zp=fedcba98 a=76543210
  279    00:E828  0A         			asl	a		; c=f zp=edcba987 a=6543210_
  280    00:E829  26 00      			rol	<__temp
  281    00:E82B  2A         			rol	a		; c=e zp=dcba9876 a=543210_f
  282    00:E82C  26 00      			rol	<__temp
  283    00:E82E  2A         			rol	a		; c=d zp=cba98765 a=43210_fe
  284    00:E82F  26 00      			rol	<__temp
  285    00:E831  2A         			rol	a		; c=4 zp=cba98765 a=3210_fed
  286    00:E832  A0 05      			ldy	#5
  287    00:E834  91 9C      			sta	[spr_ptr], y
  288    00:E836  A5 00      			lda	<__temp
  289    00:E838  88         			dey
  290    00:E839  91 9C      			sta	[spr_ptr], y
  291    00:E83B  60         			rts
  292                        	
  293                        	
  294                        	
  295                        	; ***************************************************************************
  296                        	; ***************************************************************************
  297                        	;
  298                        	; void __fastcall spr_ctrl( unsigned char mask<_al>, unsigned char value<acc> );
  299                        	
  300    00:E83C  25 F8      	_spr_ctrl.2:	and	<_al
  301    00:E83E  85 00      			sta	<__temp
  302    00:E840  A5 F8      			lda	<_al
  303    00:E842  49 FF      			eor	#$FF
  304    00:E844  A0 07      			ldy	#7
  305    00:E846  31 9C      			and	[spr_ptr], y
  306    00:E848  05 00      			ora	<__temp
  307    00:E84A  91 9C      			sta	[spr_ptr], y
  308    00:E84C  60         			rts
  309                        	
  310                        	
  311                        	
  312                        	; ***************************************************************************
  313                        	; ***************************************************************************
  314                        	;
  315                        	; void __fastcall spr_pal( unsigned char palette<acc> )
  316                        	
  317    00:E84D  29 0F      	_spr_pal.1:	and	#$0F
  318    00:E84F  85 00      			sta	<__temp
  319    00:E851  A0 06      			ldy	#6
  320    00:E853  B1 9C      			lda	[spr_ptr], y
  321    00:E855  29 F0      			and	#$F0
  322    00:E857  05 00      			ora	<__temp
  323    00:E859  91 9C      			sta	[spr_ptr], y
  324    00:E85B  60         			rts
  325                        	
  326                        	
  327                        	
  328                        	; ***************************************************************************
  329                        	; ***************************************************************************
  330                        	;
  331                        	; void __fastcall spr_pri( unsigned char priority<acc> )
  332                        	
  333    00:E85C  C9 01      	_spr_pri.1:	cmp	#1
  334    00:E85E  A0 06      			ldy	#6
  335    00:E860  B1 9C      			lda	[spr_ptr], y
  336    00:E862  29 7F      			and	#$7F
  337    00:E864  90 02      			bcc	!+
  338    00:E866  09 80      			ora	#$80
  339    00:E868  91 9C      	!:		sta	[spr_ptr], y
  340    00:E86A  60         			rts
  341                        	
  342                        	
  343                        	
  344                        	; ***************************************************************************
  345                        	; ***************************************************************************
  346                        	;
  347                        	; unsigned int __fastcall spr_get_x( void );
  348                        	
  349    00:E86B  38         	_spr_get_x:	sec
  350    00:E86C  A0 02      			ldy	#2
  351    00:E86E  B1 9C      			lda	[spr_ptr], y
  352    00:E870  E9 20      			sbc	#32
  353    00:E872  AA         			tax
  354    00:E873  C8         			iny
  355    00:E874  B1 9C      			lda	[spr_ptr], y
  356    00:E876  E9 00      			sbc	#0
  357    00:E878  A8         			tay
  358    00:E879  8A         			txa
  359    00:E87A  60         			rts
  360                        	
  361                        	
  362                        	
  363                        	; ***************************************************************************
  364                        	; ***************************************************************************
  365                        	;
  366                        	; unsigned int __fastcall spr_get_y( void );
  367                        	
  368    00:E87B  38         	_spr_get_y:	sec
  369    00:E87C  B2 9C      			lda	[spr_ptr]
  370    00:E87E  E9 40      			sbc	#64
  371    00:E880  AA         			tax
  372    00:E881  A0 01      			ldy	#1
  373    00:E883  B1 9C      			lda	[spr_ptr], y
  374    00:E885  E9 00      			sbc	#0
  375    00:E887  A8         			tay
  376    00:E888  8A         			txa
  377    00:E889  60         			rts
  378                        	
  379                        	
  380                        	
  381               0001     		.if	SUPPORT_SGX
  382                        	
  383                        	; ***************************************************************************
  384                        	; ***************************************************************************
  385                        	;
  386                        	; void __fastcall sgx_spr_set( unsigned char num<acc> );
  387                        	
  388    00:E88A  CD 8E 26   	_sgx_spr_set.1:	cmp	sgx_spr_max
  389    00:E88D  90 03      			bcc	!+
  390    00:E88F  8D 8E 26   			sta	sgx_spr_max
  391    00:E892  A0 29      	!:		ldy.h	#sgx_spr_sat
  392    00:E894  0A         			asl	a
  393    00:E895  0A         			asl	a
  394    00:E896  0A         			asl	a
  395    00:E897  90 02      			bcc	!+
  396    00:E899  C8         			iny
  397    00:E89A  18         			clc
  398    00:E89B  69 AA      	!:		adc.l	#sgx_spr_sat
  399    00:E89D  85 9E      			sta.l	<sgx_spr_ptr
  400    00:E89F  90 01      			bcc	!+
  401    00:E8A1  C8         			iny
  402    00:E8A2  84 9F      	!:		sty.h	<sgx_spr_ptr
  403    00:E8A4  60         			rts
  404                        	
  405                        	
  406                        	
  407                        	; ***************************************************************************
  408                        	; ***************************************************************************
  409                        	;
  410                        	; void __fastcall sgx_spr_hide( void );
  411                        	
  412    00:E8A5  A0 01      	_sgx_spr_hide:	ldy	#1
  413    00:E8A7  B1 9E      			lda	[sgx_spr_ptr], y
  414    00:E8A9  09 02      			ora	#2
  415    00:E8AB  91 9E      			sta	[sgx_spr_ptr], y
  416    00:E8AD  60         			rts
  417                        	
  418                        	
  419                        	
  420                        	; ***************************************************************************
  421                        	; ***************************************************************************
  422                        	;
  423                        	; void __fastcall sgx_spr_show( void );
  424                        	
  425    00:E8AE  A0 01      	_sgx_spr_show:	ldy	#1
  426    00:E8B0  B1 9E      			lda	[sgx_spr_ptr], y
  427    00:E8B2  29 01      			and	#1
  428    00:E8B4  91 9E      			sta	[sgx_spr_ptr], y
  429    00:E8B6  60         			rts
  430                        	
  431                        	
  432                        	
  433                        	; ***************************************************************************
  434                        	; ***************************************************************************
  435                        	;
  436                        	; void __fastcall sgx_spr_x( unsigned int value<acc> );
  437                        	
  438    00:E8B7  02         	_sgx_spr_x.1:	sxy
  439    00:E8B8  18         			clc
  440    00:E8B9  69 20      			adc	#32
  441    00:E8BB  A0 02      			ldy	#2
  442    00:E8BD  91 9E      			sta	[sgx_spr_ptr], y
  443    00:E8BF  8A         			txa
  444    00:E8C0  69 00      			adc	#0
  445    00:E8C2  C8         			iny
  446    00:E8C3  91 9E      			sta	[sgx_spr_ptr], y
  447    00:E8C5  60         			rts
  448                        	
  449                        	
  450                        	
  451                        	; ***************************************************************************
  452                        	; ***************************************************************************
  453                        	;
  454                        	; void __fastcall sgx_spr_y( unsigned int value<acc> );
  455                        	
  456    00:E8C6  18         	_sgx_spr_y.1:	clc
  457    00:E8C7  69 40      			adc	#64
  458    00:E8C9  92 9E      			sta	[sgx_spr_ptr]
  459    00:E8CB  98         			tya
  460    00:E8CC  69 00      			adc	#0
  461    00:E8CE  A0 01      			ldy	#1
  462    00:E8D0  91 9E      			sta	[sgx_spr_ptr], y
  463    00:E8D2  60         			rts
  464                        			
  465                        	
  466                        	
  467                        	; ***************************************************************************
  468                        	; ***************************************************************************
  469                        	;
  470                        	; void __fastcall sgx_spr_pattern( unsigned int vaddr<acc> );
  471                        	
  472    00:E8D3             	_sgx_spr_pattern.1:
  473    00:E8D3  84 00      			sty	<__temp		;     zp=fedcba98 a=76543210
  474    00:E8D5  0A         			asl	a		; c=f zp=edcba987 a=6543210_
  475    00:E8D6  26 00      			rol	<__temp
  476    00:E8D8  2A         			rol	a		; c=e zp=dcba9876 a=543210_f
  477    00:E8D9  26 00      			rol	<__temp
  478    00:E8DB  2A         			rol	a		; c=d zp=cba98765 a=43210_fe
  479    00:E8DC  26 00      			rol	<__temp
  480    00:E8DE  2A         			rol	a		; c=4 zp=cba98765 a=3210_fed
  481    00:E8DF  A0 05      			ldy	#5
  482    00:E8E1  91 9E      			sta	[sgx_spr_ptr], y
  483    00:E8E3  A5 00      			lda	<__temp
  484    00:E8E5  88         			dey
  485    00:E8E6  91 9E      			sta	[sgx_spr_ptr], y
  486    00:E8E8  60         			rts
  487                        	
  488                        	
  489                        	
  490                        	; ***************************************************************************
  491                        	; ***************************************************************************
  492                        	;
  493                        	; void __fastcall sgx_spr_ctrl( unsigned char mask<_al>, unsigned char value<acc> );
  494                        	
  495    00:E8E9  25 F8      	_sgx_spr_ctrl.2:and	<_al
  496    00:E8EB  85 00      			sta	<__temp
  497    00:E8ED  A5 F8      			lda	<_al
  498    00:E8EF  49 FF      			eor	#$FF
  499    00:E8F1  A0 07      			ldy	#7
  500    00:E8F3  31 9E      			and	[sgx_spr_ptr], y
  501    00:E8F5  05 00      			ora	<__temp
  502    00:E8F7  91 9E      			sta	[sgx_spr_ptr], y
  503    00:E8F9  60         			rts
  504                        	
  505                        	
  506                        	
  507                        	; ***************************************************************************
  508                        	; ***************************************************************************
  509                        	;
  510                        	; void __fastcall sgx_spr_pal( unsigned char palette<acc> )
  511                        	
  512    00:E8FA  29 0F      	_sgx_spr_pal.1:	and	#$0F
  513    00:E8FC  85 00      			sta	<__temp
  514    00:E8FE  A0 06      			ldy	#6
  515    00:E900  B1 9E      			lda	[sgx_spr_ptr], y
  516    00:E902  29 F0      			and	#$F0
  517    00:E904  05 00      			ora	<__temp
  518    00:E906  91 9E      			sta	[sgx_spr_ptr], y
  519    00:E908  60         			rts
  520                        	
  521                        	
  522                        	
  523                        	; ***************************************************************************
  524                        	; ***************************************************************************
  525                        	;
  526                        	; void __fastcall sgx_spr_pri( unsigned char priority<acc> )
  527                        	
  528    00:E909  C9 01      	_sgx_spr_pri.1:	cmp	#1
  529    00:E90B  A0 06      			ldy	#6
  530    00:E90D  B1 9E      			lda	[sgx_spr_ptr], y
  531    00:E90F  29 7F      			and	#$7F
  532    00:E911  90 02      			bcc	!+
  533    00:E913  09 80      			ora	#$80
  534    00:E915  91 9E      	!:		sta	[sgx_spr_ptr], y
  535    00:E917  60         			rts
  536                        	
  537                        	
  538                        	
  539                        	; ***************************************************************************
  540                        	; ***************************************************************************
  541                        	;
  542                        	; unsigned int __fastcall sgx_spr_get_x( void );
  543                        	
  544    00:E918  38         	_sgx_spr_get_x:	sec
  545    00:E919  A0 02      			ldy	#2
  546    00:E91B  B1 9E      			lda	[sgx_spr_ptr], y
  547    00:E91D  E9 20      			sbc	#32
  548    00:E91F  AA         			tax
  549    00:E920  C8         			iny
  550    00:E921  B1 9E      			lda	[sgx_spr_ptr], y
  551    00:E923  E9 00      			sbc	#0
  552    00:E925  A8         			tay
  553    00:E926  8A         			txa
  554    00:E927  60         			rts
  555                        	
  556                        	
  557                        	
  558                        	; ***************************************************************************
  559                        	; ***************************************************************************
  560                        	;
  561                        	; unsigned int __fastcall sgx_spr_get_y( void );
  562                        	
  563    00:E928  38         	_sgx_spr_get_y:	sec
  564    00:E929  B2 9E      			lda	[sgx_spr_ptr]
  565    00:E92B  E9 40      			sbc	#64
  566    00:E92D  AA         			tax
  567    00:E92E  A0 01      			ldy	#1
  568    00:E930  B1 9E      			lda	[sgx_spr_ptr], y
  569    00:E932  E9 00      			sbc	#0
  570    00:E934  A8         			tay
  571    00:E935  8A         			txa
  572    00:E936  60         			rts
  573                        	
  574                        		.endif	SUPPORT_SGX
                             #[2]   "..\..\..\include\hucc\hucc-final.asm"
   76                        		.endif
   77                        	
   78               0001     		.ifdef	HUCC_USES_BLKMAP		; Set in hucc_blkmap.h
                             #[3]   "..\..\..\include\hucc\blkmap.asm"
   79                        			include	"blkmap.asm"
    1                        	; ***************************************************************************
    2                        	; ***************************************************************************
    3                        	;
    4                        	; blkmap.asm
    5                        	;
    6                        	; A map system based on 16x16 meta-tiles (aka "blocks", aka CHR/BLK/MAP).
    7                        	;
    8                        	; Copyright John Brandwood 2025.
    9                        	;
   10                        	; Distributed under the Boost Software License, Version 1.0.
   11                        	; (See accompanying file LICENSE_1_0.txt or copy at
   12                        	;  http://www.boost.org/LICENSE_1_0.txt)
   13                        	;
   14                        	; ***************************************************************************
   15                        	; ***************************************************************************
   16                        	;
   17                        	; The maximum X and Y size for blkmaps is 128 blocks (2048 pixels).
   18                        	;
   19                        	; The maximum total size for a blkmap is 16KBytes, which allows for maps up
   20                        	; to 128x128 blocks (2048x2048 pixels).
   21                        	;
   22                        	; Huge multi-screen blkmaps are also supported (optionally).
   23                        	;
   24                        	; The maximum X and Y for multi-screen maps is 128 screens (32768 pixels).
   25                        	;
   26                        	; The maximum total size for a multi-screen map is 8KBytes, which allows for
   27                        	; a total of 1024 screens.
   28                        	;
   29                        	; ***************************************************************************
   30                        	; ***************************************************************************
   31                        	
   32                        	;
   33                        	; Include dependancies ...
   34                        	;
   35                        	
   36                        			include "common.asm"		; Common helpers.
   37                        			include "vce.asm"		; Useful VCE routines.
   38                        			include "vdc.asm"		; Useful VCE routines.
   39                        	
   40                        	;
   41                        	; Support large blkmaps up to 16KBytes instead of the regular 8KBytes?
   42                        	;
   43                        	; The maximum X and Y size for regular blkmaps is 128 tiles (2048 pixels).
   44                        	;
   45                        	; This allows for individual maps up to 128x128 tiles (2048x2048 pixels) vs
   46                        	; default limit of 128x64 or 64x128.
   47                        	;
   48                        	
   49               0000     		.ifndef	BLKMAP_LARGEMAP
   51                        		.endif
   52                        	
   53                        	;
   54                        	; Support huge multi-screen maps, up to 32768 pixels wide/high?
   55                        	;
   56                        	; These are sectorized maps split into individual BAT-sized "screens", with
   57                        	; a maximum of 1024 screens per map.
   58                        	;
   59                        	; The BAT size that is used when drawing *must* be the same as the BAT size
   60                        	; that was chosen when creating the multi-screen map.
   61                        	;
   62                        	; Each screen can use a unique set of block definitions, or it might choose
   63                        	; to share the same block definitions that are used on another screen.
   64                        	;
   65                        	; Each screen may choose which 8KByte banks of character data to select for
   66                        	; the 4 banks (32KBytes) of VRAM that its block definitions use, with a max
   67                        	; of 16 banks of characters per multi-screen map.
   68                        	;
   69                        	; Loading those character banks dynamically is an exercise for the user!
   70                        	;
   71                        	; Enabling support adds extra library code, and slightly slows down the use
   72                        	; of regular blkmaps.
   73                        	;
   74                        	
   75               0000     		.ifndef	BLKMAP_MULTISCR
   77                        		.endif
   78                        	
   79                        	;
   80                        	; Block definitions can either use character data from VRAM $1000..$7FFF or
   81                        	; they can be limited to use the 32KByte of characters in VRAM $1000..$4FFF
   82                        	; which then frees up 2-bits for flag information for each character in the
   83                        	; block.
   84                        	;
   85                        	; These 2-bits are perfect for using as collision information in game maps,
   86                        	; allowing storage of states like transparent, solid, up-slope, down-slope.
   87                        	;
   88                        	; Typically this flag information is set by the map conversion tools from a
   89                        	; seperate "collision" map layer.
   90                        	;
   91                        	
   92               0000     		.ifndef	BLKDEF_CHR_FLAG
   94                        		.endif
   95                        	
   96                        	;
   97                        	; Block definitions are accessed in MPR2 ($4000..$5FFF), and must not cross
   98                        	; the bank boundary.
   99                        	;
  100                        	; When working this way, 8 pointers in ZP are used to access the individual
  101                        	; bytes in the block definition. This is fine when using a regular map on a
  102                        	; PC Engine, but it is awfully slow when using multi-screen maps or drawing
  103                        	; maps on both VDC chips in a SuperGRAFX because the pointer values must be
  104                        	; constantly changed.
  105                        	;
  106                        	; When using multi-screen maps, or when developing a SuperGRAFX game, or if
  107                        	; developing a CDROM game, then it is usually preferable to store the block
  108                        	; definitions with 2KByte alignment, especially if they are normally stored
  109                        	; compressed and then decompressed into a 2KByte buffer in RAM when needed.
  110                        	;
  111                        	; This option controls whether the definitions are stored 2KByte aligned or
  112                        	; if pointers should be used instead.
  113                        	;
  114                        	
  115               0000     		.ifndef	BLKDEF_POINTERS
  117                        		.endif
  118                        	
  119                        	;
  120                        	; Add a timing bar to the scroll_map() to see how long the drawing takes?
  121                        	;
  122                        	
  123               0000     		.ifndef	BLKMAP_TIMETEST
  125                        		.endif
  126                        	
  127                        	;
  128                        	;
  129                        	;
  130                        	
  131               0000     		.if	BLKDEF_POINTERS
  144                        		.else
  145                        	
  146                        		; If the block definititions are 2KByte aligned.
  147                        	
  148               4000     	BLK_4000_TL_L	=	$4000
  149               4100     	BLK_4000_TR_L	=	$4100
  150               4200     	BLK_4000_BL_L	=	$4200
  151               4300     	BLK_4000_BR_L	=	$4300
  152               4400     	BLK_4000_TL_H	=	$4400
  153               4500     	BLK_4000_TR_H	=	$4500
  154               4600     	BLK_4000_BL_H	=	$4600
  155               4700     	BLK_4000_BR_H	=	$4700
  156                        	
  157               4800     	BLK_4800_TL_L	=	$4800
  158               4900     	BLK_4800_TR_L	=	$4900
  159               4A00     	BLK_4800_BL_L	=	$4A00
  160               4B00     	BLK_4800_BR_L	=	$4B00
  161               4C00     	BLK_4800_TL_H	=	$4C00
  162               4D00     	BLK_4800_TR_H	=	$4D00
  163               4E00     	BLK_4800_BL_H	=	$4E00
  164               4F00     	BLK_4800_BR_H	=	$4F00
  165                        	
  166               5000     	BLK_5000_TL_L	=	$5000
  167               5100     	BLK_5000_TR_L	=	$5100
  168               5200     	BLK_5000_BL_L	=	$5200
  169               5300     	BLK_5000_BR_L	=	$5300
  170               5400     	BLK_5000_TL_H	=	$5400
  171               5500     	BLK_5000_TR_H	=	$5500
  172               5600     	BLK_5000_BL_H	=	$5600
  173               5700     	BLK_5000_BR_H	=	$5700
  174                        	
  175               5800     	BLK_5800_TL_L	=	$5800
  176               5900     	BLK_5800_TR_L	=	$5900
  177               5A00     	BLK_5800_BL_L	=	$5A00
  178               5B00     	BLK_5800_BR_L	=	$5B00
  179               5C00     	BLK_5800_TL_H	=	$5C00
  180               5D00     	BLK_5800_TR_H	=	$5D00
  181               5E00     	BLK_5800_BL_H	=	$5E00
  182               5F00     	BLK_5800_BR_H	=	$5F00
  183                        	
  184                        		.endif
  185                        	
  186               0080     	MAP_UNALIGNED_X	=	$80
  187               0040     	MAP_UNALIGNED_Y	=	$40
  188                        	
  189                        	;
  190                        	;
  191                        	;
  192                        	
  193               2BAA     			.bss
  194                        	
  195                        	; **************
  196                        	; 8-byte (or 2-byte) entry for each SCREEN in the MULTI_MAP.
  197                        	
  198               0000     			.rsset	0
  199               0000     		.if	BLKDEF_POINTERS
  202                        		.else
  203               0000     	SCR_MAP_PAGE	.rs	1	; 256-byte aligned.
  204               0001     	SCR_MAP_BANK	.rs	1
  205               0002     	SCR_BLK_PAGE	.rs	1	; >$4000, >$4800, >$5000, or >$5800.
  206               0003     	SCR_BLK_BANK	.rs	1
  207               0004     	SCR_TBL_PAGE	.rs	1	; 256-byte aligned.
  208               0005     	SCR_TBL_BANK	.rs	1
  209               0006     	SCR_CHR_12	.rs	1	; Which CHR banks are used by the BLK, with
  210               0007     	SCR_CHR_34	.rs	1	; a max of 16 CHR banks per MULTI_MAP.
  211                        		.endif
  212                        	
  213                        			; A simple macro to help build a multi-screen map.
  214                        	
  215               0000     		.ifndef	SCREEN
  224                        		.endif
  225                        	
  226    F8:2BAA             	map_blk_flag:	ds	1	; Returned from _get_map_block().
  227    F8:2BAB             	map_blk_mask:	ds	1	; Returned from _get_map_block().
  228                        	
  229                        	; **************
  230                        	; 16-bytes of VDC blkmap info.
  231                        	;
  232                        	; N.B. MUST be 16-bytes before the SGX versions to use PCE_VDC_OFFSET.
  233                        	
  234    F8:2BAC             	vdc_old_chr_x:	ds	1	; Previous top-left X in CHR (lo-byte only).
  235    F8:2BAD             	vdc_old_chr_y:	ds	1	; Previous top-left Y in CHR (lo-byte only).
  236                        	
  237    F8:2BAE             	vdc_tbl_addr:	ds	2	; 256-byte aligned.
  238    F8:2BB0             	vdc_tbl_bank:	ds	1
  239                        	
  240    F8:2BB1             	vdc_blk_addr:	ds	2	; 2KBytes of data, 256-byte aligned.
  241    F8:2BB3             	vdc_blk_bank:	ds	1
  242                        	
  243    F8:2BB4             	vdc_map_addr:	ds	2	; Mapped into MPR3..MPR5, max 16KBytes.
  244    F8:2BB6             	vdc_map_bank:	ds	1
  245                        	
  246    F8:2BB7             	vdc_scr_addr:	ds	2	; 8KByte maximum size.
  247    F8:2BB9             	vdc_scr_bank:	ds	1
  248    F8:2BBA             	vdc_scr_chr12:	ds	1	; Which CHR banks are used by the BLK, with
  249    F8:2BBB             	vdc_scr_chr34:	ds	1	; a max of 16 banks per multi-screen map.
  250                        	
  251               0001     		.if	SUPPORT_SGX
  252                        	
  253                        	; **************
  254                        	; 16-bytes of SGX blkmap info.
  255                        	;
  256                        	; N.B. MUST be 16-bytes after the VDC versions to use SGX_VDC_OFFSET.
  257                        	
  258    F8:2BBC             	sgx_old_chr_x:	ds	1	; Previous top-left X in CHR (lo-byte only).
  259    F8:2BBD             	sgx_old_chr_y:	ds	1	; Previous top-left Y in CHR (lo-byte only).
  260                        	
  261    F8:2BBE             	sgx_tbl_addr:	ds	2	; 256-byte aligned.
  262    F8:2BC0             	sgx_tbl_bank:	ds	1
  263                        	
  264    F8:2BC1             	sgx_blk_addr:	ds	2	; 2KBytes of data, 256-byte aligned.
  265    F8:2BC3             	sgx_blk_bank:	ds	1
  266                        	
  267    F8:2BC4             	sgx_map_addr:	ds	2	; Mapped into MPR3..MPR4, max 8KBytes.
  268    F8:2BC6             	sgx_map_bank:	ds	1
  269                        	
  270    F8:2BC7             	sgx_scr_addr:	ds	2	; 8KByte maximum size.
  271    F8:2BC9             	sgx_scr_bank:	ds	1
  272    F8:2BCA             	sgx_scr_chr12:	ds	1	; Which CHR banks are used by the BLK, with
  273    F8:2BCB             	sgx_scr_chr34:	ds	1	; a max of 16 banks per multi-screen map.
  274                        	
  275                        		.endif	SUPPORT_SGX
  276                        	
  277               0000     		.if	0
  310                        		.endif	0
  311                        	
  312                        	; **************
  313                        	; Aliases for the asm variable names in HuCC.
  314                        	;
  315                        	
  316               0001     		.ifdef	HUCC
  317                        	
  318    F8:2BCC             	_map_blk_flag	.alias	map_blk_flag
  319    F8:2BCC             	_map_blk_mask	.alias	map_blk_mask
  320                        	
  321    F8:2BCC             	_vdc_map_draw_w	.alias	vdc_map_draw_w
  322    F8:2BCC             	_vdc_map_draw_h	.alias	vdc_map_draw_h
  323    F8:2BCC             	_vdc_map_pxl_x	.alias	vdc_map_pxl_x
  324    F8:2BCC             	_vdc_map_pxl_y	.alias	vdc_map_pxl_y
  325    F8:2BCC             	_vdc_old_chr_x	.alias	vdc_old_chr_x
  326    F8:2BCC             	_vdc_old_chr_y	.alias	vdc_old_chr_y
  327    F8:2BCC             	_vdc_tbl_addr	.alias	vdc_tbl_addr
  328    F8:2BCC             	_vdc_tbl_bank	.alias	vdc_tbl_bank
  329    F8:2BCC             	_vdc_blk_addr	.alias	vdc_blk_addr
  330    F8:2BCC             	_vdc_blk_bank	.alias	vdc_blk_bank
  331    F8:2BCC             	_vdc_map_line_w	.alias	vdc_map_line_w
  332    F8:2BCC             	_vdc_map_scrn_w	.alias	vdc_map_scrn_w
  333    F8:2BCC             	_vdc_map_addr	.alias	vdc_map_addr
  334    F8:2BCC             	_vdc_map_bank	.alias	vdc_map_bank
  335    F8:2BCC             	_vdc_scr_addr	.alias	vdc_scr_addr
  336    F8:2BCC             	_vdc_scr_bank	.alias	vdc_scr_bank
  337    F8:2BCC             	_vdc_scr_chr12	.alias	vdc_scr_chr12
  338    F8:2BCC             	_vdc_scr_chr34	.alias	vdc_scr_chr34
  339                        	
  340               0001     		.if	SUPPORT_SGX
  341    F8:2BCC             	_sgx_map_draw_w	.alias	sgx_map_draw_w
  342    F8:2BCC             	_sgx_map_draw_h	.alias	sgx_map_draw_h
  343    F8:2BCC             	_sgx_map_pxl_x	.alias	sgx_map_pxl_x
  344    F8:2BCC             	_sgx_map_pxl_y	.alias	sgx_map_pxl_y
  345    F8:2BCC             	_sgx_old_chr_x	.alias	sgx_old_chr_x
  346    F8:2BCC             	_sgx_old_chr_y	.alias	sgx_old_chr_y
  347    F8:2BCC             	_sgx_tbl_addr	.alias	sgx_tbl_addr
  348    F8:2BCC             	_sgx_tbl_bank	.alias	sgx_tbl_bank
  349    F8:2BCC             	_sgx_blk_addr	.alias	sgx_blk_addr
  350    F8:2BCC             	_sgx_blk_bank	.alias	sgx_blk_bank
  351    F8:2BCC             	_sgx_map_line_w	.alias	sgx_map_line_w
  352    F8:2BCC             	_sgx_map_scrn_w	.alias	sgx_map_scrn_w
  353    F8:2BCC             	_sgx_map_addr	.alias	sgx_map_addr
  354    F8:2BCC             	_sgx_map_bank	.alias	sgx_map_bank
  355    F8:2BCC             	_sgx_scr_addr	.alias	sgx_scr_addr
  356    F8:2BCC             	_sgx_scr_bank	.alias	sgx_scr_bank
  357    F8:2BCC             	_sgx_scr_chr12	.alias	sgx_scr_chr12
  358    F8:2BCC             	_sgx_scr_chr34	.alias	sgx_scr_chr34
  359                        		.endif	SUPPORT_SGX
  360                        	
  361                        		.endif	HUCC
  362                        	
  363                        	; **************
  364                        	; Temporary variables for drawing, using common zero-page locations.
  365                        	;
  366                        	
  367               20F8     	map_bat_x	=	_al	; Set by draw_map(), scroll_map() if drawing
  368               20F9     	map_bat_y	=	_ah	; aligned, or as parameters to blit_map().
  369                        	
  370               20FA     	map_draw_w	=	_bl	; Set by draw_map(), scroll_map(), but given
  371               20FB     	map_draw_h	=	_bh	; as parameters to blit_map().
  372                        	
  373               20FC     	map_pxl_x	=	_cx	; Set by draw_map(), scroll_map() and also by
  374               20FC     	map_chr_x	=	_cl	; blit__map(), from current vdc_map_pxl_x.
  375               20FD     	map_scrn_x	=	_ch
  376                        	
  377               20FE     	map_pxl_y	=	_dx	; Set by draw_map(), scroll_map() and also by
  378               20FE     	map_chr_y	=	_dl	; blit__map(), from current vdc_map_pxl_y.
  379               20FF     	map_scrn_y	=	_dh
  380                        	
  381               20EE     	map_line	=	_si	; Start of map data line being drawn.
  382                        	
  383               2000     	map_count	=	__temp + 0
  384               2001     	map_drawn	=	__temp + 1
  385                        	
  386               E937     			.code
  387                        	
  388                        	
  389                        	
  390    02:C000             	blkmap_group	.procgroup
  391                        	
  392                        	; ***************************************************************************
  393                        	; ***************************************************************************
  394                        	;
  395                        	; _set_blocks - Initialize the block definition pointers.
  396                        	; _sgx_set_blocks - Initialize the block definition pointers.
  397                        	;
  398                        	; void __fastcall set_blocks( unsigned char __far *blk_def<vdc_blk_bank:vdc_blk_addr>, unsigned char __far *flg_def<vdc_tbl_bank:vdc_tbl_addr>, unsigned char number_of_blk<_al> );
  399                        	; void __fastcall sgx_set_blocks( unsigned char __far *blk_def<sgx_blk_bank:sgx_blk_addr>, unsigned char __far *flg_def<sgx_tbl_bank:sgx_tbl_addr>, unsigned char number_of_blk<_al> );
  400                        	;
  401                        	
  402               0001     		.if	SUPPORT_SGX
  403                        	
  404    02:C000             			.proc	_sgx_set_blocks.3
  405                        	
  406    02:C000  A2 10      			ldx	#SGX_VDC_OFFSET		; Offset to SGX VDC.
  407    02:C002  F0         			db	$F0			; Turn "clx" into a "beq".
  408                        	
  409    02:C003             			.ref	_set_blocks.3
  410                        			.endp
  411                        		.endif
  412                        	
  413    02:C003             			.proc	_set_blocks.3
  414                        	
  415    02:C003  82         			clx				; Offset to PCE VDC.
  416                        	
  417    02:C004  BD AF 2B   			lda.h	vdc_tbl_addr, x		; Remap the address to MPR2.
  418    02:C007  29 1F      			and	#$1F
  419    02:C009  09 40      			ora	#$40
  420    02:C00B  9D AF 2B   			sta.h	vdc_tbl_addr, x
  421                        	
  422    02:C00E  BD B2 2B   			lda.h	vdc_blk_addr, x		; Remap the address to MPR2.
  423    02:C011  29 1F      			and	#$1F
  424    02:C013  09 40      			ora	#$40
  425    02:C015  9D B2 2B   			sta.h	vdc_blk_addr, x
  426                        	
  427               0000     		.if	BLKDEF_POINTERS
  479                        		.endif	BLKDEF_POINTERS
  480                        	
  481                        			leave
         02:C018  4C EF FF   			jmp	leave_proc
  482                        	
  483                        			.endp
  484                        	
  485                        	
  486                        	
  487                        	; ***************************************************************************
  488                        	; ***************************************************************************
  489                        	;
  490                        	; _draw_map - Draw the entire screen at the current coordinates.
  491                        	; _sgx_draw_map - Draw the entire screen at the current coordinates.
  492                        	;
  493                        	; void __fastcall draw_map( void );
  494                        	; void __fastcall sgx_draw_map( void );
  495                        	;
  496                        	
  497               0001     		.if	SUPPORT_SGX
  498                        	
  499    02:C01B             	_sgx_draw_map	.proc
  500                        	
  501    02:C01B  A2 10      			ldx	#SGX_VDC_OFFSET		; Offset to SGX VDC.
  502    02:C01D  F0         			db	$F0			; Turn "clx" into a "beq".
  503                        	
  504    02:C01E             			.ref	_draw_map
  505                        			.endp
  506                        		.endif
  507                        	
  508    02:C01E             	_draw_map	.proc
  509                        	
  510    02:C01E  82         			clx				; Offset to PCE VDC.
  511                        	
  512    02:C01F  43 04      			tma2				; Preserve MPR2..MPR4.
  513    02:C021  48         			pha
  514    02:C022  43 08      			tma3
  515    02:C024  48         			pha
  516    02:C025  43 10      			tma4
  517    02:C027  48         			pha
  518               0000     		.if	BLKMAP_LARGEMAP
  521                        		.endif
  522                        	
  523    02:C028  20 2A C1   			jsr	map_pxl_2_chr		; Set up the draw coordinates.
  524                        	
  525    02:C02B  A5 FC      			lda	<map_chr_x		; Reset previous X position.
  526    02:C02D  9D AC 2B   			sta	vdc_old_chr_x, x
  527                        	
  528    02:C030  A5 FE      			lda	<map_chr_y		; Reset previous Y position,
  529    02:C032  1A         			inc	a			; ready to draw multiple rows.
  530    02:C033  9D AD 2B   			sta	vdc_old_chr_y, x
  531                        	
  532    02:C036  BD 75 26   			lda	vdc_map_draw_w, x	; Draw the whole screen.
  533    02:C039  85 FA      			sta	<map_draw_w
  534    02:C03B  BD 76 26   			lda	vdc_map_draw_h, x
  535    02:C03E  85 FB      			sta	<map_draw_h
  536                        	
  537    02:C040  20 80 C3   			jsr	map_scroll_y		; Draw N row of CHR to the BAT.
  538                        	
  539               0000     		.if	BLKMAP_LARGEMAP
  542                        		.endif
  543    02:C043  68         			pla				; Restore MPR2..MPR4.
  544    02:C044  53 10      			tam4
  545    02:C046  68         			pla
  546    02:C047  53 08      			tam3
  547    02:C049  68         			pla
  548    02:C04A  53 04      			tam2
  549                        	
  550                        			leave
         02:C04C  4C EF FF   			jmp	leave_proc
  551                        	
  552                        			.endp
  553                        	
  554                        	
  555                        	
  556                        	; ***************************************************************************
  557                        	; ***************************************************************************
  558                        	;
  559                        	; _scroll_map - Draw a single row of CHR into the BAT to update the edge.
  560                        	; _sgx_scroll_map - Draw a single row of CHR into the BAT to update the edge.
  561                        	;
  562                        	; void __fastcall scroll_map( void );
  563                        	; void __fastcall sgx_scroll_map( void );
  564                        	;
  565                        	
  566               0001     		.if	SUPPORT_SGX
  567                        	
  568    02:C04F             	_sgx_scroll_map	.proc
  569                        	
  570    02:C04F  A2 10      			ldx	#SGX_VDC_OFFSET		; Offset to SGX VDC.
  571    02:C051  F0         			db	$F0			; Turn "clx" into a "beq".
  572                        	
  573    02:C052             			.ref	_scroll_map
  574                        			.endp
  575                        		.endif
  576                        	
  577    02:C052             	_scroll_map	.proc
  578                        	
  579    02:C052  82         			clx				; Offset to PCE VDC.
  580                        	
  581               0000     		.if	BLKMAP_TIMETEST
  587                        		.endif
  588                        	
  589    02:C053  43 04      			tma2				; Preserve MPR2..MPR4.
  590    02:C055  48         			pha
  591    02:C056  43 08      			tma3
  592    02:C058  48         			pha
  593    02:C059  43 10      			tma4
  594    02:C05B  48         			pha
  595               0000     		.if	BLKMAP_LARGEMAP
  598                        		.endif
  599                        	
  600    02:C05C  20 2A C1   			jsr	map_pxl_2_chr		; Set up the draw coordinates.
  601                        	
  602               0001     		.if	BLKMAP_MULTISCR
  603    02:C05F  A5 FD      			lda	<map_scrn_x		; map_scroll_x can change this!
  604    02:C061  48         			pha
  605                        		.endif
  606                        	
  607    02:C062  BD 76 26   			lda	vdc_map_draw_h, x	; Draw new LHS or RHS if needed.
  608    02:C065  85 FB      			sta	<map_draw_h
  609                        	;		lda	#1			; map_scroll_x only ever draws a
  610                        	;		sta	<map_draw_w		; single column.
  611    02:C067  20 61 C2   			jsr	map_scroll_x
  612                        	
  613    02:C06A  BD AC 2B   			lda	vdc_old_chr_x, x	; Restore map_chr_x which could
  614    02:C06D  85 FC      			sta	<map_chr_x		; be changed by map_scroll_x.
  615                        	
  616               0001     		.if	BLKMAP_MULTISCR
  617    02:C06F  68         			pla				; Restore before map_scroll_y.
  618    02:C070  85 FD      			sta	<map_scrn_x
  619                        		.endif
  620                        	
  621    02:C072  BD 75 26   			lda	vdc_map_draw_w, x	; Draw new TOP or BTM if needed.
  622    02:C075  85 FA      			sta	<map_draw_w
  623    02:C077  A9 01      			lda	#1
  624    02:C079  85 FB      			sta	<map_draw_h
  625    02:C07B  20 80 C3   			jsr	map_scroll_y
  626                        	
  627               0000     		.if	BLKMAP_LARGEMAP
  630                        		.endif
  631    02:C07E  68         			pla				; Restore MPR2..MPR4.
  632    02:C07F  53 10      			tam4
  633    02:C081  68         			pla
  634    02:C082  53 08      			tam3
  635    02:C084  68         			pla
  636    02:C085  53 04      			tam2
  637                        	
  638               0000     		.if	BLKMAP_TIMETEST
  640                        		.endif
  641                        	
  642                        			leave
         02:C087  4C EF FF   			jmp	leave_proc
  643                        	
  644                        			.endp
  645                        	
  646                        	
  647                        	
  648                        	; ***************************************************************************
  649                        	; ***************************************************************************
  650                        	;
  651                        	; _blit_map - Draw a map rectangle to specific BAT coordinates.
  652                        	; _sgx_blit_map - Draw a map rectangle to specific BAT coordinates.
  653                        	;
  654                        	; void __fastcall blit_map( unsigned char tile_x<map_bat_x>, unsigned char tile_y<map_bat_y>, unsigned char tile_w<map_draw_x>, unsigned char tile_h<map_draw_y> );
  655                        	; void __fastcall sgx_blit_map( unsigned char tile_x<map_bat_x>, unsigned char tile_y<map_bat_y>, unsigned char tile_w<map_draw_x>, unsigned char tile_h<map_draw_y> );
  656                        	;
  657                        	; Normally you'd just use _draw_map() and _scroll_map(), but for those folks
  658                        	; who really wish to take manual control, you can use this.
  659                        	;
  660                        	
  661               0001     		.if	SUPPORT_SGX
  662                        	
  663                        	_sgx_blit_map	.proc
  669                        			.endp
  670                        		.endif
  671                        	
  672    02:C08A             	_blit_map	.proc
  673                        	
  674    02:C08A  82         			clx				; Offset to PCE VDC.
  675                        	
  676    02:C08B  BD B9 2B   			lda	vdc_scr_bank, x		; Skip this if a multi-screen
  677    02:C08E  D0 36      			bne	.exit			; blkmap.
  678                        	
  679    02:C090  43 04      			tma2				; Preserve MPR2..MPR4.
  680    02:C092  48         			pha
  681    02:C093  43 08      			tma3
  682    02:C095  48         			pha
  683    02:C096  43 10      			tma4
  684    02:C098  48         			pha
  685               0000     		.if	BLKMAP_LARGEMAP
  688                        		.endif
  689                        	
  690    02:C099  BD 7D 26   			lda	vdc_map_option, x	; Preserve current map options.
  691    02:C09C  48         			pha
  692    02:C09D  09 C0      			ora	#MAP_UNALIGNED_X | MAP_UNALIGNED_Y
  693    02:C09F  9D 7D 26   			sta	vdc_map_option, x
  694                        	
  695    02:C0A2  20 2A C1   			jsr	map_pxl_2_chr		; Set up the draw coordinates.
  696                        	
  697    02:C0A5  A5 FA      			lda	<map_draw_w		; Are we drawing just 1 column?
  698    02:C0A7  C9 01      			cmp	#1
  699    02:C0A9  F0 1E      			beq	.draw_column
  700                        	
  701                        			; Draw N rows.
  702                        	
  703    02:C0AB  A5 FC      	.draw_rows:	lda	<map_chr_x		; Reset previous X position.
  704    02:C0AD  9D AC 2B   			sta	vdc_old_chr_x, x
  705                        	
  706    02:C0B0  A5 FE      			lda	<map_chr_y		; Reset previous Y position,
  707    02:C0B2  1A         			inc	a			; ready to draw rows upwards.
  708    02:C0B3  9D AD 2B   			sta	vdc_old_chr_y, x
  709                        	
  710    02:C0B6  20 80 C3   			jsr	map_scroll_y		; Draw a row of CHR to the BAT.
  711                        	
  712                        			; Drawing completed.
  713                        	
  714    02:C0B9  68         	.finished:	pla				; Restore previous map options.
  715    02:C0BA  9D 7D 26   			sta	vdc_map_option, x
  716                        	
  717               0000     		.if	BLKMAP_LARGEMAP
  720                        		.endif
  721    02:C0BD  68         			pla				; Restore MPR2..MPR4.
  722    02:C0BE  53 10      			tam4
  723    02:C0C0  68         			pla
  724    02:C0C1  53 08      			tam3
  725    02:C0C3  68         			pla
  726    02:C0C4  53 04      			tam2
  727                        	
  728                        	.exit:		leave
         02:C0C6  4C EF FF   			jmp	leave_proc
  729                        	
  730                        			; Draw 1 column.
  731                        	
  732    02:C0C9  A5 FC      	.draw_column:	lda	<map_chr_x		; Reset previous X position.
  733    02:C0CB  1A         			inc	a			; ready to draw 1 column.
  734    02:C0CC  9D AC 2B   			sta	vdc_old_chr_x, x
  735                        	
  736    02:C0CF  A5 FE      			lda	<map_chr_y		; Reset previous Y position.
  737    02:C0D1  9D AD 2B   			sta	vdc_old_chr_y, x
  738                        	
  739    02:C0D4  20 61 C2   			jsr	map_scroll_x		; Draw a single column of CHR.
  740                        	
  741    02:C0D7  80 E0      			bra	.finished
  742                        	
  743                        			.endp
  744                        	
  745                        	
  746                        	
  747                        	; ***************************************************************************
  748                        	; ***************************************************************************
  749                        	;
  750                        	; _get_map_block - Get the block number used at a map pixel coordinate.
  751                        	; _sgx_get_map_block - Get the block number used at a map pixel coordinate.
  752                        	;
  753                        	; unsigned char __fastcall _get_map_block( unsigned int x<map_pxl_x>, unsigned int y<map_pxl_y> );
  754                        	; unsigned char __fastcall _sgx_get_map_block( unsigned int x<map_pxl_x>, unsigned int y<map_pxl_y> );
  755                        	;
  756                        	
  757               0001     		.if	SUPPORT_SGX
  758                        	
  759                        			.proc	_sgx_get_map_block.2
  765                        			.endp
  766                        		.endif
  767                        	
  768    02:C0D9             			.proc	_get_map_block.2
  769                        	
  770    02:C0D9  82         			clx				; Offset to PCE VDC.
  771                        	
  772    02:C0DA  43 04      			tma2				; Preserve MPR2..MPR4.
  773    02:C0DC  48         			pha
  774    02:C0DD  43 08      			tma3
  775    02:C0DF  48         			pha
  776    02:C0E0  43 10      			tma4
  777    02:C0E2  48         			pha
  778               0000     		.if	BLKMAP_LARGEMAP
  781                        		.endif
  782                        	
  783    02:C0E3  20 3E C1   			jsr	xvt_pxl_2_chr		; Set up the query coordinates.
  784                        	
  785    02:C0E6  20 6C C1   			jsr	map_chr_2_data		; Page in the map address.
  786                        	
  787    02:C0E9  B2 EC      			lda	[_bp]			; Read the BLK from the map.
  788    02:C0EB  A8         			tay
  789                        	
  790    02:C0EC  A5 FC      			lda	<map_chr_x		; Calc the BLK address offset
  791    02:C0EE  4A         			lsr	a			; use depending upon even/odd
  792    02:C0EF  A5 FE      			lda	<map_chr_y		; CHR coordinates (not BAT to
  793    02:C0F1  29 01      			and	#1			; support unaligned drawing).
  794    02:C0F3  2A         			rol	a
  795    02:C0F4  09 04      			ora	#4			; Offset to BLK table top byte.
  796    02:C0F6  7D B2 2B   			adc.h	vdc_blk_addr, x		; What is the BLK data address?
  797    02:C0F9  85 ED      			sta.h	<_bp			; $4000, $4800, $5000 or $5800.
  798    02:C0FB  64 EC      			stz.l	<_bp
  799    02:C0FD  B1 EC      			lda	[_bp], y		; Read the collision flags from
  800    02:C0FF  29 0C      			and	#%00001100		; the top byte of the CHR.
  801    02:C101  4A         			lsr	a
  802    02:C102  4A         			lsr	a
  803    02:C103  4A         			lsr	a			; Swizzle the bottom bit to get
  804    02:C104  90 02      			bcc	!+			; the same bit order as used in
  805    02:C106  09 02      			ora	#2			; .HALTMAP layer.
  806    02:C108  8D AA 2B   	!:		sta	map_blk_flag
  807                        	
  808    02:C10B  BD B0 2B   			lda	vdc_tbl_bank, x		; Is there a table of flags?
  809    02:C10E  F0 09      			beq	!+
  810    02:C110  53 08      			tam3
  811                        	;		inc	a
  812                        	;		tam4
  813                        	;		lda.l	vdc_tbl_addr, x
  814                        	;		sta.l	<_bp
  815    02:C112  BD AF 2B   			lda.h	vdc_tbl_addr, x		; If so, it must be aligned!
  816    02:C115  85 ED      			sta.h	<_bp
  817    02:C117  B1 EC      			lda	[_bp], y		; Read the .MASKMAP/.OVERMAP
  818    02:C119  8D AB 2B   	!:		sta	map_blk_mask		; flag value for this BLK.
  819                        	
  820               0000     		.if	BLKMAP_LARGEMAP
  823                        		.endif
  824    02:C11C  68         			pla				; Restore MPR2..MPR4.
  825    02:C11D  53 10      			tam4
  826    02:C11F  68         			pla
  827    02:C120  53 08      			tam3
  828    02:C122  68         			pla
  829    02:C123  53 04      			tam2
  830                        	
  831    02:C125  02         			sxy				; Put the BLK number in X.
  832    02:C126  C2         			cly
  833                        	
  834                        			leave				; All done!
         02:C127  4C EF FF   			jmp	leave_proc
  835                        	
  836                        			.endp
  837                        	
  838                        	
  839                        	
  840                        	; ***************************************************************************
  841                        	; ***************************************************************************
  842                        	;
  843                        	; map_pxl_2_chr - Convert PXL to CHR, BLK and SCR coordinates.
  844                        	;
  845                        	
  846    02:C12A  BD 7B 26   	map_pxl_2_chr:	lda.l	vdc_map_pxl_y, x	; Get current map Y coordinate.
  847    02:C12D  85 FE      			sta.l	<map_pxl_y
  848    02:C12F  BD 7C 26   			lda.h	vdc_map_pxl_y, x
  849    02:C132  85 FF      			sta.h	<map_pxl_y
  850                        	
  851    02:C134  BD 79 26   			lda.l	vdc_map_pxl_x, x	; Get current map X coordinate.
  852    02:C137  85 FC      			sta.l	<map_pxl_x
  853    02:C139  BD 7A 26   			lda.h	vdc_map_pxl_x, x
  854    02:C13C  85 FD      			sta.h	<map_pxl_x
  855                        	
  856    02:C13E  A5 FD      	xvt_pxl_2_chr:	lda.h	<map_pxl_x		; Xvert map_pxl_x to map_chr_x.
  857               0001     		.if	BLKMAP_MULTISCR
  858    02:C140  A8         			tay				; Xvert map_pxl_x to map_scrn_x.
  859    02:C141  3C 70 26   			bit	vdc_bat_width, x
  860    02:C144  70 03      			bvs	.w64
  861    02:C146  10 02      			bpl	.w32
  862    02:C148  4A         	.w128:		lsr	a
  863    02:C149  4A         	.w64:		lsr	a
  864    02:C14A  85 FD      	.w32:		sta	<map_scrn_x
  865    02:C14C  98         			tya
  866                        		.endif
  867    02:C14D  4A         			lsr	a
  868    02:C14E  66 FC      			ror.l	<map_pxl_x
  869    02:C150  4A         			lsr	a
  870    02:C151  66 FC      			ror.l	<map_pxl_x
  871    02:C153  4A         			lsr	a
  872    02:C154  66 FC      			ror.l	<map_pxl_x		; Max map width is 256 CHR.
  873                        	
  874    02:C156  A5 FF      			lda.h	<map_pxl_y		; Xvert map_pxl_y to map_chr_y.
  875               0001     		.if	BLKMAP_MULTISCR
  876    02:C158  A8         			tay				; Xvert map_pxl_y to map_scrn_y.
  877    02:C159  3C 71 26   			bit	vdc_bat_height, x
  878    02:C15C  50 01      			bvc	.h32
  879    02:C15E  4A         	.h64:		lsr	a
  880    02:C15F  85 FF      	.h32:		sta	<map_scrn_y
  881    02:C161  98         			tya
  882                        		.endif
  883    02:C162  4A         			lsr	a
  884    02:C163  66 FE      			ror.l	<map_pxl_y
  885    02:C165  4A         			lsr	a
  886    02:C166  66 FE      			ror.l	<map_pxl_y
  887    02:C168  4A         			lsr	a
  888    02:C169  66 FE      			ror.l	<map_pxl_y		; Max map width is 256 CHR.
  889                        	
  890    02:C16B  60         			rts
  891                        	
  892                        	
  893                        	
  894                        	; ***************************************************************************
  895                        	; ***************************************************************************
  896                        	;
  897                        	; map_chr_2_data - Page in the MAP address for the CHR coordinates.
  898                        	;
  899                        	
  900    02:C16C             	map_chr_2_data:
  901                        	
  902               0001     		.if	BLKMAP_MULTISCR
  903                        	
  904                        			; Initialization for a multi-screen map.
  905                        	
  906    02:C16C  BD B9 2B   			lda	vdc_scr_bank, x		; Skip this if regular blkmap.
  907    02:C16F  F0 3A      			beq	.regular
  908                        	
  909    02:C171  A5 FC      	.multiscreen:	lda	<map_chr_x		; Compare old_x with cur_x.
  910    02:C173  3D 72 26   			and	vdc_bat_x_mask, x
  911    02:C176  85 F8      			sta	<map_bat_x		; Save BAT X chr coordinate.
  912                        	
  913    02:C178  A5 FE      			lda	<map_chr_y		; Save BAT Y chr coordinate.
  914    02:C17A  3D 73 26   			and	vdc_bat_y_mask, x
  915    02:C17D  85 F9      			sta	<map_bat_y
  916    02:C17F  4A         			lsr	a			; Map BLK Y coordinate.
  917    02:C180  85 EF      			sta.h	<map_line
  918    02:C182  62         			cla
  919    02:C183  3C 70 26   			bit	vdc_bat_width, x
  920    02:C186  30 08      			bmi	.w128
  921    02:C188  70 03      			bvs	.w64
  922    02:C18A  46 EF      	.w32:		lsr.h	<map_line
  923    02:C18C  6A         			ror	a
  924    02:C18D  46 EF      	.w64:		lsr.h	<map_line
  925    02:C18F  6A         			ror	a
  926    02:C190  46 EF      	.w128:		lsr.h	<map_line
  927    02:C192  6A         			ror	a
  928    02:C193  46 EF      			lsr.h	<map_line		; Hi-byte of (BLK Y * width).
  929    02:C195  6A         			ror	a
  930    02:C196  85 EE      			sta.l	<map_line		; Lo-byte of (BLK Y * width).
  931                        	
  932    02:C198  20 EC C1   			jsr	map_set_screen		; Put BLK & MAP in MPR2-MPR5.
  933                        	
  934    02:C19B  A5 F8      			lda	<map_bat_x		; Calc map data pointer.
  935    02:C19D  4A         			lsr	a			; Map BLK X coordinate.
  936    02:C19E  05 EE      			ora.l	<map_line
  937    02:C1A0  85 EC      			sta.l	<_bp
  938    02:C1A2  A5 EF      			lda.h	<map_line
  939    02:C1A4  18         			clc
  940    02:C1A5  7D B5 2B   			adc.h	vdc_map_addr, x		; N.B. 256-byte aligned!
  941    02:C1A8  85 ED      			sta.h	<_bp
  942                        	
  943    02:C1AA  60         			rts
  944                        	
  945                        		.endif	BLKMAP_MULTISCR
  946                        	
  947                        			; Initialization for a regular map.
  948                        	
  949    02:C1AB  A5 FC      	.regular:	lda	<map_chr_x		; Compare old_x with cur_x.
  950                        	;		bit	vdc_map_option, x	; Set bit7 to disable aligning
  951                        	;		bmi	!+			; BAT X with the map X.
  952    02:C1AD  3D 72 26   			and	vdc_bat_x_mask, x
  953    02:C1B0  85 F8      			sta	<map_bat_x		; Save BAT X chr coordinate.
  954                        	
  955    02:C1B2  A5 FE      	!:		lda	<map_chr_y		; A = map CHR Y coordinate.
  956    02:C1B4  A8         			tay
  957    02:C1B5  4A         			lsr	a
  958    02:C1B6  42         			say				; Y = map BLK Y coordinate.
  959                        	
  960                        	;		bit	vdc_map_option, x	; Set bit6 to disable aligning
  961                        	;		bvs	!+			; BAT Y with the map Y.
  962    02:C1B7  3D 73 26   			and	vdc_bat_y_mask, x
  963    02:C1BA  85 F9      			sta	<map_bat_y		; Save BAT Y chr coordinate.
  964                        	
  965               0000     		.if	BLKMAP_LARGEMAP
  970                        		.endif
  971                        	
  972    02:C1BC  BD 77 26   	!:		lda	vdc_map_line_w, x	; Map width in BLK.
  973               0000     		.if	FAST_MULTIPLY
  986                        		.else
  987    02:C1BF  84 EF      			sty.h	<map_line		; Takes 144..176 cycles.
  988    02:C1C1  A0 08      			ldy	#8
  989    02:C1C3  4A         			lsr	a
  990    02:C1C4  85 EE      			sta.l	<map_line
  991    02:C1C6  62         			cla
  992    02:C1C7  90 03      			bcc	.rotate
  993    02:C1C9  18         	.add:		clc
  994    02:C1CA  65 EF      			adc.h	<map_line
  995    02:C1CC  6A         	.rotate:	ror	a
  996    02:C1CD  66 EE      			ror.l	<map_line		; Lo-byte of (BLK Y * width).
  997    02:C1CF  88         			dey
  998    02:C1D0  B0 F7      			bcs	.add
  999    02:C1D2  D0 F8      			bne	.rotate
 1000    02:C1D4  A8         			tay				; Hi-byte of (BLK Y * width).
 1001                        		.endif
 1002                        	
 1003    02:C1D5  A5 FC      	!:		lda	<map_chr_x		; Map CHR X coordinate.
 1004    02:C1D7  4A         			lsr	a			; Map BLK X coordinate.
 1005    02:C1D8  18         			clc
 1006    02:C1D9  65 EE      			adc.l	<map_line		; Lo-byte of (BLK Y * width).
 1007    02:C1DB  90 01      			bcc	!+
 1008    02:C1DD  C8         			iny				; Hi-byte of (BLK Y * width).
 1009                        	
 1010    02:C1DE  18         	!:		clc				; Calc map data pointer.
 1011    02:C1DF  7D B4 2B   			adc.l	vdc_map_addr, x
 1012    02:C1E2  85 EC      			sta.l	<_bp			; Maximum map size is 16KBytes
 1013    02:C1E4  98         			tya				; so we don't need to consider
 1014    02:C1E5  7D B5 2B   			adc.h	vdc_map_addr, x		; bank overflow.
 1015    02:C1E8  85 ED      			sta.h	<_bp
 1016                        	
 1017    02:C1EA  80 66      			bra	map_set_banks		; Put BLK & MAP in MPR2-MPR5.
 1018                        	
 1019                        	
 1020                        	
 1021               0001     		.if	BLKMAP_MULTISCR
 1022                        	
 1023                        	; ***************************************************************************
 1024                        	; ***************************************************************************
 1025                        	;
 1026                        	; map_set_screen -
 1027                        	;
 1028                        	; Maximum X and Y dimension of 128 screens (32768 pixels).
 1029                        	; Maximum 8KByte total size of screen data (1024 screens).
 1030                        	;
 1031                        	
 1032    02:C1EC  A4 FF      	map_set_screen:	ldy	<map_scrn_y		; Map SCR Y coordinate.
 1033    02:C1EE  BD 78 26   			lda	vdc_map_scrn_w, x	; Map width in SCREENS.
 1034                        	
 1035               0000     		.if	FAST_MULTIPLY
 1048                        		.else
 1049    02:C1F1  84 ED      			sty.h	<_bp			; Takes 144..176 cycles.
 1050    02:C1F3  A0 08      			ldy	#8
 1051    02:C1F5  4A         			lsr	a
 1052    02:C1F6  85 EC      			sta.l	<_bp
 1053    02:C1F8  62         			cla
 1054    02:C1F9  90 03      			bcc	.rotate
 1055    02:C1FB  18         	.add:		clc
 1056    02:C1FC  65 ED      			adc.h	<_bp
 1057    02:C1FE  6A         	.rotate:	ror	a
 1058    02:C1FF  66 EC      			ror.l	<_bp			; Lo-byte of (SCR Y * width).
 1059    02:C201  88         			dey
 1060    02:C202  B0 F7      			bcs	.add
 1061    02:C204  D0 F8      			bne	.rotate
 1062    02:C206  A8         			tay				; Hi-byte of (SCR Y * width).
 1063                        		.endif
 1064                        	
 1065    02:C207  A5 FD      			lda	<map_scrn_x		; Map SCR X coordinate.
 1066    02:C209  18         			clc
 1067    02:C20A  65 EC      			adc.l	<_bp
 1068    02:C20C  90 01      			bcc	!+
 1069    02:C20E  C8         			iny
 1070                        	
 1071    02:C20F  84 ED      	!:		sty.h	<_bp			; 2 bytes per screen entry, max
 1072    02:C211  0A         			asl	a			; 8KByte screen table.
 1073    02:C212  26 ED      			rol.h	<_bp
 1074               0001     		.if	BLKDEF_POINTERS == 0
 1075    02:C214  0A         			asl	a			; 8 bytes per screen entry when
 1076    02:C215  26 ED      			rol.h	<_bp			; not using BLK pointers.
 1077    02:C217  0A         			asl	a
 1078    02:C218  26 ED      			rol.h	<_bp
 1079                        		.endif
 1080                        	
 1081    02:C21A  7D B7 2B   			adc.l	vdc_scr_addr, x		; Calc screen data pointer.
 1082    02:C21D  85 EC      			sta.l	<_bp			; Maximum data size is 8KBytes
 1083    02:C21F  A5 ED      			lda.h	<_bp			; so we don't need to consider
 1084    02:C221  7D B8 2B   			adc.h	vdc_scr_addr, x		; bank overflow.
 1085    02:C224  85 ED      			sta.h	<_bp
 1086                        	
 1087    02:C226  BD B9 2B   			lda	vdc_scr_bank, x		; Map the SCR data in MPR3..MPR4.
 1088    02:C229  53 08      			tam3
 1089    02:C22B  1A         			inc	a
 1090    02:C22C  53 10      			tam4
 1091                        	
 1092    02:C22E  C2         			cly
 1093    02:C22F  B1 EC      			lda	[_bp], y		; Get SCR_MAP_PAGE.
 1094    02:C231  9D B5 2B   			sta.h	vdc_map_addr, x
 1095    02:C234  C8         			iny
 1096    02:C235  B1 EC      			lda	[_bp], y		; Get SCR_MAP_BANK.
 1097    02:C237  9D B6 2B   			sta	vdc_map_bank, x
 1098                        	
 1099               0001     		.if	BLKDEF_POINTERS == 0
 1100    02:C23A  C8         			iny
 1101    02:C23B  B1 EC      			lda	[_bp], y		; Get SCR_BLK_PAGE.
 1102    02:C23D  9D B2 2B   			sta.h	vdc_blk_addr, x
 1103    02:C240  C8         			iny
 1104    02:C241  B1 EC      			lda	[_bp], y		; Get SCR_BLK_BANK.
 1105    02:C243  9D B3 2B   			sta	vdc_blk_bank, x
 1106    02:C246  C8         			iny
 1107    02:C247  B1 EC      			lda	[_bp], y		; Get SCR_TBL_PAGE.
 1108    02:C249  9D AF 2B   			sta.h	vdc_tbl_addr, x
 1109    02:C24C  C8         			iny
 1110    02:C24D  B1 EC      			lda	[_bp], y		; Get SCR_TBL_BANK.
 1111    02:C24F  9D B0 2B   			sta	vdc_tbl_bank, x
 1112               0000     		.if	0				; These are not currently used.
 1119                        		.endif
 1120                        		.endif
 1121                        	
 1122                        	;		lda	vdc_bat_width, x	; Set up the map width.
 1123                        	;		lsr	a			; This should have been set
 1124                        	;		sta	vdc_map_line_w, x	; with the multi-screen map.
 1125                        	
 1126                        	;		jmp	map_set_banks		; Put BLK & MAP in MPR2-MPR5.
 1127                        	
 1128                        			; Fall through to map_set_banks.
 1129                        	
 1130                        		.endif	BLKMAP_MULTISCR
 1131                        	
 1132                        	
 1133                        	
 1134                        	; ***************************************************************************
 1135                        	; ***************************************************************************
 1136                        	;
 1137                        	; map_set_banks - Put BLK & MAP in MPR2-MPR5.
 1138                        	;
 1139                        	
 1140    02:C252  BD B3 2B   	map_set_banks:	lda	vdc_blk_bank, x		; Put the BLK into MPR2.
 1141    02:C255  53 04      			tam2
 1142                        	
 1143    02:C257  BD B6 2B   			lda	vdc_map_bank, x		; Put the MAP into MPR3-MPR5.
 1144    02:C25A  53 08      			tam3
 1145    02:C25C  1A         			inc	a
 1146    02:C25D  53 10      			tam4
 1147               0000     		.if	BLKMAP_LARGEMAP
 1156                        		.endif
 1157                        	
 1158    02:C25F  60         	!:		rts
 1159                        	
 1160                        	
 1161                        	
 1162                        	; ***************************************************************************
 1163                        	; ***************************************************************************
 1164                        	;
 1165                        	; map_scroll_x - Update the BAT when X coordinate changes.
 1166                        	;
 1167                        	; N.B. This will alter map_chr_x and map_scrn_x if moved in +ve direction!
 1168                        	;
 1169                        	; N.B. This only ever draws a single column!
 1170                        	;
 1171                        	
 1172    02:C260  60         	!no_change:	rts
 1173                        	
 1174    02:C261             	map_scroll_x:
 1175                        	
 1176               0001     		.if	BLKMAP_MULTISCR
 1177                        	
 1178                        			; Initialization for a multi-screen map.
 1179                        	
 1180    02:C261  BD B9 2B   			lda	vdc_scr_bank, x		; Skip this if regular blkmap.
 1181    02:C264  F0 56      			beq	.regular
 1182                        	
 1183    02:C266  A5 FC      	.multiscreen:	lda	<map_chr_x		; Compare old_x with cur_x.
 1184    02:C268  DD AC 2B   			cmp	vdc_old_chr_x, x
 1185               0001     		.if	BLKMAP_TIMETEST == 0
 1186    02:C26B  F0 F3      			beq	!no_change-		; Do nothing if no change.
 1187                        		.endif
 1188    02:C26D  9D AC 2B   			sta	vdc_old_chr_x, x
 1189    02:C270  30 11      			bmi	!+			; Test the sign of the change.
 1190                        	
 1191    02:C272  18         			clc				; Draw RHS if chr_x >= old_x.
 1192    02:C273  3D 72 26   			and	vdc_bat_x_mask, x
 1193    02:C276  7D 75 26   			adc	vdc_map_draw_w, x	; Usually (SCR_WIDTH / 8) + 1.
 1194    02:C279  3A         			dec	a
 1195    02:C27A  85 FC      			sta	<map_chr_x		; Update CHR X chr coordinate.
 1196    02:C27C  3C 70 26   			bit	vdc_bat_width, x
 1197    02:C27F  F0 02      			beq	!+
 1198    02:C281  E6 FD      			inc	<map_scrn_x		; Wrapped to the next screen.
 1199                        	
 1200    02:C283  3D 72 26   	!:		and	vdc_bat_x_mask, x
 1201    02:C286  85 F8      			sta	<map_bat_x		; Save BAT X chr coordinate.
 1202                        	
 1203    02:C288  A5 FE      			lda	<map_chr_y		; Save BAT Y chr coordinate.
 1204    02:C28A  3D 73 26   			and	vdc_bat_y_mask, x
 1205    02:C28D  85 F9      			sta	<map_bat_y
 1206    02:C28F  4A         			lsr	a			; Map BLK Y coordinate.
 1207    02:C290  85 EF      			sta.h	<map_line
 1208    02:C292  62         			cla
 1209    02:C293  3C 70 26   			bit	vdc_bat_width, x
 1210    02:C296  30 08      			bmi	.w128
 1211    02:C298  70 03      			bvs	.w64
 1212    02:C29A  46 EF      	.w32:		lsr.h	<map_line
 1213    02:C29C  6A         			ror	a
 1214    02:C29D  46 EF      	.w64:		lsr.h	<map_line
 1215    02:C29F  6A         			ror	a
 1216    02:C2A0  46 EF      	.w128:		lsr.h	<map_line
 1217    02:C2A2  6A         			ror	a
 1218    02:C2A3  46 EF      			lsr.h	<map_line		; Hi-byte of (BLK Y * width).
 1219    02:C2A5  6A         			ror	a
 1220    02:C2A6  85 EE      			sta.l	<map_line		; Lo-byte of (BLK Y * width).
 1221                        	
 1222    02:C2A8  20 EC C1   			jsr	map_set_screen		; Put BLK & MAP in MPR2-MPR5.
 1223                        	
 1224    02:C2AB  A5 F8      			lda	<map_bat_x		; Calc map data pointer.
 1225    02:C2AD  4A         			lsr	a			; Map BLK X coordinate.
 1226    02:C2AE  05 EE      			ora.l	<map_line
 1227    02:C2B0  85 EC      			sta.l	<_bp
 1228    02:C2B2  A5 EF      			lda.h	<map_line
 1229    02:C2B4  18         			clc
 1230    02:C2B5  7D B5 2B   			adc.h	vdc_map_addr, x		; N.B. 256-byte aligned!
 1231    02:C2B8  85 ED      			sta.h	<_bp
 1232                        	
 1233    02:C2BA  80 5D      			bra	.draw_col		; Now draw it.
 1234                        	
 1235                        		.endif	BLKMAP_MULTISCR
 1236                        	
 1237                        			; Initialization for a regular map.
 1238                        	
 1239    02:C2BC  A5 FC      	.regular:	lda	<map_chr_x		; Compare old_x with cur_x.
 1240    02:C2BE  DD AC 2B   			cmp	vdc_old_chr_x, x
 1241               0001     		.if	BLKMAP_TIMETEST == 0
 1242    02:C2C1  F0 9D      			beq	!no_change-		; Do nothing if no change.
 1243                        		.endif
 1244    02:C2C3  9D AC 2B   			sta	vdc_old_chr_x, x
 1245    02:C2C6  30 07      			bmi	!+			; Test the sign of the change.
 1246                        	
 1247    02:C2C8  18         			clc				; Draw RHS if chr_x >= old_x.
 1248    02:C2C9  7D 75 26   			adc	vdc_map_draw_w, x	; Usually (SCR_WIDTH / 8) + 1.
 1249    02:C2CC  3A         			dec	a
 1250    02:C2CD  85 FC      			sta	<map_chr_x		; Update CHR X chr coordinate.
 1251                        	
 1252    02:C2CF  3C 7D 26   	!:		bit	vdc_map_option, x	; Set bit7 to disable aligning
 1253    02:C2D2  30 05      			bmi	!+			; BAT X with the map X.
 1254    02:C2D4  3D 72 26   			and	vdc_bat_x_mask, x
 1255    02:C2D7  85 F8      			sta	<map_bat_x		; Save BAT X chr coordinate.
 1256                        	
 1257    02:C2D9  A5 FE      	!:		lda	<map_chr_y		; A = map CHR Y coordinate.
 1258    02:C2DB  A8         			tay
 1259    02:C2DC  4A         			lsr	a
 1260    02:C2DD  42         			say				; Y = map BLK Y coordinate.
 1261                        	
 1262    02:C2DE  3C 7D 26   			bit	vdc_map_option, x	; Set bit6 to disable aligning
 1263    02:C2E1  70 05      			bvs	!+			; BAT Y with the map Y.
 1264    02:C2E3  3D 73 26   			and	vdc_bat_y_mask, x
 1265    02:C2E6  85 F9      			sta	<map_bat_y		; Save BAT Y chr coordinate.
 1266                        	
 1267               0000     		.if	BLKMAP_LARGEMAP
 1272                        		.endif
 1273                        	
 1274    02:C2E8  BD 77 26   	!:		lda	vdc_map_line_w, x	; Map width in BLK.
 1275               0000     		.if	FAST_MULTIPLY
 1288                        		.else
 1289    02:C2EB  84 EF      			sty.h	<map_line		; Takes 144..176 cycles.
 1290    02:C2ED  A0 08      			ldy	#8
 1291    02:C2EF  4A         			lsr	a
 1292    02:C2F0  85 EE      			sta.l	<map_line
 1293    02:C2F2  62         			cla
 1294    02:C2F3  90 03      			bcc	.rotate
 1295    02:C2F5  18         	.add:		clc
 1296    02:C2F6  65 EF      			adc.h	<map_line
 1297    02:C2F8  6A         	.rotate:	ror	a
 1298    02:C2F9  66 EE      			ror.l	<map_line		; Lo-byte of (BLK Y * width).
 1299    02:C2FB  88         			dey
 1300    02:C2FC  B0 F7      			bcs	.add
 1301    02:C2FE  D0 F8      			bne	.rotate
 1302    02:C300  A8         			tay				; Hi-byte of (BLK Y * width).
 1303                        		.endif
 1304                        	
 1305    02:C301  A5 FC      	!:		lda	<map_chr_x		; Map CHR X coordinate.
 1306    02:C303  4A         			lsr	a			; Map BLK X coordinate.
 1307    02:C304  18         			clc
 1308    02:C305  65 EE      			adc.l	<map_line		; Lo-byte of (BLK Y * width).
 1309    02:C307  90 01      			bcc	!+
 1310    02:C309  C8         			iny				; Hi-byte of (BLK Y * width).
 1311                        	
 1312    02:C30A  18         	!:		clc				; Calc map data pointer.
 1313    02:C30B  7D B4 2B   			adc.l	vdc_map_addr, x
 1314    02:C30E  85 EC      			sta.l	<_bp			; Maximum map size is 16KBytes
 1315    02:C310  98         			tya				; so we don't need to consider
 1316    02:C311  7D B5 2B   			adc.h	vdc_map_addr, x		; bank overflow.
 1317    02:C314  85 ED      			sta.h	<_bp
 1318                        	
 1319    02:C316  20 52 C2   			jsr	map_set_banks		; Put BLK & MAP in MPR2-MPR5.
 1320                        	
 1321                        			; Draw the first part of the column.
 1322                        	
 1323    02:C319  A5 F8      	.draw_col:	lda	<map_bat_x		; Set the BAT VRAM destination
 1324    02:C31B  85 F0      			sta.l	<_di			; coordinates.
 1325    02:C31D  A5 F9      			lda	<map_bat_y
 1326    02:C31F  85 F1      			sta.h	<_di
 1327                        	
 1328    02:C321  5D 73 26   			eor	vdc_bat_y_mask, x	; Calc CHR before wrap.
 1329    02:C324  1A         			inc	a
 1330    02:C325  DD 76 26   			cmp	vdc_map_draw_h, x	; Usually (SCR_HEIGHT / 8) + 1.
 1331    02:C328  90 03      			bcc	!+
 1332    02:C32A  BD 76 26   			lda	vdc_map_draw_h, x	; Maximum CHR to draw.
 1333    02:C32D  85 00      	!:		sta	<map_count		; Set number of CHR to draw.
 1334    02:C32F  85 01      			sta	<map_drawn		; Preserve number of CHR drawn.
 1335                        	
 1336    02:C331  A9 05      			lda	#VDC_CR			; Set VDC auto-increment from
 1337    02:C333  95 F7      			sta	<vdc_reg, x		; the BAT width, which is set
 1338    02:C335  9D 00 02   			sta	VDC_AR, x		; up by set_screen_size().
 1339    02:C338  B5 F4      			lda	<vdc_crh, x
 1340    02:C33A  9D 03 02   			sta	VDC_DH, x
 1341                        	
 1342    02:C33D  20 7F C6   			jsr	blk_col_strip		; Draw top of vertical strip.
 1343                        	
 1344                        			; Wrap around and draw the rest of the column (if needed).
 1345                        	
 1346    02:C340  38         			sec				; Are there any more CHR that
 1347    02:C341  BD 76 26   			lda	vdc_map_draw_h, x	; need to be drawn?
 1348    02:C344  E5 01      			sbc	<map_drawn
 1349    02:C346  F0 2C      			beq	.done
 1350                        	
 1351    02:C348  85 00      			sta	<map_count		; Set number of CHR to draw.
 1352                        	
 1353    02:C34A  A5 FE      			lda	<map_chr_y		; Update CHR Y coordinate for
 1354    02:C34C  48         			pha				; drawing unaligned tiles.
 1355    02:C34D  18         			clc
 1356    02:C34E  65 01      			adc	<map_drawn
 1357    02:C350  85 FE      			sta	<map_chr_y
 1358                        	
 1359               0001     		.if	BLKMAP_MULTISCR
 1360    02:C352  BD B9 2B   			lda	vdc_scr_bank, x		; Skip this if regular blkmap.
 1361    02:C355  F0 0F      			beq	!+
 1362                        	
 1363    02:C357  E6 FF      			inc	<map_scrn_y		; Wrapped to the next screen.
 1364                        	
 1365    02:C359  20 EC C1   			jsr	map_set_screen		; Put BLK & MAP in MPR2-MPR5.
 1366                        	
 1367    02:C35C  A5 F8      			lda	<map_bat_x		; Calc map data pointer.
 1368    02:C35E  4A         			lsr	a			; Map BLK X coordinate.
 1369    02:C35F  85 EC      			sta.l	<_bp
 1370    02:C361  BD B5 2B   			lda.h	vdc_map_addr, x		; N.B. 256-byte aligned!
 1371    02:C364  85 ED      			sta.h	<_bp
 1372                        		.endif
 1373                        	
 1374    02:C366  A5 F8      	!:		lda	<map_bat_x		; Set the BAT VRAM destination
 1375    02:C368  85 F0      			sta.l	<_di			; coordinates.
 1376    02:C36A  64 F1      			stz.h	<_di			; Reset 1st row to draw.
 1377                        	
 1378    02:C36C  20 7F C6   			jsr	blk_col_strip		; Draw btm of vertical strip.
 1379                        	
 1380               0001     		.if	BLKMAP_MULTISCR
 1381    02:C36F  C6 FF      			dec	<map_scrn_y		; Restore, no check if should.
 1382                        		.endif
 1383                        	
 1384    02:C371  68         			pla				; Restore CHR Y coordinate, we
 1385    02:C372  85 FE      			sta	<map_chr_y		; might draw another column!
 1386                        	
 1387    02:C374  A9 05      	.done:		lda	#VDC_CR			; Set VDC auto-increment to 1.
 1388    02:C376  95 F7      			sta	<vdc_reg, x
 1389    02:C378  9D 00 02   			sta	VDC_AR, x
 1390    02:C37B  9E 03 02   			stz	VDC_DH, x
 1391                        	
 1392    02:C37E  60         			rts
 1393                        	
 1394                        	
 1395                        	
 1396                        	; ***************************************************************************
 1397                        	; ***************************************************************************
 1398                        	;
 1399                        	; map_scroll_y - Update the BAT when Y coordinate changes.
 1400                        	;
 1401                        	; N.B. This will alter map_chr_y and map_scrn_y if moved in +ve direction!
 1402                        	;
 1403                        	; N.B. This draws multiple rows when called from _draw_map or _blit_map.
 1404                        	;
 1405                        	
 1406    02:C37F  60         	!no_change:	rts
 1407                        	
 1408    02:C380             	map_scroll_y:
 1409                        	
 1410               0001     		.if	BLKMAP_MULTISCR
 1411                        	
 1412                        			; Initialization for a multi-screen map.
 1413                        	
 1414    02:C380  BD B9 2B   			lda	vdc_scr_bank, x		; Skip this if regular blkmap.
 1415    02:C383  F0 56      			beq	.regular
 1416                        	
 1417    02:C385  A5 FE      	.multiscr:	lda	<map_chr_y		; Compare old_y with cur_y.
 1418    02:C387  DD AD 2B   			cmp	vdc_old_chr_y, x
 1419               0001     		.if	BLKMAP_TIMETEST == 0
 1420    02:C38A  F0 F3      			beq	!no_change-		; Do nothing if no change.
 1421                        		.endif
 1422    02:C38C  9D AD 2B   			sta	vdc_old_chr_y, x
 1423    02:C38F  30 11      			bmi	!+			; Test the sign of the change.
 1424                        	
 1425    02:C391  18         			clc				; Draw bottom if chr_y >= old_y.
 1426    02:C392  3D 73 26   			and	vdc_bat_y_mask, x
 1427    02:C395  7D 76 26   			adc	vdc_map_draw_h, x	; Usually (SCR_HEIGHT / 8) + 1.
 1428    02:C398  3A         			dec	a
 1429    02:C399  85 FE      			sta	<map_chr_y		; Update CHR Y chr coordinate.
 1430    02:C39B  3C 71 26   			bit	vdc_bat_height, x
 1431    02:C39E  F0 02      			beq	!+
 1432    02:C3A0  E6 FF      			inc	<map_scrn_y		; Wrapped to the next screen.
 1433                        	
 1434    02:C3A2  3D 73 26   	!:		and	vdc_bat_y_mask, x
 1435    02:C3A5  85 F9      			sta	<map_bat_y		; Save BAT Y chr coordinate.
 1436                        	
 1437    02:C3A7  4A         			lsr	a			; Map BLK Y coordinate.
 1438    02:C3A8  85 EF      			sta.h	<map_line
 1439    02:C3AA  62         			cla
 1440    02:C3AB  3C 70 26   			bit	vdc_bat_width, x
 1441    02:C3AE  30 08      			bmi	.w128
 1442    02:C3B0  70 03      			bvs	.w64
 1443    02:C3B2  46 EF      	.w32:		lsr.h	<map_line
 1444    02:C3B4  6A         			ror	a
 1445    02:C3B5  46 EF      	.w64:		lsr.h	<map_line
 1446    02:C3B7  6A         			ror	a
 1447    02:C3B8  46 EF      	.w128:		lsr.h	<map_line
 1448    02:C3BA  6A         			ror	a
 1449    02:C3BB  46 EF      			lsr.h	<map_line		; Hi-byte of (BLK Y * width).
 1450    02:C3BD  6A         			ror	a
 1451    02:C3BE  85 EE      			sta.l	<map_line		; Lo-byte of (BLK Y * width).
 1452                        	
 1453    02:C3C0  A5 FC      			lda	<map_chr_x
 1454    02:C3C2  3D 72 26   			and	vdc_bat_x_mask, x
 1455    02:C3C5  85 F8      			sta	<map_bat_x		; Save BAT X chr coordinate.
 1456                        	
 1457                        			; Loop to here if drawing multiple multi-screen rows.
 1458                        	
 1459    02:C3C7  20 EC C1   	.multiscr_row:	jsr	map_set_screen		; Put BLK & MAP in MPR2-MPR5.
 1460                        	
 1461    02:C3CA  A5 F8      			lda	<map_bat_x		; Calc map data pointer.
 1462    02:C3CC  4A         			lsr	a			; Map BLK X coordinate.
 1463    02:C3CD  05 EE      			ora.l	<map_line
 1464    02:C3CF  85 EC      			sta.l	<_bp
 1465    02:C3D1  A5 EF      			lda.h	<map_line
 1466    02:C3D3  18         			clc
 1467    02:C3D4  7D B5 2B   			adc.h	vdc_map_addr, x		; N.B. 256-byte aligned!
 1468    02:C3D7  85 ED      			sta.h	<_bp
 1469                        	
 1470    02:C3D9  80 60      			bra	.draw_row		; Now draw it.
 1471                        	
 1472                        		.endif	BLKMAP_MULTISCR
 1473                        	
 1474                        			; Initialization for a regular blkmap.
 1475                        	
 1476    02:C3DB  A5 FE      	.regular:	lda	<map_chr_y		; Compare old_y with cur_y.
 1477    02:C3DD  DD AD 2B   			cmp	vdc_old_chr_y, x
 1478               0001     		.if	BLKMAP_TIMETEST == 0
 1479    02:C3E0  F0 9D      			beq	!no_change-		; Do nothing if no change.
 1480                        		.endif
 1481    02:C3E2  9D AD 2B   			sta	vdc_old_chr_y, x
 1482    02:C3E5  30 07      			bmi	!+			; Test the sign of the change.
 1483                        	
 1484    02:C3E7  18         			clc				; Draw bottom if chr_y >= old_y.
 1485    02:C3E8  7D 76 26   			adc	vdc_map_draw_h, x	; Usually (SCR_HEIGHT / 8) + 1.
 1486    02:C3EB  3A         			dec	a
 1487    02:C3EC  85 FE      			sta	<map_chr_y		; Update CHR Y chr coordinate.
 1488                        	
 1489    02:C3EE  A8         	!:		tay				; A = map CHR Y coordinate.
 1490    02:C3EF  4A         			lsr	a
 1491    02:C3F0  42         			say				; Y = map BLK Y coordinate.
 1492                        	
 1493    02:C3F1  3C 7D 26   			bit	vdc_map_option, x	; Set bit6 to disable aligning
 1494    02:C3F4  70 05      			bvs	!+			; BAT Y with the map Y.
 1495    02:C3F6  3D 73 26   			and	vdc_bat_y_mask, x
 1496    02:C3F9  85 F9      			sta	<map_bat_y		; Save BAT Y chr coordinate.
 1497                        	
 1498    02:C3FB  3C 7D 26   	!:		bit	vdc_map_option, x	; Set bit7 to disable aligning
 1499    02:C3FE  30 07      			bmi	!+			; BAT X with the map X.
 1500    02:C400  A5 FC      			lda	<map_chr_x
 1501    02:C402  3D 72 26   			and	vdc_bat_x_mask, x
 1502    02:C405  85 F8      			sta	<map_bat_x		; Save BAT X chr coordinate.
 1503    02:C407             	!:
 1504                        	
 1505               0000     		.if	BLKMAP_LARGEMAP
 1510                        		.endif
 1511                        	
 1512    02:C407  BD 77 26   			lda	vdc_map_line_w, x	; Map width in BLK.
 1513               0000     		.if	FAST_MULTIPLY
 1526                        		.else
 1527    02:C40A  84 EF      			sty.h	<map_line		; Takes 144..176 cycles.
 1528    02:C40C  A0 08      			ldy	#8
 1529    02:C40E  4A         			lsr	a
 1530    02:C40F  85 EE      			sta.l	<map_line
 1531    02:C411  62         			cla
 1532    02:C412  90 03      			bcc	.rotate
 1533    02:C414  18         	.add:		clc
 1534    02:C415  65 EF      			adc.h	<map_line
 1535    02:C417  6A         	.rotate:	ror	a
 1536    02:C418  66 EE      			ror.l	<map_line		; Lo-byte of (BLK Y * width).
 1537    02:C41A  88         			dey
 1538    02:C41B  B0 F7      			bcs	.add
 1539    02:C41D  D0 F8      			bne	.rotate
 1540    02:C41F  85 EF      			sta.h	<map_line		; Hi-byte of (BLK Y * width).
 1541                        		.endif
 1542                        	
 1543    02:C421  20 52 C2   			jsr	map_set_banks		; Put BLK & MAP in MPR2-MPR5.
 1544                        	
 1545                        			; Loop to here if drawing multiple regular blkmap rows.
 1546                        	
 1547    02:C424  A4 EF      	.regular_row:	ldy.h	<map_line		; Hi-byte of (BLK Y * width).
 1548    02:C426  A5 FC      			lda	<map_chr_x		; Map CHR X coordinate.
 1549    02:C428  4A         			lsr	a			; Map BLK X coordinate.
 1550    02:C429  18         			clc
 1551    02:C42A  65 EE      			adc.l	<map_line		; Lo-byte of (BLK Y * width).
 1552    02:C42C  90 01      			bcc	!+
 1553    02:C42E  C8         			iny
 1554    02:C42F  18         	!:		clc				; Calc map data pointer.
 1555    02:C430  7D B4 2B   			adc.l	vdc_map_addr, x
 1556    02:C433  85 EC      			sta.l	<_bp			; Maximum map size is 16KBytes
 1557    02:C435  98         			tya				; so we don't need to consider
 1558    02:C436  7D B5 2B   			adc.h	vdc_map_addr, x		; bank overflow.
 1559    02:C439  85 ED      			sta.h	<_bp
 1560                        	
 1561                        			; Draw the first part of the row.
 1562                        	
 1563    02:C43B  A5 F9      	.draw_row:	lda	<map_bat_y		; Set the BAT VRAM destination
 1564    02:C43D  85 F1      			sta.h	<_di			; coordinates.
 1565    02:C43F  A5 F8      			lda	<map_bat_x
 1566    02:C441  85 F0      			sta.l	<_di
 1567                        	
 1568    02:C443  5D 72 26   			eor	vdc_bat_x_mask, x	; Calc CHR before wrap.
 1569    02:C446  1A         			inc	a
 1570    02:C447  C5 FA      			cmp	<map_draw_w		; Usually (SCR_WIDTH / 8) + 1.
 1571    02:C449  90 02      			bcc	!+
 1572    02:C44B  A5 FA      			lda	<map_draw_w		; Maximum CHR to draw.
 1573    02:C44D  85 00      	!:		sta	<map_count		; Set number of CHR to draw.
 1574    02:C44F  85 01      			sta	<map_drawn		; Preserve number of CHR drawn.
 1575                        	
 1576    02:C451  20 C1 C4   			jsr	blk_row_strip		; Draw lhs of horizontal strip.
 1577                        	
 1578                        			; Wrap around and draw the rest of the row (if needed).
 1579                        	
 1580    02:C454  38         			sec				; Are there any more CHR that
 1581    02:C455  A5 FA      			lda	<map_draw_w		; need to be drawn?
 1582    02:C457  E5 01      			sbc	<map_drawn
 1583    02:C459  F0 2E      			beq	.done_row
 1584                        	
 1585    02:C45B  85 00      			sta	<map_count		; Set number of CHR to draw.
 1586                        	
 1587    02:C45D  A5 FC      			lda	<map_chr_x		; Update CHR X coordinate for
 1588    02:C45F  48         			pha				; drawing unaligned tiles.
 1589    02:C460  18         			clc
 1590    02:C461  65 01      			adc	<map_drawn
 1591    02:C463  85 FC      			sta	<map_chr_x
 1592                        	
 1593               0001     		.if	BLKMAP_MULTISCR
 1594    02:C465  BD B9 2B   			lda	vdc_scr_bank, x		; Skip this if regular blkmap.
 1595    02:C468  F0 11      			beq	!+
 1596                        	
 1597    02:C46A  E6 FD      			inc	<map_scrn_x		; Wrapped to the next screen.
 1598                        	
 1599    02:C46C  20 EC C1   			jsr	map_set_screen		; Locate screen's BLK and MAP.
 1600                        	
 1601    02:C46F  18         			clc				; Calc map data pointer.
 1602    02:C470  A5 EE      			lda.l	<map_line
 1603    02:C472  85 EC      			sta.l	<_bp
 1604    02:C474  A5 EF      			lda.h	<map_line
 1605    02:C476  7D B5 2B   			adc.h	vdc_map_addr, x		; N.B. 256-byte aligned!
 1606    02:C479  85 ED      			sta.h	<_bp
 1607                        		.endif
 1608                        	
 1609    02:C47B  A5 F9      	!:		lda	<map_bat_y		; Set the BAT VRAM destination
 1610    02:C47D  85 F1      			sta.h	<_di			; coordinates.
 1611    02:C47F  64 F0      			stz.l	<_di			; Reset 1st column to draw.
 1612                        	
 1613    02:C481  20 C1 C4   			jsr	blk_row_strip		; Draw rhs of horizontal strip.
 1614                        	
 1615               0001     		.if	BLKMAP_MULTISCR
 1616    02:C484  C6 FD      			dec	<map_scrn_x		; Restore, no check if should.
 1617                        		.endif	BLKMAP_MULTISCR
 1618                        	
 1619    02:C486  68         			pla				; Restore CHR X coordinate, we
 1620    02:C487  85 FC      			sta	<map_chr_x		; might draw another row!
 1621                        	
 1622    02:C489  C6 FB      	.done_row:	dec	<map_draw_h		; Are all desired rows drawn?
 1623    02:C48B  F0 33      			beq	.finished
 1624                        	
 1625    02:C48D  E6 FE      			inc	<map_chr_y		; Move CHR Y down by 1.
 1626                        	
 1627    02:C48F  A5 FE      			lda	<map_chr_y		; If new BLK then ...
 1628    02:C491  4A         			lsr	a
 1629    02:C492  B0 0B      			bcs	!+
 1630    02:C494  BD 77 26   			lda	vdc_map_line_w, x	; Move the map line pointer to
 1631    02:C497  65 EE      			adc.l	<map_line		; the next line.
 1632    02:C499  85 EE      			sta.l	<map_line
 1633    02:C49B  90 02      			bcc	!+
 1634    02:C49D  E6 EF      			inc.h	<map_line
 1635                        	
 1636    02:C49F  A5 F9      	!:		lda	<map_bat_y		; Move BAT Y down by 1.
 1637    02:C4A1  1A         			inc	a
 1638    02:C4A2  3D 73 26   			and	vdc_bat_y_mask, x
 1639    02:C4A5  85 F9      			sta	<map_bat_y
 1640                        	
 1641               0001     		.if	BLKMAP_MULTISCR
 1642    02:C4A7  BC B9 2B   			ldy	vdc_scr_bank, x		; Skip this if regular blkmap.
 1643    02:C4AA  D0 03 4C 24			beq	.regular_row
         02:C4AE  C4          
 1644                        	
 1645    02:C4AF  A8         			tay				; If wrapped to the top line of
 1646    02:C4B0  D0 0B      			bne	!+			; of the BAT then increment the
 1647    02:C4B2  E6 FF      			inc	<map_scrn_y		; screen.
 1648                        	
 1649    02:C4B4  BD 74 26   			lda	vdc_bat_limit, x	; The map line must wrap around
 1650    02:C4B7  4A         			lsr	a			; too. This is simple since its
 1651    02:C4B8  4A         			lsr	a			; size (in bytes) is 1/4 of the
 1652    02:C4B9  25 EF      			and.h	<map_line		; BAT size (in words) and it is
 1653    02:C4BB  85 EF      			sta.h	<map_line		; a power-of-2.
 1654                        	
 1655    02:C4BD  4C C7 C3   	!:		jmp	.multiscr_row		; Draw next row.
 1656                        		.else
 1658                        		.endif	BLKMAP_MULTISCR
 1659                        	
 1660    02:C4C0  60         	.finished:	rts
 1661                        	
 1662                        	
 1663                        	
 1664               0000     		.if	BLKDEF_POINTERS
 1858                        		.else	BLKDEF_POINTERS
 1859                        	
 1860                        	
 1861                        	
 1862                        	; ***************************************************************************
 1863                        	; ***************************************************************************
 1864                        	;
 1865                        	; blk_row_strip - Draw a single row of CHR into the BAT.
 1866                        	;
 1867                        	
 1868    02:C4C1  20 34 E4   	blk_row_strip:	jsr	set_di_xy_mawr		; Set the BAT VRAM destination.
 1869                        	
 1870    02:C4C4  A5 FC      			lda	<map_chr_x		; Select what drawing code to
 1871    02:C4C6  4A         			lsr	a			; use depending upon even/odd
 1872    02:C4C7  A5 FE      			lda	<map_chr_y		; CHR coordinates (not BAT to
 1873    02:C4C9  29 01      			and	#1			; support unaligned drawing).
 1874    02:C4CB  2A         			rol	a
 1875    02:C4CC  0A         			asl	a
 1876    02:C4CD  1D B2 2B   			ora.h	vdc_blk_addr, x		; What is the BLK data address?
 1877    02:C4D0  29 1E      			and	#%00011110		; $4000, $4800, $5000 or $5800.
 1878    02:C4D2  A8         			tay
 1879    02:C4D3  B9 E0 C4   			lda.h	.jump_table, y		; Push the address of the code.
 1880    02:C4D6  48         			pha
 1881    02:C4D7  B9 DF C4   			lda.l	.jump_table, y
 1882    02:C4DA  48         			pha
 1883                        	
 1884    02:C4DB  B2 EC      			lda	[_bp]			; Get the first BLK number.
 1885    02:C4DD  A8         			tay
 1886                        	
 1887    02:C4DE  60         			rts				; Jump to the drawing code.
 1888                        	
 1889    02:C4DF  01 C5      	.jump_table:	dw	b4000_top_even - 1
 1890    02:C4E1  14 C5      			dw	b4000_top_odd - 1
 1891    02:C4E3  31 C5      			dw	b4000_btm_even - 1
 1892    02:C4E5  44 C5      			dw	b4000_btm_odd - 1
 1893                        	
 1894    02:C4E7  61 C5      			dw	b4800_top_even - 1
 1895    02:C4E9  74 C5      			dw	b4800_top_odd - 1
 1896    02:C4EB  91 C5      			dw	b4800_btm_even - 1
 1897    02:C4ED  A4 C5      			dw	b4800_btm_odd - 1
 1898                        	
 1899    02:C4EF  C1 C5      			dw	b5000_top_even - 1
 1900    02:C4F1  D4 C5      			dw	b5000_top_odd - 1
 1901    02:C4F3  F1 C5      			dw	b5000_btm_even - 1
 1902    02:C4F5  04 C6      			dw	b5000_btm_odd - 1
 1903                        	
 1904    02:C4F7  21 C6      			dw	b5800_top_even - 1
 1905    02:C4F9  34 C6      			dw	b5800_top_odd - 1
 1906    02:C4FB  51 C6      			dw	b5800_btm_even - 1
 1907    02:C4FD  64 C6      			dw	b5800_btm_odd - 1
 1908                        	
 1909                        			; top horizontal (32+2 rept)
 1910                        			;
 1911                        			; 89 cycles per block * 17 -> 1513 cycles
 1912                        	
 1913    02:C4FF  B2 EC      	!repeat:	lda	[_bp]			; 7
 1914    02:C501  A8         			tay				; 2
 1915                        	
 1916    02:C502  B9 00 40   	b4000_top_even:	lda	BLK_4000_TL_L, y	; 5
 1917    02:C505  9D 02 02   			sta	VDC_DL, x		; 6
 1918    02:C508  B9 00 44   			lda	BLK_4000_TL_H, y	; 5
 1919               0001     		.if	BLKDEF_CHR_FLAG
 1920    02:C50B  29 F3      			and	#%11110011		; 2
 1921                        		.endif
 1922    02:C50D  1A         			inc	a			; 2
 1923    02:C50E  9D 03 02   			sta	VDC_DH, x		; 6
 1924                        	
 1925    02:C511  C6 00      			dec	<map_count		; 6
 1926    02:C513  F0 19      			beq	!end+			; 2
 1927                        	
 1928    02:C515  B9 00 41   	b4000_top_odd:	lda	BLK_4000_TR_L, y	; 5
 1929    02:C518  9D 02 02   			sta	VDC_DL, x		; 6
 1930    02:C51B  B9 00 45   			lda	BLK_4000_TR_H, y	; 5
 1931               0001     		.if	BLKDEF_CHR_FLAG
 1932    02:C51E  29 F3      			and	#%11110011		; 2
 1933                        		.endif
 1934    02:C520  1A         			inc	a			; 2
 1935    02:C521  9D 03 02   			sta	VDC_DH, x		; 6
 1936                        	
 1937    02:C524  E6 EC      			inc.l	<_bp			; 6
 1938    02:C526  D0 02      			bne	!+			; 2/4
 1939    02:C528  E6 ED      			inc.h	<_bp			; 6
 1940                        	
 1941    02:C52A  C6 00      	!:		dec	<map_count		; 6
 1942    02:C52C  D0 D1      			bne	!repeat-		; 4
 1943                        	
 1944    02:C52E  60         	!end:		rts
 1945                        	
 1946                        			; btm horizontal (32+2 rept)
 1947                        			;
 1948                        			; 89 cycles per block * 17 -> 1513 cycles
 1949                        	
 1950    02:C52F  B2 EC      	!repeat:	lda	[_bp]			; 7
 1951    02:C531  A8         			tay				; 2
 1952                        	
 1953    02:C532  B9 00 42   	b4000_btm_even:	lda	BLK_4000_BL_L, y	; 5
 1954    02:C535  9D 02 02   			sta	VDC_DL, x		; 6
 1955    02:C538  B9 00 46   			lda	BLK_4000_BL_H, y	; 5
 1956               0001     		.if	BLKDEF_CHR_FLAG
 1957    02:C53B  29 F3      			and	#%11110011		; 2
 1958                        		.endif
 1959    02:C53D  1A         			inc	a			; 2
 1960    02:C53E  9D 03 02   			sta	VDC_DH, x		; 6
 1961                        	
 1962    02:C541  C6 00      			dec	<map_count		; 6
 1963    02:C543  F0 19      			beq	!end+			; 2
 1964                        	
 1965    02:C545  B9 00 43   	b4000_btm_odd:	lda	BLK_4000_BR_L, y	; 5
 1966    02:C548  9D 02 02   			sta	VDC_DL, x		; 6
 1967    02:C54B  B9 00 47   			lda	BLK_4000_BR_H, y	; 5
 1968               0001     		.if	BLKDEF_CHR_FLAG
 1969    02:C54E  29 F3      			and	#%11110011		; 2
 1970                        		.endif
 1971    02:C550  1A         			inc	a			; 2
 1972    02:C551  9D 03 02   			sta	VDC_DH, x		; 6
 1973                        	
 1974    02:C554  E6 EC      			inc.l	<_bp			; 6
 1975    02:C556  D0 02      			bne	!+			; 2/4
 1976    02:C558  E6 ED      			inc.h	<_bp			; 6
 1977                        	
 1978    02:C55A  C6 00      	!:		dec	<map_count		; 6
 1979    02:C55C  D0 D1      			bne	!repeat-		; 4
 1980                        	
 1981    02:C55E  60         	!end:		rts
 1982                        	
 1983                        			; top horizontal (32+2 rept)
 1984                        			;
 1985                        			; 89 cycles per block * 17 -> 1513 cycles
 1986                        	
 1987    02:C55F  B2 EC      	!repeat:	lda	[_bp]			; 7
 1988    02:C561  A8         			tay				; 2
 1989                        	
 1990    02:C562  B9 00 48   	b4800_top_even:	lda	BLK_4800_TL_L, y	; 5
 1991    02:C565  9D 02 02   			sta	VDC_DL, x		; 6
 1992    02:C568  B9 00 4C   			lda	BLK_4800_TL_H, y	; 5
 1993               0001     		.if	BLKDEF_CHR_FLAG
 1994    02:C56B  29 F3      			and	#%11110011		; 2
 1995                        		.endif
 1996    02:C56D  1A         			inc	a			; 2
 1997    02:C56E  9D 03 02   			sta	VDC_DH, x		; 6
 1998                        	
 1999    02:C571  C6 00      			dec	<map_count		; 6
 2000    02:C573  F0 19      			beq	!end+			; 2
 2001                        	
 2002    02:C575  B9 00 49   	b4800_top_odd:	lda	BLK_4800_TR_L, y	; 5
 2003    02:C578  9D 02 02   			sta	VDC_DL, x		; 6
 2004    02:C57B  B9 00 4D   			lda	BLK_4800_TR_H, y	; 5
 2005               0001     		.if	BLKDEF_CHR_FLAG
 2006    02:C57E  29 F3      			and	#%11110011		; 2
 2007                        		.endif
 2008    02:C580  1A         			inc	a			; 2
 2009    02:C581  9D 03 02   			sta	VDC_DH, x		; 6
 2010                        	
 2011    02:C584  E6 EC      			inc.l	<_bp			; 6
 2012    02:C586  D0 02      			bne	!+			; 2/4
 2013    02:C588  E6 ED      			inc.h	<_bp			; 6
 2014                        	
 2015    02:C58A  C6 00      	!:		dec	<map_count		; 6
 2016    02:C58C  D0 D1      			bne	!repeat-		; 4
 2017                        	
 2018    02:C58E  60         	!end:		rts
 2019                        	
 2020                        			; btm horizontal (32+2 rept)
 2021                        			;
 2022                        			; 89 cycles per block * 17 -> 1513 cycles
 2023                        	
 2024    02:C58F  B2 EC      	!repeat:	lda	[_bp]			; 7
 2025    02:C591  A8         			tay				; 2
 2026                        	
 2027    02:C592  B9 00 4A   	b4800_btm_even:	lda	BLK_4800_BL_L, y	; 5
 2028    02:C595  9D 02 02   			sta	VDC_DL, x		; 6
 2029    02:C598  B9 00 4E   			lda	BLK_4800_BL_H, y	; 5
 2030               0001     		.if	BLKDEF_CHR_FLAG
 2031    02:C59B  29 F3      			and	#%11110011		; 2
 2032                        		.endif
 2033    02:C59D  1A         			inc	a			; 2
 2034    02:C59E  9D 03 02   			sta	VDC_DH, x		; 6
 2035                        	
 2036    02:C5A1  C6 00      			dec	<map_count		; 6
 2037    02:C5A3  F0 19      			beq	!end+			; 2
 2038                        	
 2039    02:C5A5  B9 00 4B   	b4800_btm_odd:	lda	BLK_4800_BR_L, y	; 5
 2040    02:C5A8  9D 02 02   			sta	VDC_DL, x		; 6
 2041    02:C5AB  B9 00 4F   			lda	BLK_4800_BR_H, y	; 5
 2042               0001     		.if	BLKDEF_CHR_FLAG
 2043    02:C5AE  29 F3      			and	#%11110011		; 2
 2044                        		.endif
 2045    02:C5B0  1A         			inc	a			; 2
 2046    02:C5B1  9D 03 02   			sta	VDC_DH, x		; 6
 2047                        	
 2048    02:C5B4  E6 EC      			inc.l	<_bp			; 6
 2049    02:C5B6  D0 02      			bne	!+			; 2/4
 2050    02:C5B8  E6 ED      			inc.h	<_bp			; 6
 2051                        	
 2052    02:C5BA  C6 00      	!:		dec	<map_count		; 6
 2053    02:C5BC  D0 D1      			bne	!repeat-		; 4
 2054                        	
 2055    02:C5BE  60         	!end:		rts
 2056                        	
 2057                        			; top horizontal (32+2 rept)
 2058                        			;
 2059                        			; 89 cycles per block * 17 -> 1513 cycles
 2060                        	
 2061    02:C5BF  B2 EC      	!repeat:	lda	[_bp]			; 7
 2062    02:C5C1  A8         			tay				; 2
 2063                        	
 2064    02:C5C2  B9 00 50   	b5000_top_even:	lda	BLK_5000_TL_L, y	; 5
 2065    02:C5C5  9D 02 02   			sta	VDC_DL, x		; 6
 2066    02:C5C8  B9 00 54   			lda	BLK_5000_TL_H, y	; 5
 2067               0001     		.if	BLKDEF_CHR_FLAG
 2068    02:C5CB  29 F3      			and	#%11110011		; 2
 2069                        		.endif
 2070    02:C5CD  1A         			inc	a			; 2
 2071    02:C5CE  9D 03 02   			sta	VDC_DH, x		; 6
 2072                        	
 2073    02:C5D1  C6 00      			dec	<map_count		; 6
 2074    02:C5D3  F0 19      			beq	!end+			; 2
 2075                        	
 2076    02:C5D5  B9 00 51   	b5000_top_odd:	lda	BLK_5000_TR_L, y	; 5
 2077    02:C5D8  9D 02 02   			sta	VDC_DL, x		; 6
 2078    02:C5DB  B9 00 55   			lda	BLK_5000_TR_H, y	; 5
 2079               0001     		.if	BLKDEF_CHR_FLAG
 2080    02:C5DE  29 F3      			and	#%11110011		; 2
 2081                        		.endif
 2082    02:C5E0  1A         			inc	a			; 2
 2083    02:C5E1  9D 03 02   			sta	VDC_DH, x		; 6
 2084                        	
 2085    02:C5E4  E6 EC      			inc.l	<_bp			; 6
 2086    02:C5E6  D0 02      			bne	!+			; 2/4
 2087    02:C5E8  E6 ED      			inc.h	<_bp			; 6
 2088                        	
 2089    02:C5EA  C6 00      	!:		dec	<map_count		; 6
 2090    02:C5EC  D0 D1      			bne	!repeat-		; 4
 2091                        	
 2092    02:C5EE  60         	!end:		rts
 2093                        	
 2094                        			; btm horizontal (32+2 rept)
 2095                        			;
 2096                        			; 89 cycles per block * 17 -> 1513 cycles
 2097                        	
 2098    02:C5EF  B2 EC      	!repeat:	lda	[_bp]			; 7
 2099    02:C5F1  A8         			tay				; 2
 2100                        	
 2101    02:C5F2  B9 00 52   	b5000_btm_even:	lda	BLK_5000_BL_L, y	; 5
 2102    02:C5F5  9D 02 02   			sta	VDC_DL, x		; 6
 2103    02:C5F8  B9 00 56   			lda	BLK_5000_BL_H, y	; 5
 2104               0001     		.if	BLKDEF_CHR_FLAG
 2105    02:C5FB  29 F3      			and	#%11110011		; 2
 2106                        		.endif
 2107    02:C5FD  1A         			inc	a			; 2
 2108    02:C5FE  9D 03 02   			sta	VDC_DH, x		; 6
 2109                        	
 2110    02:C601  C6 00      			dec	<map_count		; 6
 2111    02:C603  F0 19      			beq	!end+			; 2
 2112                        	
 2113    02:C605  B9 00 53   	b5000_btm_odd:	lda	BLK_5000_BR_L, y	; 5
 2114    02:C608  9D 02 02   			sta	VDC_DL, x		; 6
 2115    02:C60B  B9 00 57   			lda	BLK_5000_BR_H, y	; 5
 2116               0001     		.if	BLKDEF_CHR_FLAG
 2117    02:C60E  29 F3      			and	#%11110011		; 2
 2118                        		.endif
 2119    02:C610  1A         			inc	a			; 2
 2120    02:C611  9D 03 02   			sta	VDC_DH, x		; 6
 2121                        	
 2122    02:C614  E6 EC      			inc.l	<_bp			; 6
 2123    02:C616  D0 02      			bne	!+			; 2/4
 2124    02:C618  E6 ED      			inc.h	<_bp			; 6
 2125                        	
 2126    02:C61A  C6 00      	!:		dec	<map_count		; 6
 2127    02:C61C  D0 D1      			bne	!repeat-		; 4
 2128                        	
 2129    02:C61E  60         	!end:		rts
 2130                        	
 2131                        			; top horizontal (32+2 rept)
 2132                        			;
 2133                        			; 89 cycles per block * 17 -> 1513 cycles
 2134                        	
 2135    02:C61F  B2 EC      	!repeat:	lda	[_bp]			; 7
 2136    02:C621  A8         			tay				; 2
 2137                        	
 2138    02:C622  B9 00 58   	b5800_top_even:	lda	BLK_5800_TL_L, y	; 5
 2139    02:C625  9D 02 02   			sta	VDC_DL, x		; 6
 2140    02:C628  B9 00 5C   			lda	BLK_5800_TL_H, y	; 5
 2141               0001     		.if	BLKDEF_CHR_FLAG
 2142    02:C62B  29 F3      			and	#%11110011		; 2
 2143                        		.endif
 2144    02:C62D  1A         			inc	a			; 2
 2145    02:C62E  9D 03 02   			sta	VDC_DH, x		; 6
 2146                        	
 2147    02:C631  C6 00      			dec	<map_count		; 6
 2148    02:C633  F0 19      			beq	!end+			; 2
 2149                        	
 2150    02:C635  B9 00 59   	b5800_top_odd:	lda	BLK_5800_TR_L, y	; 5
 2151    02:C638  9D 02 02   			sta	VDC_DL, x		; 6
 2152    02:C63B  B9 00 5D   			lda	BLK_5800_TR_H, y	; 5
 2153               0001     		.if	BLKDEF_CHR_FLAG
 2154    02:C63E  29 F3      			and	#%11110011		; 2
 2155                        		.endif
 2156    02:C640  1A         			inc	a			; 2
 2157    02:C641  9D 03 02   			sta	VDC_DH, x		; 6
 2158                        	
 2159    02:C644  E6 EC      			inc.l	<_bp			; 6
 2160    02:C646  D0 02      			bne	!+			; 2/4
 2161    02:C648  E6 ED      			inc.h	<_bp			; 6
 2162                        	
 2163    02:C64A  C6 00      	!:		dec	<map_count		; 6
 2164    02:C64C  D0 D1      			bne	!repeat-		; 4
 2165                        	
 2166    02:C64E  60         	!end:		rts
 2167                        	
 2168                        			; btm horizontal (32+2 rept)
 2169                        			;
 2170                        			; 89 cycles per block * 17 -> 1513 cycles
 2171                        	
 2172    02:C64F  B2 EC      	!repeat:	lda	[_bp]		; 7
 2173    02:C651  A8         			tay				; 2
 2174                        	
 2175    02:C652  B9 00 5A   	b5800_btm_even:	lda	BLK_5800_BL_L, y	; 5
 2176    02:C655  9D 02 02   			sta	VDC_DL, x		; 6
 2177    02:C658  B9 00 5E   			lda	BLK_5800_BL_H, y	; 5
 2178               0001     		.if	BLKDEF_CHR_FLAG
 2179    02:C65B  29 F3      			and	#%11110011		; 2
 2180                        		.endif
 2181    02:C65D  1A         			inc	a			; 2
 2182    02:C65E  9D 03 02   			sta	VDC_DH, x		; 6
 2183                        	
 2184    02:C661  C6 00      			dec	<map_count		; 6
 2185    02:C663  F0 19      			beq	!end+			; 2
 2186                        	
 2187    02:C665  B9 00 5B   	b5800_btm_odd:	lda	BLK_5800_BR_L, y	; 5
 2188    02:C668  9D 02 02   			sta	VDC_DL, x		; 6
 2189    02:C66B  B9 00 5F   			lda	BLK_5800_BR_H, y	; 5
 2190               0001     		.if	BLKDEF_CHR_FLAG
 2191    02:C66E  29 F3      			and	#%11110011		; 2
 2192                        		.endif
 2193    02:C670  1A         			inc	a			; 2
 2194    02:C671  9D 03 02   			sta	VDC_DH, x		; 6
 2195                        	
 2196    02:C674  E6 EC      			inc.l	<_bp			; 6
 2197    02:C676  D0 02      			bne	!+			; 2/4
 2198    02:C678  E6 ED      			inc.h	<_bp			; 6
 2199                        	
 2200    02:C67A  C6 00      	!:		dec	<map_count		; 6
 2201    02:C67C  D0 D1      			bne	!repeat-		; 4
 2202                        	
 2203    02:C67E  60         	!end:		rts
 2204                        	
 2205                        	
 2206                        	
 2207                        	; ***************************************************************************
 2208                        	; ***************************************************************************
 2209                        	;
 2210                        	; blk_col_strip - Draw a single column of CHR into the BAT.
 2211                        	;
 2212                        	
 2213    02:C67F  20 34 E4   	blk_col_strip:	jsr	set_di_xy_mawr		; Set the BAT VRAM destination.
 2214                        	
 2215    02:C682  A5 FC      			lda	<map_chr_x		; Select what drawing code to
 2216    02:C684  4A         			lsr	a			; use depending upon even/odd
 2217    02:C685  A5 FE      			lda	<map_chr_y		; CHR coordinates (not BAT to
 2218    02:C687  29 01      			and	#1			; support unaligned drawing).
 2219    02:C689  2A         			rol	a
 2220    02:C68A  0A         			asl	a			; N.B. Always leaves C clear.
 2221    02:C68B  1D B2 2B   			ora.h	vdc_blk_addr, x		; What is the BLK data address?
 2222    02:C68E  29 1E      			and	#%00011110		; $4000, $4800, $5000 or $5800.
 2223    02:C690  A8         			tay
 2224    02:C691  B9 9E C6   			lda.h	.jump_table, y		; Push the address of the code.
 2225    02:C694  48         			pha
 2226    02:C695  B9 9D C6   			lda.l	.jump_table, y
 2227    02:C698  48         			pha
 2228                        	
 2229    02:C699  B2 EC      			lda	[_bp]			; Get the first BLK number.
 2230    02:C69B  A8         			tay
 2231                        	
 2232    02:C69C  60         			rts				; Jump to the drawing code.
 2233                        	
 2234    02:C69D  BF C6      	.jump_table:	dw	b4000_lhs_even - 1
 2235    02:C69F  F5 C6      			dw	b4000_rhs_even - 1
 2236    02:C6A1  D2 C6      			dw	b4000_lhs_odd - 1
 2237    02:C6A3  08 C7      			dw	b4000_rhs_odd - 1
 2238                        	
 2239    02:C6A5  2B C7      			dw	b4800_lhs_even - 1
 2240    02:C6A7  61 C7      			dw	b4800_rhs_even - 1
 2241    02:C6A9  3E C7      			dw	b4800_lhs_odd - 1
 2242    02:C6AB  74 C7      			dw	b4800_rhs_odd - 1
 2243                        	
 2244    02:C6AD  97 C7      			dw	b5000_lhs_even - 1
 2245    02:C6AF  CD C7      			dw	b5000_rhs_even - 1
 2246    02:C6B1  AA C7      			dw	b5000_lhs_odd - 1
 2247    02:C6B3  E0 C7      			dw	b5000_rhs_odd - 1
 2248                        	
 2249    02:C6B5  03 C8      			dw	b5800_lhs_even - 1
 2250    02:C6B7  39 C8      			dw	b5800_rhs_even - 1
 2251    02:C6B9  16 C8      			dw	b5800_lhs_odd - 1
 2252    02:C6BB  4C C8      			dw	b5800_rhs_odd - 1
 2253                        	
 2254                        			; lhs vertical (28+2 rept)
 2255                        			;
 2256                        			; N.B. C is always clear on entry.
 2257                        			;
 2258                        			; 100 cycles per block * 15 -> 1500 cycles
 2259                        	
 2260    02:C6BD  B2 EC      	!repeat:	lda	[_bp]			; 7
 2261    02:C6BF  A8         			tay				; 2
 2262                        	
 2263    02:C6C0  B9 00 40   	b4000_lhs_even:	lda	BLK_4000_TL_L, y	; 5
 2264    02:C6C3  9D 02 02   			sta	VDC_DL, x		; 6
 2265    02:C6C6  B9 00 44   			lda	BLK_4000_TL_H, y	; 5
 2266               0001     		.if	BLKDEF_CHR_FLAG
 2267    02:C6C9  29 F3      			and	#%11110011		; 2
 2268                        		.endif
 2269    02:C6CB  1A         			inc	a			; 2
 2270    02:C6CC  9D 03 02   			sta	VDC_DH, x		; 6
 2271                        	
 2272    02:C6CF  C6 00      			dec	<map_count		; 6
 2273    02:C6D1  F0 1F      			beq	!end+			; 2
 2274                        	
 2275    02:C6D3  B9 00 42   	b4000_lhs_odd:	lda	BLK_4000_BL_L, y	; 5
 2276    02:C6D6  9D 02 02   			sta	VDC_DL, x		; 6
 2277    02:C6D9  B9 00 46   			lda	BLK_4000_BL_H, y	; 5
 2278               0001     		.if	BLKDEF_CHR_FLAG
 2279    02:C6DC  29 F3      			and	#%11110011		; 2
 2280                        		.endif
 2281    02:C6DE  1A         			inc	a			; 2
 2282    02:C6DF  9D 03 02   			sta	VDC_DH, x		; 6
 2283                        	
 2284    02:C6E2  BD 77 26   			lda	vdc_map_line_w, x	; 5
 2285    02:C6E5  65 EC      			adc.l	<_bp			; 4
 2286    02:C6E7  85 EC      			sta.l	<_bp			; 4
 2287    02:C6E9  90 03      			bcc	!+			; 2/4
 2288    02:C6EB  E6 ED      			inc.h	<_bp			; 6
 2289    02:C6ED  18         			clc				; 2
 2290                        	
 2291    02:C6EE  C6 00      	!:		dec	<map_count		; 6
 2292    02:C6F0  D0 CB      			bne	!repeat-		; 4
 2293                        	
 2294    02:C6F2  60         	!end:		rts
 2295                        	
 2296                        			; rhs vertical (28+2 rept)
 2297                        			;
 2298                        			; N.B. C is always clear on entry.
 2299                        			;
 2300                        			; 100 cycles per block * 15 -> 1500 cycles
 2301                        	
 2302    02:C6F3  B2 EC      	!repeat:	lda	[_bp]			; 7
 2303    02:C6F5  A8         			tay				; 2
 2304                        	
 2305    02:C6F6  B9 00 41   	b4000_rhs_even:	lda	BLK_4000_TR_L, y	; 5
 2306    02:C6F9  9D 02 02   			sta	VDC_DL, x		; 6
 2307    02:C6FC  B9 00 45   			lda	BLK_4000_TR_H, y	; 5
 2308               0001     		.if	BLKDEF_CHR_FLAG
 2309    02:C6FF  29 F3      			and	#%11110011		; 2
 2310                        		.endif
 2311    02:C701  1A         			inc	a			; 2
 2312    02:C702  9D 03 02   			sta	VDC_DH, x		; 6
 2313                        	
 2314    02:C705  C6 00      			dec	<map_count		; 6
 2315    02:C707  F0 1F      			beq	!end+			; 2
 2316                        	
 2317    02:C709  B9 00 43   	b4000_rhs_odd:	lda	BLK_4000_BR_L, y	; 5
 2318    02:C70C  9D 02 02   			sta	VDC_DL, x		; 6
 2319    02:C70F  B9 00 47   			lda	BLK_4000_BR_H, y	; 5
 2320               0001     		.if	BLKDEF_CHR_FLAG
 2321    02:C712  29 F3      			and	#%11110011		; 2
 2322                        		.endif
 2323    02:C714  1A         			inc	a			; 2
 2324    02:C715  9D 03 02   			sta	VDC_DH, x		; 6
 2325                        	
 2326    02:C718  BD 77 26   			lda	vdc_map_line_w, x	; 5
 2327    02:C71B  65 EC      			adc.l	<_bp			; 4
 2328    02:C71D  85 EC      			sta.l	<_bp			; 4
 2329    02:C71F  90 03      			bcc	!+			; 2/4
 2330    02:C721  E6 ED      			inc.h	<_bp			; 6
 2331    02:C723  18         			clc				; 2
 2332                        	
 2333    02:C724  C6 00      	!:		dec	<map_count		; 6
 2334    02:C726  D0 CB      			bne	!repeat-		; 4
 2335                        	
 2336    02:C728  60         	!end:		rts
 2337                        	
 2338                        			; lhs vertical (28+2 rept)
 2339                        			;
 2340                        			; N.B. C is always clear on entry.
 2341                        			;
 2342                        			; 100 cycles per block * 15 -> 1500 cycles
 2343                        	
 2344    02:C729  B2 EC      	!repeat:	lda	[_bp]			; 7
 2345    02:C72B  A8         			tay				; 2
 2346                        	
 2347    02:C72C  B9 00 48   	b4800_lhs_even:	lda	BLK_4800_TL_L, y	; 5
 2348    02:C72F  9D 02 02   			sta	VDC_DL, x		; 6
 2349    02:C732  B9 00 4C   			lda	BLK_4800_TL_H, y	; 5
 2350               0001     		.if	BLKDEF_CHR_FLAG
 2351    02:C735  29 F3      			and	#%11110011		; 2
 2352                        		.endif
 2353    02:C737  1A         			inc	a			; 2
 2354    02:C738  9D 03 02   			sta	VDC_DH, x		; 6
 2355                        	
 2356    02:C73B  C6 00      			dec	<map_count		; 6
 2357    02:C73D  F0 1F      			beq	!end+			; 2
 2358                        	
 2359    02:C73F  B9 00 4A   	b4800_lhs_odd:	lda	BLK_4800_BL_L, y	; 5
 2360    02:C742  9D 02 02   			sta	VDC_DL, x		; 6
 2361    02:C745  B9 00 4E   			lda	BLK_4800_BL_H, y	; 5
 2362               0001     		.if	BLKDEF_CHR_FLAG
 2363    02:C748  29 F3      			and	#%11110011		; 2
 2364                        		.endif
 2365    02:C74A  1A         			inc	a			; 2
 2366    02:C74B  9D 03 02   			sta	VDC_DH, x		; 6
 2367                        	
 2368    02:C74E  BD 77 26   			lda	vdc_map_line_w, x	; 5
 2369    02:C751  65 EC      			adc.l	<_bp			; 4
 2370    02:C753  85 EC      			sta.l	<_bp			; 4
 2371    02:C755  90 03      			bcc	!+			; 2/4
 2372    02:C757  E6 ED      			inc.h	<_bp			; 6
 2373    02:C759  18         			clc				; 2
 2374                        	
 2375    02:C75A  C6 00      	!:		dec	<map_count		; 6
 2376    02:C75C  D0 CB      			bne	!repeat-		; 4
 2377                        	
 2378    02:C75E  60         	!end:		rts
 2379                        	
 2380                        			; rhs vertical (28+2 rept)
 2381                        			;
 2382                        			; N.B. C is always clear on entry.
 2383                        			;
 2384                        			; 100 cycles per block * 15 -> 1500 cycles
 2385                        	
 2386    02:C75F  B2 EC      	!repeat:	lda	[_bp]			; 7
 2387    02:C761  A8         			tay				; 2
 2388                        	
 2389    02:C762  B9 00 49   	b4800_rhs_even:	lda	BLK_4800_TR_L, y	; 5
 2390    02:C765  9D 02 02   			sta	VDC_DL, x		; 6
 2391    02:C768  B9 00 4D   			lda	BLK_4800_TR_H, y	; 5
 2392               0001     		.if	BLKDEF_CHR_FLAG
 2393    02:C76B  29 F3      			and	#%11110011		; 2
 2394                        		.endif
 2395    02:C76D  1A         			inc	a			; 2
 2396    02:C76E  9D 03 02   			sta	VDC_DH, x		; 6
 2397                        	
 2398    02:C771  C6 00      			dec	<map_count		; 6
 2399    02:C773  F0 1F      			beq	!end+			; 2
 2400                        	
 2401    02:C775  B9 00 4B   	b4800_rhs_odd:	lda	BLK_4800_BR_L, y	; 5
 2402    02:C778  9D 02 02   			sta	VDC_DL, x		; 6
 2403    02:C77B  B9 00 4F   			lda	BLK_4800_BR_H, y	; 5
 2404               0001     		.if	BLKDEF_CHR_FLAG
 2405    02:C77E  29 F3      			and	#%11110011		; 2
 2406                        		.endif
 2407    02:C780  1A         			inc	a			; 2
 2408    02:C781  9D 03 02   			sta	VDC_DH, x		; 6
 2409                        	
 2410    02:C784  BD 77 26   			lda	vdc_map_line_w, x	; 5
 2411    02:C787  65 EC      			adc.l	<_bp			; 4
 2412    02:C789  85 EC      			sta.l	<_bp			; 4
 2413    02:C78B  90 03      			bcc	!+			; 2/4
 2414    02:C78D  E6 ED      			inc.h	<_bp			; 6
 2415    02:C78F  18         			clc				; 2
 2416                        	
 2417    02:C790  C6 00      	!:		dec	<map_count		; 6
 2418    02:C792  D0 CB      			bne	!repeat-		; 4
 2419                        	
 2420    02:C794  60         	!end:		rts
 2421                        	
 2422                        			; lhs vertical (28+2 rept)
 2423                        			;
 2424                        			; N.B. C is always clear on entry.
 2425                        			;
 2426                        			; 100 cycles per block * 15 -> 1500 cycles
 2427                        	
 2428    02:C795  B2 EC      	!repeat:	lda	[_bp]			; 7
 2429    02:C797  A8         			tay				; 2
 2430                        	
 2431    02:C798  B9 00 50   	b5000_lhs_even:	lda	BLK_5000_TL_L, y	; 5
 2432    02:C79B  9D 02 02   			sta	VDC_DL, x		; 6
 2433    02:C79E  B9 00 54   			lda	BLK_5000_TL_H, y	; 5
 2434               0001     		.if	BLKDEF_CHR_FLAG
 2435    02:C7A1  29 F3      			and	#%11110011		; 2
 2436                        		.endif
 2437    02:C7A3  1A         			inc	a			; 2
 2438    02:C7A4  9D 03 02   			sta	VDC_DH, x		; 6
 2439                        	
 2440    02:C7A7  C6 00      			dec	<map_count		; 6
 2441    02:C7A9  F0 1F      			beq	!end+			; 2
 2442                        	
 2443    02:C7AB  B9 00 52   	b5000_lhs_odd:	lda	BLK_5000_BL_L, y	; 5
 2444    02:C7AE  9D 02 02   			sta	VDC_DL, x		; 6
 2445    02:C7B1  B9 00 56   			lda	BLK_5000_BL_H, y	; 5
 2446               0001     		.if	BLKDEF_CHR_FLAG
 2447    02:C7B4  29 F3      			and	#%11110011		; 2
 2448                        		.endif
 2449    02:C7B6  1A         			inc	a			; 2
 2450    02:C7B7  9D 03 02   			sta	VDC_DH, x		; 6
 2451                        	
 2452    02:C7BA  BD 77 26   			lda	vdc_map_line_w, x	; 5
 2453    02:C7BD  65 EC      			adc.l	<_bp			; 4
 2454    02:C7BF  85 EC      			sta.l	<_bp			; 4
 2455    02:C7C1  90 03      			bcc	!+			; 2/4
 2456    02:C7C3  E6 ED      			inc.h	<_bp			; 6
 2457    02:C7C5  18         			clc				; 2
 2458                        	
 2459    02:C7C6  C6 00      	!:		dec	<map_count		; 6
 2460    02:C7C8  D0 CB      			bne	!repeat-		; 4
 2461                        	
 2462    02:C7CA  60         	!end:		rts
 2463                        	
 2464                        			; rhs vertical (28+2 rept)
 2465                        			;
 2466                        			; N.B. C is always clear on entry.
 2467                        			;
 2468                        			; 100 cycles per block * 15 -> 1500 cycles
 2469                        	
 2470    02:C7CB  B2 EC      	!repeat:	lda	[_bp]			; 7
 2471    02:C7CD  A8         			tay				; 2
 2472                        	
 2473    02:C7CE  B9 00 51   	b5000_rhs_even:	lda	BLK_5000_TR_L, y	; 5
 2474    02:C7D1  9D 02 02   			sta	VDC_DL, x		; 6
 2475    02:C7D4  B9 00 55   			lda	BLK_5000_TR_H, y	; 5
 2476               0001     		.if	BLKDEF_CHR_FLAG
 2477    02:C7D7  29 F3      			and	#%11110011		; 2
 2478                        		.endif
 2479    02:C7D9  1A         			inc	a			; 2
 2480    02:C7DA  9D 03 02   			sta	VDC_DH, x		; 6
 2481                        	
 2482    02:C7DD  C6 00      			dec	<map_count		; 6
 2483    02:C7DF  F0 1F      			beq	!end+			; 2
 2484                        	
 2485    02:C7E1  B9 00 53   	b5000_rhs_odd:	lda	BLK_5000_BR_L, y	; 5
 2486    02:C7E4  9D 02 02   			sta	VDC_DL, x		; 6
 2487    02:C7E7  B9 00 57   			lda	BLK_5000_BR_H, y	; 5
 2488               0001     		.if	BLKDEF_CHR_FLAG
 2489    02:C7EA  29 F3      			and	#%11110011		; 2
 2490                        		.endif
 2491    02:C7EC  1A         			inc	a			; 2
 2492    02:C7ED  9D 03 02   			sta	VDC_DH, x		; 6
 2493                        	
 2494    02:C7F0  BD 77 26   			lda	vdc_map_line_w, x	; 5
 2495    02:C7F3  65 EC      			adc.l	<_bp			; 4
 2496    02:C7F5  85 EC      			sta.l	<_bp			; 4
 2497    02:C7F7  90 03      			bcc	!+			; 2/4
 2498    02:C7F9  E6 ED      			inc.h	<_bp			; 6
 2499    02:C7FB  18         			clc				; 2
 2500                        	
 2501    02:C7FC  C6 00      	!:		dec	<map_count		; 6
 2502    02:C7FE  D0 CB      			bne	!repeat-		; 4
 2503                        	
 2504    02:C800  60         	!end:		rts
 2505                        	
 2506                        			; lhs vertical (28+2 rept)
 2507                        			;
 2508                        			; N.B. C is always clear on entry.
 2509                        			;
 2510                        			; 100 cycles per block * 15 -> 1500 cycles
 2511                        	
 2512    02:C801  B2 EC      	!repeat:	lda	[_bp]			; 7
 2513    02:C803  A8         			tay				; 2
 2514                        	
 2515    02:C804  B9 00 58   	b5800_lhs_even:	lda	BLK_5800_TL_L, y	; 5
 2516    02:C807  9D 02 02   			sta	VDC_DL, x		; 6
 2517    02:C80A  B9 00 5C   			lda	BLK_5800_TL_H, y	; 5
 2518               0001     		.if	BLKDEF_CHR_FLAG
 2519    02:C80D  29 F3      			and	#%11110011		; 2
 2520                        		.endif
 2521    02:C80F  1A         			inc	a			; 2
 2522    02:C810  9D 03 02   			sta	VDC_DH, x		; 6
 2523                        	
 2524    02:C813  C6 00      			dec	<map_count		; 6
 2525    02:C815  F0 1F      			beq	!end+			; 2
 2526                        	
 2527    02:C817  B9 00 5A   	b5800_lhs_odd:	lda	BLK_5800_BL_L, y	; 5
 2528    02:C81A  9D 02 02   			sta	VDC_DL, x		; 6
 2529    02:C81D  B9 00 5E   			lda	BLK_5800_BL_H, y	; 5
 2530               0001     		.if	BLKDEF_CHR_FLAG
 2531    02:C820  29 F3      			and	#%11110011		; 2
 2532                        		.endif
 2533    02:C822  1A         			inc	a			; 2
 2534    02:C823  9D 03 02   			sta	VDC_DH, x		; 6
 2535                        	
 2536    02:C826  BD 77 26   			lda	vdc_map_line_w, x	; 5
 2537    02:C829  65 EC      			adc.l	<_bp			; 4
 2538    02:C82B  85 EC      			sta.l	<_bp			; 4
 2539    02:C82D  90 03      			bcc	!+			; 2/4
 2540    02:C82F  E6 ED      			inc.h	<_bp			; 6
 2541    02:C831  18         			clc				; 2
 2542                        	
 2543    02:C832  C6 00      	!:		dec	<map_count		; 6
 2544    02:C834  D0 CB      			bne	!repeat-		; 4
 2545                        	
 2546    02:C836  60         	!end:		rts
 2547                        	
 2548                        			; rhs vertical (28+2 rept)
 2549                        			;
 2550                        			; N.B. C is always clear on entry.
 2551                        			;
 2552                        			; 100 cycles per block * 15 -> 1500 cycles
 2553                        	
 2554    02:C837  B2 EC      	!repeat:	lda	[_bp]			; 7
 2555    02:C839  A8         			tay				; 2
 2556                        	
 2557    02:C83A  B9 00 59   	b5800_rhs_even:	lda	BLK_5800_TR_L, y	; 5
 2558    02:C83D  9D 02 02   			sta	VDC_DL, x		; 6
 2559    02:C840  B9 00 5D   			lda	BLK_5800_TR_H, y	; 5
 2560               0001     		.if	BLKDEF_CHR_FLAG
 2561    02:C843  29 F3      			and	#%11110011		; 2
 2562                        		.endif
 2563    02:C845  1A         			inc	a			; 2
 2564    02:C846  9D 03 02   			sta	VDC_DH, x		; 6
 2565                        	
 2566    02:C849  C6 00      			dec	<map_count		; 6
 2567    02:C84B  F0 1F      			beq	!end+			; 2
 2568                        	
 2569    02:C84D  B9 00 5B   	b5800_rhs_odd:	lda	BLK_5800_BR_L, y	; 5
 2570    02:C850  9D 02 02   			sta	VDC_DL, x		; 6
 2571    02:C853  B9 00 5F   			lda	BLK_5800_BR_H, y	; 5
 2572               0001     		.if	BLKDEF_CHR_FLAG
 2573    02:C856  29 F3      			and	#%11110011		; 2
 2574                        		.endif
 2575    02:C858  1A         			inc	a			; 2
 2576    02:C859  9D 03 02   			sta	VDC_DH, x		; 6
 2577                        	
 2578    02:C85C  BD 77 26   			lda	vdc_map_line_w, x	; 5
 2579    02:C85F  65 EC      			adc.l	<_bp			; 4
 2580    02:C861  85 EC      			sta.l	<_bp			; 4
 2581    02:C863  90 03      			bcc	!+			; 2/4
 2582    02:C865  E6 ED      			inc.h	<_bp			; 6
 2583    02:C867  18         			clc				; 2
 2584                        	
 2585    02:C868  C6 00      	!:		dec	<map_count		; 6
 2586    02:C86A  D0 CB      			bne	!repeat-		; 4
 2587                        	
 2588    02:C86C  60         	!end:		rts
 2589                        	
 2590                        		.endif	BLKDEF_POINTERS
 2591                        	
 2592                        		.endprocgroup	; blkmap_group
                             #[2]   "..\..\..\include\hucc\hucc-final.asm"
   80                        		.else
   84                        		.endif	HUCC_USES_BLKMAP
   85                        	
   86               0001     		.ifdef	HUCC_USES_CHRMAP		; Set in hucc_chrmap.h
                             #[3]   "..\..\..\include\hucc\chrmap.asm"
   87                        			include	"chrmap.asm"
    1                        	; ***************************************************************************
    2                        	; ***************************************************************************
    3                        	;
    4                        	; chrmap.asm
    5                        	;
    6                        	; A simple map system based on 8x8 characters (aka "tiles") in BAT format.
    7                        	;
    8                        	; Copyright John Brandwood 2025.
    9                        	;
   10                        	; Distributed under the Boost Software License, Version 1.0.
   11                        	; (See accompanying file LICENSE_1_0.txt or copy at
   12                        	;  http://www.boost.org/LICENSE_1_0.txt)
   13                        	;
   14                        	; ***************************************************************************
   15                        	; ***************************************************************************
   16                        	;
   17                        	; The maximum X and Y size for chrmaps is 256 characters (2048 pixels).
   18                        	;
   19                        	; The maximum total size for a chrmap is 16KBytes, which allows for maps up
   20                        	; to 256x32 tiles (2048x256 pixels).
   21                        	;
   22                        	; ***************************************************************************
   23                        	; ***************************************************************************
   24                        	
   25                        	;
   26                        	; Include dependancies ...
   27                        	;
   28                        	
   29                        			include "blkmap.asm"		; This defines the variables.
   30                        	
   31                        	;
   32                        	; Chrmaps in BAT format normally address all of VRAM from $0400..$7FFF, but
   33                        	; they can be limited to use the 32KByte of characters in VRAM $1000..$4FFF
   34                        	; which then frees up 2-bits for flag information for each character in the
   35                        	; BAT entry.
   36                        	;
   37                        	; These 2-bits are perfect for using as collision information in game maps,
   38                        	; allowing storage of states like transparent, solid, up-slope, down-slope.
   39                        	;
   40                        	; Typically this flag information is set by the map conversion tools from a
   41                        	; seperate "collision" map layer.
   42                        	;
   43                        	
   44               0000     		.ifndef	CHRMAP_BAT_FLAG
   46                        		.endif
   47                        	
   48                        	;
   49                        	;
   50                        	;
   51                        	
   52                        	
   53                        	
   54    02:DC72             	chrmap_group	.procgroup
   55                        	
   56                        	; ***************************************************************************
   57                        	; ***************************************************************************
   58                        	;
   59                        	; _draw_bat - Draw the entire screen at the current coordinates.
   60                        	; _sgx_draw_bat - Draw the entire screen at the current coordinates.
   61                        	;
   62                        	; void __fastcall draw_bat( void );
   63                        	; void __fastcall sgx_draw_bat( void );
   64                        	;
   65                        	
   66               0001     		.if	SUPPORT_SGX
   67                        	
   68                        	_sgx_draw_bat	.proc
   74                        			.endp
   75                        		.endif
   76                        	
   77    02:DC72             	_draw_bat	.proc
   78                        	
   79    02:DC72  82         			clx				; Offset to PCE VDC.
   80                        	
   81    02:DC73  43 08      			tma3				; Preserve MPR3..MPR5.
   82    02:DC75  48         			pha
   83    02:DC76  43 10      			tma4
   84    02:DC78  48         			pha
   85    02:DC79  43 20      			tma5
   86    02:DC7B  48         			pha
   87                        	
   88    02:DC7C  20 1F DD   			jsr	bat_pxl_2_chr		; Set up the draw coordinates.
   89                        	
   90    02:DC7F  A5 FC      			lda	<map_chr_x		; Reset previous X position.
   91    02:DC81  9D AC 2B   			sta	vdc_old_chr_x, x
   92                        	
   93    02:DC84  A5 FE      			lda	<map_chr_y		; Reset previous Y position,
   94    02:DC86  1A         			inc	a			; ready to draw rows upwards.
   95    02:DC87  9D AD 2B   			sta	vdc_old_chr_y, x
   96                        	
   97    02:DC8A  BD 75 26   			lda	vdc_map_draw_w, x	; Draw the whole screen.
   98    02:DC8D  85 FA      			sta	<map_draw_w
   99    02:DC8F  BD 76 26   			lda	vdc_map_draw_h, x
  100    02:DC92  85 FB      			sta	<map_draw_h
  101                        	
  102    02:DC94  20 02 DE   			jsr	bat_scroll_y		; Draw N row of CHR to the BAT.
  103                        	
  104    02:DC97  68         			pla				; Restore MPR3..MPR5.
  105    02:DC98  53 20      			tam5
  106    02:DC9A  68         			pla
  107    02:DC9B  53 10      			tam4
  108    02:DC9D  68         			pla
  109    02:DC9E  53 08      			tam3
  110                        	
  111                        			leave
         02:DCA0  4C EF FF   			jmp	leave_proc
  112                        	
  113                        			.endp
  114                        	
  115                        	
  116                        	
  117                        	; ***************************************************************************
  118                        	; ***************************************************************************
  119                        	;
  120                        	; _scroll_bat - Draw a single row of CHR into the BAT to update the edge.
  121                        	; _sgx_scroll_bat - Draw a single row of CHR into the BAT to update the edge.
  122                        	;
  123                        	; void __fastcall scroll_bat( void );
  124                        	; void __fastcall sgx_scroll_bat( void );
  125                        	;
  126                        	
  127               0001     		.if	SUPPORT_SGX
  128                        	
  129                        	_sgx_scroll_bat	.proc
  135                        			.endp
  136                        		.endif
  137                        	
  138    02:DCA3             	_scroll_bat	.proc
  139                        	
  140    02:DCA3  82         			clx				; Offset to PCE VDC.
  141                        	
  142    02:DCA4  43 08      			tma3				; Preserve MPR3..MPR5.
  143    02:DCA6  48         			pha
  144    02:DCA7  43 10      			tma4
  145    02:DCA9  48         			pha
  146    02:DCAA  43 20      			tma5
  147    02:DCAC  48         			pha
  148                        	
  149    02:DCAD  20 1F DD   			jsr	bat_pxl_2_chr		; Set up the draw coordinates.
  150                        	
  151    02:DCB0  BD 76 26   			lda	vdc_map_draw_h, x	; Draw new LHS or RHS if needed.
  152    02:DCB3  85 FB      			sta	<map_draw_h
  153                        	;		lda	#1			; bat_scroll_x only ever draws a
  154                        	;		sta	<map_draw_w		; single column.
  155    02:DCB5  20 43 DD   			jsr	bat_scroll_x
  156                        	
  157    02:DCB8  BD AC 2B   			lda	vdc_old_chr_x, x	; Restore map_chr_x which could
  158    02:DCBB  85 FC      			sta	<map_chr_x		; be changed by bat_scroll_x.
  159                        	
  160    02:DCBD  BD 75 26   			lda	vdc_map_draw_w, x	; Draw new TOP or BTM if needed.
  161    02:DCC0  85 FA      			sta	<map_draw_w
  162    02:DCC2  A9 01      			lda	#1
  163    02:DCC4  85 FB      			sta	<map_draw_h
  164    02:DCC6  20 02 DE   			jsr	bat_scroll_y
  165                        	
  166    02:DCC9  68         			pla				; Restore MPR3..MPR5.
  167    02:DCCA  53 20      			tam5
  168    02:DCCC  68         			pla
  169    02:DCCD  53 10      			tam4
  170    02:DCCF  68         			pla
  171    02:DCD0  53 08      			tam3
  172                        	
  173                        			leave
         02:DCD2  4C EF FF   			jmp	leave_proc
  174                        	
  175                        			.endp
  176                        	
  177                        	
  178                        	
  179                        	; ***************************************************************************
  180                        	; ***************************************************************************
  181                        	;
  182                        	; _blit_bat - Draw a map rectangle to specific BAT coordinates.
  183                        	; _sgx_blit_bat - Draw a map rectangle to specific BAT coordinates.
  184                        	;
  185                        	; void __fastcall blit_bat( unsigned char tile_x<map_bat_x>, unsigned char tile_y<map_bat_y>, unsigned char tile_w<map_draw_x>, unsigned char tile_h<map_draw_y> );
  186                        	; void __fastcall sgx_blit_bat( unsigned char tile_x<map_bat_x>, unsigned char tile_y<map_bat_y>, unsigned char tile_w<map_draw_x>, unsigned char tile_h<map_draw_y> );
  187                        	;
  188                        	; Normally you'd just use _draw_bat() and _scroll_bat(), but for those folks
  189                        	; who really wish to take manual control, you can use this.
  190                        	;
  191                        	
  192               0001     		.if	SUPPORT_SGX
  193                        	
  194                        	_sgx_blit_bat	.proc
  200                        			.endp
  201                        		.endif
  202                        	
  203    02:DCD5             	_blit_bat	.proc
  204                        	
  205    02:DCD5  82         			clx				; Offset to PCE VDC.
  206                        	
  207    02:DCD6  43 08      			tma3				; Preserve MPR3..MPR5.
  208    02:DCD8  48         			pha
  209    02:DCD9  43 10      			tma4
  210    02:DCDB  48         			pha
  211    02:DCDC  43 20      			tma5
  212    02:DCDE  48         			pha
  213                        	
  214    02:DCDF  BD 7D 26   			lda	vdc_map_option, x	; Preserve current map options.
  215    02:DCE2  48         			pha
  216    02:DCE3  09 C0      			ora	#MAP_UNALIGNED_X | MAP_UNALIGNED_Y
  217    02:DCE5  9D 7D 26   			sta	vdc_map_option, x
  218                        	
  219    02:DCE8  20 1F DD   			jsr	bat_pxl_2_chr		; Set up the draw coordinates.
  220                        	
  221    02:DCEB  A5 FA      			lda	<map_draw_w		; Are we drawing just 1 column?
  222    02:DCED  C9 01      			cmp	#1
  223    02:DCEF  F0 1E      			beq	.draw_column
  224                        	
  225                        			; Draw N rows.
  226                        	
  227    02:DCF1  A5 FC      	.draw_rows:	lda	<map_chr_x		; Reset previous X position.
  228    02:DCF3  9D AC 2B   			sta	vdc_old_chr_x, x
  229                        	
  230    02:DCF6  A5 FE      			lda	<map_chr_y		; Reset previous Y position,
  231    02:DCF8  1A         			inc	a			; ready to draw rows upwards.
  232    02:DCF9  9D AD 2B   			sta	vdc_old_chr_y, x
  233                        	
  234    02:DCFC  20 02 DE   			jsr	bat_scroll_y		; Draw a row of CHR to the BAT.
  235                        	
  236                        			; Drawing completed.
  237                        	
  238    02:DCFF  68         	.finished:	pla				; Restore previous map options.
  239    02:DD00  9D 7D 26   			sta	vdc_map_option, x
  240                        	
  241    02:DD03  68         			pla				; Restore MPR3..MPR5.
  242    02:DD04  53 20      			tam5
  243    02:DD06  68         			pla
  244    02:DD07  53 10      			tam4
  245    02:DD09  68         			pla
  246    02:DD0A  53 08      			tam3
  247                        	
  248                        	.exit:		leave
         02:DD0C  4C EF FF   			jmp	leave_proc
  249                        	
  250                        			; Draw 1 column.
  251                        	
  252    02:DD0F  A5 FC      	.draw_column:	lda	<map_chr_x		; Reset previous X position.
  253    02:DD11  1A         			inc	a			; ready to draw 1 column.
  254    02:DD12  9D AC 2B   			sta	vdc_old_chr_x, x
  255                        	
  256    02:DD15  A5 FE      			lda	<map_chr_y		; Reset previous Y position.
  257    02:DD17  9D AD 2B   			sta	vdc_old_chr_y, x
  258                        	
  259    02:DD1A  20 43 DD   			jsr	bat_scroll_x		; Draw a single column of CHR.
  260                        	
  261    02:DD1D  80 E0      			bra	.finished
  262                        	
  263                        			.endp
  264                        	
  265                        	
  266                        	
  267                        	; ***************************************************************************
  268                        	; ***************************************************************************
  269                        	;
  270                        	
  271    02:DD1F  BD 79 26   	bat_pxl_2_chr:	lda.l	vdc_map_pxl_x, x	; Get current map X coordinate.
  272    02:DD22  85 FC      			sta.l	<map_pxl_x
  273    02:DD24  BD 7A 26   			lda.h	vdc_map_pxl_x, x	; Xvert map_pxl_x to map_chr_x.
  274    02:DD27  4A         			lsr	a
  275    02:DD28  66 FC      			ror.l	<map_pxl_x
  276    02:DD2A  4A         			lsr	a
  277    02:DD2B  66 FC      			ror.l	<map_pxl_x
  278    02:DD2D  4A         			lsr	a
  279    02:DD2E  66 FC      			ror.l	<map_pxl_x		; Max map width is 256 CHR.
  280                        	
  281    02:DD30  BD 7B 26   			lda.l	vdc_map_pxl_y, x	; Get current map Y coordinate.
  282    02:DD33  85 FE      			sta.l	<map_pxl_y
  283    02:DD35  BD 7C 26   			lda.h	vdc_map_pxl_y, x	; Xvert map_pxl_y to map_chr_y.
  284    02:DD38  4A         			lsr	a
  285    02:DD39  66 FE      			ror.l	<map_pxl_y
  286    02:DD3B  4A         			lsr	a
  287    02:DD3C  66 FE      			ror.l	<map_pxl_y
  288    02:DD3E  4A         			lsr	a
  289    02:DD3F  66 FE      			ror.l	<map_pxl_y		; Max map width is 256 CHR.
  290                        	
  291    02:DD41  60         			rts
  292                        	
  293                        	
  294                        	
  295                        	; ***************************************************************************
  296                        	; ***************************************************************************
  297                        	;
  298                        	; bat_scroll_x - Update the BAT when X coordinate changes.
  299                        	;
  300                        	; N.B. This only ever draws a single column!
  301                        	;
  302                        	
  303    02:DD42  60         	!no_change:	rts
  304                        	
  305    02:DD43  A5 FC      	bat_scroll_x:	lda	<map_chr_x		; Compare old_x with cur_x.
  306    02:DD45  DD AC 2B   			cmp	vdc_old_chr_x, x
  307    02:DD48  F0 F8      			beq	!no_change-		; Do nothing if no change.
  308    02:DD4A  9D AC 2B   			sta	vdc_old_chr_x, x
  309    02:DD4D  30 05      			bmi	.moved			; Test the sign of the change.
  310                        	
  311    02:DD4F  18         			clc				; Draw RHS if chr_x >= old_x.
  312    02:DD50  7D 75 26   			adc	vdc_map_draw_w, x	; Usually (SCR_WIDTH / 8) + 1.
  313    02:DD53  3A         			dec	a
  314                        	
  315    02:DD54  48         	.moved:		pha				; Push chr_x in map section.
  316                        	
  317    02:DD55  3C 7D 26   			bit	vdc_map_option, x	; Set bit7 to disable aligning
  318    02:DD58  30 05      			bmi	!+			; BAT X with the map X.
  319    02:DD5A  3D 72 26   			and	vdc_bat_x_mask, x
  320    02:DD5D  85 F8      			sta	<map_bat_x		; Save BAT X chr coordinate.
  321                        	
  322    02:DD5F  A5 FE      	!:		lda	<map_chr_y		; Y = chr_y in map section.
  323    02:DD61  A8         			tay
  324                        	
  325    02:DD62  3C 7D 26   			bit	vdc_map_option, x	; Set bit6 to disable aligning
  326    02:DD65  70 05      			bvs	!+			; BAT Y with the map Y.
  327    02:DD67  3D 73 26   			and	vdc_bat_y_mask, x
  328    02:DD6A  85 F9      			sta	<map_bat_y		; Save BAT Y chr coordinate.
  329                        	
  330               0000     		.if	FAST_MULTIPLY
  333                        		.endif
  334                        	
  335    02:DD6C  BD 77 26   	!:		lda	vdc_map_line_w, x	; Map width in CHR (0 == 256).
  336    02:DD6F  D0 05      			bne	!+
  337                        	
  338    02:DD71  64 EE      			stz.l	<map_line		; Multiply by 256 is easy!
  339    02:DD73  98         			tya
  340    02:DD74  80 15      			bra	.double
  341                        	
  342               0000     		.if	FAST_MULTIPLY
  354                        		.else
  355    02:DD76  84 EF      	!:		sty.h	<map_line		; Takes 144..176 cycles.
  356    02:DD78  A0 08      			ldy	#8
  357    02:DD7A  4A         			lsr	a
  358    02:DD7B  85 EE      			sta.l	<map_line
  359    02:DD7D  62         			cla
  360    02:DD7E  90 03      			bcc	.rotate
  361    02:DD80  18         	.add:		clc
  362    02:DD81  65 EF      			adc.h	<map_line
  363    02:DD83  6A         	.rotate:	ror	a
  364    02:DD84  66 EE      			ror.l	<map_line		; Lo-byte of (CHR Y * width).
  365    02:DD86  88         			dey
  366    02:DD87  B0 F7      			bcs	.add
  367    02:DD89  D0 F8      			bne	.rotate
  368                        		.endif
  369                        	
  370    02:DD8B  06 EE      	.double:	asl.l	<map_line		; Lo-byte of (CHR Y * width * 2).
  371    02:DD8D  2A         			rol	a
  372    02:DD8E  A8         			tay				; Hi-byte of (CHR Y * width * 2).
  373                        	
  374    02:DD8F  BD B6 2B   			lda	vdc_map_bank, x		; Put the MAP into MPR3-MPR5.
  375    02:DD92  53 08      			tam3				; Allow for 16KByte chrmap.
  376    02:DD94  1A         			inc	a
  377    02:DD95  53 10      			tam4
  378    02:DD97  1A         			inc	a
  379    02:DD98  53 20      			tam5
  380                        	
  381    02:DD9A  68         			pla				; Pop chr_x in map section.
  382    02:DD9B  0A         			asl	a			; 2-bytes for a BAT value.
  383    02:DD9C  90 02      			bcc	!+
  384    02:DD9E  C8         			iny				; Hi-byte of (CHR Y * width * 2).
  385    02:DD9F  18         			clc
  386    02:DDA0  65 EE      	!:		adc.l	<map_line		; Lo-byte of (CHR Y * width * 2).
  387    02:DDA2  90 01      			bcc	!+
  388    02:DDA4  C8         			iny
  389                        	
  390    02:DDA5  18         	!:		clc				; Calc map data pointer.
  391    02:DDA6  7D B4 2B   			adc.l	vdc_map_addr, x
  392    02:DDA9  85 EC      			sta.l	<_bp			; Maximum map size is 16KBytes
  393    02:DDAB  98         			tya				; so we don't need to consider
  394    02:DDAC  7D B5 2B   			adc.h	vdc_map_addr, x		; bank overflow.
  395    02:DDAF  85 ED      			sta.h	<_bp
  396                        	
  397    02:DDB1  C2         			cly				; Calculate the map line delta
  398    02:DDB2  BD 77 26   			lda	vdc_map_line_w, x	; in bytes.
  399    02:DDB5  D0 01      			bne	!+
  400    02:DDB7  C8         			iny
  401    02:DDB8  0A         	!:		asl	a
  402    02:DDB9  85 EE      			sta.l	<map_line
  403    02:DDBB  98         			tya
  404    02:DDBC  2A         			rol	a
  405    02:DDBD  85 EF      			sta.h	<map_line
  406                        	
  407                        			; Draw the first part of the column.
  408                        	
  409    02:DDBF  A5 F8      	.draw_col:	lda	<map_bat_x		; Set the BAT VRAM destination
  410    02:DDC1  85 F0      			sta.l	<_di			; coordinates.
  411    02:DDC3  A5 F9      			lda	<map_bat_y
  412    02:DDC5  85 F1      			sta.h	<_di
  413                        	
  414    02:DDC7  5D 73 26   			eor	vdc_bat_y_mask, x	; Calc CHR before wrap.
  415    02:DDCA  1A         			inc	a
  416    02:DDCB  C5 FB      			cmp	<map_draw_h		; Usually (SCR_HEIGHT / 8) + 1.
  417    02:DDCD  90 02      			bcc	!+
  418    02:DDCF  A5 FB      			lda	<map_draw_h		; Maximum CHR to draw.
  419    02:DDD1  85 00      	!:		sta	<map_count		; Set number of CHR to draw.
  420    02:DDD3  85 01      			sta	<map_drawn		; Preserve number of CHR drawn.
  421                        	
  422    02:DDD5  A9 05      			lda	#VDC_CR			; Set VDC auto-increment from
  423    02:DDD7  95 F7      			sta	<vdc_reg, x		; the BAT width, which is set
  424    02:DDD9  9D 00 02   			sta	VDC_AR, x		; up by set_screen_size().
  425    02:DDDC  B5 F4      			lda	<vdc_crh, x
  426    02:DDDE  9D 03 02   			sta	VDC_DH, x
  427                        	
  428    02:DDE1  20 E3 DE   			jsr	bat_col_strip		; Draw top of vertical strip.
  429                        	
  430                        			; Wrap around and draw the rest of the column (if needed).
  431                        	
  432    02:DDE4  38         			sec				; Are there any more CHR that
  433    02:DDE5  A5 FB      			lda	<map_draw_h		; need to be drawn?
  434    02:DDE7  E5 01      			sbc	<map_drawn
  435    02:DDE9  F0 0B      			beq	.done
  436                        	
  437    02:DDEB  85 00      			sta	<map_count		; Set number of CHR to draw.
  438                        	
  439    02:DDED  A5 F8      			lda	<map_bat_x		; Set the BAT VRAM destination
  440    02:DDEF  85 F0      			sta.l	<_di			; coordinates.
  441    02:DDF1  64 F1      			stz.h	<_di			; Reset 1st row to draw.
  442                        	
  443    02:DDF3  20 E3 DE   			jsr	bat_col_strip		; Draw btm of vertical strip.
  444                        	
  445    02:DDF6  A9 05      	.done:		lda	#VDC_CR			; Set VDC auto-increment to 1.
  446    02:DDF8  95 F7      			sta	<vdc_reg, x
  447    02:DDFA  9D 00 02   			sta	VDC_AR, x
  448    02:DDFD  9E 03 02   			stz	VDC_DH, x
  449                        	
  450    02:DE00  60         			rts
  451                        	
  452                        	
  453                        	
  454                        	; ***************************************************************************
  455                        	; ***************************************************************************
  456                        	;
  457                        	; bat_scroll_y - Update the BAT when Y coordinate changes.
  458                        	;
  459                        	; N.B. This draws multiple rows when called from _draw_bat or _blit_bat.
  460                        	;
  461                        	
  462    02:DE01  60         	!no_change:	rts
  463                        	
  464    02:DE02  A5 FE      	bat_scroll_y:	lda	<map_chr_y		; Compare old_y with cur_y.
  465    02:DE04  DD AD 2B   			cmp	vdc_old_chr_y, x
  466    02:DE07  F0 F8      			beq	!no_change-		; Do nothing if no change.
  467    02:DE09  9D AD 2B   			sta	vdc_old_chr_y, x
  468    02:DE0C  30 05      			bmi	.moved			; Test the sign of the change.
  469                        	
  470    02:DE0E  18         			clc				; Draw bottom if chr_y >= old_y.
  471    02:DE0F  7D 76 26   			adc	vdc_map_draw_h, x	; Usually (SCR_HEIGHT / 8) + 1.
  472    02:DE12  3A         			dec	a
  473                        	
  474    02:DE13  A8         	.moved:		tay				; Y = chr_y in map section.
  475                        	
  476    02:DE14  3C 7D 26   			bit	vdc_map_option, x	; Set bit6 to disable aligning
  477    02:DE17  70 05      			bvs	!+			; BAT Y with the map Y.
  478    02:DE19  3D 73 26   			and	vdc_bat_y_mask, x
  479    02:DE1C  85 F9      			sta	<map_bat_y		; Save BAT Y chr coordinate.
  480                        	
  481    02:DE1E  3C 7D 26   	!:		bit	vdc_map_option, x	; Set bit7 to disable aligning
  482    02:DE21  30 07      			bmi	!+			; BAT X with the map X.
  483    02:DE23  A5 FC      			lda	<map_chr_x
  484    02:DE25  3D 72 26   			and	vdc_bat_x_mask, x
  485    02:DE28  85 F8      			sta	<map_bat_x		; Save BAT X chr coordinate.
  486                        	
  487               0000     		.if	FAST_MULTIPLY
  490                        		.endif
  491                        	
  492    02:DE2A  BD 77 26   	!:		lda	vdc_map_line_w, x	; Map width in CHR (0 == 256).
  493    02:DE2D  D0 05      			bne	!+
  494                        	
  495    02:DE2F  64 EE      			stz.l	<map_line		; Multiply by 256 is easy!
  496    02:DE31  98         			tya
  497    02:DE32  80 15      			bra	.double
  498                        	
  499               0000     		.if	FAST_MULTIPLY
  511                        		.else
  512    02:DE34  84 EF      	!:		sty.h	<map_line		; Takes 144..176 cycles.
  513    02:DE36  A0 08      			ldy	#8
  514    02:DE38  4A         			lsr	a
  515    02:DE39  85 EE      			sta.l	<map_line
  516    02:DE3B  62         			cla
  517    02:DE3C  90 03      			bcc	.rotate
  518    02:DE3E  18         	.add:		clc
  519    02:DE3F  65 EF      			adc.h	<map_line
  520    02:DE41  6A         	.rotate:	ror	a
  521    02:DE42  66 EE      			ror.l	<map_line		; Lo-byte of (CHR Y * width).
  522    02:DE44  88         			dey
  523    02:DE45  B0 F7      			bcs	.add
  524    02:DE47  D0 F8      			bne	.rotate
  525                        		.endif
  526                        	
  527    02:DE49  06 EE      	.double:	asl.l	<map_line		; Lo-byte of (CHR Y * width * 2).
  528    02:DE4B  2A         			rol	a
  529    02:DE4C  85 EF      			sta.h	<map_line		; Hi-byte of (CHR Y * width * 2).
  530    02:DE4E  A8         			tay
  531                        	
  532    02:DE4F  BD B6 2B   			lda	vdc_map_bank, x		; Put the MAP into MPR3-MPR5.
  533    02:DE52  53 08      			tam3				; Allow for 16KByte chrmap.
  534    02:DE54  1A         			inc	a
  535    02:DE55  53 10      			tam4
  536    02:DE57  1A         			inc	a
  537    02:DE58  53 20      			tam5
  538                        	
  539                        			; Loop to here if drawing multiple rows.
  540                        	
  541    02:DE5A  A5 FC      	.next_row:	lda	<map_chr_x		; Map CHR X coordinate.
  542    02:DE5C  0A         			asl	a			; 2-bytes for a BAT value!
  543    02:DE5D  90 02      			bcc	!+
  544    02:DE5F  C8         			iny				; Hi-byte of (CHR Y * width * 2).
  545    02:DE60  18         			clc
  546    02:DE61  65 EE      	!:		adc.l	<map_line		; Lo-byte of (CHR Y * width * 2).
  547    02:DE63  90 01      			bcc	!+
  548    02:DE65  C8         			iny
  549    02:DE66  18         	!:		clc				; Calc map data pointer.
  550    02:DE67  7D B4 2B   			adc.l	vdc_map_addr, x
  551    02:DE6A  85 EC      			sta.l	<_bp			; Maximum map size is 16KBytes
  552    02:DE6C  98         			tya				; so we don't need to consider
  553    02:DE6D  7D B5 2B   			adc.h	vdc_map_addr, x		; bank overflow.
  554    02:DE70  85 ED      			sta.h	<_bp
  555                        	
  556                        			; Draw the first part of the row.
  557                        	
  558    02:DE72  A5 F9      	.draw_row:	lda	<map_bat_y		; Set the BAT VRAM destination
  559    02:DE74  85 F1      			sta.h	<_di			; coordinates.
  560    02:DE76  A5 F8      			lda	<map_bat_x
  561    02:DE78  85 F0      			sta.l	<_di
  562                        	
  563    02:DE7A  5D 72 26   			eor	vdc_bat_x_mask, x	; Calc CHR before wrap.
  564    02:DE7D  1A         			inc	a
  565    02:DE7E  C5 FA      			cmp	<map_draw_w		; Usually (SCR_WIDTH / 8) + 1.
  566    02:DE80  90 02      			bcc	!+
  567    02:DE82  A5 FA      			lda	<map_draw_w		; Maximum CHR to draw.
  568    02:DE84  85 00      	!:		sta	<map_count		; Set number of CHR to draw.
  569    02:DE86  85 01      			sta	<map_drawn		; Preserve number of CHR drawn.
  570                        	
  571    02:DE88  20 C2 DE   			jsr	bat_row_strip		; Draw lhs of horizontal strip.
  572                        	
  573                        			; Wrap around and draw the rest of the row (if needed).
  574                        	
  575    02:DE8B  38         			sec				; Are there any more CHR that
  576    02:DE8C  A5 FA      			lda	<map_draw_w		; need to be drawn?
  577    02:DE8E  E5 01      			sbc	<map_drawn
  578    02:DE90  F0 0B      			beq	.done_row
  579                        	
  580    02:DE92  85 00      			sta	<map_count		; Set number of CHR to draw.
  581                        	
  582    02:DE94  A5 F9      			lda	<map_bat_y		; Set the BAT VRAM destination
  583    02:DE96  85 F1      			sta.h	<_di			; coordinates.
  584    02:DE98  64 F0      			stz.l	<_di			; Reset 1st column to draw.
  585                        	
  586    02:DE9A  20 C2 DE   			jsr	bat_row_strip		; Draw rhs of horizontal strip.
  587                        	
  588    02:DE9D  C6 FB      	.done_row:	dec	<map_draw_h		; Are all desired rows drawn?
  589    02:DE9F  F0 20      			beq	.finished
  590                        	
  591    02:DEA1  A5 F9      			lda	<map_bat_y		; Move BAT Y down by 1.
  592    02:DEA3  1A         			inc	a
  593    02:DEA4  3D 73 26   			and	vdc_bat_y_mask, x
  594    02:DEA7  85 F9      			sta	<map_bat_y
  595                        	
  596    02:DEA9  A4 EF      			ldy.h	<map_line		; Move the map line pointer to
  597    02:DEAB  C8         			iny				; the next line.
  598    02:DEAC  BD 77 26   			lda	vdc_map_line_w, x
  599    02:DEAF  F0 0B      			beq	!++			; vdc_map_line_w == 0 == 256.
  600    02:DEB1  0A         			asl	a			; 2-bytes for a BAT value!
  601    02:DEB2  B0 01      			bcs	!+
  602    02:DEB4  88         			dey				; Fix if vdc_map_line_w <= 127.
  603    02:DEB5  18         	!:		clc
  604    02:DEB6  65 EE      			adc.l	<map_line
  605    02:DEB8  85 EE      			sta.l	<map_line
  606    02:DEBA  90 01      			bcc	!++
  607    02:DEBC  C8         	!:		iny
  608    02:DEBD  84 EF      	!:		sty.h	<map_line		; Needed for .next_row!
  609                        	
  610    02:DEBF  80 99      			bra	.next_row		; Draw next row.
  611                        	
  612    02:DEC1  60         	.finished:	rts
  613                        	
  614                        	
  615                        	
  616                        	; ***************************************************************************
  617                        	; ***************************************************************************
  618                        	;
  619                        	; bat_row_strip - Draw a single row of CHR into the BAT.
  620                        	;
  621                        	
  622    02:DEC2  20 34 E4   	bat_row_strip:	jsr	set_di_xy_mawr		; Set the BAT VRAM destination.
  623                        	
  624    02:DEC5  C2         			cly				; 2
  625    02:DEC6  B1 EC      	.repeat:	lda	[_bp], y		; 7
  626    02:DEC8  9D 02 02   			sta	VDC_DL, x		; 6
  627    02:DECB  C8         			iny				; 2
  628    02:DECC  B1 EC      			lda	[_bp], y		; 7
  629               0000     		.if	CHRMAP_BAT_FLAG
  634                        		.endif
  635    02:DECE  9D 03 02   			sta	VDC_DH, x		; 6
  636    02:DED1  C8         			iny				; 2
  637                        	
  638    02:DED2  C6 00      	!:		dec	<map_count		; 6
  639    02:DED4  D0 F0      			bne	.repeat			; 4
  640                        	
  641    02:DED6  98         			tya				; 2
  642    02:DED7  F0 07      			beq	!+			; 2/4
  643    02:DED9  18         			clc				; 2
  644    02:DEDA  65 EC      			adc.l	<_bp			; 4
  645    02:DEDC  85 EC      			sta.l	<_bp			; 4
  646    02:DEDE  90 02      			bcc	.done			; 2/4
  647    02:DEE0  E6 ED      	!:		inc.h	<_bp			; 6
  648                        	
  649    02:DEE2  60         	.done:		rts
  650                        	
  651                        	
  652                        	
  653                        	; ***************************************************************************
  654                        	; ***************************************************************************
  655                        	;
  656                        	; bat_col_strip - Draw a single column of CHR into the BAT.
  657                        	;
  658                        	
  659    02:DEE3  20 34 E4   	bat_col_strip:	jsr	set_di_xy_mawr		; Set the BAT VRAM destination.
  660                        	
  661    02:DEE6  A0 01      			ldy	#1			; 2
  662    02:DEE8  B2 EC      	.repeat:	lda	[_bp]			; 7
  663    02:DEEA  9D 02 02   			sta	VDC_DL, x		; 6
  664    02:DEED  B1 EC      			lda	[_bp], y		; 7
  665               0000     		.if	CHRMAP_BAT_FLAG
  670                        		.endif
  671    02:DEEF  9D 03 02   			sta	VDC_DH, x		; 6
  672                        	
  673    02:DEF2  18         			clc				; 2
  674    02:DEF3  A5 EE      			lda.l	<map_line		; 4
  675    02:DEF5  65 EC      			adc.l	<_bp			; 4
  676    02:DEF7  85 EC      			sta.l	<_bp			; 4
  677    02:DEF9  A5 EF      			lda.h	<map_line		; 4
  678    02:DEFB  65 ED      			adc.h	<_bp			; 4
  679    02:DEFD  85 ED      			sta.h	<_bp			; 4
  680                        	
  681    02:DEFF  C6 00      			dec	<map_count		; 6
  682    02:DF01  D0 E5      			bne	.repeat			; 4
  683                        	
  684    02:DF03  60         			rts
  685                        	
  686                        		.endprocgroup	; chrmap_group
                             #[2]   "..\..\..\include\hucc\hucc-final.asm"
   88                        		.endif	HUCC_USES_CHRMAP
   89                        	
   90               0001     		.ifdef	HUCC_USES_OLD_LINE		; Set in hucc_old_line.h
                             #[3]   "..\..\..\include\hucc\hucc-old-line.asm"
   91                        			include	"hucc-old-line.asm"
    1                        	; ***************************************************************************
    2                        	; ***************************************************************************
    3                        	;
    4                        	; hucc-old-line.asm
    5                        	;
    6                        	; Based on the original HuC and MagicKit functions by David Michel and the
    7                        	; other original HuC developers.
    8                        	;
    9                        	; Modifications copyright John Brandwood 2024-2025.
   10                        	;
   11                        	; Distributed under the Boost Software License, Version 1.0.
   12                        	; (See accompanying file LICENSE_1_0.txt or copy at
   13                        	;  http://www.boost.org/LICENSE_1_0.txt)
   14                        	;
   15                        	; ***************************************************************************
   16                        	; ***************************************************************************
   17                        	
   18                        	
   19                        	
   20                        	; ***************************************************************************
   21                        	; ***************************************************************************
   22                        	;
   23                        	; void __fastcall gfx_init( unsigned int start_vram_addr<_ax> );
   24                        	;
   25                        	; initialize graphics mode
   26                        	; - points graphics map to tiles at start_vram_addr
   27                        	
   28                        	_gfx_init.1	.proc
   73                        			.endp
   74                        	
   75                        	
   76                        	
   77                        	; ***************************************************************************
   78                        	; ***************************************************************************
   79                        	;
   80                        	; void __fastcall gfx_clear( unsigned int start_vram_addr<_di> );
   81                        	;
   82                        	; Clear the values in the graphics tiles
   83                        	; - places zeroes in graphics tiles at start_vram_addr
   84                        	
   85                        	_gfx_clear.1	.proc
  105                        			.endp
  106                        	
  107                        	
  108                        	
  109                        	; ***************************************************************************
  110                        	; ***************************************************************************
  111                        	;
  112                        	; void __fastcall gfx_line( unsigned int x1<_gfx_x1>, unsigned int y1<_gfx_y1>, unsigned int x2<_gfx_x2>, unsigned int y2<_gfx_y2>, unsigned char color<_gfx_color> );
  113                        	
  114                        	huc_gfx_line	.procgroup
  459                        			.endprocgroup	; huc_gfx_line
                             #[2]   "..\..\..\include\hucc\hucc-final.asm"
   92                        		.endif
   93                        	
   94               0000     		.ifdef	HUCC_USES_ZX0			; Set in hucc_zx0.h
   96                        		.endif
   97                        	
   98                        	
   99                        	
  100                        	; ***************************************************************************
  101                        	; ***************************************************************************
  102                        	;
  103                        	; Check that C "__zp" declarations aren't overwriting System Card variables.
  104                        	;
  105                        	
  106               20A0     			.zp
  107               0000     		.if	(* > zpg_sys_top) || (USING_PSGDRIVER && (* > zpg_psg_top))
  109                        		.endif
  110                        	
  111                        	
  112                        	
  113                        	; ***************************************************************************
  114                        	; ***************************************************************************
  115                        	;
  116                        	; Check that there isn't too much C "const" data in the ".RODATA" section.
  117                        	;
  118                        	
  119               6196     			.rodata
  120               0000     		.if	(bank(*) - _bank_base) >= (CONST_BANK + 2)
  122                        		.endif
  123               E937     			.code
                             #[1]   "main.s"

PROCEDURE LIST (in order of size):

Size: $170B, Addr: $01:C196,      .proc _update_PLAYER
Size: $086D, Addr: $02:C000, .procgroup blkmap_group
Size: $0580, Addr: $01:D8A1,      .proc _joypad_BUTTONS_SHOP
Size: $0429, Addr: $02:C86D,      .proc _joypad_DIR
Size: $03E8, Addr: $02:CC96,      .proc _init_SHOP
Size: $0390, Addr: $02:D07E,      .proc huc_monofont_x
Size: $02F0, Addr: $02:D40E,      .proc _init_HUD
Size: $02C7, Addr: $02:D6FE,      .proc _init_LEVEL
Size: $02AD, Addr: $02:D9C5,      .proc _load_OBJECT_TILES
Size: $0292, Addr: $02:DC72, .procgroup chrmap_group
Size: $01D2, Addr: $01:DE21,      .proc _main
Size: $0184, Addr: $11:C000,      .proc _check_OBJECT
Size: $0167, Addr: $11:C184,      .proc _scroll_object
Size: $0167, Addr: $11:C2EB,      .proc _scroll_chest
Size: $0167, Addr: $11:C452,      .proc _scroll_npc
Size: $013E, Addr: $11:C5B9,      .proc _check_NPC
Size: $013D, Addr: $11:C6F7,      .proc _init_OBJECT_LV1
Size: $0108, Addr: $11:C834,      .proc read_joypads
Size: $0107, Addr: $11:C93C,      .proc _recenter_CAMERA
Size: $00DF, Addr: $02:DF04, .procgroup vdc_set_mode
Size: $00D4, Addr: $11:CA43,      .proc _joypad_BUTTONS
Size: $00D4, Addr: $11:CB17,      .proc _init_NPC_LV1
Size: $00C7, Addr: $11:CBEB,      .proc _init_CHEST_LV1
Size: $00BF, Addr: $11:CCB2, .procgroup vdc_tty_out
Size: $00A5, Addr: $11:CD71,      .proc _display_TIME_SHOP
Size: $009D, Addr: $10:DF60,      .proc _display_TIME_LEVEL
Size: $0086, Addr: $11:CE16,      .proc _sgx_scroll_split.5
Size: $0081, Addr: $11:CE9C,      .proc vbl_init_scroll
Size: $007A, Addr: $11:CF1D,      .proc _check_TILE_DEPTH
Size: $0077, Addr: $11:CF97,      .proc core_main
Size: $006A, Addr: $11:D00E, .procgroup load_vram_group
Size: $0064, Addr: $11:D078,      .proc _check_BG
Size: $0062, Addr: $11:D0DC,      .proc _init_256x224
Size: $004B, Addr: $11:D13E, .procgroup hucc_memcmp
Size: $004B, Addr: $11:D189, .procgroup old_satb_group
Size: $0043, Addr: $11:D1D4, .procgroup vdc_clear_vram
Size: $0043, Addr: $11:D217,      .proc sgx_detect
Size: $003F, Addr: $11:D25A, .procgroup load_bat_group
Size: $003E, Addr: $11:D299,      .proc _vram2vram.3
Size: $003B, Addr: $11:D2D7,      .proc init_random
Size: $0033, Addr: $11:D312,      .proc _init_VARIABLES
Size: $002E, Addr: $11:D345,      .proc _scroll_BG
Size: $002C, Addr: $11:D373,      .proc _init_PLAYER
Size: $002B, Addr: $11:D39F,      .proc _load_palette.3
Size: $0025, Addr: $11:D3CA,      .proc _load_CHEST_TILES
Size: $0025, Addr: $11:D3EF,      .proc _load_NPC_TILES
Size: $0023, Addr: $11:D414,      .proc _hide_LEVEL_SPRITES
Size: $001C, Addr: $02:DFE3,      .proc _display_SCORE
Size: $001C, Addr: $11:D437,      .proc _display_ZENNY
Size: $001C, Addr: $11:D453,      .proc clear_vce
Size: $001A, Addr: $11:D46F,      .proc _display_KEY
Size: $001A, Addr: $11:D489,      .proc _display_POTION
Size: $001A, Addr: $11:D4A3,      .proc _init_SYSTEM
