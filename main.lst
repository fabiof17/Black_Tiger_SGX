                             #[1]   "main.s"
   27                        	
   28               0010     	CORE_VERSION	=	$10			; Version 1.0
   29                        	
   30                        			; Get the user program's configuration settings, this will
   31                        			; be read from the current directory, if it exists, or the
   32                        			; "../include/" directory if not.
   33                        	
                             #[4]   "..\..\..\include\hucc\core-config.inc"
   34                        			include	"core-config.inc"
    1                        	; ***************************************************************************
    2                        	; ***************************************************************************
    3                        	;
    4                        	; core-config.inc
    5                        	;
    6                        	; Configuration settings for the "CORE(not TM)" PC Engine library code.
    7                        	;
    8                        	; Copyright John Brandwood 2021-2024.
    9                        	;
   10                        	; Distributed under the Boost Software License, Version 1.0.
   11                        	; (See accompanying file LICENSE_1_0.txt or copy at
   12                        	;  http://www.boost.org/LICENSE_1_0.txt)
   13                        	;
   14                        	; ***************************************************************************
   15                        	; ***************************************************************************
   16                        	;
   17                        	; The idea is that you, a PCE developer, copy this file from the ../include/
   18                        	; directory and into your project's directory, and then customize the values
   19                        	; to suit your particular project.
   20                        	;
   21                        	; Because PCEAS searches the current (i.e. project) directory for an include
   22                        	; file first, then it will find your customized copy of the file rather than
   23                        	; the original copy in the ../include/ directory.
   24                        	;
   25                        	; That means that all of the different overlay programs in your project will
   26                        	; share the same overall library configuration for your game.
   27                        	;
   28                        	; ***************************************************************************
   29                        	; ***************************************************************************
   30                        	
   31                        	;
   32                        	; Are we going to take over MPR7?
   33                        	;
   34                        	; While this is the default for the "CORE(not TM)" library, it is definitely
   35                        	; possible to use the library to build CD-ROM code that runs with the System
   36                        	; Card in MPR7, and with the 1st bank remaining in MPR2.
   37                        	;
   38                        	; N.B. The CD-ROM Stage1 loader runs the library with USING_MPR7=0 while it
   39                        	;      installs the kernel into PCE RAM in MPR1.
   40                        	;
   41                        	
   42               0000     		.ifndef	USING_MPR7
   44                        		.endif
   45                        	
   46                        	;
   47                        	; Are we building a CD-ROM overlay that uses an already-built CD-ROM Stage1
   48                        	; loader to install the library's kernel code into PCE RAM in MPR1?
   49                        	;
   50                        	; If this is set, the library's kernel code will be excluded from the build,
   51                        	; which will save about 1KB-3KB of code space in every overlay program!
   52                        	;
   53                        	; N.B. The CD-ROM Stage1 loader sets USING_STAGE1=0 so it builds correctly.
   54                        	;
   55                        	
   56               0000     		.ifndef	USING_STAGE1
   58                        		.endif
   59                        	
   60                        	;
   61                        	; Are we currently building the CD-ROM Stage1 loader?
   62                        	;
   63                        	; If this is set, the library's startup code does not call the __sound_init
   64                        	; macro because the sound driver code is not usually a part of the kernel.
   65                        	;
   66                        	; N.B. The CD-ROM Stage1 loader sets BUILDING_STAGE1=1 so it builds correctly.
   67                        	;
   68                        	
   69               0000     		.ifndef	BUILDING_STAGE1
   71                        		.endif
   72                        	
   73                        	;
   74                        	; Is the last track of the CD a duplicate of the main ISO data track?
   75                        	;
   76                        	; Most CD games put two copies of the same ISO track on the CD, so that data
   77                        	; can be read from the secondary track if the drive has a problem reading it
   78                        	; it from the primary location.
   79                        	;
   80                        	; If set, the secondary track will be enabled when the library first starts.
   81                        	;
   82                        	
   83               0000     		.ifndef	SUPPORT_2ISO
   85                        		.endif
   86                        	
   87                        	;
   88                        	; Maximum number of directory entries to use from the ISO.
   89                        	;
   90                        	; The fewer that we choose, the less RAM memory we need. A setting of 64 is
   91                        	; a good compromise to use until you are putting lots of files on the ISO.
   92                        	;
   93                        	
   94               0000     		.ifndef	MAX_DIRSIZE
   96                        		.endif
   97                        	
   98                        	;
   99                        	; Use the System Card's PSG driver code instead of a modern alternative
  100                        	; sound driver like a DefleMask or Furnace player?
  101                        	;
  102                        	
  103               0000     		.ifndef	USING_PSGDRIVER
  105                        		.endif
  106                        	
  107                        	;
  108                        	; Support development for the Turbo EverDrive v2?
  109                        	;
  110                        	; This only applies to HuCard programs, but when chosen, the "CORE(not TM)"
  111                        	; kernel is moved from bank 0 to bank 2, and a minimal set of startup code
  112                        	; is put in bank 0.
  113                        	;
  114                        	; This is because the TED2 hardware occupies the whole of bank 0 when it is
  115                        	; activated, and so we need to run with a different bank in MPR7.
  116                        	;
  117                        	
  118               0000     		.ifndef	SUPPORT_TED2
  120                        		.endif
  121                        	
  122                        	;
  123                        	; Support development for the SuperGRAFX?
  124                        	;
  125                        	; This enables SuperGRAFX support in certain library functions.
  126                        	;
  127                        	
  128               0000     		.ifndef	SUPPORT_SGX
  130                        		.endif
  131                        	
  132                        	;
  133                        	; Choose SuperGRAFX VPC initialization mode.
  134                        	;
  135                        	; SGX_PARALLAX=0 (useful when VDC #1 is a fullscreen HUD)
  136                        	;
  137                        	;  FRONT
  138                        	;   SP1 = VDC #1 (pce) sprite pixels
  139                        	;   BG1 = VDC #1 (pce) background pixels
  140                        	;   SP2 = VDC #2 (sgx) sprite pixels
  141                        	;   BG2 = VDC #2 (sgx) background pixels
  142                        	;  BACK
  143                        	;
  144                        	; SGX_PARALLAX=1
  145                        	;
  146                        	;  FRONT
  147                        	;   SP1 = VDC #1 (pce) sprite pixels
  148                        	;   SP2 = VDC #2 (sgx) sprite pixels
  149                        	;   BG1 = VDC #1 (pce) background pixels
  150                        	;   BG2 = VDC #2 (sgx) background pixels
  151                        	;  BACK
  152                        	;
  153                        	
  154               0000     		.ifndef	SGX_PARALLAX
  156                        		.endif
  157                        	
  158                        	;
  159                        	; Support development for the ArcadeCard?
  160                        	;
  161                        	; This enables ArcadeCard support in certain library functions.
  162                        	;
  163                        	
  164               0000     		.ifndef	SUPPORT_ACD
  166                        		.endif
  167                        	
  168                        	;
  169                        	; Support development for the IFU's ADPCM hardware?
  170                        	;
  171                        	; Developers would normally just use the System Card functions for ADPCM, but
  172                        	; enabling this adds alternative functions, and allows ADPCM use on a HuCARD.
  173                        	;
  174                        	
  175               0000     		.ifndef	SUPPORT_ADPCM
  177                        		.endif
  178                        	
  179                        	;
  180                        	; Select which version of the joystick library code to include, only one of
  181                        	; these can be set to '1' ...
  182                        	;
  183                        	; SUPPORT_2BUTTON : Only returns buttons I and II.
  184                        	; SUPPORT_6BUTTON : Read buttons III-VI, but ignore a mouse.
  185                        	; SUPPORT_MOUSE	  : Read mouse, but ignore buttons III-VI.
  186                        	;
  187                        	; It doesn't make sense to design a game the relies on both the 6-button and
  188                        	; the mouse, so the joystick library is optimized for one or the other.
  189                        	;
  190                        	; Note that both those devices are always detected and no conflicts occur,
  191                        	; this just controls reading either buttons III-VI or the Mouse Y-movement.
  192                        	;
  193                        	
  194               0000     		.ifndef	SUPPORT_6BUTTON
  200                        		.endif
  201                        	
  202                        	;
  203                        	; How many joypad/mouse devices should be supported?
  204                        	;
  205                        	; This is normally 5, but can be set to 3 (or lower) in order to speed up
  206                        	; the processing and free up CPU time for other code, which is especially
  207                        	; useful for mouse games.
  208                        	;
  209                        	
  210               0000     		.ifndef	MAX_PADS
  212                        		.endif
  213                        	
  214                        	;
  215                        	; Implement a HuC-compatible seperate array for accumulating joypad presses?
  216                        	;
  217                        	; This is only really needed if your game is not expected to run at 60Hz and
  218                        	; so you will sometimes miss joypad presses.
  219                        	;
  220                        	; Alternatively you can set ACCUMULATE_JOY so that joypad presses are always
  221                        	; accumulated in the normal joytrg array, which is how asm programmers would
  222                        	; normally deal with this situation.
  223                        	;
  224                        	
  225               0000     		.ifndef HUC_JOY_EVENTS
  227                        		.endif
  228                        	
  229                        	;
  230                        	; Should "joytrg" accumulate presses, and so need to be explicitely cleared
  231                        	; after reading, or should it just be the result of the last read?
  232                        	;
  233                        	; This option has no effect if HUC_JOY_EVENTS is non-zero since that option
  234                        	; takes precedence over this one!
  235                        	;
  236                        	
  237               0000     		.ifndef ACCUMULATE_JOY
  239                        		.endif
  240                        	
  241                        	;
  242                        	; The DATA_BANK location needs to be set as early as possible so that library
  243                        	; code is able to put data in there before the total overall size of the code
  244                        	; is known.
  245                        	;
  246                        	; By default, DATA_BANK is the next bank after the CORE_BANK.
  247                        	;
  248                        	; RESERVE_BANKS allows developers to reserve some banks between the CORE_BANK
  249                        	; and the DATA_BANK that they can use however they wish.
  250                        	;
  251                        	; One use for RESERVE_BANKS is to create empty space that PCEAS can use when
  252                        	; it relocates procedures. This provides a way for a developer to group code
  253                        	; together at the start of memory, and leave the maximum number of banks for
  254                        	; loading dynamic data from CD-ROM.
  255                        	;
  256                        	; The KickC environment sets RESERVE_BANKS=1 (or higher) so that there is a
  257                        	; a bank for the permanent C code and static constants.
  258                        	;
  259                        	
  260               0000     		.ifndef	RESERVE_BANKS
  266                        		.endif	RESERVE_BANKS
                             #[3]   "..\..\..\include\hucc\core.inc"
   35                        	
   36                        	;
   37                        	; This is a simple macro to call System Card functions when using MPR7 for
   38                        	; running the "CORE(not TM)" PC Engine library code.
   39                        	;
   40                        	
   41                        	system		.macro
   42                        			ldy     #<\1
   43                        			jsr	call_bios
   44                        			.endm
   45                        	
   46                        	;
   47                        	; This replaces the System Card's ex_setvec, because "call_bios" uses the
   48                        	; Y register.
   49                        	;
   50                        	
   51                        	setvec		.macro
   52                        			php
   53                        			sei
   54                        			lda.l	#\2
   55                        			sta.l	\1
   56                        			lda.h	#\2
   57                        			sta.h	\1
   58                        			plp
   59                        			.endm
   60                        	
   61                        	;
   62                        	; Repurpose this System Card variable, since nmi_hook is never used.
   63                        	;
   64                        	; We'll use it as a vector to a user-supplied sound driver instead.
   65                        	;
   66                        	
   67               2206     	sound_hook	=	nmi_hook		; Sound Driver to run in VBL.
   68                        	
   69                        	;
   70                        	; CORE Zero-Page variables, relative to the System Card's ZP variables.
   71                        	;
   72                        	
   73               0000     		.if	USING_PSGDRIVER
   75                        		.else
   76               20EC     	core_zpend	=	$F8:20EC
   77                        		.endif	USING_PSGDRIVER
   78                        	
   79               0001     		.if	SUPPORT_SGX
   80                        	
   81                        			; Put some "CORE(not TM)" variables at the start of Zero Page.
   82                        			;
   83                        			; These are at the *start* of ZP so that the SuperGrafx shadow
   84                        			; "sgx_" registers are at a specific offset from their System
   85                        			; Card "vdc_" counterparts, and they MUST NOT be moved!
   86                        			;
   87                        			; This allows us to put SGX_VDC_OFFSET or PCE_VDC_OFFSET into
   88                        			; the X register, and then index into either set of hardware
   89                        			; registers and the "sgx_reg" or "vdc_reg" shadow-variables.
   90                        	
   91               0000     	PCE_VDC_OFFSET	=	$00		; Offset to PCE VDC chip & shadow vars.
   92               0010     	SGX_VDC_OFFSET	=	$10		; Offset to SGX VDC chip & shadow vars.
   93                        	
   94               2000     			.zp
   95               2000     			.org	$2000
   96    F8:2000             	__temp		ds	2		; $F8:2000 Use within any ASM routine.
   97    F8:2002             	_bp_bank	ds	1		; $F8:2002 Use within any ASM/HuCC routine.
   98    F8:2003             	sgx_crl		ds	1		; $F8:2003 SGX shadow (vdc_crl = $20F3).
   99    F8:2004             	sgx_crh		ds	1		; $F8:2004 SGX shadow (vdc_crh = $20F4).
  100    F8:2005             	core_1stbank	ds	1		; $F8:2005 1st bank of library code.
  101    F8:2006             	sgx_sr		ds	1		; $F8:2006 SGX shadow (vdc_sr  = $20F6).
  102    F8:2007             	sgx_reg		ds	1		; $F8:2007 SGX shadow (vdc_reg = $20F7).
  103                        	
  104               2008     	core_zp1st	=	*		; $F8:2008 1st free user address.
  105                        	
  106                        		.else	SUPPORT_SGX
  116                        		.endif	SUPPORT_SGX
  117                        	
  118                        	;
  119                        	; The kernel code in RAM follows the System Card's RAM variables.
  120                        	;
  121                        	
  122               0000     		.if	USING_PSGDRIVER
  124                        		.else
  125               22D0     	core_ram1st     =	$F8:22D0
  126                        		.endif	USING_PSGDRIVER
  127                        	
  128                        	;
  129                        	; Include the "CORE(not TM)" startup code to begin the HuCARD / Overlay.
  130                        	;
  131                        	
                             #[4]   "..\..\..\include\hucc\core-startup.asm"
  132                        			include	"core-startup.asm"
    1                        	; ***************************************************************************
    2                        	; ***************************************************************************
    3                        	;
    4                        	; core-startup.asm
    5                        	;
    6                        	; The "CORE(not TM)" PC Engine library startup code that runs at boot/reset.
    7                        	;
    8                        	; Copyright John Brandwood 2021-2024.
    9                        	;
   10                        	; Distributed under the Boost Software License, Version 1.0.
   11                        	; (See accompanying file LICENSE_1_0.txt or copy at
   12                        	;  http://www.boost.org/LICENSE_1_0.txt)
   13                        	;
   14                        	; ***************************************************************************
   15                        	; ***************************************************************************
   16                        	;
   17                        	; This is the initialization code in the 1st bank, and it is responsible for
   18                        	; setting up a consistant runtime environment for the developer's program,
   19                        	; so that the developer can concentrate on writing the program itself.
   20                        	;
   21                        	; The idea is that when a program is loaded, the first 40KB of it is mapped
   22                        	; as $4000..$DFFF, and initialization starts at $4000, with the developer's
   23                        	; program getting control after initialization, with a jump to "core_main".
   24                        	;
   25                        	; The initializtion sets up a small kernel of code that provides interrupt
   26                        	; handling that mimics a subset of the System Card's behavior, designed to
   27                        	; act in the same way on HuCARD and CD-ROM, with either the System Card in
   28                        	; MPR7, or with an overlay in MPR7.
   29                        	;
   30                        	; The kernel handles reading the joypad/mouse, and it offers handler hooks
   31                        	; for running the developer's interrupt code.  On CD-ROM systems, it also
   32                        	; handles the loading and running of subsequent overlay programs.
   33                        	;
   34                        	; On HuCARD, the kernel itself runs in MPR7; while on CD-ROM systems it is
   35                        	; run from RAM in MPR1, so that overlay programs are independant from each
   36                        	; other, and can be written in different programming languages.
   37                        	;
   38                        	;
   39                        	; 1) If we're running on a HuCARD, the initialization is simple!
   40                        	;
   41                        	;    The PC Engine's memory map is set to ...
   42                        	;
   43                        	;      MPR0 = bank $FF : PCE hardware
   44                        	;      MPR1 = bank $F8 : PCE RAM with Stack & ZP
   45                        	;      MPR2 = bank $00 : HuCARD ROM
   46                        	;      MPR3 = bank $01 : HuCARD ROM
   47                        	;      MPR4 = bank $02 : HuCARD ROM
   48                        	;      MPR5 = bank $03 : HuCARD ROM
   49                        	;      MPR6 = bank $04 : HuCARD ROM
   50                        	;      MPR7 = bank $00 : HuCARD ROM
   51                        	;
   52                        	;
   53                        	; 2) If we're running on a HuCARD that supports the Turbo Everdrive, then the
   54                        	;    first 2 banks are reserved for mapping the TED2 hardware and a RAM bank.
   55                        	;
   56                        	;    The PC Engine's memory map is set to ...
   57                        	;
   58                        	;      MPR0 = bank $FF : PCE hardware
   59                        	;      MPR1 = bank $F8 : PCE RAM with Stack & ZP
   60                        	;      MPR2 = bank $02 : HuCARD ROM
   61                        	;      MPR3 = bank $03 : HuCARD ROM
   62                        	;      MPR4 = bank $04 : HuCARD ROM
   63                        	;      MPR5 = bank $05 : HuCARD ROM
   64                        	;      MPR6 = bank $06 : HuCARD ROM
   65                        	;      MPR7 = bank $02 : HuCARD ROM
   66                        	;
   67                        	;
   68                        	; 3) If we're running on an old CD System, the overlay is loaded from the ISO
   69                        	;    into banks $80-$87 (64KB max).
   70                        	;
   71                        	;    The PC Engine's memory map is set to ...
   72                        	;
   73                        	;      MPR0 = bank $FF : PCE hardware
   74                        	;      MPR1 = bank $F8 : PCE RAM with Stack & ZP
   75                        	;      MPR2 = bank $80 : CD RAM
   76                        	;      MPR3 = bank $81 : CD RAM
   77                        	;      MPR4 = bank $82 : CD RAM
   78                        	;      MPR5 = bank $83 : CD RAM
   79                        	;      MPR6 = bank $84 : CD RAM
   80                        	;      MPR7 = bank $80 : CD RAM or System Card's bank $00
   81                        	;
   82                        	;
   83                        	; 4) If we're running on a SuperCD System, the overlay is loaded from the ISO
   84                        	;    into banks $68-$87 (256KB max).
   85                        	;
   86                        	;    The PC Engine's memory map is set to ...
   87                        	;
   88                        	;      MPR0 = bank $FF : PCE hardware
   89                        	;      MPR1 = bank $F8 : PCE RAM with Stack & ZP
   90                        	;      MPR2 = bank $68 : SCD RAM
   91                        	;      MPR3 = bank $69 : SCD RAM
   92                        	;      MPR4 = bank $6A : SCD RAM
   93                        	;      MPR5 = bank $6B : SCD RAM
   94                        	;      MPR6 = bank $6C : SCD RAM
   95                        	;      MPR7 = bank $68 : SCD RAM or System Card's bank $00
   96                        	;
   97                        	; ***************************************************************************
   98                        	; ***************************************************************************
   99                        	
  100                        	
  101                        	
  102               E000     			.code
  103               0000     			.bank	0
  104                        	
  105               0000     		.if	SUPPORT_TED2			; Do we want to use a TED2?
  177                        		.endif	SUPPORT_TED2
  178                        	
  179                        	
  180                        	
  181               0001     		.if	USING_MPR7
  182                        	
  183                        	; ***************************************************************************
  184                        	; ***************************************************************************
  185                        	;
  186                        	; RESET VECTORS (when running in MPR7, either as a HuCARD, or a CD overlay)
  187                        	;
  188                        	
  189                        			; Hardware reset and interrupt vectors.
  190                        	
  191               FFF4     			.org	$FFF4
  192                        	
  193    00:FFF4  10         	core_version:	db	CORE_VERSION		; CORE(not TM) Version.
  194    00:FFF5  80         			db	$80			; System Card compatibility.
  195                        	
  196    00:FFF6  5D E0      			dw	core_irq2		; IRQ2	(from CD/ADPCM)
  197    00:FFF8  64 E0      			dw	core_irq1		; IRQ1	(from VDC)
  198    00:FFFA  58 E1      			dw	core_timer		; TIMER (from CPU)
  199    00:FFFC  5E E1      			dw	core_rti		; NMI	(unused)
  200               0000     		.if	CDROM
  202                        		.else
  203    00:FFFE  21 E0      			dw	core_hw_reset		; RESET (HuCARD)
  204                        		.endif	CDROM
  205                        	
  206               0001     		.if	USING_NEWPROC			; If the ".proc" trampolines
  207               FFF3     	__trampolineptr =	$FFF3			; are in MPR7, tell PCEAS to
  208                        		.endif					; put them below the vectors.
  209                        	
  210                        		.else	USING_MPR7
  222                        		.endif	USING_MPR7
  223                        	
  224                        	
  225                        	
  226                        	; ***************************************************************************
  227                        	; ***************************************************************************
  228                        	;
  229                        	; !!! THE HuCARD/OVERLAY PROGRAM'S FIRST BANK STARTS HERE !!!
  230                        	;
  231                        	
  232                        			; Switch to MPR2 for the "CORE(not TM)" library init.
  233                        			;
  234                        			; This is also executed by a HuCARD once it has run
  235                        			; its initial hardware-reset code.
  236                        			;
  237                        			; When run, MPR2-MPR6 are always mapped to the 1st 5 banks of
  238                        			; the overlay program, and MPR7 contains the System Card.
  239                        	
  240               4000     			.org	$4000
  241                        	
  242               0000     	CORE_BANK	=	bank(*) - _bank_base	; It isn't always zero! ;-)
  243                        	
  244               0000     			.bank	CORE_BANK, "CORE_BANK"	; Give it a label.
  245                        	
  246               0001     		.if	USING_MPR7
  247               0007     	CORE_PAGE	=	7			; User code runs in MPR7.
  248                        		.else
  250                        		.endif	USING_MPR7
  251                        	
  252    00:4000  4C 06 40   	core_boot:	jmp	* + 6			; Allow someone to patch this.
  253                        	
  254                        			; Add an ident string so isoLINK can autodetect configuration.
  255                        			;
  256                        			; This allows isoLINK to decide whether to use the IPL-SCD boot
  257                        			; sector hack, and whether to include a SuperGRAFX signature in
  258                        			; the boot sector, without the user having to manually use some
  259                        			; command line parameters, although they are free to do that if
  260                        			; they wish.
  261                        	
  262               0001     		.if	SUPPORT_SGX
  263               0000     		.if	BUILDING_STAGE1
  265                        		.else
  266    00:4003  53 47 58   			db	"SGX"			; SGX SuperCD or SGX HuCARD.
  267                        		.endif	BUILDING_STAGE1
  268                        		.else
  282                        		.endif	SUPPORT_SGX
  283                        	
  284               0000     		.if	CDROM
  331                        		.else	CDROM
  332                        	
  333                        			; Set up HuCARD RAM in a compatible way to the System Card.
  334                        			;
  335                        			; Note that the entire RAM is cleared by "core_hw_reset".
  336                        	
  337    00:4006  A9 1F      			lda	#%11111			; Enable joypad soft-reset.
  338    00:4008  8D 27 22   			sta	joyena
  339                        	
  340                        		.endif	CDROM
  341                        	
  342                        			; Now that RAM is initialized ...
  343                        	
  344    00:400B  43 04      			tma2				; Remember overlay's 1st bank
  345    00:400D  85 05      			sta	<core_1stbank		; $00, $02, $68 or $80!
  346               0001     		.if	USING_MPR7
  347    00:400F  53 80      			tam7				; "CORE(not TM)" takes MPR7!
  348                        		.endif
  349                        	
  350    00:4011  A2 FF      			ldx	#$FF			; Initialize stack pointer.
  351    00:4013  9A         			txs
  352                        	
  353    00:4014  20 5F E1   			jsr	core_clr_hooks		; Reset default hooks.
  354                        	
  355                        	;		stz	TIMER_CR		; Stop HuC6280 timer.
  356                        	;		stz	IRQ_ACK			; Clr HuC6280 timer interrupt.
  357                        	;		stz	IRQ_MSK			; Clr HuC6280 interrupt mask.
  358                        	
  359    00:4017  AD 00 02   			lda	VDC_SR			; Purge any overdue VBL.
  360    00:401A  9C 41 22   			stz	irq_cnt			; Make it easy to check.
  361    00:401D  58         			cli				; Restore interrupts.
  362                        	
  363    00:401E  4C E5 FF   			jmp	core_main		; Start the game's code.
  364                        	
  365                        	
  366                        	
  367               0001     		.if	!CDROM
  368                        	
  369                        	; ***************************************************************************
  370                        	; ***************************************************************************
  371                        	;
  372                        	; HuCARD Kernel Code
  373                        	;
  374                        	; core_ram1st - Start of code to relocate to MPR1.
  375                        	; core_ramend - End of code to relocate to MPR1.
  376                        	;
  377                        	
  378                        			; In a HuCARD, BSS variables start as low as possible.
  379                        	
  380               2200     			.bss
  381               22D0     			.org	core_ram1st
  382               22D0     	core_ramend	=	*
  383               4021     			.code
  384                        	
  385                        			; Normal HuCARD hardware-reset code, executed in MPR7.
  386                        			;
  387                        			; This does the basic PCE startup that every HuCARD (including
  388                        			; a System Card) needs to do, and then it remaps memory to be
  389                        			; compatible with the "CORE(not TM)" CD overlay program start.
  390                        	
  391               E021     			.page	7			; This will run in MPR7.
  392                        	
  393    00:E021  78         	core_hw_reset:	sei				; Disable interrupts.
  394    00:E022  D4         			csh				; Set high-speed mode.
  395    00:E023  D8         			cld
  396                        	
  397    00:E024  A2 FF      			ldx	#$FF			; Initialize stack pointer.
  398    00:E026  9A         			txs
  399    00:E027  8A         			txa				; MPR0 = $FF : PCE hardware
  400    00:E028  53 01      			tam0				; MPR1 = $F8 : PCE RAM
  401    00:E02A  A9 F8      			lda	#$F8
  402    00:E02C  53 02      			tam1
  403                        	
  404    00:E02E  9C 01 0C   			stz	TIMER_CR		; HW reset already does these,
  405    00:E031  9C 03 14   			stz	IRQ_ACK			; but this may be a reset from
  406    00:E034  9C 02 14   			stz	IRQ_MSK			; software (i.e. joypad).
  407                        	
  408    00:E037  F3 53 E0 00			tai	const_0000, $2000, 8192 ; Clear RAM.
         00:E03B  20 00 20    
  409                        	
  410    00:E03E  43 80      			tma7				; Not always bank 0!
  411                        	
  412    00:E040  53 04      			tam2				; Set CD-ROM overlay memory map,
  413    00:E042  1A         			inc	a			; 1st 5 banks in MPR2-MPR6.
  414    00:E043  53 08      			tam3
  415    00:E045  1A         			inc	a
  416    00:E046  53 10      			tam4
  417    00:E048  1A         			inc	a
  418    00:E049  53 20      			tam5
  419    00:E04B  1A         			inc	a
  420    00:E04C  53 40      			tam6
  421                        	
  422    00:E04E  4C 00 40   			jmp	core_boot		; Continue execution in MPR2.
  423                        	
  424                        			; In a HuCARD, the kernel code is permanently in MPR7.
  425                        	
                             #[5]   "..\..\..\include\hucc\core-kernel.asm"
  426                        			include "core-kernel.asm"
    1                        	; ***************************************************************************
    2                        	; ***************************************************************************
    3                        	;
    4                        	; core-kernel.asm
    5                        	;
    6                        	; The "CORE(not TM)" PC Engine library kernel code that runs after startup.
    7                        	;
    8                        	; Copyright John Brandwood 2021-2024.
    9                        	;
   10                        	; Distributed under the Boost Software License, Version 1.0.
   11                        	; (See accompanying file LICENSE_1_0.txt or copy at
   12                        	;  http://www.boost.org/LICENSE_1_0.txt)
   13                        	;
   14                        	; ***************************************************************************
   15                        	; ***************************************************************************
   16                        	;
   17                        	; This code is permanently located in either MPR7 (HuCARD), or MPR1 (CD-ROM),
   18                        	; and it provides a consistant method of interrupt-handling on both systems
   19                        	; that is designed to be compatible with the System Card.
   20                        	;
   21                        	; The library uses the "irq1_hook" for its own VDC interrupt handler, and PCE
   22                        	; developers are expected to use "vsync_hook" and "hsync_hook" for their VDC
   23                        	; interrupt functions.  Plenty of memory is available in the 1st bank for the
   24                        	; developer to put those functions.
   25                        	;
   26                        	; The reason for using "irq1_hook", is so that the library can work properly
   27                        	; if either the current overlay program, or the System Card, are mapped into
   28                        	; MPR7 whenever an interrupt occurs.
   29                        	;
   30                        	; The VDC interupt handler itself is changed from the System Card's handler,
   31                        	; and it is designed to provide faster response to vsync_hook, and to enable
   32                        	; interrupts during the slow(ish) joypad and sound driver code, so that both
   33                        	; raster and timer interrupts are not delayed.
   34                        	;
   35                        	; Developers are free to enable interrupts during their own vsync_hook code,
   36                        	; if they wish to do so.
   37                        	;
   38                        	; On CD-ROM systems, this library kernel also provides a function to load and
   39                        	; run a new overlay program, without relying upon any of the code/data within
   40                        	; the current overlay program's memory (unlike HuC v3).
   41                        	;
   42                        	; ***************************************************************************
   43                        	; ***************************************************************************
   44                        	
   45                        	
   46                        	
   47                        	; ***************************************************************************
   48                        	; ***************************************************************************
   49                        	;
   50                        	; core_kernel - Start of kernel code.
   51                        	;
   52                        	
   53               E051     	core_kernel	=	*
   54                        	
   55                        	
   56                        	
   57                        	; ***************************************************************************
   58                        	; ***************************************************************************
   59                        	;
   60                        	; Useful constants, needed by joypad library code, and used by many others.
   61                        	;
   62                        	; The kernel starts with a non-zero byte so that core-startup.asm can check
   63                        	; whether it has already been loaded into RAM.
   64                        	;
   65                        	
   66    00:E051  FF FF      	const_FFFF:	dw	$FFFF			; Useful constant for TAI.
   67    00:E053  00 00      	const_0000:	dw	$0000			; Useful constant for TAI.
   68                        	
   69    00:E055  01 02 04 08	bit_mask:	db	$01,$02,$04,$08,$10,$20,$40,$80
         00:E059  10 20 40 80 
   70                        	
   71                        	
   72                        	
   73                        	; ***************************************************************************
   74                        	; ***************************************************************************
   75                        	;
   76                        	; core_irq2  - Minimal interrupt handler compatible with System Card.
   77                        	; core_irq1  - Minimal interrupt handler compatible with System Card.
   78                        	; core_timer - Minimal interrupt handler compatible with System Card.
   79                        	; core_rti   - Minimal interrupt handler compatible with System Card.
   80                        	;
   81                        	; Note that it takes 8 cycles to respond to an IRQ.
   82                        	;
   83                        	; These routines are copied to a location in RAM that does not vary when
   84                        	; a different overlay program is loaded.
   85                        	;
   86                        	; All overlay programs are set up to vector interrupts to these routines,
   87                        	; which is designed to avoid interrupt-related crashes when loading a new
   88                        	; overlay on top of an old overlay in memory.
   89                        	;
   90                        	; All of the game's actual interrupt handling itself is done in the "hook"
   91                        	; functions so that everything works the same if the System Card is banked
   92                        	; into MPR7 when an interrupt occurs.
   93                        	;
   94                        	; ***************************************************************************
   95                        	; ***************************************************************************
   96                        	;
   97                        	; Bit settings for irq_vec  ...
   98                        	;
   99                        	;   7 : 1 to skip BIOS hsync processsing
  100                        	;   6 : 1 to call [hsync_hook]
  101                        	;   5 : 1 to skip BIOS vsync processsing
  102                        	;   4 : 1 to call [vsync_hook]
  103                        	;
  104                        	;   3 : 1 to jump [nmi_hook]
  105                        	;   2 : 1 to jump [timer_hook]
  106                        	;   1 : 1 to jump [irq1_hook]
  107                        	;   0 : 1 to jump [irq2_hook]
  108                        	;
  109                        	; ***************************************************************************
  110                        	; ***************************************************************************
  111                        	
  112    00:E05D  8F F5 01   	core_irq2:	bbs0	<irq_vec, .hook		; 8 cycles if using hook.
  113                        	
  114               0000     		.if	CDROM
  138                        		.else
  139                        			; Does this HuCARD support the IFU's ADPCM hardware?
  140                        	
  141               0000     		.if	SUPPORT_ADPCM
  153                        		.endif	SUPPORT_ADPCM
  154                        	
  155    00:E060  40         			rti				; No IRQ2 hardware on HuCARD.
  156                        	
  157    00:E061  6C 00 22   	.hook:		jmp	[irq2_hook]		; 7 cycles.
  158                        		.endif	CDROM
  159                        	
  160                        	
  161                        	
  162                        	; ***************************************************************************
  163                        	; ***************************************************************************
  164                        	;
  165                        	; core_irq1 - Minimal interrupt handler compatible with System Card.
  166                        	;
  167                        	; irq1_handler - Basic "CORE(not TM)" IRQ1 handler to use as the "irq1_hook".
  168                        	;
  169                        	; Doing the IRQ1 handler processing in this hook means that things operate
  170                        	; the same whether the System Card or an Overlay is paged into MPR7.
  171                        	
  172               0000     		.ifndef	HUCC
  181                        		.else
  182                        			; Faster IRQ servicing for HuCC and code that would like to
  183                        			; avoid the 8 cycles used by the "bbs1" instruction that is
  184                        			; taken when the System Card is mapped into MPR7.
  185                        	
  186    00:E064             	core_irq1:	;;;				; 8 (cycles for the INT)
  187               0001     		.if	CDROM || !defined(NO_CORE_IRQ1_HOOK)
  188    00:E064  6C 02 22   			jmp	[irq1_hook]		; 7 cycles.
  189                        	
  190                        		.endif
  191                        		.endif
  192                        	
  193    00:E067  48         	irq1_handler:	pha				; 3 Save all registers.
  194    00:E068  DA         			phx				; 3
  195    00:E069  5A         			phy				; 3
  196                        	
  197               0000     		.ifndef	USING_RCR_MACROS		;   This slows things down
  206                        		.endif	USING_RCR_MACROS
  207                        	
  208    00:E06A  AD 00 02   			lda	VDC_SR			; 6 Acknowledge the VDC's IRQ.
  209    00:E06D  85 F6      			sta	<vdc_sr			; 4 Remember what caused it.
  210                        	
  211               0001     		.if	SUPPORT_SGX
  212    00:E06F  AE 10 02   			ldx	SGX_SR			; 6 Read SGX_SR after VDC_SR in
  213    00:E072  86 06      			stx	<sgx_sr			; 4 case this is not an SGX!
  214                        		.endif
  215                        	
  216                        			; Handle the VDC's RCR interrupt.
  217                        	
  218    00:E074  29 04      	!:		and	#$04			; 2 Is this an HSYNC interrupt?
  219    00:E076  F0 44      			beq	!+			; 2
  220                        	
  221               0001     		.ifdef	USING_RCR_MACROS
  222                        			VDC_RCR_MACRO
                             	
         00:E078  03 06      			st0	#VDC_RCR		; 5
                             	
         00:E07A  AE E4 25   			ldx	vdc_next_region		; 5 X and Y can be greater than
         00:E07D  BC E5 25   			ldy	vdc_regionA_nxt, x	; 5 HUCC_PCE_SPLITS if regionB!
         00:E080  18         			clc				; 2
         00:E081  D0 05      			bne	!set_next_rcr+		; 4 Stop RCR if next line is 0.
                             	
         00:E083  2D 53 E0   			and	const_0000		; 5 A=$00 with the same #cycles
         00:E086  80 05      			bra	!clr_next_rcr+		; 4 as if the branch were taken.
                             	
         00:E088  B9 94 25   	!set_next_rcr:	lda	vdc_regionA_rcr, y	; 5 Set next RCR 1 line before
         00:E08B  69 3F      			adc	#64-1			; 2 the region begins, or 0 to
         00:E08D  8D 02 02   	!clr_next_rcr:	sta	VDC_DL			; 6 disable.
         00:E090  62         			cla				; 2
         00:E091  2A         			rol	a			; 2
         00:E092  8D 03 02   			sta	VDC_DH			; 6
                             	
         00:E095  03 08      			st0	#VDC_BYR		; 5 Do BYR first to mitigate the
         00:E097  BD C4 25   			lda	vdc_regionA_yl, x	; 5 glitch if the IRQ is delayed.
         00:E09A  8D 02 02   			sta	VDC_DL			; 6 = 105 cycles from RCR on SGX
         00:E09D  BD D4 25   			lda	vdc_regionA_yh, x	; 5
         00:E0A0  8D 03 02   			sta	VDC_DH			; 6
                             	
         00:E0A3  03 05      			st0	#VDC_CR			; 5
         00:E0A5  BD 84 25   			lda	vdc_regionA_crl, x	; 5
                             	;		asl	a
         00:E0A8  8D 02 02   			sta	VDC_DL			; 6
                             	
         00:E0AB  03 07      			st0	#VDC_BXR		; 2
         00:E0AD  BD A4 25   			lda	vdc_regionA_xl, x	; 5
         00:E0B0  8D 02 02   			sta	VDC_DL			; 6
         00:E0B3  BD B4 25   			lda	vdc_regionA_xh, x	; 5
         00:E0B6  8D 03 02   			sta	VDC_DH			; 6 = 156 cycles from RCR if DUO
                             	
                             	;		bcc	!+
                             	;		lda	vdc_regionA_yh, x	; 5
                             	;		sta.l	VCE_CTW			; 6
                             	
         00:E0B9  8C E4 25   			sty	vdc_next_region		; 5
                             	
  223                        		.else
  225                        		.endif
  226                        	
  227               0001     		.if	SUPPORT_SGX
  228                        	
  229                        			; Handle the SGX's RCR interrupt.
  230                        	
  231    00:E0BC  2F 06 50   	!:		bbr2	<sgx_sr, !+		; 6 Is this an HSYNC interrupt?
  232                        	
  233               0001     		.ifdef	USING_RCR_MACROS
  234                        			SGX_RCR_MACRO
                             	
         00:E0BF  A9 06      			lda	#VDC_RCR		; 2
         00:E0C1  8D 10 02   			sta	SGX_AR			; 6
                             	
         00:E0C4  AE 65 26   			ldx	sgx_next_region		; 5 X and Y can be greater than
         00:E0C7  BC 66 26   			ldy	sgx_regionA_nxt, x	; 5 HUCC_SGX_SPLITS if regionB!
         00:E0CA  18         			clc				; 2
         00:E0CB  D0 05      			bne	!set_next_rcr+		; 4 Stop RCR if next line is 0.
                             	
         00:E0CD  2D 53 E0   			and	const_0000		; 5 A=$00 with the same #cycles
         00:E0D0  80 05      			bra	!clr_next_rcr+		; 4 as if the branch were taken.
                             	
         00:E0D2  B9 15 26   	!set_next_rcr:	lda	sgx_regionA_rcr, y	; 5 Set next RCR 1 line before
         00:E0D5  69 3F      			adc	#64-1			; 2 the region begins, or 0 to
         00:E0D7  8D 12 02   	!clr_next_rcr:	sta	SGX_DL			; 6 disable.
         00:E0DA  62         			cla				; 2
         00:E0DB  2A         			rol	a			; 2
         00:E0DC  8D 13 02   			sta	SGX_DH			; 6
                             	
         00:E0DF  A9 08      			lda	#VDC_BYR		; 2 Do BYR first to mitigate the
         00:E0E1  8D 10 02   			sta	SGX_AR			; 6 glitch if the IRQ is delayed.
         00:E0E4  BD 45 26   			lda	sgx_regionA_yl, x	; 5
         00:E0E7  8D 12 02   			sta	SGX_DL			; 6
         00:E0EA  BD 55 26   			lda	sgx_regionA_yh, x	; 5
         00:E0ED  8D 13 02   			sta	SGX_DH			; 6
                             	
         00:E0F0  A9 05      			lda	#VDC_CR			; 2
         00:E0F2  8D 10 02   			sta	SGX_AR			; 6
         00:E0F5  BD 05 26   			lda	sgx_regionA_crl, x	; 5
         00:E0F8  8D 12 02   			sta	SGX_DL			; 6
                             	
         00:E0FB  A9 07      			lda	#VDC_BXR		; 2
         00:E0FD  8D 10 02   			sta	SGX_AR			; 6
         00:E100  BD 25 26   			lda	sgx_regionA_xl, x	; 5
         00:E103  8D 12 02   			sta	SGX_DL			; 6
         00:E106  BD 35 26   			lda	sgx_regionA_xh, x	; 5
         00:E109  8D 13 02   			sta	SGX_DH			; 6 = 293 cycles (282 if no YH)
                             	
         00:E10C  8C 65 26   			sty	sgx_next_region		; 5
                             	
  235                        		.else
  237                        		.endif
  238                        	
  239                        		.endif	SUPPORT_SGX
  240                        	
  241                        			; Handle the VDC's VBL interrupt.
  242                        	
  243    00:E10F  5F F6 32   	!:		bbr5	<vdc_sr, .exit_irq1	; 6 Is this a VBLANK interrupt?
  244                        	
  245               0001     		.ifdef	USING_RCR_MACROS		;   If we didn't do it earlier
  246               0000     		.if	CDROM				;   then we need to do it now.
  253                        		.endif	CDROM
  254                        		.endif	USING_RCR_MACROS
  255                        	
  256               0001     		.if	SUPPORT_SGX
  257    00:E112  A9 05      			lda	#VDC_CR			; Update the SGX's Control
  258    00:E114  8D 10 02   			sta	SGX_AR			; Register first, just in
  259    00:E117  8D 00 02   			sta	VDC_AR			; case this is not an SGX!
  260    00:E11A  A5 03      			lda	<sgx_crl		
  261    00:E11C  8D 12 02   			sta	SGX_DL
  262    00:E11F  A5 F3      			lda	<vdc_crl
  263    00:E121  8D 02 02   			sta	VDC_DL
  264                        	
  265                        	;		lda	<sgx_crh		; Do not mess with the SGX's
  266                        	;		sta	SGX_DH			; auto-increment!!!
  267                        	;		lda	<vdc_crh		; Do not mess with the VDC's
  268                        	;		sta	VDC_DH			; auto-increment!!!
  269                        		.else
  277                        		.endif	SUPPORT_SGX
  278                        	
  279    00:E124  EE 41 22   			inc	irq_cnt			; Mark that a VBLANK occurred.
  280                        	
  281    00:E127  4F F5 02   			bbr4	<irq_vec, .skip_hookv	; Is a driver registered?
  282                        	
  283    00:E12A  44 26      			bsr	.user_vsync		; Call game's VBLANK code.
  284                        	
  285    00:E12C  DF F5 15   	.skip_hookv:	bbs5	<irq_vec, .exit_vbl	; Should we skip "BIOS" stuff?
  286                        	
  287    00:E12F  58         			cli				; Allow HSYNC and TIMER IRQ.
  288                        	
  289    00:E130  20 DB FF   			call	read_joypads		; Update joypad state.
  290                        	
  291               0000     		.if	USING_PSGDRIVER
  305                        		.else
  306    00:E133  AD 07 22   			lda	sound_hook + 1		; Is a driver registered?
  307    00:E136  F0 0C      			beq	.exit_vbl
  308                        	
  309    00:E138  A9 80      			lda	#$80			; Acquire sound mutex to avoid
  310    00:E13A  0C E7 22   			tsb	sound_mutex		; conflict with a delayed VBL.
  311    00:E13D  30 05      			bmi	.exit_vbl
  312                        	
  313    00:E13F  44 14      			bsr	.user_sound		; Call the driver hook.
  314                        	
  315    00:E141  9C E7 22   			stz	sound_mutex		; Release sound mutex.
  316                        		.endif	USING_PSGDRIVER
  317                        	
  318    00:E144             	.exit_vbl:
  319                        	
  320               0001     		.ifdef	USING_RCR_MACROS		; If USING_RCR_MACROS then 
  321               0000     		.if	CDROM				; restore after the VBLANK.
  326                        		.endif	CDROM
  327                        		.endif	USING_RCR_MACROS
  328                        	
  329    00:E144             	.exit_irq1:
  330                        	
  331               0000     		.ifndef	USING_RCR_MACROS		; If !USING_RCR_MACROS then
  338                        		.endif	USING_RCR_MACROS
  339                        	
  340               0001     		.if	SUPPORT_SGX
  341    00:E144  A5 07      			lda	<sgx_reg		; Restore SGX_AR first, just
  342    00:E146  8D 10 02   			sta	SGX_AR			; in case this is not an SGX!
  343                        		.endif
  344                        	
  345    00:E149  A5 F7      			lda	<vdc_reg		; Restore VDC_AR in case we
  346    00:E14B  8D 00 02   			sta	VDC_AR			; changed it.
  347                        	
  348    00:E14E  7A         			ply				; Restore all registers.
  349    00:E14F  FA         			plx
  350    00:E150  68         			pla
  351                        	
  352    00:E151  40         			rti				; Return from interrupt.
  353                        	
  354    00:E152  6C 08 22   	.user_vsync:	jmp	[vsync_hook]		; 7
  355    00:E155  6C 06 22   	.user_sound:	jmp	[sound_hook]		; 7
  356                        	
  357               0000     		.ifndef	USING_RCR_MACROS
  362                        		.endif	USING_RCR_MACROS
  363                        	
  364                        	
  365                        	
  366                        	; ***************************************************************************
  367                        	; ***************************************************************************
  368                        	;
  369                        	; core_timer - Minimal interrupt handler compatible with System Card.
  370                        	;
  371                        	; tirq_handler - Basic "CORE(not TM)" TIRQ handler to use as the "timer_hook".
  372                        	;
  373                        	; Doing the TIRQ handler processing in this hook means that things operate
  374                        	; the same whether the System Card or an Overlay is paged into MPR7.
  375                        	
  376               0000     		.ifndef	HUCC
  385                        		.else
  386                        			; Faster IRQ servicing for HuCC and code that would like to
  387                        			; avoid the 8 cycles used by the "bbs2" instruction that is
  388                        			; taken when the System Card is mapped into MPR7.
  389                        	
  390    00:E158             	core_timer:	;;;				; 8 (cycles for the INT)
  391               0001     		.if	CDROM || !defined(NO_CORE_TIRQ_HOOK)
  392    00:E158  6C 04 22   			jmp	[timer_hook]		; 7 cycles.
  393                        		.endif
  394                        		.endif
  395                        	
  396    00:E15B             	tirq_handler:
  397               0000     		.ifdef	USING_TIRQ_MACRO
  399                        		.else
  400    00:E15B  9C 03 14   			stz	IRQ_ACK			; 5 Clear timer interrupt.
  401                        		.endif
  402                        	
  403    00:E15E  40         	core_rti:	rti
  404                        	
  405                        	
  406                        	
  407                        	; ***************************************************************************
  408                        	; ***************************************************************************
  409                        	;
  410                        	; core_clr_hooks - Reset default "CORE(not TM)" interrupt-handling hooks.
  411                        	;
  412                        	
  413    00:E15F  08         	core_clr_hooks:	php				; Preserve interrupt state.
  414    00:E160  78         			sei				; Disable interrupts.
  415                        	
  416               0000     		.if	USING_PSGDRIVER
  419                        		.else
  420    00:E161  9C 07 22   			stz.h	sound_hook		; Disable sound driver calls.
  421                        		.endif
  422                        	
  423    00:E164  A9 88      			lda	#<core_sw_reset		; Set up the soft-reset hook.
  424    00:E166  8D 84 22   			sta.l	reset_hook
  425    00:E169  A9 E1      			lda	#>core_sw_reset
  426    00:E16B  8D 85 22   			sta.h	reset_hook
  427                        	
  428    00:E16E  A9 67      			lda	#<irq1_handler		; Set up the IRQ1 hook.
  429    00:E170  8D 02 22   			sta.l	irq1_hook
  430    00:E173  A9 E0      			lda	#>irq1_handler
  431    00:E175  8D 03 22   			sta.h	irq1_hook
  432                        	
  433    00:E178  A9 5B      			lda	#<tirq_handler		; Set up the TIRQ hook.
  434    00:E17A  8D 04 22   			sta.l	timer_hook
  435    00:E17D  A9 E1      			lda	#>tirq_handler
  436    00:E17F  8D 05 22   			sta.h	timer_hook
  437                        	
  438    00:E182  A9 06      			lda	#%00000110		; Replace the System Card's
  439    00:E184  85 F5      			sta	<irq_vec		; IRQ1 and TIRQ processing.
  440                        	
  441    00:E186  28         			plp				; Restore interrupt state.
  442    00:E187  60         			rts
  443                        	
  444                        	
  445                        	
  446                        	; ***************************************************************************
  447                        	; ***************************************************************************
  448                        	;
  449                        	; Include the joypad library, with configuration from "core-config.inc".
  450                        	;
  451                        	
                             #[6]   "..\..\..\include\hucc\joypad.asm"
  452                        			include "joypad.asm"
    1                        	; ***************************************************************************
    2                        	; ***************************************************************************
    3                        	;
    4                        	; joypad.asm
    5                        	;
    6                        	; Read 2-button & 6-button joypads & PCE mouse, with or without a MultiTap.
    7                        	;
    8                        	; Copyright John Brandwood 2019-2025.
    9                        	;
   10                        	; Distributed under the Boost Software License, Version 1.0.
   11                        	; (See accompanying file LICENSE_1_0.txt or copy at
   12                        	;  http://www.boost.org/LICENSE_1_0.txt)
   13                        	;
   14                        	; ***************************************************************************
   15                        	; ***************************************************************************
   16                        	;
   17                        	; Unlike Lemmings, this code does not interfere with a Memory Base 128! ;-)
   18                        	;
   19                        	; ***************************************************************************
   20                        	; ***************************************************************************
   21                        	;
   22                        	; With SUPPORT_MOUSE ..... 2602 cycles to read 5 ports with 5 mice
   23                        	;
   24                        	; With HuC library code .. 2442 cycles to read 5 ports with 5 pads (2-button)
   25                        	; With HuC library code .. 2442 cycles to read 5 ports with 5 pads (6-button)
   26                        	;
   27                        	; With SUPPORT_MOUSE ....  2016 cycles to read 5 ports with 5 pads (2-button)
   28                        	; With SUPPORT_MOUSE ..... 1976 cycles to read 5 ports with 5 pads (6-button)
   29                        	;
   30                        	; With SUPPORT_MOUSE ....  1618 cycles to read 3 ports with 3 mice
   31                        	; With SUPPORT_MOUSE ..... 1462 cycles to read 3 ports with 2 mice
   32                        	; With SUPPORT_MOUSE ..... 1306 cycles to read 3 ports with 1 mouse
   33                        	;
   34                        	; With SUPPORT_6BUTTON ... 1235 cycles to read 5 ports with 5 pads (2-button)
   35                        	; With SUPPORT_6BUTTON ... 1215 cycles to read 5 ports with 5 pads (6-button)
   36                        	;
   37                        	; With SUPPORT_MOUSE ..... 1126 cycles to read 2 ports with 2 mice
   38                        	; With SUPPORT_MOUSE ...... 970 cycles to read 2 ports with 1 mouse
   39                        	;
   40                        	; Only SUPPORT_2BUTTON .... 971 cycles to read 5 ports with 5 pads (2-button)
   41                        	; Only SUPPORT_2BUTTON .... 861 cycles to read 5 ports with 5 pads (6-button)
   42                        	;
   43                        	; With SUPPORT_MOUSE ...... 634 cycles to read 1 port  with 1 mouse
   44                        	;
   45                        	; ***************************************************************************
   46                        	; ***************************************************************************
   47                        	
  142                        	
  143                        	;
  144                        	; Now choose which version of the code to include.
  145                        	;
  146                        	
  147               0000     		.if	SUPPORT_2BUTTON
  278                        		.endif	SUPPORT_2BUTTON
  279                        	
  280                        	
  281                        	
  282               0000     		.if	SUPPORT_MOUSE
  845                        		.else	SUPPORT_MOUSE
  846                        	
  847                        	
  848                        	
  849               0001     		.if	SUPPORT_6BUTTON			; Without mouse!
  850                        	
  851                        	; ***************************************************************************
  852                        	; ***************************************************************************
  853                        	;
  854                        	; read_joypads - full 6-button pad support, but mouse movement is ignored.
  855                        	;
  856                        	; This code distinguishes between a mouse and a 2-button or 6-button joypad,
  857                        	; so that unsupported devices do not have to be unplugged from the MultiTap.
  858                        	;
  859                        	; The code loops two times to get both sets of buttons on a 6-button joypad.
  860                        	;
  861                        	; N.B. Takes approx 1/3 frame to detect mice the first time it is run.
  862                        	;
  863                        	; bit values for joypad 2-button bytes: (MSB = #7; LSB = #0)
  864                        	; ----------------------------------------------------------
  865                        	; bit 0 (ie $01) = I
  866                        	; bit 1 (ie $02) = II
  867                        	; bit 2 (ie $04) = SELECT
  868                        	; bit 3 (ie $08) = RUN
  869                        	; bit 4 (ie $10) = UP
  870                        	; bit 5 (ie $20) = RIGHT
  871                        	; bit 6 (ie $40) = DOWN
  872                        	; bit 7 (ie $80) = LEFT
  873                        	;
  874                        	; bit values for joypad 6-button bytes: (MSB = #7; LSB = #0)
  875                        	; ----------------------------------------------------------
  876                        	; bit 0 (ie $01) = III
  877                        	; bit 1 (ie $02) = IV
  878                        	; bit 2 (ie $04) = V
  879                        	; bit 3 (ie $08) = VI
  880                        	; bit 4 (ie $10) = zero
  881                        	; bit 5 (ie $20) = zero
  882                        	; bit 6 (ie $40) = zero
  883                        	; bit 7 (ie $80) = zero, but set to one if 6-button pad detected.
  884                        	;
  885                        	
  886               E188     			.code
  887                        	
  888               0001     		.if	(* >= $4000)			; Make this a ".proc" if it
  889    01:D756             	read_joypads	.proc                           ; not running in RAM.
  890                        		.else
  892                        		.endif
  893                        	
  894    01:D756  A9 80      			lda	#$80			; Acquire port mutex to avoid
  895    01:D758  0C D0 22   			tsb	port_mutex		; conflict with a delayed VBL
  896    01:D75B  30 75      			bmi	.exit			; or access to an MB128.
  897                        	
  898    01:D75D  73 28 22 32			tii	joynow,joyold,MAX_PADS	; Save the previous values.
         01:D761  22 05 00    
  899    01:D764  73 D3 22 D8			tii	joy6now,joy6old,MAX_PADS
         01:D768  22 05 00    
  900                        	
  901                        			; Reset the 6-btn bits, the user might change the joypad mode!
  902                        	
  903    01:D76B  F3 53 E0 D3			tai	const_0000, joy6now, MAX_PADS
         01:D76F  22 05 00    
  904                        	
  905                        			; Detect attached mice the first time this routine is called.
  906                        	
  907    01:D772  AD D2 22   			lda	mouse_flg		; Has mouse detection happened?
  908    01:D775  30 28      			bmi	.calc_pressed
  909                        	
  910    01:D777  A9 05      			lda	#MAX_PADS		; Reset number of pads to read.
  911    01:D779  8D D1 22   			sta	num_ports
  912                        	
  913    01:D77C  A9 1F      			lda	#%00011111		; Try reading everything as a
  914    01:D77E  8D D2 22   			sta	mouse_flg		; mouse.
  915                        	
  916    01:D781  A0 17      			ldy	#23			; Initialize repeat count.
  917    01:D783  A9 80      			lda	#$80			; Initialize mouse detection.
  918    01:D785  5A         	.detect_loop:	phy
  919    01:D786  48         			pha
  920    01:D787  44 53      			bsr	.read_devices		; Read all devices as if mice.
  921    01:D789  68         			pla
  922    01:D78A  82         			clx
  923    01:D78B  BC E2 22   	.detect_port:	ldy	mouse_x, x		; A movement of zero means
  924    01:D78E  D0 03      			bne	.detect_next		; this port is a mouse.
  925    01:D790  1D 55 E0   			ora	bit_mask, x
  926    01:D793  E8         	.detect_next:	inx				; Get the next pad from the
  927    01:D794  E0 05      			cpx	#MAX_PADS		; multitap.
  928    01:D796  D0 F3      			bne	.detect_port
  929    01:D798  7A         			ply				; Repeat the detection test.
  930    01:D799  88         			dey
  931    01:D79A  D0 E9      			bne	.detect_loop
  932                        	
  933                        	;	.if	DETECT_PHANTOMS
  934                        	;		cmp	#(1 << MAX_PADS) + 127	; If we find a mouse in every
  935                        	;		bne	.detect_done		; port, then assume mirrored!
  936                        	;		lda	#1			; Report a single mouse in a
  937                        	;		sta	num_ports		; single port.
  938                        	;		lda	#$81
  939                        	;	.endif
  940                        	
  941    01:D79C  8D D2 22   	.detect_done:	sta	mouse_flg		; Report mouse detection.
  942                        	
  943                        			; See what has just been pressed, and check for soft-reset.
  944                        	
  945    01:D79F  44 3B      	.calc_pressed:	bsr	.read_devices		; Read all devices normally.
  946                        	
  947    01:D7A1  A2 04      			ldx	#MAX_PADS - 1
  948                        	
  949    01:D7A3  BD D3 22   	.pressed_loop:	lda	joy6now, x		; Calc which buttons have just
  950    01:D7A6  5D D8 22   			eor	joy6old, x		; been pressed (6-button).
  951    01:D7A9  3D D3 22   			and	joy6now, x
  952               0000     		.if	HUC_JOY_EVENTS
  956                        		.else
  957               0000     		.if	ACCUMULATE_JOY
  959                        		.endif
  960    01:D7AC  9D DD 22   			sta	joy6trg, x
  961                        		.endif
  962                        	
  963    01:D7AF  BD 28 22   			lda	joynow, x		; Calc which buttons have just
  964    01:D7B2  A8         			tay                             ; been pressed (2-button).
  965    01:D7B3  5D 32 22   			eor	joyold, x
  966    01:D7B6  3D 28 22   			and	joynow, x
  967               0000     		.if	HUC_JOY_EVENTS
  971                        		.else
  972               0000     		.if	ACCUMULATE_JOY
  974                        		.endif
  975    01:D7B9  9D 2D 22   			sta	joytrg, x
  976                        		.endif
  977                        	
  978    01:D7BC  C9 04      			cmp	#$04			; Detect the soft-reset combo,
  979    01:D7BE  D0 0C      			bne	.not_reset		; hold RUN then press SELECT.
  980    01:D7C0  C0 0C      			cpy	#$0C
  981    01:D7C2  D0 08      			bne	.not_reset
  982    01:D7C4  BD 55 E0   			lda	bit_mask, x
  983    01:D7C7  2C 27 22   			bit	joyena
  984    01:D7CA  D0 09      			bne	.soft_reset
  985                        	
  986    01:D7CC  CA         	.not_reset:	dex				; Check the next pad from the
  987    01:D7CD  10 D4      			bpl	.pressed_loop		; multitap.
  988                        	
  989    01:D7CF  9C D0 22   			stz	port_mutex		; Release port mutex.
  990                        	
  991               0001     		.if	(* >= $4000)			; This is a ".proc" if it is
  992                        	.exit:		leave                           ; not running in RAM.
         01:D7D2  4C EF FF   			jmp	leave_proc
  993                        		.else
  995                        		.endif
  996                        	
  997    01:D7D5  78         	.soft_reset:	sei				; Disable interrupts.
  998    01:D7D6  9C D0 22   			stz	port_mutex		; Release port mutex.
  999    01:D7D9  6C 84 22   			jmp	[reset_hook]		; Jump to the soft-reset hook.
 1000                        	
 1001                        			; Read all of the devices attached to the MultiTap.
 1002                        	
 1003    01:D7DC  A2 02      	.read_devices:	ldx	#2			; Repeat this loop 2 times.
 1004                        	
 1005    01:D7DE  A9 01      	.read_multitap:	lda	#$01			; CLR lo, SEL hi for d-pad.
 1006    01:D7E0  8D 00 10   			sta	IO_PORT
 1007    01:D7E3  A9 03      			lda	#$03			; CLR hi, SEL hi, reset tap.
 1008    01:D7E5  8D 00 10   			sta	IO_PORT
 1009    01:D7E8  C2         			cly				; Start at port 1.
 1010                        	
 1011    01:D7E9  A9 01      	.read_port:	lda	#$01			; CLR lo, SEL hi for d-pad.
 1012    01:D7EB  8D 00 10   			sta	IO_PORT			; Wait 1.25us (9 cycles).
 1013                        	
 1014    01:D7EE  B9 55 E0   			lda	bit_mask, y		; Is there a mouse attached?
 1015    01:D7F1  2D D2 22   			and	mouse_flg
 1016    01:D7F4  D0 33      			bne	.read_mouse
 1017                        	
 1018    01:D7F6  AD 00 10   	.read_pad:	lda	IO_PORT			; Read direction-pad bits.
 1019    01:D7F9  9C 00 10   			stz	IO_PORT			; CLR lo, SEL lo for buttons.
 1020    01:D7FC  0A         			asl	a			; Wait 1.25us (9 cycles).
 1021    01:D7FD  0A         			asl	a
 1022    01:D7FE  0A         			asl	a
 1023    01:D7FF  0A         			asl	a
 1024    01:D800  F0 1B      			beq	.read_6button		; 6-btn pad if UDLR all held.
 1025                        	
 1026    01:D802  99 28 22   	.read_2button:	sta	joynow, y		; Get buttons of 2-btn pad.
 1027    01:D805  AD 00 10   			lda	IO_PORT
 1028    01:D808  29 0F      			and	#$0F
 1029    01:D80A  19 28 22   			ora	joynow, y
 1030    01:D80D  49 FF      			eor	#$FF
 1031    01:D80F  99 28 22   			sta	joynow, y
 1032                        	
 1033    01:D812  C8         	.next_port:	iny				; Get the next pad from the
 1034    01:D813  CC D1 22   			cpy	num_ports		; multitap.
 1035    01:D816  90 D1      			bcc	.read_port
 1036                        	
 1037    01:D818  CA         			dex				; Do the next complete pass.
 1038    01:D819  CA         			dex
 1039    01:D81A  10 C2      			bpl	.read_multitap		; Have we finished 2 passes?
 1040    01:D81C  60         			rts				; Now that everything is read.
 1041                        	
 1042    01:D81D  AD 00 10   	.read_6button:	lda	IO_PORT			; Get buttons of 6-btn pad.
 1043    01:D820  29 0F      			and	#$0F
 1044    01:D822  49 8F      			eor	#$8F			; Set bit-7 to show that a
 1045    01:D824  99 D3 22   			sta	joy6now, y		; 6-button pad is present.
 1046    01:D827  80 E9      			bra	.next_port
 1047                        	
 1048    01:D829  7C 5A D8   	.read_mouse:	jmp	[.mouse_vectors, x]	; Which mouse info is next?
 1049                        	
 1050                        			; Mouse processing, normally four passes, here just two.
 1051                        	
 1052    01:D82C  A9 1C      	.mouse_x_hi:	lda	#28			; 189 cycle delay after CLR lo
 1053    01:D82E  3A         	.wait_loop:	dec	a			; on port to allow the mouse
 1054    01:D82F  D0 FD      			bne	.wait_loop		; to buffer and reset counters.
 1055                        	
 1056    01:D831  AD 00 10   			lda	IO_PORT			; Read direction-pad bits.
 1057    01:D834  9C 00 10   			stz	IO_PORT			; CLR lo, SEL lo for buttons.
 1058    01:D837  0A         			asl	a			; Wait 1.25us (9 cycles).
 1059    01:D838  0A         			asl	a
 1060    01:D839  0A         			asl	a
 1061    01:D83A  0A         			asl	a
 1062    01:D83B  99 E2 22   			sta	mouse_x, y		; Save port's X-hi nibble.
 1063                        	
 1064    01:D83E  AD 00 10   			lda	IO_PORT			; Get mouse buttons.
 1065    01:D841  29 0F      			and	#$0F
 1066    01:D843  49 0F      			eor	#$0F
 1067    01:D845  99 28 22   			sta	joynow, y
 1068    01:D848  80 C8      			bra	.next_port
 1069                        	
 1070    01:D84A  AD 00 10   	.mouse_x_lo:	lda	IO_PORT			; Read direction-pad bits.
 1071    01:D84D  9C 00 10   			stz	IO_PORT			; CLR lo, SEL lo for buttons.
 1072    01:D850  29 0F      			and	#$0F			; Wait 1.25us (9 cycles).
 1073    01:D852  19 E2 22   			ora	mouse_x, y		; Add port's X-hi nibble.
 1074                        	;		eor	#$FF			; Negate so LEFT is -ve.
 1075                        	;		inc	a
 1076    01:D855  99 E2 22   			sta	mouse_x, y
 1077    01:D858  80 B8      			bra	.next_port
 1078                        	
 1079    01:D85A  4A D8      	.mouse_vectors: dw	.mouse_x_lo		; Pass 2
 1080    01:D85C  2C D8      			dw	.mouse_x_hi		; Pass 1
 1081                        	
 1082               0001     		.if	(* >= $4000)			; This is a ".proc" if it is
 1083                        			.endp                           ; not running in RAM.
 1084               22D0     			.bss				; Put the variables in RAM.
 1085                        		.endif
 1086                        	
 1087    F8:22D0             	port_mutex:	ds	1			; NZ when controller port busy.
 1088    F8:22D1             	num_ports:	ds	1			; Set to 1 if no multitap.
 1089    F8:22D2             	mouse_flg:	ds	1			; Which ports are mice?
 1090               0000     		.if	HUC_JOY_EVENTS
 1093                        		.endif
 1094    F8:22D3             	joy6now:	ds	MAX_PADS
 1095    F8:22D8             	joy6old:	ds	MAX_PADS
 1096    F8:22DD             	joy6trg:	ds	MAX_PADS
 1097    F8:22E2             	mouse_x:	ds	MAX_PADS
 1098                        	
 1099               E188     			.code
 1100                        	
 1101                        		.endif	SUPPORT_6BUTTON			; Without mouse!
 1102                        	
 1103                        		.endif	SUPPORT_MOUSE
                             #[5]   "..\..\..\include\hucc\core-kernel.asm"
  453                        	
  454                        	
  455                        	
  456               0001     		.if	!CDROM
  457                        	
  458                        	; ***************************************************************************
  459                        	; ***************************************************************************
  460                        	;
  461                        	; core_sw_reset - Default HuCARD handler for a joypad "soft-reset".
  462                        	;
  463                        	
  464    00:E188  78         	core_sw_reset:	sei				; Disable interrupts.
  465                        	
  466    00:E189  6C FE FF   			jmp	[$FFFE]			; Jump to the HuCARD reset.
  467                        	
  468                        	
  469                        	
  470                        		.else	!CDROM
  616                        		.endif	!CDROM
  617                        	
  618                        	
  619                        	
  620                        	; ***************************************************************************
  621                        	; ***************************************************************************
  622                        	
  623               0001     		.if	(core_kernel >= $4000)		; If not running in RAM, then
  624               22E7     			.bss				; put these variables in RAM.
  625                        		.endif
  626                        	
  627    F8:22E7             	sound_mutex:	ds	1			; NZ when controller port busy.
  628                        	
  629               0001     		.if	SUPPORT_SGX
  630    F8:22E8             	sgx_detected:	ds	1			; NZ if SuperGrafx detected.
  631    F8:22E9             	hsync_hook_sgx:	ds	2			; SGX version of hsync_hook.
  632                        		.endif
  633                        	
  634               0000     		.if	SUPPORT_ACD
  636                        		.endif
  637                        	
  638               0001     		.if	(core_kernel >= $4000)
  639               E18C     			.code
  640                        		.endif
                             #[4]   "..\..\..\include\hucc\core-startup.asm"
  427                        	
  428                        	
  429                        	
  430                        		.else	!CDROM
  524                        		.endif	!CDROM
  525                        	
  526                        	
  527                        	
  528                        	; ***************************************************************************
  529                        	; ***************************************************************************
  530                        	;
  531                        	; With the availability of so many different configuration options, we've now
  532                        	; built somewhere between a few hundred bytes, and a couple of KB, of code in
  533                        	; the CORE_BANK of the HuCARD / overlay program.
  534                        	;
  535                        	; This is the end of the "CORE(not TM)" library code!
  536                        	;
  537                        	; Remember that the ".proc" trampolines are located at the end of this bank,
  538                        	; so the amount of free space left depends upon the number of ".proc" calls.
  539                        	;
  540                        	
  541                        			; Switch to CORE_PAGE to run the developer's game code.
  542               E18C     			.page	CORE_PAGE
  543                        	
  544                        	
  545                        	
  546                        	; ***************************************************************************
  547                        	; ***************************************************************************
  548                        	;
  549                        	; The DATA_BANK location needs to be set as early as possible so that library
  550                        	; code is able to put data in there before the total overall size of the code
  551                        	; is known.
  552                        	;
  553                        	; By default, DATA_BANK is the next bank after the CORE_BANK.
  554                        	;
  555                        	; RESERVE_BANKS allows developers to reserve some banks between the CORE_BANK
  556                        	; and the DATA_BANK that they can use however they wish.
  557                        	;
  558                        	; One use for RESERVE_BANKS is to create empty space that PCEAS can use when
  559                        	; it relocates procedures. This provides a way for a developer to group code
  560                        	; together at the start of memory, and leave the maximum number of banks for
  561                        	; loading dynamic data from CD-ROM.
  562                        	;
  563                        	; The KickC environment sets RESERVE_BANKS=1 (or higher) so that there is a
  564                        	; a bank for the permanent C code and static constants.
  565                        	;
  566                        	; RESERVE_BANKS is normally defined in each project's "core-config.inc".
  567                        	;
  568                        	
  569                        			.opt	d+			; DATA labels use fixed MPR.
  570                        	
  571               0001     			.rsset	CORE_BANK + 1
  572                        	
  573               0000     		.ifdef	NEED_HOME_BANK
  580                        		.endif
  581                        	
  582               0001     		.ifdef	NEED_SOUND_BANK			; Defined in hucc-sound.inc
  583               0000     		.if	NEED_SOUND_BANK			; if the driver wants a bank.
  585                        		.endif
  586                        		.endif
  587                        	
  588               0001     		.ifdef	RESERVE_BANKS			; For CORE projects.
  589               0001     	RESERVED_BANK	.rs	RESERVE_BANKS
  590                        		.endif
  591                        	
  592               0001     		.ifdef	HUCC
  593               0001     		.ifdef	HUC_RESERVE_BANKS		; For HuCC projects.
  594               0001     	HUC_USER_BANK	.rs	HUC_RESERVE_BANKS
  595                        		.endif
  596                        	
  597               0001     	CONST_BANK	.rs	2
  598               6000     			.rodata
  599               0001     			.bank	CONST_BANK, ".rodata"
  600                        		.endif	HUCC
  601                        	
  602               0003     	DATA_BANK	.rs	0
  603               6000     			.data
  604               0000     		.if	BUILDING_STAGE1
  606                        		.else
  607               0003     			.bank	DATA_BANK, ".data"
  608                        		.endif
  609               6000     			.org	$6000
  610                        	
  611               E18C     			.code
                             #[3]   "..\..\..\include\hucc\core.inc"
                             #[2]   "..\..\..\include\hucc\hucc.asm"
  120                        		.else
  126                        		.endif
  127                        	
  128                        			; Allocate this as early as possible to ensure bank-aligned
  129                        			; so that there is no wasted space for aligning the table.
  130                        	
  131               0000     		.if	FAST_MULTIPLY
  138                        		.endif
  139                        	
  140                        			;
  141                        	
  144                        	
  145                        			; The hardware stack is used for expressions.
  146                        	
  147               00FF     	__tos		=	$F8:2101, 255
  148                        	
  149               2008     			.zp
  150               2008     			.align	2
  151    F8:2008             	__stack:	ds	HUCC_STACK_SZ
  152                        	
  153    F8:2088             	__ptr:		ds	2
  154    F8:208A             	__fptr:		ds	2
  155    F8:208C             	__fbank:	ds	1
  156    F8:208D             	__sp:		ds	1
  157                        	
  158                        			; REGTEMP 6-byte stack for temporaries used by SDCC.
  159                        			; Keep the size in sync with NUM_TEMP_REGS in sdcc/src/mos6502/gen.h!
  160                        	
  161    F8:208E             	REGTEMP:	ds	6
  162                        	
  163                        			; HuCC's non-recursive consecutive varargs for printf().
  164                        	
  165               2008     	__vararg1	=	__stack + 0
  166               200A     	__vararg2	=	__stack + 2
  167               200C     	__vararg3	=	__stack + 4
  168               200E     	__vararg4	=	__stack + 6
  169                        	
  170                        			; Pointer used by poke() because __ptr could be overwritten.
  171                        	
  172               20EE     	__poke		=	__si
  173                        	
  174                        			; Used for indirect calls because __ptr could be overwritten.
  175                        	
  176               20EE     	__func		=	__si
  177                        	
  178                        			; Data pointer used by SDCC for indirect indexed memory access.
  179                        	
  180               2088     	DPTR		=	__ptr
  181                        	
  182                        			; Values returned from SDCC functions that don't fit into XA.
  183                        			; These are also used as workspace for SDCC library functions,
  184                        			; including HuCC's multiplication and division functions.
  185                        	
  186    F8:2094             	___SDCC_m6502_ret0:	ds	1
  187    F8:2095             	___SDCC_m6502_ret1:	ds	1
  188    F8:2096             	___SDCC_m6502_ret2:	ds	1
  189    F8:2097             	___SDCC_m6502_ret3:	ds	1
  190                        	
  191               0000     		.if	0
  196                        		.endif
  197                        	
  198                        			; Permanent pointers for fast table-of-squares multiplication.
  199                        	
  200               0000     		.if	FAST_MULTIPLY
  205                        		.endif
  206                        	
  207                        			; HuCC keeps a realtime clock, updated in hucc_vbl.
  208                        			;
  209                        			; Defining this here means that it will go before any HuCC
  210                        			; variables in "globals.h", and so it won't get cleared in
  211                        			; a CDROM game when loading different overlays.
  212                        	
  213               22EB     			.bss
  214    F8:22EB             	old_cnt:	ds	1			; irq_cnt of previous vsync().
  215    F8:22EC             	clock_hh:	ds	1			; System Clock, hours	(0-11)
  216    F8:22ED             	clock_mm:	ds	1			; System Clock, minutes (0-59)
  217    F8:22EE             	clock_ss:	ds	1			; System Clock, seconds (0-59)
  218    F8:22EF             	clock_tt:	ds	1			; System Clock, ticks	(0-59)
  219               E18C     			.code
  220                        	
  221                        			; Critical HuCC libraries that the compiler depends upon.
  222                        			;
  223                        			; These include various macros that must be defined before
  224                        			; they are encountered in any compiler-generated code.
  225                        	
                             #[3]   "..\..\..\include\hucc\hucc-codegen.asm"
  226                        			include "hucc-codegen.asm"	; HuCC i-code macros and funcs.
    1                        	; ***************************************************************************
    2                        	; ***************************************************************************
    3                        	;
    4                        	; hucc-codegen.asm
    5                        	;
    6                        	; The HuCC compiler translates C code into these macros, it does not directly
    7                        	; generate HuC6280 instructions.
    8                        	;
    9                        	; Based on the original HuC macros created by David Michel and the other HuC
   10                        	; developers, later modified and improved by Ulrich Hecht.
   11                        	;
   12                        	; Modifications copyright John Brandwood 2024.
   13                        	;
   14                        	; Distributed under the Boost Software License, Version 1.0.
   15                        	; (See accompanying file LICENSE_1_0.txt or copy at
   16                        	;  http://www.boost.org/LICENSE_1_0.txt)
   17                        	;
   18                        	; ***************************************************************************
   19                        	; ***************************************************************************
   20                        	;
   21                        	; NAMING SCHEME FOR HuCC MACROS ...
   22                        	;
   23                        	;   __function.parameters
   24                        	;
   25                        	; {parameters} is a list of alphanumeric specifiers, starting with {size} and
   26                        	; followed by {where}, followed by {index} if an array, then optional {value}
   27                        	; and finally ending with optional {suffix}
   28                        	;
   29                        	; {size}
   30                        	;   w : 16-bit signed int (default "int" in HuCC)
   31                        	;   c : 16-bit unsigned int (a "cardinal" in Pascal terms)
   32                        	;   b :  8-bit signed char
   33                        	;   u :  8-bit unsigned char (default "char" in HuCC)
   34                        	;
   35                        	; {where} or {index}
   36                        	;   r : HuCC primary register, made up of the Y:A cpu registers
   37                        	;   t : top of expression stack
   38                        	;   p : indirect pointer, usually [__ptr]
   39                        	;   f : structure field (member) offset value
   40                        	;   i : immediate value, i.e. a decimal number
   41                        	;   m : memory, i.e. C global, static, and "-fno-recursive" variables
   42                        	;   s : stack, i.e. C function parameters and locals (not "-fno-recursive")
   43                        	;   a : array, i.e. C global, static, "-fno-recursive" arrays <= 256 bytes
   44                        	;   x : array index already in the X register
   45                        	;   y : array index already in the Y register
   46                        	;
   47                        	; {value} OPTIONAL
   48                        	;   i : immediate value, i.e. a decimal number
   49                        	;   z : zero value
   50                        	;
   51                        	; {suffix} OPTIONAL
   52                        	;   q : quick, used for optimized math on only 8-bit values, because all math
   53                        	;       is normally promoted to "int" size in C; and when optimized stores do
   54                        	;       not need to preserve the primary register contents
   55                        	;
   56                        	; ***************************************************************************
   57                        	; ***************************************************************************
   58                        	
   59                        	
   60                        	
 8399                        	
 8400                        	; ***************************************************************************
 8401                        	; ***************************************************************************
 8402                        	; subroutines for logical and arithmetic shifts by a constant amount
 8403                        	; ***************************************************************************
 8404                        	; ***************************************************************************
 8405                        	
 8406                        	; **************
 8407                        	; Y:A = Y:A << const
 8408                        	
 8409    00:E1BE  0A         	aslw15:		asl	a
 8410    00:E1BF  0A         	aslw14:		asl	a
 8411    00:E1C0  0A         	aslw13:		asl	a
 8412    00:E1C1  0A         	aslw12:		asl	a
 8413    00:E1C2  0A         	aslw11:		asl	a
 8414    00:E1C3  0A         	aslw10:		asl	a
 8415    00:E1C4  0A         	aslw9:		asl	a
 8416    00:E1C5  A8         	aslw8:		tay
 8417    00:E1C6  62         			cla
 8418    00:E1C7  60         			rts
 8419                        	
 8420               0001     		.if	1
 8421    00:E1C8  66 00      	aslw5:		ror	<__temp
 8422    00:E1CA  6A         			ror	a
 8423    00:E1CB  66 00      	aslw6:		ror	<__temp
 8424    00:E1CD  6A         			ror	a
 8425    00:E1CE  66 00      	aslw7:		ror	<__temp
 8426    00:E1D0  6A         			ror	a
 8427    00:E1D1  A4 00      			ldy	<__temp
 8428    00:E1D3  60         			rts
 8429                        		.else
 8436                        		.endif
 8437    00:E1D4  0A         	aslw4:		asl	a
 8438    00:E1D5  26 00      			rol	<__temp
 8439    00:E1D7  0A         	aslw3:		asl	a
 8440    00:E1D8  26 00      			rol	<__temp
 8441    00:E1DA  0A         	aslw2:		asl	a
 8442    00:E1DB  26 00      			rol	<__temp
 8443    00:E1DD  0A         	aslw1:		asl	a
 8444    00:E1DE  26 00      			rol	<__temp
 8445    00:E1E0  A4 00      	aslw0:		ldy	<__temp
 8446    00:E1E2  60         			rts
 8447                        	
 8448                        	; **************
 8449                        	; Y:A = Y:A >> const
 8450                        	
 8451    00:E1E3  C9 80      	asrw15:		cmp	#$80
 8452    00:E1E5  6A         			ror	a
 8453    00:E1E6  C9 80      	asrw14:		cmp	#$80
 8454    00:E1E8  6A         			ror	a
 8455    00:E1E9  C9 80      	asrw13:		cmp	#$80
 8456    00:E1EB  6A         			ror	a
 8457    00:E1EC  C9 80      	asrw12:		cmp	#$80
 8458    00:E1EE  6A         			ror	a
 8459    00:E1EF  C9 80      	asrw11:		cmp	#$80
 8460    00:E1F1  6A         			ror	a
 8461    00:E1F2  C9 80      	asrw10:		cmp	#$80
 8462    00:E1F4  6A         			ror	a
 8463    00:E1F5  C9 80      	asrw9:		cmp	#$80
 8464    00:E1F7  6A         			ror	a
 8465    00:E1F8  C9 80      	asrw8:		cmp	#$80
 8466    00:E1FA  C2         			cly
 8467    00:E1FB  90 01      			bcc	!+
 8468    00:E1FD  88         			dey
 8469    00:E1FE  60         	!:		rts
 8470                        	
 8471    00:E1FF  C0 80      	asrw7:		cpy	#$80
 8472    00:E201  66 00      			ror	<__temp
 8473    00:E203  6A         			ror	a
 8474    00:E204  C0 80      	asrw6:		cpy	#$80
 8475    00:E206  66 00      			ror	<__temp
 8476    00:E208  6A         			ror	a
 8477    00:E209  C0 80      	asrw5:		cpy	#$80
 8478    00:E20B  66 00      			ror	<__temp
 8479    00:E20D  6A         			ror	a
 8480    00:E20E  C0 80      	asrw4:		cpy	#$80
 8481    00:E210  66 00      			ror	<__temp
 8482    00:E212  6A         			ror	a
 8483    00:E213  C0 80      	asrw3:		cpy	#$80
 8484    00:E215  66 00      			ror	<__temp
 8485    00:E217  6A         			ror	a
 8486    00:E218  C0 80      	asrw2:		cpy	#$80
 8487    00:E21A  66 00      			ror	<__temp
 8488    00:E21C  6A         			ror	a
 8489    00:E21D  C0 80      	asrw1:		cpy	#$80
 8490    00:E21F  66 00      			ror	<__temp
 8491    00:E221  6A         			ror	a
 8492    00:E222  A4 00      	asrw0:		ldy	<__temp
 8493    00:E224  60         			rts
 8494                        	
 8495                        	; **************
 8496                        	; Y:A = Y:A >> const
 8497                        	
 8498    00:E225  4A         	lsrw15:		lsr	a
 8499    00:E226  4A         	lsrw14:		lsr	a
 8500    00:E227  4A         	lsrw13:		lsr	a
 8501    00:E228  4A         	lsrw12:		lsr	a
 8502    00:E229  4A         	lsrw11:		lsr	a
 8503    00:E22A  4A         	lsrw10:		lsr	a
 8504    00:E22B  4A         	lsrw9:		lsr	a
 8505    00:E22C  C2         	lsrw8:		cly
 8506    00:E22D  60         			rts
 8507                        	
 8508    00:E22E  46 00      	lsrw7:		lsr	<__temp
 8509    00:E230  6A         			ror	a
 8510    00:E231  46 00      	lsrw6:		lsr	<__temp
 8511    00:E233  6A         			ror	a
 8512    00:E234  46 00      	lsrw5:		lsr	<__temp
 8513    00:E236  6A         			ror	a
 8514    00:E237  46 00      	lsrw4:		lsr	<__temp
 8515    00:E239  6A         			ror	a
 8516    00:E23A  46 00      	lsrw3:		lsr	<__temp
 8517    00:E23C  6A         			ror	a
 8518    00:E23D  46 00      	lsrw2:		lsr	<__temp
 8519    00:E23F  6A         			ror	a
 8520    00:E240  46 00      	lsrw1:		lsr	<__temp
 8521    00:E242  6A         			ror	a
 8522    00:E243  A4 00      	lsrw0:		ldy	<__temp
 8523    00:E245  60         			rts
 8524                        	
 8525                        	
 8526                        	
 8527                        	; ***************************************************************************
 8528                        	; ***************************************************************************
 8529                        	; subroutines for logical and arithmetic shifts by a variable amount
 8530                        	; ***************************************************************************
 8531                        	; ***************************************************************************
 8532                        	
 8533                        	; **************
 8534                        	; Y:A = Y:A << X
 8535                        	
 8536    00:E246  84 00      	asl.wx:		sty	<__temp
 8537    00:E248  E0 10      			cpx	#16
 8538    00:E24A  B0 37      			bcs	!zero+
 8539    00:E24C  CA         			dex
 8540    00:E24D  30 06      			bmi	.done
 8541    00:E24F  0A         	.loop:		asl	a
 8542    00:E250  26 00      			rol	<__temp
 8543    00:E252  CA         			dex
 8544    00:E253  10 FA      			bpl	.loop
 8545    00:E255  A4 00      	.done:		ldy	<__temp
 8546    00:E257  60         			rts
 8547                        	
 8548                        	; **************
 8549                        	; Y:A = Y:A >> X
 8550                        	
 8551    00:E258  84 00      	asr.wx:		sty	<__temp
 8552    00:E25A  10 17      			bpl	!positive+
 8553    00:E25C  E0 10      	!negative:	cpx	#16
 8554    00:E25E  B0 0D      			bcs	.sign
 8555    00:E260  CA         			dex
 8556    00:E261  30 07      			bmi	.done
 8557    00:E263  38         	.loop:		sec
 8558    00:E264  66 00      			ror	<__temp
 8559    00:E266  6A         			ror	a
 8560    00:E267  CA         			dex
 8561    00:E268  10 F9      			bpl	.loop
 8562    00:E26A  A4 00      	.done:		ldy	<__temp
 8563    00:E26C  60         			rts
 8564                        	
 8565    00:E26D  A9 FF      	.sign:		lda	#$FF
 8566    00:E26F  A8         			tay
 8567    00:E270  60         			rts
 8568                        	
 8569                        	; **************
 8570                        	; Y:A = Y:A >> X
 8571                        	
 8572    00:E271  84 00      	lsr.wx:		sty	<__temp
 8573    00:E273  E0 10      	!positive:	cpx	#16
 8574    00:E275  B0 0C      			bcs	!zero+
 8575    00:E277  CA         			dex
 8576    00:E278  30 06      			bmi	.done
 8577    00:E27A  46 00      	.loop:		lsr	<__temp
 8578    00:E27C  6A         			ror	a
 8579    00:E27D  CA         			dex
 8580    00:E27E  10 FA      			bpl	.loop
 8581    00:E280  A4 00      	.done:		ldy	<__temp
 8582    00:E282  60         			rts
 8583                        	
 8584    00:E283  62         	!zero:		cla
 8585    00:E284  C2         			cly
 8586    00:E285  60         			rts
 8587                        	
 8588                        	
 8589                        	
 8590                        	; ***************************************************************************
 8591                        	; ***************************************************************************
 8592                        	; POTENTIAL OPTIMIZATIONS, NOT YET ADDED
 8593                        	; ***************************************************************************
 8594                        	; ***************************************************************************
                             #[2]   "..\..\..\include\hucc\hucc.asm"
                             #[3]   "..\..\..\include\hucc\hucc-baselib.asm"
  227                        			include	"hucc-baselib.asm"	; HuCC base library macros.
    1                        	; ***************************************************************************
    2                        	; ***************************************************************************
    3                        	;
    4                        	; hucc-baselib.asm
    5                        	;
    6                        	; Basic library functions provided (mostly) as macros.
    7                        	;
    8                        	; Copyright John Brandwood 2024-2025.
    9                        	;
   10                        	; Distributed under the Boost Software License, Version 1.0.
   11                        	; (See accompanying file LICENSE_1_0.txt or copy at
   12                        	;  http://www.boost.org/LICENSE_1_0.txt)
   13                        	;
   14                        	; ***************************************************************************
   15                        	; ***************************************************************************
   16                        	
   17                        	
   18                        	
   19                        	; ***************************************************************************
   20                        	; ***************************************************************************
   21                        	;
   22                        	; Make certain System Card variables accessible to HuCC.
   23                        	
   24    00:E286             	_irq_cnt	.alias	irq_cnt
   25    00:E286             	_joynow		.alias	joynow
   26    00:E286             	_joytrg		.alias	joytrg
   27    00:E286             	_joy6now	.alias	joy6now
   28    00:E286             	_joy6trg	.alias	joy6trg
   29    00:E286             	_bg_x1		.alias	bg_x1
   30    00:E286             	_bg_y1		.alias	bg_y1
   31    00:E286             	_bg_x2		.alias	bg_x2
   32    00:E286             	_bg_y2		.alias	bg_y2
   33                        	
   34                        	
   35                        	
   36                        	; ***************************************************************************
   37                        	; ***************************************************************************
   38                        	;
   39                        	; void __fastcall dump_screen( void );
   40                        	;
   41                        	; THIS IS AN ILLEGAL INSTRUCTION ONLY IMPLEMENTED BY THE TGEMU EMULATOR!
   42                        	
   43    00:E286  33         	_dump_screen:	db	0x33
   44                        	
   45                        	
   46                        	
   47                        	; ***************************************************************************
   48                        	; ***************************************************************************
   49                        	;
   50                        	; void __fastcall abort( void );
   51                        	;
   52                        	; THIS IS AN ILLEGAL INSTRUCTION ONLY IMPLEMENTED BY THE TGEMU EMULATOR!
   53                        	
   54    00:E287  E2         	_abort:		db	0xE2
   55                        	
   56                        	
   57                        	
   58                        	; ***************************************************************************
   59                        	; ***************************************************************************
   60                        	;
   61                        	; void __fastcall exit( int value<acc> );
   62                        	;
   63                        	; THIS IS AN ILLEGAL INSTRUCTION ONLY IMPLEMENTED BY THE TGEMU EMULATOR!
   64                        	
   65    00:E288  AA         	_exit.1:	tax				; Put the return code into X.
   66    00:E289  63         			db	0x63
   67                        	
   68    00:E28A  80 FE      	.hang:		bra	.hang			; Hang if used in normal code.
   69                        	
   70                        	
   71                        	
   72                        	; ***************************************************************************
   73                        	; ***************************************************************************
   74                        	;
   75                        	; unsigned char __fastcall __macro cd_execoverlay( unsigned char ovl_index<acc> );
   76                        	;
   77                        	; Execute program overlay from disc
   78                        	;
   79                        	; N.B. This does not return, even if there's an error.
   80                        	
   81                        			.macro	_cd_execoverlay.1
   82                        			tax
   83                        			jmp	exec_overlay
   84                        			.endm
   85                        	
   86                        	
   87                        	
   88                        	; ***************************************************************************
   89                        	; ***************************************************************************
   90                        	;
   91                        	; void __fastcall __nop set_far_base( unsigned char data_bank<_bp_bank>, unsigned char *data_addr<_bp> );
   92                        	; void __fastcall set_far_offset( unsigned int offset<_bp>, unsigned char data_bank<_bp_bank>, unsigned char *data_addr<acc> );
   93                        	
   94    00:E28C             	_set_far_offset.3:
   95    00:E28C  18         			clc
   96    00:E28D  65 EC      			adc.l	<_bp
   97    00:E28F  85 EC      			sta.l	<_bp
   98    00:E291  98         			tya
   99    00:E292  29 1F      			and	#$1F
  100    00:E294  65 ED      			adc.h	<_bp
  101    00:E296  A8         			tay
  102    00:E297  29 1F      			and	#$1F
  103    00:E299  09 60      			ora	#$60
  104    00:E29B  85 ED      			sta.h	<_bp
  105    00:E29D  98         			tya
  106    00:E29E  6A         			ror	a
  107    00:E29F  4A         			lsr	a
  108    00:E2A0  4A         			lsr	a
  109    00:E2A1  4A         			lsr	a
  110    00:E2A2  4A         			lsr	a
  111    00:E2A3  18         			clc
  112    00:E2A4  65 02      			adc	<_bp_bank
  113    00:E2A6  85 02      			sta	<_bp_bank
  114    00:E2A8  60         			rts
  115                        	
  116                        	
  117                        	; ***************************************************************************
  118                        	; ***************************************************************************
  119                        	;
  120                        	; void __fastcall __macro reset_mpr2( void );
  121                        	; void __fastcall __macro reset_mpr34( void );
  122                        	;
  123                        	; void * __fastcall __macro set_mpr2( void __far *addr<_bp_bank:_bp> );
  124                        	; void * __fastcall __macro set_mpr34( void __far *addr<_bp_bank:_bp> );
  125                        	;
  126                        	; void * __fastcall __macro far_set_mpr2( void );
  127                        	; void * __fastcall __macro far_set_mpr34( void );
  128                        	
  129                        	_reset_mpr2	.macro
  130                        		.if	SUPPORT_SGX
  131                        			lda	#$F9
  132                        		.else
  133                        			lda	#$87
  134                        		.endif
  135                        			tam2
  136                        			.endm
  137                        	
  138                        	_reset_mpr34	.macro
  139                        			lda	#CONST_BANK + _bank_base
  140                        			tam3
  141                        			inc	a
  142                        			tam4
  143                        			.endm
  144                        	
  145                        	_farset_mpr2.1	.macro
  146                        			lda	<_bp_bank
  147                        			tam2
  148                        			lda.l	<_bp
  149                        			ldy.h	<_bp
  150                        			.endm
  151                        	
  152                        	_farset_mpr34.1	.macro
  153                        			lda	<_bp_bank
  154                        			tam3
  155                        			inc	a
  156                        			tam4
  157                        			lda.l	<_bp
  158                        			ldy.h	<_bp
  159                        			.endm
  160                        	
  161                        	_far_set_mpr2	.macro
  162                        			lda	<_bp_bank
  163                        			tam2
  164                        			lda.l	<_bp
  165                        			ldy.h	<_bp
  166                        			.endm
  167                        	
  168                        	_far_set_mpr34	.macro
  169                        			lda	<_bp_bank
  170                        			tam3
  171                        			inc	a
  172                        			tam4
  173                        			lda.l	<_bp
  174                        			ldy.h	<_bp
  175                        			.endm
  176                        	
  177                        	
  178                        	
  179                        	; ***************************************************************************
  180                        	; ***************************************************************************
  181                        	;
  182                        	; unsigned char __fastcall __macro ac_exists( void );
  183                        	
  184                        	_ac_exists	.macro
  185                        			cla
  186                        			ldy	ACD_FLAG
  187                        			cpy	#ACD_ID
  188                        			bne	!+
  189                        			inc	a
  190                        	!:		cly
  191                        			.endm
  192                        	
  193                        	
  194                        	
  195                        	; ***************************************************************************
  196                        	; ***************************************************************************
  197                        	;
  198                        	; unsigned char __fastcall __macro _sgx_detect( void );
  199                        	
  200                        	_sgx_detect	.macro
  201                        			lda	sgx_detected
  202                        			cly
  203                        			.endm
  204                        	
  205                        	
  206                        	
  207                        	; ***************************************************************************
  208                        	; ***************************************************************************
  209                        	;
  210                        	; unsigned int __fastcall __macro peek( unsigned int addr<__ptr> );
  211                        	
  212                        	_peek.1		.macro
  213                        			lda	[__ptr]
  214                        			cly
  215                        			.endm
  216                        	
  217                        	
  218                        	
  219                        	; ***************************************************************************
  220                        	; ***************************************************************************
  221                        	;
  222                        	; unsigned int __fastcall __macro peekw( unsigned int addr<__ptr> );
  223                        	
  224                        	_peekw.1	.macro
  225                        			lda	[__ptr]
  226                        			pha
  227                        			ldy	#1
  228                        			lda	[__ptr], y
  229                        			tay
  230                        			pla
  231                        			.endm
  232                        	
  233                        	
  234                        	
  235                        	; ***************************************************************************
  236                        	; ***************************************************************************
  237                        	;
  238                        	; void __fastcall __macro poke( unsigned int addr<__poke>, unsigned char with<acc> );
  239                        	;
  240                        	; N.B. Because the <acc> value can be a complex C calculation, it isn't safe
  241                        	; to use __ptr as the destination, which can be overwritten in C macros.
  242                        	
  243                        	_poke.2		.macro
  244                        			sta	[__poke]
  245                        			.endm
  246                        	
  247                        	
  248                        	
  249                        	; ***************************************************************************
  250                        	; ***************************************************************************
  251                        	;
  252                        	; void __fastcall __macro pokew( unsigned int addr<__poke>, unsigned int with<acc> );
  253                        	;
  254                        	; N.B. Because the <acc> value can be a complex C calculation, it isn't safe
  255                        	; to use __ptr as the destination, which can be overwritten in C macros.
  256                        	
  257                        	_pokew.2	.macro
  258                        			sta	[__poke]
  259                        			tya
  260                        			ldy	#1
  261                        			sta	[__poke], y
  262                        			.endm
  263                        	
  264                        	
  265                        	
  266                        	; ***************************************************************************
  267                        	; ***************************************************************************
  268                        	;
  269                        	; unsigned char __fastcall __macro clock_hh( void );
  270                        	
  271                        	_clock_hh	.macro
  272                        			lda	clock_hh
  273                        			cly
  274                        			.endm
  275                        	
  276                        	
  277                        	
  278                        	; ***************************************************************************
  279                        	; ***************************************************************************
  280                        	;
  281                        	; unsigned char __fastcall __macro clock_mm( void );
  282                        	
  283                        	_clock_mm	.macro
  284                        			lda	clock_mm
  285                        			cly
  286                        			.endm
  287                        	
  288                        	
  289                        	
  290                        	; ***************************************************************************
  291                        	; ***************************************************************************
  292                        	;
  293                        	; unsigned char __fastcall __macro clock_ss( void );
  294                        	
  295                        	_clock_ss	.macro
  296                        			lda	clock_ss
  297                        			cly
  298                        			.endm
  299                        	
  300                        	
  301                        	
  302                        	; ***************************************************************************
  303                        	; ***************************************************************************
  304                        	;
  305                        	; unsigned char __fastcall __macro clock_tt( void );
  306                        	
  307                        	_clock_tt	.macro
  308                        			lda	clock_tt
  309                        			cly
  310                        			.endm
  311                        	
  312                        	
  313                        	
  314                        	; ***************************************************************************
  315                        	; ***************************************************************************
  316                        	;
  317                        	; void __fastcall __macro clock_reset( void );
  318                        	
  319                        	_clock_reset	.macro
  320                        			stz	clock_hh
  321                        			stz	clock_mm
  322                        			stz	clock_ss
  323                        			stz	clock_tt
  324                        			.endm
  325                        	
  326                        	
  327                        	
  328                        	; ***************************************************************************
  329                        	; ***************************************************************************
  330                        	;
  331                        	; unsigned int __fastcall __macro joy( unsigned char which<acc> );
  332                        	
  333                        	_joy.1		.macro
  334                        			tax
  335                        			lda	joynow, x
  336                        		.if	SUPPORT_6BUTTON
  337                        			ldy	joy6now, x
  338                        		.else
  339                        			cly
  340                        		.endif
  341                        			.endm
  342                        	
  343                        	
  344                        	
  345                        	; ***************************************************************************
  346                        	; ***************************************************************************
  347                        	;
  348                        	; unsigned int __fastcall __macro joytrg( unsigned char which<acc> );
  349                        	
  350                        	_joytrg.1	.macro
  351                        			tax
  352                        			lda	joytrg, x
  353                        		.if	SUPPORT_6BUTTON
  354                        			ldy	joy6trg, x
  355                        		.else
  356                        			cly
  357                        		.endif
  358                        			.endm
  359                        	
  360                        	
  361                        	
  362                        	; ***************************************************************************
  363                        	; ***************************************************************************
  364                        	;
  365                        	; unsigned int __fastcall __macro joybuf( unsigned char which<acc> );
  366                        	
  367                        	_joybuf.1	.macro
  368                        		.if	HUC_JOY_EVENTS
  369                        			tax
  370                        			lda	joybuf, x
  371                        		.if	SUPPORT_6BUTTON
  372                        			ldy	joy6buf, x
  373                        		.else
  374                        			cly
  375                        		.endif
  376                        		.else
  377                        			.fail	You must enable HUC_JOY_EVENTS in your hucc-config.inc!
  378                        		.endif
  379                        			.endm
  380                        	
  381                        	
  382                        	
  383                        	; ***************************************************************************
  384                        	; ***************************************************************************
  385                        	;
  386                        	; unsigned int __fastcall __macro get_joy_events( unsigned char which<acc> );
  387                        	;
  388                        	; N.B. This is just a version of joybuf() that clears the accumulated events.
  389                        	
  390                        			.macro	_get_joy_events.1
  391                        		.if	HUC_JOY_EVENTS
  392                        			tax
  393                        			lda	joybuf, x
  394                        			stz	joybuf, x
  395                        		.if	SUPPORT_6BUTTON
  396                        			ldy	joy6buf, x
  397                        			stz	joy6buf, x
  398                        		.else
  399                        			cly
  400                        		.endif
  401                        		.else
  402                        		.if	ACCUMULATE_JOY
  403                        			tax
  404                        			lda	joytrg, x
  405                        			stz	joytrg, x
  406                        		.if	SUPPORT_6BUTTON
  407                        			ldy	joy6trg, x
  408                        			stz	joy6trg, x
  409                        		.else
  410                        			cly
  411                        		.endif
  412                        		.else
  413                        			.fail	You must enable HUC_JOY_EVENTS or ACCUMULATE_JOY in your hucc-config.inc!
  414                        		.endif
  415                        		.endif
  416                        			.endm
  417                        	
  418                        	
  419                        	
  420                        	; ***************************************************************************
  421                        	; ***************************************************************************
  422                        	;
  423                        	; void __fastcall __macro clear_joy_events( unsigned char mask<acc> );
  424                        	
  425                        			.macro	_clear_joy_events.1
  426                        			php
  427                        			sei
  428                        			and	#(1 << MAX_PADS) - 1
  429                        			ldx	#$FF
  430                        	.loop:		inx
  431                        			lsr	a
  432                        			bcc	.next
  433                        		.if	HUC_JOY_EVENTS
  434                        			stz	joybuf, x
  435                        		.if	SUPPORT_6BUTTON
  436                        			stz	joy6buf, x
  437                        		.endif
  438                        		.else
  439                        		.if	ACCUMULATE_JOY
  440                        			stz	joytrg, x
  441                        		.if	SUPPORT_6BUTTON
  442                        			stz	joy6trg, x
  443                        		.endif
  444                        		.else
  445                        			.fail	You must enable HUC_JOY_EVENTS or ACCUMULATE_JOY in your hucc-config.inc!
  446                        		.endif
  447                        		.endif
  448                        	.next:		bne	.loop
  449                        			plp
  450                        			.endm
  451                        	
  452                        	
  453                        	
  454                        	; ***************************************************************************
  455                        	; ***************************************************************************
  456                        	;
  457                        	; void __fastcall srand( unsigned char seed<acc> );
  458                        	
  459               0001     		.ifndef	HUCC_NO_DEFAULT_RANDOM
  460                        	_srand.1	.macro
  461                        			tay
  462                        			jsr	init_random
  463                        			.endm
  464                        		.endif
  465                        	
  466                        	
  467                        	
  468                        	; ***************************************************************************
  469                        	; ***************************************************************************
  470                        	;
  471                        	; unsigned int __fastcall rand( void );
  472                        	; unsigned char __fastcall rand8( void );
  473                        	
  474               0001     		.ifndef	HUCC_NO_DEFAULT_RANDOM
  475    00:E2A9  20 C3 E5   	_rand:		jsr	get_random		; Random in A, preserve Y.
  476    00:E2AC  A8         			tay
  477    00:E2AD  4C C3 E5   			jmp	get_random		; Random in A, preserve Y.
  478                        		.endif
  479                        	
  480                        	
  481                        	
  482                        	; ***************************************************************************
  483                        	; ***************************************************************************
  484                        	;
  485                        	; unsigned char __fastcall random8( unsigned char limit<acc> );
  486                        	;
  487                        	; IN :	A = range (0..255)
  488                        	; OUT : A = random number interval 0 <= x < A
  489                        	
  490               0001     		.ifndef	HUCC_NO_DEFAULT_RANDOM
  491                        	
  492    00:E2B0  A8         	_random8.1:	tay				; Preserve the limit.
  493    00:E2B1  20 C3 E5   			jsr	get_random		; Random in A, preserve Y.
  494                        	
  495    00:E2B4  20 F0 E4   			jsr	__muluchar
  496    00:E2B7  98         			tya				; Do a 8.0 x 0.8 fixed point
  497    00:E2B8  C2         			cly				; fractional multiply.
  498    00:E2B9  60         			rts
  499                        		.endif
  500                        	
  501                        	
  502                        	
  503                        	; ***************************************************************************
  504                        	; ***************************************************************************
  505                        	;
  506                        	; unsigned char __fastcall random( unsigned char limit<acc> );
  507                        	;
  508                        	; IN :	A = range (0..128), 129..255 is treated as 128
  509                        	; OUT : A = random number interval 0 <= x < A
  510                        	
  511               0001     		.ifndef	HUCC_NO_DEFAULT_RANDOM
  512                        	
  513    00:E2BA  A8         	_random.1:	tay				; Preserve the limit.
  514    00:E2BB  20 C3 E5   			jsr	get_random		; Random in A, preserve Y.
  515                        	
  516    00:E2BE  C0 80      			cpy	#128			; Check the limit.
  517    00:E2C0  90 04      			bcc	!+
  518                        	
  519    00:E2C2  29 7F      			and	#$7F			; Just mask the random if
  520    00:E2C4  C2         			cly				; the limit is >= 128.
  521    00:E2C5  60         			rts
  522                        	
  523    00:E2C6  20 F0 E4   	!:		jsr	__muluchar
  524    00:E2C9  98         			tya				; If the limit is < 128 then
  525    00:E2CA  C2         			cly				; do a 8.0 x 0.8 fixed point
  526    00:E2CB  60         			rts				; fractional multiply.
  527                        		.endif
  528                        	
  529                        	
  530                        	
  531                        	; ***************************************************************************
  532                        	; ***************************************************************************
  533                        	;
  534                        	; unsigned char __fastcall __builtin_ffs( unsigned int value<__temp> );
  535                        	
  536                        			.proc	___builtin_ffs.1
  556                        			.endp
  557                        	
  558                        	
  559                        	
  560                        	; ***************************************************************************
  561                        	; ***************************************************************************
  562                        	;
  563                        	; N.B. Declared in hucc-string.h, but defined here because they're macros!
  564                        	;
  565                        	; int __fastcall __macro memcmp( unsigned char *destination<_di>, unsigned char *source<_bp>, unsigned int count<acc> );
  566                        	
  567                        	_memcmp.3	.macro
  568                        			stz	<_bp_bank		; Map the source string.
  569                        			call	_farmemcmp.3
  570                        			.endm
  571                        	
  572                        	
  573                        	
  574                        	; ***************************************************************************
  575                        	; ***************************************************************************
  576                        	;
  577                        	; N.B. Declared in hucc-gfx.h, but defined here because they're macros!
  578                        	;
  579                        	; void __fastcall __macro get_color( unsigned int index<VCE_CTA> );
  580                        	
  581                        	_get_color.1	.macro
  582                        			lda.l	VCE_CTR
  583                        			ldy.h	VCE_CTR
  584                        			.endm
  585                        	
  586                        	
  587                        	
  588                        	; ***************************************************************************
  589                        	; ***************************************************************************
  590                        	;
  591                        	; N.B. Declared in hucc-gfx.h, but defined here because they're macros!
  592                        	;
  593                        	; void __fastcall __macro fade_to_black( unsigned int __far *from<_bp_bank:_bp>, unsigned int *destination<_di>, unsigned char num_colors<_al>, unsigned char value_to_sub<_ah> );
  594                        	; void __fastcall __macro fade_to_white( unsigned int __far *from<_bp_bank:_bp>, unsigned int *destination<_di>, unsigned char num_colors<_al>, unsigned char value_to_add<_ah> );
  595                        	; void __fastcall __macro cross_fade_to( unsigned int __far *from<_bp_bank:_bp>, unsigned int *destination<_di>, unsigned char num_colors<_al>, unsigned char which_component<_ah );
  596                        	;
  597                        	; void __fastcall __macro far_fade_to_black( unsigned int *destination<_di>, unsigned char num_colors<_al>, unsigned char value_to_sub<_ah> );
  598                        	; void __fastcall __macro far_fade_to_white( unsigned int *destination<_di>, unsigned char num_colors<_al>, unsigned char value_to_add<_ah> );
  599                        	; void __fastcall __macro far_cross_fade_to( unsigned int *destination<_di>, unsigned char num_colors<_al>, unsigned char which_component<_ah );
  600                        	
  601                        			.macro	_fade_to_black.4
  602                        			ldy	<_bp_bank
  603                        			call	fade_to_black
  604                        			.endm
  605                        	
  606                        			.macro	_fade_to_white.4
  607                        			ldy	<_bp_bank
  608                        			call	fade_to_white
  609                        			.endm
  610                        	
  611                        			.macro	_cross_fade_to.4
  612                        			ldy	<_bp_bank
  613                        			call	cross_fade_to
  614                        			.endm
  615                        	
  616                        			.macro	_far_fade_to_black.3
  617                        			ldy	<_bp_bank
  618                        			call	fade_to_black
  619                        			.endm
  620                        	
  621                        			.macro	_far_fade_to_white.3
  622                        			ldy	<_bp_bank
  623                        			call	fade_to_white
  624                        			.endm
  625                        	
  626                        			.macro	_far_cross_fade_to.3
  627                        			ldy	<_bp_bank
  628                        			call	cross_fade_to
  629                        			.endm
  630                        	
  631                        	
  632                        	
  633                        	; ***************************************************************************
  634                        	; ***************************************************************************
  635                        	;
  636                        	; N.B. Declared in hucc-gfx.h, but defined here because they're macros!
  637                        	;
  638                        	; void __fastcall __macro set_xres( unsigned int x_pixels<_ax> );
  639                        	; void __fastcall __macro sgx_set_xres( unsigned int x_pixels<_ax> );
  640                        	;
  641                        	; void __fastcall set_xres( unsigned int x_pixels<_ax>, unsigned char blur_flag<_bl> );
  642                        	; void __fastcall sgx_set_xres( unsigned int x_pixels<_ax>, unsigned char blur_flag<_bl> );
  643                        	
  644                        	_set_xres.1	.macro
  645                        			lda	#XRES_SOFT
  646                        			sta	<_bl
  647                        			call	_set_xres.2
  648                        			.endm
  649                        	
  650               0001     		.if	SUPPORT_SGX
  651                        			.macro	_sgx_set_xres.1
  652                        			lda	#XRES_SOFT
  653                        			sta	<_bl
  654                        			call	_sgx_set_xres.2
  655                        			.endm
  656                        		.endif
  657                        	
  658                        	
  659                        	
  660                        	; ***************************************************************************
  661                        	; ***************************************************************************
  662                        	;
  663                        	; N.B. Declared in hucc-gfx.h, but defined here because they're macros!
  664                        	;
  665                        	; unsigned int __fastcall __macro vram_addr( unsigned char bat_x<_al>, unsigned char bat_y<_ah> );
  666                        	; unsigned int __fastcall __macro sgx_vram_addr( unsigned char bat_x<_al>, unsigned char bat_y<_ah> );
  667                        	
  668                        			.macro	_vram_addr.2
  669                        			cla
  670                        			bit	vdc_bat_width
  671                        			bmi	!w128+
  672                        			bvs	!w64+
  673                        	!w32:		lsr	<_ah
  674                        			ror	a
  675                        	!w64:		lsr	<_ah
  676                        			ror	a
  677                        	!w128:		lsr	<_ah
  678                        			ror	a
  679                        			ora	<_al
  680                        			ldy	<_ah
  681                        			.endm
  682                        	
  683               0001     		.if	SUPPORT_SGX
  684                        			.macro	_sgx_vram_addr.2
  685                        			cla
  686                        			bit	sgx_bat_width
  687                        			bmi	!w128+
  688                        			bvs	!w64+
  689                        	!w32:		lsr	<_ah
  690                        			ror	a
  691                        	!w64:		lsr	<_ah
  692                        			ror	a
  693                        	!w128:		lsr	<_ah
  694                        			ror	a
  695                        			ora	<_al
  696                        			ldy	<_ah
  697                        			.endm
  698                        		.endif
  699                        	
  700                        	
  701                        	
  702                        	; ***************************************************************************
  703                        	; ***************************************************************************
  704                        	;
  705                        	; N.B. Declared in hucc-gfx.h, but defined here because they're macros!
  706                        	;
  707                        	; unsigned int __fastcall __macro get_vram( unsigned int address<_di> );
  708                        	; void __fastcall __macro put_vram( unsigned int address<_di>, unsigned int data<acc> );
  709                        	;
  710                        	; unsigned int __fastcall __macro sgx_get_vram( unsigned int address<_di> );
  711                        	; void __fastcall __macro sgx_put_vram( unsigned int address<_di>, unsigned int data<acc> );
  712                        	
  713                        			.macro	_get_vram.1
  714                        			jsr	vdc_di_to_marr
  715                        			lda	VDC_DL
  716                        			ldy	VDC_DH
  717                        			.endm
  718                        	
  719                        			.macro	_put_vram.2
  720                        			pha
  721                        			jsr	vdc_di_to_mawr
  722                        			pla
  723                        			sta	VDC_DL
  724                        			sty	VDC_DH
  725                        			.endm
  726                        	
  727               0001     		.if	SUPPORT_SGX
  728                        			.macro	_sgx_get_vram.1
  729                        			jsr	sgx_di_to_marr
  730                        			lda	SGX_DL
  731                        			ldy	SGX_DH
  732                        			.endm
  733                        	
  734                        			.macro	_sgx_put_vram.2
  735                        			pha
  736                        			jsr	sgx_di_to_mawr
  737                        			pla
  738                        			sta	SGX_DL
  739                        			sty	SGX_DH
  740                        			.endm
  741                        		.endif
  742                        	
  743                        	
  744                        	
  745                        	; ***************************************************************************
  746                        	; ***************************************************************************
  747                        	;
  748                        	; N.B. Declared in hucc-gfx.h, but defined here because they're macros!
  749                        	;
  750                        	; void __fastcall __macro set_bgpal( unsigned char palette<_al>, unsigned char __far *data<_bp_bank:_bp> );
  751                        	; void __fastcall __macro set_bgpal( unsigned char palette<_al>, unsigned char __far *data<_bp_bank:_bp>, unsigned int num_palettes<_ah> );
  752                        	; void __fastcall __macro set_sprpal( unsigned char palette<_al>, unsigned char __far *data<_bp_bank:_bp> );
  753                        	; void __fastcall __macro set_sprpal( unsigned char palette<_al>, unsigned char __far *data<_bp_bank:_bp>, unsigned int num_palettes<_ah> );
  754                        	
  755                        	_set_bgpal.2	.macro
  756                        			lda	#1
  757                        			sta	<_ah
  758                        			call	_load_palette.3
  759                        			.endm
  760                        	
  761                        	_set_bgpal.3	.macro
  762                        			call	_load_palette.3
  763                        			.endm
  764                        	
  765                        	_set_sprpal.2	.macro
  766                        			lda	#1
  767                        			sta	<_ah
  768                        			smb4	<_al
  769                        			call	_load_palette.3
  770                        			.endm
  771                        	
  772                        	_set_sprpal.3	.macro
  773                        			smb4	<_al
  774                        			call	_load_palette.3
  775                        			.endm
  776                        	
  777                        	
  778                        	
  779                        	; ***************************************************************************
  780                        	; ***************************************************************************
  781                        	;
  782                        	; N.B. Declared in hucc-gfx.h, but defined here because they're macros!
  783                        	;
  784                        	; void __fastcall __macro load_vram( unsigned int vram<_di>, unsigned char __far *data<_bp_bank:_bp>, unsigned int num_words<_ax> );
  785                        	; void __fastcall __macro sgx_load_vram( unsigned int vram<_di>, unsigned char __far *data<_bp_bank:_bp>, unsigned int num_words<_ax> );
  786                        	;
  787                        	; void __fastcall __macro far_load_vram( unsigned int vram<_di>, unsigned int num_words<_ax> );
  788                        	; void __fastcall __macro sgx_far_load_vram( unsigned int vram<_di>, unsigned int num_words<_ax> );
  789                        	;
  790                        	
  791               0001     		.if	SUPPORT_SGX
  792                        			.macro	_sgx_load_vram.3
  793                        			ldx	#SGX_VDC_OFFSET		; Offset to SGX VDC.
  794                        			call	load_vram_x
  795                        			.endm
  796                        	
  797                        			.macro	_sgx_far_load_vram.2
  798                        			ldx	#SGX_VDC_OFFSET		; Offset to SGX VDC.
  799                        			call	load_vram_x
  800                        			.endm
  801                        		.endif
  802                        	
  803                        			.macro	_load_vram.3
  804                        			clx				; Offset to PCE VDC.
  805                        			call	load_vram_x
  806                        			.endm
  807                        	
  808                        			.macro	_far_load_vram.2
  809                        			clx				; Offset to PCE VDC.
  810                        			call	load_vram_x
  811                        			.endm
  812                        	
  813                        	
  814                        	
  815                        	; ***************************************************************************
  816                        	; ***************************************************************************
  817                        	;
  818                        	; N.B. Declared in hucc-gfx.h, but defined here because they're macros!
  819                        	;
  820                        	; void __fastcall __macro load_sprites( unsigned int vram<_di>, unsigned char __far *data<_bp_bank:_bp>, unsigned int num_groups<acc> );
  821                        	; void __fastcall __macro sgx_load_sprites( unsigned int vram<_di>, unsigned char __far *data<_bp_bank:_bp>, unsigned int num_groups<acc> );
  822                        	; void __fastcall __macro far_load_sprites( unsigned int vram<_di>, unsigned int num_groups<acc> );
  823                        	; void __fastcall __macro sgx_far_load_sprites( unsigned int vram<_di>, unsigned int num_groups<acc> );
  824                        	
  825               0001     		.if	SUPPORT_SGX
  826                        			.macro	_sgx_load_sprites.3
  827                        			stz.l	<_ax
  828                        			asl	a
  829                        			sta.h	<_ax
  830                        			ldx	#SGX_VDC_OFFSET		; Offset to SGX VDC.
  831                        			call	load_vram_x
  832                        			.endm
  833                        	
  834                        			.macro	_sgx_far_load_sprites.2
  835                        			stz.l	<_ax
  836                        			asl	a
  837                        			sta.h	<_ax
  838                        			ldx	#SGX_VDC_OFFSET		; Offset to SGX VDC.
  839                        			call	load_vram_x
  840                        			.endm
  841                        		.endif
  842                        	
  843                        			.macro	_load_sprites.3
  844                        			stz.l	<_ax
  845                        			asl	a
  846                        			sta.h	<_ax
  847                        			clx				; Offset to PCE VDC.
  848                        			call	load_vram_x
  849                        			.endm
  850                        	
  851                        			.macro	_far_load_sprites.2
  852                        			stz.l	<_ax
  853                        			asl	a
  854                        			sta.h	<_ax
  855                        			clx				; Offset to PCE VDC.
  856                        			call	load_vram_x
  857                        			.endm
  858                        	
  859                        	
  860                        	
  861                        	; ***************************************************************************
  862                        	; ***************************************************************************
  863                        	;
  864                        	; N.B. Declared in hucc-gfx.h, but defined here because they're macros!
  865                        	;
  866                        	; void __fastcall load_default_font( void );
  867                        	; void __fastcall sgx_load_default_font( void );
  868                        	;
  869                        	
  870               0001     		.if	SUPPORT_SGX
  871                        			.macro	_sgx_load_default_font
  872                        			ldx	#SGX_VDC_OFFSET		; Offset to SGX VDC.
  873                        			call	huc_monofont_x
  874                        			.endm
  875                        		.endif
  876                        	
  877                        			.macro	_load_default_font
  878                        			clx				; Offset to PCE VDC.
  879                        			call	huc_monofont_x
  880                        			.endm
  881                        	
  882                        	
  883                        	
  884                        	; ***************************************************************************
  885                        	; ***************************************************************************
  886                        	
  887               0000     		.if	0
  905                        		.endif
                             #[2]   "..\..\..\include\hucc\hucc.asm"
  228                        	
  229               0000     		.if	CDROM
  231                        		.endif
  232                        	
  233                        			; Definitions for compatibility with old HuC/MagicKit projects.
  234                        	
  235               0001     		.ifndef	HUCC_NO_DEPRECATED
                             #[3]   "..\..\..\include\hucc\hucc-deprecated.inc"
  236                        			include	"hucc-deprecated.inc"
    1                        	; ***************************************************************************
    2                        	; ***************************************************************************
    3                        	;
    4                        	; hucc-deprecated.inc
    5                        	;
    6                        	; Macros and definitions for compatibility with old HuC/MagicKit projects.
    7                        	;
    8                        	; Based on the original HuC and MagicKit definitions by David Michel and the
    9                        	; other original HuC developers.
   10                        	;
   11                        	; ***************************************************************************
   12                        	; ***************************************************************************
   13                        	
   14                        			; For compatibility with HuC projects that use the old name.
   15                        	
   16               0001     	HUC_USER_RESERVED = HUC_USER_BANK
   17                        	
   18                        			; For compatibility with code that expects the HuC naming that
   19                        			; is used in the newer HuC, rather than the original HuC v3.21.
   20                        			;
   21                        			; Code generated by HuCC uses the original single-underscore.
   22                        	
   23               0001     		.if	1				
   24               0002     	__bp		=	$F8:20EC, 2		; base pointer
   25               0002     	__si		=	$F8:20EE, 2		; source address
   26               0002     	__di		=	$F8:20F0, 2		; destination address
   27                        	
   28               0002     	__ax		=	$F8:20F8, 2
   29               0001     	__al		=	$F8:20F8, 1
   30               0001     	__ah		=	$F8:20F9, 1
   31                        	
   32               0002     	__bx		=	$F8:20FA, 2
   33               0001     	__bl		=	$F8:20FA, 1
   34               0001     	__bh		=	$F8:20FB, 1
   35                        	
   36               0002     	__cx		=	$F8:20FC, 2
   37               0001     	__cl		=	$F8:20FC, 1
   38               0001     	__ch		=	$F8:20FD, 1
   39                        	
   40               0002     	__dx		=	$F8:20FE, 2
   41               0001     	__dl		=	$F8:20FE, 1
   42               0001     	__dh		=	$F8:20FF, 1
   43                        		.endif
   44                        	
   45                        			; For compatibility with code that expects the HuC naming that
   46                        			; is used rather than the shorter upper-case #define naming.
   47                        	
   48               0001     		.if	1				
   49               0001     	video_reg	=	$FF:0200, 1		; Address/Status Register
   50               0001     	video_reg_l	=	$FF:0200, 1		; Address/Status Register
   51               0001     	video_reg_h	=	$FF:0201, 1		; Address/Status Register
   52               0002     	video_data	=	$FF:0202, 2		; Data (Read/Write) Low
   53               0001     	video_data_l	=	$FF:0202, 1		; Data (Read/Write) Low
   54               0001     	video_data_h	=	$FF:0203, 1		; Data (Read/Write) High
   55                        	
   56               0002     	color_ctrl	=	$FF:0400, 2		; Control Register
   57               0002     	color_reg	=	$FF:0402, 2		; Color Table Address
   58               0001     	color_reg_l	=	$FF:0402, 1		; Color Table Address
   59               0001     	color_reg_h	=	$FF:0402, 1		; Color Table Address
   60               0002     	color_data	=	$FF:0404, 2		; Color Table Data Read/Write
   61               0001     	color_data_l	=	$FF:0404, 1		; Color Table Data Read/Write
   62               0001     	color_data_h	=	$FF:0405, 1		; Color Table Data Read/Write
   63                        	
   64               0001     	psg_ch		=	$FF:0800, 1		; Channel Select
   65               0001     	psg_mainvol	=	$FF:0801, 1		; Main Amplitude Level
   66               0001     	psg_freqlo	=	$FF:0802, 1		; Frequency Low
   67               0001     	psg_freqhi	=	$FF:0803, 1		; Frequency High
   68               0001     	psg_ctrl	=	$FF:0804, 1		; Control & Channel Amplitude
   69               0001     	psg_pan		=	$FF:0805, 1		; L/R Amplitude Level
   70               0001     	psg_wavebuf	=	$FF:0806, 1		; Waveform
   71               0001     	psg_noise	=	$FF:0807, 1		; Noise
   72               0001     	psg_lfofreq	=	$FF:0808, 1		; LFO Frequency
   73               0001     	psg_lfoctrl	=	$FF:0809, 1		; LFO Control
   74                        	
   75               0001     	irq_m		=	irq_vec, 1		; Old System Card name.
   76               0002     	irq2_jmp	=	irq2_hook, 2		; Old System Card name.
   77               0002     	irq1_jmp	=	irq1_hook, 2		; Old System Card name.
   78               0002     	timer_jmp	=	timer_hook, 2		; Old System Card name.
   79               0002     	nmi_jmp		=	nmi_hook, 2		; Old System Card name.
   80               0002     	sat_adr		=	satb_addr, 2		; Old System Card name.
   81               0005     	joy		=	joynow, 5		; Old System Card name.
   82               0001     	mwr_m		=	vdc_mwr, 1		; Old System Card name.
   83               0001     	dcr_m		=	vdc_dcr, 1		; Old System Card name.
   84                        		.endif
   85                        	
   86                        			; Macros for compatibility with #asm usage in old HuC projects.
   87                        	
   88                        	stw		.macro
   89                        			lda.l	\1
   90                        			sta.l	\2
   91                        			lda.h	\1
   92                        			sta.h	\2
   93                        			.endm
   94                        	
   95                        	stb		.macro
   96                        			lda	\1
   97                        			sta	\2
   98                        			.endm
   99                        	
  100                        	addw		.macro
  101                        		.if	(\# = 3)
  102                        			clc
  103                        			lda.l	\2
  104                        			adc.l	\1
  105                        			sta.l	\3
  106                        			lda.h	\2
  107                        			adc.h	\1
  108                        			sta.h	\3
  109                        		.else
  110                        			clc
  111                        			lda.l	\2
  112                        			adc.l	\1
  113                        			sta.l	\2
  114                        			lda.h	\2
  115                        			adc.h	\1
  116                        			sta.h	\2
  117                        		.endif
  118                        			.endm
  119                        	
  120                        	add		.macro			; add byte-sized value to
  121                        		.if (\# = 2)			; register A (handle carry
  122                        			lda	\2		; flag)
  123                        			clc
  124                        			adc	\1
  125                        			sta	\2
  126                        		.else
  127                        			clc
  128                        			adc	\1
  129                        		.endif
  130                        			.endm
  131                        	
  132                        	subw		.macro
  133                        			sec
  134                        			lda.l	\2
  135                        			sbc.l	\1
  136                        			sta.l	\2
  137                        			lda.h	\2
  138                        			sbc.h	\1
  139                        			sta.h	\2
  140                        			.endm
  141                        	
  142                        	sub		.macro			; subtract byte-sized value
  143                        		.if (\# = 2)			; from register A (handle
  144                        			lda	\2		; carry flag)
  145                        			sec
  146                        			sbc	\1
  147                        			sta	\2
  148                        		.else
  149                        			sec
  150                        			sbc	\1
  151                        		.endif
  152                        			.endm
  153                        	
  154                        	incw		.macro			; increment a word-sized
  155                        			inc.l	\1		; value at stated memory
  156                        			bne	!+		; location
  157                        			inc.h	\1
  158                        	!:
  159                        			.endm
  160                        	
  161                        	decw		.macro			; decrement a word-sized
  162                        			lda	\1		; value at stated memory
  163                        			bne	!+		; location
  164                        			dec.h	\1
  165                        	!:		dec.l	\1
  166                        			.endm
  167                        	
  168                        	lbne		.macro
  169                        			bne	\1
  170                        			.endm
  171                        	
  172                        	lbeq		.macro
  173                        			beq	\1
  174                        			.endm
  175                        	
  176                        	lbpl		.macro
  177                        			bpl	\1
  178                        			.endm
  179                        	
  180                        	lbmi		.macro
  181                        			bmi	\1
  182                        			.endm
  183                        	
  184                        	lbcc		.macro
  185                        			bcc	\1
  186                        			.endm
  187                        	
  188                        	lbcs		.macro
  189                        			bcs	\1
  190                        			.endm
  191                        	
  192                        	lblo		.macro
  193                        			bcc	\1
  194                        			.endm
  195                        	
  196                        	lbhs		.macro
  197                        			bcs	\1
  198                        			.endm
  199                        	
  200                        	__ldwi		.macro
  201                        		__ld.wi		\1
  202                        			.endm
                             #[2]   "..\..\..\include\hucc\hucc.asm"
  237                        		.endif
  238                        	
  239                        			;
  240                        			;
  241                        			;
  242                        	
  243                        	
  244                        	
  245                        	; ***************************************************************************
  246                        	; ***************************************************************************
  247                        	;
  248                        	; core_main - This is executed after "CORE(not TM)" library initialization.
  249                        	;
  250                        	; This is the first code assembled after the library includes, so we're still
  251                        	; in the CORE_BANK, usually ".bank 0"; and because this is assembled with the
  252                        	; default configuration from "include/core-config.inc", which sets the option
  253                        	; "USING_MPR7", then we're running in MPR7 ($E000-$FFFF).
  254                        	
  255    01:DF52             	core_main	.proc
  256                        	
  257               0001     		.if	SUPPORT_SGX
  258    01:DF52  A9 F9      			lda	#$F9			; Map the 2nd SGX RAM bank.
  259                        		.else
  261                        		.endif
  262    01:DF54  53 04      			tam2
  263                        	
  264    01:DF56  A9 01      			lda	#CONST_BANK + _bank_base; Map HuCC's .RODATA bank.
  265    01:DF58  53 08      			tam3
  266    01:DF5A  1A         			inc	a
  267    01:DF5B  53 10      			tam4
  268                        	
  269               0000     		.ifdef	HOME_BANK
  271                        		.else
  272    01:DF5D  1A         			inc	a
  273                        		.endif
  274    01:DF5E  53 20      			tam5
  275                        	
  276    01:DF60  08         			php				; Disable interrupts while
  277    01:DF61  78         			sei				; clearing overlay's BSS.
  278                        	
  279               0000     		.ifndef	USING_RCR_MACROS
  294                        		.endif	USING_RCR_MACROS
  295                        	
  296    01:DF62  A9 CC      			lda	#<hucc_vbl		; Setup HuCC's VBL IRQ handler.
  297    01:DF64  8D 08 22   			sta.l	vsync_hook
  298    01:DF67  A9 E2      			lda	#>hucc_vbl
  299    01:DF69  8D 09 22   			sta.h	vsync_hook
  300                        	
  301               0000     		.if	CDROM				; Overlays should clear BSS.
  303                        		.else
  304    01:DF6C  73 B9 DF F0			tii	.rom_tia, ram_tia, 16	; Only needed on HuCARD.
         01:DF70  22 10 00    
  305                        		.endif	CDROM
  306                        	
  307               0000     		.if	(__heap_start - __bss_init)	; Copy initialized BSS data.
  309                        		.endif
  310                        	
  311    01:DF73  F3 B7 DF 08			tai	.stack_fill, __stack, HUCC_STACK_SZ
         01:DF77  20 80 00    
  312                        	
  313               0000     		.if	FAST_MULTIPLY
  322                        		.endif
  323                        	
  324    01:DF7A  A9 10      			lda	#$10			; Enable HuCC's vblank IRQ
  325    01:DF7C  04 F5      			tsb	<irq_vec		; handler.
  326                        	
  327                        			__sound_init			; Initialize a sound driver.
  328                        	
  329    01:DF7E  AD 00 02   			lda	VDC_SR			; Purge any overdue VBL.
  330    01:DF81  9C 41 22   			stz	irq_cnt			; Make it easy to check.
  331                        	
  332    01:DF84  28         			plp				; Restore interrupts.
  333                        	
  334               0001     		.ifndef	HUCC_NO_DEFAULT_SCREEN
  335    01:DF85  20 D1 FF   			call	_init_256x224		; HuCC initializes the VDC and
  336    01:DF88  20 16 E4   			jsr	set_dspon		; turns the display on.
  337                        		.endif
  338                        	
  339               0001     		.ifndef	HUCC_NO_DEFAULT_FONT
  340    01:DF8B  A9 01      			lda	#1			; HuCC loads a default font.
  341    01:DF8D  8D 72 25   			sta	monofont_fg
  342    01:DF90  9C 73 25   			stz	monofont_bg
  343                        			_load_default_font
         01:DF93  82         			clx				; Offset to PCE VDC.
         01:DF94  20 C7 FF   			call	huc_monofont_x
  344    01:DF97  A9 01      			lda	#$01			; Set the font palette entry to
  345    01:DF99  8D 02 04   			sta.l	VCE_CTA			; cyan which is a) visible, but
  346    01:DF9C  9C 03 04   			stz.h	VCE_CTA			; b) a clear indicator that the
  347    01:DF9F  A0 96      			ldy	#$96			; user hasn't set a palette yet.
  348    01:DFA1  8C 04 04   			sty.l	VCE_CTW
  349    01:DFA4  8D 05 04   			sta.h	VCE_CTW
  350                        		.endif
  351                        	
  352               0001     		.ifndef	HUCC_NO_DEFAULT_RANDOM
  353    01:DFA7  AC 41 22   			ldy	irq_cnt			; Initialize random seed.
  354    01:DFAA  20 BD FF   			call	init_random
  355                        		.endif
  356                        	
  357    01:DFAD  A2 80      			ldx	#HUCC_STACK_SZ		; Initialize the HuCC stack.
  358    01:DFAF  86 8D      			stx	<__sp
  359                        	
  360    01:DFB1  20 B3 FF   			call	_main			; Execute the HuCC program.
  361                        	
  362    01:DFB4  4C 88 E2   			jmp	_exit.1			; Pass the exit code on.
  363                        	
  364    01:DFB7  EA EA      	.stack_fill:	db	$EA,$EA			; To make it easier to see.
  365                        	
  366               0001     		.if	!CDROM
  367                        	
  368    01:DFB9  E3 34 12 02	.rom_tia:	tia	$1234, VDC_DL, 32
         01:DFBD  02 20 00    
  369    01:DFC0  60         			rts
  370                        	
  371    01:DFC1  73 34 12 78	.rom_tii:	tii	$1234, $5678, $9ABC
         01:DFC5  56 BC 9A    
  372    01:DFC8  60         			rts
  373                        	
  374               22F0     			.bss
  375    F8:22F0             	ram_tia:	ds	8
  376    F8:22F8             	ram_tii:	ds	8
  377               DFC9     			.code
  378                        	
  379                        		.endif	!CDROM
  380                        	
  381                        			.endp
  382                        	
  383                        			;
  384                        			; Self-Modifying TIA and TII instruction subroutines.
  385                        			;
  386                        			; These need to be in permanently-accessible memory so that
  387                        			; HuCC code can modify the values as __fastcall parameters.
  388                        			;
  389                        	
  390               0000     		.if	CDROM
  398                        		.endif	CDROM
  399                        	
  400               22F0     			rsset	ram_tia
  401               22F0     	ram_tia_opc	rs	1
  402               22F1     	ram_tia_src	rs	2
  403               22F3     	ram_tia_dst	rs	2
  404               22F5     	ram_tia_len	rs	2
  405               22F7     	ram_tia_rts	rs	1
  406                        	
  407               22F8     			rsset	ram_tii
  408               22F8     	ram_tii_opc	rs	1
  409               22F9     	ram_tii_src	rs	2
  410               22FB     	ram_tii_dst	rs	2
  411               22FD     	ram_tii_len	rs	2
  412               22FF     	ram_tii_rts	rs	1
  413                        	
  414                        	
  415                        	
  416                        	; ***************************************************************************
  417                        	; ***************************************************************************
  418                        	;
  419                        	; hucc_vbl - vblank IRQ handler, called by the "CORE(not TM)" kernel.
  420                        	;
  421                        	; This uses the kernel's hook to process things during vblank. It returns
  422                        	; with a simple RTS, and it can corrupt any register.
  423                        	;
  424                        	; Any slow routines in here should enable interrupts and protect itself from
  425                        	; re-entrancy problems.
  426                        	;
  427                        	
  428    00:E2CC  20 A9 FF   	hucc_vbl:	call	vbl_init_scroll		; Prepare for the next frame.
  429                        	
  430    00:E2CF  F8         			sed				; Update the HuC system clock
  431    00:E2D0  38         			sec				; which is in BCD here rather
  432    00:E2D1  AD EF 22   			lda	clock_tt		; than the binary one in HuC.
  433    00:E2D4  69 00      			adc	#0			; BCD add ...
  434    00:E2D6  C9 60      			cmp	#$60			; ... but binary comparison.
  435    00:E2D8  90 28      			bcc	.ticks
  436    00:E2DA  AD EE 22   			lda	clock_ss
  437    00:E2DD  69 00      			adc	#0			; BCD add ...
  438    00:E2DF  C9 60      			cmp	#$60			; ... but binary comparison.
  439    00:E2E1  90 1B      			bcc	.seconds
  440    00:E2E3  AD ED 22   			lda	clock_mm
  441    00:E2E6  69 00      			adc	#0			; BCD add ...
  442    00:E2E8  C9 60      			cmp	#$60			; ... but binary comparison.
  443    00:E2EA  90 0E      			bcc	.minutes
  444    00:E2EC  AD EC 22   			lda	clock_hh
  445    00:E2EF  69 00      			adc	#0			; BCD add ...
  446    00:E2F1  C9 12      			cmp	#$12			; ... but binary comparison.
  447    00:E2F3  90 01      			bcc	.hours
  448    00:E2F5  62         			cla
  449    00:E2F6  8D EC 22   	.hours:		sta	clock_hh
  450    00:E2F9  62         			cla
  451    00:E2FA  8D ED 22   	.minutes:	sta	clock_mm
  452    00:E2FD  62         			cla
  453    00:E2FE  8D EE 22   	.seconds:	sta	clock_ss
  454    00:E301  62         			cla
  455    00:E302  8D EF 22   	.ticks:		sta	clock_tt
  456    00:E305  D8         			cld
  457                        	
  458    00:E306  4C 96 E3   			jmp	xfer_palettes		; Upload any palette changes.
                             #[1]   "main.s"
   15               6000     			.data
   16               0003     			.bank	DATA_BANK
   17                        	
   18               E309     		.code
   19                        	
   20                        		.dbg	line,	"..\..\..\include\hucc\globals.h", 1; // **************************************************************************
   21                        		.dbg	line,	"..\..\..\include\hucc\globals.h", 2; // **************************************************************************
   22                        		.dbg	line,	"..\..\..\include\hucc\globals.h", 3; //
   23                        		.dbg	line,	"..\..\..\include\hucc\globals.h", 4; // globals.h
   24                        		.dbg	line,	"..\..\..\include\hucc\globals.h", 5; //
   25                        		.dbg	line,	"..\..\..\include\hucc\globals.h", 6; // **************************************************************************
   26                        		.dbg	line,	"..\..\..\include\hucc\globals.h", 7; // **************************************************************************
   27                        		.dbg	line,	"..\..\..\include\hucc\globals.h", 8; //
   28                        		.dbg	line,	"..\..\..\include\hucc\globals.h", 9; // The idea is that you, a PCE developer, copy this file from the ../include/
   29                        		.dbg	line,	"..\..\..\include\hucc\globals.h", 10; // directory and into your project's directory, and then define the variables
   30                        		.dbg	line,	"..\..\..\include\hucc\globals.h", 11; // that you want to have shared access to in all overlay programs on your CD.
   31                        		.dbg	line,	"..\..\..\include\hucc\globals.h", 12; //
   32                        		.dbg	line,	"..\..\..\include\hucc\globals.h", 13; // Because PCEAS searches the current (i.e. project) directory for an include
   33                        		.dbg	line,	"..\..\..\include\hucc\globals.h", 14; // file first, then it will find your customized copy of the file rather than
   34                        		.dbg	line,	"..\..\..\include\hucc\globals.h", 15; // the original copy in the ../include/ directory.
   35                        		.dbg	line,	"..\..\..\include\hucc\globals.h", 16; //
   36                        		.dbg	line,	"..\..\..\include\hucc\globals.h", 17; // **************************************************************************
   37                        		.dbg	line,	"..\..\..\include\hucc\globals.h", 18; // **************************************************************************
   38                        		.dbg	clear
   39               2300     		.bss
   40    F8:2300             	huc_globals:
   41                        	
   42    F8:2300             	huc_globals_end:
   43               E309     		.code
   44                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 1; #ifndef _hucc_legacy_h
   45                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 2; #define _hucc_legacy_h
   46                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 4; /****************************************************************************
   47                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 5; ; ***************************************************************************
   48                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 6; ;
   49                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 7; ; huc.h
   50                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 8; ;
   51                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 9; ; HuCC wrapper file to include a default set of HuC-compatible functions.
   52                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 10; ;
   53                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 11; ; Copyright John Brandwood 2024.
   54                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 12; ;
   55                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 13; ; Distributed under the Boost Software License, Version 1.0.
   56                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 14; ; (See accompanying file LICENSE_1_0.txt or copy at
   57                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 15; ;  http://www.boost.org/LICENSE_1_0.txt)
   58                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 16; ;
   59                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 17; ; ***************************************************************************
   60                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 18; ; ***************************************************************************
   61                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 19; ;
   62                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 20; ; When the HuCC compiler is invoked with the "--legacy" option to compile old
   63                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 21; ; projects, then this "huc.h" file is automatically included.
   64                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 22; ;
   65                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 23; ; This file includes a set of the individual HuCC headers which correspond to
   66                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 24; ; HuC's built-in functions and MagicKit library.
   67                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 25; ;
   68                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 26; ; New HuCC projects should, preferably, include the specific headers that are
   69                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 27; ; needed, which will then allow them to replace parts of the standard library
   70                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 28; ; with newer functions, or they can just manually include this "huc.h" file.
   71                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 29; ;
   72                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 30; ; ***************************************************************************
   73                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 31; ; **************************************************************************/
   74                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 33; #include "hucc-systemcard.h"
   75                        		.dbg	line,	"..\..\..\include\hucc\hucc-systemcard.h", 1; #ifndef _hucc_systemcard_h
   76                        		.dbg	line,	"..\..\..\include\hucc\hucc-systemcard.h", 2; #define _hucc_systemcard_h
   77                        		.dbg	line,	"..\..\..\include\hucc\hucc-systemcard.h", 4; /****************************************************************************
   78                        		.dbg	line,	"..\..\..\include\hucc\hucc-systemcard.h", 5; ; ***************************************************************************
   79                        		.dbg	line,	"..\..\..\include\hucc\hucc-systemcard.h", 6; ;
   80                        		.dbg	line,	"..\..\..\include\hucc\hucc-systemcard.h", 7; ; hucc-systemcard.h
   81                        		.dbg	line,	"..\..\..\include\hucc\hucc-systemcard.h", 8; ;
   82                        		.dbg	line,	"..\..\..\include\hucc\hucc-systemcard.h", 9; ; Macros and library functions for using the System Card.
   83                        		.dbg	line,	"..\..\..\include\hucc\hucc-systemcard.h", 10; ;
   84                        		.dbg	line,	"..\..\..\include\hucc\hucc-systemcard.h", 11; ; Copyright John Brandwood 2024.
   85                        		.dbg	line,	"..\..\..\include\hucc\hucc-systemcard.h", 12; ;
   86                        		.dbg	line,	"..\..\..\include\hucc\hucc-systemcard.h", 13; ; Distributed under the Boost Software License, Version 1.0.
   87                        		.dbg	line,	"..\..\..\include\hucc\hucc-systemcard.h", 14; ; (See accompanying file LICENSE_1_0.txt or copy at
   88                        		.dbg	line,	"..\..\..\include\hucc\hucc-systemcard.h", 15; ;  http://www.boost.org/LICENSE_1_0.txt)
   89                        		.dbg	line,	"..\..\..\include\hucc\hucc-systemcard.h", 16; ;
   90                        		.dbg	line,	"..\..\..\include\hucc\hucc-systemcard.h", 17; ; ***************************************************************************
   91                        		.dbg	line,	"..\..\..\include\hucc\hucc-systemcard.h", 18; ; ***************************************************************************
   92                        		.dbg	line,	"..\..\..\include\hucc\hucc-systemcard.h", 19; ;
   93                        		.dbg	line,	"..\..\..\include\hucc\hucc-systemcard.h", 20; ; Because these are mainly macros, and so must be included before being used
   94                        		.dbg	line,	"..\..\..\include\hucc\hucc-systemcard.h", 21; ; in compiled code, the actual functions here are written to avoid using any
   95                        		.dbg	line,	"..\..\..\include\hucc\hucc-systemcard.h", 22; ; BSS memory so that HuCC's overlay global-shared-variables are not effected.
   96                        		.dbg	line,	"..\..\..\include\hucc\hucc-systemcard.h", 23; ;
   97                        		.dbg	line,	"..\..\..\include\hucc\hucc-systemcard.h", 24; ; ***************************************************************************
   98                        		.dbg	line,	"..\..\..\include\hucc\hucc-systemcard.h", 25; ; **************************************************************************/
   99                        		.dbg	line,	"..\..\..\include\hucc\hucc-systemcard.h", 27; // *************
  100                        		.dbg	line,	"..\..\..\include\hucc\hucc-systemcard.h", 28; // Backup RAM defines ...
  101                        		.dbg	line,	"..\..\..\include\hucc\hucc-systemcard.h", 29; // *************
  102                        		.dbg	line,	"..\..\..\include\hucc\hucc-systemcard.h", 31; #define  BM_OK             0
  103                        		.dbg	line,	"..\..\..\include\hucc\hucc-systemcard.h", 32; #define  BM_NOT_FOUND      1
  104                        		.dbg	line,	"..\..\..\include\hucc\hucc-systemcard.h", 33; #define  BM_BAD_CHECKSUM   2
  105                        		.dbg	line,	"..\..\..\include\hucc\hucc-systemcard.h", 34; #define  BM_DIR_CORRUPTED  3
  106                        		.dbg	line,	"..\..\..\include\hucc\hucc-systemcard.h", 35; #define  BM_FILE_EMPTY     4
  107                        		.dbg	line,	"..\..\..\include\hucc\hucc-systemcard.h", 36; #define  BM_FULL           5
  108                        		.dbg	line,	"..\..\..\include\hucc\hucc-systemcard.h", 37; #define  BM_NOT_FORMATED   0xFF			// HuC incorrect spelling.
  109                        		.dbg	line,	"..\..\..\include\hucc\hucc-systemcard.h", 38; #define  BM_NOT_FORMATTED  0xFF			// HuCC can use a dictionary!
  110                        		.dbg	line,	"..\..\..\include\hucc\hucc-systemcard.h", 40; #define  BRAM_STARTPTR     0x8010
  111                        		.dbg	line,	"..\..\..\include\hucc\hucc-systemcard.h", 42; // *************
  112                        		.dbg	line,	"..\..\..\include\hucc\hucc-systemcard.h", 43; // CD defines ...
  113                        		.dbg	line,	"..\..\..\include\hucc\hucc-systemcard.h", 44; // *************
  114                        		.dbg	line,	"..\..\..\include\hucc\hucc-systemcard.h", 46; #define	CDPLAY_MUTE		0
  115                        		.dbg	line,	"..\..\..\include\hucc\hucc-systemcard.h", 47; #define	CDPLAY_REPEAT		1
  116                        		.dbg	line,	"..\..\..\include\hucc\hucc-systemcard.h", 48; #define	CDPLAY_NORMAL		2
  117                        		.dbg	line,	"..\..\..\include\hucc\hucc-systemcard.h", 49; #define	CDPLAY_ENDOFDISC	0
  118                        		.dbg	line,	"..\..\..\include\hucc\hucc-systemcard.h", 51; #define	CDFADE_CANCEL	0
  119                        		.dbg	line,	"..\..\..\include\hucc\hucc-systemcard.h", 52; #define	CDFADE_PCM6	8
  120                        		.dbg	line,	"..\..\..\include\hucc\hucc-systemcard.h", 53; #define	CDFADE_ADPCM6	10
  121                        		.dbg	line,	"..\..\..\include\hucc\hucc-systemcard.h", 54; #define	CDFADE_PCM2	12
  122                        		.dbg	line,	"..\..\..\include\hucc\hucc-systemcard.h", 55; #define	CDFADE_ADPCM2	14
  123                        		.dbg	line,	"..\..\..\include\hucc\hucc-systemcard.h", 57; #define CDTRK_AUDIO	0
  124                        		.dbg	line,	"..\..\..\include\hucc\hucc-systemcard.h", 58; #define CDTRK_DATA	4
  125                        		.dbg	line,	"..\..\..\include\hucc\hucc-systemcard.h", 60; // *************
  126                        		.dbg	line,	"..\..\..\include\hucc\hucc-systemcard.h", 61; // ADPCM defines ...
  127                        		.dbg	line,	"..\..\..\include\hucc\hucc-systemcard.h", 62; // *************
  128                        		.dbg	line,	"..\..\..\include\hucc\hucc-systemcard.h", 64; #define	ADPLAY_AUTOSTOP		0
  129                        		.dbg	line,	"..\..\..\include\hucc\hucc-systemcard.h", 65; #define	ADPLAY_REPEAT		0x80
  130                        		.dbg	line,	"..\..\..\include\hucc\hucc-systemcard.h", 67; #define ADPLAY_FREQ_16KHZ	0xE
  131                        		.dbg	line,	"..\..\..\include\hucc\hucc-systemcard.h", 68; #define ADPLAY_FREQ_10KHZ	0xD
  132                        		.dbg	line,	"..\..\..\include\hucc\hucc-systemcard.h", 69; #define ADPLAY_FREQ_8KHZ	0xC
  133                        		.dbg	line,	"..\..\..\include\hucc\hucc-systemcard.h", 70; #define ADPLAY_FREQ_6KHZ	0xB
  134                        		.dbg	line,	"..\..\..\include\hucc\hucc-systemcard.h", 71; #define ADPLAY_FREQ_5KHZ	0xA
  135                        		.dbg	line,	"..\..\..\include\hucc\hucc-systemcard.h", 73; #define ADREAD_RAM	0
  136                        		.dbg	line,	"..\..\..\include\hucc\hucc-systemcard.h", 74; #define ADREAD_VRAM	0xFF
  137                        		.dbg	line,	"..\..\..\include\hucc\hucc-systemcard.h", 76; #define ADWRITE_RAM	0
  138                        		.dbg	line,	"..\..\..\include\hucc\hucc-systemcard.h", 77; #define ADWRITE_VRAM	0xFF
  139                        		.dbg	line,	"..\..\..\include\hucc\hucc-systemcard.h", 79; // *************
  140                        		.dbg	line,	"..\..\..\include\hucc\hucc-systemcard.h", 80; // Functions in hucc-systemcard.asm ...
  141                        		.dbg	line,	"..\..\..\include\hucc\hucc-systemcard.h", 81; // *************
  142                        		.dbg	line,	"..\..\..\include\hucc\hucc-systemcard.h", 83; #ifdef __HUCC__
  143                        		.dbg	line,	"..\..\..\include\hucc\hucc-systemcard.h", 85; #asmdef	HUCC_USES_SYSTEMCARD 1
  144               0001     	HUCC_USES_SYSTEMCARD = 1
  145                        		.dbg	line,	"..\..\..\include\hucc\hucc-systemcard.h", 87; extern void __fastcall __macro cd_boot( void );
  146                        		.dbg	line,	"..\..\..\include\hucc\hucc-systemcard.h", 88; extern unsigned int __fastcall __macro cd_getver( void );
  147                        		.dbg	line,	"..\..\..\include\hucc\hucc-systemcard.h", 89; extern void __fastcall __macro cd_reset( void );
  148                        		.dbg	line,	"..\..\..\include\hucc\hucc-systemcard.h", 90; extern unsigned char __fastcall __macro cd_pause( void );
  149                        		.dbg	line,	"..\..\..\include\hucc\hucc-systemcard.h", 91; extern unsigned char __fastcall cd_unpause( void );
  150                        		.dbg	line,	"..\..\..\include\hucc\hucc-systemcard.h", 92; extern void __fastcall __macro cd_fade( unsigned char type<acc> );
  151                        		.dbg	line,	"..\..\..\include\hucc\hucc-systemcard.h", 93; extern unsigned char __fastcall cd_playtrk( unsigned char start_track<_bx>, unsigned char end_track<_cx>, unsigned char mode<_dh> );
  152                        		.dbg	line,	"..\..\..\include\hucc\hucc-systemcard.h", 94; extern unsigned char __fastcall cd_playmsf( unsigned char start_minute<_al>,  unsigned char start_second<_ah>,  unsigned char start_frame<_bl>, unsigned char end_minute<_cl>,  unsigned char end_second<_ch>,  unsigned char end_frame<_dl>,  unsigned char mode<_dh> );
  153                        		.dbg	line,	"..\..\..\include\hucc\hucc-systemcard.h", 95; extern unsigned char __fastcall cd_fastvram( unsigned char ovl_index<_cl>, unsigned int sect_offset<_si>, unsigned int vramaddr<_bx>, unsigned int sectors<_al> );
  154                        		.dbg	line,	"..\..\..\include\hucc\hucc-systemcard.h", 96; extern unsigned char __fastcall cd_loadvram( unsigned char ovl_index<_cl>, unsigned int sect_offset<_si>, unsigned int vramaddr<_bx>, unsigned int bytes<_ax> );
  155                        		.dbg	line,	"..\..\..\include\hucc\hucc-systemcard.h", 97; extern unsigned char __fastcall cd_loaddata( unsigned char ovl_index<_cl>, unsigned int sect_offset<_si>, unsigned char __far *buffer<_bp_bank:_bp>, unsigned int bytes<__ptr> );
  156                        		.dbg	line,	"..\..\..\include\hucc\hucc-systemcard.h", 98; extern unsigned char __fastcall cd_loadbank( unsigned char ovl_index<_cl>, unsigned int sect_offset<_si>, unsigned char bank<_bl>, unsigned int sectors<_al> );
  157                        		.dbg	line,	"..\..\..\include\hucc\hucc-systemcard.h", 99; extern unsigned char __fastcall __macro cd_status( unsigned char mode<acc> );
  158                        		.dbg	line,	"..\..\..\include\hucc\hucc-systemcard.h", 101; extern void __fastcall __macro ad_reset( void );
  159                        		.dbg	line,	"..\..\..\include\hucc\hucc-systemcard.h", 102; extern unsigned char __fastcall __macro ad_trans( unsigned char ovl_index<_cl>, unsigned int sect_offset<_si>, unsigned char nb_sectors<_dh>, unsigned int ad_addr<_bx> );
  160                        		.dbg	line,	"..\..\..\include\hucc\hucc-systemcard.h", 103; extern void __fastcall __macro ad_read( unsigned int ad_addr<_cx>, unsigned char mode<_dh>, unsigned int buf<_bx>, unsigned int bytes<_ax> );
  161                        		.dbg	line,	"..\..\..\include\hucc\hucc-systemcard.h", 104; extern void __fastcall __macro ad_write( unsigned int ad_addr<_cx>, unsigned char mode<_dh>, unsigned int buf<_bx>, unsigned int bytes<_ax> );
  162                        		.dbg	line,	"..\..\..\include\hucc\hucc-systemcard.h", 105; extern unsigned char __fastcall __macro ad_play( unsigned int ad_addr<_bx>, unsigned int bytes<_ax>, unsigned char freq<_dh>, unsigned char mode<_dl> );
  163                        		.dbg	line,	"..\..\..\include\hucc\hucc-systemcard.h", 106; extern unsigned char __fastcall __macro ad_cplay( unsigned char ovl_index<_cl>, unsigned int sect_offset<_si>, unsigned int nb_sectors<_bx>, unsigned char freq<_dh> );
  164                        		.dbg	line,	"..\..\..\include\hucc\hucc-systemcard.h", 107; extern void __fastcall __macro ad_stop( void );
  165                        		.dbg	line,	"..\..\..\include\hucc\hucc-systemcard.h", 108; extern unsigned char __fastcall __macro ad_stat( void );
  166                        		.dbg	line,	"..\..\..\include\hucc\hucc-systemcard.h", 110; extern unsigned char __fastcall bm_check( void );
  167                        		.dbg	line,	"..\..\..\include\hucc\hucc-systemcard.h", 111; extern unsigned char __fastcall bm_format( void );
  168                        		.dbg	line,	"..\..\..\include\hucc\hucc-systemcard.h", 112; extern unsigned int __fastcall __macro bm_free( void );
  169                        		.dbg	line,	"..\..\..\include\hucc\hucc-systemcard.h", 113; extern unsigned char __fastcall __macro bm_read( unsigned char *buffer<_bx>, unsigned char *name<_ax>, unsigned int offset<_dx>, unsigned int length<_cx> );
  170                        		.dbg	line,	"..\..\..\include\hucc\hucc-systemcard.h", 114; extern unsigned char __fastcall __macro bm_write( unsigned char *buffer<_bx>, unsigned char *name<_ax>, unsigned int offset<_dx>, unsigned int length<_cx> );
  171                        		.dbg	line,	"..\..\..\include\hucc\hucc-systemcard.h", 115; extern unsigned char __fastcall __macro bm_delete( unsigned char *name<_ax> );
  172                        		.dbg	line,	"..\..\..\include\hucc\hucc-systemcard.h", 117; // Deprecated functions ...
  173                        		.dbg	line,	"..\..\..\include\hucc\hucc-systemcard.h", 119; extern unsigned char __fastcall __macro bm_exist( unsigned char *name<_ax> );
  174                        		.dbg	line,	"..\..\..\include\hucc\hucc-systemcard.h", 120; extern unsigned char __fastcall __macro bm_create( unsigned char *name<_ax>, unsigned int length<_cx> );
  175                        		.dbg	line,	"..\..\..\include\hucc\hucc-systemcard.h", 122; // void __fastcall _xsafe add_sectors( unsigned int sector_offset<acc> );
  176                        		.dbg	line,	"..\..\..\include\hucc\hucc-systemcard.h", 124; #endif // __HUCC__
  177                        		.dbg	line,	"..\..\..\include\hucc\hucc-systemcard.h", 126; #endif // _hucc_systemcard_h
  178                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 34; #include "hucc-baselib.h"
  179                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 1; #ifndef _hucc_baselib_h
  180                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 2; #define _hucc_baselib_h
  181                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 4; /****************************************************************************
  182                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 5; ; ***************************************************************************
  183                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 6; ;
  184                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 7; ; hucc-baselib.h
  185                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 8; ;
  186                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 9; ; Basic library functions provided as macros.
  187                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 10; ;
  188                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 11; ; Copyright John Brandwood 2024.
  189                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 12; ;
  190                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 13; ; Distributed under the Boost Software License, Version 1.0.
  191                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 14; ; (See accompanying file LICENSE_1_0.txt or copy at
  192                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 15; ;  http://www.boost.org/LICENSE_1_0.txt)
  193                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 16; ;
  194                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 17; ; ***************************************************************************
  195                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 18; ; **************************************************************************/
  196                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 20; // *************
  197                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 21; // Joypad defines ...
  198                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 22; // *************
  199                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 24; #define	JOY_A		0x01
  200                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 25; #define	JOY_I		0x01
  201                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 26; #define	JOY_B		0x02
  202                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 27; #define	JOY_II		0x02
  203                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 28; #define	JOY_SLCT	0x04
  204                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 29; #define	JOY_SEL		0x04
  205                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 30; #define	JOY_STRT	0x08
  206                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 31; #define	JOY_RUN		0x08
  207                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 32; #define	JOY_UP		0x10
  208                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 33; #define	JOY_RGHT	0x20
  209                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 34; #define	JOY_RIGHT	0x20
  210                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 35; #define	JOY_DOWN	0x40
  211                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 36; #define	JOY_LEFT	0x80
  212                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 38; #define	JOY_C		0x0100
  213                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 39; #define	JOY_III		0x0100
  214                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 40; #define	JOY_D		0x0200
  215                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 41; #define	JOY_IV		0x0200
  216                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 42; #define	JOY_E		0x0400
  217                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 43; #define	JOY_V		0x0400
  218                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 44; #define	JOY_F		0x0800
  219                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 45; #define	JOY_VI		0x0800
  220                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 47; #define JOY_SIXBUT	0x8000
  221                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 48; #define JOY_TYPE6	0x8000
  222                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 50; // *************
  223                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 51; // SuperGRAFX VPC settings for set_vpc_ctl() ...
  224                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 52; // *************
  225                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 54; #define VPC_SPR1_BKG1_SPR2_BKG2	0x3000 // same as SGX_PARALLAX=0
  226                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 55; #define VPC_SPR1_SPR2_BKG1_BKG2	0x7000 // same as SGX_PARALLAX=1
  227                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 56; #define VPC_BKG1_BKG2_SPR1_SPR2	0xB000
  228                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 58; // *************
  229                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 59; // System Card variables ...
  230                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 60; // *************
  231                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 62; extern unsigned int si;
  232                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 63; extern unsigned int di;
  233                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 64; extern unsigned int bp;
  234                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 66; extern unsigned int ax;
  235                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 67; extern unsigned int bx;
  236                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 68; extern unsigned int cx;
  237                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 69; extern unsigned int dx;
  238                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 71; extern unsigned char al;
  239                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 72; extern unsigned char ah;
  240                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 73; extern unsigned char bl;
  241                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 74; extern unsigned char bh;
  242                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 75; extern unsigned char cl;
  243                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 76; extern unsigned char ch;
  244                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 77; extern unsigned char dl;
  245                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 78; extern unsigned char dh;
  246                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 80; extern unsigned char irq_cnt;
  247                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 81; extern unsigned char joynow[5];
  248                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 82; extern unsigned char joytrg[5];
  249                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 83; extern unsigned char joy6now[5];
  250                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 84; extern unsigned char joy6trg[5];
  251                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 85; extern unsigned int  bg_x1;
  252                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 86; extern unsigned int  bg_y1;
  253                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 87; extern unsigned int  bg_x2;
  254                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 88; extern unsigned int  bg_y2;
  255                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 90; // *************
  256                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 91; // Special macros to get information from PCEAS ...
  257                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 92; // *************
  258                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 94; #define BANK( datasym ) ((unsigned) (&__bank__ ## datasym))
  259                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 95; #define SIZEOF( datasym ) ((unsigned) (&__sizeof__ ## datasym))
  260                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 96; #define COUNTOF( datasym ) ((unsigned) (&__countof__ ## datasym))
  261                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 97; #define OVERLAY( datasym ) ((unsigned) (&__overlay__ ## datasym))
  262                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 100; // *************
  263                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 101; // Functions in hucc-baselib.asm ...
  264                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 102; // *************
  265                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 104; #ifdef __HUCC__
  266                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 106; #asmdef	HUCC_USES_BASELIB 1
  267               0001     	HUCC_USES_BASELIB = 1
  268                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 108; #define	_OPTIMIZE 1
  269                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 111; // *************
  270                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 112; // Hardware Detection
  271                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 113; // *************
  272                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 115; extern unsigned char __fastcall __macro sgx_detect( void );
  273                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 116; extern unsigned char __fastcall __macro ac_exists( void );
  274                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 119; // *************
  275                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 120; // Memory Access
  276                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 121; // *************
  277                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 123; extern unsigned char __fastcall __macro peek( unsigned int addr<__ptr> );
  278                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 124; extern unsigned int  __fastcall __macro peekw( unsigned int addr<__ptr> );
  279                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 126; extern void __fastcall __macro poke( unsigned int addr<__poke>, unsigned char with<acc> );
  280                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 127; extern void __fastcall __macro pokew( unsigned int addr<__poke>, unsigned int with<acc> );
  281                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 129; extern unsigned char __fastcall farpeek( void __far *addr<_bp_bank:_bp> );
  282                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 130; extern unsigned int  __fastcall farpeekw( void __far *addr<_bp_bank:_bp> );
  283                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 132; extern void __fastcall __nop set_far_base( unsigned char data_bank<_bp_bank>, unsigned char *data_addr<_bp> );
  284                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 133; extern void __fastcall set_far_offset( unsigned int offset<_bp>, unsigned char data_bank<_bp_bank>, unsigned char *data_addr<acc> );
  285                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 135; extern unsigned char __fastcall far_peek( void );
  286                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 136; extern unsigned int  __fastcall far_peekw( void );
  287                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 138; extern void __fastcall __macro reset_mpr2( void );
  288                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 139; extern void __fastcall __macro reset_mpr34( void );
  289                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 141; extern void * __fastcall __macro farset_mpr2( void __far *addr<_bp_bank:_bp> );
  290                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 142; extern void * __fastcall __macro farset_mpr34( void __far *addr<_bp_bank:_bp> );
  291                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 144; extern void * __fastcall __macro far_set_mpr2( void );
  292                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 145; extern void * __fastcall __macro far_set_mpr34( void );
  293                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 148; // *************
  294                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 149; // Clock Functions
  295                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 150; // *************
  296                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 152; extern unsigned char __fastcall __macro clock_hh( void );
  297                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 153; extern unsigned char __fastcall __macro clock_mm( void );
  298                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 154; extern unsigned char __fastcall __macro clock_ss( void );
  299                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 155; extern unsigned char __fastcall __macro clock_tt( void );
  300                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 156; extern void __fastcall __macro clock_reset( void );
  301                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 159; // *************
  302                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 160; // Joypad Functions
  303                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 161; // *************
  304                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 163; extern unsigned int __fastcall __macro joy( unsigned char which<acc> );
  305                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 164; extern unsigned int __fastcall __macro joytrg( unsigned char which<acc> );
  306                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 167; // *************
  307                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 168; // Number Functions
  308                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 169; // *************
  309                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 171; extern int __fastcall abs( int value<acc> );
  310                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 173; extern void __fastcall __macro srand( unsigned char seed<acc> );
  311                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 174; extern unsigned int __fastcall rand( void );
  312                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 175; extern unsigned char __fastcall rand8( void );
  313                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 177; // Note: "limit" is 0..255.
  314                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 178; extern unsigned char __fastcall random8( unsigned char limit<acc> );
  315                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 180; // Note: "limit" is 0..128, 129..255 are treated as 128!
  316                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 181; extern unsigned char __fastcall random( unsigned char limit<acc> );
  317                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 184; // *************
  318                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 185; // Overlay Execution
  319                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 186; // *************
  320                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 188; extern unsigned char __fastcall __macro cd_execoverlay( unsigned char ovl_index<acc> );
  321                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 191; // *************
  322                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 192; // Functions that are only optionally available if configured in your hucc-config.inc
  323                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 193; // *************
  324                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 195; extern unsigned int __fastcall __macro joybuf( unsigned char which<acc> );
  325                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 196; extern unsigned int __fastcall __macro get_joy_events( unsigned char which<acc> );
  326                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 197; extern void __fastcall __macro clear_joy_events( unsigned char mask<acc> );
  327                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 200; // *************
  328                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 201; // Functions that are only implemented in the TGEMU emulator for unit-testing
  329                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 202; // the compiler, and which should never be used in normal HuCC projects ...
  330                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 203; // *************
  331                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 205; extern void __fastcall dump_screen( void );
  332                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 206; extern void __fastcall abort( void );
  333                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 207; extern void __fastcall exit( int value<acc> );
  334                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 209; extern unsigned char __fastcall __builtin_ffs( unsigned int value<__temp> );
  335                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 211; #endif // __HUCC__
  336                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 213; #endif // _hucc_baselib_h
  337                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 35; #include "hucc-gfx.h"
  338                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 1; #ifndef _hucc_gfx_h
  339                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 2; #define _hucc_gfx_h
  340                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 4; /****************************************************************************
  341                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 5; ; ***************************************************************************
  342                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 6; ;
  343                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 7; ; huc-gfx.h
  344                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 8; ;
  345                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 9; ; Based on the original HuC and MagicKit functions by David Michel and the
  346                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 10; ; other original HuC developers.
  347                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 11; ;
  348                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 12; ; Modifications copyright John Brandwood 2024.
  349                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 13; ;
  350                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 14; ; Distributed under the Boost Software License, Version 1.0.
  351                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 15; ; (See accompanying file LICENSE_1_0.txt or copy at
  352                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 16; ;  http://www.boost.org/LICENSE_1_0.txt)
  353                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 17; ;
  354                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 18; ; ***************************************************************************
  355                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 19; ; **************************************************************************/
  356                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 21; // *************
  357                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 22; // Screen defines ...
  358                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 23; // *************
  359                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 25; #define	SCR_SIZE_32x32	0
  360                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 26; #define	SCR_SIZE_64x32	1
  361                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 27; #define	SCR_SIZE_128x32	2
  362                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 28; #define	SCR_SIZE_32x64	4
  363                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 29; #define	SCR_SIZE_64x64	5
  364                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 30; #define	SCR_SIZE_128x64	6
  365                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 32; #define	XRES_SHARP	0
  366                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 33; #define	XRES_SOFT	4
  367                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 34; #define	XRES_KEEP	128
  368                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 36; #define VPC_WIN_A	0x00
  369                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 37; #define VPC_WIN_B	0x01
  370                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 38; #define	VPC_WIN_AB	0x02
  371                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 39; #define	VPC_WIN_NONE	0x03
  372                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 40; #define	VPC_NORM	0x00
  373                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 41; #define	VPC_SPR		0x04
  374                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 42; #define	VPC_INV_SPR	0x08
  375                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 43; #define VDC1_ON		0x01
  376                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 44; #define	VDC1_OFF	0x00
  377                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 45; #define VDC2_ON		0x02
  378                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 46; #define	VDC2_OFF	0x00
  379                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 47; #define VDC_ON		0x03
  380                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 48; #define	VDC_OFF		0x00
  381                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 50; // *************
  382                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 51; // Functions in hucc-gfx.asm ...
  383                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 52; // *************
  384                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 54; #ifdef __HUCC__
  385                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 56; #asmdef	HUCC_USES_GFX 1
  386               0001     	HUCC_USES_GFX = 1
  387                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 58; // *************
  388                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 59; // Color and Palette Functions
  389                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 60; // *************
  390                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 62; extern void __fastcall clear_palette( void );
  391                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 64; extern void __fastcall __nop set_color( unsigned int index<VCE_CTA>, unsigned int value<VCE_CTW> );
  392                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 65; extern void __fastcall set_color_rgb( unsigned int index<VCE_CTA>, unsigned char r<_al>, unsigned char g<_ah>, unsigned char b<acc> );
  393                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 66; extern unsigned int __fastcall __macro get_color( unsigned int index<VCE_CTA> );
  394                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 68; extern void __fastcall load_palette( unsigned char palette<_al>, unsigned char __far *data<_bp_bank:_bp>, unsigned char num_palettes<_ah> );
  395                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 69; extern void __fastcall far_load_palette( unsigned char palette<_al>, unsigned char num_palettes<_ah> );
  396                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 71; extern void __fastcall read_palette( unsigned char palette<_al>, unsigned char num_palettes<_ah>, unsigned int *destination<_di> );
  397                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 73; extern void __fastcall __macro fade_to_black( unsigned int __far *from<_bp_bank:_bp>, unsigned int *destination<_di>, unsigned char num_colors<_al>, unsigned char value_to_sub<_ah> );
  398                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 74; extern void __fastcall __macro fade_to_white( unsigned int __far *from<_bp_bank:_bp>, unsigned int *destination<_di>, unsigned char num_colors<_al>, unsigned char value_to_add<_ah> );
  399                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 75; extern void __fastcall __macro cross_fade_to( unsigned int __far *from<_bp_bank:_bp>, unsigned int *destination<_di>, unsigned char num_colors<_al>, unsigned char which_component<_ah> );
  400                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 77; extern void __fastcall __macro far_fade_to_black( unsigned int *destination<_di>, unsigned char num_colors<_al>, unsigned char value_to_sub<_ah> );
  401                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 78; extern void __fastcall __macro far_fade_to_white( unsigned int *destination<_di>, unsigned char num_colors<_al>, unsigned char value_to_add<_ah> );
  402                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 79; extern void __fastcall __macro far_cross_fade_to( unsigned int *destination<_di>, unsigned char num_colors<_al>, unsigned char which_component<_ah> );
  403                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 83; // *************
  404                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 84; // Video Functions
  405                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 85; // *************
  406                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 87; extern void __fastcall init_240x208( void );
  407                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 88; extern void __fastcall init_256x224( void );
  408                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 90; extern void __fastcall vsync( void );
  409                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 91; extern void __fastcall vsync( unsigned char count<_al> );
  410                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 93; extern void __fastcall disp_on( void );
  411                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 94; extern void __fastcall disp_off( void );
  412                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 96; extern void __fastcall set_screen_size( unsigned char value<_al> );
  413                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 98; extern void __fastcall set_xres( unsigned int x_pixels<_ax>, unsigned char blur_flag<_bl> );
  414                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 100; extern void __fastcall cls( void );
  415                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 101; extern void __fastcall cls( unsigned int tile<acc> );
  416                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 103; extern unsigned int __fastcall __macro vram_addr( unsigned char bat_x<_al>, unsigned char bat_y<_ah> );
  417                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 104; extern unsigned int __fastcall __macro get_vram( unsigned int address<_di> );
  418                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 105; extern void __fastcall __macro put_vram( unsigned int address<_di>, unsigned int data<acc> );
  419                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 107; extern void __fastcall __macro load_vram( unsigned int vram<_di>, unsigned char __far *data<_bp_bank:_bp>, unsigned int num_words<_ax> );
  420                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 108; extern void __fastcall __macro far_load_vram( unsigned int vram<_di>,  unsigned int num_words<_ax> );
  421                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 110; extern void __fastcall load_bat( unsigned int vram<_di>, unsigned char __far *data<_bp_bank:_bp>, unsigned char tiles_w<_al>, unsigned char tiles_h<_ah> );
  422                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 111; extern void __fastcall far_load_bat( unsigned int vram<_di>, unsigned char tiles_w<_al>, unsigned char tiles_h<_ah> );
  423                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 113; extern void __fastcall __macro load_sprites( unsigned int vram<_di>, unsigned char __far *data<_bp_bank:_bp>, unsigned int num_groups<acc> );
  424                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 114; extern void __fastcall __macro far_load_sprites( unsigned int vram<_di>, unsigned int num_groups<acc> );
  425                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 116; extern void __fastcall vram2vram( unsigned int vram_dst<_ax>, unsigned int vram_src<_bx>, unsigned int word_len<_cx> );
  426                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 119; // *************
  427                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 120; // SuperGRAFX Video Functions
  428                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 121; // *************
  429                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 123; extern void __fastcall __nop vpc_set_ctl( unsigned int bits<VPC_CR> );
  430                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 124; extern void __fastcall __nop vpc_set_win1( unsigned int width<VPC_WINDOW1> );
  431                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 125; extern void __fastcall __nop vpc_set_win2( unsigned int width<VPC_WINDOW2> );
  432                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 127; extern void __fastcall sgx_set_screen_size( unsigned char value<_al> );
  433                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 129; extern void __fastcall sgx_set_xres( unsigned int x_pixels<_ax>, unsigned char blur_flag<_bl> );
  434                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 131; extern void __fastcall sgx_cls( void );
  435                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 132; extern void __fastcall sgx_cls( unsigned int tile<acc> );
  436                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 134; extern unsigned int __fastcall __macro sgx_vram_addr( unsigned char bat_x<_al>, unsigned char bat_y<_ah> );
  437                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 135; extern unsigned int __fastcall __macro sgx_get_vram( unsigned int address<_di> );
  438                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 136; extern void __fastcall __macro sgx_put_vram( unsigned int address<_di>, unsigned int data<acc> );
  439                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 138; extern void __fastcall __macro sgx_load_vram( unsigned int vram<_di>, unsigned char __far *data<_bp_bank:_bp>, unsigned int num_words<_ax> );
  440                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 139; extern void __fastcall __macro sgx_far_load_vram( unsigned int vram<_di>, unsigned int num_words<_ax> );
  441                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 141; extern void __fastcall sgx_load_bat( unsigned int vram<_di>, unsigned char __far *data<_bp_bank:_bp>, unsigned char tiles_w<_al>, unsigned char tiles_h<_ah> );
  442                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 142; extern void __fastcall sgx_far_load_bat( unsigned int vram<_di>, unsigned char tiles_w<_al>, unsigned char tiles_h<_ah> );
  443                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 144; extern void __fastcall __macro sgx_load_sprites( unsigned int vram<_di>, unsigned char __far *data<_bp_bank:_bp>, unsigned int num_groups<acc> );
  444                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 145; extern void __fastcall __macro sgx_far_load_sprites( unsigned int vram<_di>, unsigned int num_groups<acc> );
  445                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 147; extern void __fastcall sgx_vram2vram( unsigned int vram_dst<_ax>, unsigned int vram_src<_bx>, unsigned int word_len<_cx> );
  446                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 150; // *************
  447                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 151; // Font Functions
  448                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 152; // *************
  449                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 154; extern void __fastcall set_font_addr( unsigned int vram<acc> );
  450                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 155; extern void __fastcall set_font_pal( unsigned char palette<acc> );
  451                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 157; extern void __fastcall load_font( unsigned char __far *font<_bp_bank:_bp>, unsigned char count<_al>, unsigned int vram<acc> );
  452                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 158; extern void __fastcall far_load_font( unsigned char count<_al>, unsigned int vram<acc> );
  453                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 160; extern void __fastcall __nop set_font_color( unsigned char foreground<monofont_fg>, unsigned char background<monofont_bg> );
  454                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 161; extern void __fastcall __macro load_default_font( void );
  455                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 164; // *************
  456                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 165; // SuperGRAFX Font Functions
  457                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 166; // *************
  458                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 168; extern void __fastcall sgx_set_font_addr( unsigned int vram<acc> );
  459                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 169; extern void __fastcall sgx_set_font_pal( unsigned char palette<acc> );
  460                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 171; extern void __fastcall sgx_load_font( char __far *font<_bp_bank:_bp>, unsigned char count<_al>, unsigned int vram<acc> );
  461                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 172; extern void __fastcall sgx_far_load_font( unsigned char count<_al>, unsigned int vram<acc> );
  462                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 174; extern void __fastcall __macro sgx_load_default_font( void );
  463                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 177; // *************
  464                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 178; // Deprecated functions ...
  465                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 179; // *************
  466                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 181; extern void __fastcall __macro set_xres( unsigned int x_pixels<_ax> );
  467                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 182; extern void __fastcall __macro sgx_set_xres( unsigned int x_pixels<_ax> );
  468                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 184; extern void __fastcall load_background( unsigned char __far *tiles<_bp_bank:_bp>, unsigned char __far *palettes<__fbank:__fptr>, unsigned char __far *bat<_cl:_bx>, unsigned char w<_dl>, unsigned char h<_dh> );
  469                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 186; extern void __fastcall __macro set_bgpal( unsigned char palette<_al>, unsigned char __far *data<_bp_bank:_bp> );
  470                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 187; extern void __fastcall __macro set_bgpal( unsigned char palette<_al>, unsigned char __far *data<_bp_bank:_bp>, unsigned int num_palettes<_ah> );
  471                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 188; extern void __fastcall __macro set_sprpal( unsigned char palette<_al>, unsigned char __far *data<_bp_bank:_bp> );
  472                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 189; extern void __fastcall __macro set_sprpal( unsigned char palette<_al>, unsigned char __far *data<_bp_bank:_bp>, unsigned int num_palettes<_ah> );
  473                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 191; extern void __fastcall load_font( char __far *font<_bp_bank:_bp>, unsigned char count<_al> );
  474                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 193; extern void __fastcall put_string( unsigned char *string<_bp>, unsigned char bat_x<_dil>, unsigned char bat_y<_dih> );
  475                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 195; extern void __fastcall put_char( unsigned char digit<_bl>, unsigned char bat_x<_dil>, unsigned char bat_y<_dih> );
  476                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 196; extern void __fastcall put_digit( unsigned char digit<_bl>, unsigned char bat_x<_dil>, unsigned char bat_y<_dih> );
  477                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 197; extern void __fastcall put_hex( unsigned int number<_bx>, unsigned char length<_cl>, unsigned char bat_x<_dil>, unsigned char bat_y<_dih> );
  478                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 198; extern void __fastcall put_number( unsigned int number<_bx>, unsigned char length<_cl>, unsigned char bat_x<_dil>, unsigned char bat_y<_dih> );
  479                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 199; extern void __fastcall put_raw( unsigned int data<_bx>, unsigned char bat_x<_dil>, unsigned char bat_y<_dih> );
  480                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 201; #endif // __HUCC__
  481                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 203; #endif // _hucc_gfx_h
  482                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 36; #include "hucc-string.h"
  483                        		.dbg	line,	"..\..\..\include\hucc\hucc-string.h", 1; #ifndef _hucc_string_h
  484                        		.dbg	line,	"..\..\..\include\hucc\hucc-string.h", 2; #define _hucc_string_h
  485                        		.dbg	line,	"..\..\..\include\hucc\hucc-string.h", 4; /****************************************************************************
  486                        		.dbg	line,	"..\..\..\include\hucc\hucc-string.h", 5; ; ***************************************************************************
  487                        		.dbg	line,	"..\..\..\include\hucc\hucc-string.h", 6; ;
  488                        		.dbg	line,	"..\..\..\include\hucc\hucc-string.h", 7; ; hucc-string.h
  489                        		.dbg	line,	"..\..\..\include\hucc\hucc-string.h", 8; ;
  490                        		.dbg	line,	"..\..\..\include\hucc\hucc-string.h", 9; ; Not-quite-standard, but fast, replacements for <string.h>.
  491                        		.dbg	line,	"..\..\..\include\hucc\hucc-string.h", 10; ;
  492                        		.dbg	line,	"..\..\..\include\hucc\hucc-string.h", 11; ; Copyright John Brandwood 2024.
  493                        		.dbg	line,	"..\..\..\include\hucc\hucc-string.h", 12; ;
  494                        		.dbg	line,	"..\..\..\include\hucc\hucc-string.h", 13; ; Distributed under the Boost Software License, Version 1.0.
  495                        		.dbg	line,	"..\..\..\include\hucc\hucc-string.h", 14; ; (See accompanying file LICENSE_1_0.txt or copy at
  496                        		.dbg	line,	"..\..\..\include\hucc\hucc-string.h", 15; ;  http://www.boost.org/LICENSE_1_0.txt)
  497                        		.dbg	line,	"..\..\..\include\hucc\hucc-string.h", 16; ;
  498                        		.dbg	line,	"..\..\..\include\hucc\hucc-string.h", 17; ; ***************************************************************************
  499                        		.dbg	line,	"..\..\..\include\hucc\hucc-string.h", 18; ; ***************************************************************************
  500                        		.dbg	line,	"..\..\..\include\hucc\hucc-string.h", 19; ;
  501                        		.dbg	line,	"..\..\..\include\hucc\hucc-string.h", 20; ; !!! WARNING : non-standard return values !!!
  502                        		.dbg	line,	"..\..\..\include\hucc\hucc-string.h", 21; ;
  503                        		.dbg	line,	"..\..\..\include\hucc\hucc-string.h", 22; ; Strings are limited to a maximum of 255 characters (+ the terminator)!
  504                        		.dbg	line,	"..\..\..\include\hucc\hucc-string.h", 23; ;
  505                        		.dbg	line,	"..\..\..\include\hucc\hucc-string.h", 24; ; The memcpy(), strcpy() and strcat() functions do NOT return the destination
  506                        		.dbg	line,	"..\..\..\include\hucc\hucc-string.h", 25; ; address, and they are declared "void" to check that the value is not used.
  507                        		.dbg	line,	"..\..\..\include\hucc\hucc-string.h", 26; ;
  508                        		.dbg	line,	"..\..\..\include\hucc\hucc-string.h", 27; ; mempcpy() is provided which returns the end address instead of the starting
  509                        		.dbg	line,	"..\..\..\include\hucc\hucc-string.h", 28; ; address, because this is typically more useful.
  510                        		.dbg	line,	"..\..\..\include\hucc\hucc-string.h", 29; ;
  511                        		.dbg	line,	"..\..\..\include\hucc\hucc-string.h", 30; ; Please note that both memcpy() and memset() are implemented using a TII for
  512                        		.dbg	line,	"..\..\..\include\hucc\hucc-string.h", 31; ; speed, and so the length should be < 16 bytes if used in time-critical bits
  513                        		.dbg	line,	"..\..\..\include\hucc\hucc-string.h", 32; ; of code (such as when using a split screen) because they delay interrupts.
  514                        		.dbg	line,	"..\..\..\include\hucc\hucc-string.h", 33; ;
  515                        		.dbg	line,	"..\..\..\include\hucc\hucc-string.h", 34; ; strncpy() and strncat() are not provided, because strncpy() was not created
  516                        		.dbg	line,	"..\..\..\include\hucc\hucc-string.h", 35; ; for the purpose of avoiding string overruns, and strncat() is just a poorly
  517                        		.dbg	line,	"..\..\..\include\hucc\hucc-string.h", 36; ; designed function IMHO.
  518                        		.dbg	line,	"..\..\..\include\hucc\hucc-string.h", 37; ;
  519                        		.dbg	line,	"..\..\..\include\hucc\hucc-string.h", 38; ; POSIX strlcpy() and strlcat() are provided instead, but once again they are
  520                        		.dbg	line,	"..\..\..\include\hucc\hucc-string.h", 39; ; slightly non-standard in that the return value when there is an overflow is
  521                        		.dbg	line,	"..\..\..\include\hucc\hucc-string.h", 40; ; the buffer size (so that the overflow can be detected), instead of the full
  522                        		.dbg	line,	"..\..\..\include\hucc\hucc-string.h", 41; ; size of the destination string that was too big to fit in the buffer.
  523                        		.dbg	line,	"..\..\..\include\hucc\hucc-string.h", 42; ;
  524                        		.dbg	line,	"..\..\..\include\hucc\hucc-string.h", 43; ; ***************************************************************************
  525                        		.dbg	line,	"..\..\..\include\hucc\hucc-string.h", 44; ; **************************************************************************/
  526                        		.dbg	line,	"..\..\..\include\hucc\hucc-string.h", 46; // *************
  527                        		.dbg	line,	"..\..\..\include\hucc\hucc-string.h", 47; // Functions in hucc-string.asm ...
  528                        		.dbg	line,	"..\..\..\include\hucc\hucc-string.h", 48; // *************
  529                        		.dbg	line,	"..\..\..\include\hucc\hucc-string.h", 50; #ifdef __HUCC__
  530                        		.dbg	line,	"..\..\..\include\hucc\hucc-string.h", 52; #asmdef	HUCC_USES_STRING 1
  531               0001     	HUCC_USES_STRING = 1
  532                        		.dbg	line,	"..\..\..\include\hucc\hucc-string.h", 54; extern void __fastcall strcpy( char *destination<_di>, char *source<_bp> );
  533                        		.dbg	line,	"..\..\..\include\hucc\hucc-string.h", 55; extern void __fastcall strcat( char *destination<_di>, char *source<_bp> );
  534                        		.dbg	line,	"..\..\..\include\hucc\hucc-string.h", 57; extern unsigned int __fastcall strlen( char *source<_bp> );
  535                        		.dbg	line,	"..\..\..\include\hucc\hucc-string.h", 59; extern unsigned int __fastcall strlcpy( char *destination<_di>, char *source<_bp>, unsigned char size<acc> );
  536                        		.dbg	line,	"..\..\..\include\hucc\hucc-string.h", 60; extern unsigned int __fastcall strlcat( char *destination<_di>, char *source<_bp>, unsigned char size<acc> );
  537                        		.dbg	line,	"..\..\..\include\hucc\hucc-string.h", 62; extern void __fastcall memcpy( unsigned char *destination<ram_tii_dst>, unsigned char *source<ram_tii_src>, unsigned int count<acc> );
  538                        		.dbg	line,	"..\..\..\include\hucc\hucc-string.h", 63; extern void __fastcall farmemcpy( unsigned char *destination<ram_tii_dst>, unsigned char __far *source<_bp_bank:ram_tii_src>, unsigned int count<acc> );
  539                        		.dbg	line,	"..\..\..\include\hucc\hucc-string.h", 64; extern void __fastcall far_memcpy( unsigned char *destination<ram_tii_dst>, unsigned int count<acc> );
  540                        		.dbg	line,	"..\..\..\include\hucc\hucc-string.h", 66; extern unsigned char * __fastcall mempcpy( unsigned char *destination<ram_tii_dst>, unsigned char *source<ram_tii_src>, unsigned int count<acc> );
  541                        		.dbg	line,	"..\..\..\include\hucc\hucc-string.h", 67; extern unsigned char * __fastcall farmempcpy( unsigned char *destination<ram_tii_dst>, unsigned char __far *source<_bp_bank:ram_tii_src>, unsigned int count<acc> );
  542                        		.dbg	line,	"..\..\..\include\hucc\hucc-string.h", 68; extern unsigned char * __fastcall far_mempcpy( unsigned char *destination<ram_tii_dst>, unsigned int count<acc> );
  543                        		.dbg	line,	"..\..\..\include\hucc\hucc-string.h", 70; extern void __fastcall memset( unsigned char *destination<ram_tii_src>, unsigned char value<_al>, unsigned int count<acc> );
  544                        		.dbg	line,	"..\..\..\include\hucc\hucc-string.h", 72; //  0 	if strings are equal
  545                        		.dbg	line,	"..\..\..\include\hucc\hucc-string.h", 73; //  1 	if the first non-matching character in string1 > string2 (in ASCII).
  546                        		.dbg	line,	"..\..\..\include\hucc\hucc-string.h", 74; // -1 	if the first non-matching character in string1 < string2 (in ASCII).
  547                        		.dbg	line,	"..\..\..\include\hucc\hucc-string.h", 76; extern int __fastcall strcmp( char *string1<_di>, char *string2<_bp> );
  548                        		.dbg	line,	"..\..\..\include\hucc\hucc-string.h", 77; extern int __fastcall strncmp( char *string1<_di>, char *string2<_bp>, unsigned int count<_ax> );
  549                        		.dbg	line,	"..\..\..\include\hucc\hucc-string.h", 79; extern int __fastcall __macro memcmp( unsigned char *string1<_di>, unsigned char *string2<_bp>, unsigned int count<acc> );
  550                        		.dbg	line,	"..\..\..\include\hucc\hucc-string.h", 80; extern int __fastcall farmemcmp( unsigned char *string1<_di>, unsigned char __far *string2<_bp_bank:_bp>, unsigned int count<acc> );
  551                        		.dbg	line,	"..\..\..\include\hucc\hucc-string.h", 81; extern int __fastcall far_memcmp( unsigned char *string1<_di>, unsigned int count<acc> );
  552                        		.dbg	line,	"..\..\..\include\hucc\hucc-string.h", 83; #endif // __HUCC__
  553                        		.dbg	line,	"..\..\..\include\hucc\hucc-string.h", 85; #endif // _hucc_string_h
  554                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 37; #include "hucc-old-scroll.h"
  555                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-scroll.h", 1; #ifndef _hucc_old_scroll_h
  556                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-scroll.h", 2; #define _hucc_old_scroll_h
  557                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-scroll.h", 4; /****************************************************************************
  558                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-scroll.h", 5; ; ***************************************************************************
  559                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-scroll.h", 6; ;
  560                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-scroll.h", 7; ; hucc-old-scroll.h
  561                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-scroll.h", 8; ;
  562                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-scroll.h", 9; ; Based on the original HuC and MagicKit functions by David Michel and the
  563                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-scroll.h", 10; ; other original HuC developers.
  564                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-scroll.h", 11; ;
  565                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-scroll.h", 12; ; Modifications copyright John Brandwood 2024.
  566                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-scroll.h", 13; ;
  567                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-scroll.h", 14; ; Distributed under the Boost Software License, Version 1.0.
  568                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-scroll.h", 15; ; (See accompanying file LICENSE_1_0.txt or copy at
  569                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-scroll.h", 16; ;  http://www.boost.org/LICENSE_1_0.txt)
  570                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-scroll.h", 17; ;
  571                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-scroll.h", 18; ; ***************************************************************************
  572                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-scroll.h", 19; ; ***************************************************************************
  573                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-scroll.h", 20; ;
  574                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-scroll.h", 21; ; HuC's old scrolling library is provided for use with existing HuC projects,
  575                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-scroll.h", 22; ; but it should preferably be avoided in new projects because it is slow and
  576                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-scroll.h", 23; ; forever limited by its choice to handle gaps between areas, and sorting.
  577                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-scroll.h", 24; ;
  578                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-scroll.h", 25; ; HuCC's new scrolling library puts the responibility for defining both gaps
  579                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-scroll.h", 26; ; and the display order into the project's hands, but in return it runs much
  580                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-scroll.h", 27; ; faster, using less than 1/6 of the processing time in VBLANK, and far less
  581                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-scroll.h", 28; ; time in the RCR interrputs themselves. It also supports the 2nd SuperGRAFX
  582                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-scroll.h", 29; ; screen layer, which HuC's old scrolling library ignores.
  583                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-scroll.h", 30; ;
  584                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-scroll.h", 31; ; ***************************************************************************
  585                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-scroll.h", 32; ; **************************************************************************/
  586                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-scroll.h", 34; // *************
  587                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-scroll.h", 35; // Functions in hucc-old-scroll.asm ...
  588                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-scroll.h", 36; // *************
  589                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-scroll.h", 38; #ifdef __HUCC__
  590                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-scroll.h", 40; #asmdef	HUCC_USES_OLD_SCROLL 1
  591               0001     	HUCC_USES_OLD_SCROLL = 1
  592                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-scroll.h", 42; extern void __fastcall scroll( unsigned char num<_al>, unsigned int x<_cx>, unsigned int y<_dx>, unsigned char top<_ah>, unsigned char bottom<_bl>, unsigned char disp<acc> );
  593                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-scroll.h", 43; extern void __fastcall scroll_disable( unsigned char num<acc> );
  594                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-scroll.h", 45; #endif // __HUCC__
  595                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-scroll.h", 47; #endif // _hucc_old_scroll_h
  596                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 38; #include "hucc-old-spr.h"
  597                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-spr.h", 1; #ifndef _hucc_old_spr_h
  598                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-spr.h", 2; #define _hucc_old_spr_h
  599                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-spr.h", 4; /****************************************************************************
  600                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-spr.h", 5; ; ***************************************************************************
  601                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-spr.h", 6; ;
  602                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-spr.h", 7; ; hucc-old-spr.h
  603                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-spr.h", 8; ;
  604                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-spr.h", 9; ; Based on the original HuC and MagicKit functions by David Michel and the
  605                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-spr.h", 10; ; other original HuC developers.
  606                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-spr.h", 11; ;
  607                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-spr.h", 12; ; Modifications copyright John Brandwood 2024.
  608                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-spr.h", 13; ;
  609                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-spr.h", 14; ; Distributed under the Boost Software License, Version 1.0.
  610                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-spr.h", 15; ; (See accompanying file LICENSE_1_0.txt or copy at
  611                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-spr.h", 16; ;  http://www.boost.org/LICENSE_1_0.txt)
  612                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-spr.h", 17; ;
  613                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-spr.h", 18; ; ***************************************************************************
  614                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-spr.h", 19; ; **************************************************************************/
  615                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-spr.h", 21; // *************
  616                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-spr.h", 22; // Sprite defines ...
  617                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-spr.h", 23; // *************
  618                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-spr.h", 25; #define FLIP_X_MASK 0x08
  619                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-spr.h", 26; #define FLIP_Y_MASK 0x80
  620                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-spr.h", 27; #define FLIP_MAS    0x88
  621                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-spr.h", 28; #define SIZE_MAS    0x31
  622                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-spr.h", 30; #define NO_FLIP     0x00
  623                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-spr.h", 31; #define NO_FLIP_X   0x00
  624                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-spr.h", 32; #define NO_FLIP_Y   0x00
  625                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-spr.h", 33; #define FLIP_X      0x08
  626                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-spr.h", 34; #define FLIP_Y      0x80
  627                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-spr.h", 35; #define SZ_16x16    0x00
  628                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-spr.h", 36; #define SZ_16x32    0x10
  629                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-spr.h", 37; #define SZ_16x64    0x30
  630                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-spr.h", 38; #define SZ_32x16    0x01
  631                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-spr.h", 39; #define SZ_32x32    0x11
  632                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-spr.h", 40; #define	SZ_32x64    0x31
  633                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-spr.h", 42; // *************
  634                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-spr.h", 43; // Functions in hucc-old-spr.asm ...
  635                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-spr.h", 44; // *************
  636                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-spr.h", 46; #ifdef __HUCC__
  637                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-spr.h", 48; #asmdef	HUCC_USES_OLD_SPR 1
  638               0001     	HUCC_USES_OLD_SPR = 1
  639                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-spr.h", 50; extern void __fastcall init_satb( void );
  640                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-spr.h", 51; extern void __fastcall reset_satb( void );
  641                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-spr.h", 52; extern void __fastcall satb_update( void );
  642                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-spr.h", 53; extern void __fastcall spr_set( unsigned char num<acc> );
  643                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-spr.h", 54; extern void __fastcall spr_hide( void );
  644                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-spr.h", 55; extern void __fastcall spr_show( void );
  645                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-spr.h", 56; extern void __fastcall spr_x( unsigned int value<acc> );
  646                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-spr.h", 57; extern void __fastcall spr_y( unsigned int value<acc> );
  647                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-spr.h", 58; extern void __fastcall spr_pattern( unsigned int vaddr<acc> );
  648                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-spr.h", 59; extern void __fastcall spr_ctrl( unsigned char mask<_al>, unsigned char value<acc> );
  649                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-spr.h", 60; extern void __fastcall spr_pal( unsigned char palette<acc> );
  650                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-spr.h", 61; extern void __fastcall spr_pri( unsigned char priority<acc> );
  651                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-spr.h", 63; extern unsigned int __fastcall spr_get_x( void );
  652                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-spr.h", 64; extern unsigned int __fastcall spr_get_y( void );
  653                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-spr.h", 66; extern void __fastcall sgx_init_satb( void );
  654                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-spr.h", 67; extern void __fastcall sgx_reset_satb( void );
  655                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-spr.h", 68; extern void __fastcall sgx_satb_update( void );
  656                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-spr.h", 69; extern void __fastcall sgx_spr_set( unsigned char num<acc> );
  657                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-spr.h", 70; extern void __fastcall sgx_spr_hide( void );
  658                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-spr.h", 71; extern void __fastcall sgx_spr_show( void );
  659                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-spr.h", 72; extern void __fastcall sgx_spr_x( unsigned int value<acc> );
  660                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-spr.h", 73; extern void __fastcall sgx_spr_y( unsigned int value<acc> );
  661                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-spr.h", 74; extern void __fastcall sgx_spr_pattern( unsigned int vaddr<acc> );
  662                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-spr.h", 75; extern void __fastcall sgx_spr_ctrl( unsigned char mask<_al>, unsigned char value<acc> );
  663                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-spr.h", 76; extern void __fastcall sgx_spr_pal( unsigned char palette<acc> );
  664                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-spr.h", 77; extern void __fastcall sgx_spr_pri( unsigned char priority<acc> );
  665                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-spr.h", 79; extern unsigned int __fastcall sgx_spr_get_x( void );
  666                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-spr.h", 80; extern unsigned int __fastcall sgx_spr_get_y( void );
  667                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-spr.h", 82; #endif // __HUCC__
  668                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-spr.h", 84; #endif // _hucc_old_spr_h
  669                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 39; #include "hucc-old-map.h"
  670                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-map.h", 1; #ifndef _hucc_old_map_h
  671                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-map.h", 2; #define _hucc_old_map_h
  672                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-map.h", 4; /****************************************************************************
  673                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-map.h", 5; ; ***************************************************************************
  674                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-map.h", 6; ;
  675                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-map.h", 7; ; hucc-old-map.h
  676                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-map.h", 8; ;
  677                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-map.h", 9; ; Based on the original HuC and MagicKit functions by David Michel and the
  678                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-map.h", 10; ; other original HuC developers.
  679                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-map.h", 11; ;
  680                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-map.h", 12; ; Modifications copyright John Brandwood 2024.
  681                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-map.h", 13; ;
  682                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-map.h", 14; ; Distributed under the Boost Software License, Version 1.0.
  683                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-map.h", 15; ; (See accompanying file LICENSE_1_0.txt or copy at
  684                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-map.h", 16; ;  http://www.boost.org/LICENSE_1_0.txt)
  685                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-map.h", 17; ;
  686                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-map.h", 18; ; ***************************************************************************
  687                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-map.h", 19; ; **************************************************************************/
  688                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-map.h", 21; // *************
  689                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-map.h", 22; // Functions in hucc-old-map.asm ...
  690                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-map.h", 23; // *************
  691                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-map.h", 25; #ifdef __HUCC__
  692                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-map.h", 27; #asmdef	HUCC_USES_OLD_MAP 1
  693               0001     	HUCC_USES_OLD_MAP = 1
  694                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-map.h", 29; extern void __fastcall set_tile_address( unsigned int vram<_di> );
  695                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-map.h", 30; extern void __fastcall sgx_set_tile_address( unsigned int vram<_di> );
  696                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-map.h", 32; extern void __fastcall __nop set_tile_data( unsigned char __far *tiles<vdc_tile_bank:vdc_tile_addr>, unsigned char num_tiles<vdc_num_tiles>, unsigned char __far *palette_table<vdc_attr_bank:vdc_attr_addr>, unsigned char tile_type<vdc_tile_type> );
  697                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-map.h", 33; extern void __fastcall __nop sgx_set_tile_data( unsigned char __far *tiles<sgx_tile_bank:sgx_tile_addr>, unsigned char num_tiles<sgx_num_tiles>, unsigned char __far *palette_table<sgx_attr_bank:sgx_attr_addr>, unsigned char tile_type<sgx_tile_type> );
  698                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-map.h", 35; extern void __fastcall __nop set_far_tile_data( unsigned char tile_bank<vdc_tile_bank>, unsigned char *tile_addr<vdc_tile_addr>, unsigned char num_tiles<vdc_num_tiles>, unsigned char palette_table_bank<vdc_attr_bank>, unsigned char *palette_table_addr<vdc_attr_addr>, unsigned char tile_type<vdc_tile_type> );
  699                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-map.h", 36; extern void __fastcall __nop sgx_set_far_tile_data( unsigned char tile_bank<sgx_tile_bank>, unsigned char *tile_addr<sgx_tile_addr>, unsigned char num_tiles<sgx_num_tiles>, unsigned char palette_table_bank<sgx_attr_bank>, unsigned char *palette_table_addr<sgx_attr_addr>, unsigned char tile_type<sgx_tile_type> );
  700                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-map.h", 38; extern void __fastcall __nop set_map_data( unsigned char __far *map<vdc_map_bank:vdc_map_addr>, unsigned char w<vdc_map_width>, unsigned char h<vdc_map_height> );
  701                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-map.h", 39; extern void __fastcall __nop sgx_set_map_data( unsigned char __far *map<sgx_map_bank:sgx_map_addr>, unsigned char w<sgx_map_width>, unsigned char h<sgx_map_height> );
  702                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-map.h", 41; extern void __fastcall __nop set_far_map_data( unsigned char map_bank<vdc_map_bank>, unsigned char *map_addr<vdc_map_addr>, unsigned char w<vdc_map_width>, unsigned char h<vdc_map_height> );
  703                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-map.h", 42; extern void __fastcall __nop sgx_set_far_map_data( unsigned char map_bank<vdc_map_bank>, unsigned char *map_addr<vdc_map_addr>, unsigned char w<sgx_map_width>, unsigned char h<sgx_map_height> );
  704                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-map.h", 44; extern void __fastcall load_tile( unsigned int vram<_di> );
  705                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-map.h", 45; extern void __fastcall sgx_load_tile( unsigned int vram<_di> );
  706                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-map.h", 47; extern void __fastcall load_map( unsigned char bat_x<_al>, unsigned char bat_y<_ah>, int map_x<_bx>, int map_y<_dx>, unsigned char tiles_w<_cl>, unsigned char tiles_h<_ch> );
  707                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-map.h", 48; extern void __fastcall sgx_load_map( unsigned char bat_x<_al>, unsigned char bat_y<_ah>, int map_x<_bx>, int map_y<_dx>, unsigned char tiles_w<_cl>, unsigned char tiles_h<_ch> );
  708                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-map.h", 50; extern unsigned char __fastcall map_get_tile( unsigned char map_x<_bl>, unsigned char map_y<_bh> );
  709                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-map.h", 51; extern unsigned char __fastcall sgx_map_get_tile( unsigned char map_x<_bl>, unsigned char map_y<_bh> );
  710                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-map.h", 53; extern void __fastcall map_put_tile( unsigned char map_x<_bl>, unsigned char map_y<_bh>, unsigned char tile<_al> );
  711                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-map.h", 54; extern void __fastcall sgx_map_put_tile( unsigned char map_x<_bl>, unsigned char map_y<_bh>, unsigned char tile<_al> );
  712                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-map.h", 56; extern void __fastcall put_tile( unsigned char tile<_bl>, unsigned char bat_x<_al>, unsigned char bat_y<_ah> );
  713                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-map.h", 57; extern void __fastcall sgx_put_tile( unsigned char tile<_bl>, unsigned char bat_x<_al>, unsigned char bat_y<_ah> );
  714                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-map.h", 59; // Deprecated functions ...
  715                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-map.h", 61; extern void __fastcall set_tile_data( unsigned char *tile_ex<_di> );
  716                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-map.h", 63; extern void __fastcall __nop set_map_pals( unsigned char __far *palette_table<vdc_attr_bank:vdc_attr_addr> );
  717                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-map.h", 64; extern void __fastcall __nop set_map_tile_type( unsigned char tile_type<vdc_tile_type> );
  718                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-map.h", 66; extern void __fastcall __nop sgx_set_map_pals( unsigned char __far *palette_table<sgx_attr_bank:sgx_attr_addr> );
  719                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-map.h", 67; extern void __fastcall __nop sgx_set_map_tile_type( unsigned char tile_type<sgx_tile_type> );
  720                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-map.h", 69; extern void __fastcall set_map_tile_base( unsigned int vram<_di> );
  721                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-map.h", 70; extern void __fastcall sgx_set_map_tile_base( unsigned int vram<_di> );
  722                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-map.h", 72; #endif // __HUCC__
  723                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-map.h", 74; #endif // _hucc_old_map_h
  724                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 40; #include "hucc-old-line.h"
  725                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-line.h", 1; #ifndef _hucc_old_line_h
  726                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-line.h", 2; #define _hucc_old_line_h
  727                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-line.h", 4; /****************************************************************************
  728                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-line.h", 5; ; ***************************************************************************
  729                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-line.h", 6; ;
  730                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-line.h", 7; ; hucc-old-line.h
  731                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-line.h", 8; ;
  732                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-line.h", 9; ; Based on the original HuC and MagicKit functions by David Michel and the
  733                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-line.h", 10; ; other original HuC developers.
  734                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-line.h", 11; ;
  735                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-line.h", 12; ; Modifications copyright John Brandwood 2024.
  736                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-line.h", 13; ;
  737                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-line.h", 14; ; Distributed under the Boost Software License, Version 1.0.
  738                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-line.h", 15; ; (See accompanying file LICENSE_1_0.txt or copy at
  739                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-line.h", 16; ;  http://www.boost.org/LICENSE_1_0.txt)
  740                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-line.h", 17; ;
  741                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-line.h", 18; ; ***************************************************************************
  742                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-line.h", 19; ; **************************************************************************/
  743                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-line.h", 21; // *************
  744                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-line.h", 22; // Functions in hucc-old-line.asm ...
  745                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-line.h", 23; // *************
  746                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-line.h", 25; #ifdef __HUCC__
  747                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-line.h", 27; #asmdef	HUCC_USES_OLD_LINE 1
  748               0001     	HUCC_USES_OLD_LINE = 1
  749                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-line.h", 29; extern void __fastcall gfx_init( unsigned int start_vram_addr<_ax> );
  750                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-line.h", 30; extern void __fastcall gfx_clear( unsigned int start_vram_addr<_di> );
  751                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-line.h", 31; extern void __fastcall gfx_plot( unsigned int x<_gfx_x1>, unsigned int y<_gfx_y1>, char color<_gfx_color> );
  752                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-line.h", 32; extern void __fastcall gfx_line( unsigned int x1<_gfx_x1>, unsigned int y1<_gfx_y1>, unsigned int x2<_gfx_x2>, unsigned int y2<_gfx_y2>, unsigned char color<_gfx_color> );
  753                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-line.h", 34; #endif // __HUCC__
  754                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-line.h", 36; #endif // _hucc_old_line_h
  755                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 42; #endif // _hucc_legacy_h
  756                        		.dbg	line,	"main.c", 1; #include "huc.h"
  757                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 1; #ifndef _hucc_legacy_h
  758                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 2; #define _hucc_legacy_h
  759                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 4; /****************************************************************************
  760                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 5; ; ***************************************************************************
  761                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 6; ;
  762                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 7; ; huc.h
  763                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 8; ;
  764                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 9; ; HuCC wrapper file to include a default set of HuC-compatible functions.
  765                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 10; ;
  766                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 11; ; Copyright John Brandwood 2024.
  767                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 12; ;
  768                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 13; ; Distributed under the Boost Software License, Version 1.0.
  769                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 14; ; (See accompanying file LICENSE_1_0.txt or copy at
  770                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 15; ;  http://www.boost.org/LICENSE_1_0.txt)
  771                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 16; ;
  772                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 17; ; ***************************************************************************
  773                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 18; ; ***************************************************************************
  774                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 19; ;
  775                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 20; ; When the HuCC compiler is invoked with the "--legacy" option to compile old
  776                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 21; ; projects, then this "huc.h" file is automatically included.
  777                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 22; ;
  778                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 23; ; This file includes a set of the individual HuCC headers which correspond to
  779                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 24; ; HuC's built-in functions and MagicKit library.
  780                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 25; ;
  781                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 26; ; New HuCC projects should, preferably, include the specific headers that are
  782                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 27; ; needed, which will then allow them to replace parts of the standard library
  783                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 28; ; with newer functions, or they can just manually include this "huc.h" file.
  784                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 29; ;
  785                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 30; ; ***************************************************************************
  786                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 31; ; **************************************************************************/
  787                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 33; #include "hucc-systemcard.h"
  788                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 34; #include "hucc-baselib.h"
  789                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 35; #include "hucc-gfx.h"
  790                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 36; #include "hucc-string.h"
  791                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 37; #include "hucc-old-scroll.h"
  792                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 38; #include "hucc-old-spr.h"
  793                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 39; #include "hucc-old-map.h"
  794                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 40; #include "hucc-old-line.h"
  795                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 42; #endif // _hucc_legacy_h
  796                        		.dbg	line,	"main.c", 2; #include "hucc-scroll.h"
  797                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 1; #ifndef _hucc_scroll_h
  798                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 2; #define _hucc_scroll_h
  799                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 4; /****************************************************************************
  800                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 5; ; ***************************************************************************
  801                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 6; ;
  802                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 7; ; hucc-scroll.h
  803                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 8; ;
  804                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 9; ; Routines for a fast split-screen scrolling system.
  805                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 10; ;
  806                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 11; ; Copyright John Brandwood 2024.
  807                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 12; ;
  808                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 13; ; Distributed under the Boost Software License, Version 1.0.
  809                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 14; ; (See accompanying file LICENSE_1_0.txt or copy at
  810                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 15; ;  http://www.boost.org/LICENSE_1_0.txt)
  811                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 16; ;
  812                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 17; ; ***************************************************************************
  813                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 18; ; ***************************************************************************
  814                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 19; ;
  815                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 20; ; The maximum number of splits for each screen layer is set in your project's
  816                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 21; ; "hucc-config.inc" file, with the library having a limit of 128-per-layer.
  817                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 22; ;
  818                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 23; ; Your first active split must be defined to start at screen line 0, and then
  819                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 24; ; the rest of the active splits must be in increasing line order to match the
  820                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 25; ; way that the PC Engine displays the output image.
  821                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 26; ;
  822                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 27; ; You can have disabled splits interleaved with your active splits.
  823                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 28; ;
  824                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 29; ; Splits that are normally disabled can be used to create full screen effects
  825                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 30; ; such as bouncing the screen up and down by adding blank areas at the top or
  826                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 31; ; bottom of the screen, and then rapidly changing the height of those areas.
  827                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 32; ;
  828                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 33; ; ***************************************************************************
  829                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 34; ; **************************************************************************/
  830                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 36; // *************
  831                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 37; // VDC bits for display_flags ...
  832                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 38; // *************
  833                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 40; #ifndef BKG_OFF
  834                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 41; #define BKG_OFF 0x00
  835                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 42; #endif
  836                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 44; #ifndef SPR_OFF
  837                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 45; #define SPR_OFF 0x00
  838                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 46; #endif
  839                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 48; #ifndef BKG_ON
  840                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 49; #define BKG_ON 0x80
  841                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 50; #endif
  842                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 52; #ifndef SPR_ON
  843                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 53; #define SPR_ON 0x40
  844                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 54; #endif
  845                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 56; // *************
  846                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 57; // Functions in hucc-scroll.asm ...
  847                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 58; // *************
  848                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 60; #ifdef __HUCC__
  849                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 62; #asmdef	HUCC_USES_NEW_SCROLL 1
  850               0001     	HUCC_USES_NEW_SCROLL = 1
  851                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 64; extern void __fastcall scroll_split( unsigned char index<_al>, unsigned char screen_line<_ah>, unsigned int bat_x<_bx>, unsigned int bat_y<_cx>, unsigned char display_flags<_dl> );
  852                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 65; extern void __fastcall sgx_scroll_split( unsigned char index<_al>, unsigned char screen_line<_ah>, unsigned int bat_x<_bx>, unsigned int bat_y<_cx>, unsigned char display_flags<_dl> );
  853                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 67; extern void __fastcall disable_split( unsigned char index<acc> );
  854                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 68; extern void __fastcall sgx_disable_split( unsigned char index<acc> );
  855                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 70; extern void __fastcall __macro disable_all_splits( void );
  856                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 71; extern void __fastcall __macro sgx_disable_all_splits( void );
  857                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 73; #asm
  858                        		.dbg	clear
  859                        			.macro	_disable_all_splits
  860                        			ldy	#HUCC_PCE_SPLITS - 1
  861                        	!loop:		tya
  862                        			call	_disable_split.1
  863                        			dey
  864                        			bpl	!loop-
  865                        			.endm
  866                        			.macro	_sgx_disable_all_splits
  867                        			ldy	#HUCC_SGX_SPLITS - 1
  868                        	!loop:		tya
  869                        			call	_sgx_disable_split.1
  870                        			dey
  871                        			bpl	!loop-
  872                        			.endm
  873                        	
  874                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 89; #endasm
  875                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 91; #endif // __HUCC__
  876                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 93; #endif // _hucc_scroll_h
  877                        		.dbg	line,	"main.c", 3; #include "hucc-chrmap.h"
  878                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 1; #ifndef _hucc_chrmap_h
  879                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 2; #define _hucc_chrmap_h
  880                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 4; /****************************************************************************
  881                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 5; ; ***************************************************************************
  882                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 6; ;
  883                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 7; ; hucc-chrmap.h
  884                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 8; ;
  885                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 9; ; A simple map system based on 8x8 characters (aka "tiles") in BAT format.
  886                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 10; ;
  887                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 11; ; Copyright John Brandwood 2025.
  888                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 12; ;
  889                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 13; ; Distributed under the Boost Software License, Version 1.0.
  890                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 14; ; (See accompanying file LICENSE_1_0.txt or copy at
  891                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 15; ;  http://www.boost.org/LICENSE_1_0.txt)
  892                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 16; ;
  893                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 17; ; ***************************************************************************
  894                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 18; ; ***************************************************************************
  895                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 19; ;
  896                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 20; ; The maximum X and Y size for chrmaps is 256 characters (2048 pixels).
  897                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 21; ;
  898                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 22; ; The maximum total size for a chrmap is 16KBytes, which allows for maps up
  899                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 23; ; to 256x32 tiles (2048x256 pixels).
  900                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 24; ;
  901                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 25; ; ***************************************************************************
  902                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 26; ; **************************************************************************/
  903                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 28; // *************
  904                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 29; // This code extends the blkmap library ...
  905                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 30; // *************
  906                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 32; #include "hucc-blkmap.h"
  907                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 1; #ifndef _hucc_blkmap_h
  908                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 2; #define _hucc_blkmap_h
  909                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 4; /****************************************************************************
  910                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 5; ; ***************************************************************************
  911                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 6; ;
  912                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 7; ; hucc-blkmap.h
  913                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 8; ;
  914                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 9; ; A map system based on 16x16 meta-tiles (aka "blocks", aka CHR/BLK/MAP).
  915                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 10; ;
  916                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 11; ; Copyright John Brandwood 2025.
  917                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 12; ;
  918                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 13; ; Distributed under the Boost Software License, Version 1.0.
  919                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 14; ; (See accompanying file LICENSE_1_0.txt or copy at
  920                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 15; ;  http://www.boost.org/LICENSE_1_0.txt)
  921                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 16; ;
  922                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 17; ; ***************************************************************************
  923                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 18; ; ***************************************************************************
  924                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 19; ;
  925                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 20; ; The maximum X and Y size for blkmaps is 128 blocks (2048 pixels).
  926                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 21; ;
  927                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 22; ; The maximum total size for a blkmap is 16KBytes, which allows for maps up
  928                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 23; ; to 128x128 blocks (2048x2048 pixels).
  929                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 24; ;
  930                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 25; ; Huge multi-screen blkmaps are also supported (optionally).
  931                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 26; ;
  932                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 27; ; The maximum X and Y for multi-screen maps is 128 screens (32768 pixels).
  933                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 28; ;
  934                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 29; ; The maximum total size for a multi-screen map is 8KBytes, which allows for
  935                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 30; ; a total of 1024 screens.
  936                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 31; ;
  937                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 32; ; ***************************************************************************
  938                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 33; ; **************************************************************************/
  939                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 35; // *************
  940                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 36; // Functions in blkmap.asm ...
  941                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 37; // *************
  942                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 39; #ifdef __HUCC__
  943                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 41; #asmdef	HUCC_USES_BLKMAP 1
  944               0001     	HUCC_USES_BLKMAP = 1
  945                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 43; // Current top-left of drawn map in pixels.
  946                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 44; extern unsigned int   vdc_map_pxl_x;
  947                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 45; extern unsigned int   vdc_map_pxl_y;
  948                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 47; // Width and height to draw/scroll in characters (not tiles).
  949                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 48; extern unsigned char  vdc_map_draw_w;
  950                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 49; extern unsigned char  vdc_map_draw_h;
  951                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 51; // Width of map (or multi-screen BAT) in tiles.
  952                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 52; extern unsigned char  vdc_map_line_w;
  953                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 54; // Width of map in screens (if multi-screen map).
  954                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 55; extern unsigned char  vdc_map_scrn_w;
  955                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 57; // Extra information returned by get_map_block() and sgx_get_map_block(),
  956                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 58; // which are the collision flags and the mask/overlay sprite for the BLK.
  957                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 59; extern unsigned char  map_blk_flag;
  958                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 60; extern unsigned char  map_blk_mask;
  959                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 62; extern unsigned char  vdc_scr_bank;
  960                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 63; extern unsigned char *vdc_scr_addr;
  961                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 65; extern unsigned char  vdc_map_bank;
  962                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 66; extern unsigned char *vdc_map_addr;
  963                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 68; extern unsigned char  vdc_blk_bank;
  964                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 69; extern unsigned char *vdc_blk_addr;
  965                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 71; extern unsigned char  vdc_tbl_bank;
  966                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 72; extern unsigned char *vdc_tbl_addr;
  967                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 74; extern void __fastcall set_blocks( unsigned char __far *blk_def<vdc_blk_bank:vdc_blk_addr>, unsigned char __far *flg_def<vdc_tbl_bank:vdc_tbl_addr>, unsigned char number_of_blocks<_al> );
  968                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 75; extern void __fastcall __macro set_blkmap( unsigned char __far *blk_map<vdc_map_bank:vdc_map_addr>, unsigned char blocks_w<vdc_map_line_w> );
  969                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 76; extern void __fastcall __macro set_multimap( unsigned char __far *multi_map<vdc_scr_bank:vdc_scr_addr>, unsigned char screens_w<vdc_map_scrn_w> );
  970                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 78; extern void __fastcall draw_map( void );
  971                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 79; extern void __fastcall scroll_map( void );
  972                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 81; extern void __fastcall blit_map( unsigned char tile_x<map_bat_x>, unsigned char tile_y<map_bat_y>, unsigned char tile_w<map_draw_x>, unsigned char tile_h<map_draw_y> );
  973                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 83; extern unsigned char __fastcall get_map_block( unsigned int x<map_pxl_x>, unsigned int y<map_pxl_y> );
  974                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 85; #asm
  975                        		.dbg	clear
  976                        			.macro	_set_blkmap.2
  977                        			stz	vdc_scr_bank
  978                        			.endm
  979                        			.macro	_set_multimap.2
  980                        			lda	vdc_bat_width
  981                        			lsr	a
  982                        			sta	vdc_map_line_w
  983                        			.endm
  984                        			.macro	SCREEN
  985                        			db	(((\1) & $1FFF) | $6000) >> 8, bank(\1)
  986                        			db	(((\2) & $1FFF) | $4000) >> 8, bank(\2)
  987                        			db	(((\3) & $1FFF) | $6000) >> 8, bank(\3)
  988                        			dw	(\4)
  989                        			.endm
  990                        	
  991                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 102; #endasm
  992                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 104; #ifdef _SGX
  993                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 106; // Current top-left of drawn map in pixels.
  994                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 107; extern unsigned int   sgx_map_pxl_x;
  995                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 108; extern unsigned int   sgx_map_pxl_y;
  996                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 110; // Width and height to draw/scroll in characters (not tiles).
  997                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 111; extern unsigned char  sgx_map_draw_w;
  998                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 112; extern unsigned char  sgx_map_draw_h;
  999                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 114; // Width of map (or multi-screen BAT) in tiles.
 1000                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 115; extern unsigned char  sgx_map_line_w;
 1001                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 117; // Width of map in screens (if multi-screen map).
 1002                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 118; extern unsigned char  sgx_map_scrn_w;
 1003                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 120; extern unsigned char  sgx_scr_bank;
 1004                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 121; extern unsigned char *sgx_scr_addr;
 1005                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 123; extern unsigned char  sgx_map_bank;
 1006                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 124; extern unsigned char *sgx_map_addr;
 1007                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 126; extern unsigned char  sgx_blk_bank;
 1008                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 127; extern unsigned char *sgx_blk_addr;
 1009                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 129; extern unsigned char  sgx_tbl_bank;
 1010                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 130; extern unsigned char *sgx_tbl_addr;
 1011                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 132; extern void __fastcall sgx_set_blocks( unsigned char __far *blk_def<sgx_blk_bank:sgx_blk_addr>, unsigned char __far *flg_def<sgx_tbl_bank:sgx_tbl_addr>, unsigned char number_of_blocks<_al> );
 1012                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 133; extern void __fastcall __macro sgx_set_blkmap( unsigned char __far *blk_map<sgx_map_bank:sgx_map_addr>, unsigned char blocks_w<sgx_map_line_w> );
 1013                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 134; extern void __fastcall __macro sgx_set_multimap( unsigned char __far *multi_map<sgx_scr_bank:sgx_scr_addr>, unsigned char screens_w<sgx_map_scrn_w> );
 1014                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 136; extern void __fastcall sgx_draw_map( void );
 1015                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 137; extern void __fastcall sgx_scroll_map( void );
 1016                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 139; extern void __fastcall sgx_blit_map( unsigned char tile_x<map_bat_x>, unsigned char tile_y<map_bat_y>, unsigned char tile_w<map_draw_x>, unsigned char tile_h<map_draw_y> );
 1017                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 141; extern unsigned char __fastcall sgx_get_map_block( unsigned int x<map_pxl_x>, unsigned int y<map_pxl_y> );
 1018                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 143; #asm
 1019                        		.dbg	clear
 1020                        			.macro	_sgx_set_blkmap.2
 1021                        			stz	sgx_scr_bank
 1022                        			.endm
 1023                        			.macro	_sgx_set_multimap.2
 1024                        			lda	sgx_bat_width
 1025                        			lsr	a
 1026                        			sta	sgx_map_line_w
 1027                        			.endm
 1028                        	
 1029                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 153; #endasm
 1030                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 155; #endif
 1031                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 157; #endif // __HUCC__
 1032                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 159; #endif // _hucc_blkmap_h
 1033                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 34; // *************
 1034                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 35; // Functions in chrmap.asm ...
 1035                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 36; // *************
 1036                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 38; #ifdef __HUCC__
 1037                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 40; #asmdef	HUCC_USES_CHRMAP 1
 1038               0001     	HUCC_USES_CHRMAP = 1
 1039                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 42; extern void __fastcall __nop set_chrmap( unsigned char __far *chrmap<vdc_map_bank:vdc_map_addr>, unsigned char tiles_w<vdc_map_line_w> );
 1040                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 44; extern void __fastcall draw_bat( void );
 1041                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 45; extern void __fastcall scroll_bat( void );
 1042                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 47; extern void __fastcall blit_bat( unsigned char tile_x<map_bat_x>, unsigned char tile_y<map_bat_y>, unsigned char tile_w<map_draw_x>, unsigned char tile_h<map_draw_y> );
 1043                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 49; #ifdef _SGX
 1044                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 51; extern void __fastcall __nop sgx_set_chrmap( unsigned char __far *chrmap<sgx_map_bank:sgx_map_addr>, unsigned char tiles_w<sgx_map_line_w> );
 1045                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 53; extern void __fastcall sgx_draw_bat( void );
 1046                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 54; extern void __fastcall sgx_scroll_bat( void );
 1047                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 56; extern void __fastcall sgx_blit_bat( unsigned char tile_x<map_bat_x>, unsigned char tile_y<map_bat_y>, unsigned char tile_w<map_draw_x>, unsigned char tile_h<map_draw_y> );
 1048                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 58; #endif
 1049                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 60; #endif // __HUCC__
 1050                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 62; #endif // _hucc_chrmap_h
 1051                        		.dbg	line,	"main.c", 4; #include "hucc-blkmap.h"
 1052                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 1; #ifndef _hucc_blkmap_h
 1053                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 2; #define _hucc_blkmap_h
 1054                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 4; /****************************************************************************
 1055                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 5; ; ***************************************************************************
 1056                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 6; ;
 1057                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 7; ; hucc-blkmap.h
 1058                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 8; ;
 1059                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 9; ; A map system based on 16x16 meta-tiles (aka "blocks", aka CHR/BLK/MAP).
 1060                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 10; ;
 1061                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 11; ; Copyright John Brandwood 2025.
 1062                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 12; ;
 1063                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 13; ; Distributed under the Boost Software License, Version 1.0.
 1064                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 14; ; (See accompanying file LICENSE_1_0.txt or copy at
 1065                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 15; ;  http://www.boost.org/LICENSE_1_0.txt)
 1066                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 16; ;
 1067                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 17; ; ***************************************************************************
 1068                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 18; ; ***************************************************************************
 1069                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 19; ;
 1070                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 20; ; The maximum X and Y size for blkmaps is 128 blocks (2048 pixels).
 1071                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 21; ;
 1072                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 22; ; The maximum total size for a blkmap is 16KBytes, which allows for maps up
 1073                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 23; ; to 128x128 blocks (2048x2048 pixels).
 1074                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 24; ;
 1075                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 25; ; Huge multi-screen blkmaps are also supported (optionally).
 1076                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 26; ;
 1077                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 27; ; The maximum X and Y for multi-screen maps is 128 screens (32768 pixels).
 1078                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 28; ;
 1079                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 29; ; The maximum total size for a multi-screen map is 8KBytes, which allows for
 1080                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 30; ; a total of 1024 screens.
 1081                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 31; ;
 1082                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 32; ; ***************************************************************************
 1083                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 33; ; **************************************************************************/
 1084                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 35; // *************
 1085                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 36; // Functions in blkmap.asm ...
 1086                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 37; // *************
 1087                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 39; #ifdef __HUCC__
 1088                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 41; #asmdef	HUCC_USES_BLKMAP 1
 1089                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 43; // Current top-left of drawn map in pixels.
 1090                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 44; extern unsigned int   vdc_map_pxl_x;
 1091                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 45; extern unsigned int   vdc_map_pxl_y;
 1092                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 47; // Width and height to draw/scroll in characters (not tiles).
 1093                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 48; extern unsigned char  vdc_map_draw_w;
 1094                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 49; extern unsigned char  vdc_map_draw_h;
 1095                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 51; // Width of map (or multi-screen BAT) in tiles.
 1096                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 52; extern unsigned char  vdc_map_line_w;
 1097                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 54; // Width of map in screens (if multi-screen map).
 1098                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 55; extern unsigned char  vdc_map_scrn_w;
 1099                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 57; // Extra information returned by get_map_block() and sgx_get_map_block(),
 1100                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 58; // which are the collision flags and the mask/overlay sprite for the BLK.
 1101                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 59; extern unsigned char  map_blk_flag;
 1102                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 60; extern unsigned char  map_blk_mask;
 1103                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 62; extern unsigned char  vdc_scr_bank;
 1104                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 63; extern unsigned char *vdc_scr_addr;
 1105                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 65; extern unsigned char  vdc_map_bank;
 1106                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 66; extern unsigned char *vdc_map_addr;
 1107                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 68; extern unsigned char  vdc_blk_bank;
 1108                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 69; extern unsigned char *vdc_blk_addr;
 1109                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 71; extern unsigned char  vdc_tbl_bank;
 1110                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 72; extern unsigned char *vdc_tbl_addr;
 1111                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 74; extern void __fastcall set_blocks( unsigned char __far *blk_def<vdc_blk_bank:vdc_blk_addr>, unsigned char __far *flg_def<vdc_tbl_bank:vdc_tbl_addr>, unsigned char number_of_blocks<_al> );
 1112                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 75; extern void __fastcall __macro set_blkmap( unsigned char __far *blk_map<vdc_map_bank:vdc_map_addr>, unsigned char blocks_w<vdc_map_line_w> );
 1113                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 76; extern void __fastcall __macro set_multimap( unsigned char __far *multi_map<vdc_scr_bank:vdc_scr_addr>, unsigned char screens_w<vdc_map_scrn_w> );
 1114                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 78; extern void __fastcall draw_map( void );
 1115                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 79; extern void __fastcall scroll_map( void );
 1116                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 81; extern void __fastcall blit_map( unsigned char tile_x<map_bat_x>, unsigned char tile_y<map_bat_y>, unsigned char tile_w<map_draw_x>, unsigned char tile_h<map_draw_y> );
 1117                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 83; extern unsigned char __fastcall get_map_block( unsigned int x<map_pxl_x>, unsigned int y<map_pxl_y> );
 1118                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 85; #asm
 1119                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 86; .macro	_set_blkmap.2
 1120                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 87; stz	vdc_scr_bank
 1121                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 88; .endm
 1122                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 90; .macro	_set_multimap.2
 1123                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 91; lda	vdc_bat_width
 1124                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 92; lsr	a
 1125                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 93; sta	vdc_map_line_w
 1126                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 94; .endm
 1127                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 96; .macro	SCREEN
 1128                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 97; db	(((\1) & $1FFF) | $6000) >> 8, bank(\1)
 1129                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 98; db	(((\2) & $1FFF) | $4000) >> 8, bank(\2)
 1130                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 99; db	(((\3) & $1FFF) | $6000) >> 8, bank(\3)
 1131                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 100; dw	(\4)
 1132                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 101; .endm
 1133                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 102; #endasm
 1134                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 104; #ifdef _SGX
 1135                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 106; // Current top-left of drawn map in pixels.
 1136                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 107; extern unsigned int   sgx_map_pxl_x;
 1137                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 108; extern unsigned int   sgx_map_pxl_y;
 1138                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 110; // Width and height to draw/scroll in characters (not tiles).
 1139                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 111; extern unsigned char  sgx_map_draw_w;
 1140                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 112; extern unsigned char  sgx_map_draw_h;
 1141                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 114; // Width of map (or multi-screen BAT) in tiles.
 1142                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 115; extern unsigned char  sgx_map_line_w;
 1143                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 117; // Width of map in screens (if multi-screen map).
 1144                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 118; extern unsigned char  sgx_map_scrn_w;
 1145                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 120; extern unsigned char  sgx_scr_bank;
 1146                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 121; extern unsigned char *sgx_scr_addr;
 1147                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 123; extern unsigned char  sgx_map_bank;
 1148                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 124; extern unsigned char *sgx_map_addr;
 1149                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 126; extern unsigned char  sgx_blk_bank;
 1150                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 127; extern unsigned char *sgx_blk_addr;
 1151                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 129; extern unsigned char  sgx_tbl_bank;
 1152                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 130; extern unsigned char *sgx_tbl_addr;
 1153                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 132; extern void __fastcall sgx_set_blocks( unsigned char __far *blk_def<sgx_blk_bank:sgx_blk_addr>, unsigned char __far *flg_def<sgx_tbl_bank:sgx_tbl_addr>, unsigned char number_of_blocks<_al> );
 1154                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 133; extern void __fastcall __macro sgx_set_blkmap( unsigned char __far *blk_map<sgx_map_bank:sgx_map_addr>, unsigned char blocks_w<sgx_map_line_w> );
 1155                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 134; extern void __fastcall __macro sgx_set_multimap( unsigned char __far *multi_map<sgx_scr_bank:sgx_scr_addr>, unsigned char screens_w<sgx_map_scrn_w> );
 1156                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 136; extern void __fastcall sgx_draw_map( void );
 1157                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 137; extern void __fastcall sgx_scroll_map( void );
 1158                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 139; extern void __fastcall sgx_blit_map( unsigned char tile_x<map_bat_x>, unsigned char tile_y<map_bat_y>, unsigned char tile_w<map_draw_x>, unsigned char tile_h<map_draw_y> );
 1159                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 141; extern unsigned char __fastcall sgx_get_map_block( unsigned int x<map_pxl_x>, unsigned int y<map_pxl_y> );
 1160                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 143; #asm
 1161                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 144; .macro	_sgx_set_blkmap.2
 1162                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 145; stz	sgx_scr_bank
 1163                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 146; .endm
 1164                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 148; .macro	_sgx_set_multimap.2
 1165                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 149; lda	sgx_bat_width
 1166                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 150; lsr	a
 1167                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 151; sta	sgx_map_line_w
 1168                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 152; .endm
 1169                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 153; #endasm
 1170                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 155; #endif
 1171                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 157; #endif // __HUCC__
 1172                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 159; #endif // _hucc_blkmap_h
 1173                        		.dbg	line,	"main.c", 9; #include "include/constants.c"
 1174                        		.dbg	line,	"include\constants.c", 1; //*****************************************************************************//
 1175                        		.dbg	line,	"include\constants.c", 2; //                                                                             //
 1176                        		.dbg	line,	"include\constants.c", 3; //                                SYSTEM CONSTANTS                             //
 1177                        		.dbg	line,	"include\constants.c", 4; //                                                                             //
 1178                        		.dbg	line,	"include\constants.c", 5; //*****************************************************************************//
 1179                        		.dbg	line,	"include\constants.c", 7; #define FALSE 0
 1180                        		.dbg	line,	"include\constants.c", 8; #define TRUE  1
 1181                        		.dbg	line,	"include\constants.c", 10; #define YES   1
 1182                        		.dbg	line,	"include\constants.c", 11; #define NO    2
 1183                        		.dbg	line,	"include\constants.c", 13; #define JOYPAD_1 0
 1184                        		.dbg	line,	"include\constants.c", 14; #define JOYPAD_2 1
 1185                        		.dbg	line,	"include\constants.c", 16; #define BAT_SIZE_W 2048 // IN PIXELS
 1186                        		.dbg	line,	"include\constants.c", 17; #define BAT_SIZE_H 256  // IN PIXELS
 1187                        		.dbg	line,	"include\constants.c", 19; #define NUMBERS_FONT_VRAM_ADR   0x0900
 1188                        		.dbg	line,	"include\constants.c", 21; #define JOY_DIR_PRESSED (JOY_DOWN | JOY_UP | JOY_RIGHT | JOY_LEFT)
 1189                        		.dbg	line,	"include\constants.c", 24; #define TILES_1   16
 1190                        		.dbg	line,	"include\constants.c", 25; #define TILES_2   32
 1191                        		.dbg	line,	"include\constants.c", 26; #define TILES_3   48
 1192                        		.dbg	line,	"include\constants.c", 27; #define TILES_4   64
 1193                        		.dbg	line,	"include\constants.c", 28; #define TILES_8   128
 1194                        		.dbg	line,	"include\constants.c", 29; #define TILES_16  256
 1195                        		.dbg	line,	"include\constants.c", 30; #define TILES_32  512
 1196                        		.dbg	line,	"include\constants.c", 31; #define TILES_48  768
 1197                        		.dbg	line,	"include\constants.c", 32; #define TILES_64  1024
 1198                        		.dbg	line,	"include\constants.c", 33; #define TILES_80  1280
 1199                        		.dbg	line,	"include\constants.c", 34; #define TILES_96  1536
 1200                        		.dbg	line,	"include\constants.c", 35; #define TILES_112 1792
 1201                        		.dbg	line,	"include\constants.c", 36; #define TILES_128 2048
 1202                        		.dbg	line,	"include\constants.c", 37; #define TILES_144 2304
 1203                        		.dbg	line,	"include\constants.c", 38; #define TILES_160 2560
 1204                        		.dbg	line,	"include\constants.c", 39; #define TILES_176 2816
 1205                        		.dbg	line,	"include\constants.c", 40; #define TILES_192 3072
 1206                        		.dbg	line,	"include\constants.c", 41; #define TILES_208 3328
 1207                        		.dbg	line,	"include\constants.c", 42; #define TILES_224 3584+256
 1208                        		.dbg	line,	"include\constants.c", 45; #define OFFSET_PLAYER_WALK_1     256
 1209                        		.dbg	line,	"include\constants.c", 46; #define OFFSET_PLAYER_WALK_2     512
 1210                        		.dbg	line,	"include\constants.c", 47; #define OFFSET_PLAYER_WALK_3     768
 1211                        		.dbg	line,	"include\constants.c", 48; #define OFFSET_PLAYER_WALK_4     1024
 1212                        		.dbg	line,	"include\constants.c", 49; #define OFFSET_PLAYER_WALK_5     1280
 1213                        		.dbg	line,	"include\constants.c", 50; #define OFFSET_PLAYER_WALK_6     1536
 1214                        		.dbg	line,	"include\constants.c", 57; #define SEQUENCE_TITLE      0
 1215                        		.dbg	line,	"include\constants.c", 58; #define SEQUENCE_INTRO      1
 1216                        		.dbg	line,	"include\constants.c", 59; #define SEQUENCE_GAME       2
 1217                        		.dbg	line,	"include\constants.c", 62; #define CAMERA_RECENTER_VELOCITY    4
 1218                        		.dbg	line,	"include\constants.c", 67; //-----------------------------------------------------------------------------//
 1219                        		.dbg	line,	"include\constants.c", 68; //                                                                             //
 1220                        		.dbg	line,	"include\constants.c", 69; //                                   PLAYER                                    //
 1221                        		.dbg	line,	"include\constants.c", 70; //                                                                             //
 1222                        		.dbg	line,	"include\constants.c", 71; //-----------------------------------------------------------------------------//
 1223                        		.dbg	line,	"include\constants.c", 73; #define AXIS_RIGHT          0
 1224                        		.dbg	line,	"include\constants.c", 74; #define AXIS_LEFT           1
 1225                        		.dbg	line,	"include\constants.c", 75; #define AXIS_UP             2
 1226                        		.dbg	line,	"include\constants.c", 76; #define AXIS_DOWN           3
 1227                        		.dbg	line,	"include\constants.c", 80; #define STATE_IDLE                  0
 1228                        		.dbg	line,	"include\constants.c", 81; #define STATE_WALK                  1
 1229                        		.dbg	line,	"include\constants.c", 82; #define STATE_PUNCH                 2
 1230                        		.dbg	line,	"include\constants.c", 83; #define STATE_JUMP                  4
 1231                        		.dbg	line,	"include\constants.c", 84; #define STATE_JUMP_RIGHT            5
 1232                        		.dbg	line,	"include\constants.c", 85; #define STATE_JUMP_LEFT             6
 1233                        		.dbg	line,	"include\constants.c", 86; #define STATE_CROUCH                7
 1234                        		.dbg	line,	"include\constants.c", 87; #define STATE_CROUCH_PUNCH          8
 1235                        		.dbg	line,	"include\constants.c", 88; #define STATE_FALL                  9
 1236                        		.dbg	line,	"include\constants.c", 89; #define STATE_HANG                  10
 1237                        		.dbg	line,	"include\constants.c", 90; #define STATE_CLIMB_UP              11
 1238                        		.dbg	line,	"include\constants.c", 91; #define STATE_CLIMB_DOWN            12
 1239                        		.dbg	line,	"include\constants.c", 92; #define STATE_JUMP_LADDER           13
 1240                        		.dbg	line,	"include\constants.c", 96; #define PLAYER_VRAM_ADR     0x1800
 1241                        		.dbg	line,	"include\constants.c", 98; #define PLAYER_BASE_Y_POS   128
 1242                        		.dbg	line,	"include\constants.c", 103; //-----------------------------------------------------------------------------//
 1243                        		.dbg	line,	"include\constants.c", 104; //                                                                             //
 1244                        		.dbg	line,	"include\constants.c", 105; //                                  COLLISIONS                                 //
 1245                        		.dbg	line,	"include\constants.c", 106; //                                                                             //
 1246                        		.dbg	line,	"include\constants.c", 107; //-----------------------------------------------------------------------------//
 1247                        		.dbg	line,	"include\constants.c", 109; #define TILE_EMPTY          0
 1248                        		.dbg	line,	"include\constants.c", 110; #define TILE_BG             1
 1249                        		.dbg	line,	"include\constants.c", 111; #define TILE_LADDER         2
 1250                        		.dbg	line,	"include\constants.c", 116; //-----------------------------------------------------------------------------//
 1251                        		.dbg	line,	"include\constants.c", 117; //                                                                             //
 1252                        		.dbg	line,	"include\constants.c", 118; //                                     HUD                                     //
 1253                        		.dbg	line,	"include\constants.c", 119; //                                                                             //
 1254                        		.dbg	line,	"include\constants.c", 120; //-----------------------------------------------------------------------------//
 1255                        		.dbg	line,	"include\constants.c", 122; #define LIFEBAR_1_VRAM_ADR      0x1000
 1256                        		.dbg	line,	"include\constants.c", 123; #define LIFEBAR_2_VRAM_ADR      LIFEBAR_1_VRAM_ADR+TILES_2
 1257                        		.dbg	line,	"include\constants.c", 124; #define LIFEBAR_3_VRAM_ADR      LIFEBAR_2_VRAM_ADR+TILES_2
 1258                        		.dbg	line,	"include\constants.c", 125; #define LIFEBAR_4_VRAM_ADR      LIFEBAR_3_VRAM_ADR+TILES_2
 1259                        		.dbg	line,	"include\constants.c", 126; #define LIFEBAR_5_VRAM_ADR      LIFEBAR_4_VRAM_ADR+TILES_2
 1260                        		.dbg	line,	"include\constants.c", 128; #define WEAPON_VRAM_ADR         LIFEBAR_5_VRAM_ADR+TILES_2
 1261                        		.dbg	line,	"include\constants.c", 129; #define ARMOR_VRAM_ADR          WEAPON_VRAM_ADR+TILES_4
 1262                        		.dbg	line,	"include\constants.c", 134; //-----------------------------------------------------------------------------//
 1263                        		.dbg	line,	"include\constants.c", 135; //                                                                             //
 1264                        		.dbg	line,	"include\constants.c", 136; //                                    LEVELS                                   //
 1265                        		.dbg	line,	"include\constants.c", 137; //                                                                             //
 1266                        		.dbg	line,	"include\constants.c", 138; //-----------------------------------------------------------------------------//
 1267                        		.dbg	line,	"include\constants.c", 140; #define LV1_WALL_VRAM_ADR       0x1000
 1268                        		.dbg	line,	"include\constants.c", 141; #define LV1_DOOR_VRAM_ADR       LV1_WALL_VRAM_ADR+256
 1269                        		.dbg	line,	"include\constants.c", 144; #define OBJECT_NUMBER_LV1       23
 1270                        		.dbg	line,	"include\constants.c", 145; #define CHEST_NUMBER_LV1        2
 1271                        		.dbg	line,	"include\constants.c", 146; #define NPC_NUMBER_LV1          2
 1272                        		.dbg	line,	"include\constants.c", 148; #define OBJECT_START_INDEX_LV1  3
 1273                        		.dbg	line,	"include\constants.c", 149; #define CHEST_START_INDEX_LV1   OBJECT_START_INDEX_LV1+OBJECT_NUMBER_LV1
 1274                        		.dbg	line,	"include\constants.c", 150; #define NPC_START_INDEX_LV1     CHEST_START_INDEX_LV1+CHEST_NUMBER_LV1
 1275                        		.dbg	line,	"include\constants.c", 155; //-----------------------------------------------------------------------------//
 1276                        		.dbg	line,	"include\constants.c", 156; //                                                                             //
 1277                        		.dbg	line,	"include\constants.c", 157; //                                   OBJECTS                                   //
 1278                        		.dbg	line,	"include\constants.c", 158; //                                                                             //
 1279                        		.dbg	line,	"include\constants.c", 159; //-----------------------------------------------------------------------------//
 1280                        		.dbg	line,	"include\constants.c", 161; #define TYPE_HOURGLASS          0
 1281                        		.dbg	line,	"include\constants.c", 162; #define TYPE_POT                1
 1282                        		.dbg	line,	"include\constants.c", 163; #define TYPE_POW                2
 1283                        		.dbg	line,	"include\constants.c", 164; #define TYPE_CHEST              3
 1284                        		.dbg	line,	"include\constants.c", 165; #define TYPE_GRAY_KEY           4
 1285                        		.dbg	line,	"include\constants.c", 166; #define TYPE_GOLD_KEY           5
 1286                        		.dbg	line,	"include\constants.c", 167; #define TYPE_1UP                6
 1287                        		.dbg	line,	"include\constants.c", 168; #define TYPE_COIN_1             7
 1288                        		.dbg	line,	"include\constants.c", 169; #define TYPE_COIN_5             8
 1289                        		.dbg	line,	"include\constants.c", 170; #define TYPE_COIN_10            9
 1290                        		.dbg	line,	"include\constants.c", 171; #define TYPE_COIN_50            10
 1291                        		.dbg	line,	"include\constants.c", 172; #define TYPE_COIN_100           11
 1292                        		.dbg	line,	"include\constants.c", 173; #define TYPE_COIN_500           12
 1293                        		.dbg	line,	"include\constants.c", 174; #define TYPE_COIN_1000          13
 1294                        		.dbg	line,	"include\constants.c", 175; #define TYPE_YASHICHI           14
 1295                        		.dbg	line,	"include\constants.c", 178; #define STATE_ACTIVE            0
 1296                        		.dbg	line,	"include\constants.c", 179; #define STATE_INACTIVE          1
 1297                        		.dbg	line,	"include\constants.c", 182; #define POT1_VRAM_ADR           0x1C00
 1298                        		.dbg	line,	"include\constants.c", 183; #define POT2_VRAM_ADR           POT1_VRAM_ADR+TILES_4
 1299                        		.dbg	line,	"include\constants.c", 184; #define POT3_VRAM_ADR           POT2_VRAM_ADR+TILES_4
 1300                        		.dbg	line,	"include\constants.c", 185; #define POT4_VRAM_ADR           POT3_VRAM_ADR+TILES_4
 1301                        		.dbg	line,	"include\constants.c", 186; #define POT5_VRAM_ADR           POT4_VRAM_ADR+TILES_4
 1302                        		.dbg	line,	"include\constants.c", 187; #define POT6_VRAM_ADR           POT5_VRAM_ADR+TILES_4
 1303                        		.dbg	line,	"include\constants.c", 188; #define POT7_VRAM_ADR           POT6_VRAM_ADR+TILES_4
 1304                        		.dbg	line,	"include\constants.c", 189; #define POT8_VRAM_ADR           POT7_VRAM_ADR+TILES_4
 1305                        		.dbg	line,	"include\constants.c", 191; #define POW_VRAM_ADR            POT8_VRAM_ADR+TILES_4
 1306                        		.dbg	line,	"include\constants.c", 192; #define GRAY_KEY_VRAM_ADR       POW_VRAM_ADR+TILES_4
 1307                        		.dbg	line,	"include\constants.c", 193; #define GOLD_KEY_VRAM_ADR       GRAY_KEY_VRAM_ADR+TILES_4
 1308                        		.dbg	line,	"include\constants.c", 194; #define LIFE_VRAM_ADR           GOLD_KEY_VRAM_ADR+TILES_4
 1309                        		.dbg	line,	"include\constants.c", 196; #define COIN_1_VRAM_ADR         LIFE_VRAM_ADR+TILES_4
 1310                        		.dbg	line,	"include\constants.c", 197; #define COIN_5_VRAM_ADR         COIN_1_VRAM_ADR+TILES_4
 1311                        		.dbg	line,	"include\constants.c", 198; #define COIN_10_VRAM_ADR        COIN_5_VRAM_ADR+TILES_4
 1312                        		.dbg	line,	"include\constants.c", 199; #define COIN_50_VRAM_ADR        COIN_10_VRAM_ADR+TILES_4
 1313                        		.dbg	line,	"include\constants.c", 200; #define COIN_100_VRAM_ADR       COIN_50_VRAM_ADR+TILES_4
 1314                        		.dbg	line,	"include\constants.c", 201; #define COIN_500_VRAM_ADR       COIN_100_VRAM_ADR+TILES_4
 1315                        		.dbg	line,	"include\constants.c", 202; #define COIN_1000_VRAM_ADR      COIN_500_VRAM_ADR+TILES_4
 1316                        		.dbg	line,	"include\constants.c", 204; #define STAR_VRAM_ADR           COIN_1000_VRAM_ADR+TILES_4
 1317                        		.dbg	line,	"include\constants.c", 205; #define OCTOPUS_VRAM_ADR        STAR_VRAM_ADR+TILES_4
 1318                        		.dbg	line,	"include\constants.c", 206; #define FRUIT_VRAM_ADR          OCTOPUS_VRAM_ADR+TILES_4
 1319                        		.dbg	line,	"include\constants.c", 207; #define BARREL_VRAM_ADR         FRUIT_VRAM_ADR+TILES_4
 1320                        		.dbg	line,	"include\constants.c", 208; #define HOURGLASS_VRAM_ADR      BARREL_VRAM_ADR+TILES_4
 1321                        		.dbg	line,	"include\constants.c", 209; #define BAMBOO_VRAM_ADR         HOURGLASS_VRAM_ADR+TILES_4
 1322                        		.dbg	line,	"include\constants.c", 210; #define YASHICHI_VRAM_ADR       BAMBOO_VRAM_ADR+TILES_4
 1323                        		.dbg	line,	"include\constants.c", 211; #define ELEPHANT_VRAM_ADR       YASHICHI_VRAM_ADR+TILES_4
 1324                        		.dbg	line,	"include\constants.c", 212; #define DRAGONFLY_VRAM_ADR      ELEPHANT_VRAM_ADR+TILES_4
 1325                        		.dbg	line,	"include\constants.c", 213; #define COW_VRAM_ADR            DRAGONFLY_VRAM_ADR+TILES_4
 1326                        		.dbg	line,	"include\constants.c", 214; #define MOBICHAN_VRAM_ADR       COW_VRAM_ADR+TILES_4
 1327                        		.dbg	line,	"include\constants.c", 216; #define CHEST_VRAM_ADR          0x2400
 1328                        		.dbg	line,	"include\constants.c", 217; #define NPC_VRAM_ADR            CHEST_VRAM_ADR+TILES_96
 1329                        		.dbg	line,	"main.c", 10; #include "include/variables.c"
 1330                        		.dbg	line,	"include\variables.c", 1; #include "huc.h"
 1331                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 1; #ifndef _hucc_legacy_h
 1332                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 2; #define _hucc_legacy_h
 1333                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 4; /****************************************************************************
 1334                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 5; ; ***************************************************************************
 1335                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 6; ;
 1336                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 7; ; huc.h
 1337                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 8; ;
 1338                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 9; ; HuCC wrapper file to include a default set of HuC-compatible functions.
 1339                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 10; ;
 1340                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 11; ; Copyright John Brandwood 2024.
 1341                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 12; ;
 1342                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 13; ; Distributed under the Boost Software License, Version 1.0.
 1343                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 14; ; (See accompanying file LICENSE_1_0.txt or copy at
 1344                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 15; ;  http://www.boost.org/LICENSE_1_0.txt)
 1345                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 16; ;
 1346                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 17; ; ***************************************************************************
 1347                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 18; ; ***************************************************************************
 1348                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 19; ;
 1349                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 20; ; When the HuCC compiler is invoked with the "--legacy" option to compile old
 1350                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 21; ; projects, then this "huc.h" file is automatically included.
 1351                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 22; ;
 1352                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 23; ; This file includes a set of the individual HuCC headers which correspond to
 1353                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 24; ; HuC's built-in functions and MagicKit library.
 1354                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 25; ;
 1355                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 26; ; New HuCC projects should, preferably, include the specific headers that are
 1356                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 27; ; needed, which will then allow them to replace parts of the standard library
 1357                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 28; ; with newer functions, or they can just manually include this "huc.h" file.
 1358                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 29; ;
 1359                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 30; ; ***************************************************************************
 1360                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 31; ; **************************************************************************/
 1361                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 33; #include "hucc-systemcard.h"
 1362                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 34; #include "hucc-baselib.h"
 1363                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 35; #include "hucc-gfx.h"
 1364                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 36; #include "hucc-string.h"
 1365                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 37; #include "hucc-old-scroll.h"
 1366                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 38; #include "hucc-old-spr.h"
 1367                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 39; #include "hucc-old-map.h"
 1368                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 40; #include "hucc-old-line.h"
 1369                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 42; #endif // _hucc_legacy_h
 1370                        		.dbg	line,	"include\variables.c", 2; #include "hucc-scroll.h"
 1371                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 1; #ifndef _hucc_scroll_h
 1372                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 2; #define _hucc_scroll_h
 1373                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 4; /****************************************************************************
 1374                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 5; ; ***************************************************************************
 1375                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 6; ;
 1376                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 7; ; hucc-scroll.h
 1377                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 8; ;
 1378                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 9; ; Routines for a fast split-screen scrolling system.
 1379                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 10; ;
 1380                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 11; ; Copyright John Brandwood 2024.
 1381                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 12; ;
 1382                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 13; ; Distributed under the Boost Software License, Version 1.0.
 1383                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 14; ; (See accompanying file LICENSE_1_0.txt or copy at
 1384                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 15; ;  http://www.boost.org/LICENSE_1_0.txt)
 1385                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 16; ;
 1386                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 17; ; ***************************************************************************
 1387                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 18; ; ***************************************************************************
 1388                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 19; ;
 1389                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 20; ; The maximum number of splits for each screen layer is set in your project's
 1390                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 21; ; "hucc-config.inc" file, with the library having a limit of 128-per-layer.
 1391                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 22; ;
 1392                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 23; ; Your first active split must be defined to start at screen line 0, and then
 1393                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 24; ; the rest of the active splits must be in increasing line order to match the
 1394                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 25; ; way that the PC Engine displays the output image.
 1395                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 26; ;
 1396                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 27; ; You can have disabled splits interleaved with your active splits.
 1397                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 28; ;
 1398                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 29; ; Splits that are normally disabled can be used to create full screen effects
 1399                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 30; ; such as bouncing the screen up and down by adding blank areas at the top or
 1400                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 31; ; bottom of the screen, and then rapidly changing the height of those areas.
 1401                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 32; ;
 1402                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 33; ; ***************************************************************************
 1403                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 34; ; **************************************************************************/
 1404                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 36; // *************
 1405                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 37; // VDC bits for display_flags ...
 1406                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 38; // *************
 1407                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 40; #ifndef BKG_OFF
 1408                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 41; #define BKG_OFF 0x00
 1409                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 42; #endif
 1410                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 44; #ifndef SPR_OFF
 1411                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 45; #define SPR_OFF 0x00
 1412                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 46; #endif
 1413                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 48; #ifndef BKG_ON
 1414                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 49; #define BKG_ON 0x80
 1415                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 50; #endif
 1416                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 52; #ifndef SPR_ON
 1417                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 53; #define SPR_ON 0x40
 1418                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 54; #endif
 1419                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 56; // *************
 1420                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 57; // Functions in hucc-scroll.asm ...
 1421                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 58; // *************
 1422                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 60; #ifdef __HUCC__
 1423                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 62; #asmdef	HUCC_USES_NEW_SCROLL 1
 1424                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 64; extern void __fastcall scroll_split( unsigned char index<_al>, unsigned char screen_line<_ah>, unsigned int bat_x<_bx>, unsigned int bat_y<_cx>, unsigned char display_flags<_dl> );
 1425                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 65; extern void __fastcall sgx_scroll_split( unsigned char index<_al>, unsigned char screen_line<_ah>, unsigned int bat_x<_bx>, unsigned int bat_y<_cx>, unsigned char display_flags<_dl> );
 1426                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 67; extern void __fastcall disable_split( unsigned char index<acc> );
 1427                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 68; extern void __fastcall sgx_disable_split( unsigned char index<acc> );
 1428                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 70; extern void __fastcall __macro disable_all_splits( void );
 1429                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 71; extern void __fastcall __macro sgx_disable_all_splits( void );
 1430                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 73; #asm
 1431                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 74; .macro	_disable_all_splits
 1432                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 75; ldy	#HUCC_PCE_SPLITS - 1
 1433                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 76; !loop:		tya
 1434                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 77; call	_disable_split.1
 1435                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 78; dey
 1436                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 79; bpl	!loop-
 1437                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 80; .endm
 1438                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 82; .macro	_sgx_disable_all_splits
 1439                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 83; ldy	#HUCC_SGX_SPLITS - 1
 1440                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 84; !loop:		tya
 1441                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 85; call	_sgx_disable_split.1
 1442                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 86; dey
 1443                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 87; bpl	!loop-
 1444                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 88; .endm
 1445                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 89; #endasm
 1446                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 91; #endif // __HUCC__
 1447                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 93; #endif // _hucc_scroll_h
 1448                        		.dbg	line,	"include\variables.c", 3; #include "hucc-chrmap.h"
 1449                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 1; #ifndef _hucc_chrmap_h
 1450                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 2; #define _hucc_chrmap_h
 1451                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 4; /****************************************************************************
 1452                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 5; ; ***************************************************************************
 1453                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 6; ;
 1454                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 7; ; hucc-chrmap.h
 1455                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 8; ;
 1456                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 9; ; A simple map system based on 8x8 characters (aka "tiles") in BAT format.
 1457                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 10; ;
 1458                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 11; ; Copyright John Brandwood 2025.
 1459                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 12; ;
 1460                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 13; ; Distributed under the Boost Software License, Version 1.0.
 1461                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 14; ; (See accompanying file LICENSE_1_0.txt or copy at
 1462                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 15; ;  http://www.boost.org/LICENSE_1_0.txt)
 1463                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 16; ;
 1464                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 17; ; ***************************************************************************
 1465                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 18; ; ***************************************************************************
 1466                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 19; ;
 1467                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 20; ; The maximum X and Y size for chrmaps is 256 characters (2048 pixels).
 1468                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 21; ;
 1469                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 22; ; The maximum total size for a chrmap is 16KBytes, which allows for maps up
 1470                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 23; ; to 256x32 tiles (2048x256 pixels).
 1471                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 24; ;
 1472                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 25; ; ***************************************************************************
 1473                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 26; ; **************************************************************************/
 1474                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 28; // *************
 1475                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 29; // This code extends the blkmap library ...
 1476                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 30; // *************
 1477                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 32; #include "hucc-blkmap.h"
 1478                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 34; // *************
 1479                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 35; // Functions in chrmap.asm ...
 1480                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 36; // *************
 1481                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 38; #ifdef __HUCC__
 1482                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 40; #asmdef	HUCC_USES_CHRMAP 1
 1483                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 42; extern void __fastcall __nop set_chrmap( unsigned char __far *chrmap<vdc_map_bank:vdc_map_addr>, unsigned char tiles_w<vdc_map_line_w> );
 1484                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 44; extern void __fastcall draw_bat( void );
 1485                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 45; extern void __fastcall scroll_bat( void );
 1486                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 47; extern void __fastcall blit_bat( unsigned char tile_x<map_bat_x>, unsigned char tile_y<map_bat_y>, unsigned char tile_w<map_draw_x>, unsigned char tile_h<map_draw_y> );
 1487                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 49; #ifdef _SGX
 1488                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 51; extern void __fastcall __nop sgx_set_chrmap( unsigned char __far *chrmap<sgx_map_bank:sgx_map_addr>, unsigned char tiles_w<sgx_map_line_w> );
 1489                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 53; extern void __fastcall sgx_draw_bat( void );
 1490                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 54; extern void __fastcall sgx_scroll_bat( void );
 1491                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 56; extern void __fastcall sgx_blit_bat( unsigned char tile_x<map_bat_x>, unsigned char tile_y<map_bat_y>, unsigned char tile_w<map_draw_x>, unsigned char tile_h<map_draw_y> );
 1492                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 58; #endif
 1493                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 60; #endif // __HUCC__
 1494                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 62; #endif // _hucc_chrmap_h
 1495                        		.dbg	line,	"include\variables.c", 4; #include "hucc-blkmap.h"
 1496                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 1; #ifndef _hucc_blkmap_h
 1497                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 2; #define _hucc_blkmap_h
 1498                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 4; /****************************************************************************
 1499                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 5; ; ***************************************************************************
 1500                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 6; ;
 1501                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 7; ; hucc-blkmap.h
 1502                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 8; ;
 1503                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 9; ; A map system based on 16x16 meta-tiles (aka "blocks", aka CHR/BLK/MAP).
 1504                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 10; ;
 1505                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 11; ; Copyright John Brandwood 2025.
 1506                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 12; ;
 1507                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 13; ; Distributed under the Boost Software License, Version 1.0.
 1508                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 14; ; (See accompanying file LICENSE_1_0.txt or copy at
 1509                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 15; ;  http://www.boost.org/LICENSE_1_0.txt)
 1510                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 16; ;
 1511                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 17; ; ***************************************************************************
 1512                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 18; ; ***************************************************************************
 1513                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 19; ;
 1514                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 20; ; The maximum X and Y size for blkmaps is 128 blocks (2048 pixels).
 1515                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 21; ;
 1516                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 22; ; The maximum total size for a blkmap is 16KBytes, which allows for maps up
 1517                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 23; ; to 128x128 blocks (2048x2048 pixels).
 1518                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 24; ;
 1519                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 25; ; Huge multi-screen blkmaps are also supported (optionally).
 1520                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 26; ;
 1521                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 27; ; The maximum X and Y for multi-screen maps is 128 screens (32768 pixels).
 1522                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 28; ;
 1523                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 29; ; The maximum total size for a multi-screen map is 8KBytes, which allows for
 1524                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 30; ; a total of 1024 screens.
 1525                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 31; ;
 1526                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 32; ; ***************************************************************************
 1527                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 33; ; **************************************************************************/
 1528                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 35; // *************
 1529                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 36; // Functions in blkmap.asm ...
 1530                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 37; // *************
 1531                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 39; #ifdef __HUCC__
 1532                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 41; #asmdef	HUCC_USES_BLKMAP 1
 1533                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 43; // Current top-left of drawn map in pixels.
 1534                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 44; extern unsigned int   vdc_map_pxl_x;
 1535                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 45; extern unsigned int   vdc_map_pxl_y;
 1536                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 47; // Width and height to draw/scroll in characters (not tiles).
 1537                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 48; extern unsigned char  vdc_map_draw_w;
 1538                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 49; extern unsigned char  vdc_map_draw_h;
 1539                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 51; // Width of map (or multi-screen BAT) in tiles.
 1540                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 52; extern unsigned char  vdc_map_line_w;
 1541                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 54; // Width of map in screens (if multi-screen map).
 1542                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 55; extern unsigned char  vdc_map_scrn_w;
 1543                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 57; // Extra information returned by get_map_block() and sgx_get_map_block(),
 1544                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 58; // which are the collision flags and the mask/overlay sprite for the BLK.
 1545                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 59; extern unsigned char  map_blk_flag;
 1546                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 60; extern unsigned char  map_blk_mask;
 1547                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 62; extern unsigned char  vdc_scr_bank;
 1548                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 63; extern unsigned char *vdc_scr_addr;
 1549                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 65; extern unsigned char  vdc_map_bank;
 1550                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 66; extern unsigned char *vdc_map_addr;
 1551                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 68; extern unsigned char  vdc_blk_bank;
 1552                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 69; extern unsigned char *vdc_blk_addr;
 1553                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 71; extern unsigned char  vdc_tbl_bank;
 1554                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 72; extern unsigned char *vdc_tbl_addr;
 1555                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 74; extern void __fastcall set_blocks( unsigned char __far *blk_def<vdc_blk_bank:vdc_blk_addr>, unsigned char __far *flg_def<vdc_tbl_bank:vdc_tbl_addr>, unsigned char number_of_blocks<_al> );
 1556                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 75; extern void __fastcall __macro set_blkmap( unsigned char __far *blk_map<vdc_map_bank:vdc_map_addr>, unsigned char blocks_w<vdc_map_line_w> );
 1557                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 76; extern void __fastcall __macro set_multimap( unsigned char __far *multi_map<vdc_scr_bank:vdc_scr_addr>, unsigned char screens_w<vdc_map_scrn_w> );
 1558                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 78; extern void __fastcall draw_map( void );
 1559                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 79; extern void __fastcall scroll_map( void );
 1560                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 81; extern void __fastcall blit_map( unsigned char tile_x<map_bat_x>, unsigned char tile_y<map_bat_y>, unsigned char tile_w<map_draw_x>, unsigned char tile_h<map_draw_y> );
 1561                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 83; extern unsigned char __fastcall get_map_block( unsigned int x<map_pxl_x>, unsigned int y<map_pxl_y> );
 1562                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 85; #asm
 1563                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 86; .macro	_set_blkmap.2
 1564                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 87; stz	vdc_scr_bank
 1565                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 88; .endm
 1566                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 90; .macro	_set_multimap.2
 1567                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 91; lda	vdc_bat_width
 1568                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 92; lsr	a
 1569                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 93; sta	vdc_map_line_w
 1570                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 94; .endm
 1571                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 96; .macro	SCREEN
 1572                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 97; db	(((\1) & $1FFF) | $6000) >> 8, bank(\1)
 1573                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 98; db	(((\2) & $1FFF) | $4000) >> 8, bank(\2)
 1574                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 99; db	(((\3) & $1FFF) | $6000) >> 8, bank(\3)
 1575                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 100; dw	(\4)
 1576                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 101; .endm
 1577                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 102; #endasm
 1578                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 104; #ifdef _SGX
 1579                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 106; // Current top-left of drawn map in pixels.
 1580                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 107; extern unsigned int   sgx_map_pxl_x;
 1581                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 108; extern unsigned int   sgx_map_pxl_y;
 1582                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 110; // Width and height to draw/scroll in characters (not tiles).
 1583                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 111; extern unsigned char  sgx_map_draw_w;
 1584                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 112; extern unsigned char  sgx_map_draw_h;
 1585                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 114; // Width of map (or multi-screen BAT) in tiles.
 1586                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 115; extern unsigned char  sgx_map_line_w;
 1587                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 117; // Width of map in screens (if multi-screen map).
 1588                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 118; extern unsigned char  sgx_map_scrn_w;
 1589                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 120; extern unsigned char  sgx_scr_bank;
 1590                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 121; extern unsigned char *sgx_scr_addr;
 1591                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 123; extern unsigned char  sgx_map_bank;
 1592                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 124; extern unsigned char *sgx_map_addr;
 1593                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 126; extern unsigned char  sgx_blk_bank;
 1594                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 127; extern unsigned char *sgx_blk_addr;
 1595                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 129; extern unsigned char  sgx_tbl_bank;
 1596                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 130; extern unsigned char *sgx_tbl_addr;
 1597                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 132; extern void __fastcall sgx_set_blocks( unsigned char __far *blk_def<sgx_blk_bank:sgx_blk_addr>, unsigned char __far *flg_def<sgx_tbl_bank:sgx_tbl_addr>, unsigned char number_of_blocks<_al> );
 1598                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 133; extern void __fastcall __macro sgx_set_blkmap( unsigned char __far *blk_map<sgx_map_bank:sgx_map_addr>, unsigned char blocks_w<sgx_map_line_w> );
 1599                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 134; extern void __fastcall __macro sgx_set_multimap( unsigned char __far *multi_map<sgx_scr_bank:sgx_scr_addr>, unsigned char screens_w<sgx_map_scrn_w> );
 1600                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 136; extern void __fastcall sgx_draw_map( void );
 1601                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 137; extern void __fastcall sgx_scroll_map( void );
 1602                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 139; extern void __fastcall sgx_blit_map( unsigned char tile_x<map_bat_x>, unsigned char tile_y<map_bat_y>, unsigned char tile_w<map_draw_x>, unsigned char tile_h<map_draw_y> );
 1603                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 141; extern unsigned char __fastcall sgx_get_map_block( unsigned int x<map_pxl_x>, unsigned int y<map_pxl_y> );
 1604                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 143; #asm
 1605                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 144; .macro	_sgx_set_blkmap.2
 1606                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 145; stz	sgx_scr_bank
 1607                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 146; .endm
 1608                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 148; .macro	_sgx_set_multimap.2
 1609                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 149; lda	sgx_bat_width
 1610                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 150; lsr	a
 1611                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 151; sta	sgx_map_line_w
 1612                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 152; .endm
 1613                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 153; #endasm
 1614                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 155; #endif
 1615                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 157; #endif // __HUCC__
 1616                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 159; #endif // _hucc_blkmap_h
 1617                        		.dbg	line,	"include\variables.c", 13; unsigned char   sequence_id,
 1618                        		.dbg	line,	"include\variables.c", 14; sequence_loaded,
 1619                        		.dbg	line,	"include\variables.c", 16; level_id,
 1620                        		.dbg	line,	"include\variables.c", 18; player_id,
 1621                        		.dbg	line,	"include\variables.c", 19; player_state,
 1622                        		.dbg	line,	"include\variables.c", 20; player_axis,
 1623                        		.dbg	line,	"include\variables.c", 21; player_previous_axis,
 1624                        		.dbg	line,	"include\variables.c", 22; player_counter_anim,
 1625                        		.dbg	line,	"include\variables.c", 23; player_index_jump,
 1626                        		.dbg	line,	"include\variables.c", 24; player_index_fall,
 1627                        		.dbg	line,	"include\variables.c", 26; jump_ladder,
 1628                        		.dbg	line,	"include\variables.c", 27; jump_max_index,
 1629                        		.dbg	line,	"include\variables.c", 29; life_number,
 1630                        		.dbg	line,	"include\variables.c", 30; key_number,
 1631                        		.dbg	line,	"include\variables.c", 31; potion_number,
 1632                        		.dbg	line,	"include\variables.c", 32; zenny_number,
 1633                        		.dbg	line,	"include\variables.c", 34; minutes,
 1634                        		.dbg	line,	"include\variables.c", 35; seconds,
 1635                        		.dbg	line,	"include\variables.c", 36; time_counter,
 1636                        		.dbg	line,	"include\variables.c", 39; // OBJECTS //
 1637                        		.dbg	line,	"include\variables.c", 40; object_start_index,
 1638                        		.dbg	line,	"include\variables.c", 41; level_object_number,
 1639                        		.dbg	line,	"include\variables.c", 42; onscreen_object_number,
 1640                        		.dbg	line,	"include\variables.c", 43; 
 1641                        		.dbg	line,	"include\variables.c", 44; list_object_type[25],
 1642                        		.dbg	line,	"include\variables.c", 45; list_object_state[25],
 1643                        		.dbg	line,	"include\variables.c", 46; list_object_energy[25],
 1644                        		.dbg	line,	"include\variables.c", 47; list_reward_type[25],
 1645                        		.dbg	line,	"include\variables.c", 48; 
 1646                        		.dbg	line,	"include\variables.c", 49; list_onscreen_object[8],
 1647                        		.dbg	line,	"include\variables.c", 50; 
 1648                        		.dbg	line,	"include\variables.c", 51; // CHESTS //
 1649                        		.dbg	line,	"include\variables.c", 52; chest_start_index,
 1650                        		.dbg	line,	"include\variables.c", 53; level_chest_number,
 1651                        		.dbg	line,	"include\variables.c", 54; onscreen_chest_number,
 1652                        		.dbg	line,	"include\variables.c", 55; 
 1653                        		.dbg	line,	"include\variables.c", 56; list_chest_state[8],
 1654                        		.dbg	line,	"include\variables.c", 57; list_onscreen_chest[8],
 1655                        		.dbg	line,	"include\variables.c", 59; // NPC //
 1656                        		.dbg	line,	"include\variables.c", 60; npc_start_index,
 1657                        		.dbg	line,	"include\variables.c", 61; level_npc_number,
 1658                        		.dbg	line,	"include\variables.c", 62; onscreen_npc_number,
 1659                        		.dbg	line,	"include\variables.c", 64; list_npc_state[9],
 1660                        		.dbg	line,	"include\variables.c", 65; list_onscreen_npc[9];
 1661                        		.dbg	line,	"include\variables.c", 70; signed int      player_pos_x,
 1662                        		.dbg	line,	"include\variables.c", 71; player_pos_y,
 1663                        		.dbg	line,	"include\variables.c", 72; camera_max_y_position,
 1664                        		.dbg	line,	"include\variables.c", 75; list_object_x_pos[25],
 1665                        		.dbg	line,	"include\variables.c", 76; list_object_y_pos[25],
 1666                        		.dbg	line,	"include\variables.c", 77; list_object_x_pos_ref[25],
 1667                        		.dbg	line,	"include\variables.c", 78; list_object_y_pos_ref[25],
 1668                        		.dbg	line,	"include\variables.c", 81; list_chest_x_pos[8],
 1669                        		.dbg	line,	"include\variables.c", 82; list_chest_y_pos[8],
 1670                        		.dbg	line,	"include\variables.c", 83; list_chest_x_pos_ref[8],
 1671                        		.dbg	line,	"include\variables.c", 84; list_chest_y_pos_ref[8],
 1672                        		.dbg	line,	"include\variables.c", 87; list_npc_x_pos[9],
 1673                        		.dbg	line,	"include\variables.c", 88; list_npc_y_pos[9],
 1674                        		.dbg	line,	"include\variables.c", 89; list_npc_x_pos_ref[9],
 1675                        		.dbg	line,	"include\variables.c", 90; list_npc_y_pos_ref[9];
 1676                        		.dbg	line,	"include\variables.c", 91; 
 1677                        		.dbg	line,	"include\variables.c", 95; extern unsigned char tileset_LV1_BG_B[];
 1678                        		.dbg	line,	"include\variables.c", 96; extern unsigned char multimap_LV1_BG_B[];
 1679                        		.dbg	line,	"include\variables.c", 98; extern unsigned char tileset_LV1_BG_A[];
 1680                        		.dbg	line,	"include\variables.c", 99; extern unsigned char multimap_LV1_BG_A[];
 1681                        		.dbg	line,	"main.c", 15; #include "include/gfx_BG.c"
 1682                        		.dbg	line,	"include\gfx_BG.c", 1; #include "huc.h"
 1683                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 1; #ifndef _hucc_legacy_h
 1684                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 2; #define _hucc_legacy_h
 1685                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 4; /****************************************************************************
 1686                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 5; ; ***************************************************************************
 1687                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 6; ;
 1688                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 7; ; huc.h
 1689                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 8; ;
 1690                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 9; ; HuCC wrapper file to include a default set of HuC-compatible functions.
 1691                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 10; ;
 1692                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 11; ; Copyright John Brandwood 2024.
 1693                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 12; ;
 1694                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 13; ; Distributed under the Boost Software License, Version 1.0.
 1695                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 14; ; (See accompanying file LICENSE_1_0.txt or copy at
 1696                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 15; ;  http://www.boost.org/LICENSE_1_0.txt)
 1697                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 16; ;
 1698                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 17; ; ***************************************************************************
 1699                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 18; ; ***************************************************************************
 1700                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 19; ;
 1701                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 20; ; When the HuCC compiler is invoked with the "--legacy" option to compile old
 1702                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 21; ; projects, then this "huc.h" file is automatically included.
 1703                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 22; ;
 1704                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 23; ; This file includes a set of the individual HuCC headers which correspond to
 1705                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 24; ; HuC's built-in functions and MagicKit library.
 1706                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 25; ;
 1707                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 26; ; New HuCC projects should, preferably, include the specific headers that are
 1708                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 27; ; needed, which will then allow them to replace parts of the standard library
 1709                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 28; ; with newer functions, or they can just manually include this "huc.h" file.
 1710                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 29; ;
 1711                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 30; ; ***************************************************************************
 1712                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 31; ; **************************************************************************/
 1713                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 33; #include "hucc-systemcard.h"
 1714                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 34; #include "hucc-baselib.h"
 1715                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 35; #include "hucc-gfx.h"
 1716                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 36; #include "hucc-string.h"
 1717                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 37; #include "hucc-old-scroll.h"
 1718                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 38; #include "hucc-old-spr.h"
 1719                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 39; #include "hucc-old-map.h"
 1720                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 40; #include "hucc-old-line.h"
 1721                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 42; #endif // _hucc_legacy_h
 1722                        		.dbg	line,	"include\gfx_BG.c", 2; #include "hucc-scroll.h"
 1723                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 1; #ifndef _hucc_scroll_h
 1724                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 2; #define _hucc_scroll_h
 1725                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 4; /****************************************************************************
 1726                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 5; ; ***************************************************************************
 1727                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 6; ;
 1728                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 7; ; hucc-scroll.h
 1729                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 8; ;
 1730                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 9; ; Routines for a fast split-screen scrolling system.
 1731                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 10; ;
 1732                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 11; ; Copyright John Brandwood 2024.
 1733                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 12; ;
 1734                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 13; ; Distributed under the Boost Software License, Version 1.0.
 1735                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 14; ; (See accompanying file LICENSE_1_0.txt or copy at
 1736                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 15; ;  http://www.boost.org/LICENSE_1_0.txt)
 1737                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 16; ;
 1738                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 17; ; ***************************************************************************
 1739                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 18; ; ***************************************************************************
 1740                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 19; ;
 1741                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 20; ; The maximum number of splits for each screen layer is set in your project's
 1742                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 21; ; "hucc-config.inc" file, with the library having a limit of 128-per-layer.
 1743                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 22; ;
 1744                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 23; ; Your first active split must be defined to start at screen line 0, and then
 1745                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 24; ; the rest of the active splits must be in increasing line order to match the
 1746                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 25; ; way that the PC Engine displays the output image.
 1747                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 26; ;
 1748                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 27; ; You can have disabled splits interleaved with your active splits.
 1749                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 28; ;
 1750                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 29; ; Splits that are normally disabled can be used to create full screen effects
 1751                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 30; ; such as bouncing the screen up and down by adding blank areas at the top or
 1752                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 31; ; bottom of the screen, and then rapidly changing the height of those areas.
 1753                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 32; ;
 1754                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 33; ; ***************************************************************************
 1755                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 34; ; **************************************************************************/
 1756                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 36; // *************
 1757                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 37; // VDC bits for display_flags ...
 1758                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 38; // *************
 1759                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 40; #ifndef BKG_OFF
 1760                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 41; #define BKG_OFF 0x00
 1761                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 42; #endif
 1762                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 44; #ifndef SPR_OFF
 1763                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 45; #define SPR_OFF 0x00
 1764                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 46; #endif
 1765                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 48; #ifndef BKG_ON
 1766                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 49; #define BKG_ON 0x80
 1767                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 50; #endif
 1768                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 52; #ifndef SPR_ON
 1769                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 53; #define SPR_ON 0x40
 1770                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 54; #endif
 1771                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 56; // *************
 1772                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 57; // Functions in hucc-scroll.asm ...
 1773                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 58; // *************
 1774                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 60; #ifdef __HUCC__
 1775                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 62; #asmdef	HUCC_USES_NEW_SCROLL 1
 1776                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 64; extern void __fastcall scroll_split( unsigned char index<_al>, unsigned char screen_line<_ah>, unsigned int bat_x<_bx>, unsigned int bat_y<_cx>, unsigned char display_flags<_dl> );
 1777                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 65; extern void __fastcall sgx_scroll_split( unsigned char index<_al>, unsigned char screen_line<_ah>, unsigned int bat_x<_bx>, unsigned int bat_y<_cx>, unsigned char display_flags<_dl> );
 1778                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 67; extern void __fastcall disable_split( unsigned char index<acc> );
 1779                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 68; extern void __fastcall sgx_disable_split( unsigned char index<acc> );
 1780                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 70; extern void __fastcall __macro disable_all_splits( void );
 1781                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 71; extern void __fastcall __macro sgx_disable_all_splits( void );
 1782                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 73; #asm
 1783                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 74; .macro	_disable_all_splits
 1784                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 75; ldy	#HUCC_PCE_SPLITS - 1
 1785                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 76; !loop:		tya
 1786                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 77; call	_disable_split.1
 1787                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 78; dey
 1788                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 79; bpl	!loop-
 1789                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 80; .endm
 1790                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 82; .macro	_sgx_disable_all_splits
 1791                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 83; ldy	#HUCC_SGX_SPLITS - 1
 1792                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 84; !loop:		tya
 1793                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 85; call	_sgx_disable_split.1
 1794                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 86; dey
 1795                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 87; bpl	!loop-
 1796                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 88; .endm
 1797                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 89; #endasm
 1798                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 91; #endif // __HUCC__
 1799                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 93; #endif // _hucc_scroll_h
 1800                        		.dbg	line,	"include\gfx_BG.c", 3; #include "hucc-chrmap.h"
 1801                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 1; #ifndef _hucc_chrmap_h
 1802                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 2; #define _hucc_chrmap_h
 1803                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 4; /****************************************************************************
 1804                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 5; ; ***************************************************************************
 1805                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 6; ;
 1806                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 7; ; hucc-chrmap.h
 1807                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 8; ;
 1808                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 9; ; A simple map system based on 8x8 characters (aka "tiles") in BAT format.
 1809                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 10; ;
 1810                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 11; ; Copyright John Brandwood 2025.
 1811                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 12; ;
 1812                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 13; ; Distributed under the Boost Software License, Version 1.0.
 1813                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 14; ; (See accompanying file LICENSE_1_0.txt or copy at
 1814                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 15; ;  http://www.boost.org/LICENSE_1_0.txt)
 1815                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 16; ;
 1816                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 17; ; ***************************************************************************
 1817                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 18; ; ***************************************************************************
 1818                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 19; ;
 1819                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 20; ; The maximum X and Y size for chrmaps is 256 characters (2048 pixels).
 1820                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 21; ;
 1821                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 22; ; The maximum total size for a chrmap is 16KBytes, which allows for maps up
 1822                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 23; ; to 256x32 tiles (2048x256 pixels).
 1823                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 24; ;
 1824                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 25; ; ***************************************************************************
 1825                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 26; ; **************************************************************************/
 1826                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 28; // *************
 1827                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 29; // This code extends the blkmap library ...
 1828                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 30; // *************
 1829                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 32; #include "hucc-blkmap.h"
 1830                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 34; // *************
 1831                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 35; // Functions in chrmap.asm ...
 1832                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 36; // *************
 1833                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 38; #ifdef __HUCC__
 1834                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 40; #asmdef	HUCC_USES_CHRMAP 1
 1835                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 42; extern void __fastcall __nop set_chrmap( unsigned char __far *chrmap<vdc_map_bank:vdc_map_addr>, unsigned char tiles_w<vdc_map_line_w> );
 1836                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 44; extern void __fastcall draw_bat( void );
 1837                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 45; extern void __fastcall scroll_bat( void );
 1838                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 47; extern void __fastcall blit_bat( unsigned char tile_x<map_bat_x>, unsigned char tile_y<map_bat_y>, unsigned char tile_w<map_draw_x>, unsigned char tile_h<map_draw_y> );
 1839                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 49; #ifdef _SGX
 1840                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 51; extern void __fastcall __nop sgx_set_chrmap( unsigned char __far *chrmap<sgx_map_bank:sgx_map_addr>, unsigned char tiles_w<sgx_map_line_w> );
 1841                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 53; extern void __fastcall sgx_draw_bat( void );
 1842                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 54; extern void __fastcall sgx_scroll_bat( void );
 1843                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 56; extern void __fastcall sgx_blit_bat( unsigned char tile_x<map_bat_x>, unsigned char tile_y<map_bat_y>, unsigned char tile_w<map_draw_x>, unsigned char tile_h<map_draw_y> );
 1844                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 58; #endif
 1845                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 60; #endif // __HUCC__
 1846                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 62; #endif // _hucc_chrmap_h
 1847                        		.dbg	line,	"include\gfx_BG.c", 4; #include "hucc-blkmap.h"
 1848                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 1; #ifndef _hucc_blkmap_h
 1849                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 2; #define _hucc_blkmap_h
 1850                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 4; /****************************************************************************
 1851                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 5; ; ***************************************************************************
 1852                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 6; ;
 1853                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 7; ; hucc-blkmap.h
 1854                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 8; ;
 1855                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 9; ; A map system based on 16x16 meta-tiles (aka "blocks", aka CHR/BLK/MAP).
 1856                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 10; ;
 1857                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 11; ; Copyright John Brandwood 2025.
 1858                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 12; ;
 1859                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 13; ; Distributed under the Boost Software License, Version 1.0.
 1860                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 14; ; (See accompanying file LICENSE_1_0.txt or copy at
 1861                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 15; ;  http://www.boost.org/LICENSE_1_0.txt)
 1862                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 16; ;
 1863                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 17; ; ***************************************************************************
 1864                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 18; ; ***************************************************************************
 1865                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 19; ;
 1866                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 20; ; The maximum X and Y size for blkmaps is 128 blocks (2048 pixels).
 1867                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 21; ;
 1868                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 22; ; The maximum total size for a blkmap is 16KBytes, which allows for maps up
 1869                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 23; ; to 128x128 blocks (2048x2048 pixels).
 1870                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 24; ;
 1871                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 25; ; Huge multi-screen blkmaps are also supported (optionally).
 1872                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 26; ;
 1873                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 27; ; The maximum X and Y for multi-screen maps is 128 screens (32768 pixels).
 1874                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 28; ;
 1875                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 29; ; The maximum total size for a multi-screen map is 8KBytes, which allows for
 1876                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 30; ; a total of 1024 screens.
 1877                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 31; ;
 1878                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 32; ; ***************************************************************************
 1879                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 33; ; **************************************************************************/
 1880                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 35; // *************
 1881                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 36; // Functions in blkmap.asm ...
 1882                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 37; // *************
 1883                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 39; #ifdef __HUCC__
 1884                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 41; #asmdef	HUCC_USES_BLKMAP 1
 1885                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 43; // Current top-left of drawn map in pixels.
 1886                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 44; extern unsigned int   vdc_map_pxl_x;
 1887                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 45; extern unsigned int   vdc_map_pxl_y;
 1888                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 47; // Width and height to draw/scroll in characters (not tiles).
 1889                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 48; extern unsigned char  vdc_map_draw_w;
 1890                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 49; extern unsigned char  vdc_map_draw_h;
 1891                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 51; // Width of map (or multi-screen BAT) in tiles.
 1892                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 52; extern unsigned char  vdc_map_line_w;
 1893                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 54; // Width of map in screens (if multi-screen map).
 1894                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 55; extern unsigned char  vdc_map_scrn_w;
 1895                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 57; // Extra information returned by get_map_block() and sgx_get_map_block(),
 1896                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 58; // which are the collision flags and the mask/overlay sprite for the BLK.
 1897                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 59; extern unsigned char  map_blk_flag;
 1898                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 60; extern unsigned char  map_blk_mask;
 1899                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 62; extern unsigned char  vdc_scr_bank;
 1900                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 63; extern unsigned char *vdc_scr_addr;
 1901                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 65; extern unsigned char  vdc_map_bank;
 1902                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 66; extern unsigned char *vdc_map_addr;
 1903                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 68; extern unsigned char  vdc_blk_bank;
 1904                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 69; extern unsigned char *vdc_blk_addr;
 1905                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 71; extern unsigned char  vdc_tbl_bank;
 1906                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 72; extern unsigned char *vdc_tbl_addr;
 1907                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 74; extern void __fastcall set_blocks( unsigned char __far *blk_def<vdc_blk_bank:vdc_blk_addr>, unsigned char __far *flg_def<vdc_tbl_bank:vdc_tbl_addr>, unsigned char number_of_blocks<_al> );
 1908                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 75; extern void __fastcall __macro set_blkmap( unsigned char __far *blk_map<vdc_map_bank:vdc_map_addr>, unsigned char blocks_w<vdc_map_line_w> );
 1909                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 76; extern void __fastcall __macro set_multimap( unsigned char __far *multi_map<vdc_scr_bank:vdc_scr_addr>, unsigned char screens_w<vdc_map_scrn_w> );
 1910                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 78; extern void __fastcall draw_map( void );
 1911                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 79; extern void __fastcall scroll_map( void );
 1912                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 81; extern void __fastcall blit_map( unsigned char tile_x<map_bat_x>, unsigned char tile_y<map_bat_y>, unsigned char tile_w<map_draw_x>, unsigned char tile_h<map_draw_y> );
 1913                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 83; extern unsigned char __fastcall get_map_block( unsigned int x<map_pxl_x>, unsigned int y<map_pxl_y> );
 1914                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 85; #asm
 1915                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 86; .macro	_set_blkmap.2
 1916                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 87; stz	vdc_scr_bank
 1917                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 88; .endm
 1918                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 90; .macro	_set_multimap.2
 1919                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 91; lda	vdc_bat_width
 1920                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 92; lsr	a
 1921                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 93; sta	vdc_map_line_w
 1922                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 94; .endm
 1923                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 96; .macro	SCREEN
 1924                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 97; db	(((\1) & $1FFF) | $6000) >> 8, bank(\1)
 1925                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 98; db	(((\2) & $1FFF) | $4000) >> 8, bank(\2)
 1926                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 99; db	(((\3) & $1FFF) | $6000) >> 8, bank(\3)
 1927                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 100; dw	(\4)
 1928                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 101; .endm
 1929                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 102; #endasm
 1930                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 104; #ifdef _SGX
 1931                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 106; // Current top-left of drawn map in pixels.
 1932                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 107; extern unsigned int   sgx_map_pxl_x;
 1933                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 108; extern unsigned int   sgx_map_pxl_y;
 1934                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 110; // Width and height to draw/scroll in characters (not tiles).
 1935                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 111; extern unsigned char  sgx_map_draw_w;
 1936                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 112; extern unsigned char  sgx_map_draw_h;
 1937                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 114; // Width of map (or multi-screen BAT) in tiles.
 1938                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 115; extern unsigned char  sgx_map_line_w;
 1939                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 117; // Width of map in screens (if multi-screen map).
 1940                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 118; extern unsigned char  sgx_map_scrn_w;
 1941                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 120; extern unsigned char  sgx_scr_bank;
 1942                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 121; extern unsigned char *sgx_scr_addr;
 1943                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 123; extern unsigned char  sgx_map_bank;
 1944                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 124; extern unsigned char *sgx_map_addr;
 1945                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 126; extern unsigned char  sgx_blk_bank;
 1946                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 127; extern unsigned char *sgx_blk_addr;
 1947                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 129; extern unsigned char  sgx_tbl_bank;
 1948                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 130; extern unsigned char *sgx_tbl_addr;
 1949                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 132; extern void __fastcall sgx_set_blocks( unsigned char __far *blk_def<sgx_blk_bank:sgx_blk_addr>, unsigned char __far *flg_def<sgx_tbl_bank:sgx_tbl_addr>, unsigned char number_of_blocks<_al> );
 1950                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 133; extern void __fastcall __macro sgx_set_blkmap( unsigned char __far *blk_map<sgx_map_bank:sgx_map_addr>, unsigned char blocks_w<sgx_map_line_w> );
 1951                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 134; extern void __fastcall __macro sgx_set_multimap( unsigned char __far *multi_map<sgx_scr_bank:sgx_scr_addr>, unsigned char screens_w<sgx_map_scrn_w> );
 1952                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 136; extern void __fastcall sgx_draw_map( void );
 1953                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 137; extern void __fastcall sgx_scroll_map( void );
 1954                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 139; extern void __fastcall sgx_blit_map( unsigned char tile_x<map_bat_x>, unsigned char tile_y<map_bat_y>, unsigned char tile_w<map_draw_x>, unsigned char tile_h<map_draw_y> );
 1955                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 141; extern unsigned char __fastcall sgx_get_map_block( unsigned int x<map_pxl_x>, unsigned int y<map_pxl_y> );
 1956                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 143; #asm
 1957                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 144; .macro	_sgx_set_blkmap.2
 1958                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 145; stz	sgx_scr_bank
 1959                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 146; .endm
 1960                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 148; .macro	_sgx_set_multimap.2
 1961                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 149; lda	sgx_bat_width
 1962                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 150; lsr	a
 1963                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 151; sta	sgx_map_line_w
 1964                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 152; .endm
 1965                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 153; #endasm
 1966                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 155; #endif
 1967                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 157; #endif // __HUCC__
 1968                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 159; #endif // _hucc_blkmap_h
 1969                        		.dbg	line,	"include\gfx_BG.c", 13; #incchr(tileset_NUMBERS_FONT,"res/maps/tiles_NUMBERS_FONT.png");
 1970               6000     		.data
 1971    03:6000             	_tileset_NUMBERS_FONT: 	.incchr		"res/maps/tiles_NUMBERS_FONT.png"
 1972               E309     		.code
 1973                        		.dbg	line,	"include\gfx_BG.c", 16; //**************************************************************************************//
 1974                        		.dbg	line,	"include\gfx_BG.c", 17; //                                                                                      //
 1975                        		.dbg	line,	"include\gfx_BG.c", 18; //                                       LEVEL 1                                        //
 1976                        		.dbg	line,	"include\gfx_BG.c", 19; //                                                                                      //
 1977                        		.dbg	line,	"include\gfx_BG.c", 20; //**************************************************************************************//
 1978                        		.dbg	line,	"include\gfx_BG.c", 22; #incchr(tileset_LV1_WALL,"res/maps/tiles_LV1_WALL.png", 4 , 4);
 1979               6140     		.data
 1980    03:6140             	_tileset_LV1_WALL: 	.incchr		"res/maps/tiles_LV1_WALL.png", 4, 4
 1981               E309     		.code
 1982                        		.dbg	line,	"include\gfx_BG.c", 23; #incchr(tileset_LV1_DOOR_OPEN,"res/maps/tiles_LV1_DOOR_OPEN.png", 4 , 6);
 1983               6340     		.data
 1984    03:6340             	_tileset_LV1_DOOR_OPEN: 	.incchr		"res/maps/tiles_LV1_DOOR_OPEN.png", 4, 6
 1985               E309     		.code
 1986                        		.dbg	line,	"include\gfx_BG.c", 24; #incchr(tileset_LV1_DOOR_CLOSED,"res/maps/tiles_LV1_DOOR_CLOSED.png", 4 , 6);
 1987               6640     		.data
 1988    03:6640             	_tileset_LV1_DOOR_CLOSED: 	.incchr		"res/maps/tiles_LV1_DOOR_CLOSED.png", 4, 6
 1989               E309     		.code
 1990                        		.dbg	line,	"include\gfx_BG.c", 26; #incchr(tileset_LIFE_RED,"res/maps/tileset_LIFE_RED.png", 2 , 1);
 1991               6940     		.data
 1992    03:6940             	_tileset_LIFE_RED: 	.incchr		"res/maps/tileset_LIFE_RED.png", 2, 1
 1993               E309     		.code
 1994                        		.dbg	line,	"include\gfx_BG.c", 27; #incchr(tileset_LIFE_ORANGE,"res/maps/tileset_LIFE_ORANGE.png", 2 , 1);
 1995               6980     		.data
 1996    03:6980             	_tileset_LIFE_ORANGE: 	.incchr		"res/maps/tileset_LIFE_ORANGE.png", 2, 1
 1997               E309     		.code
 1998                        		.dbg	line,	"include\gfx_BG.c", 28; #incchr(tileset_LIFE_YELLOW,"res/maps/tileset_LIFE_YELLOW.png", 2 , 1);
 1999               69C0     		.data
 2000    03:69C0             	_tileset_LIFE_YELLOW: 	.incchr		"res/maps/tileset_LIFE_YELLOW.png", 2, 1
 2001               E309     		.code
 2002                        		.dbg	line,	"include\gfx_BG.c", 29; #incchr(tileset_LIFE_EMPTY,"res/maps/tileset_LIFE_EMPTY.png", 2 , 1);
 2003               6A00     		.data
 2004    03:6A00             	_tileset_LIFE_EMPTY: 	.incchr		"res/maps/tileset_LIFE_EMPTY.png", 2, 1
 2005               E309     		.code
 2006                        		.dbg	line,	"include\gfx_BG.c", 31; #incchr(tileset_ARMOR_1,"res/maps/tileset_ARMOR_1.png", 2 , 2);
 2007               6A40     		.data
 2008    03:6A40             	_tileset_ARMOR_1: 	.incchr		"res/maps/tileset_ARMOR_1.png", 2, 2
 2009               E309     		.code
 2010                        		.dbg	line,	"include\gfx_BG.c", 32; #incchr(tileset_ARMOR_2,"res/maps/tileset_ARMOR_2.png", 2 , 2);
 2011               6AC0     		.data
 2012    03:6AC0             	_tileset_ARMOR_2: 	.incchr		"res/maps/tileset_ARMOR_2.png", 2, 2
 2013               E309     		.code
 2014                        		.dbg	line,	"include\gfx_BG.c", 33; #incchr(tileset_ARMOR_4,"res/maps/tileset_ARMOR_4.png", 2 , 2);
 2015               6B40     		.data
 2016    03:6B40             	_tileset_ARMOR_4: 	.incchr		"res/maps/tileset_ARMOR_4.png", 2, 2
 2017               E309     		.code
 2018                        		.dbg	line,	"include\gfx_BG.c", 34; #incchr(tileset_ARMOR_8,"res/maps/tileset_ARMOR_8.png", 2 , 2);
 2019               6BC0     		.data
 2020    03:6BC0             	_tileset_ARMOR_8: 	.incchr		"res/maps/tileset_ARMOR_8.png", 2, 2
 2021               E309     		.code
 2022                        		.dbg	line,	"include\gfx_BG.c", 36; #incchr(tileset_WEAPON_1,"res/maps/tileset_WEAPON_1.png", 2 , 2);
 2023               6C40     		.data
 2024    03:6C40             	_tileset_WEAPON_1: 	.incchr		"res/maps/tileset_WEAPON_1.png", 2, 2
 2025               E309     		.code
 2026                        		.dbg	line,	"include\gfx_BG.c", 37; #incchr(tileset_WEAPON_2,"res/maps/tileset_WEAPON_2.png", 2 , 2);
 2027               6CC0     		.data
 2028    03:6CC0             	_tileset_WEAPON_2: 	.incchr		"res/maps/tileset_WEAPON_2.png", 2, 2
 2029               E309     		.code
 2030                        		.dbg	line,	"include\gfx_BG.c", 38; #incchr(tileset_WEAPON_4,"res/maps/tileset_WEAPON_4.png", 2 , 2);
 2031               6D40     		.data
 2032    03:6D40             	_tileset_WEAPON_4: 	.incchr		"res/maps/tileset_WEAPON_4.png", 2, 2
 2033               E309     		.code
 2034                        		.dbg	line,	"include\gfx_BG.c", 39; #incchr(tileset_WEAPON_5,"res/maps/tileset_WEAPON_5.png", 2 , 2);
 2035               6DC0     		.data
 2036    03:6DC0             	_tileset_WEAPON_5: 	.incchr		"res/maps/tileset_WEAPON_5.png", 2, 2
 2037               E309     		.code
 2038                        		.dbg	line,	"include\gfx_BG.c", 40; #incchr(tileset_WEAPON_8,"res/maps/tileset_WEAPON_8.png", 2 , 2);
 2039               6E40     		.data
 2040    03:6E40             	_tileset_WEAPON_8: 	.incchr		"res/maps/tileset_WEAPON_8.png", 2, 2
 2041               E309     		.code
 2042                        		.dbg	line,	"include\gfx_BG.c", 43; //--------------------------------------------------------------------------------------//
 2043                        		.dbg	line,	"include\gfx_BG.c", 44; //                                        VDC 2                                         //
 2044                        		.dbg	line,	"include\gfx_BG.c", 45; //--------------------------------------------------------------------------------------//
 2045                        		.dbg	line,	"include\gfx_BG.c", 47; #asm
 2046                        		.dbg	clear
 2047               0001     	OPTIMIZE	=	1
 2048               6EC0     			.data
 2049                        	; EXTRACT TILESET
 2050                        	;----------------
 2051    03:6EC0             	_tileset_LV1_BG_B:  incchr	"res/maps/template_LV1_WALL.png"
 2052    03:70C0             			incchr	"res/maps/template_LV1_DOOR.png"
 2053    03:73C0             			incchr	"res/maps/tilemap_LV1_BG_B.png", OPTIMIZE
 2054                        	; EXTRACT BLOCKS
 2055                        	;--------------
 2056    07:6800             	blocks_LV1_BG_B1:	incblk	"res/maps/tilemap_LV1_BG_B.png" , 0x1000 ,    0 ,   0 ,  64 , 32 , _tileset_LV1_BG_B ; // 96x16 = 1536 | 32x16 =  512
 2057    07:7000             	blocks_LV1_BG_B2:	incblk	"res/maps/tilemap_LV1_BG_B.png" , 0x1000 , 1024 ,   0 ,  96 , 32 , _tileset_LV1_BG_B ; // 64x16 = 1024 | 32x16 =  512
 2058    07:7800             	blocks_LV1_BG_B3:	incblk	"res/maps/tilemap_LV1_BG_B.png" , 0x1000 ,    0 , 512 ,  64 , 32 , _tileset_LV1_BG_B ; // 96x16 = 1536 | 16x16 =  256
 2059    08:6000             	blocks_LV1_BG_B4:	incblk	"res/maps/tilemap_LV1_BG_B.png" , 0x1000 , 1024 , 512 ,  96 , 32 , _tileset_LV1_BG_B ; // 64x16 = 1024 | 16x16 =  256
 2060                        	; EXTRACT MAPS
 2061                        	;------------
 2062               6800     			align	256
 2063    08:6800             	MAP_LV1_BG_B1:		incmap	"res/maps/tilemap_LV1_BG_B.png",    0 ,   0 ,  64 , 32 , blocks_LV1_BG_B1 ; // 96x16 = 1536 | 32x16 =  512
 2064               7000     			align	256
 2065    08:7000             	MAP_LV1_BG_B2:		incmap	"res/maps/tilemap_LV1_BG_B.png", 1024 ,   0 ,  96 , 32 , blocks_LV1_BG_B2 ; // 64x16 = 1024 | 32x16 =  512
 2066               7C00     			align	256
 2067    08:7C00             	MAP_LV1_BG_B3:		incmap	"res/maps/tilemap_LV1_BG_B.png",    0 , 512 ,  64 , 32 , blocks_LV1_BG_B3 ; // 96x16 = 1536 | 16x16 =  256
 2068               6400     			align	256
 2069    09:6400             	MAP_LV1_BG_B4:		incmap	"res/maps/tilemap_LV1_BG_B.png", 1024 , 512 ,  96 , 32 , blocks_LV1_BG_B4 ; // 64x16 = 1024 | 16x16 =  256
 2070                        	; MASK (EMPTY)
 2071                        	;----------------
 2072    09:7000  00 00 00 00	dummy_tbl:	ds	256
         09:7004  00 00 00 00 
         09:7008  00 00 00 00 
         09:700C  00 00 00 00 
         09:7010  00 00 00 00 
         09:7014  00 00 00 00 
         09:7018  00 00 00 00 
         09:701C  00 00 00 00 
         09:7020  00 00 00 00 
         09:7024  00 00 00 00 
         09:7028  00 00 00 00 
         09:702C  00 00 00 00 
         09:7030  00 00 00 00 
         09:7034  00 00 00 00 
         09:7038  00 00 00 00 
         09:703C  00 00 00 00 
         09:7040  00 00 00 00 
         09:7044  00 00 00 00 
         09:7048  00 00 00 00 
         09:704C  00 00 00 00 
         09:7050  00 00 00 00 
         09:7054  00 00 00 00 
         09:7058  00 00 00 00 
         09:705C  00 00 00 00 
         09:7060  00 00 00 00 
         09:7064  00 00 00 00 
         09:7068  00 00 00 00 
         09:706C  00 00 00 00 
         09:7070  00 00 00 00 
         09:7074  00 00 00 00 
         09:7078  00 00 00 00 
         09:707C  00 00 00 00 
         09:7080  00 00 00 00 
         09:7084  00 00 00 00 
         09:7088  00 00 00 00 
         09:708C  00 00 00 00 
         09:7090  00 00 00 00 
         09:7094  00 00 00 00 
         09:7098  00 00 00 00 
         09:709C  00 00 00 00 
         09:70A0  00 00 00 00 
         09:70A4  00 00 00 00 
         09:70A8  00 00 00 00 
         09:70AC  00 00 00 00 
         09:70B0  00 00 00 00 
         09:70B4  00 00 00 00 
         09:70B8  00 00 00 00 
         09:70BC  00 00 00 00 
         09:70C0  00 00 00 00 
         09:70C4  00 00 00 00 
         09:70C8  00 00 00 00 
         09:70CC  00 00 00 00 
         09:70D0  00 00 00 00 
         09:70D4  00 00 00 00 
         09:70D8  00 00 00 00 
         09:70DC  00 00 00 00 
         09:70E0  00 00 00 00 
         09:70E4  00 00 00 00 
         09:70E8  00 00 00 00 
         09:70EC  00 00 00 00 
         09:70F0  00 00 00 00 
         09:70F4  00 00 00 00 
         09:70F8  00 00 00 00 
         09:70FC  00 00 00 00 
 2073                        	; SWIZZLE MAPS
 2074                        	;-------------
 2075    09:7100             	swizzle	MAP_LV1_BG_B1,  32, 16 ;
 2076    09:7100             	swizzle	MAP_LV1_BG_B2,  32, 16 ;
 2077    09:7100             	swizzle	MAP_LV1_BG_B3,  32, 16 ;
 2078    09:7100             	swizzle	MAP_LV1_BG_B4,  32, 16 ;
 2079                        	; BUILD MULTIMAP
 2080                        	;---------------
 2081    09:7100             	_multimap_LV1_BG_B:
 2082                        			; 1st line of 5 screens (512x256)
 2083                        			SCREEN MAP_LV1_BG_B1 + 0x0000, blocks_LV1_BG_B1, dummy_tbl, 0
         09:7100  68 08      			db	(((MAP_LV1_BG_B1 + 0x0000) & $1FFF) | $6000) >> 8, bank(MAP_LV1_BG_B1 + 0x0000)
         09:7102  48 07      			db	(((blocks_LV1_BG_B1) & $1FFF) | $4000) >> 8, bank(blocks_LV1_BG_B1)
         09:7104  70 09      			db	(((dummy_tbl) & $1FFF) | $6000) >> 8, bank(dummy_tbl)
         09:7106  00 00      			dw	(0)
 2084                        			SCREEN MAP_LV1_BG_B1 + 0x0200, blocks_LV1_BG_B1, dummy_tbl, 0
         09:7108  6A 08      			db	(((MAP_LV1_BG_B1 + 0x0200) & $1FFF) | $6000) >> 8, bank(MAP_LV1_BG_B1 + 0x0200)
         09:710A  48 07      			db	(((blocks_LV1_BG_B1) & $1FFF) | $4000) >> 8, bank(blocks_LV1_BG_B1)
         09:710C  70 09      			db	(((dummy_tbl) & $1FFF) | $6000) >> 8, bank(dummy_tbl)
         09:710E  00 00      			dw	(0)
 2085                        			SCREEN MAP_LV1_BG_B2 + 0x0000, blocks_LV1_BG_B2, dummy_tbl, 0
         09:7110  70 08      			db	(((MAP_LV1_BG_B2 + 0x0000) & $1FFF) | $6000) >> 8, bank(MAP_LV1_BG_B2 + 0x0000)
         09:7112  50 07      			db	(((blocks_LV1_BG_B2) & $1FFF) | $4000) >> 8, bank(blocks_LV1_BG_B2)
         09:7114  70 09      			db	(((dummy_tbl) & $1FFF) | $6000) >> 8, bank(dummy_tbl)
         09:7116  00 00      			dw	(0)
 2086                        			SCREEN MAP_LV1_BG_B2 + 0x0200, blocks_LV1_BG_B2, dummy_tbl, 0
         09:7118  72 08      			db	(((MAP_LV1_BG_B2 + 0x0200) & $1FFF) | $6000) >> 8, bank(MAP_LV1_BG_B2 + 0x0200)
         09:711A  50 07      			db	(((blocks_LV1_BG_B2) & $1FFF) | $4000) >> 8, bank(blocks_LV1_BG_B2)
         09:711C  70 09      			db	(((dummy_tbl) & $1FFF) | $6000) >> 8, bank(dummy_tbl)
         09:711E  00 00      			dw	(0)
 2087                        			SCREEN MAP_LV1_BG_B2 + 0x0400, blocks_LV1_BG_B2, dummy_tbl, 0
         09:7120  74 08      			db	(((MAP_LV1_BG_B2 + 0x0400) & $1FFF) | $6000) >> 8, bank(MAP_LV1_BG_B2 + 0x0400)
         09:7122  50 07      			db	(((blocks_LV1_BG_B2) & $1FFF) | $4000) >> 8, bank(blocks_LV1_BG_B2)
         09:7124  70 09      			db	(((dummy_tbl) & $1FFF) | $6000) >> 8, bank(dummy_tbl)
         09:7126  00 00      			dw	(0)
 2088                        			; 2nd line of 5 screens (512x256)
 2089                        			SCREEN MAP_LV1_BG_B1 + 0x0400, blocks_LV1_BG_B1, dummy_tbl, 0
         09:7128  6C 08      			db	(((MAP_LV1_BG_B1 + 0x0400) & $1FFF) | $6000) >> 8, bank(MAP_LV1_BG_B1 + 0x0400)
         09:712A  48 07      			db	(((blocks_LV1_BG_B1) & $1FFF) | $4000) >> 8, bank(blocks_LV1_BG_B1)
         09:712C  70 09      			db	(((dummy_tbl) & $1FFF) | $6000) >> 8, bank(dummy_tbl)
         09:712E  00 00      			dw	(0)
 2090                        			SCREEN MAP_LV1_BG_B1 + 0x0600, blocks_LV1_BG_B1, dummy_tbl, 0
         09:7130  6E 08      			db	(((MAP_LV1_BG_B1 + 0x0600) & $1FFF) | $6000) >> 8, bank(MAP_LV1_BG_B1 + 0x0600)
         09:7132  48 07      			db	(((blocks_LV1_BG_B1) & $1FFF) | $4000) >> 8, bank(blocks_LV1_BG_B1)
         09:7134  70 09      			db	(((dummy_tbl) & $1FFF) | $6000) >> 8, bank(dummy_tbl)
         09:7136  00 00      			dw	(0)
 2091                        			SCREEN MAP_LV1_BG_B2 + 0x0600, blocks_LV1_BG_B2, dummy_tbl, 0
         09:7138  76 08      			db	(((MAP_LV1_BG_B2 + 0x0600) & $1FFF) | $6000) >> 8, bank(MAP_LV1_BG_B2 + 0x0600)
         09:713A  50 07      			db	(((blocks_LV1_BG_B2) & $1FFF) | $4000) >> 8, bank(blocks_LV1_BG_B2)
         09:713C  70 09      			db	(((dummy_tbl) & $1FFF) | $6000) >> 8, bank(dummy_tbl)
         09:713E  00 00      			dw	(0)
 2092                        			SCREEN MAP_LV1_BG_B2 + 0x0800, blocks_LV1_BG_B2, dummy_tbl, 0
         09:7140  78 08      			db	(((MAP_LV1_BG_B2 + 0x0800) & $1FFF) | $6000) >> 8, bank(MAP_LV1_BG_B2 + 0x0800)
         09:7142  50 07      			db	(((blocks_LV1_BG_B2) & $1FFF) | $4000) >> 8, bank(blocks_LV1_BG_B2)
         09:7144  70 09      			db	(((dummy_tbl) & $1FFF) | $6000) >> 8, bank(dummy_tbl)
         09:7146  00 00      			dw	(0)
 2093                        			SCREEN MAP_LV1_BG_B2 + 0x0A00, blocks_LV1_BG_B2, dummy_tbl, 0
         09:7148  7A 08      			db	(((MAP_LV1_BG_B2 + 0x0A00) & $1FFF) | $6000) >> 8, bank(MAP_LV1_BG_B2 + 0x0A00)
         09:714A  50 07      			db	(((blocks_LV1_BG_B2) & $1FFF) | $4000) >> 8, bank(blocks_LV1_BG_B2)
         09:714C  70 09      			db	(((dummy_tbl) & $1FFF) | $6000) >> 8, bank(dummy_tbl)
         09:714E  00 00      			dw	(0)
 2094                        			; 3rd line of 5 screens (512x256)
 2095                        			SCREEN MAP_LV1_BG_B3 + 0x0000, blocks_LV1_BG_B3, dummy_tbl, 0
         09:7150  7C 08      			db	(((MAP_LV1_BG_B3 + 0x0000) & $1FFF) | $6000) >> 8, bank(MAP_LV1_BG_B3 + 0x0000)
         09:7152  58 07      			db	(((blocks_LV1_BG_B3) & $1FFF) | $4000) >> 8, bank(blocks_LV1_BG_B3)
         09:7154  70 09      			db	(((dummy_tbl) & $1FFF) | $6000) >> 8, bank(dummy_tbl)
         09:7156  00 00      			dw	(0)
 2096                        			SCREEN MAP_LV1_BG_B3 + 0x0200, blocks_LV1_BG_B3, dummy_tbl, 0
         09:7158  7E 08      			db	(((MAP_LV1_BG_B3 + 0x0200) & $1FFF) | $6000) >> 8, bank(MAP_LV1_BG_B3 + 0x0200)
         09:715A  58 07      			db	(((blocks_LV1_BG_B3) & $1FFF) | $4000) >> 8, bank(blocks_LV1_BG_B3)
         09:715C  70 09      			db	(((dummy_tbl) & $1FFF) | $6000) >> 8, bank(dummy_tbl)
         09:715E  00 00      			dw	(0)
 2097                        			SCREEN MAP_LV1_BG_B4 + 0x0000, blocks_LV1_BG_B4, dummy_tbl, 0
         09:7160  64 09      			db	(((MAP_LV1_BG_B4 + 0x0000) & $1FFF) | $6000) >> 8, bank(MAP_LV1_BG_B4 + 0x0000)
         09:7162  40 08      			db	(((blocks_LV1_BG_B4) & $1FFF) | $4000) >> 8, bank(blocks_LV1_BG_B4)
         09:7164  70 09      			db	(((dummy_tbl) & $1FFF) | $6000) >> 8, bank(dummy_tbl)
         09:7166  00 00      			dw	(0)
 2098                        			SCREEN MAP_LV1_BG_B4 + 0x0200, blocks_LV1_BG_B4, dummy_tbl, 0
         09:7168  66 09      			db	(((MAP_LV1_BG_B4 + 0x0200) & $1FFF) | $6000) >> 8, bank(MAP_LV1_BG_B4 + 0x0200)
         09:716A  40 08      			db	(((blocks_LV1_BG_B4) & $1FFF) | $4000) >> 8, bank(blocks_LV1_BG_B4)
         09:716C  70 09      			db	(((dummy_tbl) & $1FFF) | $6000) >> 8, bank(dummy_tbl)
         09:716E  00 00      			dw	(0)
 2099                        			SCREEN MAP_LV1_BG_B4 + 0x0400, blocks_LV1_BG_B4, dummy_tbl, 0
         09:7170  68 09      			db	(((MAP_LV1_BG_B4 + 0x0400) & $1FFF) | $6000) >> 8, bank(MAP_LV1_BG_B4 + 0x0400)
         09:7172  40 08      			db	(((blocks_LV1_BG_B4) & $1FFF) | $4000) >> 8, bank(blocks_LV1_BG_B4)
         09:7174  70 09      			db	(((dummy_tbl) & $1FFF) | $6000) >> 8, bank(dummy_tbl)
         09:7176  00 00      			dw	(0)
 2100                        			; 4th line of 5 screens (512x256)
 2101                        			SCREEN MAP_LV1_BG_B3 + 0x0400, blocks_LV1_BG_B3, dummy_tbl, 0
         09:7178  60 09      			db	(((MAP_LV1_BG_B3 + 0x0400) & $1FFF) | $6000) >> 8, bank(MAP_LV1_BG_B3 + 0x0400)
         09:717A  58 07      			db	(((blocks_LV1_BG_B3) & $1FFF) | $4000) >> 8, bank(blocks_LV1_BG_B3)
         09:717C  70 09      			db	(((dummy_tbl) & $1FFF) | $6000) >> 8, bank(dummy_tbl)
         09:717E  00 00      			dw	(0)
 2102                        			SCREEN MAP_LV1_BG_B3 + 0x0600, blocks_LV1_BG_B3, dummy_tbl, 0
         09:7180  62 09      			db	(((MAP_LV1_BG_B3 + 0x0600) & $1FFF) | $6000) >> 8, bank(MAP_LV1_BG_B3 + 0x0600)
         09:7182  58 07      			db	(((blocks_LV1_BG_B3) & $1FFF) | $4000) >> 8, bank(blocks_LV1_BG_B3)
         09:7184  70 09      			db	(((dummy_tbl) & $1FFF) | $6000) >> 8, bank(dummy_tbl)
         09:7186  00 00      			dw	(0)
 2103                        			SCREEN MAP_LV1_BG_B4 + 0x0600, blocks_LV1_BG_B4, dummy_tbl, 0
         09:7188  6A 09      			db	(((MAP_LV1_BG_B4 + 0x0600) & $1FFF) | $6000) >> 8, bank(MAP_LV1_BG_B4 + 0x0600)
         09:718A  40 08      			db	(((blocks_LV1_BG_B4) & $1FFF) | $4000) >> 8, bank(blocks_LV1_BG_B4)
         09:718C  70 09      			db	(((dummy_tbl) & $1FFF) | $6000) >> 8, bank(dummy_tbl)
         09:718E  00 00      			dw	(0)
 2104                        			SCREEN MAP_LV1_BG_B4 + 0x0800, blocks_LV1_BG_B4, dummy_tbl, 0
         09:7190  6C 09      			db	(((MAP_LV1_BG_B4 + 0x0800) & $1FFF) | $6000) >> 8, bank(MAP_LV1_BG_B4 + 0x0800)
         09:7192  40 08      			db	(((blocks_LV1_BG_B4) & $1FFF) | $4000) >> 8, bank(blocks_LV1_BG_B4)
         09:7194  70 09      			db	(((dummy_tbl) & $1FFF) | $6000) >> 8, bank(dummy_tbl)
         09:7196  00 00      			dw	(0)
 2105                        			SCREEN MAP_LV1_BG_B4 + 0x0A00, blocks_LV1_BG_B4, dummy_tbl, 0
         09:7198  6E 09      			db	(((MAP_LV1_BG_B4 + 0x0A00) & $1FFF) | $6000) >> 8, bank(MAP_LV1_BG_B4 + 0x0A00)
         09:719A  40 08      			db	(((blocks_LV1_BG_B4) & $1FFF) | $4000) >> 8, bank(blocks_LV1_BG_B4)
         09:719C  70 09      			db	(((dummy_tbl) & $1FFF) | $6000) >> 8, bank(dummy_tbl)
         09:719E  00 00      			dw	(0)
 2106                        	;//--------------------------------------------------------------------------------------//
 2107                        	;//                                        VDC 1                                         //
 2108                        	;//--------------------------------------------------------------------------------------//
 2109                        	; EXTRACT TILESET
 2110                        	;----------------
 2111    09:71A0             	_tileset_LV1_BG_A:	incchr	"res/maps/template_LIFEBAR_1.png"
 2112    09:71E0             			incchr	"res/maps/template_LIFEBAR_2.png"
 2113    09:7220             			incchr	"res/maps/template_LIFEBAR_3.png"
 2114    09:7260             			incchr	"res/maps/template_LIFEBAR_4.png"
 2115    09:72A0             			incchr	"res/maps/template_LIFEBAR_5.png"
 2116    09:72E0             			incchr	"res/maps/tileset_WEAPON_1.png"
 2117    09:7360             			incchr	"res/maps/tileset_ARMOR_1.png"
 2118    09:73E0             			incchr	"res/maps/tilemap_LV1_BG_A.png", OPTIMIZE
 2119                        	; EXTRACT BLOCKS
 2120                        	;--------------
 2121    0A:6000             	blocks_LV1_BG_A1:	incblk	"res/maps/tilemap_LV1_BG_A.png" , 0x1000 ,    0 ,   0 , 128 , 64 , _tileset_LV1_BG_A ; // 128x16 = 2048 | 64x16 = 1024
 2122    0A:6800             	blocks_LV1_BG_A2:	incblk	"res/maps/tilemap_LV1_BG_A.png" , 0x1000 , 2048 ,   0 ,  32 , 64 , _tileset_LV1_BG_A ; //  32x16 =  512 | 64x16 = 1024
 2123                        	; EXTRACT MAPS
 2124                        	;------------
 2125               7000     			align	256
 2126    0A:7000             	MAP_LV1_BG_A1:		incmap	"res/maps/tilemap_LV1_BG_A.png",    0 ,   0 , 128 , 64 , blocks_LV1_BG_A1 ; // 128x16 = 2048 | 64x16 = 1024
 2127    0B:7000             			flagmap "res/maps/collision_LV1.png",       0 ,   0 , 128 , 64 , MAP_LV1_BG_A1
 2128               7000     			align	256
 2129    0B:7000             	MAP_LV1_BG_A2:		incmap	"res/maps/tilemap_LV1_BG_A.png", 2048 ,   0 ,  32 , 64 , blocks_LV1_BG_A2 ; //  32x16 =  512 | 64x16 = 1024
 2130    0B:7800             			flagmap "res/maps/collision_LV1.png",    2048 ,   0 ,  32 , 64 , MAP_LV1_BG_A2
 2131                        	; SWIZZLE MAPS
 2132                        	;-------------
 2133    0B:7800             	swizzle	MAP_LV1_BG_A1,  32, 16 ;
 2134    0B:7800             	swizzle	MAP_LV1_BG_A2,  32, 16 ;
 2135                        	; BUILD MULTIMAP
 2136                        	;---------------
 2137    0B:7800             	_multimap_LV1_BG_A:
 2138                        			; 1st line of 5 screens (512x256)
 2139                        			SCREEN MAP_LV1_BG_A1 + 0x0000, blocks_LV1_BG_A1, dummy_tbl, 0
         0B:7800  70 0A      			db	(((MAP_LV1_BG_A1 + 0x0000) & $1FFF) | $6000) >> 8, bank(MAP_LV1_BG_A1 + 0x0000)
         0B:7802  40 0A      			db	(((blocks_LV1_BG_A1) & $1FFF) | $4000) >> 8, bank(blocks_LV1_BG_A1)
         0B:7804  70 09      			db	(((dummy_tbl) & $1FFF) | $6000) >> 8, bank(dummy_tbl)
         0B:7806  00 00      			dw	(0)
 2140                        			SCREEN MAP_LV1_BG_A1 + 0x0200, blocks_LV1_BG_A1, dummy_tbl, 0
         0B:7808  72 0A      			db	(((MAP_LV1_BG_A1 + 0x0200) & $1FFF) | $6000) >> 8, bank(MAP_LV1_BG_A1 + 0x0200)
         0B:780A  40 0A      			db	(((blocks_LV1_BG_A1) & $1FFF) | $4000) >> 8, bank(blocks_LV1_BG_A1)
         0B:780C  70 09      			db	(((dummy_tbl) & $1FFF) | $6000) >> 8, bank(dummy_tbl)
         0B:780E  00 00      			dw	(0)
 2141                        			SCREEN MAP_LV1_BG_A1 + 0x0400, blocks_LV1_BG_A1, dummy_tbl, 0
         0B:7810  74 0A      			db	(((MAP_LV1_BG_A1 + 0x0400) & $1FFF) | $6000) >> 8, bank(MAP_LV1_BG_A1 + 0x0400)
         0B:7812  40 0A      			db	(((blocks_LV1_BG_A1) & $1FFF) | $4000) >> 8, bank(blocks_LV1_BG_A1)
         0B:7814  70 09      			db	(((dummy_tbl) & $1FFF) | $6000) >> 8, bank(dummy_tbl)
         0B:7816  00 00      			dw	(0)
 2142                        			SCREEN MAP_LV1_BG_A1 + 0x0600, blocks_LV1_BG_A1, dummy_tbl, 0
         0B:7818  76 0A      			db	(((MAP_LV1_BG_A1 + 0x0600) & $1FFF) | $6000) >> 8, bank(MAP_LV1_BG_A1 + 0x0600)
         0B:781A  40 0A      			db	(((blocks_LV1_BG_A1) & $1FFF) | $4000) >> 8, bank(blocks_LV1_BG_A1)
         0B:781C  70 09      			db	(((dummy_tbl) & $1FFF) | $6000) >> 8, bank(dummy_tbl)
         0B:781E  00 00      			dw	(0)
 2143                        			SCREEN MAP_LV1_BG_A2 + 0x0000, blocks_LV1_BG_A2, dummy_tbl, 0
         0B:7820  70 0B      			db	(((MAP_LV1_BG_A2 + 0x0000) & $1FFF) | $6000) >> 8, bank(MAP_LV1_BG_A2 + 0x0000)
         0B:7822  48 0A      			db	(((blocks_LV1_BG_A2) & $1FFF) | $4000) >> 8, bank(blocks_LV1_BG_A2)
         0B:7824  70 09      			db	(((dummy_tbl) & $1FFF) | $6000) >> 8, bank(dummy_tbl)
         0B:7826  00 00      			dw	(0)
 2144                        			; 2nd line of 5 screens (512x256)
 2145                        			SCREEN MAP_LV1_BG_A1 + 0x0800, blocks_LV1_BG_A1, dummy_tbl, 0
         0B:7828  78 0A      			db	(((MAP_LV1_BG_A1 + 0x0800) & $1FFF) | $6000) >> 8, bank(MAP_LV1_BG_A1 + 0x0800)
         0B:782A  40 0A      			db	(((blocks_LV1_BG_A1) & $1FFF) | $4000) >> 8, bank(blocks_LV1_BG_A1)
         0B:782C  70 09      			db	(((dummy_tbl) & $1FFF) | $6000) >> 8, bank(dummy_tbl)
         0B:782E  00 00      			dw	(0)
 2146                        			SCREEN MAP_LV1_BG_A1 + 0x0A00, blocks_LV1_BG_A1, dummy_tbl, 0
         0B:7830  7A 0A      			db	(((MAP_LV1_BG_A1 + 0x0A00) & $1FFF) | $6000) >> 8, bank(MAP_LV1_BG_A1 + 0x0A00)
         0B:7832  40 0A      			db	(((blocks_LV1_BG_A1) & $1FFF) | $4000) >> 8, bank(blocks_LV1_BG_A1)
         0B:7834  70 09      			db	(((dummy_tbl) & $1FFF) | $6000) >> 8, bank(dummy_tbl)
         0B:7836  00 00      			dw	(0)
 2147                        			SCREEN MAP_LV1_BG_A1 + 0x0C00, blocks_LV1_BG_A1, dummy_tbl, 0
         0B:7838  7C 0A      			db	(((MAP_LV1_BG_A1 + 0x0C00) & $1FFF) | $6000) >> 8, bank(MAP_LV1_BG_A1 + 0x0C00)
         0B:783A  40 0A      			db	(((blocks_LV1_BG_A1) & $1FFF) | $4000) >> 8, bank(blocks_LV1_BG_A1)
         0B:783C  70 09      			db	(((dummy_tbl) & $1FFF) | $6000) >> 8, bank(dummy_tbl)
         0B:783E  00 00      			dw	(0)
 2148                        			SCREEN MAP_LV1_BG_A1 + 0x0E00, blocks_LV1_BG_A1, dummy_tbl, 0
         0B:7840  7E 0A      			db	(((MAP_LV1_BG_A1 + 0x0E00) & $1FFF) | $6000) >> 8, bank(MAP_LV1_BG_A1 + 0x0E00)
         0B:7842  40 0A      			db	(((blocks_LV1_BG_A1) & $1FFF) | $4000) >> 8, bank(blocks_LV1_BG_A1)
         0B:7844  70 09      			db	(((dummy_tbl) & $1FFF) | $6000) >> 8, bank(dummy_tbl)
         0B:7846  00 00      			dw	(0)
 2149                        			SCREEN MAP_LV1_BG_A2 + 0x0200, blocks_LV1_BG_A2, dummy_tbl, 0
         0B:7848  72 0B      			db	(((MAP_LV1_BG_A2 + 0x0200) & $1FFF) | $6000) >> 8, bank(MAP_LV1_BG_A2 + 0x0200)
         0B:784A  48 0A      			db	(((blocks_LV1_BG_A2) & $1FFF) | $4000) >> 8, bank(blocks_LV1_BG_A2)
         0B:784C  70 09      			db	(((dummy_tbl) & $1FFF) | $6000) >> 8, bank(dummy_tbl)
         0B:784E  00 00      			dw	(0)
 2150                        			; 3rd line of 5 screens (512x256)
 2151                        			SCREEN MAP_LV1_BG_A1 + 0x1000, blocks_LV1_BG_A1, dummy_tbl, 0
         0B:7850  60 0B      			db	(((MAP_LV1_BG_A1 + 0x1000) & $1FFF) | $6000) >> 8, bank(MAP_LV1_BG_A1 + 0x1000)
         0B:7852  40 0A      			db	(((blocks_LV1_BG_A1) & $1FFF) | $4000) >> 8, bank(blocks_LV1_BG_A1)
         0B:7854  70 09      			db	(((dummy_tbl) & $1FFF) | $6000) >> 8, bank(dummy_tbl)
         0B:7856  00 00      			dw	(0)
 2152                        			SCREEN MAP_LV1_BG_A1 + 0x1200, blocks_LV1_BG_A1, dummy_tbl, 0
         0B:7858  62 0B      			db	(((MAP_LV1_BG_A1 + 0x1200) & $1FFF) | $6000) >> 8, bank(MAP_LV1_BG_A1 + 0x1200)
         0B:785A  40 0A      			db	(((blocks_LV1_BG_A1) & $1FFF) | $4000) >> 8, bank(blocks_LV1_BG_A1)
         0B:785C  70 09      			db	(((dummy_tbl) & $1FFF) | $6000) >> 8, bank(dummy_tbl)
         0B:785E  00 00      			dw	(0)
 2153                        			SCREEN MAP_LV1_BG_A1 + 0x1400, blocks_LV1_BG_A1, dummy_tbl, 0
         0B:7860  64 0B      			db	(((MAP_LV1_BG_A1 + 0x1400) & $1FFF) | $6000) >> 8, bank(MAP_LV1_BG_A1 + 0x1400)
         0B:7862  40 0A      			db	(((blocks_LV1_BG_A1) & $1FFF) | $4000) >> 8, bank(blocks_LV1_BG_A1)
         0B:7864  70 09      			db	(((dummy_tbl) & $1FFF) | $6000) >> 8, bank(dummy_tbl)
         0B:7866  00 00      			dw	(0)
 2154                        			SCREEN MAP_LV1_BG_A1 + 0x1600, blocks_LV1_BG_A1, dummy_tbl, 0
         0B:7868  66 0B      			db	(((MAP_LV1_BG_A1 + 0x1600) & $1FFF) | $6000) >> 8, bank(MAP_LV1_BG_A1 + 0x1600)
         0B:786A  40 0A      			db	(((blocks_LV1_BG_A1) & $1FFF) | $4000) >> 8, bank(blocks_LV1_BG_A1)
         0B:786C  70 09      			db	(((dummy_tbl) & $1FFF) | $6000) >> 8, bank(dummy_tbl)
         0B:786E  00 00      			dw	(0)
 2155                        			SCREEN MAP_LV1_BG_A2 + 0x0400, blocks_LV1_BG_A2, dummy_tbl, 0
         0B:7870  74 0B      			db	(((MAP_LV1_BG_A2 + 0x0400) & $1FFF) | $6000) >> 8, bank(MAP_LV1_BG_A2 + 0x0400)
         0B:7872  48 0A      			db	(((blocks_LV1_BG_A2) & $1FFF) | $4000) >> 8, bank(blocks_LV1_BG_A2)
         0B:7874  70 09      			db	(((dummy_tbl) & $1FFF) | $6000) >> 8, bank(dummy_tbl)
         0B:7876  00 00      			dw	(0)
 2156                        			; 4th line of 5 screens (512x256)
 2157                        			SCREEN MAP_LV1_BG_A1 + 0x1800, blocks_LV1_BG_A1, dummy_tbl, 0
         0B:7878  68 0B      			db	(((MAP_LV1_BG_A1 + 0x1800) & $1FFF) | $6000) >> 8, bank(MAP_LV1_BG_A1 + 0x1800)
         0B:787A  40 0A      			db	(((blocks_LV1_BG_A1) & $1FFF) | $4000) >> 8, bank(blocks_LV1_BG_A1)
         0B:787C  70 09      			db	(((dummy_tbl) & $1FFF) | $6000) >> 8, bank(dummy_tbl)
         0B:787E  00 00      			dw	(0)
 2158                        			SCREEN MAP_LV1_BG_A1 + 0x1A00, blocks_LV1_BG_A1, dummy_tbl, 0
         0B:7880  6A 0B      			db	(((MAP_LV1_BG_A1 + 0x1A00) & $1FFF) | $6000) >> 8, bank(MAP_LV1_BG_A1 + 0x1A00)
         0B:7882  40 0A      			db	(((blocks_LV1_BG_A1) & $1FFF) | $4000) >> 8, bank(blocks_LV1_BG_A1)
         0B:7884  70 09      			db	(((dummy_tbl) & $1FFF) | $6000) >> 8, bank(dummy_tbl)
         0B:7886  00 00      			dw	(0)
 2159                        			SCREEN MAP_LV1_BG_A1 + 0x1C00, blocks_LV1_BG_A1, dummy_tbl, 0
         0B:7888  6C 0B      			db	(((MAP_LV1_BG_A1 + 0x1C00) & $1FFF) | $6000) >> 8, bank(MAP_LV1_BG_A1 + 0x1C00)
         0B:788A  40 0A      			db	(((blocks_LV1_BG_A1) & $1FFF) | $4000) >> 8, bank(blocks_LV1_BG_A1)
         0B:788C  70 09      			db	(((dummy_tbl) & $1FFF) | $6000) >> 8, bank(dummy_tbl)
         0B:788E  00 00      			dw	(0)
 2160                        			SCREEN MAP_LV1_BG_A1 + 0x1E00, blocks_LV1_BG_A1, dummy_tbl, 0
         0B:7890  6E 0B      			db	(((MAP_LV1_BG_A1 + 0x1E00) & $1FFF) | $6000) >> 8, bank(MAP_LV1_BG_A1 + 0x1E00)
         0B:7892  40 0A      			db	(((blocks_LV1_BG_A1) & $1FFF) | $4000) >> 8, bank(blocks_LV1_BG_A1)
         0B:7894  70 09      			db	(((dummy_tbl) & $1FFF) | $6000) >> 8, bank(dummy_tbl)
         0B:7896  00 00      			dw	(0)
 2161                        			SCREEN MAP_LV1_BG_A2 + 0x0600, blocks_LV1_BG_A2, dummy_tbl, 0
         0B:7898  76 0B      			db	(((MAP_LV1_BG_A2 + 0x0600) & $1FFF) | $6000) >> 8, bank(MAP_LV1_BG_A2 + 0x0600)
         0B:789A  48 0A      			db	(((blocks_LV1_BG_A2) & $1FFF) | $4000) >> 8, bank(blocks_LV1_BG_A2)
         0B:789C  70 09      			db	(((dummy_tbl) & $1FFF) | $6000) >> 8, bank(dummy_tbl)
         0B:789E  00 00      			dw	(0)
 2162               E309     			.code
 2163                        	
 2164                        		.dbg	line,	"include\gfx_BG.c", 207; #endasm
 2165                        		.dbg	line,	"include\gfx_BG.c", 211; //--------------------------------------------------------------------------------------//
 2166                        		.dbg	line,	"include\gfx_BG.c", 212; //                                   EXTRACT PALETTES                                   //
 2167                        		.dbg	line,	"include\gfx_BG.c", 213; //--------------------------------------------------------------------------------------//
 2168                        		.dbg	line,	"include\gfx_BG.c", 215; // EXTRACT PALETTE //
 2169                        		.dbg	line,	"include\gfx_BG.c", 216; #incpal(palette_LV1,"res/maps/tilemap_LV1_BG_B.png");
 2170               78A0     		.data
 2171    0B:78A0             	_palette_LV1:	.incpal		"res/maps/tilemap_LV1_BG_B.png"
 2172               E309     		.code
 2173                        		.dbg	line,	"main.c", 16; #include "include/gfx_SPRITES.c"
 2174                        		.dbg	line,	"include\gfx_SPRITES.c", 1; #include "huc.h"
 2175                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 1; #ifndef _hucc_legacy_h
 2176                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 2; #define _hucc_legacy_h
 2177                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 4; /****************************************************************************
 2178                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 5; ; ***************************************************************************
 2179                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 6; ;
 2180                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 7; ; huc.h
 2181                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 8; ;
 2182                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 9; ; HuCC wrapper file to include a default set of HuC-compatible functions.
 2183                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 10; ;
 2184                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 11; ; Copyright John Brandwood 2024.
 2185                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 12; ;
 2186                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 13; ; Distributed under the Boost Software License, Version 1.0.
 2187                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 14; ; (See accompanying file LICENSE_1_0.txt or copy at
 2188                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 15; ;  http://www.boost.org/LICENSE_1_0.txt)
 2189                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 16; ;
 2190                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 17; ; ***************************************************************************
 2191                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 18; ; ***************************************************************************
 2192                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 19; ;
 2193                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 20; ; When the HuCC compiler is invoked with the "--legacy" option to compile old
 2194                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 21; ; projects, then this "huc.h" file is automatically included.
 2195                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 22; ;
 2196                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 23; ; This file includes a set of the individual HuCC headers which correspond to
 2197                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 24; ; HuC's built-in functions and MagicKit library.
 2198                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 25; ;
 2199                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 26; ; New HuCC projects should, preferably, include the specific headers that are
 2200                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 27; ; needed, which will then allow them to replace parts of the standard library
 2201                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 28; ; with newer functions, or they can just manually include this "huc.h" file.
 2202                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 29; ;
 2203                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 30; ; ***************************************************************************
 2204                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 31; ; **************************************************************************/
 2205                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 33; #include "hucc-systemcard.h"
 2206                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 34; #include "hucc-baselib.h"
 2207                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 35; #include "hucc-gfx.h"
 2208                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 36; #include "hucc-string.h"
 2209                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 37; #include "hucc-old-scroll.h"
 2210                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 38; #include "hucc-old-spr.h"
 2211                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 39; #include "hucc-old-map.h"
 2212                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 40; #include "hucc-old-line.h"
 2213                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 42; #endif // _hucc_legacy_h
 2214                        		.dbg	line,	"include\gfx_SPRITES.c", 10; // EXTRACT PLAYER TILES //
 2215                        		.dbg	line,	"include\gfx_SPRITES.c", 11; #incspr(tiles_SPR_PLAYER,"res/sprites/tiles_SPR_PLAYER.png")
 2216               7AA0     		.data
 2217    0B:7AA0             	_tiles_SPR_PLAYER:	.incspr		"res/sprites/tiles_SPR_PLAYER.png"
 2218               E309     		.code
 2219                        		.dbg	line,	"include\gfx_SPRITES.c", 13; // EXTRACT PLAYER PALETTE //
 2220                        		.dbg	line,	"include\gfx_SPRITES.c", 14; #incpal(palette_PLAYER,"res/palettes/palette_PLAYER.png");
 2221               7AA0     		.data
 2222    0C:7AA0             	_palette_PLAYER:	.incpal		"res/palettes/palette_PLAYER.png"
 2223               E309     		.code
 2224                        		.dbg	line,	"include\gfx_SPRITES.c", 17; #incspr(tiles_SPR_HIT,"res/sprites/tiles_SPR_HIT.png")
 2225               7CA0     		.data
 2226    0C:7CA0             	_tiles_SPR_HIT:	.incspr		"res/sprites/tiles_SPR_HIT.png"
 2227               E309     		.code
 2228                        		.dbg	line,	"include\gfx_SPRITES.c", 20; // EXTRACT OBJECTS TILES //
 2229                        		.dbg	line,	"include\gfx_SPRITES.c", 21; #incspr(tiles_SPR_BARREL,"res/sprites/tiles_SPR_BARREL.png")
 2230               7D20     		.data
 2231    0C:7D20             	_tiles_SPR_BARREL:	.incspr		"res/sprites/tiles_SPR_BARREL.png"
 2232               E309     		.code
 2233                        		.dbg	line,	"include\gfx_SPRITES.c", 22; #incspr(tiles_SPR_CHEST,"res/sprites/tiles_SPR_CHEST.png")
 2234               7DA0     		.data
 2235    0C:7DA0             	_tiles_SPR_CHEST:	.incspr		"res/sprites/tiles_SPR_CHEST.png"
 2236               E309     		.code
 2237                        		.dbg	line,	"include\gfx_SPRITES.c", 23; #incspr(tiles_SPR_COIN_1,"res/sprites/tiles_SPR_COIN_1.png")
 2238               69A0     		.data
 2239    0D:69A0             	_tiles_SPR_COIN_1:	.incspr		"res/sprites/tiles_SPR_COIN_1.png"
 2240               E309     		.code
 2241                        		.dbg	line,	"include\gfx_SPRITES.c", 24; #incspr(tiles_SPR_COIN_5,"res/sprites/tiles_SPR_COIN_5.png")
 2242               6A20     		.data
 2243    0D:6A20             	_tiles_SPR_COIN_5:	.incspr		"res/sprites/tiles_SPR_COIN_5.png"
 2244               E309     		.code
 2245                        		.dbg	line,	"include\gfx_SPRITES.c", 25; #incspr(tiles_SPR_COIN_10,"res/sprites/tiles_SPR_COIN_10.png")
 2246               6AA0     		.data
 2247    0D:6AA0             	_tiles_SPR_COIN_10:	.incspr		"res/sprites/tiles_SPR_COIN_10.png"
 2248               E309     		.code
 2249                        		.dbg	line,	"include\gfx_SPRITES.c", 26; #incspr(tiles_SPR_COIN_50,"res/sprites/tiles_SPR_COIN_50.png")
 2250               6B20     		.data
 2251    0D:6B20             	_tiles_SPR_COIN_50:	.incspr		"res/sprites/tiles_SPR_COIN_50.png"
 2252               E309     		.code
 2253                        		.dbg	line,	"include\gfx_SPRITES.c", 27; #incspr(tiles_SPR_COIN_100,"res/sprites/tiles_SPR_COIN_100.png")
 2254               6BA0     		.data
 2255    0D:6BA0             	_tiles_SPR_COIN_100:	.incspr		"res/sprites/tiles_SPR_COIN_100.png"
 2256               E309     		.code
 2257                        		.dbg	line,	"include\gfx_SPRITES.c", 28; #incspr(tiles_SPR_COIN_500,"res/sprites/tiles_SPR_COIN_500.png")
 2258               6C20     		.data
 2259    0D:6C20             	_tiles_SPR_COIN_500:	.incspr		"res/sprites/tiles_SPR_COIN_500.png"
 2260               E309     		.code
 2261                        		.dbg	line,	"include\gfx_SPRITES.c", 29; #incspr(tiles_SPR_COIN_1000,"res/sprites/tiles_SPR_COIN_1000.png")
 2262               6CA0     		.data
 2263    0D:6CA0             	_tiles_SPR_COIN_1000:	.incspr		"res/sprites/tiles_SPR_COIN_1000.png"
 2264               E309     		.code
 2265                        		.dbg	line,	"include\gfx_SPRITES.c", 30; #incspr(tiles_SPR_FRUIT,"res/sprites/tiles_SPR_FRUIT.png")
 2266               6D20     		.data
 2267    0D:6D20             	_tiles_SPR_FRUIT:	.incspr		"res/sprites/tiles_SPR_FRUIT.png"
 2268               E309     		.code
 2269                        		.dbg	line,	"include\gfx_SPRITES.c", 31; #incspr(tiles_SPR_GRAY_KEY,"res/sprites/tiles_SPR_GRAY_KEY.png")
 2270               6DA0     		.data
 2271    0D:6DA0             	_tiles_SPR_GRAY_KEY:	.incspr		"res/sprites/tiles_SPR_GRAY_KEY.png"
 2272               E309     		.code
 2273                        		.dbg	line,	"include\gfx_SPRITES.c", 32; #incspr(tiles_SPR_GOLD_KEY,"res/sprites/tiles_SPR_GOLD_KEY.png")
 2274               6E20     		.data
 2275    0D:6E20             	_tiles_SPR_GOLD_KEY:	.incspr		"res/sprites/tiles_SPR_GOLD_KEY.png"
 2276               E309     		.code
 2277                        		.dbg	line,	"include\gfx_SPRITES.c", 33; #incspr(tiles_SPR_HOURGLASS,"res/sprites/tiles_SPR_HOURGLASS.png")
 2278               6EA0     		.data
 2279    0D:6EA0             	_tiles_SPR_HOURGLASS:	.incspr		"res/sprites/tiles_SPR_HOURGLASS.png"
 2280               E309     		.code
 2281                        		.dbg	line,	"include\gfx_SPRITES.c", 34; #incspr(tiles_SPR_LIFE,"res/sprites/tiles_SPR_LIFE.png")
 2282               6F20     		.data
 2283    0D:6F20             	_tiles_SPR_LIFE:	.incspr		"res/sprites/tiles_SPR_LIFE.png"
 2284               E309     		.code
 2285                        		.dbg	line,	"include\gfx_SPRITES.c", 35; #incspr(tiles_SPR_OCTOPUS,"res/sprites/tiles_SPR_OCTOPUS.png")
 2286               6FA0     		.data
 2287    0D:6FA0             	_tiles_SPR_OCTOPUS:	.incspr		"res/sprites/tiles_SPR_OCTOPUS.png"
 2288               E309     		.code
 2289                        		.dbg	line,	"include\gfx_SPRITES.c", 36; #incspr(tiles_SPR_POT,"res/sprites/tiles_SPR_POT.png")
 2290               7020     		.data
 2291    0D:7020             	_tiles_SPR_POT:	.incspr		"res/sprites/tiles_SPR_POT.png"
 2292               E309     		.code
 2293                        		.dbg	line,	"include\gfx_SPRITES.c", 37; #incspr(tiles_SPR_POW,"res/sprites/tiles_SPR_POW.png")
 2294               7420     		.data
 2295    0D:7420             	_tiles_SPR_POW:	.incspr		"res/sprites/tiles_SPR_POW.png"
 2296               E309     		.code
 2297                        		.dbg	line,	"include\gfx_SPRITES.c", 38; #incspr(tiles_SPR_STAR,"res/sprites/tiles_SPR_STAR.png")
 2298               74A0     		.data
 2299    0D:74A0             	_tiles_SPR_STAR:	.incspr		"res/sprites/tiles_SPR_STAR.png"
 2300               E309     		.code
 2301                        		.dbg	line,	"include\gfx_SPRITES.c", 39; #incspr(tiles_SPR_BAMBOO,"res/sprites/tiles_SPR_BAMBOO.png")
 2302               7520     		.data
 2303    0D:7520             	_tiles_SPR_BAMBOO:	.incspr		"res/sprites/tiles_SPR_BAMBOO.png"
 2304               E309     		.code
 2305                        		.dbg	line,	"include\gfx_SPRITES.c", 40; #incspr(tiles_SPR_YASHICHI,"res/sprites/tiles_SPR_YASHICHI.png")
 2306               75A0     		.data
 2307    0D:75A0             	_tiles_SPR_YASHICHI:	.incspr		"res/sprites/tiles_SPR_YASHICHI.png"
 2308               E309     		.code
 2309                        		.dbg	line,	"include\gfx_SPRITES.c", 41; #incspr(tiles_SPR_ELEPHANT,"res/sprites/tiles_SPR_ELEPHANT.png")
 2310               7620     		.data
 2311    0D:7620             	_tiles_SPR_ELEPHANT:	.incspr		"res/sprites/tiles_SPR_ELEPHANT.png"
 2312               E309     		.code
 2313                        		.dbg	line,	"include\gfx_SPRITES.c", 42; #incspr(tiles_SPR_DRAGONFLY,"res/sprites/tiles_SPR_DRAGONFLY.png")
 2314               76A0     		.data
 2315    0D:76A0             	_tiles_SPR_DRAGONFLY:	.incspr		"res/sprites/tiles_SPR_DRAGONFLY.png"
 2316               E309     		.code
 2317                        		.dbg	line,	"include\gfx_SPRITES.c", 43; #incspr(tiles_SPR_COW,"res/sprites/tiles_SPR_COW.png")
 2318               7720     		.data
 2319    0D:7720             	_tiles_SPR_COW:	.incspr		"res/sprites/tiles_SPR_COW.png"
 2320               E309     		.code
 2321                        		.dbg	line,	"include\gfx_SPRITES.c", 44; #incspr(tiles_SPR_MOBICHAN,"res/sprites/tiles_SPR_MOBICHAN.png")
 2322               77A0     		.data
 2323    0D:77A0             	_tiles_SPR_MOBICHAN:	.incspr		"res/sprites/tiles_SPR_MOBICHAN.png"
 2324               E309     		.code
 2325                        		.dbg	line,	"include\gfx_SPRITES.c", 46; // EXTRACT OBJECTS PALETTE //
 2326                        		.dbg	line,	"include\gfx_SPRITES.c", 47; #incpal(palette_objects_1,"res/palettes/palette_objects_1.png");
 2327               7820     		.data
 2328    0D:7820             	_palette_objects_1:	.incpal		"res/palettes/palette_objects_1.png"
 2329               E309     		.code
 2330                        		.dbg	line,	"include\gfx_SPRITES.c", 48; #incpal(palette_objects_2,"res/palettes/palette_objects_2.png");
 2331               7A20     		.data
 2332    0D:7A20             	_palette_objects_2:	.incpal		"res/palettes/palette_objects_2.png"
 2333               E309     		.code
 2334                        		.dbg	line,	"include\gfx_SPRITES.c", 51; // EXTRACT NPCS TILES //
 2335                        		.dbg	line,	"include\gfx_SPRITES.c", 52; #incspr(tiles_SPR_NPC,"res/sprites/tiles_SPR_NPC.png")
 2336               7C20     		.data
 2337    0D:7C20             	_tiles_SPR_NPC:	.incspr		"res/sprites/tiles_SPR_NPC.png"
 2338               E309     		.code
 2339                        		.dbg	line,	"main.c", 20; #include "include/tables_NPC.c"
 2340                        		.dbg	line,	"include\tables_NPC.c", 1; //-----------------------------------------------------------------------------//
 2341                        		.dbg	line,	"include\tables_NPC.c", 2; //                                                                             //
 2342                        		.dbg	line,	"include\tables_NPC.c", 3; //                                   LEVEL 1                                   //
 2343                        		.dbg	line,	"include\tables_NPC.c", 4; //                                                                             //
 2344                        		.dbg	line,	"include\tables_NPC.c", 5; //-----------------------------------------------------------------------------//
 2345                        		.dbg	line,	"include\tables_NPC.c", 7; /*const char              TABLE_OBJECT_TYPE_LV1[NPC_NUMBER_LV1]      =   {
 2346                        		.dbg	line,	"include\tables_NPC.c", 8; TYPE_HOURGLASS,
 2347                        		.dbg	line,	"include\tables_NPC.c", 9; TYPE_POT,
 2348                        		.dbg	line,	"include\tables_NPC.c", 10; TYPE_POT,
 2349                        		.dbg	line,	"include\tables_NPC.c", 11; TYPE_POT,
 2350                        		.dbg	line,	"include\tables_NPC.c", 12; TYPE_POT,
 2351                        		.dbg	line,	"include\tables_NPC.c", 13; TYPE_POT,
 2352                        		.dbg	line,	"include\tables_NPC.c", 14; TYPE_POT,
 2353                        		.dbg	line,	"include\tables_NPC.c", 15; TYPE_POW,
 2354                        		.dbg	line,	"include\tables_NPC.c", 16; TYPE_POT,
 2355                        		.dbg	line,	"include\tables_NPC.c", 17; TYPE_POT,
 2356                        		.dbg	line,	"include\tables_NPC.c", 19; //
 2357                        		.dbg	line,	"include\tables_NPC.c", 20; TYPE_POT,
 2358                        		.dbg	line,	"include\tables_NPC.c", 21; TYPE_POT,
 2359                        		.dbg	line,	"include\tables_NPC.c", 22; TYPE_POT,
 2360                        		.dbg	line,	"include\tables_NPC.c", 23; TYPE_POT,
 2361                        		.dbg	line,	"include\tables_NPC.c", 24; TYPE_POT,
 2362                        		.dbg	line,	"include\tables_NPC.c", 25; TYPE_POT,
 2363                        		.dbg	line,	"include\tables_NPC.c", 26; TYPE_POT,
 2364                        		.dbg	line,	"include\tables_NPC.c", 27; TYPE_POT,
 2365                        		.dbg	line,	"include\tables_NPC.c", 28; TYPE_POT,
 2366                        		.dbg	line,	"include\tables_NPC.c", 29; TYPE_POT,
 2367                        		.dbg	line,	"include\tables_NPC.c", 31; //
 2368                        		.dbg	line,	"include\tables_NPC.c", 32; TYPE_POT,
 2369                        		.dbg	line,	"include\tables_NPC.c", 33; TYPE_POT,
 2370                        		.dbg	line,	"include\tables_NPC.c", 34; TYPE_POT
 2371                        		.dbg	line,	"include\tables_NPC.c", 35; };*/
 2372                        		.dbg	line,	"include\tables_NPC.c", 38; const signed int        TABLE_NPC_X_POS_REF_LV1[NPC_NUMBER_LV1]         =   {
 2373                        		.dbg	line,	"include\tables_NPC.c", 39; 912,
 2374                        		.dbg	line,	"include\tables_NPC.c", 40; 1232
 2375                        		.dbg	line,	"include\tables_NPC.c", 41; };
 2376                        		.dbg	line,	"include\tables_NPC.c", 44; const signed int        TABLE_NPC_Y_POS_REF_LV1[NPC_NUMBER_LV1]         =   {
 2377                        		.dbg	line,	"include\tables_NPC.c", 45; 576,
 2378                        		.dbg	line,	"include\tables_NPC.c", 46; 400
 2379                        		.dbg	line,	"include\tables_NPC.c", 47; };
 2380                        		.dbg	line,	"main.c", 21; #include "include/tables_OBJECT.c"
 2381                        		.dbg	line,	"include\tables_OBJECT.c", 1; //-----------------------------------------------------------------------------//
 2382                        		.dbg	line,	"include\tables_OBJECT.c", 2; //                                                                             //
 2383                        		.dbg	line,	"include\tables_OBJECT.c", 3; //                                   LEVEL 1                                   //
 2384                        		.dbg	line,	"include\tables_OBJECT.c", 4; //                                                                             //
 2385                        		.dbg	line,	"include\tables_OBJECT.c", 5; //-----------------------------------------------------------------------------//
 2386                        		.dbg	line,	"include\tables_OBJECT.c", 7; const char              TABLE_OBJECT_TYPE_LV1[OBJECT_NUMBER_LV1]      =   {
 2387                        		.dbg	line,	"include\tables_OBJECT.c", 8; TYPE_HOURGLASS,
 2388                        		.dbg	line,	"include\tables_OBJECT.c", 9; TYPE_POT,
 2389                        		.dbg	line,	"include\tables_OBJECT.c", 10; TYPE_POT,
 2390                        		.dbg	line,	"include\tables_OBJECT.c", 11; TYPE_POT,
 2391                        		.dbg	line,	"include\tables_OBJECT.c", 12; TYPE_POT,
 2392                        		.dbg	line,	"include\tables_OBJECT.c", 13; TYPE_POT,
 2393                        		.dbg	line,	"include\tables_OBJECT.c", 14; TYPE_POT,
 2394                        		.dbg	line,	"include\tables_OBJECT.c", 15; TYPE_POW,
 2395                        		.dbg	line,	"include\tables_OBJECT.c", 16; TYPE_POT,
 2396                        		.dbg	line,	"include\tables_OBJECT.c", 17; TYPE_POT,
 2397                        		.dbg	line,	"include\tables_OBJECT.c", 19; //
 2398                        		.dbg	line,	"include\tables_OBJECT.c", 20; TYPE_POT,
 2399                        		.dbg	line,	"include\tables_OBJECT.c", 21; TYPE_POT,
 2400                        		.dbg	line,	"include\tables_OBJECT.c", 22; TYPE_POT,
 2401                        		.dbg	line,	"include\tables_OBJECT.c", 23; TYPE_POT,
 2402                        		.dbg	line,	"include\tables_OBJECT.c", 24; TYPE_POT,
 2403                        		.dbg	line,	"include\tables_OBJECT.c", 25; TYPE_POT,
 2404                        		.dbg	line,	"include\tables_OBJECT.c", 26; TYPE_POT,
 2405                        		.dbg	line,	"include\tables_OBJECT.c", 27; TYPE_POT,
 2406                        		.dbg	line,	"include\tables_OBJECT.c", 28; TYPE_POT,
 2407                        		.dbg	line,	"include\tables_OBJECT.c", 29; TYPE_POT,
 2408                        		.dbg	line,	"include\tables_OBJECT.c", 31; //
 2409                        		.dbg	line,	"include\tables_OBJECT.c", 32; TYPE_POT,
 2410                        		.dbg	line,	"include\tables_OBJECT.c", 33; TYPE_POT,
 2411                        		.dbg	line,	"include\tables_OBJECT.c", 34; TYPE_POT
 2412                        		.dbg	line,	"include\tables_OBJECT.c", 35; };
 2413                        		.dbg	line,	"include\tables_OBJECT.c", 38; const signed int        TABLE_OBJECT_X_POS_REF_LV1[OBJECT_NUMBER_LV1] =   {
 2414                        		.dbg	line,	"include\tables_OBJECT.c", 39; 1680,
 2415                        		.dbg	line,	"include\tables_OBJECT.c", 40; 1280,
 2416                        		.dbg	line,	"include\tables_OBJECT.c", 41; 1472,
 2417                        		.dbg	line,	"include\tables_OBJECT.c", 42; 1440,
 2418                        		.dbg	line,	"include\tables_OBJECT.c", 43; 1168,
 2419                        		.dbg	line,	"include\tables_OBJECT.c", 44; 1200,
 2420                        		.dbg	line,	"include\tables_OBJECT.c", 45; 960,
 2421                        		.dbg	line,	"include\tables_OBJECT.c", 46; 984,
 2422                        		.dbg	line,	"include\tables_OBJECT.c", 47; 1360,
 2423                        		.dbg	line,	"include\tables_OBJECT.c", 48; 1392,
 2424                        		.dbg	line,	"include\tables_OBJECT.c", 50; //
 2425                        		.dbg	line,	"include\tables_OBJECT.c", 51; 1552,
 2426                        		.dbg	line,	"include\tables_OBJECT.c", 52; 1680,
 2427                        		.dbg	line,	"include\tables_OBJECT.c", 53; 1712,
 2428                        		.dbg	line,	"include\tables_OBJECT.c", 54; 1744,
 2429                        		.dbg	line,	"include\tables_OBJECT.c", 55; 1248,
 2430                        		.dbg	line,	"include\tables_OBJECT.c", 56; 1280,
 2431                        		.dbg	line,	"include\tables_OBJECT.c", 57; 1168,
 2432                        		.dbg	line,	"include\tables_OBJECT.c", 58; 1040,
 2433                        		.dbg	line,	"include\tables_OBJECT.c", 59; 640,
 2434                        		.dbg	line,	"include\tables_OBJECT.c", 60; 672,
 2435                        		.dbg	line,	"include\tables_OBJECT.c", 62; //
 2436                        		.dbg	line,	"include\tables_OBJECT.c", 63; 336,
 2437                        		.dbg	line,	"include\tables_OBJECT.c", 64; 368,
 2438                        		.dbg	line,	"include\tables_OBJECT.c", 65; 416
 2439                        		.dbg	line,	"include\tables_OBJECT.c", 66; };
 2440                        		.dbg	line,	"include\tables_OBJECT.c", 69; const signed int        TABLE_OBJECT_Y_POS_REF_LV1[OBJECT_NUMBER_LV1] =   {
 2441                        		.dbg	line,	"include\tables_OBJECT.c", 70; 384,
 2442                        		.dbg	line,	"include\tables_OBJECT.c", 71; 416,
 2443                        		.dbg	line,	"include\tables_OBJECT.c", 72; 480,
 2444                        		.dbg	line,	"include\tables_OBJECT.c", 73; 496,
 2445                        		.dbg	line,	"include\tables_OBJECT.c", 74; 560,
 2446                        		.dbg	line,	"include\tables_OBJECT.c", 75; 560,
 2447                        		.dbg	line,	"include\tables_OBJECT.c", 76; 592,
 2448                        		.dbg	line,	"include\tables_OBJECT.c", 77; 592,
 2449                        		.dbg	line,	"include\tables_OBJECT.c", 78; 592,
 2450                        		.dbg	line,	"include\tables_OBJECT.c", 79; 592,
 2451                        		.dbg	line,	"include\tables_OBJECT.c", 81; //
 2452                        		.dbg	line,	"include\tables_OBJECT.c", 82; 704,
 2453                        		.dbg	line,	"include\tables_OBJECT.c", 83; 720,
 2454                        		.dbg	line,	"include\tables_OBJECT.c", 84; 720,
 2455                        		.dbg	line,	"include\tables_OBJECT.c", 85; 720,
 2456                        		.dbg	line,	"include\tables_OBJECT.c", 86; 736,
 2457                        		.dbg	line,	"include\tables_OBJECT.c", 87; 736,
 2458                        		.dbg	line,	"include\tables_OBJECT.c", 88; 752,
 2459                        		.dbg	line,	"include\tables_OBJECT.c", 89; 848,
 2460                        		.dbg	line,	"include\tables_OBJECT.c", 90; 880,
 2461                        		.dbg	line,	"include\tables_OBJECT.c", 91; 880,
 2462                        		.dbg	line,	"include\tables_OBJECT.c", 93; //
 2463                        		.dbg	line,	"include\tables_OBJECT.c", 94; 896,
 2464                        		.dbg	line,	"include\tables_OBJECT.c", 95; 896,
 2465                        		.dbg	line,	"include\tables_OBJECT.c", 96; 896
 2466                        		.dbg	line,	"include\tables_OBJECT.c", 97; };
 2467                        		.dbg	line,	"include\tables_OBJECT.c", 100; /*const char              TABLE_REWARD_TYPE_LV1[OBJECT_NUMBER_LV1]       =   {
 2468                        		.dbg	line,	"include\tables_OBJECT.c", 101; TYPE_POT
 2469                        		.dbg	line,	"include\tables_OBJECT.c", 102; TYPE_POT,
 2470                        		.dbg	line,	"include\tables_OBJECT.c", 103; TYPE_POT,
 2471                        		.dbg	line,	"include\tables_OBJECT.c", 104; TYPE_POT,
 2472                        		.dbg	line,	"include\tables_OBJECT.c", 105; TYPE_POT,
 2473                        		.dbg	line,	"include\tables_OBJECT.c", 106; TYPE_POT,
 2474                        		.dbg	line,	"include\tables_OBJECT.c", 107; TYPE_POT,
 2475                        		.dbg	line,	"include\tables_OBJECT.c", 108; TYPE_POW,
 2476                        		.dbg	line,	"include\tables_OBJECT.c", 109; TYPE_POT,
 2477                        		.dbg	line,	"include\tables_OBJECT.c", 110; TYPE_POT,
 2478                        		.dbg	line,	"include\tables_OBJECT.c", 112; //
 2479                        		.dbg	line,	"include\tables_OBJECT.c", 113; TYPE_POT,
 2480                        		.dbg	line,	"include\tables_OBJECT.c", 114; TYPE_POT,
 2481                        		.dbg	line,	"include\tables_OBJECT.c", 115; TYPE_POT,
 2482                        		.dbg	line,	"include\tables_OBJECT.c", 116; TYPE_POT,
 2483                        		.dbg	line,	"include\tables_OBJECT.c", 117; TYPE_POT,
 2484                        		.dbg	line,	"include\tables_OBJECT.c", 118; TYPE_POT,
 2485                        		.dbg	line,	"include\tables_OBJECT.c", 119; TYPE_POT,
 2486                        		.dbg	line,	"include\tables_OBJECT.c", 120; TYPE_POT,
 2487                        		.dbg	line,	"include\tables_OBJECT.c", 122; //
 2488                        		.dbg	line,	"include\tables_OBJECT.c", 123; TYPE_GRAY_KEY,
 2489                        		.dbg	line,	"include\tables_OBJECT.c", 124; TYPE_GRAY_KEY,
 2490                        		.dbg	line,	"include\tables_OBJECT.c", 125; TYPE_GRAY_KEY,
 2491                        		.dbg	line,	"include\tables_OBJECT.c", 126; TYPE_COIN_5,
 2492                        		.dbg	line,	"include\tables_OBJECT.c", 127; TYPE_GRAY_KEY
 2493                        		.dbg	line,	"include\tables_OBJECT.c", 128; };*/
 2494                        		.dbg	line,	"include\tables_OBJECT.c", 133; const signed int        TABLE_CHEST_X_POS_REF_LV1[CHEST_NUMBER_LV1]   =   {
 2495                        		.dbg	line,	"include\tables_OBJECT.c", 134; 1072,
 2496                        		.dbg	line,	"include\tables_OBJECT.c", 135; 816
 2497                        		.dbg	line,	"include\tables_OBJECT.c", 136; };
 2498                        		.dbg	line,	"include\tables_OBJECT.c", 139; const signed int        TABLE_CHEST_Y_POS_REF_LV1[CHEST_NUMBER_LV1]   =   {
 2499                        		.dbg	line,	"include\tables_OBJECT.c", 140; 832,
 2500                        		.dbg	line,	"include\tables_OBJECT.c", 141; 848
 2501                        		.dbg	line,	"main.c", 21; };
 2502                        		.dbg	line,	"main.c", 22; #include "include/tables_PLAYER.c"
 2503                        		.dbg	line,	"include\tables_PLAYER.c", 3; const signed char       TABLE_PLAYER_JUMP_V[35]     =   {
 2504                        		.dbg	line,	"include\tables_PLAYER.c", 4; // UPWARD
 2505                        		.dbg	line,	"include\tables_PLAYER.c", 5; -4,
 2506                        		.dbg	line,	"include\tables_PLAYER.c", 6; -5,
 2507                        		.dbg	line,	"include\tables_PLAYER.c", 7; -10,
 2508                        		.dbg	line,	"include\tables_PLAYER.c", 8; -4,
 2509                        		.dbg	line,	"include\tables_PLAYER.c", 9; -4,
 2510                        		.dbg	line,	"include\tables_PLAYER.c", 10; -7,
 2511                        		.dbg	line,	"include\tables_PLAYER.c", 11; -6,
 2512                        		.dbg	line,	"include\tables_PLAYER.c", 12; -3,
 2513                        		.dbg	line,	"include\tables_PLAYER.c", 13; -5,
 2514                        		.dbg	line,	"include\tables_PLAYER.c", 14; -2,
 2515                        		.dbg	line,	"include\tables_PLAYER.c", 15; -4,
 2516                        		.dbg	line,	"include\tables_PLAYER.c", 16; -1,
 2517                        		.dbg	line,	"include\tables_PLAYER.c", 17; -1,
 2518                        		.dbg	line,	"include\tables_PLAYER.c", 18; -1,
 2519                        		.dbg	line,	"include\tables_PLAYER.c", 19; -1,
 2520                        		.dbg	line,	"include\tables_PLAYER.c", 20; 0,
 2521                        		.dbg	line,	"include\tables_PLAYER.c", 21; 0,
 2522                        		.dbg	line,	"include\tables_PLAYER.c", 22; 0,
 2523                        		.dbg	line,	"include\tables_PLAYER.c", 23; 0,
 2524                        		.dbg	line,	"include\tables_PLAYER.c", 24; // DOWNWARD
 2525                        		.dbg	line,	"include\tables_PLAYER.c", 25; 1,
 2526                        		.dbg	line,	"include\tables_PLAYER.c", 26; 1,
 2527                        		.dbg	line,	"include\tables_PLAYER.c", 27; 1,
 2528                        		.dbg	line,	"include\tables_PLAYER.c", 28; 1,
 2529                        		.dbg	line,	"include\tables_PLAYER.c", 29; 4,
 2530                        		.dbg	line,	"include\tables_PLAYER.c", 30; 2,
 2531                        		.dbg	line,	"include\tables_PLAYER.c", 31; 5,
 2532                        		.dbg	line,	"include\tables_PLAYER.c", 32; 3,
 2533                        		.dbg	line,	"include\tables_PLAYER.c", 33; 6,
 2534                        		.dbg	line,	"include\tables_PLAYER.c", 34; 7,
 2535                        		.dbg	line,	"include\tables_PLAYER.c", 35; 4,
 2536                        		.dbg	line,	"include\tables_PLAYER.c", 36; 4,
 2537                        		.dbg	line,	"include\tables_PLAYER.c", 37; 10,
 2538                        		.dbg	line,	"include\tables_PLAYER.c", 38; 4,
 2539                        		.dbg	line,	"include\tables_PLAYER.c", 39; 4,
 2540                        		.dbg	line,	"include\tables_PLAYER.c", 40; 5
 2541                        		.dbg	line,	"include\tables_PLAYER.c", 41; };
 2542                        		.dbg	line,	"include\tables_PLAYER.c", 44; const signed char       TABLE_PLAYER_FALL[21]       =   {
 2543                        		.dbg	line,	"include\tables_PLAYER.c", 45; 0,
 2544                        		.dbg	line,	"include\tables_PLAYER.c", 46; 0,
 2545                        		.dbg	line,	"include\tables_PLAYER.c", 47; 0,
 2546                        		.dbg	line,	"include\tables_PLAYER.c", 48; 0,
 2547                        		.dbg	line,	"include\tables_PLAYER.c", 49; 1,
 2548                        		.dbg	line,	"include\tables_PLAYER.c", 50; 1,
 2549                        		.dbg	line,	"include\tables_PLAYER.c", 51; 1,
 2550                        		.dbg	line,	"include\tables_PLAYER.c", 52; 1,
 2551                        		.dbg	line,	"include\tables_PLAYER.c", 53; 2,
 2552                        		.dbg	line,	"include\tables_PLAYER.c", 54; 2,
 2553                        		.dbg	line,	"include\tables_PLAYER.c", 55; 2,
 2554                        		.dbg	line,	"include\tables_PLAYER.c", 56; 2,
 2555                        		.dbg	line,	"include\tables_PLAYER.c", 57; 3,
 2556                        		.dbg	line,	"include\tables_PLAYER.c", 58; 3,
 2557                        		.dbg	line,	"include\tables_PLAYER.c", 59; 3,
 2558                        		.dbg	line,	"include\tables_PLAYER.c", 60; 4,
 2559                        		.dbg	line,	"include\tables_PLAYER.c", 61; 4,
 2560                        		.dbg	line,	"include\tables_PLAYER.c", 62; 4,
 2561                        		.dbg	line,	"include\tables_PLAYER.c", 63; 4,
 2562                        		.dbg	line,	"include\tables_PLAYER.c", 64; 4,
 2563                        		.dbg	line,	"include\tables_PLAYER.c", 65; 5
 2564                        		.dbg	line,	"include\tables_PLAYER.c", 66; };
 2565                        		.dbg	line,	"include\tables_PLAYER.c", 69; const signed char       TABLE_PLAYER_JUMP_LADDER[30]    =   {
 2566                        		.dbg	line,	"include\tables_PLAYER.c", 70; // UPWARD
 2567                        		.dbg	line,	"include\tables_PLAYER.c", 71; -4,
 2568                        		.dbg	line,	"include\tables_PLAYER.c", 72; -4,
 2569                        		.dbg	line,	"include\tables_PLAYER.c", 73; -3,
 2570                        		.dbg	line,	"include\tables_PLAYER.c", 74; -3,
 2571                        		.dbg	line,	"include\tables_PLAYER.c", 75; -3,
 2572                        		.dbg	line,	"include\tables_PLAYER.c", 76; -2,
 2573                        		.dbg	line,	"include\tables_PLAYER.c", 77; -2,
 2574                        		.dbg	line,	"include\tables_PLAYER.c", 78; -2,
 2575                        		.dbg	line,	"include\tables_PLAYER.c", 79; -1,
 2576                        		.dbg	line,	"include\tables_PLAYER.c", 80; -1,
 2577                        		.dbg	line,	"include\tables_PLAYER.c", 81; -1,
 2578                        		.dbg	line,	"include\tables_PLAYER.c", 82; -1,
 2579                        		.dbg	line,	"include\tables_PLAYER.c", 83; -1,
 2580                        		.dbg	line,	"include\tables_PLAYER.c", 84; 0,
 2581                        		.dbg	line,	"include\tables_PLAYER.c", 85; 0,
 2582                        		.dbg	line,	"include\tables_PLAYER.c", 86; 0,
 2583                        		.dbg	line,	"include\tables_PLAYER.c", 87; 0,
 2584                        		.dbg	line,	"include\tables_PLAYER.c", 88; // DOWNWARD
 2585                        		.dbg	line,	"include\tables_PLAYER.c", 89; 1,
 2586                        		.dbg	line,	"include\tables_PLAYER.c", 90; 1,
 2587                        		.dbg	line,	"include\tables_PLAYER.c", 91; 1,
 2588                        		.dbg	line,	"include\tables_PLAYER.c", 92; 1,
 2589                        		.dbg	line,	"include\tables_PLAYER.c", 93; 1,
 2590                        		.dbg	line,	"include\tables_PLAYER.c", 94; 2,
 2591                        		.dbg	line,	"include\tables_PLAYER.c", 95; 2,
 2592                        		.dbg	line,	"include\tables_PLAYER.c", 96; 2,
 2593                        		.dbg	line,	"include\tables_PLAYER.c", 97; 3,
 2594                        		.dbg	line,	"include\tables_PLAYER.c", 98; 3,
 2595                        		.dbg	line,	"include\tables_PLAYER.c", 99; 3,
 2596                        		.dbg	line,	"include\tables_PLAYER.c", 100; 4,
 2597                        		.dbg	line,	"include\tables_PLAYER.c", 101; 4
 2598                        		.dbg	line,	"main.c", 22; };
 2599                        		.dbg	line,	"main.c", 23; #include "include/routines_LEVELS.c"
 2600                        		.dbg	line,	"include\routines_LEVELS.c", 1; #include "huc.h"
 2601                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 1; #ifndef _hucc_legacy_h
 2602                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 2; #define _hucc_legacy_h
 2603                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 4; /****************************************************************************
 2604                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 5; ; ***************************************************************************
 2605                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 6; ;
 2606                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 7; ; huc.h
 2607                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 8; ;
 2608                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 9; ; HuCC wrapper file to include a default set of HuC-compatible functions.
 2609                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 10; ;
 2610                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 11; ; Copyright John Brandwood 2024.
 2611                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 12; ;
 2612                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 13; ; Distributed under the Boost Software License, Version 1.0.
 2613                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 14; ; (See accompanying file LICENSE_1_0.txt or copy at
 2614                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 15; ;  http://www.boost.org/LICENSE_1_0.txt)
 2615                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 16; ;
 2616                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 17; ; ***************************************************************************
 2617                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 18; ; ***************************************************************************
 2618                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 19; ;
 2619                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 20; ; When the HuCC compiler is invoked with the "--legacy" option to compile old
 2620                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 21; ; projects, then this "huc.h" file is automatically included.
 2621                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 22; ;
 2622                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 23; ; This file includes a set of the individual HuCC headers which correspond to
 2623                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 24; ; HuC's built-in functions and MagicKit library.
 2624                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 25; ;
 2625                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 26; ; New HuCC projects should, preferably, include the specific headers that are
 2626                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 27; ; needed, which will then allow them to replace parts of the standard library
 2627                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 28; ; with newer functions, or they can just manually include this "huc.h" file.
 2628                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 29; ;
 2629                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 30; ; ***************************************************************************
 2630                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 31; ; **************************************************************************/
 2631                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 33; #include "hucc-systemcard.h"
 2632                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 34; #include "hucc-baselib.h"
 2633                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 35; #include "hucc-gfx.h"
 2634                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 36; #include "hucc-string.h"
 2635                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 37; #include "hucc-old-scroll.h"
 2636                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 38; #include "hucc-old-spr.h"
 2637                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 39; #include "hucc-old-map.h"
 2638                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 40; #include "hucc-old-line.h"
 2639                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 42; #endif // _hucc_legacy_h
 2640                        		.dbg	line,	"include\routines_LEVELS.c", 2; #include "hucc-scroll.h"
 2641                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 1; #ifndef _hucc_scroll_h
 2642                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 2; #define _hucc_scroll_h
 2643                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 4; /****************************************************************************
 2644                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 5; ; ***************************************************************************
 2645                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 6; ;
 2646                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 7; ; hucc-scroll.h
 2647                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 8; ;
 2648                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 9; ; Routines for a fast split-screen scrolling system.
 2649                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 10; ;
 2650                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 11; ; Copyright John Brandwood 2024.
 2651                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 12; ;
 2652                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 13; ; Distributed under the Boost Software License, Version 1.0.
 2653                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 14; ; (See accompanying file LICENSE_1_0.txt or copy at
 2654                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 15; ;  http://www.boost.org/LICENSE_1_0.txt)
 2655                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 16; ;
 2656                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 17; ; ***************************************************************************
 2657                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 18; ; ***************************************************************************
 2658                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 19; ;
 2659                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 20; ; The maximum number of splits for each screen layer is set in your project's
 2660                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 21; ; "hucc-config.inc" file, with the library having a limit of 128-per-layer.
 2661                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 22; ;
 2662                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 23; ; Your first active split must be defined to start at screen line 0, and then
 2663                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 24; ; the rest of the active splits must be in increasing line order to match the
 2664                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 25; ; way that the PC Engine displays the output image.
 2665                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 26; ;
 2666                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 27; ; You can have disabled splits interleaved with your active splits.
 2667                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 28; ;
 2668                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 29; ; Splits that are normally disabled can be used to create full screen effects
 2669                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 30; ; such as bouncing the screen up and down by adding blank areas at the top or
 2670                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 31; ; bottom of the screen, and then rapidly changing the height of those areas.
 2671                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 32; ;
 2672                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 33; ; ***************************************************************************
 2673                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 34; ; **************************************************************************/
 2674                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 36; // *************
 2675                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 37; // VDC bits for display_flags ...
 2676                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 38; // *************
 2677                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 40; #ifndef BKG_OFF
 2678                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 41; #define BKG_OFF 0x00
 2679                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 42; #endif
 2680                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 44; #ifndef SPR_OFF
 2681                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 45; #define SPR_OFF 0x00
 2682                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 46; #endif
 2683                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 48; #ifndef BKG_ON
 2684                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 49; #define BKG_ON 0x80
 2685                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 50; #endif
 2686                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 52; #ifndef SPR_ON
 2687                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 53; #define SPR_ON 0x40
 2688                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 54; #endif
 2689                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 56; // *************
 2690                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 57; // Functions in hucc-scroll.asm ...
 2691                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 58; // *************
 2692                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 60; #ifdef __HUCC__
 2693                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 62; #asmdef	HUCC_USES_NEW_SCROLL 1
 2694                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 64; extern void __fastcall scroll_split( unsigned char index<_al>, unsigned char screen_line<_ah>, unsigned int bat_x<_bx>, unsigned int bat_y<_cx>, unsigned char display_flags<_dl> );
 2695                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 65; extern void __fastcall sgx_scroll_split( unsigned char index<_al>, unsigned char screen_line<_ah>, unsigned int bat_x<_bx>, unsigned int bat_y<_cx>, unsigned char display_flags<_dl> );
 2696                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 67; extern void __fastcall disable_split( unsigned char index<acc> );
 2697                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 68; extern void __fastcall sgx_disable_split( unsigned char index<acc> );
 2698                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 70; extern void __fastcall __macro disable_all_splits( void );
 2699                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 71; extern void __fastcall __macro sgx_disable_all_splits( void );
 2700                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 73; #asm
 2701                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 74; .macro	_disable_all_splits
 2702                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 75; ldy	#HUCC_PCE_SPLITS - 1
 2703                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 76; !loop:		tya
 2704                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 77; call	_disable_split.1
 2705                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 78; dey
 2706                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 79; bpl	!loop-
 2707                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 80; .endm
 2708                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 82; .macro	_sgx_disable_all_splits
 2709                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 83; ldy	#HUCC_SGX_SPLITS - 1
 2710                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 84; !loop:		tya
 2711                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 85; call	_sgx_disable_split.1
 2712                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 86; dey
 2713                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 87; bpl	!loop-
 2714                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 88; .endm
 2715                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 89; #endasm
 2716                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 91; #endif // __HUCC__
 2717                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 93; #endif // _hucc_scroll_h
 2718                        		.dbg	line,	"include\routines_LEVELS.c", 3; #include "hucc-chrmap.h"
 2719                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 1; #ifndef _hucc_chrmap_h
 2720                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 2; #define _hucc_chrmap_h
 2721                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 4; /****************************************************************************
 2722                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 5; ; ***************************************************************************
 2723                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 6; ;
 2724                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 7; ; hucc-chrmap.h
 2725                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 8; ;
 2726                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 9; ; A simple map system based on 8x8 characters (aka "tiles") in BAT format.
 2727                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 10; ;
 2728                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 11; ; Copyright John Brandwood 2025.
 2729                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 12; ;
 2730                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 13; ; Distributed under the Boost Software License, Version 1.0.
 2731                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 14; ; (See accompanying file LICENSE_1_0.txt or copy at
 2732                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 15; ;  http://www.boost.org/LICENSE_1_0.txt)
 2733                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 16; ;
 2734                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 17; ; ***************************************************************************
 2735                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 18; ; ***************************************************************************
 2736                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 19; ;
 2737                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 20; ; The maximum X and Y size for chrmaps is 256 characters (2048 pixels).
 2738                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 21; ;
 2739                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 22; ; The maximum total size for a chrmap is 16KBytes, which allows for maps up
 2740                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 23; ; to 256x32 tiles (2048x256 pixels).
 2741                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 24; ;
 2742                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 25; ; ***************************************************************************
 2743                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 26; ; **************************************************************************/
 2744                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 28; // *************
 2745                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 29; // This code extends the blkmap library ...
 2746                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 30; // *************
 2747                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 32; #include "hucc-blkmap.h"
 2748                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 34; // *************
 2749                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 35; // Functions in chrmap.asm ...
 2750                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 36; // *************
 2751                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 38; #ifdef __HUCC__
 2752                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 40; #asmdef	HUCC_USES_CHRMAP 1
 2753                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 42; extern void __fastcall __nop set_chrmap( unsigned char __far *chrmap<vdc_map_bank:vdc_map_addr>, unsigned char tiles_w<vdc_map_line_w> );
 2754                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 44; extern void __fastcall draw_bat( void );
 2755                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 45; extern void __fastcall scroll_bat( void );
 2756                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 47; extern void __fastcall blit_bat( unsigned char tile_x<map_bat_x>, unsigned char tile_y<map_bat_y>, unsigned char tile_w<map_draw_x>, unsigned char tile_h<map_draw_y> );
 2757                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 49; #ifdef _SGX
 2758                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 51; extern void __fastcall __nop sgx_set_chrmap( unsigned char __far *chrmap<sgx_map_bank:sgx_map_addr>, unsigned char tiles_w<sgx_map_line_w> );
 2759                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 53; extern void __fastcall sgx_draw_bat( void );
 2760                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 54; extern void __fastcall sgx_scroll_bat( void );
 2761                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 56; extern void __fastcall sgx_blit_bat( unsigned char tile_x<map_bat_x>, unsigned char tile_y<map_bat_y>, unsigned char tile_w<map_draw_x>, unsigned char tile_h<map_draw_y> );
 2762                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 58; #endif
 2763                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 60; #endif // __HUCC__
 2764                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 62; #endif // _hucc_chrmap_h
 2765                        		.dbg	line,	"include\routines_LEVELS.c", 4; #include "hucc-blkmap.h"
 2766                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 1; #ifndef _hucc_blkmap_h
 2767                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 2; #define _hucc_blkmap_h
 2768                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 4; /****************************************************************************
 2769                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 5; ; ***************************************************************************
 2770                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 6; ;
 2771                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 7; ; hucc-blkmap.h
 2772                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 8; ;
 2773                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 9; ; A map system based on 16x16 meta-tiles (aka "blocks", aka CHR/BLK/MAP).
 2774                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 10; ;
 2775                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 11; ; Copyright John Brandwood 2025.
 2776                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 12; ;
 2777                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 13; ; Distributed under the Boost Software License, Version 1.0.
 2778                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 14; ; (See accompanying file LICENSE_1_0.txt or copy at
 2779                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 15; ;  http://www.boost.org/LICENSE_1_0.txt)
 2780                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 16; ;
 2781                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 17; ; ***************************************************************************
 2782                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 18; ; ***************************************************************************
 2783                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 19; ;
 2784                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 20; ; The maximum X and Y size for blkmaps is 128 blocks (2048 pixels).
 2785                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 21; ;
 2786                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 22; ; The maximum total size for a blkmap is 16KBytes, which allows for maps up
 2787                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 23; ; to 128x128 blocks (2048x2048 pixels).
 2788                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 24; ;
 2789                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 25; ; Huge multi-screen blkmaps are also supported (optionally).
 2790                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 26; ;
 2791                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 27; ; The maximum X and Y for multi-screen maps is 128 screens (32768 pixels).
 2792                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 28; ;
 2793                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 29; ; The maximum total size for a multi-screen map is 8KBytes, which allows for
 2794                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 30; ; a total of 1024 screens.
 2795                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 31; ;
 2796                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 32; ; ***************************************************************************
 2797                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 33; ; **************************************************************************/
 2798                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 35; // *************
 2799                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 36; // Functions in blkmap.asm ...
 2800                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 37; // *************
 2801                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 39; #ifdef __HUCC__
 2802                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 41; #asmdef	HUCC_USES_BLKMAP 1
 2803                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 43; // Current top-left of drawn map in pixels.
 2804                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 44; extern unsigned int   vdc_map_pxl_x;
 2805                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 45; extern unsigned int   vdc_map_pxl_y;
 2806                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 47; // Width and height to draw/scroll in characters (not tiles).
 2807                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 48; extern unsigned char  vdc_map_draw_w;
 2808                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 49; extern unsigned char  vdc_map_draw_h;
 2809                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 51; // Width of map (or multi-screen BAT) in tiles.
 2810                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 52; extern unsigned char  vdc_map_line_w;
 2811                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 54; // Width of map in screens (if multi-screen map).
 2812                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 55; extern unsigned char  vdc_map_scrn_w;
 2813                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 57; // Extra information returned by get_map_block() and sgx_get_map_block(),
 2814                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 58; // which are the collision flags and the mask/overlay sprite for the BLK.
 2815                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 59; extern unsigned char  map_blk_flag;
 2816                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 60; extern unsigned char  map_blk_mask;
 2817                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 62; extern unsigned char  vdc_scr_bank;
 2818                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 63; extern unsigned char *vdc_scr_addr;
 2819                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 65; extern unsigned char  vdc_map_bank;
 2820                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 66; extern unsigned char *vdc_map_addr;
 2821                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 68; extern unsigned char  vdc_blk_bank;
 2822                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 69; extern unsigned char *vdc_blk_addr;
 2823                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 71; extern unsigned char  vdc_tbl_bank;
 2824                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 72; extern unsigned char *vdc_tbl_addr;
 2825                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 74; extern void __fastcall set_blocks( unsigned char __far *blk_def<vdc_blk_bank:vdc_blk_addr>, unsigned char __far *flg_def<vdc_tbl_bank:vdc_tbl_addr>, unsigned char number_of_blocks<_al> );
 2826                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 75; extern void __fastcall __macro set_blkmap( unsigned char __far *blk_map<vdc_map_bank:vdc_map_addr>, unsigned char blocks_w<vdc_map_line_w> );
 2827                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 76; extern void __fastcall __macro set_multimap( unsigned char __far *multi_map<vdc_scr_bank:vdc_scr_addr>, unsigned char screens_w<vdc_map_scrn_w> );
 2828                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 78; extern void __fastcall draw_map( void );
 2829                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 79; extern void __fastcall scroll_map( void );
 2830                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 81; extern void __fastcall blit_map( unsigned char tile_x<map_bat_x>, unsigned char tile_y<map_bat_y>, unsigned char tile_w<map_draw_x>, unsigned char tile_h<map_draw_y> );
 2831                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 83; extern unsigned char __fastcall get_map_block( unsigned int x<map_pxl_x>, unsigned int y<map_pxl_y> );
 2832                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 85; #asm
 2833                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 86; .macro	_set_blkmap.2
 2834                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 87; stz	vdc_scr_bank
 2835                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 88; .endm
 2836                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 90; .macro	_set_multimap.2
 2837                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 91; lda	vdc_bat_width
 2838                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 92; lsr	a
 2839                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 93; sta	vdc_map_line_w
 2840                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 94; .endm
 2841                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 96; .macro	SCREEN
 2842                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 97; db	(((\1) & $1FFF) | $6000) >> 8, bank(\1)
 2843                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 98; db	(((\2) & $1FFF) | $4000) >> 8, bank(\2)
 2844                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 99; db	(((\3) & $1FFF) | $6000) >> 8, bank(\3)
 2845                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 100; dw	(\4)
 2846                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 101; .endm
 2847                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 102; #endasm
 2848                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 104; #ifdef _SGX
 2849                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 106; // Current top-left of drawn map in pixels.
 2850                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 107; extern unsigned int   sgx_map_pxl_x;
 2851                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 108; extern unsigned int   sgx_map_pxl_y;
 2852                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 110; // Width and height to draw/scroll in characters (not tiles).
 2853                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 111; extern unsigned char  sgx_map_draw_w;
 2854                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 112; extern unsigned char  sgx_map_draw_h;
 2855                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 114; // Width of map (or multi-screen BAT) in tiles.
 2856                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 115; extern unsigned char  sgx_map_line_w;
 2857                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 117; // Width of map in screens (if multi-screen map).
 2858                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 118; extern unsigned char  sgx_map_scrn_w;
 2859                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 120; extern unsigned char  sgx_scr_bank;
 2860                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 121; extern unsigned char *sgx_scr_addr;
 2861                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 123; extern unsigned char  sgx_map_bank;
 2862                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 124; extern unsigned char *sgx_map_addr;
 2863                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 126; extern unsigned char  sgx_blk_bank;
 2864                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 127; extern unsigned char *sgx_blk_addr;
 2865                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 129; extern unsigned char  sgx_tbl_bank;
 2866                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 130; extern unsigned char *sgx_tbl_addr;
 2867                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 132; extern void __fastcall sgx_set_blocks( unsigned char __far *blk_def<sgx_blk_bank:sgx_blk_addr>, unsigned char __far *flg_def<sgx_tbl_bank:sgx_tbl_addr>, unsigned char number_of_blocks<_al> );
 2868                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 133; extern void __fastcall __macro sgx_set_blkmap( unsigned char __far *blk_map<sgx_map_bank:sgx_map_addr>, unsigned char blocks_w<sgx_map_line_w> );
 2869                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 134; extern void __fastcall __macro sgx_set_multimap( unsigned char __far *multi_map<sgx_scr_bank:sgx_scr_addr>, unsigned char screens_w<sgx_map_scrn_w> );
 2870                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 136; extern void __fastcall sgx_draw_map( void );
 2871                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 137; extern void __fastcall sgx_scroll_map( void );
 2872                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 139; extern void __fastcall sgx_blit_map( unsigned char tile_x<map_bat_x>, unsigned char tile_y<map_bat_y>, unsigned char tile_w<map_draw_x>, unsigned char tile_h<map_draw_y> );
 2873                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 141; extern unsigned char __fastcall sgx_get_map_block( unsigned int x<map_pxl_x>, unsigned int y<map_pxl_y> );
 2874                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 143; #asm
 2875                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 144; .macro	_sgx_set_blkmap.2
 2876                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 145; stz	sgx_scr_bank
 2877                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 146; .endm
 2878                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 148; .macro	_sgx_set_multimap.2
 2879                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 149; lda	sgx_bat_width
 2880                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 150; lsr	a
 2881                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 151; sta	sgx_map_line_w
 2882                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 152; .endm
 2883                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 153; #endasm
 2884                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 155; #endif
 2885                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 157; #endif // __HUCC__
 2886                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 159; #endif // _hucc_blkmap_h
 2887                        		.dbg	line,	"include\routines_LEVELS.c", 13; void display_TIME()
 2888                        		.dbg	line,	"include\routines_LEVELS.c", 14; {
 2889                        	;***********************
 2890                        	;***********************
 2891                        	
 2892                        		.hucc
 2893    01:DD34             		.proc		_display_TIME
 2894                        		__enter		_display_TIME
 2895                        	
 2896                        		.dbg	line,	"include\routines_LEVELS.c", 15; put_number(minutes,1,1,3);
 2897                        		__ld.um		_minutes
         01:DD34  AD 1D 23   			lda	_minutes
         01:DD37  C2         			cly
 2898                        		__st.wmq	_bx
         01:DD38  85 FA      			sta.l	_bx
         01:DD3A  84 FB      			sty.h	_bx
 2899                        		__st.umiq	1, _cl
         01:DD3C  A9 01      			lda.l	#1
         01:DD3E  85 FC      			sta	_cl
 2900                        		__st.umiq	1, _dil
         01:DD40  A9 01      			lda.l	#1
         01:DD42  85 F0      			sta	_dil
 2901                        		__st.umiq	3, _dih
         01:DD44  A9 03      			lda.l	#3
         01:DD46  85 F1      			sta	_dih
 2902                        		__call		_put_number.4
         01:DD48  20 9F FF   			call	_put_number.4
 2903                        	
 2904                        		.dbg	line,	"include\routines_LEVELS.c", 17; if(seconds < 10)
 2905                        		__ld.umq	_seconds
         01:DD4B  AD 1E 23   			lda	_seconds
 2906                        		__ult_b.uiq	10
         01:DD4E  C9 0A      			cmp	#10		; Subtract integer from A.
         01:DD50  6A         			ror	a		; CC if A < integer.
         01:DD51  49 80      			eor	#$80
         01:DD53  2A         			rol	a
 2907                        		__bfalse	.LL3
         01:DD54  90 2C      			bcc	.LL3
 2908                        	
 2909                        		.dbg	line,	"include\routines_LEVELS.c", 18; {
 2910                        	
 2911                        		.dbg	line,	"include\routines_LEVELS.c", 19; put_number(0,1,3,3);
 2912                        		__st.wmiq	0, _bx
         01:DD56  64 FA      			stz.l	_bx
         01:DD58  64 FB      			stz.h	_bx
 2913                        		__st.umiq	1, _cl
         01:DD5A  A9 01      			lda.l	#1
         01:DD5C  85 FC      			sta	_cl
 2914                        		__st.umiq	3, _dil
         01:DD5E  A9 03      			lda.l	#3
         01:DD60  85 F0      			sta	_dil
 2915                        		__st.umiq	3, _dih
         01:DD62  A9 03      			lda.l	#3
         01:DD64  85 F1      			sta	_dih
 2916                        		__call		_put_number.4
         01:DD66  20 9F FF   			call	_put_number.4
 2917                        	
 2918                        		.dbg	line,	"include\routines_LEVELS.c", 20; put_number(seconds,1,4,3);
 2919                        		__ld.um		_seconds
         01:DD69  AD 1E 23   			lda	_seconds
         01:DD6C  C2         			cly
 2920                        		__st.wmq	_bx
         01:DD6D  85 FA      			sta.l	_bx
         01:DD6F  84 FB      			sty.h	_bx
 2921                        		__st.umiq	1, _cl
         01:DD71  A9 01      			lda.l	#1
         01:DD73  85 FC      			sta	_cl
 2922                        		__st.umiq	4, _dil
         01:DD75  A9 04      			lda.l	#4
         01:DD77  85 F0      			sta	_dil
 2923                        		__st.umiq	3, _dih
         01:DD79  A9 03      			lda.l	#3
         01:DD7B  85 F1      			sta	_dih
 2924                        		__call		_put_number.4
         01:DD7D  20 9F FF   			call	_put_number.4
 2925                        	
 2926                        		.dbg	line,	"include\routines_LEVELS.c", 21; }
 2927                        	
 2928                        		.dbg	line,	"include\routines_LEVELS.c", 23; else
 2929                        		__bra		.LL4
         01:DD80  80 17      			bra	.LL4
 2930    01:DD82             	.LL3:
 2931                        	
 2932                        		.dbg	line,	"include\routines_LEVELS.c", 24; {
 2933                        	
 2934                        		.dbg	line,	"include\routines_LEVELS.c", 25; put_number(seconds,2,3,3);
 2935                        		__ld.um		_seconds
         01:DD82  AD 1E 23   			lda	_seconds
         01:DD85  C2         			cly
 2936                        		__st.wmq	_bx
         01:DD86  85 FA      			sta.l	_bx
         01:DD88  84 FB      			sty.h	_bx
 2937                        		__st.umiq	2, _cl
         01:DD8A  A9 02      			lda.l	#2
         01:DD8C  85 FC      			sta	_cl
 2938                        		__st.umiq	3, _dil
         01:DD8E  A9 03      			lda.l	#3
         01:DD90  85 F0      			sta	_dil
 2939                        		__st.umiq	3, _dih
         01:DD92  A9 03      			lda.l	#3
         01:DD94  85 F1      			sta	_dih
 2940                        		__call		_put_number.4
         01:DD96  20 9F FF   			call	_put_number.4
 2941                        	
 2942                        		.dbg	line,	"include\routines_LEVELS.c", 26; }
 2943    01:DD99             	.LL4:
 2944                        	
 2945                        		.dbg	line,	"include\routines_LEVELS.c", 28; time_counter += 1;
 2946                        		__add_st.umiq	1, _time_counter
         01:DD99  EE 1F 23   			inc	_time_counter
 2947                        	
 2948                        		.dbg	line,	"include\routines_LEVELS.c", 30; if(time_counter == 60)
 2949                        		__ld.umq	_time_counter
         01:DD9C  AD 1F 23   			lda	_time_counter
 2950                        		__equ_b.uiq	60
         01:DD9F  C9 3C      			cmp	#60
         01:DDA1  F0 01      			beq	!+
         01:DDA3  18         			clc
         01:DDA4             	!:
 2951                        		__bfalse	.LL5
         01:DDA4  90 28      			bcc	.LL5
 2952                        	
 2953                        		.dbg	line,	"include\routines_LEVELS.c", 31; {
 2954                        	
 2955                        		.dbg	line,	"include\routines_LEVELS.c", 32; time_counter = 0;
 2956                        		__st.umiq	0, _time_counter
         01:DDA6  9C 1F 23   			stz	_time_counter
 2957                        	
 2958                        		.dbg	line,	"include\routines_LEVELS.c", 34; if(seconds > 0)
 2959                        		__ld.umq	_seconds
         01:DDA9  AD 1E 23   			lda	_seconds
 2960                        		__ugt_b.uiq	0
         01:DDAC  18         			clc			; Subtract integer+1 from A.
         01:DDAD  E9 00      			sbc	#0		; CS if A > integer.
 2961                        		__bfalse	.LL6
         01:DDAF  90 05      			bcc	.LL6
 2962                        	
 2963                        		.dbg	line,	"include\routines_LEVELS.c", 35; {
 2964                        	
 2965                        		.dbg	line,	"include\routines_LEVELS.c", 36; seconds -= 1;
 2966                        		__sub_st.umiq	1, _seconds
         01:DDB1  CE 1E 23   			dec	_seconds
 2967                        	
 2968                        		.dbg	line,	"include\routines_LEVELS.c", 37; }
 2969                        	
 2970                        		.dbg	line,	"include\routines_LEVELS.c", 39; else
 2971                        		__bra		.LL7
         01:DDB4  80 18      			bra	.LL7
 2972    01:DDB6             	.LL6:
 2973                        	
 2974                        		.dbg	line,	"include\routines_LEVELS.c", 40; {
 2975                        	
 2976                        		.dbg	line,	"include\routines_LEVELS.c", 41; if(minutes > 0)
 2977                        		__ld.umq	_minutes
         01:DDB6  AD 1D 23   			lda	_minutes
 2978                        		__ugt_b.uiq	0
         01:DDB9  18         			clc			; Subtract integer+1 from A.
         01:DDBA  E9 00      			sbc	#0		; CS if A > integer.
 2979                        		__bfalse	.LL8
         01:DDBC  90 0A      			bcc	.LL8
 2980                        	
 2981                        		.dbg	line,	"include\routines_LEVELS.c", 42; {
 2982                        	
 2983                        		.dbg	line,	"include\routines_LEVELS.c", 43; seconds = 59;
 2984                        		__st.umiq	59, _seconds
         01:DDBE  A9 3B      			lda.l	#59
         01:DDC0  8D 1E 23   			sta	_seconds
 2985                        	
 2986                        		.dbg	line,	"include\routines_LEVELS.c", 44; minutes -= 1;
 2987                        		__sub_st.umiq	1, _minutes
         01:DDC3  CE 1D 23   			dec	_minutes
 2988                        	
 2989                        		.dbg	line,	"include\routines_LEVELS.c", 45; }
 2990                        	
 2991                        		.dbg	line,	"include\routines_LEVELS.c", 47; else
 2992                        		__bra		.LL9
         01:DDC6  80 06      			bra	.LL9
 2993    01:DDC8             	.LL8:
 2994                        	
 2995                        		.dbg	line,	"include\routines_LEVELS.c", 48; {
 2996                        	
 2997                        		.dbg	line,	"include\routines_LEVELS.c", 49; seconds = 0;
 2998                        		__st.umiq	0, _seconds
         01:DDC8  9C 1E 23   			stz	_seconds
 2999                        	
 3000                        		.dbg	line,	"include\routines_LEVELS.c", 50; minutes = 0;
 3001                        		__st.umiq	0, _minutes
         01:DDCB  9C 1D 23   			stz	_minutes
 3002                        	
 3003                        		.dbg	line,	"include\routines_LEVELS.c", 51; // TIME OUT //
 3004                        	
 3005                        		.dbg	line,	"include\routines_LEVELS.c", 52; }
 3006    01:DDCE             	.LL9:
 3007                        	
 3008                        		.dbg	line,	"include\routines_LEVELS.c", 53; }
 3009    01:DDCE             	.LL7:
 3010                        	
 3011                        		.dbg	line,	"include\routines_LEVELS.c", 54; }
 3012                        	
 3013                        		.dbg	line,	"include\routines_LEVELS.c", 55; 
 3014                        	
 3015                        		.dbg	line,	"include\routines_LEVELS.c", 56; }
 3016    01:DDCE             	.LL5:
 3017    01:DDCE             	.LL2:
 3018                        		__return	0
         01:DDCE  4C EF FF   			jmp	leave_proc
 3019                        		.dbg	clear
 3020                        		.endp
 3021                        		.pceas
 3022                        	
 3023                        		.dbg	line,	"include\routines_LEVELS.c", 59; void display_KEY()
 3024                        		.dbg	line,	"include\routines_LEVELS.c", 60; {
 3025                        	;***********************
 3026                        	;***********************
 3027                        	
 3028                        		.hucc
 3029    02:C3DB             		.proc		_display_KEY
 3030                        		__enter		_display_KEY
 3031                        	
 3032                        		.dbg	line,	"include\routines_LEVELS.c", 61; put_number(key_number,2,7,27);
 3033                        		__ld.um		_key_number
         02:C3DB  AD 1A 23   			lda	_key_number
         02:C3DE  C2         			cly
 3034                        		__st.wmq	_bx
         02:C3DF  85 FA      			sta.l	_bx
         02:C3E1  84 FB      			sty.h	_bx
 3035                        		__st.umiq	2, _cl
         02:C3E3  A9 02      			lda.l	#2
         02:C3E5  85 FC      			sta	_cl
 3036                        		__st.umiq	7, _dil
         02:C3E7  A9 07      			lda.l	#7
         02:C3E9  85 F0      			sta	_dil
 3037                        		__st.umiq	27, _dih
         02:C3EB  A9 1B      			lda.l	#27
         02:C3ED  85 F1      			sta	_dih
 3038                        		__call		_put_number.4
         02:C3EF  20 9F FF   			call	_put_number.4
 3039                        	
 3040                        		.dbg	line,	"include\routines_LEVELS.c", 62; }
 3041    02:C3F2             	.LL10:
 3042                        		__return	0
         02:C3F2  4C EF FF   			jmp	leave_proc
 3043                        		.dbg	clear
 3044                        		.endp
 3045                        		.pceas
 3046                        	
 3047                        		.dbg	line,	"include\routines_LEVELS.c", 65; void display_POTION()
 3048                        		.dbg	line,	"include\routines_LEVELS.c", 66; {
 3049                        	;***********************
 3050                        	;***********************
 3051                        	
 3052                        		.hucc
 3053    02:C3F5             		.proc		_display_POTION
 3054                        		__enter		_display_POTION
 3055                        	
 3056                        		.dbg	line,	"include\routines_LEVELS.c", 67; put_number(potion_number,2,19,27);
 3057                        		__ld.um		_potion_number
         02:C3F5  AD 1B 23   			lda	_potion_number
         02:C3F8  C2         			cly
 3058                        		__st.wmq	_bx
         02:C3F9  85 FA      			sta.l	_bx
         02:C3FB  84 FB      			sty.h	_bx
 3059                        		__st.umiq	2, _cl
         02:C3FD  A9 02      			lda.l	#2
         02:C3FF  85 FC      			sta	_cl
 3060                        		__st.umiq	19, _dil
         02:C401  A9 13      			lda.l	#19
         02:C403  85 F0      			sta	_dil
 3061                        		__st.umiq	27, _dih
         02:C405  A9 1B      			lda.l	#27
         02:C407  85 F1      			sta	_dih
 3062                        		__call		_put_number.4
         02:C409  20 9F FF   			call	_put_number.4
 3063                        	
 3064                        		.dbg	line,	"include\routines_LEVELS.c", 68; }
 3065    02:C40C             	.LL11:
 3066                        		__return	0
         02:C40C  4C EF FF   			jmp	leave_proc
 3067                        		.dbg	clear
 3068                        		.endp
 3069                        		.pceas
 3070                        	
 3071                        		.dbg	line,	"include\routines_LEVELS.c", 71; void display_ZENNY()
 3072                        		.dbg	line,	"include\routines_LEVELS.c", 72; {
 3073                        	;***********************
 3074                        	;***********************
 3075                        	
 3076                        		.hucc
 3077    02:C40F             		.proc		_display_ZENNY
 3078                        		__enter		_display_ZENNY
 3079                        	
 3080                        		.dbg	line,	"include\routines_LEVELS.c", 73; put_number(zenny_number,5,26,4);
 3081                        		__ld.um		_zenny_number
         02:C40F  AD 1C 23   			lda	_zenny_number
         02:C412  C2         			cly
 3082                        		__st.wmq	_bx
         02:C413  85 FA      			sta.l	_bx
         02:C415  84 FB      			sty.h	_bx
 3083                        		__st.umiq	5, _cl
         02:C417  A9 05      			lda.l	#5
         02:C419  85 FC      			sta	_cl
 3084                        		__st.umiq	26, _dil
         02:C41B  A9 1A      			lda.l	#26
         02:C41D  85 F0      			sta	_dil
 3085                        		__st.umiq	4, _dih
         02:C41F  A9 04      			lda.l	#4
         02:C421  85 F1      			sta	_dih
 3086                        		__call		_put_number.4
         02:C423  20 9F FF   			call	_put_number.4
 3087                        	
 3088                        		.dbg	line,	"include\routines_LEVELS.c", 74; }
 3089    02:C426             	.LL12:
 3090                        		__return	0
         02:C426  4C EF FF   			jmp	leave_proc
 3091                        		.dbg	clear
 3092                        		.endp
 3093                        		.pceas
 3094                        	
 3095                        		.dbg	line,	"include\routines_LEVELS.c", 80; void scroll_object()
 3096                        		.dbg	line,	"include\routines_LEVELS.c", 81; {
 3097                        	;***********************
 3098                        	;***********************
 3099                        	
 3100                        		.hucc
 3101    01:D1ED             		.proc		_scroll_object
 3102                        		__enter		_scroll_object
 3103                        	
 3104                        		.dbg	line,	"include\routines_LEVELS.c", 82; char i;
 3105                        	
 3106                        		.dbg	line,	"include\routines_LEVELS.c", 83; onscreen_object_number = 0;
 3107                        		__st.umiq	0, _onscreen_object_number
         01:D1ED  9C 22 23   			stz	_onscreen_object_number
 3108                        	
 3109                        		.dbg	line,	"include\routines_LEVELS.c", 85; for(i=0 ; i<level_object_number ; i++)
 3110                        		__st.umiq	0, __scroll_object_end - 1  /* i */
         01:D1F0  9C 10 25   			stz	__scroll_object_end - 1
 3111    01:D1F3             	.LL14:
 3112                        		__ld.umq	__scroll_object_end - 1  /* i */
         01:D1F3  AD 10 25   			lda	__scroll_object_end - 1
 3113                        		__ult_b.umq	_level_object_number
         01:D1F6  CD 21 23   			cmp	_level_object_number		; Subtract memory from A.
         01:D1F9  6A         			ror	a		; CC if A < memory.
         01:D1FA  49 80      			eor	#$80
         01:D1FC  2A         			rol	a
 3114                        		__btrue		.LL16
         01:D1FD  B0 08      			bcs	.LL16
 3115                        		__bra		.LL17
         01:D1FF  4C 51 D3   			bra	.LL17
 3116    01:D202             	.LL15:
 3117                        		__inc.umq	__scroll_object_end - 1  /* i */
         01:D202  EE 10 25   			inc	__scroll_object_end - 1
 3118                        		__bra		.LL14
         01:D205  80 EC      			bra	.LL14
 3119    01:D207             	.LL16:
 3120                        	
 3121                        		.dbg	line,	"include\routines_LEVELS.c", 86; {
 3122                        	
 3123                        		.dbg	line,	"include\routines_LEVELS.c", 87; if(list_object_state[i] != STATE_INACTIVE)
 3124                        		__ldx.umq	__scroll_object_end - 1  /* i */
         01:D207  AE 10 25   			ldx	__scroll_object_end - 1
 3125                        		__ld.uaxq	_list_object_state
         01:D20A  BD 3C 23   			lda	_list_object_state, x
 3126                        		__neq_b.uiq	1
         01:D20D  38         			sec
         01:D20E  49 01      			eor	#1
         01:D210  D0 01      			bne	!+
         01:D212  18         			clc
         01:D213             	!:
 3127                        		__bfalse	.LL18
         01:D213  90 ED      			bcc	.LL18
 3128                        	
 3129                        		.dbg	line,	"include\routines_LEVELS.c", 88; {
 3130                        	
 3131                        		.dbg	line,	"include\routines_LEVELS.c", 89; char scroll_allowed = FALSE;
 3132                        		__st.umiq	0, __scroll_object_end - 2  /* scroll_allowed */
         01:D215  9C 0F 25   			stz	__scroll_object_end - 2
 3133                        	
 3134                        		.dbg	line,	"include\routines_LEVELS.c", 90; 
 3135                        	
 3136                        		.dbg	line,	"include\routines_LEVELS.c", 91; // IF OBJECT X POSITION IS INFERIOR TO SCREEN RIGHT SIDE //
 3137                        	
 3138                        		.dbg	line,	"include\routines_LEVELS.c", 92; if(list_object_x_pos_ref[i] < sgx_map_pxl_x + 256)
 3139                        		__ld.wm		_sgx_map_pxl_x
         01:D218  AD 55 25   			lda.l	_sgx_map_pxl_x
         01:D21B  AC 56 25   			ldy.h	_sgx_map_pxl_x
 3140                        		__add.wi	256
         01:D21E  18         			clc
         01:D21F  69 00      			adc.l	#256
         01:D221  42         			say
         01:D222  69 01      			adc.h	#256
         01:D224  42         			say
 3141                        		__ld2x.um	__scroll_object_end - 1  /* i */
         01:D225  AA         			tax
         01:D226  AD 10 25   			lda	__scroll_object_end - 1
         01:D229  0A         			asl	a
         01:D22A  22         			sax
 3142                        		__ugt_w.wax	_list_object_x_pos_ref
         01:D22B  18         			clc			; Subtract memory+1 from Y:A.
         01:D22C  FD 21 24   			sbc.l	_list_object_x_pos_ref, x
         01:D22F  98         			tya
         01:D230  FD 22 24   			sbc.h	_list_object_x_pos_ref, x		; CS if Y:A > memory.
 3143                        		__bfalse	.LL19
         01:D233  B0 03 4C B8			bcc	.LL19
         01:D237  D2          
 3144                        	
 3145                        		.dbg	line,	"include\routines_LEVELS.c", 93; {
 3146                        	
 3147                        		.dbg	line,	"include\routines_LEVELS.c", 94; // IF OBJECT X POSITION IS SUPERIOR TO SCREEN LEFT SIDE PLUS 16 PX //
 3148                        	
 3149                        		.dbg	line,	"include\routines_LEVELS.c", 95; if(list_object_x_pos_ref[i] - sgx_map_pxl_x + 16 > 0)
 3150                        		__ld2x.umq	__scroll_object_end - 1  /* i */
         01:D238  AD 10 25   			lda	__scroll_object_end - 1
         01:D23B  0A         			asl	a
         01:D23C  AA         			tax
 3151                        		__ld.wax	_list_object_x_pos_ref
         01:D23D  BD 21 24   			lda.l	_list_object_x_pos_ref, x
         01:D240  BC 22 24   			ldy.h	_list_object_x_pos_ref, x
 3152                        		__sub.wm	_sgx_map_pxl_x
         01:D243  38         			sec
         01:D244  ED 55 25   			sbc.l	_sgx_map_pxl_x
         01:D247  42         			say
         01:D248  ED 56 25   			sbc.h	_sgx_map_pxl_x
         01:D24B  42         			say
 3153                        		__add.wi	16
         01:D24C  18         			clc
         01:D24D  69 10      			adc.l	#16
         01:D24F  90 01      			bcc	!+
         01:D251  C8         			iny
         01:D252             	!:
 3154                        		__sgt_w.wi	0
         01:D252  18         			clc			; Subtract integer+1 from Y:A.
         01:D253  E9 00      			sbc.l	#0
         01:D255  98         			tya
         01:D256  E9 00      			sbc.h	#0
         01:D258  50 02      			bvc	!+
         01:D25A  49 80      			eor	#$80		; +ve if Y:A > integer (signed).
         01:D25C  49 80      	!:		eor	#$80
         01:D25E  0A         			asl	a
 3155                        		__bfalse	.LL20
         01:D25F  90 57      			bcc	.LL20
 3156                        	
 3157                        		.dbg	line,	"include\routines_LEVELS.c", 96; {
 3158                        	
 3159                        		.dbg	line,	"include\routines_LEVELS.c", 97; // IF OBJECT Y POSITION IS INFERIOR TO SCREEN BOTTOM //
 3160                        	
 3161                        		.dbg	line,	"include\routines_LEVELS.c", 98; if(list_object_y_pos_ref[i] < sgx_map_pxl_y + 224)
 3162                        		__ld.wm		_sgx_map_pxl_y
         01:D261  AD 57 25   			lda.l	_sgx_map_pxl_y
         01:D264  AC 58 25   			ldy.h	_sgx_map_pxl_y
 3163                        		__add.wi	224
         01:D267  18         			clc
         01:D268  69 E0      			adc.l	#224
         01:D26A  90 01      			bcc	!+
         01:D26C  C8         			iny
         01:D26D             	!:
 3164                        		__ld2x.um	__scroll_object_end - 1  /* i */
         01:D26D  AA         			tax
         01:D26E  AD 10 25   			lda	__scroll_object_end - 1
         01:D271  0A         			asl	a
         01:D272  22         			sax
 3165                        		__ugt_w.wax	_list_object_y_pos_ref
         01:D273  18         			clc			; Subtract memory+1 from Y:A.
         01:D274  FD 53 24   			sbc.l	_list_object_y_pos_ref, x
         01:D277  98         			tya
         01:D278  FD 54 24   			sbc.h	_list_object_y_pos_ref, x		; CS if Y:A > memory.
 3166                        		__bfalse	.LL21
         01:D27B  90 3B      			bcc	.LL21
 3167                        	
 3168                        		.dbg	line,	"include\routines_LEVELS.c", 99; {
 3169                        	
 3170                        		.dbg	line,	"include\routines_LEVELS.c", 100; // IF OBJECT Y POSITION IS SUPERIOR TO SCREEN TOP PLUS 16 PX //
 3171                        	
 3172                        		.dbg	line,	"include\routines_LEVELS.c", 101; if(list_object_y_pos_ref[i] - sgx_map_pxl_y + 16 > 0)
 3173                        		__ld2x.umq	__scroll_object_end - 1  /* i */
         01:D27D  AD 10 25   			lda	__scroll_object_end - 1
         01:D280  0A         			asl	a
         01:D281  AA         			tax
 3174                        		__ld.wax	_list_object_y_pos_ref
         01:D282  BD 53 24   			lda.l	_list_object_y_pos_ref, x
         01:D285  BC 54 24   			ldy.h	_list_object_y_pos_ref, x
 3175                        		__sub.wm	_sgx_map_pxl_y
         01:D288  38         			sec
         01:D289  ED 57 25   			sbc.l	_sgx_map_pxl_y
         01:D28C  42         			say
         01:D28D  ED 58 25   			sbc.h	_sgx_map_pxl_y
         01:D290  42         			say
 3176                        		__add.wi	16
         01:D291  18         			clc
         01:D292  69 10      			adc.l	#16
         01:D294  90 01      			bcc	!+
         01:D296  C8         			iny
         01:D297             	!:
 3177                        		__sgt_w.wi	0
         01:D297  18         			clc			; Subtract integer+1 from Y:A.
         01:D298  E9 00      			sbc.l	#0
         01:D29A  98         			tya
         01:D29B  E9 00      			sbc.h	#0
         01:D29D  50 02      			bvc	!+
         01:D29F  49 80      			eor	#$80		; +ve if Y:A > integer (signed).
         01:D2A1  49 80      	!:		eor	#$80
         01:D2A3  0A         			asl	a
 3178                        		__bfalse	.LL22
         01:D2A4  90 12      			bcc	.LL22
 3179                        	
 3180                        		.dbg	line,	"include\routines_LEVELS.c", 102; {
 3181                        	
 3182                        		.dbg	line,	"include\routines_LEVELS.c", 103; // WE STORE THE OBJECT ID //
 3183                        	
 3184                        		.dbg	line,	"include\routines_LEVELS.c", 104; //put_number(i,2,0,2+onscreen_object_number);
 3185                        	
 3186                        		.dbg	line,	"include\routines_LEVELS.c", 105; list_onscreen_object[onscreen_object_number] = i;
 3187                        		__ldx.umq	_onscreen_object_number
         01:D2A6  AE 22 23   			ldx	_onscreen_object_number
 3188                        		__ld.um		__scroll_object_end - 1  /* i */
         01:D2A9  AD 10 25   			lda	__scroll_object_end - 1
         01:D2AC  C2         			cly
 3189                        		__st.uaxq	_list_onscreen_object
         01:D2AD  9D 87 23   			sta	_list_onscreen_object, x
 3190                        	
 3191                        		.dbg	line,	"include\routines_LEVELS.c", 106; onscreen_object_number += 1;
 3192                        		__add_st.umiq	1, _onscreen_object_number
         01:D2B0  EE 22 23   			inc	_onscreen_object_number
 3193                        	
 3194                        		.dbg	line,	"include\routines_LEVELS.c", 107; 
 3195                        	
 3196                        		.dbg	line,	"include\routines_LEVELS.c", 108; //list_object_visibility[i] = ON_SCREEN;
 3197                        	
 3198                        		.dbg	line,	"include\routines_LEVELS.c", 109; scroll_allowed = TRUE;
 3199                        		__st.umiq	1, __scroll_object_end - 2  /* scroll_allowed */
         01:D2B3  A9 01      			lda.l	#1
         01:D2B5  8D 0F 25   			sta	__scroll_object_end - 2
 3200                        	
 3201                        		.dbg	line,	"include\routines_LEVELS.c", 110; }
 3202                        	
 3203                        		.dbg	line,	"include\routines_LEVELS.c", 111; }
 3204    01:D2B8             	.LL22:
 3205                        	
 3206                        		.dbg	line,	"include\routines_LEVELS.c", 112; }
 3207    01:D2B8             	.LL21:
 3208                        	
 3209                        		.dbg	line,	"include\routines_LEVELS.c", 113; }
 3210    01:D2B8             	.LL20:
 3211                        	
 3212                        		.dbg	line,	"include\routines_LEVELS.c", 115; // IF OBJECTS IS WITHIN THE SCREEN LIMITS //
 3213                        	
 3214                        		.dbg	line,	"include\routines_LEVELS.c", 116; if(scroll_allowed == TRUE)
 3215    01:D2B8             	.LL19:
 3216                        		__ld.umq	__scroll_object_end - 2  /* scroll_allowed */
         01:D2B8  AD 0F 25   			lda	__scroll_object_end - 2
 3217                        		__equ_b.uiq	1
         01:D2BB  C9 01      			cmp	#1
         01:D2BD  F0 01      			beq	!+
         01:D2BF  18         			clc
         01:D2C0             	!:
 3218                        		__bfalse	.LL23
         01:D2C0  90 44      			bcc	.LL23
 3219                        	
 3220                        		.dbg	line,	"include\routines_LEVELS.c", 117; {
 3221                        	
 3222                        		.dbg	line,	"include\routines_LEVELS.c", 118; list_object_x_pos[i] = list_object_x_pos_ref[i] - sgx_map_pxl_x;
 3223                        		__ld2x.umq	__scroll_object_end - 1  /* i */
         01:D2C2  AD 10 25   			lda	__scroll_object_end - 1
         01:D2C5  0A         			asl	a
         01:D2C6  AA         			tax
 3224                        		__ld.wax	_list_object_x_pos_ref
         01:D2C7  BD 21 24   			lda.l	_list_object_x_pos_ref, x
         01:D2CA  BC 22 24   			ldy.h	_list_object_x_pos_ref, x
 3225                        		__sub.wm	_sgx_map_pxl_x
         01:D2CD  38         			sec
         01:D2CE  ED 55 25   			sbc.l	_sgx_map_pxl_x
         01:D2D1  42         			say
         01:D2D2  ED 56 25   			sbc.h	_sgx_map_pxl_x
         01:D2D5  42         			say
 3226                        		__ld2x.um	__scroll_object_end - 1  /* i */
         01:D2D6  AA         			tax
         01:D2D7  AD 10 25   			lda	__scroll_object_end - 1
         01:D2DA  0A         			asl	a
         01:D2DB  22         			sax
 3227                        		__st.waxq	_list_object_x_pos
         01:D2DC  9D BD 23   			sta.l	_list_object_x_pos, x
         01:D2DF  98         			tya
         01:D2E0  9D BE 23   			sta.h	_list_object_x_pos, x
 3228                        	
 3229                        		.dbg	line,	"include\routines_LEVELS.c", 119; list_object_y_pos[i] = list_object_y_pos_ref[i] - sgx_map_pxl_y;
 3230                        		__ld2x.umq	__scroll_object_end - 1  /* i */
         01:D2E3  AD 10 25   			lda	__scroll_object_end - 1
         01:D2E6  0A         			asl	a
         01:D2E7  AA         			tax
 3231                        		__ld.wax	_list_object_y_pos_ref
         01:D2E8  BD 53 24   			lda.l	_list_object_y_pos_ref, x
         01:D2EB  BC 54 24   			ldy.h	_list_object_y_pos_ref, x
 3232                        		__sub.wm	_sgx_map_pxl_y
         01:D2EE  38         			sec
         01:D2EF  ED 57 25   			sbc.l	_sgx_map_pxl_y
         01:D2F2  42         			say
         01:D2F3  ED 58 25   			sbc.h	_sgx_map_pxl_y
         01:D2F6  42         			say
 3233                        		__ld2x.um	__scroll_object_end - 1  /* i */
         01:D2F7  AA         			tax
         01:D2F8  AD 10 25   			lda	__scroll_object_end - 1
         01:D2FB  0A         			asl	a
         01:D2FC  22         			sax
 3234                        		__st.waxq	_list_object_y_pos
         01:D2FD  9D EF 23   			sta.l	_list_object_y_pos, x
         01:D300  98         			tya
         01:D301  9D F0 23   			sta.h	_list_object_y_pos, x
 3235                        	
 3236                        		.dbg	line,	"include\routines_LEVELS.c", 120; }
 3237                        	
 3238                        		.dbg	line,	"include\routines_LEVELS.c", 122; else
 3239                        		__bra		.LL24
         01:D304  80 1E      			bra	.LL24
 3240    01:D306             	.LL23:
 3241                        	
 3242                        		.dbg	line,	"include\routines_LEVELS.c", 123; {
 3243                        	
 3244                        		.dbg	line,	"include\routines_LEVELS.c", 124; list_object_x_pos[i] = -16;
 3245                        		__ld2x.umq	__scroll_object_end - 1  /* i */
         01:D306  AD 10 25   			lda	__scroll_object_end - 1
         01:D309  0A         			asl	a
         01:D30A  AA         			tax
 3246                        		__st.waxiq	-16, _list_object_x_pos
         01:D30B  A9 F0      			lda.l	#-16
         01:D30D  9D BD 23   			sta.l	_list_object_x_pos, x
         01:D310  A9 FF      			lda.h	#-16
         01:D312  9D BE 23   			sta.h	_list_object_x_pos, x
 3247                        	
 3248                        		.dbg	line,	"include\routines_LEVELS.c", 125; list_object_y_pos[i] = -16;
 3249                        		__ld2x.umq	__scroll_object_end - 1  /* i */
         01:D315  AD 10 25   			lda	__scroll_object_end - 1
         01:D318  0A         			asl	a
         01:D319  AA         			tax
 3250                        		__st.waxiq	-16, _list_object_y_pos
         01:D31A  A9 F0      			lda.l	#-16
         01:D31C  9D EF 23   			sta.l	_list_object_y_pos, x
         01:D31F  A9 FF      			lda.h	#-16
         01:D321  9D F0 23   			sta.h	_list_object_y_pos, x
 3251                        	
 3252                        		.dbg	line,	"include\routines_LEVELS.c", 126; //list_object_visibility[i] = OFF_SCREEN;
 3253                        	
 3254                        		.dbg	line,	"include\routines_LEVELS.c", 127; }
 3255    01:D324             	.LL24:
 3256                        	
 3257                        		.dbg	line,	"include\routines_LEVELS.c", 129; spr_set(i + object_start_index);
 3258                        		__ld.um		__scroll_object_end - 1  /* i */
         01:D324  AD 10 25   			lda	__scroll_object_end - 1
         01:D327  C2         			cly
 3259                        		__add.um	_object_start_index
         01:D328  18         			clc
         01:D329  6D 20 23   			adc	_object_start_index
         01:D32C  90 01      			bcc	!+
         01:D32E  C8         			iny
         01:D32F             	!:
 3260                        		__call		_spr_set.1
         01:D32F  20 DD E7   			call	_spr_set.1
 3261                        	
 3262                        		.dbg	line,	"include\routines_LEVELS.c", 131; spr_x(list_object_x_pos[i]);
 3263                        		__ld2x.umq	__scroll_object_end - 1  /* i */
         01:D332  AD 10 25   			lda	__scroll_object_end - 1
         01:D335  0A         			asl	a
         01:D336  AA         			tax
 3264                        		__ld.wax	_list_object_x_pos
         01:D337  BD BD 23   			lda.l	_list_object_x_pos, x
         01:D33A  BC BE 23   			ldy.h	_list_object_x_pos, x
 3265                        		__call		_spr_x.1
         01:D33D  20 0A E8   			call	_spr_x.1
 3266                        	
 3267                        		.dbg	line,	"include\routines_LEVELS.c", 132; spr_y(list_object_y_pos[i]);
 3268                        		__ld2x.umq	__scroll_object_end - 1  /* i */
         01:D340  AD 10 25   			lda	__scroll_object_end - 1
         01:D343  0A         			asl	a
         01:D344  AA         			tax
 3269                        		__ld.wax	_list_object_y_pos
         01:D345  BD EF 23   			lda.l	_list_object_y_pos, x
         01:D348  BC F0 23   			ldy.h	_list_object_y_pos, x
 3270                        		__call		_spr_y.1
         01:D34B  20 19 E8   			call	_spr_y.1
 3271                        	
 3272                        		.dbg	line,	"include\routines_LEVELS.c", 133; }
 3273                        	
 3274                        		.dbg	line,	"include\routines_LEVELS.c", 134; }
 3275    01:D34E             	.LL18	.alias		.LL15
 3276                        		__bra		.LL15
         01:D34E  4C 02 D2   			bra	.LL15
 3277    01:D351             	.LL17:
 3278                        	
 3279                        		.dbg	line,	"include\routines_LEVELS.c", 135; }
 3280    01:D351             	.LL13:
 3281                        		__return	0
         01:D351  4C EF FF   			jmp	leave_proc
 3282                        		.dbg	clear
 3283                        		.endp
 3284                        		.pceas
 3285                        	
 3286                        		.dbg	line,	"include\routines_LEVELS.c", 138; void scroll_chest()
 3287                        		.dbg	line,	"include\routines_LEVELS.c", 139; {
 3288                        	;***********************
 3289                        	;***********************
 3290                        	
 3291                        		.hucc
 3292    01:D354             		.proc		_scroll_chest
 3293                        		__enter		_scroll_chest
 3294                        	
 3295                        		.dbg	line,	"include\routines_LEVELS.c", 140; char i;
 3296                        	
 3297                        		.dbg	line,	"include\routines_LEVELS.c", 141; onscreen_chest_number = 0;
 3298                        		__st.umiq	0, _onscreen_chest_number
         01:D354  9C 91 23   			stz	_onscreen_chest_number
 3299                        	
 3300                        		.dbg	line,	"include\routines_LEVELS.c", 143; for(i=0 ; i<level_chest_number ; i++)
 3301                        		__st.umiq	0, __scroll_chest_end - 1  /* i */
         01:D357  9C 10 25   			stz	__scroll_chest_end - 1
 3302    01:D35A             	.LL26:
 3303                        		__ld.umq	__scroll_chest_end - 1  /* i */
         01:D35A  AD 10 25   			lda	__scroll_chest_end - 1
 3304                        		__ult_b.umq	_level_chest_number
         01:D35D  CD 90 23   			cmp	_level_chest_number		; Subtract memory from A.
         01:D360  6A         			ror	a		; CC if A < memory.
         01:D361  49 80      			eor	#$80
         01:D363  2A         			rol	a
 3305                        		__btrue		.LL28
         01:D364  B0 08      			bcs	.LL28
 3306                        		__bra		.LL29
         01:D366  4C B8 D4   			bra	.LL29
 3307    01:D369             	.LL27:
 3308                        		__inc.umq	__scroll_chest_end - 1  /* i */
         01:D369  EE 10 25   			inc	__scroll_chest_end - 1
 3309                        		__bra		.LL26
         01:D36C  80 EC      			bra	.LL26
 3310    01:D36E             	.LL28:
 3311                        	
 3312                        		.dbg	line,	"include\routines_LEVELS.c", 144; {
 3313                        	
 3314                        		.dbg	line,	"include\routines_LEVELS.c", 145; if(list_chest_state[i] != STATE_INACTIVE)
 3315                        		__ldx.umq	__scroll_chest_end - 1  /* i */
         01:D36E  AE 10 25   			ldx	__scroll_chest_end - 1
 3316                        		__ld.uaxq	_list_chest_state
         01:D371  BD 92 23   			lda	_list_chest_state, x
 3317                        		__neq_b.uiq	1
         01:D374  38         			sec
         01:D375  49 01      			eor	#1
         01:D377  D0 01      			bne	!+
         01:D379  18         			clc
         01:D37A             	!:
 3318                        		__bfalse	.LL30
         01:D37A  90 ED      			bcc	.LL30
 3319                        	
 3320                        		.dbg	line,	"include\routines_LEVELS.c", 146; {
 3321                        	
 3322                        		.dbg	line,	"include\routines_LEVELS.c", 147; char scroll_allowed = FALSE;
 3323                        		__st.umiq	0, __scroll_chest_end - 2  /* scroll_allowed */
         01:D37C  9C 0F 25   			stz	__scroll_chest_end - 2
 3324                        	
 3325                        		.dbg	line,	"include\routines_LEVELS.c", 148; 
 3326                        	
 3327                        		.dbg	line,	"include\routines_LEVELS.c", 149; // IF CHEST X POSITION IS INFERIOR TO SCREEN RIGHT SIDE //
 3328                        	
 3329                        		.dbg	line,	"include\routines_LEVELS.c", 150; if(list_chest_x_pos_ref[i] < sgx_map_pxl_x + 256)
 3330                        		__ld.wm		_sgx_map_pxl_x
         01:D37F  AD 55 25   			lda.l	_sgx_map_pxl_x
         01:D382  AC 56 25   			ldy.h	_sgx_map_pxl_x
 3331                        		__add.wi	256
         01:D385  18         			clc
         01:D386  69 00      			adc.l	#256
         01:D388  42         			say
         01:D389  69 01      			adc.h	#256
         01:D38B  42         			say
 3332                        		__ld2x.um	__scroll_chest_end - 1  /* i */
         01:D38C  AA         			tax
         01:D38D  AD 10 25   			lda	__scroll_chest_end - 1
         01:D390  0A         			asl	a
         01:D391  22         			sax
 3333                        		__ugt_w.wax	_list_chest_x_pos_ref
         01:D392  18         			clc			; Subtract memory+1 from Y:A.
         01:D393  FD A5 24   			sbc.l	_list_chest_x_pos_ref, x
         01:D396  98         			tya
         01:D397  FD A6 24   			sbc.h	_list_chest_x_pos_ref, x		; CS if Y:A > memory.
 3334                        		__bfalse	.LL31
         01:D39A  B0 03 4C 1F			bcc	.LL31
         01:D39E  D4          
 3335                        	
 3336                        		.dbg	line,	"include\routines_LEVELS.c", 151; {
 3337                        	
 3338                        		.dbg	line,	"include\routines_LEVELS.c", 152; // IF CHEST X POSITION IS SUPERIOR TO SCREEN LEFT SIDE PLUS 32 PX //
 3339                        	
 3340                        		.dbg	line,	"include\routines_LEVELS.c", 153; if(list_chest_x_pos_ref[i] - sgx_map_pxl_x + 32 > 0)
 3341                        		__ld2x.umq	__scroll_chest_end - 1  /* i */
         01:D39F  AD 10 25   			lda	__scroll_chest_end - 1
         01:D3A2  0A         			asl	a
         01:D3A3  AA         			tax
 3342                        		__ld.wax	_list_chest_x_pos_ref
         01:D3A4  BD A5 24   			lda.l	_list_chest_x_pos_ref, x
         01:D3A7  BC A6 24   			ldy.h	_list_chest_x_pos_ref, x
 3343                        		__sub.wm	_sgx_map_pxl_x
         01:D3AA  38         			sec
         01:D3AB  ED 55 25   			sbc.l	_sgx_map_pxl_x
         01:D3AE  42         			say
         01:D3AF  ED 56 25   			sbc.h	_sgx_map_pxl_x
         01:D3B2  42         			say
 3344                        		__add.wi	32
         01:D3B3  18         			clc
         01:D3B4  69 20      			adc.l	#32
         01:D3B6  90 01      			bcc	!+
         01:D3B8  C8         			iny
         01:D3B9             	!:
 3345                        		__sgt_w.wi	0
         01:D3B9  18         			clc			; Subtract integer+1 from Y:A.
         01:D3BA  E9 00      			sbc.l	#0
         01:D3BC  98         			tya
         01:D3BD  E9 00      			sbc.h	#0
         01:D3BF  50 02      			bvc	!+
         01:D3C1  49 80      			eor	#$80		; +ve if Y:A > integer (signed).
         01:D3C3  49 80      	!:		eor	#$80
         01:D3C5  0A         			asl	a
 3346                        		__bfalse	.LL32
         01:D3C6  90 57      			bcc	.LL32
 3347                        	
 3348                        		.dbg	line,	"include\routines_LEVELS.c", 154; {
 3349                        	
 3350                        		.dbg	line,	"include\routines_LEVELS.c", 155; // IF CHEST Y POSITION IS INFERIOR TO SCREEN BOTTOM //
 3351                        	
 3352                        		.dbg	line,	"include\routines_LEVELS.c", 156; if(list_chest_y_pos_ref[i] < sgx_map_pxl_y + 224)
 3353                        		__ld.wm		_sgx_map_pxl_y
         01:D3C8  AD 57 25   			lda.l	_sgx_map_pxl_y
         01:D3CB  AC 58 25   			ldy.h	_sgx_map_pxl_y
 3354                        		__add.wi	224
         01:D3CE  18         			clc
         01:D3CF  69 E0      			adc.l	#224
         01:D3D1  90 01      			bcc	!+
         01:D3D3  C8         			iny
         01:D3D4             	!:
 3355                        		__ld2x.um	__scroll_chest_end - 1  /* i */
         01:D3D4  AA         			tax
         01:D3D5  AD 10 25   			lda	__scroll_chest_end - 1
         01:D3D8  0A         			asl	a
         01:D3D9  22         			sax
 3356                        		__ugt_w.wax	_list_chest_y_pos_ref
         01:D3DA  18         			clc			; Subtract memory+1 from Y:A.
         01:D3DB  FD B5 24   			sbc.l	_list_chest_y_pos_ref, x
         01:D3DE  98         			tya
         01:D3DF  FD B6 24   			sbc.h	_list_chest_y_pos_ref, x		; CS if Y:A > memory.
 3357                        		__bfalse	.LL33
         01:D3E2  90 3B      			bcc	.LL33
 3358                        	
 3359                        		.dbg	line,	"include\routines_LEVELS.c", 157; {
 3360                        	
 3361                        		.dbg	line,	"include\routines_LEVELS.c", 158; // IF CHEST Y POSITION IS SUPERIOR TO SCREEN TOP PLUS 32 PX //
 3362                        	
 3363                        		.dbg	line,	"include\routines_LEVELS.c", 159; if(list_chest_y_pos_ref[i] - sgx_map_pxl_y + 32 > 0)
 3364                        		__ld2x.umq	__scroll_chest_end - 1  /* i */
         01:D3E4  AD 10 25   			lda	__scroll_chest_end - 1
         01:D3E7  0A         			asl	a
         01:D3E8  AA         			tax
 3365                        		__ld.wax	_list_chest_y_pos_ref
         01:D3E9  BD B5 24   			lda.l	_list_chest_y_pos_ref, x
         01:D3EC  BC B6 24   			ldy.h	_list_chest_y_pos_ref, x
 3366                        		__sub.wm	_sgx_map_pxl_y
         01:D3EF  38         			sec
         01:D3F0  ED 57 25   			sbc.l	_sgx_map_pxl_y
         01:D3F3  42         			say
         01:D3F4  ED 58 25   			sbc.h	_sgx_map_pxl_y
         01:D3F7  42         			say
 3367                        		__add.wi	32
         01:D3F8  18         			clc
         01:D3F9  69 20      			adc.l	#32
         01:D3FB  90 01      			bcc	!+
         01:D3FD  C8         			iny
         01:D3FE             	!:
 3368                        		__sgt_w.wi	0
         01:D3FE  18         			clc			; Subtract integer+1 from Y:A.
         01:D3FF  E9 00      			sbc.l	#0
         01:D401  98         			tya
         01:D402  E9 00      			sbc.h	#0
         01:D404  50 02      			bvc	!+
         01:D406  49 80      			eor	#$80		; +ve if Y:A > integer (signed).
         01:D408  49 80      	!:		eor	#$80
         01:D40A  0A         			asl	a
 3369                        		__bfalse	.LL34
         01:D40B  90 12      			bcc	.LL34
 3370                        	
 3371                        		.dbg	line,	"include\routines_LEVELS.c", 160; {
 3372                        	
 3373                        		.dbg	line,	"include\routines_LEVELS.c", 161; // WE STORE THE CHEST ID //
 3374                        	
 3375                        		.dbg	line,	"include\routines_LEVELS.c", 162; list_onscreen_chest[onscreen_chest_number] = i;
 3376                        		__ldx.umq	_onscreen_chest_number
         01:D40D  AE 91 23   			ldx	_onscreen_chest_number
 3377                        		__ld.um		__scroll_chest_end - 1  /* i */
         01:D410  AD 10 25   			lda	__scroll_chest_end - 1
         01:D413  C2         			cly
 3378                        		__st.uaxq	_list_onscreen_chest
         01:D414  9D 9A 23   			sta	_list_onscreen_chest, x
 3379                        	
 3380                        		.dbg	line,	"include\routines_LEVELS.c", 163; onscreen_chest_number += 1;
 3381                        		__add_st.umiq	1, _onscreen_chest_number
         01:D417  EE 91 23   			inc	_onscreen_chest_number
 3382                        	
 3383                        		.dbg	line,	"include\routines_LEVELS.c", 164; 
 3384                        	
 3385                        		.dbg	line,	"include\routines_LEVELS.c", 165; scroll_allowed = TRUE;
 3386                        		__st.umiq	1, __scroll_chest_end - 2  /* scroll_allowed */
         01:D41A  A9 01      			lda.l	#1
         01:D41C  8D 0F 25   			sta	__scroll_chest_end - 2
 3387                        	
 3388                        		.dbg	line,	"include\routines_LEVELS.c", 166; }
 3389                        	
 3390                        		.dbg	line,	"include\routines_LEVELS.c", 167; }
 3391    01:D41F             	.LL34:
 3392                        	
 3393                        		.dbg	line,	"include\routines_LEVELS.c", 168; }
 3394    01:D41F             	.LL33:
 3395                        	
 3396                        		.dbg	line,	"include\routines_LEVELS.c", 169; }
 3397    01:D41F             	.LL32:
 3398                        	
 3399                        		.dbg	line,	"include\routines_LEVELS.c", 171; // IF CHEST IS WITHIN THE SCREEN LIMITS //
 3400                        	
 3401                        		.dbg	line,	"include\routines_LEVELS.c", 172; if(scroll_allowed == TRUE)
 3402    01:D41F             	.LL31:
 3403                        		__ld.umq	__scroll_chest_end - 2  /* scroll_allowed */
         01:D41F  AD 0F 25   			lda	__scroll_chest_end - 2
 3404                        		__equ_b.uiq	1
         01:D422  C9 01      			cmp	#1
         01:D424  F0 01      			beq	!+
         01:D426  18         			clc
         01:D427             	!:
 3405                        		__bfalse	.LL35
         01:D427  90 44      			bcc	.LL35
 3406                        	
 3407                        		.dbg	line,	"include\routines_LEVELS.c", 173; {
 3408                        	
 3409                        		.dbg	line,	"include\routines_LEVELS.c", 174; list_chest_x_pos[i] = list_chest_x_pos_ref[i] - sgx_map_pxl_x;
 3410                        		__ld2x.umq	__scroll_chest_end - 1  /* i */
         01:D429  AD 10 25   			lda	__scroll_chest_end - 1
         01:D42C  0A         			asl	a
         01:D42D  AA         			tax
 3411                        		__ld.wax	_list_chest_x_pos_ref
         01:D42E  BD A5 24   			lda.l	_list_chest_x_pos_ref, x
         01:D431  BC A6 24   			ldy.h	_list_chest_x_pos_ref, x
 3412                        		__sub.wm	_sgx_map_pxl_x
         01:D434  38         			sec
         01:D435  ED 55 25   			sbc.l	_sgx_map_pxl_x
         01:D438  42         			say
         01:D439  ED 56 25   			sbc.h	_sgx_map_pxl_x
         01:D43C  42         			say
 3413                        		__ld2x.um	__scroll_chest_end - 1  /* i */
         01:D43D  AA         			tax
         01:D43E  AD 10 25   			lda	__scroll_chest_end - 1
         01:D441  0A         			asl	a
         01:D442  22         			sax
 3414                        		__st.waxq	_list_chest_x_pos
         01:D443  9D 85 24   			sta.l	_list_chest_x_pos, x
         01:D446  98         			tya
         01:D447  9D 86 24   			sta.h	_list_chest_x_pos, x
 3415                        	
 3416                        		.dbg	line,	"include\routines_LEVELS.c", 175; list_chest_y_pos[i] = list_chest_y_pos_ref[i] - sgx_map_pxl_y;
 3417                        		__ld2x.umq	__scroll_chest_end - 1  /* i */
         01:D44A  AD 10 25   			lda	__scroll_chest_end - 1
         01:D44D  0A         			asl	a
         01:D44E  AA         			tax
 3418                        		__ld.wax	_list_chest_y_pos_ref
         01:D44F  BD B5 24   			lda.l	_list_chest_y_pos_ref, x
         01:D452  BC B6 24   			ldy.h	_list_chest_y_pos_ref, x
 3419                        		__sub.wm	_sgx_map_pxl_y
         01:D455  38         			sec
         01:D456  ED 57 25   			sbc.l	_sgx_map_pxl_y
         01:D459  42         			say
         01:D45A  ED 58 25   			sbc.h	_sgx_map_pxl_y
         01:D45D  42         			say
 3420                        		__ld2x.um	__scroll_chest_end - 1  /* i */
         01:D45E  AA         			tax
         01:D45F  AD 10 25   			lda	__scroll_chest_end - 1
         01:D462  0A         			asl	a
         01:D463  22         			sax
 3421                        		__st.waxq	_list_chest_y_pos
         01:D464  9D 95 24   			sta.l	_list_chest_y_pos, x
         01:D467  98         			tya
         01:D468  9D 96 24   			sta.h	_list_chest_y_pos, x
 3422                        	
 3423                        		.dbg	line,	"include\routines_LEVELS.c", 176; }
 3424                        	
 3425                        		.dbg	line,	"include\routines_LEVELS.c", 178; else
 3426                        		__bra		.LL36
         01:D46B  80 1E      			bra	.LL36
 3427    01:D46D             	.LL35:
 3428                        	
 3429                        		.dbg	line,	"include\routines_LEVELS.c", 179; {
 3430                        	
 3431                        		.dbg	line,	"include\routines_LEVELS.c", 180; list_chest_x_pos[i] = -32;
 3432                        		__ld2x.umq	__scroll_chest_end - 1  /* i */
         01:D46D  AD 10 25   			lda	__scroll_chest_end - 1
         01:D470  0A         			asl	a
         01:D471  AA         			tax
 3433                        		__st.waxiq	-32, _list_chest_x_pos
         01:D472  A9 E0      			lda.l	#-32
         01:D474  9D 85 24   			sta.l	_list_chest_x_pos, x
         01:D477  A9 FF      			lda.h	#-32
         01:D479  9D 86 24   			sta.h	_list_chest_x_pos, x
 3434                        	
 3435                        		.dbg	line,	"include\routines_LEVELS.c", 181; list_chest_y_pos[i] = -32;
 3436                        		__ld2x.umq	__scroll_chest_end - 1  /* i */
         01:D47C  AD 10 25   			lda	__scroll_chest_end - 1
         01:D47F  0A         			asl	a
         01:D480  AA         			tax
 3437                        		__st.waxiq	-32, _list_chest_y_pos
         01:D481  A9 E0      			lda.l	#-32
         01:D483  9D 95 24   			sta.l	_list_chest_y_pos, x
         01:D486  A9 FF      			lda.h	#-32
         01:D488  9D 96 24   			sta.h	_list_chest_y_pos, x
 3438                        	
 3439                        		.dbg	line,	"include\routines_LEVELS.c", 182; }
 3440    01:D48B             	.LL36:
 3441                        	
 3442                        		.dbg	line,	"include\routines_LEVELS.c", 184; spr_set(i + chest_start_index);
 3443                        		__ld.um		__scroll_chest_end - 1  /* i */
         01:D48B  AD 10 25   			lda	__scroll_chest_end - 1
         01:D48E  C2         			cly
 3444                        		__add.um	_chest_start_index
         01:D48F  18         			clc
         01:D490  6D 8F 23   			adc	_chest_start_index
         01:D493  90 01      			bcc	!+
         01:D495  C8         			iny
         01:D496             	!:
 3445                        		__call		_spr_set.1
         01:D496  20 DD E7   			call	_spr_set.1
 3446                        	
 3447                        		.dbg	line,	"include\routines_LEVELS.c", 186; spr_x(list_chest_x_pos[i]);
 3448                        		__ld2x.umq	__scroll_chest_end - 1  /* i */
         01:D499  AD 10 25   			lda	__scroll_chest_end - 1
         01:D49C  0A         			asl	a
         01:D49D  AA         			tax
 3449                        		__ld.wax	_list_chest_x_pos
         01:D49E  BD 85 24   			lda.l	_list_chest_x_pos, x
         01:D4A1  BC 86 24   			ldy.h	_list_chest_x_pos, x
 3450                        		__call		_spr_x.1
         01:D4A4  20 0A E8   			call	_spr_x.1
 3451                        	
 3452                        		.dbg	line,	"include\routines_LEVELS.c", 187; spr_y(list_chest_y_pos[i]);
 3453                        		__ld2x.umq	__scroll_chest_end - 1  /* i */
         01:D4A7  AD 10 25   			lda	__scroll_chest_end - 1
         01:D4AA  0A         			asl	a
         01:D4AB  AA         			tax
 3454                        		__ld.wax	_list_chest_y_pos
         01:D4AC  BD 95 24   			lda.l	_list_chest_y_pos, x
         01:D4AF  BC 96 24   			ldy.h	_list_chest_y_pos, x
 3455                        		__call		_spr_y.1
         01:D4B2  20 19 E8   			call	_spr_y.1
 3456                        	
 3457                        		.dbg	line,	"include\routines_LEVELS.c", 188; }
 3458                        	
 3459                        		.dbg	line,	"include\routines_LEVELS.c", 189; }
 3460    01:D4B5             	.LL30	.alias		.LL27
 3461                        		__bra		.LL27
         01:D4B5  4C 69 D3   			bra	.LL27
 3462    01:D4B8             	.LL29:
 3463                        	
 3464                        		.dbg	line,	"include\routines_LEVELS.c", 190; }
 3465    01:D4B8             	.LL25:
 3466                        		__return	0
         01:D4B8  4C EF FF   			jmp	leave_proc
 3467                        		.dbg	clear
 3468                        		.endp
 3469                        		.pceas
 3470                        	
 3471                        		.dbg	line,	"include\routines_LEVELS.c", 193; void scroll_npc()
 3472                        		.dbg	line,	"include\routines_LEVELS.c", 194; {
 3473                        	;***********************
 3474                        	;***********************
 3475                        	
 3476                        		.hucc
 3477    01:D4BB             		.proc		_scroll_npc
 3478                        		__enter		_scroll_npc
 3479                        	
 3480                        		.dbg	line,	"include\routines_LEVELS.c", 195; char i;
 3481                        	
 3482                        		.dbg	line,	"include\routines_LEVELS.c", 196; onscreen_npc_number = 0;
 3483                        		__st.umiq	0, _onscreen_npc_number
         01:D4BB  9C A4 23   			stz	_onscreen_npc_number
 3484                        	
 3485                        		.dbg	line,	"include\routines_LEVELS.c", 198; for(i=0 ; i<level_npc_number ; i++)
 3486                        		__st.umiq	0, __scroll_npc_end - 1  /* i */
         01:D4BE  9C 10 25   			stz	__scroll_npc_end - 1
 3487    01:D4C1             	.LL38:
 3488                        		__ld.umq	__scroll_npc_end - 1  /* i */
         01:D4C1  AD 10 25   			lda	__scroll_npc_end - 1
 3489                        		__ult_b.umq	_level_npc_number
         01:D4C4  CD A3 23   			cmp	_level_npc_number		; Subtract memory from A.
         01:D4C7  6A         			ror	a		; CC if A < memory.
         01:D4C8  49 80      			eor	#$80
         01:D4CA  2A         			rol	a
 3490                        		__btrue		.LL40
         01:D4CB  B0 08      			bcs	.LL40
 3491                        		__bra		.LL41
         01:D4CD  4C 1F D6   			bra	.LL41
 3492    01:D4D0             	.LL39:
 3493                        		__inc.umq	__scroll_npc_end - 1  /* i */
         01:D4D0  EE 10 25   			inc	__scroll_npc_end - 1
 3494                        		__bra		.LL38
         01:D4D3  80 EC      			bra	.LL38
 3495    01:D4D5             	.LL40:
 3496                        	
 3497                        		.dbg	line,	"include\routines_LEVELS.c", 199; {
 3498                        	
 3499                        		.dbg	line,	"include\routines_LEVELS.c", 200; if(list_npc_state[i] != STATE_INACTIVE)
 3500                        		__ldx.umq	__scroll_npc_end - 1  /* i */
         01:D4D5  AE 10 25   			ldx	__scroll_npc_end - 1
 3501                        		__ld.uaxq	_list_npc_state
         01:D4D8  BD A5 23   			lda	_list_npc_state, x
 3502                        		__neq_b.uiq	1
         01:D4DB  38         			sec
         01:D4DC  49 01      			eor	#1
         01:D4DE  D0 01      			bne	!+
         01:D4E0  18         			clc
         01:D4E1             	!:
 3503                        		__bfalse	.LL42
         01:D4E1  90 ED      			bcc	.LL42
 3504                        	
 3505                        		.dbg	line,	"include\routines_LEVELS.c", 201; {
 3506                        	
 3507                        		.dbg	line,	"include\routines_LEVELS.c", 202; char scroll_allowed = FALSE;
 3508                        		__st.umiq	0, __scroll_npc_end - 2  /* scroll_allowed */
         01:D4E3  9C 0F 25   			stz	__scroll_npc_end - 2
 3509                        	
 3510                        		.dbg	line,	"include\routines_LEVELS.c", 203; 
 3511                        	
 3512                        		.dbg	line,	"include\routines_LEVELS.c", 204; // IF NPC X POSITION IS INFERIOR TO SCREEN RIGHT SIDE //
 3513                        	
 3514                        		.dbg	line,	"include\routines_LEVELS.c", 205; if(list_npc_x_pos_ref[i] < sgx_map_pxl_x + 256)
 3515                        		__ld.wm		_sgx_map_pxl_x
         01:D4E6  AD 55 25   			lda.l	_sgx_map_pxl_x
         01:D4E9  AC 56 25   			ldy.h	_sgx_map_pxl_x
 3516                        		__add.wi	256
         01:D4EC  18         			clc
         01:D4ED  69 00      			adc.l	#256
         01:D4EF  42         			say
         01:D4F0  69 01      			adc.h	#256
         01:D4F2  42         			say
 3517                        		__ld2x.um	__scroll_npc_end - 1  /* i */
         01:D4F3  AA         			tax
         01:D4F4  AD 10 25   			lda	__scroll_npc_end - 1
         01:D4F7  0A         			asl	a
         01:D4F8  22         			sax
 3518                        		__ugt_w.wax	_list_npc_x_pos_ref
         01:D4F9  18         			clc			; Subtract memory+1 from Y:A.
         01:D4FA  FD E9 24   			sbc.l	_list_npc_x_pos_ref, x
         01:D4FD  98         			tya
         01:D4FE  FD EA 24   			sbc.h	_list_npc_x_pos_ref, x		; CS if Y:A > memory.
 3519                        		__bfalse	.LL43
         01:D501  B0 03 4C 86			bcc	.LL43
         01:D505  D5          
 3520                        	
 3521                        		.dbg	line,	"include\routines_LEVELS.c", 206; {
 3522                        	
 3523                        		.dbg	line,	"include\routines_LEVELS.c", 207; // IF NPC X POSITION IS SUPERIOR TO SCREEN LEFT SIDE PLUS 32 PX //
 3524                        	
 3525                        		.dbg	line,	"include\routines_LEVELS.c", 208; if(list_npc_x_pos_ref[i] - sgx_map_pxl_x + 32 > 0)
 3526                        		__ld2x.umq	__scroll_npc_end - 1  /* i */
         01:D506  AD 10 25   			lda	__scroll_npc_end - 1
         01:D509  0A         			asl	a
         01:D50A  AA         			tax
 3527                        		__ld.wax	_list_npc_x_pos_ref
         01:D50B  BD E9 24   			lda.l	_list_npc_x_pos_ref, x
         01:D50E  BC EA 24   			ldy.h	_list_npc_x_pos_ref, x
 3528                        		__sub.wm	_sgx_map_pxl_x
         01:D511  38         			sec
         01:D512  ED 55 25   			sbc.l	_sgx_map_pxl_x
         01:D515  42         			say
         01:D516  ED 56 25   			sbc.h	_sgx_map_pxl_x
         01:D519  42         			say
 3529                        		__add.wi	32
         01:D51A  18         			clc
         01:D51B  69 20      			adc.l	#32
         01:D51D  90 01      			bcc	!+
         01:D51F  C8         			iny
         01:D520             	!:
 3530                        		__sgt_w.wi	0
         01:D520  18         			clc			; Subtract integer+1 from Y:A.
         01:D521  E9 00      			sbc.l	#0
         01:D523  98         			tya
         01:D524  E9 00      			sbc.h	#0
         01:D526  50 02      			bvc	!+
         01:D528  49 80      			eor	#$80		; +ve if Y:A > integer (signed).
         01:D52A  49 80      	!:		eor	#$80
         01:D52C  0A         			asl	a
 3531                        		__bfalse	.LL44
         01:D52D  90 57      			bcc	.LL44
 3532                        	
 3533                        		.dbg	line,	"include\routines_LEVELS.c", 209; {
 3534                        	
 3535                        		.dbg	line,	"include\routines_LEVELS.c", 210; // IF NPC Y POSITION IS INFERIOR TO SCREEN BOTTOM //
 3536                        	
 3537                        		.dbg	line,	"include\routines_LEVELS.c", 211; if(list_npc_y_pos_ref[i] < sgx_map_pxl_y + 224)
 3538                        		__ld.wm		_sgx_map_pxl_y
         01:D52F  AD 57 25   			lda.l	_sgx_map_pxl_y
         01:D532  AC 58 25   			ldy.h	_sgx_map_pxl_y
 3539                        		__add.wi	224
         01:D535  18         			clc
         01:D536  69 E0      			adc.l	#224
         01:D538  90 01      			bcc	!+
         01:D53A  C8         			iny
         01:D53B             	!:
 3540                        		__ld2x.um	__scroll_npc_end - 1  /* i */
         01:D53B  AA         			tax
         01:D53C  AD 10 25   			lda	__scroll_npc_end - 1
         01:D53F  0A         			asl	a
         01:D540  22         			sax
 3541                        		__ugt_w.wax	_list_npc_y_pos_ref
         01:D541  18         			clc			; Subtract memory+1 from Y:A.
         01:D542  FD FB 24   			sbc.l	_list_npc_y_pos_ref, x
         01:D545  98         			tya
         01:D546  FD FC 24   			sbc.h	_list_npc_y_pos_ref, x		; CS if Y:A > memory.
 3542                        		__bfalse	.LL45
         01:D549  90 3B      			bcc	.LL45
 3543                        	
 3544                        		.dbg	line,	"include\routines_LEVELS.c", 212; {
 3545                        	
 3546                        		.dbg	line,	"include\routines_LEVELS.c", 213; // IF NPC Y POSITION IS SUPERIOR TO SCREEN TOP PLUS 32 PX //
 3547                        	
 3548                        		.dbg	line,	"include\routines_LEVELS.c", 214; if(list_npc_y_pos_ref[i] - sgx_map_pxl_y + 32 > 0)
 3549                        		__ld2x.umq	__scroll_npc_end - 1  /* i */
         01:D54B  AD 10 25   			lda	__scroll_npc_end - 1
         01:D54E  0A         			asl	a
         01:D54F  AA         			tax
 3550                        		__ld.wax	_list_npc_y_pos_ref
         01:D550  BD FB 24   			lda.l	_list_npc_y_pos_ref, x
         01:D553  BC FC 24   			ldy.h	_list_npc_y_pos_ref, x
 3551                        		__sub.wm	_sgx_map_pxl_y
         01:D556  38         			sec
         01:D557  ED 57 25   			sbc.l	_sgx_map_pxl_y
         01:D55A  42         			say
         01:D55B  ED 58 25   			sbc.h	_sgx_map_pxl_y
         01:D55E  42         			say
 3552                        		__add.wi	32
         01:D55F  18         			clc
         01:D560  69 20      			adc.l	#32
         01:D562  90 01      			bcc	!+
         01:D564  C8         			iny
         01:D565             	!:
 3553                        		__sgt_w.wi	0
         01:D565  18         			clc			; Subtract integer+1 from Y:A.
         01:D566  E9 00      			sbc.l	#0
         01:D568  98         			tya
         01:D569  E9 00      			sbc.h	#0
         01:D56B  50 02      			bvc	!+
         01:D56D  49 80      			eor	#$80		; +ve if Y:A > integer (signed).
         01:D56F  49 80      	!:		eor	#$80
         01:D571  0A         			asl	a
 3554                        		__bfalse	.LL46
         01:D572  90 12      			bcc	.LL46
 3555                        	
 3556                        		.dbg	line,	"include\routines_LEVELS.c", 215; {
 3557                        	
 3558                        		.dbg	line,	"include\routines_LEVELS.c", 216; // WE STORE THE NPC ID //
 3559                        	
 3560                        		.dbg	line,	"include\routines_LEVELS.c", 217; list_onscreen_npc[onscreen_npc_number] = i;
 3561                        		__ldx.umq	_onscreen_npc_number
         01:D574  AE A4 23   			ldx	_onscreen_npc_number
 3562                        		__ld.um		__scroll_npc_end - 1  /* i */
         01:D577  AD 10 25   			lda	__scroll_npc_end - 1
         01:D57A  C2         			cly
 3563                        		__st.uaxq	_list_onscreen_npc
         01:D57B  9D AE 23   			sta	_list_onscreen_npc, x
 3564                        	
 3565                        		.dbg	line,	"include\routines_LEVELS.c", 218; onscreen_npc_number += 1;
 3566                        		__add_st.umiq	1, _onscreen_npc_number
         01:D57E  EE A4 23   			inc	_onscreen_npc_number
 3567                        	
 3568                        		.dbg	line,	"include\routines_LEVELS.c", 219; 
 3569                        	
 3570                        		.dbg	line,	"include\routines_LEVELS.c", 220; scroll_allowed = TRUE;
 3571                        		__st.umiq	1, __scroll_npc_end - 2  /* scroll_allowed */
         01:D581  A9 01      			lda.l	#1
         01:D583  8D 0F 25   			sta	__scroll_npc_end - 2
 3572                        	
 3573                        		.dbg	line,	"include\routines_LEVELS.c", 221; }
 3574                        	
 3575                        		.dbg	line,	"include\routines_LEVELS.c", 222; }
 3576    01:D586             	.LL46:
 3577                        	
 3578                        		.dbg	line,	"include\routines_LEVELS.c", 223; }
 3579    01:D586             	.LL45:
 3580                        	
 3581                        		.dbg	line,	"include\routines_LEVELS.c", 224; }
 3582    01:D586             	.LL44:
 3583                        	
 3584                        		.dbg	line,	"include\routines_LEVELS.c", 226; // IF NPC IS WITHIN THE SCREEN LIMITS //
 3585                        	
 3586                        		.dbg	line,	"include\routines_LEVELS.c", 227; if(scroll_allowed == TRUE)
 3587    01:D586             	.LL43:
 3588                        		__ld.umq	__scroll_npc_end - 2  /* scroll_allowed */
         01:D586  AD 0F 25   			lda	__scroll_npc_end - 2
 3589                        		__equ_b.uiq	1
         01:D589  C9 01      			cmp	#1
         01:D58B  F0 01      			beq	!+
         01:D58D  18         			clc
         01:D58E             	!:
 3590                        		__bfalse	.LL47
         01:D58E  90 44      			bcc	.LL47
 3591                        	
 3592                        		.dbg	line,	"include\routines_LEVELS.c", 228; {
 3593                        	
 3594                        		.dbg	line,	"include\routines_LEVELS.c", 229; list_npc_x_pos[i] = list_npc_x_pos_ref[i] - sgx_map_pxl_x;
 3595                        		__ld2x.umq	__scroll_npc_end - 1  /* i */
         01:D590  AD 10 25   			lda	__scroll_npc_end - 1
         01:D593  0A         			asl	a
         01:D594  AA         			tax
 3596                        		__ld.wax	_list_npc_x_pos_ref
         01:D595  BD E9 24   			lda.l	_list_npc_x_pos_ref, x
         01:D598  BC EA 24   			ldy.h	_list_npc_x_pos_ref, x
 3597                        		__sub.wm	_sgx_map_pxl_x
         01:D59B  38         			sec
         01:D59C  ED 55 25   			sbc.l	_sgx_map_pxl_x
         01:D59F  42         			say
         01:D5A0  ED 56 25   			sbc.h	_sgx_map_pxl_x
         01:D5A3  42         			say
 3598                        		__ld2x.um	__scroll_npc_end - 1  /* i */
         01:D5A4  AA         			tax
         01:D5A5  AD 10 25   			lda	__scroll_npc_end - 1
         01:D5A8  0A         			asl	a
         01:D5A9  22         			sax
 3599                        		__st.waxq	_list_npc_x_pos
         01:D5AA  9D C5 24   			sta.l	_list_npc_x_pos, x
         01:D5AD  98         			tya
         01:D5AE  9D C6 24   			sta.h	_list_npc_x_pos, x
 3600                        	
 3601                        		.dbg	line,	"include\routines_LEVELS.c", 230; list_npc_y_pos[i] = list_npc_y_pos_ref[i] - sgx_map_pxl_y;
 3602                        		__ld2x.umq	__scroll_npc_end - 1  /* i */
         01:D5B1  AD 10 25   			lda	__scroll_npc_end - 1
         01:D5B4  0A         			asl	a
         01:D5B5  AA         			tax
 3603                        		__ld.wax	_list_npc_y_pos_ref
         01:D5B6  BD FB 24   			lda.l	_list_npc_y_pos_ref, x
         01:D5B9  BC FC 24   			ldy.h	_list_npc_y_pos_ref, x
 3604                        		__sub.wm	_sgx_map_pxl_y
         01:D5BC  38         			sec
         01:D5BD  ED 57 25   			sbc.l	_sgx_map_pxl_y
         01:D5C0  42         			say
         01:D5C1  ED 58 25   			sbc.h	_sgx_map_pxl_y
         01:D5C4  42         			say
 3605                        		__ld2x.um	__scroll_npc_end - 1  /* i */
         01:D5C5  AA         			tax
         01:D5C6  AD 10 25   			lda	__scroll_npc_end - 1
         01:D5C9  0A         			asl	a
         01:D5CA  22         			sax
 3606                        		__st.waxq	_list_npc_y_pos
         01:D5CB  9D D7 24   			sta.l	_list_npc_y_pos, x
         01:D5CE  98         			tya
         01:D5CF  9D D8 24   			sta.h	_list_npc_y_pos, x
 3607                        	
 3608                        		.dbg	line,	"include\routines_LEVELS.c", 231; }
 3609                        	
 3610                        		.dbg	line,	"include\routines_LEVELS.c", 233; else
 3611                        		__bra		.LL48
         01:D5D2  80 1E      			bra	.LL48
 3612    01:D5D4             	.LL47:
 3613                        	
 3614                        		.dbg	line,	"include\routines_LEVELS.c", 234; {
 3615                        	
 3616                        		.dbg	line,	"include\routines_LEVELS.c", 235; list_npc_x_pos[i] = -32;
 3617                        		__ld2x.umq	__scroll_npc_end - 1  /* i */
         01:D5D4  AD 10 25   			lda	__scroll_npc_end - 1
         01:D5D7  0A         			asl	a
         01:D5D8  AA         			tax
 3618                        		__st.waxiq	-32, _list_npc_x_pos
         01:D5D9  A9 E0      			lda.l	#-32
         01:D5DB  9D C5 24   			sta.l	_list_npc_x_pos, x
         01:D5DE  A9 FF      			lda.h	#-32
         01:D5E0  9D C6 24   			sta.h	_list_npc_x_pos, x
 3619                        	
 3620                        		.dbg	line,	"include\routines_LEVELS.c", 236; list_npc_y_pos[i] = -32;
 3621                        		__ld2x.umq	__scroll_npc_end - 1  /* i */
         01:D5E3  AD 10 25   			lda	__scroll_npc_end - 1
         01:D5E6  0A         			asl	a
         01:D5E7  AA         			tax
 3622                        		__st.waxiq	-32, _list_npc_y_pos
         01:D5E8  A9 E0      			lda.l	#-32
         01:D5EA  9D D7 24   			sta.l	_list_npc_y_pos, x
         01:D5ED  A9 FF      			lda.h	#-32
         01:D5EF  9D D8 24   			sta.h	_list_npc_y_pos, x
 3623                        	
 3624                        		.dbg	line,	"include\routines_LEVELS.c", 237; }
 3625    01:D5F2             	.LL48:
 3626                        	
 3627                        		.dbg	line,	"include\routines_LEVELS.c", 239; spr_set(i + npc_start_index);
 3628                        		__ld.um		__scroll_npc_end - 1  /* i */
         01:D5F2  AD 10 25   			lda	__scroll_npc_end - 1
         01:D5F5  C2         			cly
 3629                        		__add.um	_npc_start_index
         01:D5F6  18         			clc
         01:D5F7  6D A2 23   			adc	_npc_start_index
         01:D5FA  90 01      			bcc	!+
         01:D5FC  C8         			iny
         01:D5FD             	!:
 3630                        		__call		_spr_set.1
         01:D5FD  20 DD E7   			call	_spr_set.1
 3631                        	
 3632                        		.dbg	line,	"include\routines_LEVELS.c", 241; spr_x(list_npc_x_pos[i]);
 3633                        		__ld2x.umq	__scroll_npc_end - 1  /* i */
         01:D600  AD 10 25   			lda	__scroll_npc_end - 1
         01:D603  0A         			asl	a
         01:D604  AA         			tax
 3634                        		__ld.wax	_list_npc_x_pos
         01:D605  BD C5 24   			lda.l	_list_npc_x_pos, x
         01:D608  BC C6 24   			ldy.h	_list_npc_x_pos, x
 3635                        		__call		_spr_x.1
         01:D60B  20 0A E8   			call	_spr_x.1
 3636                        	
 3637                        		.dbg	line,	"include\routines_LEVELS.c", 242; spr_y(list_npc_y_pos[i]);
 3638                        		__ld2x.umq	__scroll_npc_end - 1  /* i */
         01:D60E  AD 10 25   			lda	__scroll_npc_end - 1
         01:D611  0A         			asl	a
         01:D612  AA         			tax
 3639                        		__ld.wax	_list_npc_y_pos
         01:D613  BD D7 24   			lda.l	_list_npc_y_pos, x
         01:D616  BC D8 24   			ldy.h	_list_npc_y_pos, x
 3640                        		__call		_spr_y.1
         01:D619  20 19 E8   			call	_spr_y.1
 3641                        	
 3642                        		.dbg	line,	"include\routines_LEVELS.c", 243; }
 3643                        	
 3644                        		.dbg	line,	"include\routines_LEVELS.c", 244; }
 3645    01:D61C             	.LL42	.alias		.LL39
 3646                        		__bra		.LL39
         01:D61C  4C D0 D4   			bra	.LL39
 3647    01:D61F             	.LL41:
 3648                        	
 3649                        		.dbg	line,	"include\routines_LEVELS.c", 245; }
 3650    01:D61F             	.LL37:
 3651                        		__return	0
         01:D61F  4C EF FF   			jmp	leave_proc
 3652                        		.dbg	clear
 3653                        		.endp
 3654                        		.pceas
 3655                        	
 3656                        		.dbg	line,	"include\routines_LEVELS.c", 250; int check_TILE_DEPTH(signed char x_offset , signed char y_offset)
 3657                        		.dbg	line,	"include\routines_LEVELS.c", 251; {
 3658                        	;***********************
 3659                        	;***********************
 3660                        	
 3661                        		.hucc
 3662    01:DED8             		.proc		_check_TILE_DEPTH
 3663                        		__enter		_check_TILE_DEPTH
 3664                        	
 3665                        		.dbg	line,	"include\routines_LEVELS.c", 252; int player_COLL_X;
 3666                        	
 3667                        		.dbg	line,	"include\routines_LEVELS.c", 253; int player_COLL_Y;
 3668                        	
 3669                        		.dbg	line,	"include\routines_LEVELS.c", 256; player_COLL_X = player_pos_x + x_offset;
 3670                        		__ld.bs		2  /* x_offset */
         01:DED8  A6 8D      			ldx	<__sp
         01:DEDA  B5 0A      			lda	<__stack + 2, x
         01:DEDC  C2         			cly
         01:DEDD  10 01      			bpl	!+	; signed
         01:DEDF  88         			dey
         01:DEE0             	!:
 3671                        		__add.wm	_player_pos_x
         01:DEE0  18         			clc
         01:DEE1  6D B7 23   			adc.l	_player_pos_x
         01:DEE4  42         			say
         01:DEE5  6D B8 23   			adc.h	_player_pos_x
         01:DEE8  42         			say
 3672                        		__st.wmq	__check_TILE_DEPTH_end - 2  /* player_COLL_X */
         01:DEE9  8D 0F 25   			sta.l	__check_TILE_DEPTH_end - 2
         01:DEEC  8C 10 25   			sty.h	__check_TILE_DEPTH_end - 2
 3673                        	
 3674                        		.dbg	line,	"include\routines_LEVELS.c", 257; player_COLL_Y = player_pos_y + 32 - y_offset;//32
 3675                        		__ld.wm		_player_pos_y
         01:DEEF  AD B9 23   			lda.l	_player_pos_y
         01:DEF2  AC BA 23   			ldy.h	_player_pos_y
 3676                        		__add.wi	32
         01:DEF5  18         			clc
         01:DEF6  69 20      			adc.l	#32
         01:DEF8  90 01      			bcc	!+
         01:DEFA  C8         			iny
         01:DEFB             	!:
 3677                        		__push.wr
         01:DEFB  5A         			phy
         01:DEFC  48         			pha
 3678                        		__ld.bs		0  /* y_offset */
         01:DEFD  A6 8D      			ldx	<__sp
         01:DEFF  B5 08      			lda	<__stack + 0, x
         01:DF01  C2         			cly
         01:DF02  10 01      			bpl	!+	; signed
         01:DF04  88         			dey
         01:DF05             	!:
 3679                        		__sub.wt
         01:DF05  BA         			tsx
         01:DF06  38         			sec
         01:DF07  49 FF      			eor	#$FF
         01:DF09  7D 01 21   			adc.l	__tos, x
         01:DF0C  42         			say
         01:DF0D  49 FF      			eor	#$FF
         01:DF0F  7D 02 21   			adc.h	__tos, x
         01:DF12  42         			say
         01:DF13  E8         			inx
         01:DF14  E8         			inx
         01:DF15  9A         			txs
 3680                        		__st.wmq	__check_TILE_DEPTH_end - 4  /* player_COLL_Y */
         01:DF16  8D 0D 25   			sta.l	__check_TILE_DEPTH_end - 4
         01:DF19  8C 0E 25   			sty.h	__check_TILE_DEPTH_end - 4
 3681                        	
 3682                        		.dbg	line,	"include\routines_LEVELS.c", 259; get_map_block(player_COLL_X + sgx_map_pxl_x, player_COLL_Y + sgx_map_pxl_y);
 3683                        		__ld.wm		__check_TILE_DEPTH_end - 2  /* player_COLL_X */
         01:DF1C  AD 0F 25   			lda.l	__check_TILE_DEPTH_end - 2
         01:DF1F  AC 10 25   			ldy.h	__check_TILE_DEPTH_end - 2
 3684                        		__add.wm	_sgx_map_pxl_x
         01:DF22  18         			clc
         01:DF23  6D 55 25   			adc.l	_sgx_map_pxl_x
         01:DF26  42         			say
         01:DF27  6D 56 25   			adc.h	_sgx_map_pxl_x
         01:DF2A  42         			say
 3685                        		__st.wmq	map_pxl_x
         01:DF2B  85 FC      			sta.l	map_pxl_x
         01:DF2D  84 FD      			sty.h	map_pxl_x
 3686                        		__ld.wm		__check_TILE_DEPTH_end - 4  /* player_COLL_Y */
         01:DF2F  AD 0D 25   			lda.l	__check_TILE_DEPTH_end - 4
         01:DF32  AC 0E 25   			ldy.h	__check_TILE_DEPTH_end - 4
 3687                        		__add.wm	_sgx_map_pxl_y
         01:DF35  18         			clc
         01:DF36  6D 57 25   			adc.l	_sgx_map_pxl_y
         01:DF39  42         			say
         01:DF3A  6D 58 25   			adc.h	_sgx_map_pxl_y
         01:DF3D  42         			say
 3688                        		__st.wmq	map_pxl_y
         01:DF3E  85 FE      			sta.l	map_pxl_y
         01:DF40  84 FF      			sty.h	map_pxl_y
 3689                        		__call		_get_map_block.2
         01:DF42  20 95 FF   			call	_get_map_block.2
 3690                        	
 3691                        		.dbg	line,	"include\routines_LEVELS.c", 260; }
 3692    01:DF45             	.LL49:
 3693                        		__modsp		4
         01:DF45  AA         			tax
         01:DF46  A5 8D      			lda	<__sp
         01:DF48  18         			clc
         01:DF49  69 04      			adc	#4
         01:DF4B  85 8D      			sta	<__sp
         01:DF4D  8A         			txa
 3694                        		__return	1
         01:DF4E  AA         			tax
         01:DF4F  4C EF FF   			jmp	leave_proc
 3695                        		.dbg	clear
 3696                        		.endp
 3697                        		.pceas
 3698                        	
 3699                        		.dbg	line,	"include\routines_LEVELS.c", 262; // CHECK COLLISION WITH BG //
 3700                        		.dbg	line,	"include\routines_LEVELS.c", 263; int check_BG(signed char x_offset , signed char y_offset)
 3701                        		.dbg	line,	"include\routines_LEVELS.c", 264; {
 3702                        	;***********************
 3703                        	;***********************
 3704                        	
 3705                        		.hucc
 3706    02:C06A             		.proc		_check_BG
 3707                        		__enter		_check_BG
 3708                        	
 3709                        		.dbg	line,	"include\routines_LEVELS.c", 265; int player_COLL_X;
 3710                        	
 3711                        		.dbg	line,	"include\routines_LEVELS.c", 266; int player_COLL_Y;
 3712                        	
 3713                        		.dbg	line,	"include\routines_LEVELS.c", 269; player_COLL_X = player_pos_x + x_offset;
 3714                        		__ld.bs		2  /* x_offset */
         02:C06A  A6 8D      			ldx	<__sp
         02:C06C  B5 0A      			lda	<__stack + 2, x
         02:C06E  C2         			cly
         02:C06F  10 01      			bpl	!+	; signed
         02:C071  88         			dey
         02:C072             	!:
 3715                        		__add.wm	_player_pos_x
         02:C072  18         			clc
         02:C073  6D B7 23   			adc.l	_player_pos_x
         02:C076  42         			say
         02:C077  6D B8 23   			adc.h	_player_pos_x
         02:C07A  42         			say
 3716                        		__st.wmq	__check_BG_end - 2  /* player_COLL_X */
         02:C07B  8D 0F 25   			sta.l	__check_BG_end - 2
         02:C07E  8C 10 25   			sty.h	__check_BG_end - 2
 3717                        	
 3718                        		.dbg	line,	"include\routines_LEVELS.c", 270; player_COLL_Y = player_pos_y + y_offset;
 3719                        		__ld.bs		0  /* y_offset */
         02:C081  A6 8D      			ldx	<__sp
         02:C083  B5 08      			lda	<__stack + 0, x
         02:C085  C2         			cly
         02:C086  10 01      			bpl	!+	; signed
         02:C088  88         			dey
         02:C089             	!:
 3720                        		__add.wm	_player_pos_y
         02:C089  18         			clc
         02:C08A  6D B9 23   			adc.l	_player_pos_y
         02:C08D  42         			say
         02:C08E  6D BA 23   			adc.h	_player_pos_y
         02:C091  42         			say
 3721                        		__st.wmq	__check_BG_end - 4  /* player_COLL_Y */
         02:C092  8D 0D 25   			sta.l	__check_BG_end - 4
         02:C095  8C 0E 25   			sty.h	__check_BG_end - 4
 3722                        	
 3723                        		.dbg	line,	"include\routines_LEVELS.c", 272; get_map_block(player_COLL_X + sgx_map_pxl_x, player_COLL_Y + sgx_map_pxl_y);
 3724                        		__ld.wm		__check_BG_end - 2  /* player_COLL_X */
         02:C098  AD 0F 25   			lda.l	__check_BG_end - 2
         02:C09B  AC 10 25   			ldy.h	__check_BG_end - 2
 3725                        		__add.wm	_sgx_map_pxl_x
         02:C09E  18         			clc
         02:C09F  6D 55 25   			adc.l	_sgx_map_pxl_x
         02:C0A2  42         			say
         02:C0A3  6D 56 25   			adc.h	_sgx_map_pxl_x
         02:C0A6  42         			say
 3726                        		__st.wmq	map_pxl_x
         02:C0A7  85 FC      			sta.l	map_pxl_x
         02:C0A9  84 FD      			sty.h	map_pxl_x
 3727                        		__ld.wm		__check_BG_end - 4  /* player_COLL_Y */
         02:C0AB  AD 0D 25   			lda.l	__check_BG_end - 4
         02:C0AE  AC 0E 25   			ldy.h	__check_BG_end - 4
 3728                        		__add.wm	_sgx_map_pxl_y
         02:C0B1  18         			clc
         02:C0B2  6D 57 25   			adc.l	_sgx_map_pxl_y
         02:C0B5  42         			say
         02:C0B6  6D 58 25   			adc.h	_sgx_map_pxl_y
         02:C0B9  42         			say
 3729                        		__st.wmq	map_pxl_y
         02:C0BA  85 FE      			sta.l	map_pxl_y
         02:C0BC  84 FF      			sty.h	map_pxl_y
 3730                        		__call		_get_map_block.2
         02:C0BE  20 95 FF   			call	_get_map_block.2
 3731                        	
 3732                        		.dbg	line,	"include\routines_LEVELS.c", 273; }
 3733    02:C0C1             	.LL50:
 3734                        		__modsp		4
         02:C0C1  AA         			tax
         02:C0C2  A5 8D      			lda	<__sp
         02:C0C4  18         			clc
         02:C0C5  69 04      			adc	#4
         02:C0C7  85 8D      			sta	<__sp
         02:C0C9  8A         			txa
 3735                        		__return	1
         02:C0CA  AA         			tax
         02:C0CB  4C EF FF   			jmp	leave_proc
 3736                        		.dbg	clear
 3737                        		.endp
 3738                        		.pceas
 3739                        	
 3740                        		.dbg	line,	"include\routines_LEVELS.c", 275; // CHECK COLLISION WITH OBJECTS //
 3741                        		.dbg	line,	"include\routines_LEVELS.c", 276; void check_OBJECTS()
 3742                        		.dbg	line,	"include\routines_LEVELS.c", 277; {
 3743                        	;***********************
 3744                        	;***********************
 3745                        	
 3746                        		.hucc
 3747    01:D069             		.proc		_check_OBJECTS
 3748                        		__enter		_check_OBJECTS
 3749                        	
 3750                        		.dbg	line,	"include\routines_LEVELS.c", 278; if(onscreen_object_number != 0)
 3751                        		__tst.um	_onscreen_object_number
         01:D069  AD 22 23   			lda	_onscreen_object_number
         01:D06C  C9 01      			cmp	#1
 3752                        		__bfalse	.LL52
         01:D06E  B0 03 4C EA			bcc	.LL52
         01:D072  D1          
 3753                        	
 3754                        		.dbg	line,	"include\routines_LEVELS.c", 279; {
 3755                        	
 3756                        		.dbg	line,	"include\routines_LEVELS.c", 280; char i;
 3757                        	
 3758                        		.dbg	line,	"include\routines_LEVELS.c", 281; char current_object_id;
 3759                        	
 3760                        		.dbg	line,	"include\routines_LEVELS.c", 282; char current_object_type;
 3761                        	
 3762                        		.dbg	line,	"include\routines_LEVELS.c", 284; for(i=0 ; i<onscreen_object_number ; i++)
 3763                        		__st.umiq	0, __check_OBJECTS_end - 1  /* i */
         01:D073  9C 02 23   			stz	__check_OBJECTS_end - 1
 3764    01:D076             	.LL53:
 3765                        		__ld.umq	__check_OBJECTS_end - 1  /* i */
         01:D076  AD 02 23   			lda	__check_OBJECTS_end - 1
 3766                        		__ult_b.umq	_onscreen_object_number
         01:D079  CD 22 23   			cmp	_onscreen_object_number		; Subtract memory from A.
         01:D07C  6A         			ror	a		; CC if A < memory.
         01:D07D  49 80      			eor	#$80
         01:D07F  2A         			rol	a
 3767                        		__btrue		.LL55
         01:D080  B0 08      			bcs	.LL55
 3768                        		__bra		.LL56
         01:D082  4C EA D1   			bra	.LL56
 3769    01:D085             	.LL54:
 3770                        		__inc.umq	__check_OBJECTS_end - 1  /* i */
         01:D085  EE 02 23   			inc	__check_OBJECTS_end - 1
 3771                        		__bra		.LL53
         01:D088  80 EC      			bra	.LL53
 3772    01:D08A             	.LL55:
 3773                        	
 3774                        		.dbg	line,	"include\routines_LEVELS.c", 285; {
 3775                        	
 3776                        		.dbg	line,	"include\routines_LEVELS.c", 286; // RETRIEVE OBJECT INDEX IN THE LIST //
 3777                        	
 3778                        		.dbg	line,	"include\routines_LEVELS.c", 287; current_object_id = list_onscreen_object[i];
 3779                        		__ldx.umq	__check_OBJECTS_end - 1  /* i */
         01:D08A  AE 02 23   			ldx	__check_OBJECTS_end - 1
 3780                        		__ld.uax	_list_onscreen_object
         01:D08D  BD 87 23   			lda	_list_onscreen_object, x
         01:D090  C2         			cly
 3781                        		__st.umq	__check_OBJECTS_end - 2  /* current_object_id */
         01:D091  8D 01 23   			sta	__check_OBJECTS_end - 2
 3782                        	
 3783                        		.dbg	line,	"include\routines_LEVELS.c", 288; // RETRIEVE OBJECT TYPE //
 3784                        	
 3785                        		.dbg	line,	"include\routines_LEVELS.c", 289; current_object_type = list_object_type[current_object_id];
 3786                        		__ldx.umq	__check_OBJECTS_end - 2  /* current_object_id */
         01:D094  AE 01 23   			ldx	__check_OBJECTS_end - 2
 3787                        		__ld.uax	_list_object_type
         01:D097  BD 23 23   			lda	_list_object_type, x
         01:D09A  C2         			cly
 3788                        		__st.umq	__check_OBJECTS_end - 3  /* current_object_type */
         01:D09B  8D 00 23   			sta	__check_OBJECTS_end - 3
 3789                        	
 3790                        		.dbg	line,	"include\routines_LEVELS.c", 291; if(current_object_type != TYPE_POT)
 3791                        		__ld.umq	__check_OBJECTS_end - 3  /* current_object_type */
         01:D09E  AD 00 23   			lda	__check_OBJECTS_end - 3
 3792                        		__neq_b.uiq	1
         01:D0A1  38         			sec
         01:D0A2  49 01      			eor	#1
         01:D0A4  D0 01      			bne	!+
         01:D0A6  18         			clc
         01:D0A7             	!:
 3793                        		__bfalse	.LL57
         01:D0A7  90 DC      			bcc	.LL57
 3794                        	
 3795                        		.dbg	line,	"include\routines_LEVELS.c", 292; {
 3796                        	
 3797                        		.dbg	line,	"include\routines_LEVELS.c", 293; if(abs( (player_pos_x + 16) - (list_object_x_pos[current_object_id] + 8) ) < 9)
 3798                        		__ld.wm		_player_pos_x
         01:D0A9  AD B7 23   			lda.l	_player_pos_x
         01:D0AC  AC B8 23   			ldy.h	_player_pos_x
 3799                        		__add.wi	16
         01:D0AF  18         			clc
         01:D0B0  69 10      			adc.l	#16
         01:D0B2  90 01      			bcc	!+
         01:D0B4  C8         			iny
         01:D0B5             	!:
 3800                        		__push.wr
         01:D0B5  5A         			phy
         01:D0B6  48         			pha
 3801                        		__ld2x.umq	__check_OBJECTS_end - 2  /* current_object_id */
         01:D0B7  AD 01 23   			lda	__check_OBJECTS_end - 2
         01:D0BA  0A         			asl	a
         01:D0BB  AA         			tax
 3802                        		__ld.wax	_list_object_x_pos
         01:D0BC  BD BD 23   			lda.l	_list_object_x_pos, x
         01:D0BF  BC BE 23   			ldy.h	_list_object_x_pos, x
 3803                        		__add.wi	8
         01:D0C2  18         			clc
         01:D0C3  69 08      			adc.l	#8
         01:D0C5  90 01      			bcc	!+
         01:D0C7  C8         			iny
         01:D0C8             	!:
 3804                        		__sub.wt
         01:D0C8  BA         			tsx
         01:D0C9  38         			sec
         01:D0CA  49 FF      			eor	#$FF
         01:D0CC  7D 01 21   			adc.l	__tos, x
         01:D0CF  42         			say
         01:D0D0  49 FF      			eor	#$FF
         01:D0D2  7D 02 21   			adc.h	__tos, x
         01:D0D5  42         			say
         01:D0D6  E8         			inx
         01:D0D7  E8         			inx
         01:D0D8  9A         			txs
 3805                        		__call		_abs.1
         01:D0D9  20 09 E5   			call	_abs.1
 3806                        		__slt_w.wi	9
         01:D0DC  C9 09      			cmp.l	#9		; Subtract integer from Y:A.
         01:D0DE  98         			tya
         01:D0DF  E9 00      			sbc.h	#9
         01:D0E1  50 02      			bvc	!+
         01:D0E3  49 80      			eor	#$80		; -ve if Y:A < integer (signed).
         01:D0E5  0A         	!:		asl	a
 3807                        		__bfalse	.LL58
         01:D0E6  90 9D      			bcc	.LL58
 3808                        	
 3809                        		.dbg	line,	"include\routines_LEVELS.c", 294; {
 3810                        	
 3811                        		.dbg	line,	"include\routines_LEVELS.c", 295; if(abs( (player_pos_y + 16) - (list_object_y_pos[current_object_id] + 8) ) < 9)
 3812                        		__ld.wm		_player_pos_y
         01:D0E8  AD B9 23   			lda.l	_player_pos_y
         01:D0EB  AC BA 23   			ldy.h	_player_pos_y
 3813                        		__add.wi	16
         01:D0EE  18         			clc
         01:D0EF  69 10      			adc.l	#16
         01:D0F1  90 01      			bcc	!+
         01:D0F3  C8         			iny
         01:D0F4             	!:
 3814                        		__push.wr
         01:D0F4  5A         			phy
         01:D0F5  48         			pha
 3815                        		__ld2x.umq	__check_OBJECTS_end - 2  /* current_object_id */
         01:D0F6  AD 01 23   			lda	__check_OBJECTS_end - 2
         01:D0F9  0A         			asl	a
         01:D0FA  AA         			tax
 3816                        		__ld.wax	_list_object_y_pos
         01:D0FB  BD EF 23   			lda.l	_list_object_y_pos, x
         01:D0FE  BC F0 23   			ldy.h	_list_object_y_pos, x
 3817                        		__add.wi	8
         01:D101  18         			clc
         01:D102  69 08      			adc.l	#8
         01:D104  90 01      			bcc	!+
         01:D106  C8         			iny
         01:D107             	!:
 3818                        		__sub.wt
         01:D107  BA         			tsx
         01:D108  38         			sec
         01:D109  49 FF      			eor	#$FF
         01:D10B  7D 01 21   			adc.l	__tos, x
         01:D10E  42         			say
         01:D10F  49 FF      			eor	#$FF
         01:D111  7D 02 21   			adc.h	__tos, x
         01:D114  42         			say
         01:D115  E8         			inx
         01:D116  E8         			inx
         01:D117  9A         			txs
 3819                        		__call		_abs.1
         01:D118  20 09 E5   			call	_abs.1
 3820                        		__slt_w.wi	9
         01:D11B  C9 09      			cmp.l	#9		; Subtract integer from Y:A.
         01:D11D  98         			tya
         01:D11E  E9 00      			sbc.h	#9
         01:D120  50 02      			bvc	!+
         01:D122  49 80      			eor	#$80		; -ve if Y:A < integer (signed).
         01:D124  0A         	!:		asl	a
 3821                        		__bfalse	.LL59
         01:D125  B0 03 4C 85			bcc	.LL59
         01:D129  D0          
 3822                        	
 3823                        		.dbg	line,	"include\routines_LEVELS.c", 296; {
 3824                        	
 3825                        		.dbg	line,	"include\routines_LEVELS.c", 297; // THE OBJECT DISAPPEARS //
 3826                        	
 3827                        		.dbg	line,	"include\routines_LEVELS.c", 298; list_object_x_pos[current_object_id] = -16;
 3828                        		__ld2x.umq	__check_OBJECTS_end - 2  /* current_object_id */
         01:D12A  AD 01 23   			lda	__check_OBJECTS_end - 2
         01:D12D  0A         			asl	a
         01:D12E  AA         			tax
 3829                        		__st.waxiq	-16, _list_object_x_pos
         01:D12F  A9 F0      			lda.l	#-16
         01:D131  9D BD 23   			sta.l	_list_object_x_pos, x
         01:D134  A9 FF      			lda.h	#-16
         01:D136  9D BE 23   			sta.h	_list_object_x_pos, x
 3830                        	
 3831                        		.dbg	line,	"include\routines_LEVELS.c", 299; list_object_y_pos[current_object_id] = -16;
 3832                        		__ld2x.umq	__check_OBJECTS_end - 2  /* current_object_id */
         01:D139  AD 01 23   			lda	__check_OBJECTS_end - 2
         01:D13C  0A         			asl	a
         01:D13D  AA         			tax
 3833                        		__st.waxiq	-16, _list_object_y_pos
         01:D13E  A9 F0      			lda.l	#-16
         01:D140  9D EF 23   			sta.l	_list_object_y_pos, x
         01:D143  A9 FF      			lda.h	#-16
         01:D145  9D F0 23   			sta.h	_list_object_y_pos, x
 3834                        	
 3835                        		.dbg	line,	"include\routines_LEVELS.c", 300; list_object_state[current_object_id] = STATE_INACTIVE;
 3836                        		__ldx.umq	__check_OBJECTS_end - 2  /* current_object_id */
         01:D148  AE 01 23   			ldx	__check_OBJECTS_end - 2
 3837                        		__st.uaxiq	1, _list_object_state
         01:D14B  A9 01      			lda.l	#1
         01:D14D  9D 3C 23   			sta	_list_object_state, x
 3838                        	
 3839                        		.dbg	line,	"include\routines_LEVELS.c", 302; spr_set(current_object_id + object_start_index);
 3840                        		__ld.um		__check_OBJECTS_end - 2  /* current_object_id */
         01:D150  AD 01 23   			lda	__check_OBJECTS_end - 2
         01:D153  C2         			cly
 3841                        		__add.um	_object_start_index
         01:D154  18         			clc
         01:D155  6D 20 23   			adc	_object_start_index
         01:D158  90 01      			bcc	!+
         01:D15A  C8         			iny
         01:D15B             	!:
 3842                        		__call		_spr_set.1
         01:D15B  20 DD E7   			call	_spr_set.1
 3843                        	
 3844                        		.dbg	line,	"include\routines_LEVELS.c", 303; spr_x(list_object_x_pos[current_object_id]);
 3845                        		__ld2x.umq	__check_OBJECTS_end - 2  /* current_object_id */
         01:D15E  AD 01 23   			lda	__check_OBJECTS_end - 2
         01:D161  0A         			asl	a
         01:D162  AA         			tax
 3846                        		__ld.wax	_list_object_x_pos
         01:D163  BD BD 23   			lda.l	_list_object_x_pos, x
         01:D166  BC BE 23   			ldy.h	_list_object_x_pos, x
 3847                        		__call		_spr_x.1
         01:D169  20 0A E8   			call	_spr_x.1
 3848                        	
 3849                        		.dbg	line,	"include\routines_LEVELS.c", 304; spr_y(list_object_y_pos[current_object_id]);
 3850                        		__ld2x.umq	__check_OBJECTS_end - 2  /* current_object_id */
         01:D16C  AD 01 23   			lda	__check_OBJECTS_end - 2
         01:D16F  0A         			asl	a
         01:D170  AA         			tax
 3851                        		__ld.wax	_list_object_y_pos
         01:D171  BD EF 23   			lda.l	_list_object_y_pos, x
         01:D174  BC F0 23   			ldy.h	_list_object_y_pos, x
 3852                        		__call		_spr_y.1
         01:D177  20 19 E8   			call	_spr_y.1
 3853                        	
 3854                        		.dbg	line,	"include\routines_LEVELS.c", 305; 
 3855                        	
 3856                        		.dbg	line,	"include\routines_LEVELS.c", 307; switch(current_object_type)
 3857                        		__ld.umq	__check_OBJECTS_end - 3  /* current_object_type */
         01:D17A  AD 00 23   			lda	__check_OBJECTS_end - 3
 3858                        		__bra		.LL60
         01:D17D  80 4A      			bra	.LL60
 3859                        	
 3860                        		.dbg	line,	"include\routines_LEVELS.c", 308; {
 3861                        	
 3862                        		.dbg	line,	"include\routines_LEVELS.c", 309; case TYPE_HOURGLASS:
 3863    01:D17F             	.LL62:
 3864                        		__case		0
 3865                        	
 3866                        		.dbg	line,	"include\routines_LEVELS.c", 310; if(seconds + 30 > 59)
 3867                        		__ld.um		_seconds
         01:D17F  AD 1E 23   			lda	_seconds
         01:D182  C2         			cly
 3868                        		__add.wi	30
         01:D183  18         			clc
         01:D184  69 1E      			adc.l	#30
         01:D186  90 01      			bcc	!+
         01:D188  C8         			iny
         01:D189             	!:
 3869                        		__sgt_w.wi	59
         01:D189  18         			clc			; Subtract integer+1 from Y:A.
         01:D18A  E9 3B      			sbc.l	#59
         01:D18C  98         			tya
         01:D18D  E9 00      			sbc.h	#59
         01:D18F  50 02      			bvc	!+
         01:D191  49 80      			eor	#$80		; +ve if Y:A > integer (signed).
         01:D193  49 80      	!:		eor	#$80
         01:D195  0A         			asl	a
 3870                        		__bfalse	.LL63
         01:D196  90 13      			bcc	.LL63
 3871                        	
 3872                        		.dbg	line,	"include\routines_LEVELS.c", 311; {
 3873                        	
 3874                        		.dbg	line,	"include\routines_LEVELS.c", 312; seconds = seconds + 30 - 60;
 3875                        		__ld.um		_seconds
         01:D198  AD 1E 23   			lda	_seconds
         01:D19B  C2         			cly
 3876                        		__sub.wi	30
         01:D19C  38         			sec
         01:D19D  E9 1E      			sbc.l	#30
         01:D19F  B0 01      			bcs	!+
         01:D1A1  88         			dey
         01:D1A2             	!:
 3877                        		__st.umq	_seconds
         01:D1A2  8D 1E 23   			sta	_seconds
 3878                        	
 3879                        		.dbg	line,	"include\routines_LEVELS.c", 313; minutes += 1;
 3880                        		__add_st.umiq	1, _minutes
         01:D1A5  EE 1D 23   			inc	_minutes
 3881                        	
 3882                        		.dbg	line,	"include\routines_LEVELS.c", 314; }
 3883                        	
 3884                        		.dbg	line,	"include\routines_LEVELS.c", 316; else
 3885                        		__bra		.LL64
         01:D1A8  4C 85 D0   			bra	.LL64
 3886    01:D1AB             	.LL63:
 3887                        	
 3888                        		.dbg	line,	"include\routines_LEVELS.c", 317; {
 3889                        	
 3890                        		.dbg	line,	"include\routines_LEVELS.c", 318; seconds += 30;
 3891                        		__add_st.umiq	30, _seconds
         01:D1AB  18         			clc
         01:D1AC  AD 1E 23   			lda	_seconds
         01:D1AF  69 1E      			adc	#30
         01:D1B1  8D 1E 23   			sta	_seconds
 3892                        	
 3893                        		.dbg	line,	"include\routines_LEVELS.c", 319; }
 3894    01:D1B4             	.LL64	.alias		.LL61
 3895                        	
 3896                        		.dbg	line,	"include\routines_LEVELS.c", 321; break;
 3897                        		__bra		.LL61
         01:D1B4  4C 85 D0   			bra	.LL61
 3898                        	
 3899                        		.dbg	line,	"include\routines_LEVELS.c", 323; case TYPE_POW:
 3900    01:D1B7             	.LL65:
 3901                        		__case		2
 3902                        	
 3903                        		.dbg	line,	"include\routines_LEVELS.c", 324; //
 3904                        	
 3905                        		.dbg	line,	"include\routines_LEVELS.c", 325; break;
 3906                        		__bra		.LL61
         01:D1B7  4C 85 D0   			bra	.LL61
 3907                        	
 3908                        		.dbg	line,	"include\routines_LEVELS.c", 327; case TYPE_GRAY_KEY:
 3909    01:D1BA             	.LL66:
 3910                        		__case		4
 3911                        	
 3912                        		.dbg	line,	"include\routines_LEVELS.c", 328; key_number += 1;
 3913                        		__add_st.umiq	1, _key_number
         01:D1BA  EE 1A 23   			inc	_key_number
 3914                        	
 3915                        		.dbg	line,	"include\routines_LEVELS.c", 329; display_KEY();
 3916                        		__call		_display_KEY
         01:D1BD  20 8B FF   			call	_display_KEY
 3917                        	
 3918                        		.dbg	line,	"include\routines_LEVELS.c", 330; break;
 3919                        		__bra		.LL61
         01:D1C0  4C 85 D0   			bra	.LL61
 3920                        	
 3921                        		.dbg	line,	"include\routines_LEVELS.c", 332; case TYPE_YASHICHI:
 3922    01:D1C3             	.LL67:
 3923                        		__case		14
 3924                        	
 3925                        		.dbg	line,	"include\routines_LEVELS.c", 333; life_number += 1;
 3926                        		__add_st.umiq	1, _life_number
         01:D1C3  EE 19 23   			inc	_life_number
 3927                        	
 3928                        		.dbg	line,	"include\routines_LEVELS.c", 334; break;
 3929                        		__bra		.LL61
         01:D1C6  4C 85 D0   			bra	.LL61
 3930                        	
 3931                        		.dbg	line,	"include\routines_LEVELS.c", 335; }
 3932    01:D1C9             	.LL60:
 3933                        		__switch_c.ur	4
         01:D1C9  A2 05      			ldx	#4 + 1
         01:D1CB  CA         	!loop:		dex
         01:D1CC  F0 05      			beq	!found+
         01:D1CE  DD D8 D1   			cmp	!table+ - 1, x
         01:D1D1  D0 F8      			bne	!loop-
         01:D1D3  8A         	!found:		txa
         01:D1D4  0A         			asl	a
         01:D1D5  AA         			tax
         01:D1D6  7C DD D1   			jmp	[!table+ + 4, x]
 3934                        	
 3935    01:D1D9  0E 04 02 00	!table:		db	14, 4, 2, 0
 3936    01:D1DD  85 D0      			dw	.LL61
 3937    01:D1DF  C3 D1      			dw	.LL67, .LL66, .LL65, .LL62
         01:D1E1  BA D1       
         01:D1E3  B7 D1       
         01:D1E5  7F D1       
 3938                        	
 3939    01:D1E7             	.LL61	.alias		.LL54
 3940                        	
 3941                        		.dbg	line,	"include\routines_LEVELS.c", 336; }
 3942                        	
 3943                        		.dbg	line,	"include\routines_LEVELS.c", 337; }
 3944    01:D1E7             	.LL59	.alias		.LL54
 3945                        	
 3946                        		.dbg	line,	"include\routines_LEVELS.c", 338; }
 3947    01:D1E7             	.LL58	.alias		.LL54
 3948                        	
 3949                        		.dbg	line,	"include\routines_LEVELS.c", 339; }
 3950    01:D1E7             	.LL57	.alias		.LL54
 3951                        		__bra		.LL54
         01:D1E7  4C 85 D0   			bra	.LL54
 3952    01:D1EA             	.LL56:
 3953                        	
 3954                        		.dbg	line,	"include\routines_LEVELS.c", 340; }
 3955                        	
 3956                        		.dbg	line,	"include\routines_LEVELS.c", 341; }
 3957    01:D1EA             	.LL52:
 3958    01:D1EA             	.LL51:
 3959                        		__return	0
         01:D1EA  4C EF FF   			jmp	leave_proc
 3960                        		.dbg	clear
 3961                        		.endp
 3962               6820     		.data
 3963               2300     		.bss
 3964    F8:2300             	__check_OBJECTS_loc:
 3965    F8:2300             			ds	3
 3966    F8:2303             	__check_OBJECTS_end:
 3967               E309     		.code
 3968                        		.pceas
 3969                        	
 3970                        		.dbg	line,	"include\routines_LEVELS.c", 347; void scroll_BG()
 3971                        		.dbg	line,	"include\routines_LEVELS.c", 348; {
 3972                        	;***********************
 3973                        	;***********************
 3974                        	
 3975                        		.hucc
 3976    01:DFC9             		.proc		_scroll_BG
 3977                        		__enter		_scroll_BG
 3978                        	
 3979                        		.dbg	line,	"include\routines_LEVELS.c", 349; // UPDATE VDC2 BG //
 3980                        	
 3981                        		.dbg	line,	"include\routines_LEVELS.c", 350; sgx_scroll_map();
 3982                        		__call		_sgx_scroll_map
         01:DFC9  20 81 FF   			call	_sgx_scroll_map
 3983                        	
 3984                        		.dbg	line,	"include\routines_LEVELS.c", 352; //--------------------------------------------------------------------------------------//
 3985                        	
 3986                        		.dbg	line,	"include\routines_LEVELS.c", 353; //                                        VDC 2                                         //
 3987                        	
 3988                        		.dbg	line,	"include\routines_LEVELS.c", 354; //--------------------------------------------------------------------------------------//
 3989                        	
 3990                        		.dbg	line,	"include\routines_LEVELS.c", 356; sgx_scroll_split(0,   0, sgx_map_pxl_x & (BAT_SIZE_W - 1), sgx_map_pxl_y & (BAT_SIZE_H - 1), BKG_ON | SPR_ON);
 3991                        		__st.umiq	0, _al
         01:DFCC  64 F8      			stz	_al
 3992                        		__st.umiq	0, _ah
         01:DFCE  64 F9      			stz	_ah
 3993                        		__ld.wm		_sgx_map_pxl_x
         01:DFD0  AD 55 25   			lda.l	_sgx_map_pxl_x
         01:DFD3  AC 56 25   			ldy.h	_sgx_map_pxl_x
 3994                        		__and.wi	2047
         01:DFD6  29 FF      			and.l	#2047
         01:DFD8  42         			say
         01:DFD9  29 07      			and.h	#2047
         01:DFDB  42         			say
 3995                        		__st.wmq	_bx
         01:DFDC  85 FA      			sta.l	_bx
         01:DFDE  84 FB      			sty.h	_bx
 3996                        		__ld.wm		_sgx_map_pxl_y
         01:DFE0  AD 57 25   			lda.l	_sgx_map_pxl_y
         01:DFE3  AC 58 25   			ldy.h	_sgx_map_pxl_y
 3997                        		__and.wi	255
         01:DFE6  29 FF      			and	#255
         01:DFE8  C2         			cly
 3998                        		__st.wmq	_cx
         01:DFE9  85 FC      			sta.l	_cx
         01:DFEB  84 FD      			sty.h	_cx
 3999                        		__st.umiq	192, _dl
         01:DFED  A9 C0      			lda.l	#192
         01:DFEF  85 FE      			sta	_dl
 4000                        		__call		_sgx_scroll_split.5
         01:DFF1  20 77 FF   			call	_sgx_scroll_split.5
 4001                        	
 4002                        		.dbg	line,	"include\routines_LEVELS.c", 357; }
 4003    01:DFF4             	.LL68:
 4004                        		__return	0
         01:DFF4  4C EF FF   			jmp	leave_proc
 4005                        		.dbg	clear
 4006                        		.endp
 4007                        		.pceas
 4008                        	
 4009                        		.dbg	line,	"include\routines_LEVELS.c", 360; void recenter_CAMERA()
 4010                        		.dbg	line,	"include\routines_LEVELS.c", 361; {
 4011                        	;***********************
 4012                        	;***********************
 4013                        	
 4014                        		.hucc
 4015    01:D85E             		.proc		_recenter_CAMERA
 4016                        		__enter		_recenter_CAMERA
 4017                        	
 4018                        		.dbg	line,	"include\routines_LEVELS.c", 362; signed char camera_y_move;
 4019                        	
 4020                        		.dbg	line,	"include\routines_LEVELS.c", 364; spr_set(player_id);
 4021                        		__ld.umq	_player_id
         01:D85E  AD 10 23   			lda	_player_id
 4022                        		__call		_spr_set.1
         01:D861  20 DD E7   			call	_spr_set.1
 4023                        	
 4024                        		.dbg	line,	"include\routines_LEVELS.c", 367; if(player_pos_y < 128)
 4025                        		__ld.wm		_player_pos_y
         01:D864  AD B9 23   			lda.l	_player_pos_y
         01:D867  AC BA 23   			ldy.h	_player_pos_y
 4026                        		__slt_w.wi	128
         01:D86A  C9 80      			cmp.l	#128		; Subtract integer from Y:A.
         01:D86C  98         			tya
         01:D86D  E9 00      			sbc.h	#128
         01:D86F  50 02      			bvc	!+
         01:D871  49 80      			eor	#$80		; -ve if Y:A < integer (signed).
         01:D873  0A         	!:		asl	a
 4027                        		__bfalse	.LL70
         01:D874  90 70      			bcc	.LL70
 4028                        	
 4029                        		.dbg	line,	"include\routines_LEVELS.c", 368; {
 4030                        	
 4031                        		.dbg	line,	"include\routines_LEVELS.c", 369; player_pos_y += CAMERA_RECENTER_VELOCITY;
 4032                        		__add_st.wmiq	4, _player_pos_y
         01:D876  18         			clc
         01:D877  AD B9 23   			lda.l	_player_pos_y
         01:D87A  69 04      			adc.l	#4
         01:D87C  8D B9 23   			sta.l	_player_pos_y
         01:D87F  90 03      			bcc	!+
         01:D881  EE BA 23   			inc.h	_player_pos_y
         01:D884             	!:
 4033                        	
 4034                        		.dbg	line,	"include\routines_LEVELS.c", 371; if(player_pos_y > 128)
 4035                        		__ld.wm		_player_pos_y
         01:D884  AD B9 23   			lda.l	_player_pos_y
         01:D887  AC BA 23   			ldy.h	_player_pos_y
 4036                        		__sgt_w.wi	128
         01:D88A  18         			clc			; Subtract integer+1 from Y:A.
         01:D88B  E9 80      			sbc.l	#128
         01:D88D  98         			tya
         01:D88E  E9 00      			sbc.h	#128
         01:D890  50 02      			bvc	!+
         01:D892  49 80      			eor	#$80		; +ve if Y:A > integer (signed).
         01:D894  49 80      	!:		eor	#$80
         01:D896  0A         			asl	a
 4037                        		__bfalse	.LL71
         01:D897  90 24      			bcc	.LL71
 4038                        	
 4039                        		.dbg	line,	"include\routines_LEVELS.c", 372; {
 4040                        	
 4041                        		.dbg	line,	"include\routines_LEVELS.c", 373; camera_y_move = CAMERA_RECENTER_VELOCITY - (player_pos_y - 128);
 4042                        		__ld.wm		_player_pos_y
         01:D899  AD B9 23   			lda.l	_player_pos_y
         01:D89C  AC BA 23   			ldy.h	_player_pos_y
 4043                        		__sub.wi	128
         01:D89F  38         			sec
         01:D8A0  E9 80      			sbc.l	#128
         01:D8A2  B0 01      			bcs	!+
         01:D8A4  88         			dey
         01:D8A5             	!:
 4044                        		__isub.wi	4
         01:D8A5  38         			sec
         01:D8A6  49 FF      			eor	#$FF
         01:D8A8  69 04      			adc.l	#4
         01:D8AA  42         			say
         01:D8AB  49 FF      			eor	#$FF
         01:D8AD  69 00      			adc.h	#4
         01:D8AF  42         			say
 4045                        		__st.umq	__recenter_CAMERA_end - 1  /* camera_y_move */
         01:D8B0  8D 10 25   			sta	__recenter_CAMERA_end - 1
 4046                        	
 4047                        		.dbg	line,	"include\routines_LEVELS.c", 375; player_pos_y = 128;
 4048                        		__st.wmiq	128, _player_pos_y
         01:D8B3  A9 80      			lda.l	#128
         01:D8B5  8D B9 23   			sta.l	_player_pos_y
         01:D8B8  9C BA 23   			stz.h	_player_pos_y
 4049                        	
 4050                        		.dbg	line,	"include\routines_LEVELS.c", 376; }
 4051                        	
 4052                        		.dbg	line,	"include\routines_LEVELS.c", 378; else
 4053                        		__bra		.LL72
         01:D8BB  80 05      			bra	.LL72
 4054    01:D8BD             	.LL71:
 4055                        	
 4056                        		.dbg	line,	"include\routines_LEVELS.c", 379; {
 4057                        	
 4058                        		.dbg	line,	"include\routines_LEVELS.c", 380; camera_y_move = CAMERA_RECENTER_VELOCITY;
 4059                        		__st.umiq	4, __recenter_CAMERA_end - 1  /* camera_y_move */
         01:D8BD  A9 04      			lda.l	#4
         01:D8BF  8D 10 25   			sta	__recenter_CAMERA_end - 1
 4060                        	
 4061                        		.dbg	line,	"include\routines_LEVELS.c", 381; }
 4062    01:D8C2             	.LL72:
 4063                        	
 4064                        		.dbg	line,	"include\routines_LEVELS.c", 383; spr_y(player_pos_y);
 4065                        		__ld.wm		_player_pos_y
         01:D8C2  AD B9 23   			lda.l	_player_pos_y
         01:D8C5  AC BA 23   			ldy.h	_player_pos_y
 4066                        		__call		_spr_y.1
         01:D8C8  20 19 E8   			call	_spr_y.1
 4067                        	
 4068                        		.dbg	line,	"include\routines_LEVELS.c", 385; sgx_map_pxl_y -= camera_y_move;
 4069                        		__ld.bm		__recenter_CAMERA_end - 1  /* camera_y_move */
         01:D8CB  AD 10 25   			lda	__recenter_CAMERA_end - 1
         01:D8CE  C2         			cly
         01:D8CF  10 01      			bpl	!+
         01:D8D1  88         			dey
         01:D8D2             	!:
 4070                        		__isub_st.wmq	_sgx_map_pxl_y
         01:D8D2  38         			sec
         01:D8D3  49 FF      			eor	#$FF
         01:D8D5  6D 57 25   			adc.l	_sgx_map_pxl_y
         01:D8D8  8D 57 25   			sta.l	_sgx_map_pxl_y
         01:D8DB  98         			tya
         01:D8DC  49 FF      			eor	#$FF
         01:D8DE  6D 58 25   			adc.h	_sgx_map_pxl_y
         01:D8E1  8D 58 25   			sta.h	_sgx_map_pxl_y
 4071                        	
 4072                        		.dbg	line,	"include\routines_LEVELS.c", 386; }
 4073                        	
 4074                        		.dbg	line,	"include\routines_LEVELS.c", 389; else if(player_pos_y > 128)
 4075                        		__bra		.LL73
         01:D8E4  80 7C      			bra	.LL73
 4076    01:D8E6             	.LL70:
 4077                        		__ld.wm		_player_pos_y
         01:D8E6  AD B9 23   			lda.l	_player_pos_y
         01:D8E9  AC BA 23   			ldy.h	_player_pos_y
 4078                        		__sgt_w.wi	128
         01:D8EC  18         			clc			; Subtract integer+1 from Y:A.
         01:D8ED  E9 80      			sbc.l	#128
         01:D8EF  98         			tya
         01:D8F0  E9 00      			sbc.h	#128
         01:D8F2  50 02      			bvc	!+
         01:D8F4  49 80      			eor	#$80		; +ve if Y:A > integer (signed).
         01:D8F6  49 80      	!:		eor	#$80
         01:D8F8  0A         			asl	a
 4079                        		__bfalse	.LL74
         01:D8F9  90 67      			bcc	.LL74
 4080                        	
 4081                        		.dbg	line,	"include\routines_LEVELS.c", 390; {
 4082                        	
 4083                        		.dbg	line,	"include\routines_LEVELS.c", 391; player_pos_y -= CAMERA_RECENTER_VELOCITY;
 4084                        		__sub_st.wmiq	4, _player_pos_y
         01:D8FB  38         			sec
         01:D8FC  AD B9 23   			lda.l	_player_pos_y
         01:D8FF  E9 04      			sbc.l	#4
         01:D901  8D B9 23   			sta.l	_player_pos_y
         01:D904  B0 03      			bcs	!+
         01:D906  CE BA 23   			dec.h	_player_pos_y
         01:D909             	!:
 4085                        	
 4086                        		.dbg	line,	"include\routines_LEVELS.c", 393; if(player_pos_y < 128)
 4087                        		__ld.wm		_player_pos_y
         01:D909  AD B9 23   			lda.l	_player_pos_y
         01:D90C  AC BA 23   			ldy.h	_player_pos_y
 4088                        		__slt_w.wi	128
         01:D90F  C9 80      			cmp.l	#128		; Subtract integer from Y:A.
         01:D911  98         			tya
         01:D912  E9 00      			sbc.h	#128
         01:D914  50 02      			bvc	!+
         01:D916  49 80      			eor	#$80		; -ve if Y:A < integer (signed).
         01:D918  0A         	!:		asl	a
 4089                        		__bfalse	.LL75
         01:D919  90 24      			bcc	.LL75
 4090                        	
 4091                        		.dbg	line,	"include\routines_LEVELS.c", 394; {
 4092                        	
 4093                        		.dbg	line,	"include\routines_LEVELS.c", 395; camera_y_move = CAMERA_RECENTER_VELOCITY - (128 - player_pos_y);
 4094                        		__ld.wi		128
         01:D91B  A9 80      			lda.l	#128
         01:D91D  C2         			cly
 4095                        		__sub.wm	_player_pos_y
         01:D91E  38         			sec
         01:D91F  ED B9 23   			sbc.l	_player_pos_y
         01:D922  42         			say
         01:D923  ED BA 23   			sbc.h	_player_pos_y
         01:D926  42         			say
 4096                        		__isub.wi	4
         01:D927  38         			sec
         01:D928  49 FF      			eor	#$FF
         01:D92A  69 04      			adc.l	#4
         01:D92C  42         			say
         01:D92D  49 FF      			eor	#$FF
         01:D92F  69 00      			adc.h	#4
         01:D931  42         			say
 4097                        		__st.umq	__recenter_CAMERA_end - 1  /* camera_y_move */
         01:D932  8D 10 25   			sta	__recenter_CAMERA_end - 1
 4098                        	
 4099                        		.dbg	line,	"include\routines_LEVELS.c", 397; player_pos_y = 128;
 4100                        		__st.wmiq	128, _player_pos_y
         01:D935  A9 80      			lda.l	#128
         01:D937  8D B9 23   			sta.l	_player_pos_y
         01:D93A  9C BA 23   			stz.h	_player_pos_y
 4101                        	
 4102                        		.dbg	line,	"include\routines_LEVELS.c", 398; }
 4103                        	
 4104                        		.dbg	line,	"include\routines_LEVELS.c", 400; else
 4105                        		__bra		.LL76
         01:D93D  80 05      			bra	.LL76
 4106    01:D93F             	.LL75:
 4107                        	
 4108                        		.dbg	line,	"include\routines_LEVELS.c", 401; {
 4109                        	
 4110                        		.dbg	line,	"include\routines_LEVELS.c", 402; camera_y_move = CAMERA_RECENTER_VELOCITY;
 4111                        		__st.umiq	4, __recenter_CAMERA_end - 1  /* camera_y_move */
         01:D93F  A9 04      			lda.l	#4
         01:D941  8D 10 25   			sta	__recenter_CAMERA_end - 1
 4112                        	
 4113                        		.dbg	line,	"include\routines_LEVELS.c", 403; }
 4114    01:D944             	.LL76:
 4115                        	
 4116                        		.dbg	line,	"include\routines_LEVELS.c", 405; spr_y(player_pos_y);
 4117                        		__ld.wm		_player_pos_y
         01:D944  AD B9 23   			lda.l	_player_pos_y
         01:D947  AC BA 23   			ldy.h	_player_pos_y
 4118                        		__call		_spr_y.1
         01:D94A  20 19 E8   			call	_spr_y.1
 4119                        	
 4120                        		.dbg	line,	"include\routines_LEVELS.c", 407; sgx_map_pxl_y += camera_y_move;
 4121                        		__ld.bm		__recenter_CAMERA_end - 1  /* camera_y_move */
         01:D94D  AD 10 25   			lda	__recenter_CAMERA_end - 1
         01:D950  C2         			cly
         01:D951  10 01      			bpl	!+
         01:D953  88         			dey
         01:D954             	!:
 4122                        		__add_st.wmq	_sgx_map_pxl_y
         01:D954  18         			clc
         01:D955  6D 57 25   			adc.l	_sgx_map_pxl_y
         01:D958  8D 57 25   			sta.l	_sgx_map_pxl_y
         01:D95B  98         			tya
         01:D95C  6D 58 25   			adc.h	_sgx_map_pxl_y
         01:D95F  8D 58 25   			sta.h	_sgx_map_pxl_y
 4123                        	
 4124                        		.dbg	line,	"include\routines_LEVELS.c", 408; }
 4125                        	
 4126                        		.dbg	line,	"include\routines_LEVELS.c", 409; }
 4127    01:D962             	.LL74:
 4128    01:D962             	.LL73:
 4129    01:D962             	.LL69:
 4130                        		__return	0
         01:D962  4C EF FF   			jmp	leave_proc
 4131                        		.dbg	clear
 4132                        		.endp
 4133                        		.pceas
 4134                        	
 4135                        		.dbg	line,	"include\routines_LEVELS.c", 418; void joypad_BUTTONS()
 4136                        		.dbg	line,	"include\routines_LEVELS.c", 419; {
 4137                        	;***********************
 4138                        	;***********************
 4139                        	
 4140                        		.hucc
 4141    09:DF29             		.proc		_joypad_BUTTONS
 4142                        		__enter		_joypad_BUTTONS
 4143                        	
 4144                        		.dbg	line,	"include\routines_LEVELS.c", 420; if(joytrg(JOYPAD_1) == JOY_I)
 4145                        		__ld.uiq	0
         09:DF29  62         			cla
 4146                        		 _joytrg.1
         09:DF2A  AA         			tax
         09:DF2B  BD 2D 22   			lda	joytrg, x
         09:DF2E  BC DD 22   			ldy	joy6trg, x
 4147                        		__equ_w.wi	1
         09:DF31  C9 01      			cmp.l	#1
         09:DF33  D0 04      			bne	!false+
         09:DF35  C0 00      			cpy.h	#1
         09:DF37  F0 01      			beq	!+
         09:DF39  18         	!false:		clc
         09:DF3A             	!:
 4148                        		__bfalse	.LL78
         09:DF3A  B0 03 4C FA			bcc	.LL78
         09:DF3E  DF          
 4149                        	
 4150                        		.dbg	line,	"include\routines_LEVELS.c", 421; {
 4151                        	
 4152                        		.dbg	line,	"include\routines_LEVELS.c", 422; if(player_state == STATE_IDLE)
 4153                        		__not.um	_player_state
         09:DF3F  AD 11 23   			lda	_player_state
         09:DF42  18         			clc
         09:DF43  D0 01      			bne	!+
         09:DF45  38         			sec
         09:DF46             	!:
 4154                        		__bfalse	.LL79
         09:DF46  90 0B      			bcc	.LL79
 4155                        	
 4156                        		.dbg	line,	"include\routines_LEVELS.c", 423; {
 4157                        	
 4158                        		.dbg	line,	"include\routines_LEVELS.c", 424; player_counter_anim = 0;
 4159                        		__st.umiq	0, _player_counter_anim
         09:DF48  9C 14 23   			stz	_player_counter_anim
 4160                        	
 4161                        		.dbg	line,	"include\routines_LEVELS.c", 426; player_state = STATE_JUMP;
 4162                        		__st.umiq	4, _player_state
         09:DF4B  A9 04      			lda.l	#4
         09:DF4D  8D 11 23   			sta	_player_state
 4163                        	
 4164                        		.dbg	line,	"include\routines_LEVELS.c", 427; }
 4165                        	
 4166                        		.dbg	line,	"include\routines_LEVELS.c", 430; else if(player_state == STATE_WALK)
 4167                        		__bra		.LL80
         09:DF50  4C FA DF   			bra	.LL80
 4168    09:DF53             	.LL79:
 4169                        		__ld.umq	_player_state
         09:DF53  AD 11 23   			lda	_player_state
 4170                        		__equ_b.uiq	1
         09:DF56  C9 01      			cmp	#1
         09:DF58  F0 01      			beq	!+
         09:DF5A  18         			clc
         09:DF5B             	!:
 4171                        		__bfalse	.LL81
         09:DF5B  90 13      			bcc	.LL81
 4172                        	
 4173                        		.dbg	line,	"include\routines_LEVELS.c", 431; {
 4174                        	
 4175                        		.dbg	line,	"include\routines_LEVELS.c", 432; player_counter_anim = 0;
 4176                        		__st.umiq	0, _player_counter_anim
         09:DF5D  9C 14 23   			stz	_player_counter_anim
 4177                        	
 4178                        		.dbg	line,	"include\routines_LEVELS.c", 434; player_state = STATE_JUMP_RIGHT + player_axis;
 4179                        		__ld.wi		5
         09:DF60  A9 05      			lda.l	#5
         09:DF62  C2         			cly
 4180                        		__add.um	_player_axis
         09:DF63  18         			clc
         09:DF64  6D 12 23   			adc	_player_axis
         09:DF67  90 01      			bcc	!+
         09:DF69  C8         			iny
         09:DF6A             	!:
 4181                        		__st.umq	_player_state
         09:DF6A  8D 11 23   			sta	_player_state
 4182                        	
 4183                        		.dbg	line,	"include\routines_LEVELS.c", 435; }
 4184                        	
 4185                        		.dbg	line,	"include\routines_LEVELS.c", 438; else if(player_state == STATE_HANG || player_state == STATE_CLIMB_UP || player_state == STATE_CLIMB_DOWN)
 4186                        		__bra		.LL82
         09:DF6D  4C FA DF   			bra	.LL82
 4187    09:DF70             	.LL81:
 4188                        		__ld.umq	_player_state
         09:DF70  AD 11 23   			lda	_player_state
 4189                        		__equ_b.uiq	10
         09:DF73  C9 0A      			cmp	#10
         09:DF75  F0 01      			beq	!+
         09:DF77  18         			clc
         09:DF78             	!:
 4190                        		__btrue		.LL84
         09:DF78  B0 08      			bcs	.LL84
 4191                        		__ld.umq	_player_state
         09:DF7A  AD 11 23   			lda	_player_state
 4192                        		__equ_b.uiq	11
         09:DF7D  C9 0B      			cmp	#11
         09:DF7F  F0 01      			beq	!+
         09:DF81  18         			clc
         09:DF82             	!:
 4193    09:DF82             	.LL84:
 4194                        		__btrue		.LL85
         09:DF82  B0 08      			bcs	.LL85
 4195                        		__ld.umq	_player_state
         09:DF84  AD 11 23   			lda	_player_state
 4196                        		__equ_b.uiq	12
         09:DF87  C9 0C      			cmp	#12
         09:DF89  F0 01      			beq	!+
         09:DF8B  18         			clc
         09:DF8C             	!:
 4197    09:DF8C             	.LL85:
 4198                        		__bfalse	.LL83
         09:DF8C  90 6C      			bcc	.LL83
 4199                        	
 4200                        		.dbg	line,	"include\routines_LEVELS.c", 439; {
 4201                        	
 4202                        		.dbg	line,	"include\routines_LEVELS.c", 440; if(joy(JOYPAD_1) & JOY_RIGHT)
 4203                        		__ld.uiq	0
         09:DF8E  62         			cla
 4204                        		 _joy.1
         09:DF8F  AA         			tax
         09:DF90  BD 28 22   			lda	joynow, x
         09:DF93  BC D3 22   			ldy	joy6now, x
 4205                        		__tand.wi	32
         09:DF96  29 20      			and	#32
         09:DF98  C9 01      	!:		cmp	#1
 4206                        		__bfalse	.LL86
         09:DF9A  90 0A      			bcc	.LL86
 4207                        	
 4208                        		.dbg	line,	"include\routines_LEVELS.c", 441; {
 4209                        	
 4210                        		.dbg	line,	"include\routines_LEVELS.c", 442; player_counter_anim = 0;
 4211                        		__st.umiq	0, _player_counter_anim
         09:DF9C  9C 14 23   			stz	_player_counter_anim
 4212                        	
 4213                        		.dbg	line,	"include\routines_LEVELS.c", 444; player_state = STATE_JUMP_RIGHT;
 4214                        		__st.umiq	5, _player_state
         09:DF9F  A9 05      			lda.l	#5
         09:DFA1  8D 11 23   			sta	_player_state
 4215                        	
 4216                        		.dbg	line,	"include\routines_LEVELS.c", 445; }
 4217                        	
 4218                        		.dbg	line,	"include\routines_LEVELS.c", 447; else if(joy(JOYPAD_1) & JOY_LEFT)
 4219                        		__bra		.LL87
         09:DFA4  80 54      			bra	.LL87
 4220    09:DFA6             	.LL86:
 4221                        		__ld.uiq	0
         09:DFA6  62         			cla
 4222                        		 _joy.1
         09:DFA7  AA         			tax
         09:DFA8  BD 28 22   			lda	joynow, x
         09:DFAB  BC D3 22   			ldy	joy6now, x
 4223                        		__tand.wi	128
         09:DFAE  29 80      			and	#128
         09:DFB0  C9 01      	!:		cmp	#1
 4224                        		__bfalse	.LL88
         09:DFB2  90 0A      			bcc	.LL88
 4225                        	
 4226                        		.dbg	line,	"include\routines_LEVELS.c", 448; {
 4227                        	
 4228                        		.dbg	line,	"include\routines_LEVELS.c", 449; player_counter_anim = 0;
 4229                        		__st.umiq	0, _player_counter_anim
         09:DFB4  9C 14 23   			stz	_player_counter_anim
 4230                        	
 4231                        		.dbg	line,	"include\routines_LEVELS.c", 451; player_state = STATE_JUMP_LEFT;
 4232                        		__st.umiq	6, _player_state
         09:DFB7  A9 06      			lda.l	#6
         09:DFB9  8D 11 23   			sta	_player_state
 4233                        	
 4234                        		.dbg	line,	"include\routines_LEVELS.c", 452; }
 4235                        	
 4236                        		.dbg	line,	"include\routines_LEVELS.c", 454; else if(joy(JOYPAD_1) & JOY_UP)
 4237                        		__bra		.LL89
         09:DFBC  80 3C      			bra	.LL89
 4238    09:DFBE             	.LL88:
 4239                        		__ld.uiq	0
         09:DFBE  62         			cla
 4240                        		 _joy.1
         09:DFBF  AA         			tax
         09:DFC0  BD 28 22   			lda	joynow, x
         09:DFC3  BC D3 22   			ldy	joy6now, x
 4241                        		__tand.wi	16
         09:DFC6  29 10      			and	#16
         09:DFC8  C9 01      	!:		cmp	#1
 4242                        		__bfalse	.LL90
         09:DFCA  90 2E      			bcc	.LL90
 4243                        	
 4244                        		.dbg	line,	"include\routines_LEVELS.c", 455; {
 4245                        	
 4246                        		.dbg	line,	"include\routines_LEVELS.c", 456; player_counter_anim = 0;
 4247                        		__st.umiq	0, _player_counter_anim
         09:DFCC  9C 14 23   			stz	_player_counter_anim
 4248                        	
 4249                        		.dbg	line,	"include\routines_LEVELS.c", 458; check_BG( 15 , 8 );
 4250                        		__ld.wi		15
         09:DFCF  A9 0F      			lda.l	#15
         09:DFD1  C2         			cly
 4251                        		__pusharg.wr
         09:DFD2  A6 8D      			ldx	<__sp
         09:DFD4  CA         			dex
         09:DFD5  CA         			dex
         09:DFD6  95 08      			sta.l	<__stack, x
         09:DFD8  94 09      			sty.h	<__stack, x
         09:DFDA  86 8D      			stx	<__sp
 4252                        		__ld.wi		8
         09:DFDC  A9 08      			lda.l	#8
         09:DFDE  C2         			cly
 4253                        		__pusharg.wr
         09:DFDF  A6 8D      			ldx	<__sp
         09:DFE1  CA         			dex
         09:DFE2  CA         			dex
         09:DFE3  95 08      			sta.l	<__stack, x
         09:DFE5  94 09      			sty.h	<__stack, x
         09:DFE7  86 8D      			stx	<__sp
 4254                        		__call		_check_BG
         09:DFE9  20 6D FF   			call	_check_BG
 4255                        	
 4256                        		.dbg	line,	"include\routines_LEVELS.c", 460; if(map_blk_flag == TILE_EMPTY)
 4257                        		__not.um	_map_blk_flag
         09:DFEC  AD 76 2A   			lda	_map_blk_flag
         09:DFEF  18         			clc
         09:DFF0  D0 01      			bne	!+
         09:DFF2  38         			sec
         09:DFF3             	!:
 4258                        		__bfalse	.LL91
         09:DFF3  90 05      			bcc	.LL91
 4259                        	
 4260                        		.dbg	line,	"include\routines_LEVELS.c", 461; {
 4261                        	
 4262                        		.dbg	line,	"include\routines_LEVELS.c", 462; player_state = STATE_JUMP_LADDER;
 4263                        		__st.umiq	13, _player_state
         09:DFF5  A9 0D      			lda.l	#13
         09:DFF7  8D 11 23   			sta	_player_state
 4264                        	
 4265                        		.dbg	line,	"include\routines_LEVELS.c", 463; }
 4266                        	
 4267                        		.dbg	line,	"include\routines_LEVELS.c", 464; }
 4268    09:DFFA             	.LL91:
 4269                        	
 4270                        		.dbg	line,	"include\routines_LEVELS.c", 465; }
 4271    09:DFFA             	.LL90:
 4272    09:DFFA             	.LL89:
 4273    09:DFFA             	.LL87:
 4274                        	
 4275                        		.dbg	line,	"include\routines_LEVELS.c", 466; }
 4276    09:DFFA             	.LL83:
 4277    09:DFFA             	.LL82:
 4278    09:DFFA             	.LL80:
 4279                        	
 4280                        		.dbg	line,	"include\routines_LEVELS.c", 467; }
 4281    09:DFFA             	.LL78:
 4282    09:DFFA             	.LL77:
 4283                        		__return	0
         09:DFFA  4C EF FF   			jmp	leave_proc
 4284                        		.dbg	clear
 4285                        		.endp
 4286                        		.pceas
 4287                        	
 4288                        		.dbg	line,	"include\routines_LEVELS.c", 470; void joypad_DIR()
 4289                        		.dbg	line,	"include\routines_LEVELS.c", 471; {
 4290                        	;***********************
 4291                        	;***********************
 4292                        	
 4293                        		.hucc
 4294    09:D880             		.proc		_joypad_DIR
 4295                        		__enter		_joypad_DIR
 4296                        	
 4297                        		.dbg	line,	"include\routines_LEVELS.c", 472; //--------------------------------------------------------------------------------------//
 4298                        	
 4299                        		.dbg	line,	"include\routines_LEVELS.c", 473; //                                        NO DIR                                        //
 4300                        	
 4301                        		.dbg	line,	"include\routines_LEVELS.c", 474; //--------------------------------------------------------------------------------------//
 4302                        	
 4303                        		.dbg	line,	"include\routines_LEVELS.c", 476; if(! (joy(JOYPAD_1) & JOY_DIR_PRESSED) )
 4304                        		__ld.uiq	0
         09:D880  62         			cla
 4305                        		 _joy.1
         09:D881  AA         			tax
         09:D882  BD 28 22   			lda	joynow, x
         09:D885  BC D3 22   			ldy	joy6now, x
 4306                        		__nand.wi	240
         09:D888  18         			clc
         09:D889  29 F0      			and	#240
         09:D88B  D0 01      			bne	!+
         09:D88D  38         			sec
         09:D88E             	!:
 4307                        		__bfalse	.LL93
         09:D88E  90 3C      			bcc	.LL93
 4308                        	
 4309                        		.dbg	line,	"include\routines_LEVELS.c", 477; {
 4310                        	
 4311                        		.dbg	line,	"include\routines_LEVELS.c", 478; if(player_state == STATE_WALK || player_state == STATE_CROUCH)
 4312                        		__ld.umq	_player_state
         09:D890  AD 11 23   			lda	_player_state
 4313                        		__equ_b.uiq	1
         09:D893  C9 01      			cmp	#1
         09:D895  F0 01      			beq	!+
         09:D897  18         			clc
         09:D898             	!:
 4314                        		__btrue		.LL95
         09:D898  B0 08      			bcs	.LL95
 4315                        		__ld.umq	_player_state
         09:D89A  AD 11 23   			lda	_player_state
 4316                        		__equ_b.uiq	7
         09:D89D  C9 07      			cmp	#7
         09:D89F  F0 01      			beq	!+
         09:D8A1  18         			clc
         09:D8A2             	!:
 4317    09:D8A2             	.LL95:
 4318                        		__bfalse	.LL94
         09:D8A2  90 0A      			bcc	.LL94
 4319                        	
 4320                        		.dbg	line,	"include\routines_LEVELS.c", 479; {
 4321                        	
 4322                        		.dbg	line,	"include\routines_LEVELS.c", 480; player_counter_anim = 1;
 4323                        		__st.umiq	1, _player_counter_anim
         09:D8A4  A9 01      			lda.l	#1
         09:D8A6  8D 14 23   			sta	_player_counter_anim
 4324                        	
 4325                        		.dbg	line,	"include\routines_LEVELS.c", 481; player_state = STATE_IDLE;
 4326                        		__st.umiq	0, _player_state
         09:D8A9  9C 11 23   			stz	_player_state
 4327                        	
 4328                        		.dbg	line,	"include\routines_LEVELS.c", 482; }
 4329                        	
 4330                        		.dbg	line,	"include\routines_LEVELS.c", 485; else if(player_state == STATE_CLIMB_UP || player_state == STATE_CLIMB_DOWN)
 4331                        		__bra		.LL96
         09:D8AC  80 1E      			bra	.LL96
 4332    09:D8AE             	.LL94:
 4333                        		__ld.umq	_player_state
         09:D8AE  AD 11 23   			lda	_player_state
 4334                        		__equ_b.uiq	11
         09:D8B1  C9 0B      			cmp	#11
         09:D8B3  F0 01      			beq	!+
         09:D8B5  18         			clc
         09:D8B6             	!:
 4335                        		__btrue		.LL98
         09:D8B6  B0 08      			bcs	.LL98
 4336                        		__ld.umq	_player_state
         09:D8B8  AD 11 23   			lda	_player_state
 4337                        		__equ_b.uiq	12
         09:D8BB  C9 0C      			cmp	#12
         09:D8BD  F0 01      			beq	!+
         09:D8BF  18         			clc
         09:D8C0             	!:
 4338    09:D8C0             	.LL98:
 4339                        		__bfalse	.LL97
         09:D8C0  90 0A      			bcc	.LL97
 4340                        	
 4341                        		.dbg	line,	"include\routines_LEVELS.c", 486; {
 4342                        	
 4343                        		.dbg	line,	"include\routines_LEVELS.c", 487; player_counter_anim = 1;
 4344                        		__st.umiq	1, _player_counter_anim
         09:D8C2  A9 01      			lda.l	#1
         09:D8C4  8D 14 23   			sta	_player_counter_anim
 4345                        	
 4346                        		.dbg	line,	"include\routines_LEVELS.c", 488; player_state = STATE_HANG;
 4347                        		__st.umiq	10, _player_state
         09:D8C7  A9 0A      			lda.l	#10
         09:D8C9  8D 11 23   			sta	_player_state
 4348                        	
 4349                        		.dbg	line,	"include\routines_LEVELS.c", 489; }
 4350                        	
 4351                        		.dbg	line,	"include\routines_LEVELS.c", 490; }
 4352    09:D8CC             	.LL97:
 4353    09:D8CC             	.LL96:
 4354                        	
 4355                        		.dbg	line,	"include\routines_LEVELS.c", 493; //--------------------------------------------------------------------------------------//
 4356                        	
 4357                        		.dbg	line,	"include\routines_LEVELS.c", 494; //                                     RIGHT BUTTON                                     //
 4358                        	
 4359                        		.dbg	line,	"include\routines_LEVELS.c", 495; //--------------------------------------------------------------------------------------//
 4360                        	
 4361                        		.dbg	line,	"include\routines_LEVELS.c", 497; if(joy(JOYPAD_1) & JOY_RIGHT)
 4362    09:D8CC             	.LL93:
 4363                        		__ld.uiq	0
         09:D8CC  62         			cla
 4364                        		 _joy.1
         09:D8CD  AA         			tax
         09:D8CE  BD 28 22   			lda	joynow, x
         09:D8D1  BC D3 22   			ldy	joy6now, x
 4365                        		__tand.wi	32
         09:D8D4  29 20      			and	#32
         09:D8D6  C9 01      	!:		cmp	#1
 4366                        		__bfalse	.LL99
         09:D8D8  B0 03 4C B5			bcc	.LL99
         09:D8DC  D9          
 4367                        	
 4368                        		.dbg	line,	"include\routines_LEVELS.c", 498; {
 4369                        	
 4370                        		.dbg	line,	"include\routines_LEVELS.c", 499; if(player_state == STATE_IDLE || player_state == STATE_WALK)
 4371                        		__not.um	_player_state
         09:D8DD  AD 11 23   			lda	_player_state
         09:D8E0  18         			clc
         09:D8E1  D0 01      			bne	!+
         09:D8E3  38         			sec
         09:D8E4             	!:
 4372                        		__btrue		.LL101
         09:D8E4  B0 08      			bcs	.LL101
 4373                        		__ld.umq	_player_state
         09:D8E6  AD 11 23   			lda	_player_state
 4374                        		__equ_b.uiq	1
         09:D8E9  C9 01      			cmp	#1
         09:D8EB  F0 01      			beq	!+
         09:D8ED  18         			clc
         09:D8EE             	!:
 4375    09:D8EE             	.LL101:
 4376                        		__bfalse	.LL100
         09:D8EE  90 47      			bcc	.LL100
 4377                        	
 4378                        		.dbg	line,	"include\routines_LEVELS.c", 500; {
 4379                        	
 4380                        		.dbg	line,	"include\routines_LEVELS.c", 501; player_axis = AXIS_RIGHT;
 4381                        		__st.umiq	0, _player_axis
         09:D8F0  9C 12 23   			stz	_player_axis
 4382                        	
 4383                        		.dbg	line,	"include\routines_LEVELS.c", 503; if(player_previous_axis != player_axis)
 4384                        		__ld.umq	_player_previous_axis
         09:D8F3  AD 13 23   			lda	_player_previous_axis
 4385                        		__neq_b.umq	_player_axis
         09:D8F6  38         			sec
         09:D8F7  4D 12 23   			eor	_player_axis
         09:D8FA  D0 01      			bne	!+
         09:D8FC  18         			clc
         09:D8FD             	!:
 4386                        		__bfalse	.LL102
         09:D8FD  90 15      			bcc	.LL102
 4387                        	
 4388                        		.dbg	line,	"include\routines_LEVELS.c", 504; {
 4389                        	
 4390                        		.dbg	line,	"include\routines_LEVELS.c", 505; player_previous_axis = player_axis;
 4391                        		__ld.um		_player_axis
         09:D8FF  AD 12 23   			lda	_player_axis
         09:D902  C2         			cly
 4392                        		__st.umq	_player_previous_axis
         09:D903  8D 13 23   			sta	_player_previous_axis
 4393                        	
 4394                        		.dbg	line,	"include\routines_LEVELS.c", 507; spr_set(player_id);
 4395                        		__ld.umq	_player_id
         09:D906  AD 10 23   			lda	_player_id
 4396                        		__call		_spr_set.1
         09:D909  20 DD E7   			call	_spr_set.1
 4397                        	
 4398                        		.dbg	line,	"include\routines_LEVELS.c", 508; spr_ctrl(FLIP_MAS, NO_FLIP_X);
 4399                        		__st.umiq	136, _al
         09:D90C  A9 88      			lda.l	#136
         09:D90E  85 F8      			sta	_al
 4400                        		__ld.uiq	0
         09:D910  62         			cla
 4401                        		__call		_spr_ctrl.2
         09:D911  20 3C E8   			call	_spr_ctrl.2
 4402                        	
 4403                        		.dbg	line,	"include\routines_LEVELS.c", 509; }
 4404                        	
 4405                        		.dbg	line,	"include\routines_LEVELS.c", 511; if(joy(JOYPAD_1) & JOY_DOWN)
 4406    09:D914             	.LL102:
 4407                        		__ld.uiq	0
         09:D914  62         			cla
 4408                        		 _joy.1
         09:D915  AA         			tax
         09:D916  BD 28 22   			lda	joynow, x
         09:D919  BC D3 22   			ldy	joy6now, x
 4409                        		__tand.wi	64
         09:D91C  29 40      			and	#64
         09:D91E  C9 01      	!:		cmp	#1
 4410                        		__bfalse	.LL103
         09:D920  90 0D      			bcc	.LL103
 4411                        	
 4412                        		.dbg	line,	"include\routines_LEVELS.c", 512; {
 4413                        	
 4414                        		.dbg	line,	"include\routines_LEVELS.c", 513; player_counter_anim = 1;
 4415                        		__st.umiq	1, _player_counter_anim
         09:D922  A9 01      			lda.l	#1
         09:D924  8D 14 23   			sta	_player_counter_anim
 4416                        	
 4417                        		.dbg	line,	"include\routines_LEVELS.c", 514; player_state = STATE_CROUCH;
 4418                        		__st.umiq	7, _player_state
         09:D927  A9 07      			lda.l	#7
         09:D929  8D 11 23   			sta	_player_state
 4419                        	
 4420                        		.dbg	line,	"include\routines_LEVELS.c", 515; return;
 4421                        		__bra		.LL92
         09:D92C  4C 94 DC   			bra	.LL92
 4422                        	
 4423                        		.dbg	line,	"include\routines_LEVELS.c", 516; }
 4424                        	
 4425                        		.dbg	line,	"include\routines_LEVELS.c", 518; player_state = STATE_WALK;
 4426    09:D92F             	.LL103:
 4427                        		__st.umiq	1, _player_state
         09:D92F  A9 01      			lda.l	#1
         09:D931  8D 11 23   			sta	_player_state
 4428                        	
 4429                        		.dbg	line,	"include\routines_LEVELS.c", 519; }
 4430                        	
 4431                        		.dbg	line,	"include\routines_LEVELS.c", 522; else if(player_state == STATE_JUMP || player_state == STATE_JUMP_LEFT || player_state == STATE_CROUCH || player_state == STATE_FALL || player_state == STATE_HANG)
 4432                        		__bra		.LL104
         09:D934  4C 94 DC   			bra	.LL104
 4433    09:D937             	.LL100:
 4434                        		__ld.umq	_player_state
         09:D937  AD 11 23   			lda	_player_state
 4435                        		__equ_b.uiq	4
         09:D93A  C9 04      			cmp	#4
         09:D93C  F0 01      			beq	!+
         09:D93E  18         			clc
         09:D93F             	!:
 4436                        		__btrue		.LL106
         09:D93F  B0 08      			bcs	.LL106
 4437                        		__ld.umq	_player_state
         09:D941  AD 11 23   			lda	_player_state
 4438                        		__equ_b.uiq	6
         09:D944  C9 06      			cmp	#6
         09:D946  F0 01      			beq	!+
         09:D948  18         			clc
         09:D949             	!:
 4439    09:D949             	.LL106:
 4440                        		__btrue		.LL107
         09:D949  B0 08      			bcs	.LL107
 4441                        		__ld.umq	_player_state
         09:D94B  AD 11 23   			lda	_player_state
 4442                        		__equ_b.uiq	7
         09:D94E  C9 07      			cmp	#7
         09:D950  F0 01      			beq	!+
         09:D952  18         			clc
         09:D953             	!:
 4443    09:D953             	.LL107:
 4444                        		__btrue		.LL108
         09:D953  B0 08      			bcs	.LL108
 4445                        		__ld.umq	_player_state
         09:D955  AD 11 23   			lda	_player_state
 4446                        		__equ_b.uiq	9
         09:D958  C9 09      			cmp	#9
         09:D95A  F0 01      			beq	!+
         09:D95C  18         			clc
         09:D95D             	!:
 4447    09:D95D             	.LL108:
 4448                        		__btrue		.LL109
         09:D95D  B0 08      			bcs	.LL109
 4449                        		__ld.umq	_player_state
         09:D95F  AD 11 23   			lda	_player_state
 4450                        		__equ_b.uiq	10
         09:D962  C9 0A      			cmp	#10
         09:D964  F0 01      			beq	!+
         09:D966  18         			clc
         09:D967             	!:
 4451    09:D967             	.LL109:
 4452                        		__bfalse	.LL105
         09:D967  90 28      			bcc	.LL105
 4453                        	
 4454                        		.dbg	line,	"include\routines_LEVELS.c", 523; {
 4455                        	
 4456                        		.dbg	line,	"include\routines_LEVELS.c", 524; if(player_axis == AXIS_LEFT)
 4457                        		__ld.umq	_player_axis
         09:D969  AD 12 23   			lda	_player_axis
 4458                        		__equ_b.uiq	1
         09:D96C  C9 01      			cmp	#1
         09:D96E  F0 01      			beq	!+
         09:D970  18         			clc
         09:D971             	!:
 4459                        		__bfalse	.LL110
         09:D971  B0 03 4C 94			bcc	.LL110
         09:D975  DC          
 4460                        	
 4461                        		.dbg	line,	"include\routines_LEVELS.c", 525; {
 4462                        	
 4463                        		.dbg	line,	"include\routines_LEVELS.c", 526; player_axis = AXIS_RIGHT;
 4464                        		__st.umiq	0, _player_axis
         09:D976  9C 12 23   			stz	_player_axis
 4465                        	
 4466                        		.dbg	line,	"include\routines_LEVELS.c", 527; player_previous_axis = player_axis;
 4467                        		__ld.um		_player_axis
         09:D979  AD 12 23   			lda	_player_axis
         09:D97C  C2         			cly
 4468                        		__st.umq	_player_previous_axis
         09:D97D  8D 13 23   			sta	_player_previous_axis
 4469                        	
 4470                        		.dbg	line,	"include\routines_LEVELS.c", 529; spr_set(player_id);
 4471                        		__ld.umq	_player_id
         09:D980  AD 10 23   			lda	_player_id
 4472                        		__call		_spr_set.1
         09:D983  20 DD E7   			call	_spr_set.1
 4473                        	
 4474                        		.dbg	line,	"include\routines_LEVELS.c", 530; spr_ctrl(FLIP_MAS, NO_FLIP_X);
 4475                        		__st.umiq	136, _al
         09:D986  A9 88      			lda.l	#136
         09:D988  85 F8      			sta	_al
 4476                        		__ld.uiq	0
         09:D98A  62         			cla
 4477                        		__call		_spr_ctrl.2
         09:D98B  20 3C E8   			call	_spr_ctrl.2
 4478                        	
 4479                        		.dbg	line,	"include\routines_LEVELS.c", 531; }
 4480                        	
 4481                        		.dbg	line,	"include\routines_LEVELS.c", 532; }
 4482    09:D98E             	.LL110	.alias		.LL111
 4483                        	
 4484                        		.dbg	line,	"include\routines_LEVELS.c", 535; else if(player_state == STATE_CLIMB_UP || player_state == STATE_CLIMB_DOWN)
 4485                        		__bra		.LL111
         09:D98E  4C 94 DC   			bra	.LL111
 4486    09:D991             	.LL105:
 4487                        		__ld.umq	_player_state
         09:D991  AD 11 23   			lda	_player_state
 4488                        		__equ_b.uiq	11
         09:D994  C9 0B      			cmp	#11
         09:D996  F0 01      			beq	!+
         09:D998  18         			clc
         09:D999             	!:
 4489                        		__btrue		.LL113
         09:D999  B0 08      			bcs	.LL113
 4490                        		__ld.umq	_player_state
         09:D99B  AD 11 23   			lda	_player_state
 4491                        		__equ_b.uiq	12
         09:D99E  C9 0C      			cmp	#12
         09:D9A0  F0 01      			beq	!+
         09:D9A2  18         			clc
         09:D9A3             	!:
 4492    09:D9A3             	.LL113:
 4493                        		__bfalse	.LL112
         09:D9A3  B0 03 4C 94			bcc	.LL112
         09:D9A7  DC          
 4494                        	
 4495                        		.dbg	line,	"include\routines_LEVELS.c", 536; {
 4496                        	
 4497                        		.dbg	line,	"include\routines_LEVELS.c", 537; player_counter_anim = 1;
 4498                        		__st.umiq	1, _player_counter_anim
         09:D9A8  A9 01      			lda.l	#1
         09:D9AA  8D 14 23   			sta	_player_counter_anim
 4499                        	
 4500                        		.dbg	line,	"include\routines_LEVELS.c", 538; player_state = STATE_HANG;
 4501                        		__st.umiq	10, _player_state
         09:D9AD  A9 0A      			lda.l	#10
         09:D9AF  8D 11 23   			sta	_player_state
 4502                        	
 4503                        		.dbg	line,	"include\routines_LEVELS.c", 539; }
 4504                        	
 4505                        		.dbg	line,	"include\routines_LEVELS.c", 540; }
 4506    09:D9B2             	.LL112	.alias		.LL114
 4507    09:D9B2             	.LL111	.alias		.LL114
 4508    09:D9B2             	.LL104	.alias		.LL114
 4509                        	
 4510                        		.dbg	line,	"include\routines_LEVELS.c", 543; //--------------------------------------------------------------------------------------//
 4511                        	
 4512                        		.dbg	line,	"include\routines_LEVELS.c", 544; //                                     LEFT BUTTON                                      //
 4513                        	
 4514                        		.dbg	line,	"include\routines_LEVELS.c", 545; //--------------------------------------------------------------------------------------//
 4515                        	
 4516                        		.dbg	line,	"include\routines_LEVELS.c", 547; else if(joy(JOYPAD_1) & JOY_LEFT)
 4517                        		__bra		.LL114
         09:D9B2  4C 94 DC   			bra	.LL114
 4518    09:D9B5             	.LL99:
 4519                        		__ld.uiq	0
         09:D9B5  62         			cla
 4520                        		 _joy.1
         09:D9B6  AA         			tax
         09:D9B7  BD 28 22   			lda	joynow, x
         09:D9BA  BC D3 22   			ldy	joy6now, x
 4521                        		__tand.wi	128
         09:D9BD  29 80      			and	#128
         09:D9BF  C9 01      	!:		cmp	#1
 4522                        		__bfalse	.LL115
         09:D9C1  B0 03 4C A3			bcc	.LL115
         09:D9C5  DA          
 4523                        	
 4524                        		.dbg	line,	"include\routines_LEVELS.c", 548; {
 4525                        	
 4526                        		.dbg	line,	"include\routines_LEVELS.c", 549; if(player_state == STATE_IDLE || player_state == STATE_WALK)
 4527                        		__not.um	_player_state
         09:D9C6  AD 11 23   			lda	_player_state
         09:D9C9  18         			clc
         09:D9CA  D0 01      			bne	!+
         09:D9CC  38         			sec
         09:D9CD             	!:
 4528                        		__btrue		.LL117
         09:D9CD  B0 08      			bcs	.LL117
 4529                        		__ld.umq	_player_state
         09:D9CF  AD 11 23   			lda	_player_state
 4530                        		__equ_b.uiq	1
         09:D9D2  C9 01      			cmp	#1
         09:D9D4  F0 01      			beq	!+
         09:D9D6  18         			clc
         09:D9D7             	!:
 4531    09:D9D7             	.LL117:
 4532                        		__bfalse	.LL116
         09:D9D7  90 4A      			bcc	.LL116
 4533                        	
 4534                        		.dbg	line,	"include\routines_LEVELS.c", 550; {
 4535                        	
 4536                        		.dbg	line,	"include\routines_LEVELS.c", 551; player_axis = AXIS_LEFT;
 4537                        		__st.umiq	1, _player_axis
         09:D9D9  A9 01      			lda.l	#1
         09:D9DB  8D 12 23   			sta	_player_axis
 4538                        	
 4539                        		.dbg	line,	"include\routines_LEVELS.c", 553; if(player_previous_axis != player_axis)
 4540                        		__ld.umq	_player_previous_axis
         09:D9DE  AD 13 23   			lda	_player_previous_axis
 4541                        		__neq_b.umq	_player_axis
         09:D9E1  38         			sec
         09:D9E2  4D 12 23   			eor	_player_axis
         09:D9E5  D0 01      			bne	!+
         09:D9E7  18         			clc
         09:D9E8             	!:
 4542                        		__bfalse	.LL118
         09:D9E8  90 16      			bcc	.LL118
 4543                        	
 4544                        		.dbg	line,	"include\routines_LEVELS.c", 554; {
 4545                        	
 4546                        		.dbg	line,	"include\routines_LEVELS.c", 555; player_previous_axis = player_axis;
 4547                        		__ld.um		_player_axis
         09:D9EA  AD 12 23   			lda	_player_axis
         09:D9ED  C2         			cly
 4548                        		__st.umq	_player_previous_axis
         09:D9EE  8D 13 23   			sta	_player_previous_axis
 4549                        	
 4550                        		.dbg	line,	"include\routines_LEVELS.c", 557; spr_set(player_id);
 4551                        		__ld.umq	_player_id
         09:D9F1  AD 10 23   			lda	_player_id
 4552                        		__call		_spr_set.1
         09:D9F4  20 DD E7   			call	_spr_set.1
 4553                        	
 4554                        		.dbg	line,	"include\routines_LEVELS.c", 558; spr_ctrl(FLIP_MAS, FLIP_X);
 4555                        		__st.umiq	136, _al
         09:D9F7  A9 88      			lda.l	#136
         09:D9F9  85 F8      			sta	_al
 4556                        		__ld.uiq	8
         09:D9FB  A9 08      			lda	#8
 4557                        		__call		_spr_ctrl.2
         09:D9FD  20 3C E8   			call	_spr_ctrl.2
 4558                        	
 4559                        		.dbg	line,	"include\routines_LEVELS.c", 559; }
 4560                        	
 4561                        		.dbg	line,	"include\routines_LEVELS.c", 561; if(joy(JOYPAD_1) & JOY_DOWN)
 4562    09:DA00             	.LL118:
 4563                        		__ld.uiq	0
         09:DA00  62         			cla
 4564                        		 _joy.1
         09:DA01  AA         			tax
         09:DA02  BD 28 22   			lda	joynow, x
         09:DA05  BC D3 22   			ldy	joy6now, x
 4565                        		__tand.wi	64
         09:DA08  29 40      			and	#64
         09:DA0A  C9 01      	!:		cmp	#1
 4566                        		__bfalse	.LL119
         09:DA0C  90 0D      			bcc	.LL119
 4567                        	
 4568                        		.dbg	line,	"include\routines_LEVELS.c", 562; {
 4569                        	
 4570                        		.dbg	line,	"include\routines_LEVELS.c", 563; player_counter_anim = 1;
 4571                        		__st.umiq	1, _player_counter_anim
         09:DA0E  A9 01      			lda.l	#1
         09:DA10  8D 14 23   			sta	_player_counter_anim
 4572                        	
 4573                        		.dbg	line,	"include\routines_LEVELS.c", 564; player_state = STATE_CROUCH;
 4574                        		__st.umiq	7, _player_state
         09:DA13  A9 07      			lda.l	#7
         09:DA15  8D 11 23   			sta	_player_state
 4575                        	
 4576                        		.dbg	line,	"include\routines_LEVELS.c", 565; return;
 4577                        		__bra		.LL92
         09:DA18  4C 94 DC   			bra	.LL92
 4578                        	
 4579                        		.dbg	line,	"include\routines_LEVELS.c", 566; }
 4580                        	
 4581                        		.dbg	line,	"include\routines_LEVELS.c", 568; player_state = STATE_WALK;
 4582    09:DA1B             	.LL119:
 4583                        		__st.umiq	1, _player_state
         09:DA1B  A9 01      			lda.l	#1
         09:DA1D  8D 11 23   			sta	_player_state
 4584                        	
 4585                        		.dbg	line,	"include\routines_LEVELS.c", 569; }
 4586                        	
 4587                        		.dbg	line,	"include\routines_LEVELS.c", 572; else if(player_state == STATE_JUMP || player_state == STATE_JUMP_RIGHT || player_state == STATE_CROUCH || player_state == STATE_FALL || player_state == STATE_HANG)
 4588                        		__bra		.LL120
         09:DA20  4C 94 DC   			bra	.LL120
 4589    09:DA23             	.LL116:
 4590                        		__ld.umq	_player_state
         09:DA23  AD 11 23   			lda	_player_state
 4591                        		__equ_b.uiq	4
         09:DA26  C9 04      			cmp	#4
         09:DA28  F0 01      			beq	!+
         09:DA2A  18         			clc
         09:DA2B             	!:
 4592                        		__btrue		.LL122
         09:DA2B  B0 08      			bcs	.LL122
 4593                        		__ld.umq	_player_state
         09:DA2D  AD 11 23   			lda	_player_state
 4594                        		__equ_b.uiq	5
         09:DA30  C9 05      			cmp	#5
         09:DA32  F0 01      			beq	!+
         09:DA34  18         			clc
         09:DA35             	!:
 4595    09:DA35             	.LL122:
 4596                        		__btrue		.LL123
         09:DA35  B0 08      			bcs	.LL123
 4597                        		__ld.umq	_player_state
         09:DA37  AD 11 23   			lda	_player_state
 4598                        		__equ_b.uiq	7
         09:DA3A  C9 07      			cmp	#7
         09:DA3C  F0 01      			beq	!+
         09:DA3E  18         			clc
         09:DA3F             	!:
 4599    09:DA3F             	.LL123:
 4600                        		__btrue		.LL124
         09:DA3F  B0 08      			bcs	.LL124
 4601                        		__ld.umq	_player_state
         09:DA41  AD 11 23   			lda	_player_state
 4602                        		__equ_b.uiq	9
         09:DA44  C9 09      			cmp	#9
         09:DA46  F0 01      			beq	!+
         09:DA48  18         			clc
         09:DA49             	!:
 4603    09:DA49             	.LL124:
 4604                        		__btrue		.LL125
         09:DA49  B0 08      			bcs	.LL125
 4605                        		__ld.umq	_player_state
         09:DA4B  AD 11 23   			lda	_player_state
 4606                        		__equ_b.uiq	10
         09:DA4E  C9 0A      			cmp	#10
         09:DA50  F0 01      			beq	!+
         09:DA52  18         			clc
         09:DA53             	!:
 4607    09:DA53             	.LL125:
 4608                        		__bfalse	.LL121
         09:DA53  90 2A      			bcc	.LL121
 4609                        	
 4610                        		.dbg	line,	"include\routines_LEVELS.c", 573; {
 4611                        	
 4612                        		.dbg	line,	"include\routines_LEVELS.c", 574; if(player_axis == AXIS_RIGHT)
 4613                        		__not.um	_player_axis
         09:DA55  AD 12 23   			lda	_player_axis
         09:DA58  18         			clc
         09:DA59  D0 01      			bne	!+
         09:DA5B  38         			sec
         09:DA5C             	!:
 4614                        		__bfalse	.LL126
         09:DA5C  B0 03 4C 94			bcc	.LL126
         09:DA60  DC          
 4615                        	
 4616                        		.dbg	line,	"include\routines_LEVELS.c", 575; {
 4617                        	
 4618                        		.dbg	line,	"include\routines_LEVELS.c", 576; player_axis = AXIS_LEFT;
 4619                        		__st.umiq	1, _player_axis
         09:DA61  A9 01      			lda.l	#1
         09:DA63  8D 12 23   			sta	_player_axis
 4620                        	
 4621                        		.dbg	line,	"include\routines_LEVELS.c", 577; player_previous_axis = player_axis;
 4622                        		__ld.um		_player_axis
         09:DA66  AD 12 23   			lda	_player_axis
         09:DA69  C2         			cly
 4623                        		__st.umq	_player_previous_axis
         09:DA6A  8D 13 23   			sta	_player_previous_axis
 4624                        	
 4625                        		.dbg	line,	"include\routines_LEVELS.c", 579; spr_set(player_id);
 4626                        		__ld.umq	_player_id
         09:DA6D  AD 10 23   			lda	_player_id
 4627                        		__call		_spr_set.1
         09:DA70  20 DD E7   			call	_spr_set.1
 4628                        	
 4629                        		.dbg	line,	"include\routines_LEVELS.c", 580; spr_ctrl(FLIP_MAS, FLIP_X);
 4630                        		__st.umiq	136, _al
         09:DA73  A9 88      			lda.l	#136
         09:DA75  85 F8      			sta	_al
 4631                        		__ld.uiq	8
         09:DA77  A9 08      			lda	#8
 4632                        		__call		_spr_ctrl.2
         09:DA79  20 3C E8   			call	_spr_ctrl.2
 4633                        	
 4634                        		.dbg	line,	"include\routines_LEVELS.c", 581; }
 4635                        	
 4636                        		.dbg	line,	"include\routines_LEVELS.c", 582; }
 4637    09:DA7C             	.LL126	.alias		.LL127
 4638                        	
 4639                        		.dbg	line,	"include\routines_LEVELS.c", 585; else if(player_state == STATE_CLIMB_UP || player_state == STATE_CLIMB_DOWN)
 4640                        		__bra		.LL127
         09:DA7C  4C 94 DC   			bra	.LL127
 4641    09:DA7F             	.LL121:
 4642                        		__ld.umq	_player_state
         09:DA7F  AD 11 23   			lda	_player_state
 4643                        		__equ_b.uiq	11
         09:DA82  C9 0B      			cmp	#11
         09:DA84  F0 01      			beq	!+
         09:DA86  18         			clc
         09:DA87             	!:
 4644                        		__btrue		.LL129
         09:DA87  B0 08      			bcs	.LL129
 4645                        		__ld.umq	_player_state
         09:DA89  AD 11 23   			lda	_player_state
 4646                        		__equ_b.uiq	12
         09:DA8C  C9 0C      			cmp	#12
         09:DA8E  F0 01      			beq	!+
         09:DA90  18         			clc
         09:DA91             	!:
 4647    09:DA91             	.LL129:
 4648                        		__bfalse	.LL128
         09:DA91  B0 03 4C 94			bcc	.LL128
         09:DA95  DC          
 4649                        	
 4650                        		.dbg	line,	"include\routines_LEVELS.c", 586; {
 4651                        	
 4652                        		.dbg	line,	"include\routines_LEVELS.c", 587; player_counter_anim = 1;
 4653                        		__st.umiq	1, _player_counter_anim
         09:DA96  A9 01      			lda.l	#1
         09:DA98  8D 14 23   			sta	_player_counter_anim
 4654                        	
 4655                        		.dbg	line,	"include\routines_LEVELS.c", 588; player_state = STATE_HANG;
 4656                        		__st.umiq	10, _player_state
         09:DA9B  A9 0A      			lda.l	#10
         09:DA9D  8D 11 23   			sta	_player_state
 4657                        	
 4658                        		.dbg	line,	"include\routines_LEVELS.c", 589; }
 4659                        	
 4660                        		.dbg	line,	"include\routines_LEVELS.c", 590; }
 4661    09:DAA0             	.LL128	.alias		.LL130
 4662    09:DAA0             	.LL127	.alias		.LL130
 4663    09:DAA0             	.LL120	.alias		.LL130
 4664                        	
 4665                        		.dbg	line,	"include\routines_LEVELS.c", 593; //--------------------------------------------------------------------------------------//
 4666                        	
 4667                        		.dbg	line,	"include\routines_LEVELS.c", 594; //                                      UP BUTTON                                       //
 4668                        	
 4669                        		.dbg	line,	"include\routines_LEVELS.c", 595; //--------------------------------------------------------------------------------------//
 4670                        	
 4671                        		.dbg	line,	"include\routines_LEVELS.c", 597; else if(joy(JOYPAD_1) & JOY_UP)
 4672                        		__bra		.LL130
         09:DAA0  4C 94 DC   			bra	.LL130
 4673    09:DAA3             	.LL115:
 4674                        		__ld.uiq	0
         09:DAA3  62         			cla
 4675                        		 _joy.1
         09:DAA4  AA         			tax
         09:DAA5  BD 28 22   			lda	joynow, x
         09:DAA8  BC D3 22   			ldy	joy6now, x
 4676                        		__tand.wi	16
         09:DAAB  29 10      			and	#16
         09:DAAD  C9 01      	!:		cmp	#1
 4677                        		__bfalse	.LL131
         09:DAAF  B0 03 4C 78			bcc	.LL131
         09:DAB3  DB          
 4678                        	
 4679                        		.dbg	line,	"include\routines_LEVELS.c", 598; {
 4680                        	
 4681                        		.dbg	line,	"include\routines_LEVELS.c", 599; if(player_state == STATE_HANG || player_state == STATE_CLIMB_UP || player_state == STATE_CLIMB_DOWN)
 4682                        		__ld.umq	_player_state
         09:DAB4  AD 11 23   			lda	_player_state
 4683                        		__equ_b.uiq	10
         09:DAB7  C9 0A      			cmp	#10
         09:DAB9  F0 01      			beq	!+
         09:DABB  18         			clc
         09:DABC             	!:
 4684                        		__btrue		.LL133
         09:DABC  B0 08      			bcs	.LL133
 4685                        		__ld.umq	_player_state
         09:DABE  AD 11 23   			lda	_player_state
 4686                        		__equ_b.uiq	11
         09:DAC1  C9 0B      			cmp	#11
         09:DAC3  F0 01      			beq	!+
         09:DAC5  18         			clc
         09:DAC6             	!:
 4687    09:DAC6             	.LL133:
 4688                        		__btrue		.LL134
         09:DAC6  B0 08      			bcs	.LL134
 4689                        		__ld.umq	_player_state
         09:DAC8  AD 11 23   			lda	_player_state
 4690                        		__equ_b.uiq	12
         09:DACB  C9 0C      			cmp	#12
         09:DACD  F0 01      			beq	!+
         09:DACF  18         			clc
         09:DAD0             	!:
 4691    09:DAD0             	.LL134:
 4692                        		__bfalse	.LL132
         09:DAD0  B0 03 4C 94			bcc	.LL132
         09:DAD4  DC          
 4693                        	
 4694                        		.dbg	line,	"include\routines_LEVELS.c", 600; {
 4695                        	
 4696                        		.dbg	line,	"include\routines_LEVELS.c", 601; unsigned char i;
 4697                        	
 4698                        		.dbg	line,	"include\routines_LEVELS.c", 603; check_BG( 15 , 8 );
 4699                        		__ld.wi		15
         09:DAD5  A9 0F      			lda.l	#15
         09:DAD7  C2         			cly
 4700                        		__pusharg.wr
         09:DAD8  A6 8D      			ldx	<__sp
         09:DADA  CA         			dex
         09:DADB  CA         			dex
         09:DADC  95 08      			sta.l	<__stack, x
         09:DADE  94 09      			sty.h	<__stack, x
         09:DAE0  86 8D      			stx	<__sp
 4701                        		__ld.wi		8
         09:DAE2  A9 08      			lda.l	#8
         09:DAE4  C2         			cly
 4702                        		__pusharg.wr
         09:DAE5  A6 8D      			ldx	<__sp
         09:DAE7  CA         			dex
         09:DAE8  CA         			dex
         09:DAE9  95 08      			sta.l	<__stack, x
         09:DAEB  94 09      			sty.h	<__stack, x
         09:DAED  86 8D      			stx	<__sp
 4703                        		__call		_check_BG
         09:DAEF  20 6D FF   			call	_check_BG
 4704                        	
 4705                        		.dbg	line,	"include\routines_LEVELS.c", 605; if(map_blk_flag == TILE_EMPTY)
 4706                        		__not.um	_map_blk_flag
         09:DAF2  AD 76 2A   			lda	_map_blk_flag
         09:DAF5  18         			clc
         09:DAF6  D0 01      			bne	!+
         09:DAF8  38         			sec
         09:DAF9             	!:
 4707                        		__bfalse	.LL135
         09:DAF9  90 67      			bcc	.LL135
 4708                        	
 4709                        		.dbg	line,	"include\routines_LEVELS.c", 606; {
 4710                        	
 4711                        		.dbg	line,	"include\routines_LEVELS.c", 607; for(i=1 ; i<3 ; i++)
 4712                        		__st.umiq	1, __joypad_DIR_end - 1  /* i */
         09:DAFB  A9 01      			lda.l	#1
         09:DAFD  8D 04 23   			sta	__joypad_DIR_end - 1
 4713    09:DB00             	.LL136:
 4714                        		__ld.umq	__joypad_DIR_end - 1  /* i */
         09:DB00  AD 04 23   			lda	__joypad_DIR_end - 1
 4715                        		__ult_b.uiq	3
         09:DB03  C9 03      			cmp	#3		; Subtract integer from A.
         09:DB05  6A         			ror	a		; CC if A < integer.
         09:DB06  49 80      			eor	#$80
         09:DB08  2A         			rol	a
 4716                        		__btrue		.LL138
         09:DB09  B0 07      			bcs	.LL138
 4717                        		__bra		.LL139
         09:DB0B  80 63      			bra	.LL139
 4718    09:DB0D             	.LL137:
 4719                        		__inc.umq	__joypad_DIR_end - 1  /* i */
         09:DB0D  EE 04 23   			inc	__joypad_DIR_end - 1
 4720                        		__bra		.LL136
         09:DB10  80 EE      			bra	.LL136
 4721    09:DB12             	.LL138:
 4722                        	
 4723                        		.dbg	line,	"include\routines_LEVELS.c", 608; {
 4724                        	
 4725                        		.dbg	line,	"include\routines_LEVELS.c", 609; check_BG( 15 , 8 + i );
 4726                        		__ld.wi		15
         09:DB12  A9 0F      			lda.l	#15
         09:DB14  C2         			cly
 4727                        		__pusharg.wr
         09:DB15  A6 8D      			ldx	<__sp
         09:DB17  CA         			dex
         09:DB18  CA         			dex
         09:DB19  95 08      			sta.l	<__stack, x
         09:DB1B  94 09      			sty.h	<__stack, x
         09:DB1D  86 8D      			stx	<__sp
 4728                        		__ld.wi		8
         09:DB1F  A9 08      			lda.l	#8
         09:DB21  C2         			cly
 4729                        		__add.um	__joypad_DIR_end - 1  /* i */
         09:DB22  18         			clc
         09:DB23  6D 04 23   			adc	__joypad_DIR_end - 1
         09:DB26  90 01      			bcc	!+
         09:DB28  C8         			iny
         09:DB29             	!:
 4730                        		__pusharg.wr
         09:DB29  A6 8D      			ldx	<__sp
         09:DB2B  CA         			dex
         09:DB2C  CA         			dex
         09:DB2D  95 08      			sta.l	<__stack, x
         09:DB2F  94 09      			sty.h	<__stack, x
         09:DB31  86 8D      			stx	<__sp
 4731                        		__call		_check_BG
         09:DB33  20 6D FF   			call	_check_BG
 4732                        	
 4733                        		.dbg	line,	"include\routines_LEVELS.c", 611; if(map_blk_flag == TILE_LADDER)
 4734                        		__ld.umq	_map_blk_flag
         09:DB36  AD 76 2A   			lda	_map_blk_flag
 4735                        		__equ_b.uiq	2
         09:DB39  C9 02      			cmp	#2
         09:DB3B  F0 01      			beq	!+
         09:DB3D  18         			clc
         09:DB3E             	!:
 4736                        		__bfalse	.LL140
         09:DB3E  90 CD      			bcc	.LL140
 4737                        	
 4738                        		.dbg	line,	"include\routines_LEVELS.c", 612; {
 4739                        	
 4740                        		.dbg	line,	"include\routines_LEVELS.c", 613; sgx_map_pxl_y -= (2 - i);
 4741                        		__ld.wi		2
         09:DB40  A9 02      			lda.l	#2
         09:DB42  C2         			cly
 4742                        		__sub.um	__joypad_DIR_end - 1  /* i */
         09:DB43  38         			sec
         09:DB44  ED 04 23   			sbc	__joypad_DIR_end - 1
         09:DB47  B0 01      			bcs	!+
         09:DB49  88         			dey
         09:DB4A             	!:
 4743                        		__isub_st.wmq	_sgx_map_pxl_y
         09:DB4A  38         			sec
         09:DB4B  49 FF      			eor	#$FF
         09:DB4D  6D 57 25   			adc.l	_sgx_map_pxl_y
         09:DB50  8D 57 25   			sta.l	_sgx_map_pxl_y
         09:DB53  98         			tya
         09:DB54  49 FF      			eor	#$FF
         09:DB56  6D 58 25   			adc.h	_sgx_map_pxl_y
         09:DB59  8D 58 25   			sta.h	_sgx_map_pxl_y
 4744                        	
 4745                        		.dbg	line,	"include\routines_LEVELS.c", 614; break;
 4746                        		__bra		.LL139
         09:DB5C  80 12      			bra	.LL139
 4747                        	
 4748                        		.dbg	line,	"include\routines_LEVELS.c", 615; }
 4749                        	
 4750                        		.dbg	line,	"include\routines_LEVELS.c", 616; }
 4751    09:DB5E             	.LL140	.alias		.LL137
 4752                        		__bra		.LL137
         09:DB5E  80 AD      			bra	.LL137
 4753    09:DB60             	.LL139	.alias		.LL141
 4754                        	
 4755                        		.dbg	line,	"include\routines_LEVELS.c", 617; }
 4756                        	
 4757                        		.dbg	line,	"include\routines_LEVELS.c", 619; else
 4758                        		__bra		.LL141
         09:DB60  80 0E      			bra	.LL141
 4759    09:DB62             	.LL135:
 4760                        	
 4761                        		.dbg	line,	"include\routines_LEVELS.c", 620; {
 4762                        	
 4763                        		.dbg	line,	"include\routines_LEVELS.c", 621; sgx_map_pxl_y -= 2;
 4764                        		__sub_st.wmiq	2, _sgx_map_pxl_y
         09:DB62  38         			sec
         09:DB63  AD 57 25   			lda.l	_sgx_map_pxl_y
         09:DB66  E9 02      			sbc.l	#2
         09:DB68  8D 57 25   			sta.l	_sgx_map_pxl_y
         09:DB6B  B0 03      			bcs	!+
         09:DB6D  CE 58 25   			dec.h	_sgx_map_pxl_y
         09:DB70             	!:
 4765                        	
 4766                        		.dbg	line,	"include\routines_LEVELS.c", 622; }
 4767    09:DB70             	.LL141:
 4768                        	
 4769                        		.dbg	line,	"include\routines_LEVELS.c", 624; player_state = STATE_CLIMB_UP;
 4770                        		__st.umiq	11, _player_state
         09:DB70  A9 0B      			lda.l	#11
         09:DB72  8D 11 23   			sta	_player_state
 4771                        	
 4772                        		.dbg	line,	"include\routines_LEVELS.c", 625; }
 4773                        	
 4774                        		.dbg	line,	"include\routines_LEVELS.c", 626; }
 4775    09:DB75             	.LL132	.alias		.LL142
 4776                        	
 4777                        		.dbg	line,	"include\routines_LEVELS.c", 629; //--------------------------------------------------------------------------------------//
 4778                        	
 4779                        		.dbg	line,	"include\routines_LEVELS.c", 630; //                                     DOWN BUTTON                                      //
 4780                        	
 4781                        		.dbg	line,	"include\routines_LEVELS.c", 631; //--------------------------------------------------------------------------------------//
 4782                        	
 4783                        		.dbg	line,	"include\routines_LEVELS.c", 633; else if(joy(JOYPAD_1) & JOY_DOWN)
 4784                        		__bra		.LL142
         09:DB75  4C 94 DC   			bra	.LL142
 4785    09:DB78             	.LL131:
 4786                        		__ld.uiq	0
         09:DB78  62         			cla
 4787                        		 _joy.1
         09:DB79  AA         			tax
         09:DB7A  BD 28 22   			lda	joynow, x
         09:DB7D  BC D3 22   			ldy	joy6now, x
 4788                        		__tand.wi	64
         09:DB80  29 40      			and	#64
         09:DB82  C9 01      	!:		cmp	#1
 4789                        		__bfalse	.LL143
         09:DB84  B0 03 4C 94			bcc	.LL143
         09:DB88  DC          
 4790                        	
 4791                        		.dbg	line,	"include\routines_LEVELS.c", 634; {
 4792                        	
 4793                        		.dbg	line,	"include\routines_LEVELS.c", 635; if(player_state == STATE_IDLE || player_state == STATE_WALK)
 4794                        		__not.um	_player_state
         09:DB89  AD 11 23   			lda	_player_state
         09:DB8C  18         			clc
         09:DB8D  D0 01      			bne	!+
         09:DB8F  38         			sec
         09:DB90             	!:
 4795                        		__btrue		.LL145
         09:DB90  B0 08      			bcs	.LL145
 4796                        		__ld.umq	_player_state
         09:DB92  AD 11 23   			lda	_player_state
 4797                        		__equ_b.uiq	1
         09:DB95  C9 01      			cmp	#1
         09:DB97  F0 01      			beq	!+
         09:DB99  18         			clc
         09:DB9A             	!:
 4798    09:DB9A             	.LL145:
 4799                        		__bfalse	.LL144
         09:DB9A  90 0D      			bcc	.LL144
 4800                        	
 4801                        		.dbg	line,	"include\routines_LEVELS.c", 636; {
 4802                        	
 4803                        		.dbg	line,	"include\routines_LEVELS.c", 637; player_counter_anim = 1;
 4804                        		__st.umiq	1, _player_counter_anim
         09:DB9C  A9 01      			lda.l	#1
         09:DB9E  8D 14 23   			sta	_player_counter_anim
 4805                        	
 4806                        		.dbg	line,	"include\routines_LEVELS.c", 638; player_state = STATE_CROUCH;
 4807                        		__st.umiq	7, _player_state
         09:DBA1  A9 07      			lda.l	#7
         09:DBA3  8D 11 23   			sta	_player_state
 4808                        	
 4809                        		.dbg	line,	"include\routines_LEVELS.c", 639; }
 4810                        	
 4811                        		.dbg	line,	"include\routines_LEVELS.c", 642; else if(player_state == STATE_HANG || player_state == STATE_CLIMB_UP || player_state == STATE_CLIMB_DOWN)
 4812                        		__bra		.LL146
         09:DBA6  4C 94 DC   			bra	.LL146
 4813    09:DBA9             	.LL144:
 4814                        		__ld.umq	_player_state
         09:DBA9  AD 11 23   			lda	_player_state
 4815                        		__equ_b.uiq	10
         09:DBAC  C9 0A      			cmp	#10
         09:DBAE  F0 01      			beq	!+
         09:DBB0  18         			clc
         09:DBB1             	!:
 4816                        		__btrue		.LL148
         09:DBB1  B0 08      			bcs	.LL148
 4817                        		__ld.umq	_player_state
         09:DBB3  AD 11 23   			lda	_player_state
 4818                        		__equ_b.uiq	11
         09:DBB6  C9 0B      			cmp	#11
         09:DBB8  F0 01      			beq	!+
         09:DBBA  18         			clc
         09:DBBB             	!:
 4819    09:DBBB             	.LL148:
 4820                        		__btrue		.LL149
         09:DBBB  B0 08      			bcs	.LL149
 4821                        		__ld.umq	_player_state
         09:DBBD  AD 11 23   			lda	_player_state
 4822                        		__equ_b.uiq	12
         09:DBC0  C9 0C      			cmp	#12
         09:DBC2  F0 01      			beq	!+
         09:DBC4  18         			clc
         09:DBC5             	!:
 4823    09:DBC5             	.LL149:
 4824                        		__bfalse	.LL147
         09:DBC5  B0 03 4C 94			bcc	.LL147
         09:DBC9  DC          
 4825                        	
 4826                        		.dbg	line,	"include\routines_LEVELS.c", 643; {
 4827                        	
 4828                        		.dbg	line,	"include\routines_LEVELS.c", 644; unsigned char i;
 4829                        	
 4830                        		.dbg	line,	"include\routines_LEVELS.c", 646; check_BG( 15 , 10 );
 4831                        		__ld.wi		15
         09:DBCA  A9 0F      			lda.l	#15
         09:DBCC  C2         			cly
 4832                        		__pusharg.wr
         09:DBCD  A6 8D      			ldx	<__sp
         09:DBCF  CA         			dex
         09:DBD0  CA         			dex
         09:DBD1  95 08      			sta.l	<__stack, x
         09:DBD3  94 09      			sty.h	<__stack, x
         09:DBD5  86 8D      			stx	<__sp
 4833                        		__ld.wi		10
         09:DBD7  A9 0A      			lda.l	#10
         09:DBD9  C2         			cly
 4834                        		__pusharg.wr
         09:DBDA  A6 8D      			ldx	<__sp
         09:DBDC  CA         			dex
         09:DBDD  CA         			dex
         09:DBDE  95 08      			sta.l	<__stack, x
         09:DBE0  94 09      			sty.h	<__stack, x
         09:DBE2  86 8D      			stx	<__sp
 4835                        		__call		_check_BG
         09:DBE4  20 6D FF   			call	_check_BG
 4836                        	
 4837                        		.dbg	line,	"include\routines_LEVELS.c", 648; if(map_blk_flag == TILE_EMPTY)
 4838                        		__not.um	_map_blk_flag
         09:DBE7  AD 76 2A   			lda	_map_blk_flag
         09:DBEA  18         			clc
         09:DBEB  D0 01      			bne	!+
         09:DBED  38         			sec
         09:DBEE             	!:
 4839                        		__bfalse	.LL150
         09:DBEE  B0 03 4C 81			bcc	.LL150
         09:DBF2  DC          
 4840                        	
 4841                        		.dbg	line,	"include\routines_LEVELS.c", 649; {
 4842                        	
 4843                        		.dbg	line,	"include\routines_LEVELS.c", 650; for(i=1 ; i<3 ; i++)
 4844                        		__st.umiq	1, __joypad_DIR_end - 2  /* i */
         09:DBF3  A9 01      			lda.l	#1
         09:DBF5  8D 03 23   			sta	__joypad_DIR_end - 2
 4845    09:DBF8             	.LL151:
 4846                        		__ld.umq	__joypad_DIR_end - 2  /* i */
         09:DBF8  AD 03 23   			lda	__joypad_DIR_end - 2
 4847                        		__ult_b.uiq	3
         09:DBFB  C9 03      			cmp	#3		; Subtract integer from A.
         09:DBFD  6A         			ror	a		; CC if A < integer.
         09:DBFE  49 80      			eor	#$80
         09:DC00  2A         			rol	a
 4848                        		__btrue		.LL153
         09:DC01  B0 08      			bcs	.LL153
 4849                        		__bra		.LL154
         09:DC03  4C 94 DC   			bra	.LL154
 4850    09:DC06             	.LL152:
 4851                        		__inc.umq	__joypad_DIR_end - 2  /* i */
         09:DC06  EE 03 23   			inc	__joypad_DIR_end - 2
 4852                        		__bra		.LL151
         09:DC09  80 ED      			bra	.LL151
 4853    09:DC0B             	.LL153:
 4854                        	
 4855                        		.dbg	line,	"include\routines_LEVELS.c", 651; {
 4856                        	
 4857                        		.dbg	line,	"include\routines_LEVELS.c", 652; check_BG( 15 , 22 + i );
 4858                        		__ld.wi		15
         09:DC0B  A9 0F      			lda.l	#15
         09:DC0D  C2         			cly
 4859                        		__pusharg.wr
         09:DC0E  A6 8D      			ldx	<__sp
         09:DC10  CA         			dex
         09:DC11  CA         			dex
         09:DC12  95 08      			sta.l	<__stack, x
         09:DC14  94 09      			sty.h	<__stack, x
         09:DC16  86 8D      			stx	<__sp
 4860                        		__ld.wi		22
         09:DC18  A9 16      			lda.l	#22
         09:DC1A  C2         			cly
 4861                        		__add.um	__joypad_DIR_end - 2  /* i */
         09:DC1B  18         			clc
         09:DC1C  6D 03 23   			adc	__joypad_DIR_end - 2
         09:DC1F  90 01      			bcc	!+
         09:DC21  C8         			iny
         09:DC22             	!:
 4862                        		__pusharg.wr
         09:DC22  A6 8D      			ldx	<__sp
         09:DC24  CA         			dex
         09:DC25  CA         			dex
         09:DC26  95 08      			sta.l	<__stack, x
         09:DC28  94 09      			sty.h	<__stack, x
         09:DC2A  86 8D      			stx	<__sp
 4863                        		__call		_check_BG
         09:DC2C  20 6D FF   			call	_check_BG
 4864                        	
 4865                        		.dbg	line,	"include\routines_LEVELS.c", 654; if(map_blk_flag == TILE_LADDER)
 4866                        		__ld.umq	_map_blk_flag
         09:DC2F  AD 76 2A   			lda	_map_blk_flag
 4867                        		__equ_b.uiq	2
         09:DC32  C9 02      			cmp	#2
         09:DC34  F0 01      			beq	!+
         09:DC36  18         			clc
         09:DC37             	!:
 4868                        		__bfalse	.LL155
         09:DC37  90 1A      			bcc	.LL155
 4869                        	
 4870                        		.dbg	line,	"include\routines_LEVELS.c", 655; {
 4871                        	
 4872                        		.dbg	line,	"include\routines_LEVELS.c", 656; sgx_map_pxl_y += (2 - i);
 4873                        		__ld.wi		2
         09:DC39  A9 02      			lda.l	#2
         09:DC3B  C2         			cly
 4874                        		__sub.um	__joypad_DIR_end - 2  /* i */
         09:DC3C  38         			sec
         09:DC3D  ED 03 23   			sbc	__joypad_DIR_end - 2
         09:DC40  B0 01      			bcs	!+
         09:DC42  88         			dey
         09:DC43             	!:
 4875                        		__add_st.wmq	_sgx_map_pxl_y
         09:DC43  18         			clc
         09:DC44  6D 57 25   			adc.l	_sgx_map_pxl_y
         09:DC47  8D 57 25   			sta.l	_sgx_map_pxl_y
         09:DC4A  98         			tya
         09:DC4B  6D 58 25   			adc.h	_sgx_map_pxl_y
         09:DC4E  8D 58 25   			sta.h	_sgx_map_pxl_y
 4876                        	
 4877                        		.dbg	line,	"include\routines_LEVELS.c", 657; break;
 4878                        		__bra		.LL154
         09:DC51  80 41      			bra	.LL154
 4879                        	
 4880                        		.dbg	line,	"include\routines_LEVELS.c", 658; }
 4881                        	
 4882                        		.dbg	line,	"include\routines_LEVELS.c", 660; else
 4883    09:DC53             	.LL155:
 4884                        	
 4885                        		.dbg	line,	"include\routines_LEVELS.c", 661; {
 4886                        	
 4887                        		.dbg	line,	"include\routines_LEVELS.c", 662; load_vram(PLAYER_VRAM_ADR, tiles_SPR_PLAYER + TILES_224 , TILES_16);
 4888                        		__st.wmiq	6144, _di
         09:DC53  64 F0      			stz.l	_di
         09:DC55  A9 18      			lda.h	#6144
         09:DC57  85 F1      			sta.h	_di
 4889                        		__farptr	_tiles_SPR_PLAYER + 7168 + 512, _bp_bank, _bp
         09:DC59  A9 A0      			lda.l	#$6000 + ($1FFF & (_tiles_SPR_PLAYER + 7168 + 512))
         09:DC5B  85 EC      			sta.l	_bp
         09:DC5D  A9 78      			lda.h	#$6000 + ($1FFF & (_tiles_SPR_PLAYER + 7168 + 512))
         09:DC5F  85 ED      			sta.h	_bp
         09:DC61  A9 0C      			lda	#bank(_tiles_SPR_PLAYER + 7168 + 512)
         09:DC63  85 02      			sta	_bp_bank
 4890                        		__st.wmiq	256, _ax
         09:DC65  64 F8      			stz.l	_ax
         09:DC67  A9 01      			lda.h	#256
         09:DC69  85 F9      			sta.h	_ax
 4891                        		 _load_vram.3
         09:DC6B  82         			clx				; Offset to PCE VDC.
         09:DC6C  20 63 FF   			call	load_vram_x
 4892                        	
 4893                        		.dbg	line,	"include\routines_LEVELS.c", 664; jump_ladder = FALSE;
 4894                        		__st.umiq	0, _jump_ladder
         09:DC6F  9C 17 23   			stz	_jump_ladder
 4895                        	
 4896                        		.dbg	line,	"include\routines_LEVELS.c", 665; player_index_jump = 0;
 4897                        		__st.umiq	0, _player_index_jump
         09:DC72  9C 15 23   			stz	_player_index_jump
 4898                        	
 4899                        		.dbg	line,	"include\routines_LEVELS.c", 666; player_index_fall = 0;
 4900                        		__st.umiq	0, _player_index_fall
         09:DC75  9C 16 23   			stz	_player_index_fall
 4901                        	
 4902                        		.dbg	line,	"include\routines_LEVELS.c", 667; player_state = STATE_FALL;
 4903                        		__st.umiq	9, _player_state
         09:DC78  A9 09      			lda.l	#9
         09:DC7A  8D 11 23   			sta	_player_state
 4904                        	
 4905                        		.dbg	line,	"include\routines_LEVELS.c", 668; }
 4906    09:DC7D             	.LL156	.alias		.LL152
 4907                        	
 4908                        		.dbg	line,	"include\routines_LEVELS.c", 669; }
 4909                        		__bra		.LL152
         09:DC7D  80 87      			bra	.LL152
 4910    09:DC7F             	.LL154	.alias		.LL157
 4911                        	
 4912                        		.dbg	line,	"include\routines_LEVELS.c", 670; }
 4913                        	
 4914                        		.dbg	line,	"include\routines_LEVELS.c", 672; else
 4915                        		__bra		.LL157
         09:DC7F  80 13      			bra	.LL157
 4916    09:DC81             	.LL150:
 4917                        	
 4918                        		.dbg	line,	"include\routines_LEVELS.c", 673; {
 4919                        	
 4920                        		.dbg	line,	"include\routines_LEVELS.c", 674; sgx_map_pxl_y += 2;
 4921                        		__add_st.wmiq	2, _sgx_map_pxl_y
         09:DC81  18         			clc
         09:DC82  AD 57 25   			lda.l	_sgx_map_pxl_y
         09:DC85  69 02      			adc.l	#2
         09:DC87  8D 57 25   			sta.l	_sgx_map_pxl_y
         09:DC8A  90 03      			bcc	!+
         09:DC8C  EE 58 25   			inc.h	_sgx_map_pxl_y
         09:DC8F             	!:
 4922                        	
 4923                        		.dbg	line,	"include\routines_LEVELS.c", 675; player_state = STATE_CLIMB_DOWN;
 4924                        		__st.umiq	12, _player_state
         09:DC8F  A9 0C      			lda.l	#12
         09:DC91  8D 11 23   			sta	_player_state
 4925                        	
 4926                        		.dbg	line,	"include\routines_LEVELS.c", 676; }
 4927    09:DC94             	.LL157:
 4928                        	
 4929                        		.dbg	line,	"include\routines_LEVELS.c", 677; }
 4930                        	
 4931                        		.dbg	line,	"include\routines_LEVELS.c", 678; }
 4932    09:DC94             	.LL147:
 4933    09:DC94             	.LL146:
 4934                        	
 4935                        		.dbg	line,	"include\routines_LEVELS.c", 679; }
 4936    09:DC94             	.LL143:
 4937    09:DC94             	.LL142:
 4938    09:DC94             	.LL130:
 4939    09:DC94             	.LL114:
 4940    09:DC94             	.LL92:
 4941                        		__return	0
         09:DC94  4C EF FF   			jmp	leave_proc
 4942                        		.dbg	clear
 4943                        		.endp
 4944               6820     		.data
 4945               2303     		.bss
 4946    F8:2303             	__joypad_DIR_loc:
 4947    F8:2303             			ds	2
 4948    F8:2305             	__joypad_DIR_end:
 4949               E309     		.code
 4950                        		.pceas
 4951                        	
 4952                        		.dbg	line,	"include\routines_LEVELS.c", 688; void update_PLAYER()
 4953                        		.dbg	line,	"include\routines_LEVELS.c", 689; {
 4954                        	;***********************
 4955                        	;***********************
 4956                        	
 4957                        		.hucc
 4958    0E:C820             		.proc		_update_PLAYER
 4959                        		__enter		_update_PLAYER
 4960                        	
 4961                        		.dbg	line,	"include\routines_LEVELS.c", 690; if(player_state == STATE_IDLE)
 4962                        		__not.um	_player_state
         0E:C820  AD 11 23   			lda	_player_state
         0E:C823  18         			clc
         0E:C824  D0 01      			bne	!+
         0E:C826  38         			sec
         0E:C827             	!:
 4963                        		__bfalse	.LL159
         0E:C827  B0 03 4C D7			bcc	.LL159
         0E:C82B  C8          
 4964                        	
 4965                        		.dbg	line,	"include\routines_LEVELS.c", 691; {
 4966                        	
 4967                        		.dbg	line,	"include\routines_LEVELS.c", 692; if(player_counter_anim == 1)
 4968                        		__ld.umq	_player_counter_anim
         0E:C82C  AD 14 23   			lda	_player_counter_anim
 4969                        		__equ_b.uiq	1
         0E:C82F  C9 01      			cmp	#1
         0E:C831  F0 01      			beq	!+
         0E:C833  18         			clc
         0E:C834             	!:
 4970                        		__bfalse	.LL160
         0E:C834  90 1F      			bcc	.LL160
 4971                        	
 4972                        		.dbg	line,	"include\routines_LEVELS.c", 693; {
 4973                        	
 4974                        		.dbg	line,	"include\routines_LEVELS.c", 694; load_vram(PLAYER_VRAM_ADR, tiles_SPR_PLAYER , TILES_16);
 4975                        		__st.wmiq	6144, _di
         0E:C836  64 F0      			stz.l	_di
         0E:C838  A9 18      			lda.h	#6144
         0E:C83A  85 F1      			sta.h	_di
 4976                        		__farptr	_tiles_SPR_PLAYER, _bp_bank, _bp
         0E:C83C  A9 A0      			lda.l	#$6000 + ($1FFF & (_tiles_SPR_PLAYER))
         0E:C83E  85 EC      			sta.l	_bp
         0E:C840  A9 7A      			lda.h	#$6000 + ($1FFF & (_tiles_SPR_PLAYER))
         0E:C842  85 ED      			sta.h	_bp
         0E:C844  A9 0B      			lda	#bank(_tiles_SPR_PLAYER)
         0E:C846  85 02      			sta	_bp_bank
 4977                        		__st.wmiq	256, _ax
         0E:C848  64 F8      			stz.l	_ax
         0E:C84A  A9 01      			lda.h	#256
         0E:C84C  85 F9      			sta.h	_ax
 4978                        		 _load_vram.3
         0E:C84E  82         			clx				; Offset to PCE VDC.
         0E:C84F  20 63 FF   			call	load_vram_x
 4979                        	
 4980                        		.dbg	line,	"include\routines_LEVELS.c", 696; player_counter_anim = 0;
 4981                        		__st.umiq	0, _player_counter_anim
         0E:C852  9C 14 23   			stz	_player_counter_anim
 4982                        	
 4983                        		.dbg	line,	"include\routines_LEVELS.c", 697; }
 4984                        	
 4985                        		.dbg	line,	"include\routines_LEVELS.c", 699; recenter_CAMERA();
 4986    0E:C855             	.LL160:
 4987                        		__call		_recenter_CAMERA
         0E:C855  20 59 FF   			call	_recenter_CAMERA
 4988                        	
 4989                        		.dbg	line,	"include\routines_LEVELS.c", 702; // CHECK COLLISION WITH LEFT FLOOR //
 4990                        	
 4991                        		.dbg	line,	"include\routines_LEVELS.c", 703; check_BG( 10 , 32 );//8
 4992                        		__ld.wi		10
         0E:C858  A9 0A      			lda.l	#10
         0E:C85A  C2         			cly
 4993                        		__pusharg.wr
         0E:C85B  A6 8D      			ldx	<__sp
         0E:C85D  CA         			dex
         0E:C85E  CA         			dex
         0E:C85F  95 08      			sta.l	<__stack, x
         0E:C861  94 09      			sty.h	<__stack, x
         0E:C863  86 8D      			stx	<__sp
 4994                        		__ld.wi		32
         0E:C865  A9 20      			lda.l	#32
         0E:C867  C2         			cly
 4995                        		__pusharg.wr
         0E:C868  A6 8D      			ldx	<__sp
         0E:C86A  CA         			dex
         0E:C86B  CA         			dex
         0E:C86C  95 08      			sta.l	<__stack, x
         0E:C86E  94 09      			sty.h	<__stack, x
         0E:C870  86 8D      			stx	<__sp
 4996                        		__call		_check_BG
         0E:C872  20 6D FF   			call	_check_BG
 4997                        	
 4998                        		.dbg	line,	"include\routines_LEVELS.c", 705; if(map_blk_flag == TILE_EMPTY)
 4999                        		__not.um	_map_blk_flag
         0E:C875  AD 76 2A   			lda	_map_blk_flag
         0E:C878  18         			clc
         0E:C879  D0 01      			bne	!+
         0E:C87B  38         			sec
         0E:C87C             	!:
 5000                        		__bfalse	.LL161
         0E:C87C  B0 03 4C 39			bcc	.LL161
         0E:C880  DD          
 5001                        	
 5002                        		.dbg	line,	"include\routines_LEVELS.c", 706; {
 5003                        	
 5004                        		.dbg	line,	"include\routines_LEVELS.c", 707; // CHECK COLLISION WITH RIGHT FLOOR //
 5005                        	
 5006                        		.dbg	line,	"include\routines_LEVELS.c", 708; check_BG( 22 , 32 );//24
 5007                        		__ld.wi		22
         0E:C881  A9 16      			lda.l	#22
         0E:C883  C2         			cly
 5008                        		__pusharg.wr
         0E:C884  A6 8D      			ldx	<__sp
         0E:C886  CA         			dex
         0E:C887  CA         			dex
         0E:C888  95 08      			sta.l	<__stack, x
         0E:C88A  94 09      			sty.h	<__stack, x
         0E:C88C  86 8D      			stx	<__sp
 5009                        		__ld.wi		32
         0E:C88E  A9 20      			lda.l	#32
         0E:C890  C2         			cly
 5010                        		__pusharg.wr
         0E:C891  A6 8D      			ldx	<__sp
         0E:C893  CA         			dex
         0E:C894  CA         			dex
         0E:C895  95 08      			sta.l	<__stack, x
         0E:C897  94 09      			sty.h	<__stack, x
         0E:C899  86 8D      			stx	<__sp
 5011                        		__call		_check_BG
         0E:C89B  20 6D FF   			call	_check_BG
 5012                        	
 5013                        		.dbg	line,	"include\routines_LEVELS.c", 710; if(map_blk_flag == TILE_EMPTY)
 5014                        		__not.um	_map_blk_flag
         0E:C89E  AD 76 2A   			lda	_map_blk_flag
         0E:C8A1  18         			clc
         0E:C8A2  D0 01      			bne	!+
         0E:C8A4  38         			sec
         0E:C8A5             	!:
 5015                        		__bfalse	.LL162
         0E:C8A5  B0 03 4C 39			bcc	.LL162
         0E:C8A9  DD          
 5016                        	
 5017                        		.dbg	line,	"include\routines_LEVELS.c", 711; {
 5018                        	
 5019                        		.dbg	line,	"include\routines_LEVELS.c", 712; load_vram(PLAYER_VRAM_ADR, tiles_SPR_PLAYER , TILES_16);
 5020                        		__st.wmiq	6144, _di
         0E:C8AA  64 F0      			stz.l	_di
         0E:C8AC  A9 18      			lda.h	#6144
         0E:C8AE  85 F1      			sta.h	_di
 5021                        		__farptr	_tiles_SPR_PLAYER, _bp_bank, _bp
         0E:C8B0  A9 A0      			lda.l	#$6000 + ($1FFF & (_tiles_SPR_PLAYER))
         0E:C8B2  85 EC      			sta.l	_bp
         0E:C8B4  A9 7A      			lda.h	#$6000 + ($1FFF & (_tiles_SPR_PLAYER))
         0E:C8B6  85 ED      			sta.h	_bp
         0E:C8B8  A9 0B      			lda	#bank(_tiles_SPR_PLAYER)
         0E:C8BA  85 02      			sta	_bp_bank
 5022                        		__st.wmiq	256, _ax
         0E:C8BC  64 F8      			stz.l	_ax
         0E:C8BE  A9 01      			lda.h	#256
         0E:C8C0  85 F9      			sta.h	_ax
 5023                        		 _load_vram.3
         0E:C8C2  82         			clx				; Offset to PCE VDC.
         0E:C8C3  20 63 FF   			call	load_vram_x
 5024                        	
 5025                        		.dbg	line,	"include\routines_LEVELS.c", 714; jump_ladder = FALSE;
 5026                        		__st.umiq	0, _jump_ladder
         0E:C8C6  9C 17 23   			stz	_jump_ladder
 5027                        	
 5028                        		.dbg	line,	"include\routines_LEVELS.c", 715; player_index_jump = 0;
 5029                        		__st.umiq	0, _player_index_jump
         0E:C8C9  9C 15 23   			stz	_player_index_jump
 5030                        	
 5031                        		.dbg	line,	"include\routines_LEVELS.c", 716; player_index_fall = 0;
 5032                        		__st.umiq	0, _player_index_fall
         0E:C8CC  9C 16 23   			stz	_player_index_fall
 5033                        	
 5034                        		.dbg	line,	"include\routines_LEVELS.c", 717; player_state = STATE_FALL;
 5035                        		__st.umiq	9, _player_state
         0E:C8CF  A9 09      			lda.l	#9
         0E:C8D1  8D 11 23   			sta	_player_state
 5036                        	
 5037                        		.dbg	line,	"include\routines_LEVELS.c", 718; }
 5038                        	
 5039                        		.dbg	line,	"include\routines_LEVELS.c", 719; }
 5040    0E:C8D4             	.LL162	.alias		.LL163
 5041                        	
 5042                        		.dbg	line,	"include\routines_LEVELS.c", 720; }
 5043    0E:C8D4             	.LL161	.alias		.LL163
 5044                        	
 5045                        		.dbg	line,	"include\routines_LEVELS.c", 723; else if(player_state == STATE_WALK)
 5046                        		__bra		.LL163
         0E:C8D4  4C 39 DD   			bra	.LL163
 5047    0E:C8D7             	.LL159:
 5048                        		__ld.umq	_player_state
         0E:C8D7  AD 11 23   			lda	_player_state
 5049                        		__equ_b.uiq	1
         0E:C8DA  C9 01      			cmp	#1
         0E:C8DC  F0 01      			beq	!+
         0E:C8DE  18         			clc
         0E:C8DF             	!:
 5050                        		__bfalse	.LL164
         0E:C8DF  B0 03 4C B2			bcc	.LL164
         0E:C8E3  CB          
 5051                        	
 5052                        		.dbg	line,	"include\routines_LEVELS.c", 724; {
 5053                        	
 5054                        		.dbg	line,	"include\routines_LEVELS.c", 725; recenter_CAMERA();
 5055                        		__call		_recenter_CAMERA
         0E:C8E4  20 59 FF   			call	_recenter_CAMERA
 5056                        	
 5057                        		.dbg	line,	"include\routines_LEVELS.c", 728; //--------------------------------------------------------------------------------------//
 5058                        	
 5059                        		.dbg	line,	"include\routines_LEVELS.c", 729; //                                   FLOOR COLLISION                                    //
 5060                        	
 5061                        		.dbg	line,	"include\routines_LEVELS.c", 730; //--------------------------------------------------------------------------------------//
 5062                        	
 5063                        		.dbg	line,	"include\routines_LEVELS.c", 732; // CHECK COLLISION WITH LEFT FLOOR //
 5064                        	
 5065                        		.dbg	line,	"include\routines_LEVELS.c", 733; check_BG( 10 , 32 );//8
 5066                        		__ld.wi		10
         0E:C8E7  A9 0A      			lda.l	#10
         0E:C8E9  C2         			cly
 5067                        		__pusharg.wr
         0E:C8EA  A6 8D      			ldx	<__sp
         0E:C8EC  CA         			dex
         0E:C8ED  CA         			dex
         0E:C8EE  95 08      			sta.l	<__stack, x
         0E:C8F0  94 09      			sty.h	<__stack, x
         0E:C8F2  86 8D      			stx	<__sp
 5068                        		__ld.wi		32
         0E:C8F4  A9 20      			lda.l	#32
         0E:C8F6  C2         			cly
 5069                        		__pusharg.wr
         0E:C8F7  A6 8D      			ldx	<__sp
         0E:C8F9  CA         			dex
         0E:C8FA  CA         			dex
         0E:C8FB  95 08      			sta.l	<__stack, x
         0E:C8FD  94 09      			sty.h	<__stack, x
         0E:C8FF  86 8D      			stx	<__sp
 5070                        		__call		_check_BG
         0E:C901  20 6D FF   			call	_check_BG
 5071                        	
 5072                        		.dbg	line,	"include\routines_LEVELS.c", 735; if(map_blk_flag == TILE_EMPTY)
 5073                        		__not.um	_map_blk_flag
         0E:C904  AD 76 2A   			lda	_map_blk_flag
         0E:C907  18         			clc
         0E:C908  D0 01      			bne	!+
         0E:C90A  38         			sec
         0E:C90B             	!:
 5074                        		__bfalse	.LL165
         0E:C90B  B0 03 4C DF			bcc	.LL165
         0E:C90F  C9          
 5075                        	
 5076                        		.dbg	line,	"include\routines_LEVELS.c", 736; {
 5077                        	
 5078                        		.dbg	line,	"include\routines_LEVELS.c", 737; // CHECK COLLISION WITH RIGHT FLOOR //
 5079                        	
 5080                        		.dbg	line,	"include\routines_LEVELS.c", 738; check_BG( 22 , 32 );//24
 5081                        		__ld.wi		22
         0E:C910  A9 16      			lda.l	#22
         0E:C912  C2         			cly
 5082                        		__pusharg.wr
         0E:C913  A6 8D      			ldx	<__sp
         0E:C915  CA         			dex
         0E:C916  CA         			dex
         0E:C917  95 08      			sta.l	<__stack, x
         0E:C919  94 09      			sty.h	<__stack, x
         0E:C91B  86 8D      			stx	<__sp
 5083                        		__ld.wi		32
         0E:C91D  A9 20      			lda.l	#32
         0E:C91F  C2         			cly
 5084                        		__pusharg.wr
         0E:C920  A6 8D      			ldx	<__sp
         0E:C922  CA         			dex
         0E:C923  CA         			dex
         0E:C924  95 08      			sta.l	<__stack, x
         0E:C926  94 09      			sty.h	<__stack, x
         0E:C928  86 8D      			stx	<__sp
 5085                        		__call		_check_BG
         0E:C92A  20 6D FF   			call	_check_BG
 5086                        	
 5087                        		.dbg	line,	"include\routines_LEVELS.c", 740; if(map_blk_flag == TILE_EMPTY)
 5088                        		__not.um	_map_blk_flag
         0E:C92D  AD 76 2A   			lda	_map_blk_flag
         0E:C930  18         			clc
         0E:C931  D0 01      			bne	!+
         0E:C933  38         			sec
         0E:C934             	!:
 5089                        		__bfalse	.LL166
         0E:C934  90 2D      			bcc	.LL166
 5090                        	
 5091                        		.dbg	line,	"include\routines_LEVELS.c", 741; {
 5092                        	
 5093                        		.dbg	line,	"include\routines_LEVELS.c", 742; load_vram(PLAYER_VRAM_ADR, tiles_SPR_PLAYER , TILES_16);
 5094                        		__st.wmiq	6144, _di
         0E:C936  64 F0      			stz.l	_di
         0E:C938  A9 18      			lda.h	#6144
         0E:C93A  85 F1      			sta.h	_di
 5095                        		__farptr	_tiles_SPR_PLAYER, _bp_bank, _bp
         0E:C93C  A9 A0      			lda.l	#$6000 + ($1FFF & (_tiles_SPR_PLAYER))
         0E:C93E  85 EC      			sta.l	_bp
         0E:C940  A9 7A      			lda.h	#$6000 + ($1FFF & (_tiles_SPR_PLAYER))
         0E:C942  85 ED      			sta.h	_bp
         0E:C944  A9 0B      			lda	#bank(_tiles_SPR_PLAYER)
         0E:C946  85 02      			sta	_bp_bank
 5096                        		__st.wmiq	256, _ax
         0E:C948  64 F8      			stz.l	_ax
         0E:C94A  A9 01      			lda.h	#256
         0E:C94C  85 F9      			sta.h	_ax
 5097                        		 _load_vram.3
         0E:C94E  82         			clx				; Offset to PCE VDC.
         0E:C94F  20 63 FF   			call	load_vram_x
 5098                        	
 5099                        		.dbg	line,	"include\routines_LEVELS.c", 744; jump_ladder = FALSE;
 5100                        		__st.umiq	0, _jump_ladder
         0E:C952  9C 17 23   			stz	_jump_ladder
 5101                        	
 5102                        		.dbg	line,	"include\routines_LEVELS.c", 745; player_index_jump = 0;
 5103                        		__st.umiq	0, _player_index_jump
         0E:C955  9C 15 23   			stz	_player_index_jump
 5104                        	
 5105                        		.dbg	line,	"include\routines_LEVELS.c", 746; player_index_fall = 0;
 5106                        		__st.umiq	0, _player_index_fall
         0E:C958  9C 16 23   			stz	_player_index_fall
 5107                        	
 5108                        		.dbg	line,	"include\routines_LEVELS.c", 747; player_state = STATE_FALL;
 5109                        		__st.umiq	9, _player_state
         0E:C95B  A9 09      			lda.l	#9
         0E:C95D  8D 11 23   			sta	_player_state
 5110                        	
 5111                        		.dbg	line,	"include\routines_LEVELS.c", 748; }
 5112                        	
 5113                        		.dbg	line,	"include\routines_LEVELS.c", 750; else
 5114                        		__bra		.LL167
         0E:C960  4C 52 CA   			bra	.LL167
 5115    0E:C963             	.LL166:
 5116                        	
 5117                        		.dbg	line,	"include\routines_LEVELS.c", 751; {
 5118                        	
 5119                        		.dbg	line,	"include\routines_LEVELS.c", 752; if(player_axis == AXIS_RIGHT)
 5120                        		__not.um	_player_axis
         0E:C963  AD 12 23   			lda	_player_axis
         0E:C966  18         			clc
         0E:C967  D0 01      			bne	!+
         0E:C969  38         			sec
         0E:C96A             	!:
 5121                        		__bfalse	.LL168
         0E:C96A  90 3A      			bcc	.LL168
 5122                        	
 5123                        		.dbg	line,	"include\routines_LEVELS.c", 753; {
 5124                        	
 5125                        		.dbg	line,	"include\routines_LEVELS.c", 754; // CHECK COLLISION WITH RIGHT WALL //
 5126                        	
 5127                        		.dbg	line,	"include\routines_LEVELS.c", 755; check_BG( 24 , 31 ); // 24+2
 5128                        		__ld.wi		24
         0E:C96C  A9 18      			lda.l	#24
         0E:C96E  C2         			cly
 5129                        		__pusharg.wr
         0E:C96F  A6 8D      			ldx	<__sp
         0E:C971  CA         			dex
         0E:C972  CA         			dex
         0E:C973  95 08      			sta.l	<__stack, x
         0E:C975  94 09      			sty.h	<__stack, x
         0E:C977  86 8D      			stx	<__sp
 5130                        		__ld.wi		31
         0E:C979  A9 1F      			lda.l	#31
         0E:C97B  C2         			cly
 5131                        		__pusharg.wr
         0E:C97C  A6 8D      			ldx	<__sp
         0E:C97E  CA         			dex
         0E:C97F  CA         			dex
         0E:C980  95 08      			sta.l	<__stack, x
         0E:C982  94 09      			sty.h	<__stack, x
         0E:C984  86 8D      			stx	<__sp
 5132                        		__call		_check_BG
         0E:C986  20 6D FF   			call	_check_BG
 5133                        	
 5134                        		.dbg	line,	"include\routines_LEVELS.c", 757; if(map_blk_flag == TILE_EMPTY)
 5135                        		__not.um	_map_blk_flag
         0E:C989  AD 76 2A   			lda	_map_blk_flag
         0E:C98C  18         			clc
         0E:C98D  D0 01      			bne	!+
         0E:C98F  38         			sec
         0E:C990             	!:
 5136                        		__bfalse	.LL169
         0E:C990  B0 03 4C 52			bcc	.LL169
         0E:C994  CA          
 5137                        	
 5138                        		.dbg	line,	"include\routines_LEVELS.c", 758; {
 5139                        	
 5140                        		.dbg	line,	"include\routines_LEVELS.c", 759; sgx_map_pxl_x += 2;
 5141                        		__add_st.wmiq	2, _sgx_map_pxl_x
         0E:C995  18         			clc
         0E:C996  AD 55 25   			lda.l	_sgx_map_pxl_x
         0E:C999  69 02      			adc.l	#2
         0E:C99B  8D 55 25   			sta.l	_sgx_map_pxl_x
         0E:C99E  90 03      			bcc	!+
         0E:C9A0  EE 56 25   			inc.h	_sgx_map_pxl_x
         0E:C9A3             	!:
 5142                        	
 5143                        		.dbg	line,	"include\routines_LEVELS.c", 760; }
 5144                        	
 5145                        		.dbg	line,	"include\routines_LEVELS.c", 761; }
 5146    0E:C9A3             	.LL169	.alias		.LL170
 5147                        	
 5148                        		.dbg	line,	"include\routines_LEVELS.c", 763; else
 5149                        		__bra		.LL170
         0E:C9A3  4C 52 CA   			bra	.LL170
 5150    0E:C9A6             	.LL168:
 5151                        	
 5152                        		.dbg	line,	"include\routines_LEVELS.c", 764; {
 5153                        	
 5154                        		.dbg	line,	"include\routines_LEVELS.c", 765; // CHECK COLLISION WITH LEFT WALL //
 5155                        	
 5156                        		.dbg	line,	"include\routines_LEVELS.c", 766; check_BG( 8 , 31 ); // 8-2
 5157                        		__ld.wi		8
         0E:C9A6  A9 08      			lda.l	#8
         0E:C9A8  C2         			cly
 5158                        		__pusharg.wr
         0E:C9A9  A6 8D      			ldx	<__sp
         0E:C9AB  CA         			dex
         0E:C9AC  CA         			dex
         0E:C9AD  95 08      			sta.l	<__stack, x
         0E:C9AF  94 09      			sty.h	<__stack, x
         0E:C9B1  86 8D      			stx	<__sp
 5159                        		__ld.wi		31
         0E:C9B3  A9 1F      			lda.l	#31
         0E:C9B5  C2         			cly
 5160                        		__pusharg.wr
         0E:C9B6  A6 8D      			ldx	<__sp
         0E:C9B8  CA         			dex
         0E:C9B9  CA         			dex
         0E:C9BA  95 08      			sta.l	<__stack, x
         0E:C9BC  94 09      			sty.h	<__stack, x
         0E:C9BE  86 8D      			stx	<__sp
 5161                        		__call		_check_BG
         0E:C9C0  20 6D FF   			call	_check_BG
 5162                        	
 5163                        		.dbg	line,	"include\routines_LEVELS.c", 768; if(map_blk_flag == TILE_EMPTY)
 5164                        		__not.um	_map_blk_flag
         0E:C9C3  AD 76 2A   			lda	_map_blk_flag
         0E:C9C6  18         			clc
         0E:C9C7  D0 01      			bne	!+
         0E:C9C9  38         			sec
         0E:C9CA             	!:
 5165                        		__bfalse	.LL171
         0E:C9CA  B0 03 4C 52			bcc	.LL171
         0E:C9CE  CA          
 5166                        	
 5167                        		.dbg	line,	"include\routines_LEVELS.c", 769; {
 5168                        	
 5169                        		.dbg	line,	"include\routines_LEVELS.c", 770; sgx_map_pxl_x -= 2;
 5170                        		__sub_st.wmiq	2, _sgx_map_pxl_x
         0E:C9CF  38         			sec
         0E:C9D0  AD 55 25   			lda.l	_sgx_map_pxl_x
         0E:C9D3  E9 02      			sbc.l	#2
         0E:C9D5  8D 55 25   			sta.l	_sgx_map_pxl_x
         0E:C9D8  B0 03      			bcs	!+
         0E:C9DA  CE 56 25   			dec.h	_sgx_map_pxl_x
         0E:C9DD             	!:
 5171                        	
 5172                        		.dbg	line,	"include\routines_LEVELS.c", 771; }
 5173                        	
 5174                        		.dbg	line,	"include\routines_LEVELS.c", 772; }
 5175    0E:C9DD             	.LL171	.alias		.LL172
 5176    0E:C9DD             	.LL170	.alias		.LL172
 5177                        	
 5178                        		.dbg	line,	"include\routines_LEVELS.c", 773; }
 5179    0E:C9DD             	.LL167	.alias		.LL172
 5180                        	
 5181                        		.dbg	line,	"include\routines_LEVELS.c", 774; }
 5182                        	
 5183                        		.dbg	line,	"include\routines_LEVELS.c", 776; else
 5184                        		__bra		.LL172
         0E:C9DD  80 73      			bra	.LL172
 5185    0E:C9DF             	.LL165:
 5186                        	
 5187                        		.dbg	line,	"include\routines_LEVELS.c", 777; {
 5188                        	
 5189                        		.dbg	line,	"include\routines_LEVELS.c", 778; if(player_axis == AXIS_RIGHT)
 5190                        		__not.um	_player_axis
         0E:C9DF  AD 12 23   			lda	_player_axis
         0E:C9E2  18         			clc
         0E:C9E3  D0 01      			bne	!+
         0E:C9E5  38         			sec
         0E:C9E6             	!:
 5191                        		__bfalse	.LL173
         0E:C9E6  90 36      			bcc	.LL173
 5192                        	
 5193                        		.dbg	line,	"include\routines_LEVELS.c", 779; {
 5194                        	
 5195                        		.dbg	line,	"include\routines_LEVELS.c", 780; // CHECK COLLISION WITH RIGHT WALL //
 5196                        	
 5197                        		.dbg	line,	"include\routines_LEVELS.c", 781; check_BG( 24 , 31 ); // 24+2
 5198                        		__ld.wi		24
         0E:C9E8  A9 18      			lda.l	#24
         0E:C9EA  C2         			cly
 5199                        		__pusharg.wr
         0E:C9EB  A6 8D      			ldx	<__sp
         0E:C9ED  CA         			dex
         0E:C9EE  CA         			dex
         0E:C9EF  95 08      			sta.l	<__stack, x
         0E:C9F1  94 09      			sty.h	<__stack, x
         0E:C9F3  86 8D      			stx	<__sp
 5200                        		__ld.wi		31
         0E:C9F5  A9 1F      			lda.l	#31
         0E:C9F7  C2         			cly
 5201                        		__pusharg.wr
         0E:C9F8  A6 8D      			ldx	<__sp
         0E:C9FA  CA         			dex
         0E:C9FB  CA         			dex
         0E:C9FC  95 08      			sta.l	<__stack, x
         0E:C9FE  94 09      			sty.h	<__stack, x
         0E:CA00  86 8D      			stx	<__sp
 5202                        		__call		_check_BG
         0E:CA02  20 6D FF   			call	_check_BG
 5203                        	
 5204                        		.dbg	line,	"include\routines_LEVELS.c", 783; if(map_blk_flag == TILE_EMPTY)
 5205                        		__not.um	_map_blk_flag
         0E:CA05  AD 76 2A   			lda	_map_blk_flag
         0E:CA08  18         			clc
         0E:CA09  D0 01      			bne	!+
         0E:CA0B  38         			sec
         0E:CA0C             	!:
 5206                        		__bfalse	.LL174
         0E:CA0C  90 44      			bcc	.LL174
 5207                        	
 5208                        		.dbg	line,	"include\routines_LEVELS.c", 784; {
 5209                        	
 5210                        		.dbg	line,	"include\routines_LEVELS.c", 785; sgx_map_pxl_x += 2;
 5211                        		__add_st.wmiq	2, _sgx_map_pxl_x
         0E:CA0E  18         			clc
         0E:CA0F  AD 55 25   			lda.l	_sgx_map_pxl_x
         0E:CA12  69 02      			adc.l	#2
         0E:CA14  8D 55 25   			sta.l	_sgx_map_pxl_x
         0E:CA17  90 03      			bcc	!+
         0E:CA19  EE 56 25   			inc.h	_sgx_map_pxl_x
         0E:CA1C             	!:
 5212                        	
 5213                        		.dbg	line,	"include\routines_LEVELS.c", 786; }
 5214                        	
 5215                        		.dbg	line,	"include\routines_LEVELS.c", 787; }
 5216    0E:CA1C             	.LL174	.alias		.LL175
 5217                        	
 5218                        		.dbg	line,	"include\routines_LEVELS.c", 789; else
 5219                        		__bra		.LL175
         0E:CA1C  80 34      			bra	.LL175
 5220    0E:CA1E             	.LL173:
 5221                        	
 5222                        		.dbg	line,	"include\routines_LEVELS.c", 790; {
 5223                        	
 5224                        		.dbg	line,	"include\routines_LEVELS.c", 791; // CHECK COLLISION WITH LEFT WALL //
 5225                        	
 5226                        		.dbg	line,	"include\routines_LEVELS.c", 792; check_BG( 8 , 31 ); // 8-2
 5227                        		__ld.wi		8
         0E:CA1E  A9 08      			lda.l	#8
         0E:CA20  C2         			cly
 5228                        		__pusharg.wr
         0E:CA21  A6 8D      			ldx	<__sp
         0E:CA23  CA         			dex
         0E:CA24  CA         			dex
         0E:CA25  95 08      			sta.l	<__stack, x
         0E:CA27  94 09      			sty.h	<__stack, x
         0E:CA29  86 8D      			stx	<__sp
 5229                        		__ld.wi		31
         0E:CA2B  A9 1F      			lda.l	#31
         0E:CA2D  C2         			cly
 5230                        		__pusharg.wr
         0E:CA2E  A6 8D      			ldx	<__sp
         0E:CA30  CA         			dex
         0E:CA31  CA         			dex
         0E:CA32  95 08      			sta.l	<__stack, x
         0E:CA34  94 09      			sty.h	<__stack, x
         0E:CA36  86 8D      			stx	<__sp
 5231                        		__call		_check_BG
         0E:CA38  20 6D FF   			call	_check_BG
 5232                        	
 5233                        		.dbg	line,	"include\routines_LEVELS.c", 794; if(map_blk_flag == TILE_EMPTY)
 5234                        		__not.um	_map_blk_flag
         0E:CA3B  AD 76 2A   			lda	_map_blk_flag
         0E:CA3E  18         			clc
         0E:CA3F  D0 01      			bne	!+
         0E:CA41  38         			sec
         0E:CA42             	!:
 5235                        		__bfalse	.LL176
         0E:CA42  90 0E      			bcc	.LL176
 5236                        	
 5237                        		.dbg	line,	"include\routines_LEVELS.c", 795; {
 5238                        	
 5239                        		.dbg	line,	"include\routines_LEVELS.c", 796; sgx_map_pxl_x -= 2;
 5240                        		__sub_st.wmiq	2, _sgx_map_pxl_x
         0E:CA44  38         			sec
         0E:CA45  AD 55 25   			lda.l	_sgx_map_pxl_x
         0E:CA48  E9 02      			sbc.l	#2
         0E:CA4A  8D 55 25   			sta.l	_sgx_map_pxl_x
         0E:CA4D  B0 03      			bcs	!+
         0E:CA4F  CE 56 25   			dec.h	_sgx_map_pxl_x
         0E:CA52             	!:
 5241                        	
 5242                        		.dbg	line,	"include\routines_LEVELS.c", 797; }
 5243                        	
 5244                        		.dbg	line,	"include\routines_LEVELS.c", 798; }
 5245    0E:CA52             	.LL176:
 5246    0E:CA52             	.LL175:
 5247                        	
 5248                        		.dbg	line,	"include\routines_LEVELS.c", 799; }
 5249    0E:CA52             	.LL172:
 5250                        	
 5251                        		.dbg	line,	"include\routines_LEVELS.c", 804; spr_set(player_id);
 5252                        		__ld.umq	_player_id
         0E:CA52  AD 10 23   			lda	_player_id
 5253                        		__call		_spr_set.1
         0E:CA55  20 DD E7   			call	_spr_set.1
 5254                        	
 5255                        		.dbg	line,	"include\routines_LEVELS.c", 807; // UPDATE PLAYER TILES //
 5256                        	
 5257                        		.dbg	line,	"include\routines_LEVELS.c", 808; if(player_counter_anim == 0)
 5258                        		__not.um	_player_counter_anim
         0E:CA58  AD 14 23   			lda	_player_counter_anim
         0E:CA5B  18         			clc
         0E:CA5C  D0 01      			bne	!+
         0E:CA5E  38         			sec
         0E:CA5F             	!:
 5259                        		__bfalse	.LL177
         0E:CA5F  90 1F      			bcc	.LL177
 5260                        	
 5261                        		.dbg	line,	"include\routines_LEVELS.c", 809; {
 5262                        	
 5263                        		.dbg	line,	"include\routines_LEVELS.c", 810; load_vram(PLAYER_VRAM_ADR, tiles_SPR_PLAYER , TILES_16);
 5264                        		__st.wmiq	6144, _di
         0E:CA61  64 F0      			stz.l	_di
         0E:CA63  A9 18      			lda.h	#6144
         0E:CA65  85 F1      			sta.h	_di
 5265                        		__farptr	_tiles_SPR_PLAYER, _bp_bank, _bp
         0E:CA67  A9 A0      			lda.l	#$6000 + ($1FFF & (_tiles_SPR_PLAYER))
         0E:CA69  85 EC      			sta.l	_bp
         0E:CA6B  A9 7A      			lda.h	#$6000 + ($1FFF & (_tiles_SPR_PLAYER))
         0E:CA6D  85 ED      			sta.h	_bp
         0E:CA6F  A9 0B      			lda	#bank(_tiles_SPR_PLAYER)
         0E:CA71  85 02      			sta	_bp_bank
 5266                        		__st.wmiq	256, _ax
         0E:CA73  64 F8      			stz.l	_ax
         0E:CA75  A9 01      			lda.h	#256
         0E:CA77  85 F9      			sta.h	_ax
 5267                        		 _load_vram.3
         0E:CA79  82         			clx				; Offset to PCE VDC.
         0E:CA7A  20 63 FF   			call	load_vram_x
 5268                        	
 5269                        		.dbg	line,	"include\routines_LEVELS.c", 811; }
 5270                        	
 5271                        		.dbg	line,	"include\routines_LEVELS.c", 814; else if(player_counter_anim == 2)
 5272                        		__bra		.LL178
         0E:CA7D  4C AC CB   			bra	.LL178
 5273    0E:CA80             	.LL177:
 5274                        		__ld.umq	_player_counter_anim
         0E:CA80  AD 14 23   			lda	_player_counter_anim
 5275                        		__equ_b.uiq	2
         0E:CA83  C9 02      			cmp	#2
         0E:CA85  F0 01      			beq	!+
         0E:CA87  18         			clc
         0E:CA88             	!:
 5276                        		__bfalse	.LL179
         0E:CA88  90 1F      			bcc	.LL179
 5277                        	
 5278                        		.dbg	line,	"include\routines_LEVELS.c", 815; {
 5279                        	
 5280                        		.dbg	line,	"include\routines_LEVELS.c", 816; load_vram(PLAYER_VRAM_ADR, tiles_SPR_PLAYER + OFFSET_PLAYER_WALK_1 , TILES_16);
 5281                        		__st.wmiq	6144, _di
         0E:CA8A  64 F0      			stz.l	_di
         0E:CA8C  A9 18      			lda.h	#6144
         0E:CA8E  85 F1      			sta.h	_di
 5282                        		__farptr	_tiles_SPR_PLAYER + 512, _bp_bank, _bp
         0E:CA90  A9 A0      			lda.l	#$6000 + ($1FFF & (_tiles_SPR_PLAYER + 512))
         0E:CA92  85 EC      			sta.l	_bp
         0E:CA94  A9 7C      			lda.h	#$6000 + ($1FFF & (_tiles_SPR_PLAYER + 512))
         0E:CA96  85 ED      			sta.h	_bp
         0E:CA98  A9 0B      			lda	#bank(_tiles_SPR_PLAYER + 512)
         0E:CA9A  85 02      			sta	_bp_bank
 5283                        		__st.wmiq	256, _ax
         0E:CA9C  64 F8      			stz.l	_ax
         0E:CA9E  A9 01      			lda.h	#256
         0E:CAA0  85 F9      			sta.h	_ax
 5284                        		 _load_vram.3
         0E:CAA2  82         			clx				; Offset to PCE VDC.
         0E:CAA3  20 63 FF   			call	load_vram_x
 5285                        	
 5286                        		.dbg	line,	"include\routines_LEVELS.c", 817; }
 5287                        	
 5288                        		.dbg	line,	"include\routines_LEVELS.c", 820; else if(player_counter_anim == 5)
 5289                        		__bra		.LL180
         0E:CAA6  4C AC CB   			bra	.LL180
 5290    0E:CAA9             	.LL179:
 5291                        		__ld.umq	_player_counter_anim
         0E:CAA9  AD 14 23   			lda	_player_counter_anim
 5292                        		__equ_b.uiq	5
         0E:CAAC  C9 05      			cmp	#5
         0E:CAAE  F0 01      			beq	!+
         0E:CAB0  18         			clc
         0E:CAB1             	!:
 5293                        		__bfalse	.LL181
         0E:CAB1  90 1F      			bcc	.LL181
 5294                        	
 5295                        		.dbg	line,	"include\routines_LEVELS.c", 821; {
 5296                        	
 5297                        		.dbg	line,	"include\routines_LEVELS.c", 822; load_vram(PLAYER_VRAM_ADR, tiles_SPR_PLAYER + OFFSET_PLAYER_WALK_2 , TILES_16);
 5298                        		__st.wmiq	6144, _di
         0E:CAB3  64 F0      			stz.l	_di
         0E:CAB5  A9 18      			lda.h	#6144
         0E:CAB7  85 F1      			sta.h	_di
 5299                        		__farptr	_tiles_SPR_PLAYER + 1024, _bp_bank, _bp
         0E:CAB9  A9 A0      			lda.l	#$6000 + ($1FFF & (_tiles_SPR_PLAYER + 1024))
         0E:CABB  85 EC      			sta.l	_bp
         0E:CABD  A9 7E      			lda.h	#$6000 + ($1FFF & (_tiles_SPR_PLAYER + 1024))
         0E:CABF  85 ED      			sta.h	_bp
         0E:CAC1  A9 0B      			lda	#bank(_tiles_SPR_PLAYER + 1024)
         0E:CAC3  85 02      			sta	_bp_bank
 5300                        		__st.wmiq	256, _ax
         0E:CAC5  64 F8      			stz.l	_ax
         0E:CAC7  A9 01      			lda.h	#256
         0E:CAC9  85 F9      			sta.h	_ax
 5301                        		 _load_vram.3
         0E:CACB  82         			clx				; Offset to PCE VDC.
         0E:CACC  20 63 FF   			call	load_vram_x
 5302                        	
 5303                        		.dbg	line,	"include\routines_LEVELS.c", 823; }
 5304                        	
 5305                        		.dbg	line,	"include\routines_LEVELS.c", 826; else if(player_counter_anim == 8)
 5306                        		__bra		.LL182
         0E:CACF  4C AC CB   			bra	.LL182
 5307    0E:CAD2             	.LL181:
 5308                        		__ld.umq	_player_counter_anim
         0E:CAD2  AD 14 23   			lda	_player_counter_anim
 5309                        		__equ_b.uiq	8
         0E:CAD5  C9 08      			cmp	#8
         0E:CAD7  F0 01      			beq	!+
         0E:CAD9  18         			clc
         0E:CADA             	!:
 5310                        		__bfalse	.LL183
         0E:CADA  90 1F      			bcc	.LL183
 5311                        	
 5312                        		.dbg	line,	"include\routines_LEVELS.c", 827; {
 5313                        	
 5314                        		.dbg	line,	"include\routines_LEVELS.c", 828; load_vram(PLAYER_VRAM_ADR, tiles_SPR_PLAYER + OFFSET_PLAYER_WALK_3 , TILES_16);
 5315                        		__st.wmiq	6144, _di
         0E:CADC  64 F0      			stz.l	_di
         0E:CADE  A9 18      			lda.h	#6144
         0E:CAE0  85 F1      			sta.h	_di
 5316                        		__farptr	_tiles_SPR_PLAYER + 1536, _bp_bank, _bp
         0E:CAE2  A9 A0      			lda.l	#$6000 + ($1FFF & (_tiles_SPR_PLAYER + 1536))
         0E:CAE4  85 EC      			sta.l	_bp
         0E:CAE6  A9 60      			lda.h	#$6000 + ($1FFF & (_tiles_SPR_PLAYER + 1536))
         0E:CAE8  85 ED      			sta.h	_bp
         0E:CAEA  A9 0C      			lda	#bank(_tiles_SPR_PLAYER + 1536)
         0E:CAEC  85 02      			sta	_bp_bank
 5317                        		__st.wmiq	256, _ax
         0E:CAEE  64 F8      			stz.l	_ax
         0E:CAF0  A9 01      			lda.h	#256
         0E:CAF2  85 F9      			sta.h	_ax
 5318                        		 _load_vram.3
         0E:CAF4  82         			clx				; Offset to PCE VDC.
         0E:CAF5  20 63 FF   			call	load_vram_x
 5319                        	
 5320                        		.dbg	line,	"include\routines_LEVELS.c", 829; }
 5321                        	
 5322                        		.dbg	line,	"include\routines_LEVELS.c", 832; else if(player_counter_anim == 11)
 5323                        		__bra		.LL184
         0E:CAF8  4C AC CB   			bra	.LL184
 5324    0E:CAFB             	.LL183:
 5325                        		__ld.umq	_player_counter_anim
         0E:CAFB  AD 14 23   			lda	_player_counter_anim
 5326                        		__equ_b.uiq	11
         0E:CAFE  C9 0B      			cmp	#11
         0E:CB00  F0 01      			beq	!+
         0E:CB02  18         			clc
         0E:CB03             	!:
 5327                        		__bfalse	.LL185
         0E:CB03  90 1F      			bcc	.LL185
 5328                        	
 5329                        		.dbg	line,	"include\routines_LEVELS.c", 833; {
 5330                        	
 5331                        		.dbg	line,	"include\routines_LEVELS.c", 834; load_vram(PLAYER_VRAM_ADR, tiles_SPR_PLAYER , TILES_16);
 5332                        		__st.wmiq	6144, _di
         0E:CB05  64 F0      			stz.l	_di
         0E:CB07  A9 18      			lda.h	#6144
         0E:CB09  85 F1      			sta.h	_di
 5333                        		__farptr	_tiles_SPR_PLAYER, _bp_bank, _bp
         0E:CB0B  A9 A0      			lda.l	#$6000 + ($1FFF & (_tiles_SPR_PLAYER))
         0E:CB0D  85 EC      			sta.l	_bp
         0E:CB0F  A9 7A      			lda.h	#$6000 + ($1FFF & (_tiles_SPR_PLAYER))
         0E:CB11  85 ED      			sta.h	_bp
         0E:CB13  A9 0B      			lda	#bank(_tiles_SPR_PLAYER)
         0E:CB15  85 02      			sta	_bp_bank
 5334                        		__st.wmiq	256, _ax
         0E:CB17  64 F8      			stz.l	_ax
         0E:CB19  A9 01      			lda.h	#256
         0E:CB1B  85 F9      			sta.h	_ax
 5335                        		 _load_vram.3
         0E:CB1D  82         			clx				; Offset to PCE VDC.
         0E:CB1E  20 63 FF   			call	load_vram_x
 5336                        	
 5337                        		.dbg	line,	"include\routines_LEVELS.c", 835; }
 5338                        	
 5339                        		.dbg	line,	"include\routines_LEVELS.c", 838; else if(player_counter_anim == 14)
 5340                        		__bra		.LL186
         0E:CB21  4C AC CB   			bra	.LL186
 5341    0E:CB24             	.LL185:
 5342                        		__ld.umq	_player_counter_anim
         0E:CB24  AD 14 23   			lda	_player_counter_anim
 5343                        		__equ_b.uiq	14
         0E:CB27  C9 0E      			cmp	#14
         0E:CB29  F0 01      			beq	!+
         0E:CB2B  18         			clc
         0E:CB2C             	!:
 5344                        		__bfalse	.LL187
         0E:CB2C  90 1E      			bcc	.LL187
 5345                        	
 5346                        		.dbg	line,	"include\routines_LEVELS.c", 839; {
 5347                        	
 5348                        		.dbg	line,	"include\routines_LEVELS.c", 840; load_vram(PLAYER_VRAM_ADR, tiles_SPR_PLAYER + OFFSET_PLAYER_WALK_4 , TILES_16);
 5349                        		__st.wmiq	6144, _di
         0E:CB2E  64 F0      			stz.l	_di
         0E:CB30  A9 18      			lda.h	#6144
         0E:CB32  85 F1      			sta.h	_di
 5350                        		__farptr	_tiles_SPR_PLAYER + 2048, _bp_bank, _bp
         0E:CB34  A9 A0      			lda.l	#$6000 + ($1FFF & (_tiles_SPR_PLAYER + 2048))
         0E:CB36  85 EC      			sta.l	_bp
         0E:CB38  A9 62      			lda.h	#$6000 + ($1FFF & (_tiles_SPR_PLAYER + 2048))
         0E:CB3A  85 ED      			sta.h	_bp
         0E:CB3C  A9 0C      			lda	#bank(_tiles_SPR_PLAYER + 2048)
         0E:CB3E  85 02      			sta	_bp_bank
 5351                        		__st.wmiq	256, _ax
         0E:CB40  64 F8      			stz.l	_ax
         0E:CB42  A9 01      			lda.h	#256
         0E:CB44  85 F9      			sta.h	_ax
 5352                        		 _load_vram.3
         0E:CB46  82         			clx				; Offset to PCE VDC.
         0E:CB47  20 63 FF   			call	load_vram_x
 5353                        	
 5354                        		.dbg	line,	"include\routines_LEVELS.c", 841; }
 5355                        	
 5356                        		.dbg	line,	"include\routines_LEVELS.c", 844; else if(player_counter_anim == 17)
 5357                        		__bra		.LL188
         0E:CB4A  80 60      			bra	.LL188
 5358    0E:CB4C             	.LL187:
 5359                        		__ld.umq	_player_counter_anim
         0E:CB4C  AD 14 23   			lda	_player_counter_anim
 5360                        		__equ_b.uiq	17
         0E:CB4F  C9 11      			cmp	#17
         0E:CB51  F0 01      			beq	!+
         0E:CB53  18         			clc
         0E:CB54             	!:
 5361                        		__bfalse	.LL189
         0E:CB54  90 1E      			bcc	.LL189
 5362                        	
 5363                        		.dbg	line,	"include\routines_LEVELS.c", 845; {
 5364                        	
 5365                        		.dbg	line,	"include\routines_LEVELS.c", 846; load_vram(PLAYER_VRAM_ADR, tiles_SPR_PLAYER + OFFSET_PLAYER_WALK_5 , TILES_16);
 5366                        		__st.wmiq	6144, _di
         0E:CB56  64 F0      			stz.l	_di
         0E:CB58  A9 18      			lda.h	#6144
         0E:CB5A  85 F1      			sta.h	_di
 5367                        		__farptr	_tiles_SPR_PLAYER + 2560, _bp_bank, _bp
         0E:CB5C  A9 A0      			lda.l	#$6000 + ($1FFF & (_tiles_SPR_PLAYER + 2560))
         0E:CB5E  85 EC      			sta.l	_bp
         0E:CB60  A9 64      			lda.h	#$6000 + ($1FFF & (_tiles_SPR_PLAYER + 2560))
         0E:CB62  85 ED      			sta.h	_bp
         0E:CB64  A9 0C      			lda	#bank(_tiles_SPR_PLAYER + 2560)
         0E:CB66  85 02      			sta	_bp_bank
 5368                        		__st.wmiq	256, _ax
         0E:CB68  64 F8      			stz.l	_ax
         0E:CB6A  A9 01      			lda.h	#256
         0E:CB6C  85 F9      			sta.h	_ax
 5369                        		 _load_vram.3
         0E:CB6E  82         			clx				; Offset to PCE VDC.
         0E:CB6F  20 63 FF   			call	load_vram_x
 5370                        	
 5371                        		.dbg	line,	"include\routines_LEVELS.c", 847; }
 5372                        	
 5373                        		.dbg	line,	"include\routines_LEVELS.c", 850; else if(player_counter_anim == 20)
 5374                        		__bra		.LL190
         0E:CB72  80 38      			bra	.LL190
 5375    0E:CB74             	.LL189:
 5376                        		__ld.umq	_player_counter_anim
         0E:CB74  AD 14 23   			lda	_player_counter_anim
 5377                        		__equ_b.uiq	20
         0E:CB77  C9 14      			cmp	#20
         0E:CB79  F0 01      			beq	!+
         0E:CB7B  18         			clc
         0E:CB7C             	!:
 5378                        		__bfalse	.LL191
         0E:CB7C  90 1E      			bcc	.LL191
 5379                        	
 5380                        		.dbg	line,	"include\routines_LEVELS.c", 851; {
 5381                        	
 5382                        		.dbg	line,	"include\routines_LEVELS.c", 852; load_vram(PLAYER_VRAM_ADR, tiles_SPR_PLAYER + OFFSET_PLAYER_WALK_6 , TILES_16);
 5383                        		__st.wmiq	6144, _di
         0E:CB7E  64 F0      			stz.l	_di
         0E:CB80  A9 18      			lda.h	#6144
         0E:CB82  85 F1      			sta.h	_di
 5384                        		__farptr	_tiles_SPR_PLAYER + 3072, _bp_bank, _bp
         0E:CB84  A9 A0      			lda.l	#$6000 + ($1FFF & (_tiles_SPR_PLAYER + 3072))
         0E:CB86  85 EC      			sta.l	_bp
         0E:CB88  A9 66      			lda.h	#$6000 + ($1FFF & (_tiles_SPR_PLAYER + 3072))
         0E:CB8A  85 ED      			sta.h	_bp
         0E:CB8C  A9 0C      			lda	#bank(_tiles_SPR_PLAYER + 3072)
         0E:CB8E  85 02      			sta	_bp_bank
 5385                        		__st.wmiq	256, _ax
         0E:CB90  64 F8      			stz.l	_ax
         0E:CB92  A9 01      			lda.h	#256
         0E:CB94  85 F9      			sta.h	_ax
 5386                        		 _load_vram.3
         0E:CB96  82         			clx				; Offset to PCE VDC.
         0E:CB97  20 63 FF   			call	load_vram_x
 5387                        	
 5388                        		.dbg	line,	"include\routines_LEVELS.c", 853; }
 5389                        	
 5390                        		.dbg	line,	"include\routines_LEVELS.c", 856; else if(player_counter_anim == 22)
 5391                        		__bra		.LL192
         0E:CB9A  80 10      			bra	.LL192
 5392    0E:CB9C             	.LL191:
 5393                        		__ld.umq	_player_counter_anim
         0E:CB9C  AD 14 23   			lda	_player_counter_anim
 5394                        		__equ_b.uiq	22
         0E:CB9F  C9 16      			cmp	#22
         0E:CBA1  F0 01      			beq	!+
         0E:CBA3  18         			clc
         0E:CBA4             	!:
 5395                        		__bfalse	.LL193
         0E:CBA4  90 06      			bcc	.LL193
 5396                        	
 5397                        		.dbg	line,	"include\routines_LEVELS.c", 857; {
 5398                        	
 5399                        		.dbg	line,	"include\routines_LEVELS.c", 858; player_counter_anim = 0;
 5400                        		__st.umiq	0, _player_counter_anim
         0E:CBA6  9C 14 23   			stz	_player_counter_anim
 5401                        	
 5402                        		.dbg	line,	"include\routines_LEVELS.c", 860; return;
 5403                        		__bra		.LL158
         0E:CBA9  4C 39 DD   			bra	.LL158
 5404                        	
 5405                        		.dbg	line,	"include\routines_LEVELS.c", 861; }
 5406                        	
 5407                        		.dbg	line,	"include\routines_LEVELS.c", 864; player_counter_anim += 1;
 5408    0E:CBAC             	.LL193:
 5409    0E:CBAC             	.LL192:
 5410    0E:CBAC             	.LL190:
 5411    0E:CBAC             	.LL188:
 5412    0E:CBAC             	.LL186:
 5413    0E:CBAC             	.LL184:
 5414    0E:CBAC             	.LL182:
 5415    0E:CBAC             	.LL180:
 5416    0E:CBAC             	.LL178:
 5417                        		__add_st.umiq	1, _player_counter_anim
         0E:CBAC  EE 14 23   			inc	_player_counter_anim
 5418                        	
 5419                        		.dbg	line,	"include\routines_LEVELS.c", 866; }
 5420                        	
 5421                        		.dbg	line,	"include\routines_LEVELS.c", 869; else if(player_state == STATE_JUMP)
 5422                        		__bra		.LL194
         0E:CBAF  4C 39 DD   			bra	.LL194
 5423    0E:CBB2             	.LL164:
 5424                        		__ld.umq	_player_state
         0E:CBB2  AD 11 23   			lda	_player_state
 5425                        		__equ_b.uiq	4
         0E:CBB5  C9 04      			cmp	#4
         0E:CBB7  F0 01      			beq	!+
         0E:CBB9  18         			clc
         0E:CBBA             	!:
 5426                        		__bfalse	.LL195
         0E:CBBA  B0 03 4C B2			bcc	.LL195
         0E:CBBE  CE          
 5427                        	
 5428                        		.dbg	line,	"include\routines_LEVELS.c", 870; {
 5429                        	
 5430                        		.dbg	line,	"include\routines_LEVELS.c", 871; unsigned char i;
 5431                        	
 5432                        		.dbg	line,	"include\routines_LEVELS.c", 872; i = 1;
 5433                        		__st.umiq	1, __update_PLAYER_end - 1  /* i */
         0E:CBBF  A9 01      			lda.l	#1
         0E:CBC1  8D 0C 23   			sta	__update_PLAYER_end - 1
 5434                        	
 5435                        		.dbg	line,	"include\routines_LEVELS.c", 875; if(player_counter_anim == 0)
 5436                        		__not.um	_player_counter_anim
         0E:CBC4  AD 14 23   			lda	_player_counter_anim
         0E:CBC7  18         			clc
         0E:CBC8  D0 01      			bne	!+
         0E:CBCA  38         			sec
         0E:CBCB             	!:
 5437                        		__bfalse	.LL196
         0E:CBCB  90 21      			bcc	.LL196
 5438                        	
 5439                        		.dbg	line,	"include\routines_LEVELS.c", 876; {
 5440                        	
 5441                        		.dbg	line,	"include\routines_LEVELS.c", 877; load_vram(PLAYER_VRAM_ADR, tiles_SPR_PLAYER + TILES_112 , TILES_16);
 5442                        		__st.wmiq	6144, _di
         0E:CBCD  64 F0      			stz.l	_di
         0E:CBCF  A9 18      			lda.h	#6144
         0E:CBD1  85 F1      			sta.h	_di
 5443                        		__farptr	_tiles_SPR_PLAYER + 3584, _bp_bank, _bp
         0E:CBD3  A9 A0      			lda.l	#$6000 + ($1FFF & (_tiles_SPR_PLAYER + 3584))
         0E:CBD5  85 EC      			sta.l	_bp
         0E:CBD7  A9 68      			lda.h	#$6000 + ($1FFF & (_tiles_SPR_PLAYER + 3584))
         0E:CBD9  85 ED      			sta.h	_bp
         0E:CBDB  A9 0C      			lda	#bank(_tiles_SPR_PLAYER + 3584)
         0E:CBDD  85 02      			sta	_bp_bank
 5444                        		__st.wmiq	256, _ax
         0E:CBDF  64 F8      			stz.l	_ax
         0E:CBE1  A9 01      			lda.h	#256
         0E:CBE3  85 F9      			sta.h	_ax
 5445                        		 _load_vram.3
         0E:CBE5  82         			clx				; Offset to PCE VDC.
         0E:CBE6  20 63 FF   			call	load_vram_x
 5446                        	
 5447                        		.dbg	line,	"include\routines_LEVELS.c", 879; player_counter_anim = 1;
 5448                        		__st.umiq	1, _player_counter_anim
         0E:CBE9  A9 01      			lda.l	#1
         0E:CBEB  8D 14 23   			sta	_player_counter_anim
 5449                        	
 5450                        		.dbg	line,	"include\routines_LEVELS.c", 880; }
 5451                        	
 5452                        		.dbg	line,	"include\routines_LEVELS.c", 883; player_pos_y += TABLE_PLAYER_JUMP_V[player_index_jump];
 5453    0E:CBEE             	.LL196:
 5454                        		__ldx.umq	_player_index_jump
         0E:CBEE  AE 15 23   			ldx	_player_index_jump
 5455                        		__ld.bax	_TABLE_PLAYER_JUMP_V
         0E:CBF1  BD A0 60   			lda	_TABLE_PLAYER_JUMP_V, x
         0E:CBF4  C2         			cly
         0E:CBF5  10 01      			bpl	!+
         0E:CBF7  88         			dey
         0E:CBF8             	!:
 5456                        		__add_st.wmq	_player_pos_y
         0E:CBF8  18         			clc
         0E:CBF9  6D B9 23   			adc.l	_player_pos_y
         0E:CBFC  8D B9 23   			sta.l	_player_pos_y
         0E:CBFF  98         			tya
         0E:CC00  6D BA 23   			adc.h	_player_pos_y
         0E:CC03  8D BA 23   			sta.h	_player_pos_y
 5457                        	
 5458                        		.dbg	line,	"include\routines_LEVELS.c", 885; // CHECK COLLISION WITH CEILING //
 5459                        	
 5460                        		.dbg	line,	"include\routines_LEVELS.c", 886; check_BG( 15 , 8 );
 5461                        		__ld.wi		15
         0E:CC06  A9 0F      			lda.l	#15
         0E:CC08  C2         			cly
 5462                        		__pusharg.wr
         0E:CC09  A6 8D      			ldx	<__sp
         0E:CC0B  CA         			dex
         0E:CC0C  CA         			dex
         0E:CC0D  95 08      			sta.l	<__stack, x
         0E:CC0F  94 09      			sty.h	<__stack, x
         0E:CC11  86 8D      			stx	<__sp
 5463                        		__ld.wi		8
         0E:CC13  A9 08      			lda.l	#8
         0E:CC15  C2         			cly
 5464                        		__pusharg.wr
         0E:CC16  A6 8D      			ldx	<__sp
         0E:CC18  CA         			dex
         0E:CC19  CA         			dex
         0E:CC1A  95 08      			sta.l	<__stack, x
         0E:CC1C  94 09      			sty.h	<__stack, x
         0E:CC1E  86 8D      			stx	<__sp
 5465                        		__call		_check_BG
         0E:CC20  20 6D FF   			call	_check_BG
 5466                        	
 5467                        		.dbg	line,	"include\routines_LEVELS.c", 888; if(map_blk_flag == TILE_BG)
 5468                        		__ld.umq	_map_blk_flag
         0E:CC23  AD 76 2A   			lda	_map_blk_flag
 5469                        		__equ_b.uiq	1
         0E:CC26  C9 01      			cmp	#1
         0E:CC28  F0 01      			beq	!+
         0E:CC2A  18         			clc
         0E:CC2B             	!:
 5470                        		__bfalse	.LL197
         0E:CC2B  90 5A      			bcc	.LL197
 5471                        	
 5472                        		.dbg	line,	"include\routines_LEVELS.c", 889; {
 5473                        	
 5474                        		.dbg	line,	"include\routines_LEVELS.c", 890; for(i=1 ; i<8 ; i++)
 5475                        		__st.umiq	1, __update_PLAYER_end - 1  /* i */
         0E:CC2D  A9 01      			lda.l	#1
         0E:CC2F  8D 0C 23   			sta	__update_PLAYER_end - 1
 5476    0E:CC32             	.LL198:
 5477                        		__ld.umq	__update_PLAYER_end - 1  /* i */
         0E:CC32  AD 0C 23   			lda	__update_PLAYER_end - 1
 5478                        		__ult_b.uiq	8
         0E:CC35  C9 08      			cmp	#8		; Subtract integer from A.
         0E:CC37  6A         			ror	a		; CC if A < integer.
         0E:CC38  49 80      			eor	#$80
         0E:CC3A  2A         			rol	a
 5479                        		__btrue		.LL200
         0E:CC3B  B0 07      			bcs	.LL200
 5480                        		__bra		.LL201
         0E:CC3D  80 48      			bra	.LL201
 5481    0E:CC3F             	.LL199:
 5482                        		__inc.umq	__update_PLAYER_end - 1  /* i */
         0E:CC3F  EE 0C 23   			inc	__update_PLAYER_end - 1
 5483                        		__bra		.LL198
         0E:CC42  80 EE      			bra	.LL198
 5484    0E:CC44             	.LL200:
 5485                        	
 5486                        		.dbg	line,	"include\routines_LEVELS.c", 891; {
 5487                        	
 5488                        		.dbg	line,	"include\routines_LEVELS.c", 892; check_BG( 15 , 8 + i );
 5489                        		__ld.wi		15
         0E:CC44  A9 0F      			lda.l	#15
         0E:CC46  C2         			cly
 5490                        		__pusharg.wr
         0E:CC47  A6 8D      			ldx	<__sp
         0E:CC49  CA         			dex
         0E:CC4A  CA         			dex
         0E:CC4B  95 08      			sta.l	<__stack, x
         0E:CC4D  94 09      			sty.h	<__stack, x
         0E:CC4F  86 8D      			stx	<__sp
 5491                        		__ld.wi		8
         0E:CC51  A9 08      			lda.l	#8
         0E:CC53  C2         			cly
 5492                        		__add.um	__update_PLAYER_end - 1  /* i */
         0E:CC54  18         			clc
         0E:CC55  6D 0C 23   			adc	__update_PLAYER_end - 1
         0E:CC58  90 01      			bcc	!+
         0E:CC5A  C8         			iny
         0E:CC5B             	!:
 5493                        		__pusharg.wr
         0E:CC5B  A6 8D      			ldx	<__sp
         0E:CC5D  CA         			dex
         0E:CC5E  CA         			dex
         0E:CC5F  95 08      			sta.l	<__stack, x
         0E:CC61  94 09      			sty.h	<__stack, x
         0E:CC63  86 8D      			stx	<__sp
 5494                        		__call		_check_BG
         0E:CC65  20 6D FF   			call	_check_BG
 5495                        	
 5496                        		.dbg	line,	"include\routines_LEVELS.c", 893; {
 5497                        	
 5498                        		.dbg	line,	"include\routines_LEVELS.c", 894; if(map_blk_flag == TILE_EMPTY)
 5499                        		__not.um	_map_blk_flag
         0E:CC68  AD 76 2A   			lda	_map_blk_flag
         0E:CC6B  18         			clc
         0E:CC6C  D0 01      			bne	!+
         0E:CC6E  38         			sec
         0E:CC6F             	!:
 5500                        		__bfalse	.LL202
         0E:CC6F  90 CE      			bcc	.LL202
 5501                        	
 5502                        		.dbg	line,	"include\routines_LEVELS.c", 895; {
 5503                        	
 5504                        		.dbg	line,	"include\routines_LEVELS.c", 896; player_pos_y += i;
 5505                        		__ld.um		__update_PLAYER_end - 1  /* i */
         0E:CC71  AD 0C 23   			lda	__update_PLAYER_end - 1
         0E:CC74  C2         			cly
 5506                        		__add_st.wmq	_player_pos_y
         0E:CC75  18         			clc
         0E:CC76  6D B9 23   			adc.l	_player_pos_y
         0E:CC79  8D B9 23   			sta.l	_player_pos_y
         0E:CC7C  98         			tya
         0E:CC7D  6D BA 23   			adc.h	_player_pos_y
         0E:CC80  8D BA 23   			sta.h	_player_pos_y
 5507                        	
 5508                        		.dbg	line,	"include\routines_LEVELS.c", 897; break;
 5509                        		__bra		.LL201
         0E:CC83  80 02      			bra	.LL201
 5510                        	
 5511                        		.dbg	line,	"include\routines_LEVELS.c", 898; }
 5512                        	
 5513                        		.dbg	line,	"include\routines_LEVELS.c", 899; }
 5514    0E:CC85             	.LL202	.alias		.LL199
 5515                        	
 5516                        		.dbg	line,	"include\routines_LEVELS.c", 900; }
 5517                        		__bra		.LL199
         0E:CC85  80 B8      			bra	.LL199
 5518    0E:CC87             	.LL201:
 5519                        	
 5520                        		.dbg	line,	"include\routines_LEVELS.c", 901; }
 5521                        	
 5522                        		.dbg	line,	"include\routines_LEVELS.c", 903; spr_set(player_id);
 5523    0E:CC87             	.LL197:
 5524                        		__ld.umq	_player_id
         0E:CC87  AD 10 23   			lda	_player_id
 5525                        		__call		_spr_set.1
         0E:CC8A  20 DD E7   			call	_spr_set.1
 5526                        	
 5527                        		.dbg	line,	"include\routines_LEVELS.c", 904; spr_y(player_pos_y);
 5528                        		__ld.wm		_player_pos_y
         0E:CC8D  AD B9 23   			lda.l	_player_pos_y
         0E:CC90  AC BA 23   			ldy.h	_player_pos_y
 5529                        		__call		_spr_y.1
         0E:CC93  20 19 E8   			call	_spr_y.1
 5530                        	
 5531                        		.dbg	line,	"include\routines_LEVELS.c", 908; if(player_index_jump < 34)
 5532                        		__ld.umq	_player_index_jump
         0E:CC96  AD 15 23   			lda	_player_index_jump
 5533                        		__ult_b.uiq	34
         0E:CC99  C9 22      			cmp	#34		; Subtract integer from A.
         0E:CC9B  6A         			ror	a		; CC if A < integer.
         0E:CC9C  49 80      			eor	#$80
         0E:CC9E  2A         			rol	a
 5534                        		__bfalse	.LL203
         0E:CC9F  90 03      			bcc	.LL203
 5535                        	
 5536                        		.dbg	line,	"include\routines_LEVELS.c", 909; {
 5537                        	
 5538                        		.dbg	line,	"include\routines_LEVELS.c", 911; player_index_jump += 1;
 5539                        		__add_st.umiq	1, _player_index_jump
         0E:CCA1  EE 15 23   			inc	_player_index_jump
 5540                        	
 5541                        		.dbg	line,	"include\routines_LEVELS.c", 912; }
 5542                        	
 5543                        		.dbg	line,	"include\routines_LEVELS.c", 917; //--------------------------------------------------------------------------------------//
 5544                        	
 5545                        		.dbg	line,	"include\routines_LEVELS.c", 918; //                                   FLOOR COLLISION                                    //
 5546                        	
 5547                        		.dbg	line,	"include\routines_LEVELS.c", 919; //--------------------------------------------------------------------------------------//
 5548                        	
 5549                        		.dbg	line,	"include\routines_LEVELS.c", 921; if(player_index_jump > 14)
 5550    0E:CCA4             	.LL203:
 5551                        		__ld.umq	_player_index_jump
         0E:CCA4  AD 15 23   			lda	_player_index_jump
 5552                        		__ugt_b.uiq	14
         0E:CCA7  18         			clc			; Subtract integer+1 from A.
         0E:CCA8  E9 0E      			sbc	#14		; CS if A > integer.
 5553                        		__bfalse	.LL204
         0E:CCAA  B0 03 4C 25			bcc	.LL204
         0E:CCAE  CE          
 5554                        	
 5555                        		.dbg	line,	"include\routines_LEVELS.c", 922; {
 5556                        	
 5557                        		.dbg	line,	"include\routines_LEVELS.c", 923; // CHECK COLLISION WITH LEFT FLOOR //
 5558                        	
 5559                        		.dbg	line,	"include\routines_LEVELS.c", 924; check_BG( 10 , 32 );
 5560                        		__ld.wi		10
         0E:CCAF  A9 0A      			lda.l	#10
         0E:CCB1  C2         			cly
 5561                        		__pusharg.wr
         0E:CCB2  A6 8D      			ldx	<__sp
         0E:CCB4  CA         			dex
         0E:CCB5  CA         			dex
         0E:CCB6  95 08      			sta.l	<__stack, x
         0E:CCB8  94 09      			sty.h	<__stack, x
         0E:CCBA  86 8D      			stx	<__sp
 5562                        		__ld.wi		32
         0E:CCBC  A9 20      			lda.l	#32
         0E:CCBE  C2         			cly
 5563                        		__pusharg.wr
         0E:CCBF  A6 8D      			ldx	<__sp
         0E:CCC1  CA         			dex
         0E:CCC2  CA         			dex
         0E:CCC3  95 08      			sta.l	<__stack, x
         0E:CCC5  94 09      			sty.h	<__stack, x
         0E:CCC7  86 8D      			stx	<__sp
 5564                        		__call		_check_BG
         0E:CCC9  20 6D FF   			call	_check_BG
 5565                        	
 5566                        		.dbg	line,	"include\routines_LEVELS.c", 926; // IF PLAYER TOUCHES THE GROUND TO THE LEFT //
 5567                        	
 5568                        		.dbg	line,	"include\routines_LEVELS.c", 927; if(map_blk_flag == TILE_BG)
 5569                        		__ld.umq	_map_blk_flag
         0E:CCCC  AD 76 2A   			lda	_map_blk_flag
 5570                        		__equ_b.uiq	1
         0E:CCCF  C9 01      			cmp	#1
         0E:CCD1  F0 01      			beq	!+
         0E:CCD3  18         			clc
         0E:CCD4             	!:
 5571                        		__bfalse	.LL205
         0E:CCD4  B0 03 4C 6A			bcc	.LL205
         0E:CCD8  CD          
 5572                        	
 5573                        		.dbg	line,	"include\routines_LEVELS.c", 928; {
 5574                        	
 5575                        		.dbg	line,	"include\routines_LEVELS.c", 929; // CALCULATE HOW MANY PIXELS THE PLAYER MOVED INTO THE GROUND //
 5576                        	
 5577                        		.dbg	line,	"include\routines_LEVELS.c", 930; for(i=1; i<11 ; i++ )
 5578                        		__st.umiq	1, __update_PLAYER_end - 1  /* i */
         0E:CCD9  A9 01      			lda.l	#1
         0E:CCDB  8D 0C 23   			sta	__update_PLAYER_end - 1
 5579    0E:CCDE             	.LL206:
 5580                        		__ld.umq	__update_PLAYER_end - 1  /* i */
         0E:CCDE  AD 0C 23   			lda	__update_PLAYER_end - 1
 5581                        		__ult_b.uiq	11
         0E:CCE1  C9 0B      			cmp	#11		; Subtract integer from A.
         0E:CCE3  6A         			ror	a		; CC if A < integer.
         0E:CCE4  49 80      			eor	#$80
         0E:CCE6  2A         			rol	a
 5582                        		__btrue		.LL208
         0E:CCE7  B0 07      			bcs	.LL208
 5583                        		__bra		.LL209
         0E:CCE9  80 71      			bra	.LL209
 5584    0E:CCEB             	.LL207:
 5585                        		__inc.umq	__update_PLAYER_end - 1  /* i */
         0E:CCEB  EE 0C 23   			inc	__update_PLAYER_end - 1
 5586                        		__bra		.LL206
         0E:CCEE  80 EE      			bra	.LL206
 5587    0E:CCF0             	.LL208:
 5588                        	
 5589                        		.dbg	line,	"include\routines_LEVELS.c", 931; {
 5590                        	
 5591                        		.dbg	line,	"include\routines_LEVELS.c", 932; check_TILE_DEPTH( 10 , i);
 5592                        		__ld.wi		10
         0E:CCF0  A9 0A      			lda.l	#10
         0E:CCF2  C2         			cly
 5593                        		__pusharg.wr
         0E:CCF3  A6 8D      			ldx	<__sp
         0E:CCF5  CA         			dex
         0E:CCF6  CA         			dex
         0E:CCF7  95 08      			sta.l	<__stack, x
         0E:CCF9  94 09      			sty.h	<__stack, x
         0E:CCFB  86 8D      			stx	<__sp
 5594                        		__ld.um		__update_PLAYER_end - 1  /* i */
         0E:CCFD  AD 0C 23   			lda	__update_PLAYER_end - 1
         0E:CD00  C2         			cly
 5595                        		__pusharg.wr
         0E:CD01  A6 8D      			ldx	<__sp
         0E:CD03  CA         			dex
         0E:CD04  CA         			dex
         0E:CD05  95 08      			sta.l	<__stack, x
         0E:CD07  94 09      			sty.h	<__stack, x
         0E:CD09  86 8D      			stx	<__sp
 5596                        		__call		_check_TILE_DEPTH
         0E:CD0B  20 4F FF   			call	_check_TILE_DEPTH
 5597                        	
 5598                        		.dbg	line,	"include\routines_LEVELS.c", 934; if(map_blk_flag == TILE_EMPTY)
 5599                        		__not.um	_map_blk_flag
         0E:CD0E  AD 76 2A   			lda	_map_blk_flag
         0E:CD11  18         			clc
         0E:CD12  D0 01      			bne	!+
         0E:CD14  38         			sec
         0E:CD15             	!:
 5600                        		__bfalse	.LL210
         0E:CD15  90 D4      			bcc	.LL210
 5601                        	
 5602                        		.dbg	line,	"include\routines_LEVELS.c", 935; {
 5603                        	
 5604                        		.dbg	line,	"include\routines_LEVELS.c", 936; load_vram(PLAYER_VRAM_ADR, tiles_SPR_PLAYER , TILES_16);
 5605                        		__st.wmiq	6144, _di
         0E:CD17  64 F0      			stz.l	_di
         0E:CD19  A9 18      			lda.h	#6144
         0E:CD1B  85 F1      			sta.h	_di
 5606                        		__farptr	_tiles_SPR_PLAYER, _bp_bank, _bp
         0E:CD1D  A9 A0      			lda.l	#$6000 + ($1FFF & (_tiles_SPR_PLAYER))
         0E:CD1F  85 EC      			sta.l	_bp
         0E:CD21  A9 7A      			lda.h	#$6000 + ($1FFF & (_tiles_SPR_PLAYER))
         0E:CD23  85 ED      			sta.h	_bp
         0E:CD25  A9 0B      			lda	#bank(_tiles_SPR_PLAYER)
         0E:CD27  85 02      			sta	_bp_bank
 5607                        		__st.wmiq	256, _ax
         0E:CD29  64 F8      			stz.l	_ax
         0E:CD2B  A9 01      			lda.h	#256
         0E:CD2D  85 F9      			sta.h	_ax
 5608                        		 _load_vram.3
         0E:CD2F  82         			clx				; Offset to PCE VDC.
         0E:CD30  20 63 FF   			call	load_vram_x
 5609                        	
 5610                        		.dbg	line,	"include\routines_LEVELS.c", 938; player_pos_y -= (i - 1);
 5611                        		__ld.um		__update_PLAYER_end - 1  /* i */
         0E:CD33  AD 0C 23   			lda	__update_PLAYER_end - 1
         0E:CD36  C2         			cly
 5612                        		__sub.wi	1
         0E:CD37  38         			sec
         0E:CD38  E9 01      			sbc.l	#1
         0E:CD3A  B0 01      			bcs	!+
         0E:CD3C  88         			dey
         0E:CD3D             	!:
 5613                        		__isub_st.wmq	_player_pos_y
         0E:CD3D  38         			sec
         0E:CD3E  49 FF      			eor	#$FF
         0E:CD40  6D B9 23   			adc.l	_player_pos_y
         0E:CD43  8D B9 23   			sta.l	_player_pos_y
         0E:CD46  98         			tya
         0E:CD47  49 FF      			eor	#$FF
         0E:CD49  6D BA 23   			adc.h	_player_pos_y
         0E:CD4C  8D BA 23   			sta.h	_player_pos_y
 5614                        	
 5615                        		.dbg	line,	"include\routines_LEVELS.c", 939; spr_y(player_pos_y);
 5616                        		__ld.wm		_player_pos_y
         0E:CD4F  AD B9 23   			lda.l	_player_pos_y
         0E:CD52  AC BA 23   			ldy.h	_player_pos_y
 5617                        		__call		_spr_y.1
         0E:CD55  20 19 E8   			call	_spr_y.1
 5618                        	
 5619                        		.dbg	line,	"include\routines_LEVELS.c", 940; break;
 5620                        		__bra		.LL209
         0E:CD58  80 02      			bra	.LL209
 5621                        	
 5622                        		.dbg	line,	"include\routines_LEVELS.c", 941; }
 5623                        	
 5624                        		.dbg	line,	"include\routines_LEVELS.c", 943; }
 5625    0E:CD5A             	.LL210	.alias		.LL207
 5626                        		__bra		.LL207
         0E:CD5A  80 8F      			bra	.LL207
 5627    0E:CD5C             	.LL209:
 5628                        	
 5629                        		.dbg	line,	"include\routines_LEVELS.c", 945; player_counter_anim = 1;
 5630                        		__st.umiq	1, _player_counter_anim
         0E:CD5C  A9 01      			lda.l	#1
         0E:CD5E  8D 14 23   			sta	_player_counter_anim
 5631                        	
 5632                        		.dbg	line,	"include\routines_LEVELS.c", 946; player_index_jump = 0;
 5633                        		__st.umiq	0, _player_index_jump
         0E:CD61  9C 15 23   			stz	_player_index_jump
 5634                        	
 5635                        		.dbg	line,	"include\routines_LEVELS.c", 947; player_state = STATE_IDLE;
 5636                        		__st.umiq	0, _player_state
         0E:CD64  9C 11 23   			stz	_player_state
 5637                        	
 5638                        		.dbg	line,	"include\routines_LEVELS.c", 948; return;
 5639                        		__bra		.LL158
         0E:CD67  4C 39 DD   			bra	.LL158
 5640                        	
 5641                        		.dbg	line,	"include\routines_LEVELS.c", 949; }
 5642                        	
 5643                        		.dbg	line,	"include\routines_LEVELS.c", 951; // IF PLAYER TOUCHES THE GROUND TO THE RIGHT //
 5644                        	
 5645                        		.dbg	line,	"include\routines_LEVELS.c", 952; else
 5646    0E:CD6A             	.LL205:
 5647                        	
 5648                        		.dbg	line,	"include\routines_LEVELS.c", 953; {
 5649                        	
 5650                        		.dbg	line,	"include\routines_LEVELS.c", 954; // CHECK COLLISION WITH RIGHT FLOOR //
 5651                        	
 5652                        		.dbg	line,	"include\routines_LEVELS.c", 955; check_BG( 22 , 32 );
 5653                        		__ld.wi		22
         0E:CD6A  A9 16      			lda.l	#22
         0E:CD6C  C2         			cly
 5654                        		__pusharg.wr
         0E:CD6D  A6 8D      			ldx	<__sp
         0E:CD6F  CA         			dex
         0E:CD70  CA         			dex
         0E:CD71  95 08      			sta.l	<__stack, x
         0E:CD73  94 09      			sty.h	<__stack, x
         0E:CD75  86 8D      			stx	<__sp
 5655                        		__ld.wi		32
         0E:CD77  A9 20      			lda.l	#32
         0E:CD79  C2         			cly
 5656                        		__pusharg.wr
         0E:CD7A  A6 8D      			ldx	<__sp
         0E:CD7C  CA         			dex
         0E:CD7D  CA         			dex
         0E:CD7E  95 08      			sta.l	<__stack, x
         0E:CD80  94 09      			sty.h	<__stack, x
         0E:CD82  86 8D      			stx	<__sp
 5657                        		__call		_check_BG
         0E:CD84  20 6D FF   			call	_check_BG
 5658                        	
 5659                        		.dbg	line,	"include\routines_LEVELS.c", 957; if(map_blk_flag == TILE_BG)
 5660                        		__ld.umq	_map_blk_flag
         0E:CD87  AD 76 2A   			lda	_map_blk_flag
 5661                        		__equ_b.uiq	1
         0E:CD8A  C9 01      			cmp	#1
         0E:CD8C  F0 01      			beq	!+
         0E:CD8E  18         			clc
         0E:CD8F             	!:
 5662                        		__bfalse	.LL212
         0E:CD8F  B0 03 4C 25			bcc	.LL212
         0E:CD93  CE          
 5663                        	
 5664                        		.dbg	line,	"include\routines_LEVELS.c", 958; {
 5665                        	
 5666                        		.dbg	line,	"include\routines_LEVELS.c", 959; // CALCULATE HOW MANY PIXELS THE PLAYER MOVED INTO THE GROUND //
 5667                        	
 5668                        		.dbg	line,	"include\routines_LEVELS.c", 960; for(i=1; i<11 ; i++ )
 5669                        		__st.umiq	1, __update_PLAYER_end - 1  /* i */
         0E:CD94  A9 01      			lda.l	#1
         0E:CD96  8D 0C 23   			sta	__update_PLAYER_end - 1
 5670    0E:CD99             	.LL213:
 5671                        		__ld.umq	__update_PLAYER_end - 1  /* i */
         0E:CD99  AD 0C 23   			lda	__update_PLAYER_end - 1
 5672                        		__ult_b.uiq	11
         0E:CD9C  C9 0B      			cmp	#11		; Subtract integer from A.
         0E:CD9E  6A         			ror	a		; CC if A < integer.
         0E:CD9F  49 80      			eor	#$80
         0E:CDA1  2A         			rol	a
 5673                        		__btrue		.LL215
         0E:CDA2  B0 07      			bcs	.LL215
 5674                        		__bra		.LL216
         0E:CDA4  80 71      			bra	.LL216
 5675    0E:CDA6             	.LL214:
 5676                        		__inc.umq	__update_PLAYER_end - 1  /* i */
         0E:CDA6  EE 0C 23   			inc	__update_PLAYER_end - 1
 5677                        		__bra		.LL213
         0E:CDA9  80 EE      			bra	.LL213
 5678    0E:CDAB             	.LL215:
 5679                        	
 5680                        		.dbg	line,	"include\routines_LEVELS.c", 961; {
 5681                        	
 5682                        		.dbg	line,	"include\routines_LEVELS.c", 962; check_TILE_DEPTH( 22 , i);
 5683                        		__ld.wi		22
         0E:CDAB  A9 16      			lda.l	#22
         0E:CDAD  C2         			cly
 5684                        		__pusharg.wr
         0E:CDAE  A6 8D      			ldx	<__sp
         0E:CDB0  CA         			dex
         0E:CDB1  CA         			dex
         0E:CDB2  95 08      			sta.l	<__stack, x
         0E:CDB4  94 09      			sty.h	<__stack, x
         0E:CDB6  86 8D      			stx	<__sp
 5685                        		__ld.um		__update_PLAYER_end - 1  /* i */
         0E:CDB8  AD 0C 23   			lda	__update_PLAYER_end - 1
         0E:CDBB  C2         			cly
 5686                        		__pusharg.wr
         0E:CDBC  A6 8D      			ldx	<__sp
         0E:CDBE  CA         			dex
         0E:CDBF  CA         			dex
         0E:CDC0  95 08      			sta.l	<__stack, x
         0E:CDC2  94 09      			sty.h	<__stack, x
         0E:CDC4  86 8D      			stx	<__sp
 5687                        		__call		_check_TILE_DEPTH
         0E:CDC6  20 4F FF   			call	_check_TILE_DEPTH
 5688                        	
 5689                        		.dbg	line,	"include\routines_LEVELS.c", 964; if(map_blk_flag == TILE_EMPTY)
 5690                        		__not.um	_map_blk_flag
         0E:CDC9  AD 76 2A   			lda	_map_blk_flag
         0E:CDCC  18         			clc
         0E:CDCD  D0 01      			bne	!+
         0E:CDCF  38         			sec
         0E:CDD0             	!:
 5691                        		__bfalse	.LL217
         0E:CDD0  90 D4      			bcc	.LL217
 5692                        	
 5693                        		.dbg	line,	"include\routines_LEVELS.c", 965; {
 5694                        	
 5695                        		.dbg	line,	"include\routines_LEVELS.c", 966; load_vram(PLAYER_VRAM_ADR, tiles_SPR_PLAYER , TILES_16);
 5696                        		__st.wmiq	6144, _di
         0E:CDD2  64 F0      			stz.l	_di
         0E:CDD4  A9 18      			lda.h	#6144
         0E:CDD6  85 F1      			sta.h	_di
 5697                        		__farptr	_tiles_SPR_PLAYER, _bp_bank, _bp
         0E:CDD8  A9 A0      			lda.l	#$6000 + ($1FFF & (_tiles_SPR_PLAYER))
         0E:CDDA  85 EC      			sta.l	_bp
         0E:CDDC  A9 7A      			lda.h	#$6000 + ($1FFF & (_tiles_SPR_PLAYER))
         0E:CDDE  85 ED      			sta.h	_bp
         0E:CDE0  A9 0B      			lda	#bank(_tiles_SPR_PLAYER)
         0E:CDE2  85 02      			sta	_bp_bank
 5698                        		__st.wmiq	256, _ax
         0E:CDE4  64 F8      			stz.l	_ax
         0E:CDE6  A9 01      			lda.h	#256
         0E:CDE8  85 F9      			sta.h	_ax
 5699                        		 _load_vram.3
         0E:CDEA  82         			clx				; Offset to PCE VDC.
         0E:CDEB  20 63 FF   			call	load_vram_x
 5700                        	
 5701                        		.dbg	line,	"include\routines_LEVELS.c", 968; player_pos_y -= (i - 1);
 5702                        		__ld.um		__update_PLAYER_end - 1  /* i */
         0E:CDEE  AD 0C 23   			lda	__update_PLAYER_end - 1
         0E:CDF1  C2         			cly
 5703                        		__sub.wi	1
         0E:CDF2  38         			sec
         0E:CDF3  E9 01      			sbc.l	#1
         0E:CDF5  B0 01      			bcs	!+
         0E:CDF7  88         			dey
         0E:CDF8             	!:
 5704                        		__isub_st.wmq	_player_pos_y
         0E:CDF8  38         			sec
         0E:CDF9  49 FF      			eor	#$FF
         0E:CDFB  6D B9 23   			adc.l	_player_pos_y
         0E:CDFE  8D B9 23   			sta.l	_player_pos_y
         0E:CE01  98         			tya
         0E:CE02  49 FF      			eor	#$FF
         0E:CE04  6D BA 23   			adc.h	_player_pos_y
         0E:CE07  8D BA 23   			sta.h	_player_pos_y
 5705                        	
 5706                        		.dbg	line,	"include\routines_LEVELS.c", 969; spr_y(player_pos_y);
 5707                        		__ld.wm		_player_pos_y
         0E:CE0A  AD B9 23   			lda.l	_player_pos_y
         0E:CE0D  AC BA 23   			ldy.h	_player_pos_y
 5708                        		__call		_spr_y.1
         0E:CE10  20 19 E8   			call	_spr_y.1
 5709                        	
 5710                        		.dbg	line,	"include\routines_LEVELS.c", 970; break;
 5711                        		__bra		.LL216
         0E:CE13  80 02      			bra	.LL216
 5712                        	
 5713                        		.dbg	line,	"include\routines_LEVELS.c", 971; }
 5714                        	
 5715                        		.dbg	line,	"include\routines_LEVELS.c", 973; }
 5716    0E:CE15             	.LL217	.alias		.LL214
 5717                        		__bra		.LL214
         0E:CE15  80 8F      			bra	.LL214
 5718    0E:CE17             	.LL216:
 5719                        	
 5720                        		.dbg	line,	"include\routines_LEVELS.c", 975; player_counter_anim = 1;
 5721                        		__st.umiq	1, _player_counter_anim
         0E:CE17  A9 01      			lda.l	#1
         0E:CE19  8D 14 23   			sta	_player_counter_anim
 5722                        	
 5723                        		.dbg	line,	"include\routines_LEVELS.c", 976; player_index_jump = 0;
 5724                        		__st.umiq	0, _player_index_jump
         0E:CE1C  9C 15 23   			stz	_player_index_jump
 5725                        	
 5726                        		.dbg	line,	"include\routines_LEVELS.c", 977; player_state = STATE_IDLE;
 5727                        		__st.umiq	0, _player_state
         0E:CE1F  9C 11 23   			stz	_player_state
 5728                        	
 5729                        		.dbg	line,	"include\routines_LEVELS.c", 978; return;
 5730                        		__bra		.LL158
         0E:CE22  4C 39 DD   			bra	.LL158
 5731                        	
 5732                        		.dbg	line,	"include\routines_LEVELS.c", 979; }
 5733                        	
 5734                        		.dbg	line,	"include\routines_LEVELS.c", 980; }
 5735    0E:CE25             	.LL212:
 5736    0E:CE25             	.LL211:
 5737                        	
 5738                        		.dbg	line,	"include\routines_LEVELS.c", 981; }
 5739                        	
 5740                        		.dbg	line,	"include\routines_LEVELS.c", 985; // CHECK COLLISION WITH LADDERS //
 5741                        	
 5742                        		.dbg	line,	"include\routines_LEVELS.c", 986; check_BG( 16 , 16 );
 5743    0E:CE25             	.LL204:
 5744                        		__ld.wi		16
         0E:CE25  A9 10      			lda.l	#16
         0E:CE27  C2         			cly
 5745                        		__pusharg.wr
         0E:CE28  A6 8D      			ldx	<__sp
         0E:CE2A  CA         			dex
         0E:CE2B  CA         			dex
         0E:CE2C  95 08      			sta.l	<__stack, x
         0E:CE2E  94 09      			sty.h	<__stack, x
         0E:CE30  86 8D      			stx	<__sp
 5746                        		__ld.wi		16
         0E:CE32  A9 10      			lda.l	#16
         0E:CE34  C2         			cly
 5747                        		__pusharg.wr
         0E:CE35  A6 8D      			ldx	<__sp
         0E:CE37  CA         			dex
         0E:CE38  CA         			dex
         0E:CE39  95 08      			sta.l	<__stack, x
         0E:CE3B  94 09      			sty.h	<__stack, x
         0E:CE3D  86 8D      			stx	<__sp
 5748                        		__call		_check_BG
         0E:CE3F  20 6D FF   			call	_check_BG
 5749                        	
 5750                        		.dbg	line,	"include\routines_LEVELS.c", 988; // IF PLAYER HITS THE LADDER //
 5751                        	
 5752                        		.dbg	line,	"include\routines_LEVELS.c", 989; if(map_blk_flag == TILE_LADDER)
 5753                        		__ld.umq	_map_blk_flag
         0E:CE42  AD 76 2A   			lda	_map_blk_flag
 5754                        		__equ_b.uiq	2
         0E:CE45  C9 02      			cmp	#2
         0E:CE47  F0 01      			beq	!+
         0E:CE49  18         			clc
         0E:CE4A             	!:
 5755                        		__bfalse	.LL218
         0E:CE4A  B0 03 4C 39			bcc	.LL218
         0E:CE4E  DD          
 5756                        	
 5757                        		.dbg	line,	"include\routines_LEVELS.c", 990; {
 5758                        	
 5759                        		.dbg	line,	"include\routines_LEVELS.c", 991; // CAMERA GOES 8 PX BACKWARD //
 5760                        	
 5761                        		.dbg	line,	"include\routines_LEVELS.c", 992; sgx_map_pxl_x = ( (sgx_map_pxl_x >> 3) << 3 );
 5762                        		__ld.wm		_sgx_map_pxl_x
         0E:CE4F  AD 55 25   			lda.l	_sgx_map_pxl_x
         0E:CE52  AC 56 25   			ldy.h	_sgx_map_pxl_x
 5763                        		__lsr.wi	3
         0E:CE55  84 00      			sty	__temp
         0E:CE57  20 3A E2   			jsr	lsrw3
 5764                        		__asl.wi	3
         0E:CE5A  84 00      			sty	__temp
         0E:CE5C  20 D7 E1   			jsr	aslw3
 5765                        		__st.wmq	_sgx_map_pxl_x
         0E:CE5F  8D 55 25   			sta.l	_sgx_map_pxl_x
         0E:CE62  8C 56 25   			sty.h	_sgx_map_pxl_x
 5766                        	
 5767                        		.dbg	line,	"include\routines_LEVELS.c", 994; // SO WE UPDATE THE MAP //
 5768                        	
 5769                        		.dbg	line,	"include\routines_LEVELS.c", 995; sgx_scroll_map();
 5770                        		__call		_sgx_scroll_map
         0E:CE65  20 81 FF   			call	_sgx_scroll_map
 5771                        	
 5772                        		.dbg	line,	"include\routines_LEVELS.c", 997; // CHECK IF THE PLAYER STANDS RIGHT TO THE LADDER //
 5773                        	
 5774                        		.dbg	line,	"include\routines_LEVELS.c", 998; check_BG( 31 , 16 );
 5775                        		__ld.wi		31
         0E:CE68  A9 1F      			lda.l	#31
         0E:CE6A  C2         			cly
 5776                        		__pusharg.wr
         0E:CE6B  A6 8D      			ldx	<__sp
         0E:CE6D  CA         			dex
         0E:CE6E  CA         			dex
         0E:CE6F  95 08      			sta.l	<__stack, x
         0E:CE71  94 09      			sty.h	<__stack, x
         0E:CE73  86 8D      			stx	<__sp
 5777                        		__ld.wi		16
         0E:CE75  A9 10      			lda.l	#16
         0E:CE77  C2         			cly
 5778                        		__pusharg.wr
         0E:CE78  A6 8D      			ldx	<__sp
         0E:CE7A  CA         			dex
         0E:CE7B  CA         			dex
         0E:CE7C  95 08      			sta.l	<__stack, x
         0E:CE7E  94 09      			sty.h	<__stack, x
         0E:CE80  86 8D      			stx	<__sp
 5779                        		__call		_check_BG
         0E:CE82  20 6D FF   			call	_check_BG
 5780                        	
 5781                        		.dbg	line,	"include\routines_LEVELS.c", 1000; if(map_blk_flag == TILE_LADDER)
 5782                        		__ld.umq	_map_blk_flag
         0E:CE85  AD 76 2A   			lda	_map_blk_flag
 5783                        		__equ_b.uiq	2
         0E:CE88  C9 02      			cmp	#2
         0E:CE8A  F0 01      			beq	!+
         0E:CE8C  18         			clc
         0E:CE8D             	!:
 5784                        		__bfalse	.LL219
         0E:CE8D  90 0E      			bcc	.LL219
 5785                        	
 5786                        		.dbg	line,	"include\routines_LEVELS.c", 1001; {
 5787                        	
 5788                        		.dbg	line,	"include\routines_LEVELS.c", 1002; sgx_map_pxl_x += 8;
 5789                        		__add_st.wmiq	8, _sgx_map_pxl_x
         0E:CE8F  18         			clc
         0E:CE90  AD 55 25   			lda.l	_sgx_map_pxl_x
         0E:CE93  69 08      			adc.l	#8
         0E:CE95  8D 55 25   			sta.l	_sgx_map_pxl_x
         0E:CE98  90 03      			bcc	!+
         0E:CE9A  EE 56 25   			inc.h	_sgx_map_pxl_x
         0E:CE9D             	!:
 5790                        	
 5791                        		.dbg	line,	"include\routines_LEVELS.c", 1003; }
 5792                        	
 5793                        		.dbg	line,	"include\routines_LEVELS.c", 1005; player_counter_anim = 1;
 5794    0E:CE9D             	.LL219:
 5795                        		__st.umiq	1, _player_counter_anim
         0E:CE9D  A9 01      			lda.l	#1
         0E:CE9F  8D 14 23   			sta	_player_counter_anim
 5796                        	
 5797                        		.dbg	line,	"include\routines_LEVELS.c", 1006; player_index_jump = 0;
 5798                        		__st.umiq	0, _player_index_jump
         0E:CEA2  9C 15 23   			stz	_player_index_jump
 5799                        	
 5800                        		.dbg	line,	"include\routines_LEVELS.c", 1007; jump_ladder = TRUE;
 5801                        		__st.umiq	1, _jump_ladder
         0E:CEA5  A9 01      			lda.l	#1
         0E:CEA7  8D 17 23   			sta	_jump_ladder
 5802                        	
 5803                        		.dbg	line,	"include\routines_LEVELS.c", 1008; player_state = STATE_HANG;
 5804                        		__st.umiq	10, _player_state
         0E:CEAA  A9 0A      			lda.l	#10
         0E:CEAC  8D 11 23   			sta	_player_state
 5805                        	
 5806                        		.dbg	line,	"include\routines_LEVELS.c", 1009; }
 5807                        	
 5808                        		.dbg	line,	"include\routines_LEVELS.c", 1010; }
 5809    0E:CEAF             	.LL218	.alias		.LL220
 5810                        	
 5811                        		.dbg	line,	"include\routines_LEVELS.c", 1013; else if(player_state == STATE_JUMP_RIGHT)
 5812                        		__bra		.LL220
         0E:CEAF  4C 39 DD   			bra	.LL220
 5813    0E:CEB2             	.LL195:
 5814                        		__ld.umq	_player_state
         0E:CEB2  AD 11 23   			lda	_player_state
 5815                        		__equ_b.uiq	5
         0E:CEB5  C9 05      			cmp	#5
         0E:CEB7  F0 01      			beq	!+
         0E:CEB9  18         			clc
         0E:CEBA             	!:
 5816                        		__bfalse	.LL221
         0E:CEBA  B0 03 4C DD			bcc	.LL221
         0E:CEBE  D2          
 5817                        	
 5818                        		.dbg	line,	"include\routines_LEVELS.c", 1014; {
 5819                        	
 5820                        		.dbg	line,	"include\routines_LEVELS.c", 1015; unsigned char i, camera_y_move;
 5821                        	
 5822                        		.dbg	line,	"include\routines_LEVELS.c", 1016; i = 1;
 5823                        		__st.umiq	1, __update_PLAYER_end - 2  /* i */
         0E:CEBF  A9 01      			lda.l	#1
         0E:CEC1  8D 0B 23   			sta	__update_PLAYER_end - 2
 5824                        	
 5825                        		.dbg	line,	"include\routines_LEVELS.c", 1019; // UPDATE PLAYER TILES //
 5826                        	
 5827                        		.dbg	line,	"include\routines_LEVELS.c", 1020; if(player_counter_anim == 0)
 5828                        		__not.um	_player_counter_anim
         0E:CEC4  AD 14 23   			lda	_player_counter_anim
         0E:CEC7  18         			clc
         0E:CEC8  D0 01      			bne	!+
         0E:CECA  38         			sec
         0E:CECB             	!:
 5829                        		__bfalse	.LL222
         0E:CECB  90 21      			bcc	.LL222
 5830                        	
 5831                        		.dbg	line,	"include\routines_LEVELS.c", 1021; {
 5832                        	
 5833                        		.dbg	line,	"include\routines_LEVELS.c", 1022; load_vram(PLAYER_VRAM_ADR, tiles_SPR_PLAYER + TILES_112 , TILES_16);
 5834                        		__st.wmiq	6144, _di
         0E:CECD  64 F0      			stz.l	_di
         0E:CECF  A9 18      			lda.h	#6144
         0E:CED1  85 F1      			sta.h	_di
 5835                        		__farptr	_tiles_SPR_PLAYER + 3584, _bp_bank, _bp
         0E:CED3  A9 A0      			lda.l	#$6000 + ($1FFF & (_tiles_SPR_PLAYER + 3584))
         0E:CED5  85 EC      			sta.l	_bp
         0E:CED7  A9 68      			lda.h	#$6000 + ($1FFF & (_tiles_SPR_PLAYER + 3584))
         0E:CED9  85 ED      			sta.h	_bp
         0E:CEDB  A9 0C      			lda	#bank(_tiles_SPR_PLAYER + 3584)
         0E:CEDD  85 02      			sta	_bp_bank
 5836                        		__st.wmiq	256, _ax
         0E:CEDF  64 F8      			stz.l	_ax
         0E:CEE1  A9 01      			lda.h	#256
         0E:CEE3  85 F9      			sta.h	_ax
 5837                        		 _load_vram.3
         0E:CEE5  82         			clx				; Offset to PCE VDC.
         0E:CEE6  20 63 FF   			call	load_vram_x
 5838                        	
 5839                        		.dbg	line,	"include\routines_LEVELS.c", 1024; player_counter_anim = 1;
 5840                        		__st.umiq	1, _player_counter_anim
         0E:CEE9  A9 01      			lda.l	#1
         0E:CEEB  8D 14 23   			sta	_player_counter_anim
 5841                        	
 5842                        		.dbg	line,	"include\routines_LEVELS.c", 1025; }
 5843                        	
 5844                        		.dbg	line,	"include\routines_LEVELS.c", 1028; // SELECT PLAYER SPRITE //
 5845                        	
 5846                        		.dbg	line,	"include\routines_LEVELS.c", 1029; spr_set(player_id);
 5847    0E:CEEE             	.LL222:
 5848                        		__ld.umq	_player_id
         0E:CEEE  AD 10 23   			lda	_player_id
 5849                        		__call		_spr_set.1
         0E:CEF1  20 DD E7   			call	_spr_set.1
 5850                        	
 5851                        		.dbg	line,	"include\routines_LEVELS.c", 1032; //**************************************************************************************//
 5852                        	
 5853                        		.dbg	line,	"include\routines_LEVELS.c", 1033; //                                        H MOVE                                        //
 5854                        	
 5855                        		.dbg	line,	"include\routines_LEVELS.c", 1034; //**************************************************************************************//
 5856                        	
 5857                        		.dbg	line,	"include\routines_LEVELS.c", 1036; //--------------------------------------------------------------------------------------//
 5858                        	
 5859                        		.dbg	line,	"include\routines_LEVELS.c", 1037; //                                    WALL COLLISION                                    //
 5860                        	
 5861                        		.dbg	line,	"include\routines_LEVELS.c", 1038; //--------------------------------------------------------------------------------------//
 5862                        	
 5863                        		.dbg	line,	"include\routines_LEVELS.c", 1040; // CHECK COLLISION WITH BOTTOM RIGHT WALL //
 5864                        	
 5865                        		.dbg	line,	"include\routines_LEVELS.c", 1041; check_BG( 24 , 31 );
 5866                        		__ld.wi		24
         0E:CEF4  A9 18      			lda.l	#24
         0E:CEF6  C2         			cly
 5867                        		__pusharg.wr
         0E:CEF7  A6 8D      			ldx	<__sp
         0E:CEF9  CA         			dex
         0E:CEFA  CA         			dex
         0E:CEFB  95 08      			sta.l	<__stack, x
         0E:CEFD  94 09      			sty.h	<__stack, x
         0E:CEFF  86 8D      			stx	<__sp
 5868                        		__ld.wi		31
         0E:CF01  A9 1F      			lda.l	#31
         0E:CF03  C2         			cly
 5869                        		__pusharg.wr
         0E:CF04  A6 8D      			ldx	<__sp
         0E:CF06  CA         			dex
         0E:CF07  CA         			dex
         0E:CF08  95 08      			sta.l	<__stack, x
         0E:CF0A  94 09      			sty.h	<__stack, x
         0E:CF0C  86 8D      			stx	<__sp
 5870                        		__call		_check_BG
         0E:CF0E  20 6D FF   			call	_check_BG
 5871                        	
 5872                        		.dbg	line,	"include\routines_LEVELS.c", 1043; if(map_blk_flag != TILE_BG)
 5873                        		__ld.umq	_map_blk_flag
         0E:CF11  AD 76 2A   			lda	_map_blk_flag
 5874                        		__neq_b.uiq	1
         0E:CF14  38         			sec
         0E:CF15  49 01      			eor	#1
         0E:CF17  D0 01      			bne	!+
         0E:CF19  18         			clc
         0E:CF1A             	!:
 5875                        		__bfalse	.LL223
         0E:CF1A  90 78      			bcc	.LL223
 5876                        	
 5877                        		.dbg	line,	"include\routines_LEVELS.c", 1044; {
 5878                        	
 5879                        		.dbg	line,	"include\routines_LEVELS.c", 1045; // CHECK COLLISION WITH TOP RIGHT WALL //
 5880                        	
 5881                        		.dbg	line,	"include\routines_LEVELS.c", 1046; check_BG( 24 , 15 );
 5882                        		__ld.wi		24
         0E:CF1C  A9 18      			lda.l	#24
         0E:CF1E  C2         			cly
 5883                        		__pusharg.wr
         0E:CF1F  A6 8D      			ldx	<__sp
         0E:CF21  CA         			dex
         0E:CF22  CA         			dex
         0E:CF23  95 08      			sta.l	<__stack, x
         0E:CF25  94 09      			sty.h	<__stack, x
         0E:CF27  86 8D      			stx	<__sp
 5884                        		__ld.wi		15
         0E:CF29  A9 0F      			lda.l	#15
         0E:CF2B  C2         			cly
 5885                        		__pusharg.wr
         0E:CF2C  A6 8D      			ldx	<__sp
         0E:CF2E  CA         			dex
         0E:CF2F  CA         			dex
         0E:CF30  95 08      			sta.l	<__stack, x
         0E:CF32  94 09      			sty.h	<__stack, x
         0E:CF34  86 8D      			stx	<__sp
 5886                        		__call		_check_BG
         0E:CF36  20 6D FF   			call	_check_BG
 5887                        	
 5888                        		.dbg	line,	"include\routines_LEVELS.c", 1048; if(map_blk_flag == TILE_BG)
 5889                        		__ld.umq	_map_blk_flag
         0E:CF39  AD 76 2A   			lda	_map_blk_flag
 5890                        		__equ_b.uiq	1
         0E:CF3C  C9 01      			cmp	#1
         0E:CF3E  F0 01      			beq	!+
         0E:CF40  18         			clc
         0E:CF41             	!:
 5891                        		__bfalse	.LL224
         0E:CF41  90 41      			bcc	.LL224
 5892                        	
 5893                        		.dbg	line,	"include\routines_LEVELS.c", 1049; {
 5894                        	
 5895                        		.dbg	line,	"include\routines_LEVELS.c", 1050; check_TILE_DEPTH( 15 , -16 );
 5896                        		__ld.wi		15
         0E:CF43  A9 0F      			lda.l	#15
         0E:CF45  C2         			cly
 5897                        		__pusharg.wr
         0E:CF46  A6 8D      			ldx	<__sp
         0E:CF48  CA         			dex
         0E:CF49  CA         			dex
         0E:CF4A  95 08      			sta.l	<__stack, x
         0E:CF4C  94 09      			sty.h	<__stack, x
         0E:CF4E  86 8D      			stx	<__sp
 5898                        		__ld.wi		-16
         0E:CF50  A9 F0      			lda.l	#-16
         0E:CF52  A0 FF      			ldy.h	#-16
 5899                        		__pusharg.wr
         0E:CF54  A6 8D      			ldx	<__sp
         0E:CF56  CA         			dex
         0E:CF57  CA         			dex
         0E:CF58  95 08      			sta.l	<__stack, x
         0E:CF5A  94 09      			sty.h	<__stack, x
         0E:CF5C  86 8D      			stx	<__sp
 5900                        		__call		_check_TILE_DEPTH
         0E:CF5E  20 4F FF   			call	_check_TILE_DEPTH
 5901                        	
 5902                        		.dbg	line,	"include\routines_LEVELS.c", 1052; if(map_blk_flag == TILE_EMPTY && jump_ladder == TRUE)
 5903                        		__not.um	_map_blk_flag
         0E:CF61  AD 76 2A   			lda	_map_blk_flag
         0E:CF64  18         			clc
         0E:CF65  D0 01      			bne	!+
         0E:CF67  38         			sec
         0E:CF68             	!:
 5904                        		__bfalse	.LL226
         0E:CF68  90 08      			bcc	.LL226
 5905                        		__ld.umq	_jump_ladder
         0E:CF6A  AD 17 23   			lda	_jump_ladder
 5906                        		__equ_b.uiq	1
         0E:CF6D  C9 01      			cmp	#1
         0E:CF6F  F0 01      			beq	!+
         0E:CF71  18         			clc
         0E:CF72             	!:
 5907    0E:CF72             	.LL226:
 5908                        		__bfalse	.LL225
         0E:CF72  90 5F      			bcc	.LL225
 5909                        	
 5910                        		.dbg	line,	"include\routines_LEVELS.c", 1053; {
 5911                        	
 5912                        		.dbg	line,	"include\routines_LEVELS.c", 1054; jump_ladder = FALSE;
 5913                        		__st.umiq	0, _jump_ladder
         0E:CF74  9C 17 23   			stz	_jump_ladder
 5914                        	
 5915                        		.dbg	line,	"include\routines_LEVELS.c", 1055; player_index_fall = 0;
 5916                        		__st.umiq	0, _player_index_fall
         0E:CF77  9C 16 23   			stz	_player_index_fall
 5917                        	
 5918                        		.dbg	line,	"include\routines_LEVELS.c", 1056; player_state = STATE_FALL;
 5919                        		__st.umiq	9, _player_state
         0E:CF7A  A9 09      			lda.l	#9
         0E:CF7C  8D 11 23   			sta	_player_state
 5920                        	
 5921                        		.dbg	line,	"include\routines_LEVELS.c", 1057; return;
 5922                        		__bra		.LL158
         0E:CF7F  4C 39 DD   			bra	.LL158
 5923                        	
 5924                        		.dbg	line,	"include\routines_LEVELS.c", 1058; }
 5925                        	
 5926                        		.dbg	line,	"include\routines_LEVELS.c", 1059; }
 5927    0E:CF82             	.LL225	.alias		.LL227
 5928                        	
 5929                        		.dbg	line,	"include\routines_LEVELS.c", 1061; else
 5930                        		__bra		.LL227
         0E:CF82  80 4F      			bra	.LL227
 5931    0E:CF84             	.LL224:
 5932                        	
 5933                        		.dbg	line,	"include\routines_LEVELS.c", 1062; {
 5934                        	
 5935                        		.dbg	line,	"include\routines_LEVELS.c", 1063; sgx_map_pxl_x += 2;
 5936                        		__add_st.wmiq	2, _sgx_map_pxl_x
         0E:CF84  18         			clc
         0E:CF85  AD 55 25   			lda.l	_sgx_map_pxl_x
         0E:CF88  69 02      			adc.l	#2
         0E:CF8A  8D 55 25   			sta.l	_sgx_map_pxl_x
         0E:CF8D  90 03      			bcc	!+
         0E:CF8F  EE 56 25   			inc.h	_sgx_map_pxl_x
         0E:CF92             	!:
 5937                        	
 5938                        		.dbg	line,	"include\routines_LEVELS.c", 1064; }
 5939    0E:CF92             	.LL227	.alias		.LL228
 5940                        	
 5941                        		.dbg	line,	"include\routines_LEVELS.c", 1065; }
 5942                        	
 5943                        		.dbg	line,	"include\routines_LEVELS.c", 1067; else
 5944                        		__bra		.LL228
         0E:CF92  80 3F      			bra	.LL228
 5945    0E:CF94             	.LL223:
 5946                        	
 5947                        		.dbg	line,	"include\routines_LEVELS.c", 1068; {
 5948                        	
 5949                        		.dbg	line,	"include\routines_LEVELS.c", 1069; check_TILE_DEPTH( 15 , -16 );
 5950                        		__ld.wi		15
         0E:CF94  A9 0F      			lda.l	#15
         0E:CF96  C2         			cly
 5951                        		__pusharg.wr
         0E:CF97  A6 8D      			ldx	<__sp
         0E:CF99  CA         			dex
         0E:CF9A  CA         			dex
         0E:CF9B  95 08      			sta.l	<__stack, x
         0E:CF9D  94 09      			sty.h	<__stack, x
         0E:CF9F  86 8D      			stx	<__sp
 5952                        		__ld.wi		-16
         0E:CFA1  A9 F0      			lda.l	#-16
         0E:CFA3  A0 FF      			ldy.h	#-16
 5953                        		__pusharg.wr
         0E:CFA5  A6 8D      			ldx	<__sp
         0E:CFA7  CA         			dex
         0E:CFA8  CA         			dex
         0E:CFA9  95 08      			sta.l	<__stack, x
         0E:CFAB  94 09      			sty.h	<__stack, x
         0E:CFAD  86 8D      			stx	<__sp
 5954                        		__call		_check_TILE_DEPTH
         0E:CFAF  20 4F FF   			call	_check_TILE_DEPTH
 5955                        	
 5956                        		.dbg	line,	"include\routines_LEVELS.c", 1071; if(map_blk_flag == TILE_EMPTY && jump_ladder == TRUE)
 5957                        		__not.um	_map_blk_flag
         0E:CFB2  AD 76 2A   			lda	_map_blk_flag
         0E:CFB5  18         			clc
         0E:CFB6  D0 01      			bne	!+
         0E:CFB8  38         			sec
         0E:CFB9             	!:
 5958                        		__bfalse	.LL230
         0E:CFB9  90 08      			bcc	.LL230
 5959                        		__ld.umq	_jump_ladder
         0E:CFBB  AD 17 23   			lda	_jump_ladder
 5960                        		__equ_b.uiq	1
         0E:CFBE  C9 01      			cmp	#1
         0E:CFC0  F0 01      			beq	!+
         0E:CFC2  18         			clc
         0E:CFC3             	!:
 5961    0E:CFC3             	.LL230:
 5962                        		__bfalse	.LL229
         0E:CFC3  90 0E      			bcc	.LL229
 5963                        	
 5964                        		.dbg	line,	"include\routines_LEVELS.c", 1072; {
 5965                        	
 5966                        		.dbg	line,	"include\routines_LEVELS.c", 1073; jump_ladder = FALSE;
 5967                        		__st.umiq	0, _jump_ladder
         0E:CFC5  9C 17 23   			stz	_jump_ladder
 5968                        	
 5969                        		.dbg	line,	"include\routines_LEVELS.c", 1074; player_index_fall = 0;
 5970                        		__st.umiq	0, _player_index_fall
         0E:CFC8  9C 16 23   			stz	_player_index_fall
 5971                        	
 5972                        		.dbg	line,	"include\routines_LEVELS.c", 1075; player_state = STATE_FALL;
 5973                        		__st.umiq	9, _player_state
         0E:CFCB  A9 09      			lda.l	#9
         0E:CFCD  8D 11 23   			sta	_player_state
 5974                        	
 5975                        		.dbg	line,	"include\routines_LEVELS.c", 1076; return;
 5976                        		__bra		.LL158
         0E:CFD0  4C 39 DD   			bra	.LL158
 5977                        	
 5978                        		.dbg	line,	"include\routines_LEVELS.c", 1077; }
 5979                        	
 5980                        		.dbg	line,	"include\routines_LEVELS.c", 1078; }
 5981    0E:CFD3             	.LL229:
 5982    0E:CFD3             	.LL228:
 5983                        	
 5984                        		.dbg	line,	"include\routines_LEVELS.c", 1083; //**************************************************************************************//
 5985                        	
 5986                        		.dbg	line,	"include\routines_LEVELS.c", 1084; //                                        V MOVE                                        //
 5987                        	
 5988                        		.dbg	line,	"include\routines_LEVELS.c", 1085; //**************************************************************************************//
 5989                        	
 5990                        		.dbg	line,	"include\routines_LEVELS.c", 1087; // UPDATE PLAYER Y POSITION //
 5991                        	
 5992                        		.dbg	line,	"include\routines_LEVELS.c", 1088; if(jump_ladder == FALSE)
 5993                        		__not.um	_jump_ladder
         0E:CFD3  AD 17 23   			lda	_jump_ladder
         0E:CFD6  18         			clc
         0E:CFD7  D0 01      			bne	!+
         0E:CFD9  38         			sec
         0E:CFDA             	!:
 5994                        		__bfalse	.LL231
         0E:CFDA  90 1A      			bcc	.LL231
 5995                        	
 5996                        		.dbg	line,	"include\routines_LEVELS.c", 1089; {
 5997                        	
 5998                        		.dbg	line,	"include\routines_LEVELS.c", 1090; player_pos_y += TABLE_PLAYER_JUMP_V[player_index_jump];
 5999                        		__ldx.umq	_player_index_jump
         0E:CFDC  AE 15 23   			ldx	_player_index_jump
 6000                        		__ld.bax	_TABLE_PLAYER_JUMP_V
         0E:CFDF  BD A0 60   			lda	_TABLE_PLAYER_JUMP_V, x
         0E:CFE2  C2         			cly
         0E:CFE3  10 01      			bpl	!+
         0E:CFE5  88         			dey
         0E:CFE6             	!:
 6001                        		__add_st.wmq	_player_pos_y
         0E:CFE6  18         			clc
         0E:CFE7  6D B9 23   			adc.l	_player_pos_y
         0E:CFEA  8D B9 23   			sta.l	_player_pos_y
         0E:CFED  98         			tya
         0E:CFEE  6D BA 23   			adc.h	_player_pos_y
         0E:CFF1  8D BA 23   			sta.h	_player_pos_y
 6002                        	
 6003                        		.dbg	line,	"include\routines_LEVELS.c", 1091; }
 6004                        	
 6005                        		.dbg	line,	"include\routines_LEVELS.c", 1093; else
 6006                        		__bra		.LL232
         0E:CFF4  80 18      			bra	.LL232
 6007    0E:CFF6             	.LL231:
 6008                        	
 6009                        		.dbg	line,	"include\routines_LEVELS.c", 1094; {
 6010                        	
 6011                        		.dbg	line,	"include\routines_LEVELS.c", 1095; player_pos_y += TABLE_PLAYER_JUMP_LADDER[player_index_jump];
 6012                        		__ldx.umq	_player_index_jump
         0E:CFF6  AE 15 23   			ldx	_player_index_jump
 6013                        		__ld.bax	_TABLE_PLAYER_JUMP_LADDER
         0E:CFF9  BD D8 60   			lda	_TABLE_PLAYER_JUMP_LADDER, x
         0E:CFFC  C2         			cly
         0E:CFFD  10 01      			bpl	!+
         0E:CFFF  88         			dey
         0E:D000             	!:
 6014                        		__add_st.wmq	_player_pos_y
         0E:D000  18         			clc
         0E:D001  6D B9 23   			adc.l	_player_pos_y
         0E:D004  8D B9 23   			sta.l	_player_pos_y
         0E:D007  98         			tya
         0E:D008  6D BA 23   			adc.h	_player_pos_y
         0E:D00B  8D BA 23   			sta.h	_player_pos_y
 6015                        	
 6016                        		.dbg	line,	"include\routines_LEVELS.c", 1096; }
 6017    0E:D00E             	.LL232:
 6018                        	
 6019                        		.dbg	line,	"include\routines_LEVELS.c", 1100; // IF PLAYER GOES BELOW ITS BASE Y POSITION //
 6020                        	
 6021                        		.dbg	line,	"include\routines_LEVELS.c", 1101; if(player_pos_y >= PLAYER_BASE_Y_POS)
 6022                        		__ld.wm		_player_pos_y
         0E:D00E  AD B9 23   			lda.l	_player_pos_y
         0E:D011  AC BA 23   			ldy.h	_player_pos_y
 6023                        		__sge_w.wi	128
         0E:D014  C9 80      			cmp.l	#128		; Subtract integer from Y:A.
         0E:D016  98         			tya
         0E:D017  E9 00      			sbc.h	#128
         0E:D019  50 02      			bvc	!+
         0E:D01B  49 80      			eor	#$80		; +ve if Y:A >= integer (signed).
         0E:D01D  49 80      	!:		eor	#$80
         0E:D01F  0A         			asl	a
 6024                        		__bfalse	.LL233
         0E:D020  90 4E      			bcc	.LL233
 6025                        	
 6026                        		.dbg	line,	"include\routines_LEVELS.c", 1102; {
 6027                        	
 6028                        		.dbg	line,	"include\routines_LEVELS.c", 1103; // THE CAMERA MOVES //
 6029                        	
 6030                        		.dbg	line,	"include\routines_LEVELS.c", 1104; // CALCULATE HOW MANY PIXELS THE CAMERA HAS TO MOVE DOWN //
 6031                        	
 6032                        		.dbg	line,	"include\routines_LEVELS.c", 1105; camera_y_move = player_pos_y - PLAYER_BASE_Y_POS;
 6033                        		__ld.wm		_player_pos_y
         0E:D022  AD B9 23   			lda.l	_player_pos_y
         0E:D025  AC BA 23   			ldy.h	_player_pos_y
 6034                        		__sub.wi	128
         0E:D028  38         			sec
         0E:D029  E9 80      			sbc.l	#128
         0E:D02B  B0 01      			bcs	!+
         0E:D02D  88         			dey
         0E:D02E             	!:
 6035                        		__st.umq	__update_PLAYER_end - 3  /* camera_y_move */
         0E:D02E  8D 0A 23   			sta	__update_PLAYER_end - 3
 6036                        	
 6037                        		.dbg	line,	"include\routines_LEVELS.c", 1106; sgx_map_pxl_y += camera_y_move;
 6038                        		__ld.um		__update_PLAYER_end - 3  /* camera_y_move */
         0E:D031  AD 0A 23   			lda	__update_PLAYER_end - 3
         0E:D034  C2         			cly
 6039                        		__add_st.wmq	_sgx_map_pxl_y
         0E:D035  18         			clc
         0E:D036  6D 57 25   			adc.l	_sgx_map_pxl_y
         0E:D039  8D 57 25   			sta.l	_sgx_map_pxl_y
         0E:D03C  98         			tya
         0E:D03D  6D 58 25   			adc.h	_sgx_map_pxl_y
         0E:D040  8D 58 25   			sta.h	_sgx_map_pxl_y
 6040                        	
 6041                        		.dbg	line,	"include\routines_LEVELS.c", 1108; // IF THE CAMERA HAS REACHED ITS MAX (LOWEST) POSITION //
 6042                        	
 6043                        		.dbg	line,	"include\routines_LEVELS.c", 1109; if(sgx_map_pxl_y > camera_max_y_position)
 6044                        		__ld.wm		_sgx_map_pxl_y
         0E:D043  AD 57 25   			lda.l	_sgx_map_pxl_y
         0E:D046  AC 58 25   			ldy.h	_sgx_map_pxl_y
 6045                        		__ugt_w.wm	_camera_max_y_position
         0E:D049  18         			clc			; Subtract memory+1 from Y:A.
         0E:D04A  ED BB 23   			sbc.l	_camera_max_y_position
         0E:D04D  98         			tya
         0E:D04E  ED BC 23   			sbc.h	_camera_max_y_position		; CS if Y:A > memory.
 6046                        		__bfalse	.LL234
         0E:D051  90 0C      			bcc	.LL234
 6047                        	
 6048                        		.dbg	line,	"include\routines_LEVELS.c", 1110; {
 6049                        	
 6050                        		.dbg	line,	"include\routines_LEVELS.c", 1111; // THE CAMERA CAN NOT MOVE LOWER //
 6051                        	
 6052                        		.dbg	line,	"include\routines_LEVELS.c", 1112; sgx_map_pxl_y = camera_max_y_position;
 6053                        		__ld.wm		_camera_max_y_position
         0E:D053  AD BB 23   			lda.l	_camera_max_y_position
         0E:D056  AC BC 23   			ldy.h	_camera_max_y_position
 6054                        		__st.wmq	_sgx_map_pxl_y
         0E:D059  8D 57 25   			sta.l	_sgx_map_pxl_y
         0E:D05C  8C 58 25   			sty.h	_sgx_map_pxl_y
 6055                        	
 6056                        		.dbg	line,	"include\routines_LEVELS.c", 1113; }
 6057                        	
 6058                        		.dbg	line,	"include\routines_LEVELS.c", 1115; // THE PLAYER STAYS AT ITS BASE Y POSITION //
 6059                        	
 6060                        		.dbg	line,	"include\routines_LEVELS.c", 1116; player_pos_y = PLAYER_BASE_Y_POS;
 6061    0E:D05F             	.LL234:
 6062                        		__st.wmiq	128, _player_pos_y
         0E:D05F  A9 80      			lda.l	#128
         0E:D061  8D B9 23   			sta.l	_player_pos_y
         0E:D064  9C BA 23   			stz.h	_player_pos_y
 6063                        	
 6064                        		.dbg	line,	"include\routines_LEVELS.c", 1118; spr_y(player_pos_y);
 6065                        		__ld.wm		_player_pos_y
         0E:D067  AD B9 23   			lda.l	_player_pos_y
         0E:D06A  AC BA 23   			ldy.h	_player_pos_y
 6066                        		__call		_spr_y.1
         0E:D06D  20 19 E8   			call	_spr_y.1
 6067                        	
 6068                        		.dbg	line,	"include\routines_LEVELS.c", 1119; }
 6069                        	
 6070                        		.dbg	line,	"include\routines_LEVELS.c", 1122; // UPDATE JUMP INDEX IN THE ARRAY //
 6071                        	
 6072                        		.dbg	line,	"include\routines_LEVELS.c", 1123; if(player_index_jump < jump_max_index)
 6073    0E:D070             	.LL233:
 6074                        		__ld.umq	_player_index_jump
         0E:D070  AD 15 23   			lda	_player_index_jump
 6075                        		__ult_b.umq	_jump_max_index
         0E:D073  CD 18 23   			cmp	_jump_max_index		; Subtract memory from A.
         0E:D076  6A         			ror	a		; CC if A < memory.
         0E:D077  49 80      			eor	#$80
         0E:D079  2A         			rol	a
 6076                        		__bfalse	.LL235
         0E:D07A  90 03      			bcc	.LL235
 6077                        	
 6078                        		.dbg	line,	"include\routines_LEVELS.c", 1124; {
 6079                        	
 6080                        		.dbg	line,	"include\routines_LEVELS.c", 1125; player_index_jump += 1;
 6081                        		__add_st.umiq	1, _player_index_jump
         0E:D07C  EE 15 23   			inc	_player_index_jump
 6082                        	
 6083                        		.dbg	line,	"include\routines_LEVELS.c", 1126; }
 6084                        	
 6085                        		.dbg	line,	"include\routines_LEVELS.c", 1131; //--------------------------------------------------------------------------------------//
 6086                        	
 6087                        		.dbg	line,	"include\routines_LEVELS.c", 1132; //                                   FLOOR COLLISION                                    //
 6088                        	
 6089                        		.dbg	line,	"include\routines_LEVELS.c", 1133; //--------------------------------------------------------------------------------------//
 6090                        	
 6091                        		.dbg	line,	"include\routines_LEVELS.c", 1135; if(player_index_jump > 14)
 6092    0E:D07F             	.LL235:
 6093                        		__ld.umq	_player_index_jump
         0E:D07F  AD 15 23   			lda	_player_index_jump
 6094                        		__ugt_b.uiq	14
         0E:D082  18         			clc			; Subtract integer+1 from A.
         0E:D083  E9 0E      			sbc	#14		; CS if A > integer.
 6095                        		__bfalse	.LL236
         0E:D085  B0 03 4C 3A			bcc	.LL236
         0E:D089  D2          
 6096                        	
 6097                        		.dbg	line,	"include\routines_LEVELS.c", 1136; {
 6098                        	
 6099                        		.dbg	line,	"include\routines_LEVELS.c", 1137; // CHECK COLLISION WITH LEFT FLOOR //
 6100                        	
 6101                        		.dbg	line,	"include\routines_LEVELS.c", 1138; check_BG( 10 , 32 );
 6102                        		__ld.wi		10
         0E:D08A  A9 0A      			lda.l	#10
         0E:D08C  C2         			cly
 6103                        		__pusharg.wr
         0E:D08D  A6 8D      			ldx	<__sp
         0E:D08F  CA         			dex
         0E:D090  CA         			dex
         0E:D091  95 08      			sta.l	<__stack, x
         0E:D093  94 09      			sty.h	<__stack, x
         0E:D095  86 8D      			stx	<__sp
 6104                        		__ld.wi		32
         0E:D097  A9 20      			lda.l	#32
         0E:D099  C2         			cly
 6105                        		__pusharg.wr
         0E:D09A  A6 8D      			ldx	<__sp
         0E:D09C  CA         			dex
         0E:D09D  CA         			dex
         0E:D09E  95 08      			sta.l	<__stack, x
         0E:D0A0  94 09      			sty.h	<__stack, x
         0E:D0A2  86 8D      			stx	<__sp
 6106                        		__call		_check_BG
         0E:D0A4  20 6D FF   			call	_check_BG
 6107                        	
 6108                        		.dbg	line,	"include\routines_LEVELS.c", 1140; // IF PLAYER TOUCHES THE GROUND TO THE LEFT //
 6109                        	
 6110                        		.dbg	line,	"include\routines_LEVELS.c", 1141; if(map_blk_flag == TILE_BG)
 6111                        		__ld.umq	_map_blk_flag
         0E:D0A7  AD 76 2A   			lda	_map_blk_flag
 6112                        		__equ_b.uiq	1
         0E:D0AA  C9 01      			cmp	#1
         0E:D0AC  F0 01      			beq	!+
         0E:D0AE  18         			clc
         0E:D0AF             	!:
 6113                        		__bfalse	.LL237
         0E:D0AF  B0 03 4C 62			bcc	.LL237
         0E:D0B3  D1          
 6114                        	
 6115                        		.dbg	line,	"include\routines_LEVELS.c", 1142; {
 6116                        	
 6117                        		.dbg	line,	"include\routines_LEVELS.c", 1143; // CALCULATE HOW MANY PIXELS THE PLAYER MOVED INTO THE GROUND //
 6118                        	
 6119                        		.dbg	line,	"include\routines_LEVELS.c", 1144; for(i=1; i<11 ; i++)
 6120                        		__st.umiq	1, __update_PLAYER_end - 2  /* i */
         0E:D0B4  A9 01      			lda.l	#1
         0E:D0B6  8D 0B 23   			sta	__update_PLAYER_end - 2
 6121    0E:D0B9             	.LL238:
 6122                        		__ld.umq	__update_PLAYER_end - 2  /* i */
         0E:D0B9  AD 0B 23   			lda	__update_PLAYER_end - 2
 6123                        		__ult_b.uiq	11
         0E:D0BC  C9 0B      			cmp	#11		; Subtract integer from A.
         0E:D0BE  6A         			ror	a		; CC if A < integer.
         0E:D0BF  49 80      			eor	#$80
         0E:D0C1  2A         			rol	a
 6124                        		__btrue		.LL240
         0E:D0C2  B0 07      			bcs	.LL240
 6125                        		__bra		.LL241
         0E:D0C4  80 7D      			bra	.LL241
 6126    0E:D0C6             	.LL239:
 6127                        		__inc.umq	__update_PLAYER_end - 2  /* i */
         0E:D0C6  EE 0B 23   			inc	__update_PLAYER_end - 2
 6128                        		__bra		.LL238
         0E:D0C9  80 EE      			bra	.LL238
 6129    0E:D0CB             	.LL240:
 6130                        	
 6131                        		.dbg	line,	"include\routines_LEVELS.c", 1145; {
 6132                        	
 6133                        		.dbg	line,	"include\routines_LEVELS.c", 1146; check_TILE_DEPTH( 10 , i);
 6134                        		__ld.wi		10
         0E:D0CB  A9 0A      			lda.l	#10
         0E:D0CD  C2         			cly
 6135                        		__pusharg.wr
         0E:D0CE  A6 8D      			ldx	<__sp
         0E:D0D0  CA         			dex
         0E:D0D1  CA         			dex
         0E:D0D2  95 08      			sta.l	<__stack, x
         0E:D0D4  94 09      			sty.h	<__stack, x
         0E:D0D6  86 8D      			stx	<__sp
 6136                        		__ld.um		__update_PLAYER_end - 2  /* i */
         0E:D0D8  AD 0B 23   			lda	__update_PLAYER_end - 2
         0E:D0DB  C2         			cly
 6137                        		__pusharg.wr
         0E:D0DC  A6 8D      			ldx	<__sp
         0E:D0DE  CA         			dex
         0E:D0DF  CA         			dex
         0E:D0E0  95 08      			sta.l	<__stack, x
         0E:D0E2  94 09      			sty.h	<__stack, x
         0E:D0E4  86 8D      			stx	<__sp
 6138                        		__call		_check_TILE_DEPTH
         0E:D0E6  20 4F FF   			call	_check_TILE_DEPTH
 6139                        	
 6140                        		.dbg	line,	"include\routines_LEVELS.c", 1148; if(map_blk_flag == TILE_EMPTY)
 6141                        		__not.um	_map_blk_flag
         0E:D0E9  AD 76 2A   			lda	_map_blk_flag
         0E:D0EC  18         			clc
         0E:D0ED  D0 01      			bne	!+
         0E:D0EF  38         			sec
         0E:D0F0             	!:
 6142                        		__bfalse	.LL242
         0E:D0F0  90 D4      			bcc	.LL242
 6143                        	
 6144                        		.dbg	line,	"include\routines_LEVELS.c", 1149; {
 6145                        	
 6146                        		.dbg	line,	"include\routines_LEVELS.c", 1150; if(player_pos_y != PLAYER_BASE_Y_POS)
 6147                        		__ld.wm		_player_pos_y
         0E:D0F2  AD B9 23   			lda.l	_player_pos_y
         0E:D0F5  AC BA 23   			ldy.h	_player_pos_y
 6148                        		__neq_w.wi	128
         0E:D0F8  38         			sec
         0E:D0F9  49 80      			eor.l	#128
         0E:D0FB  D0 06      			bne	!+
         0E:D0FD  98         			tya
         0E:D0FE  49 00      			eor.h	#128
         0E:D100  D0 01      			bne	!+
         0E:D102  18         			clc
         0E:D103             	!:
 6149                        		__bfalse	.LL243
         0E:D103  90 1E      			bcc	.LL243
 6150                        	
 6151                        		.dbg	line,	"include\routines_LEVELS.c", 1151; {
 6152                        	
 6153                        		.dbg	line,	"include\routines_LEVELS.c", 1152; player_pos_y -= (i - 1);
 6154                        		__ld.um		__update_PLAYER_end - 2  /* i */
         0E:D105  AD 0B 23   			lda	__update_PLAYER_end - 2
         0E:D108  C2         			cly
 6155                        		__sub.wi	1
         0E:D109  38         			sec
         0E:D10A  E9 01      			sbc.l	#1
         0E:D10C  B0 01      			bcs	!+
         0E:D10E  88         			dey
         0E:D10F             	!:
 6156                        		__isub_st.wmq	_player_pos_y
         0E:D10F  38         			sec
         0E:D110  49 FF      			eor	#$FF
         0E:D112  6D B9 23   			adc.l	_player_pos_y
         0E:D115  8D B9 23   			sta.l	_player_pos_y
         0E:D118  98         			tya
         0E:D119  49 FF      			eor	#$FF
         0E:D11B  6D BA 23   			adc.h	_player_pos_y
         0E:D11E  8D BA 23   			sta.h	_player_pos_y
 6157                        	
 6158                        		.dbg	line,	"include\routines_LEVELS.c", 1153; }
 6159                        	
 6160                        		.dbg	line,	"include\routines_LEVELS.c", 1155; else
 6161                        		__bra		.LL244
         0E:D121  80 20      			bra	.LL244
 6162    0E:D123             	.LL243:
 6163                        	
 6164                        		.dbg	line,	"include\routines_LEVELS.c", 1156; {
 6165                        	
 6166                        		.dbg	line,	"include\routines_LEVELS.c", 1157; sgx_map_pxl_y -= (i - 1);
 6167                        		__ld.um		__update_PLAYER_end - 2  /* i */
         0E:D123  AD 0B 23   			lda	__update_PLAYER_end - 2
         0E:D126  C2         			cly
 6168                        		__sub.wi	1
         0E:D127  38         			sec
         0E:D128  E9 01      			sbc.l	#1
         0E:D12A  B0 01      			bcs	!+
         0E:D12C  88         			dey
         0E:D12D             	!:
 6169                        		__isub_st.wmq	_sgx_map_pxl_y
         0E:D12D  38         			sec
         0E:D12E  49 FF      			eor	#$FF
         0E:D130  6D 57 25   			adc.l	_sgx_map_pxl_y
         0E:D133  8D 57 25   			sta.l	_sgx_map_pxl_y
         0E:D136  98         			tya
         0E:D137  49 FF      			eor	#$FF
         0E:D139  6D 58 25   			adc.h	_sgx_map_pxl_y
         0E:D13C  8D 58 25   			sta.h	_sgx_map_pxl_y
 6170                        	
 6171                        		.dbg	line,	"include\routines_LEVELS.c", 1158; }
 6172    0E:D13F             	.LL244	.alias		.LL241
 6173                        	
 6174                        		.dbg	line,	"include\routines_LEVELS.c", 1160; break;
 6175                        		__bra		.LL241
         0E:D13F  80 02      			bra	.LL241
 6176                        	
 6177                        		.dbg	line,	"include\routines_LEVELS.c", 1161; }
 6178                        	
 6179                        		.dbg	line,	"include\routines_LEVELS.c", 1162; }
 6180    0E:D141             	.LL242	.alias		.LL239
 6181                        		__bra		.LL239
         0E:D141  80 83      			bra	.LL239
 6182    0E:D143             	.LL241:
 6183                        	
 6184                        		.dbg	line,	"include\routines_LEVELS.c", 1164; // SET PLAYER SPRITE NEW POSITION //
 6185                        	
 6186                        		.dbg	line,	"include\routines_LEVELS.c", 1165; spr_y(player_pos_y);
 6187                        		__ld.wm		_player_pos_y
         0E:D143  AD B9 23   			lda.l	_player_pos_y
         0E:D146  AC BA 23   			ldy.h	_player_pos_y
 6188                        		__call		_spr_y.1
         0E:D149  20 19 E8   			call	_spr_y.1
 6189                        	
 6190                        		.dbg	line,	"include\routines_LEVELS.c", 1167; player_counter_anim = 1;
 6191                        		__st.umiq	1, _player_counter_anim
         0E:D14C  A9 01      			lda.l	#1
         0E:D14E  8D 14 23   			sta	_player_counter_anim
 6192                        	
 6193                        		.dbg	line,	"include\routines_LEVELS.c", 1168; player_index_jump = 0;
 6194                        		__st.umiq	0, _player_index_jump
         0E:D151  9C 15 23   			stz	_player_index_jump
 6195                        	
 6196                        		.dbg	line,	"include\routines_LEVELS.c", 1169; jump_ladder = FALSE;
 6197                        		__st.umiq	0, _jump_ladder
         0E:D154  9C 17 23   			stz	_jump_ladder
 6198                        	
 6199                        		.dbg	line,	"include\routines_LEVELS.c", 1170; jump_max_index = 34;
 6200                        		__st.umiq	34, _jump_max_index
         0E:D157  A9 22      			lda.l	#34
         0E:D159  8D 18 23   			sta	_jump_max_index
 6201                        	
 6202                        		.dbg	line,	"include\routines_LEVELS.c", 1171; player_state = STATE_IDLE;
 6203                        		__st.umiq	0, _player_state
         0E:D15C  9C 11 23   			stz	_player_state
 6204                        	
 6205                        		.dbg	line,	"include\routines_LEVELS.c", 1172; return;
 6206                        		__bra		.LL158
         0E:D15F  4C 39 DD   			bra	.LL158
 6207                        	
 6208                        		.dbg	line,	"include\routines_LEVELS.c", 1173; }
 6209                        	
 6210                        		.dbg	line,	"include\routines_LEVELS.c", 1175; // IF PLAYER TOUCHES THE GROUND TO THE RIGHT //
 6211                        	
 6212                        		.dbg	line,	"include\routines_LEVELS.c", 1176; else
 6213    0E:D162             	.LL237:
 6214                        	
 6215                        		.dbg	line,	"include\routines_LEVELS.c", 1177; {
 6216                        	
 6217                        		.dbg	line,	"include\routines_LEVELS.c", 1178; // CHECK COLLISION WITH RIGHT FLOOR //
 6218                        	
 6219                        		.dbg	line,	"include\routines_LEVELS.c", 1179; check_BG( 22 , 32 );
 6220                        		__ld.wi		22
         0E:D162  A9 16      			lda.l	#22
         0E:D164  C2         			cly
 6221                        		__pusharg.wr
         0E:D165  A6 8D      			ldx	<__sp
         0E:D167  CA         			dex
         0E:D168  CA         			dex
         0E:D169  95 08      			sta.l	<__stack, x
         0E:D16B  94 09      			sty.h	<__stack, x
         0E:D16D  86 8D      			stx	<__sp
 6222                        		__ld.wi		32
         0E:D16F  A9 20      			lda.l	#32
         0E:D171  C2         			cly
 6223                        		__pusharg.wr
         0E:D172  A6 8D      			ldx	<__sp
         0E:D174  CA         			dex
         0E:D175  CA         			dex
         0E:D176  95 08      			sta.l	<__stack, x
         0E:D178  94 09      			sty.h	<__stack, x
         0E:D17A  86 8D      			stx	<__sp
 6224                        		__call		_check_BG
         0E:D17C  20 6D FF   			call	_check_BG
 6225                        	
 6226                        		.dbg	line,	"include\routines_LEVELS.c", 1181; if(map_blk_flag == TILE_BG)
 6227                        		__ld.umq	_map_blk_flag
         0E:D17F  AD 76 2A   			lda	_map_blk_flag
 6228                        		__equ_b.uiq	1
         0E:D182  C9 01      			cmp	#1
         0E:D184  F0 01      			beq	!+
         0E:D186  18         			clc
         0E:D187             	!:
 6229                        		__bfalse	.LL246
         0E:D187  B0 03 4C 3A			bcc	.LL246
         0E:D18B  D2          
 6230                        	
 6231                        		.dbg	line,	"include\routines_LEVELS.c", 1182; {
 6232                        	
 6233                        		.dbg	line,	"include\routines_LEVELS.c", 1183; // CALCULATE HOW MANY PIXELS THE PLAYER MOVED INTO THE GROUND //
 6234                        	
 6235                        		.dbg	line,	"include\routines_LEVELS.c", 1184; for(i=1; i<11 ; i++)
 6236                        		__st.umiq	1, __update_PLAYER_end - 2  /* i */
         0E:D18C  A9 01      			lda.l	#1
         0E:D18E  8D 0B 23   			sta	__update_PLAYER_end - 2
 6237    0E:D191             	.LL247:
 6238                        		__ld.umq	__update_PLAYER_end - 2  /* i */
         0E:D191  AD 0B 23   			lda	__update_PLAYER_end - 2
 6239                        		__ult_b.uiq	11
         0E:D194  C9 0B      			cmp	#11		; Subtract integer from A.
         0E:D196  6A         			ror	a		; CC if A < integer.
         0E:D197  49 80      			eor	#$80
         0E:D199  2A         			rol	a
 6240                        		__btrue		.LL249
         0E:D19A  B0 07      			bcs	.LL249
 6241                        		__bra		.LL250
         0E:D19C  80 7D      			bra	.LL250
 6242    0E:D19E             	.LL248:
 6243                        		__inc.umq	__update_PLAYER_end - 2  /* i */
         0E:D19E  EE 0B 23   			inc	__update_PLAYER_end - 2
 6244                        		__bra		.LL247
         0E:D1A1  80 EE      			bra	.LL247
 6245    0E:D1A3             	.LL249:
 6246                        	
 6247                        		.dbg	line,	"include\routines_LEVELS.c", 1185; {
 6248                        	
 6249                        		.dbg	line,	"include\routines_LEVELS.c", 1186; check_TILE_DEPTH( 22 , i);
 6250                        		__ld.wi		22
         0E:D1A3  A9 16      			lda.l	#22
         0E:D1A5  C2         			cly
 6251                        		__pusharg.wr
         0E:D1A6  A6 8D      			ldx	<__sp
         0E:D1A8  CA         			dex
         0E:D1A9  CA         			dex
         0E:D1AA  95 08      			sta.l	<__stack, x
         0E:D1AC  94 09      			sty.h	<__stack, x
         0E:D1AE  86 8D      			stx	<__sp
 6252                        		__ld.um		__update_PLAYER_end - 2  /* i */
         0E:D1B0  AD 0B 23   			lda	__update_PLAYER_end - 2
         0E:D1B3  C2         			cly
 6253                        		__pusharg.wr
         0E:D1B4  A6 8D      			ldx	<__sp
         0E:D1B6  CA         			dex
         0E:D1B7  CA         			dex
         0E:D1B8  95 08      			sta.l	<__stack, x
         0E:D1BA  94 09      			sty.h	<__stack, x
         0E:D1BC  86 8D      			stx	<__sp
 6254                        		__call		_check_TILE_DEPTH
         0E:D1BE  20 4F FF   			call	_check_TILE_DEPTH
 6255                        	
 6256                        		.dbg	line,	"include\routines_LEVELS.c", 1188; if(map_blk_flag == TILE_EMPTY)
 6257                        		__not.um	_map_blk_flag
         0E:D1C1  AD 76 2A   			lda	_map_blk_flag
         0E:D1C4  18         			clc
         0E:D1C5  D0 01      			bne	!+
         0E:D1C7  38         			sec
         0E:D1C8             	!:
 6258                        		__bfalse	.LL251
         0E:D1C8  90 D4      			bcc	.LL251
 6259                        	
 6260                        		.dbg	line,	"include\routines_LEVELS.c", 1189; {
 6261                        	
 6262                        		.dbg	line,	"include\routines_LEVELS.c", 1190; if(player_pos_y != PLAYER_BASE_Y_POS)
 6263                        		__ld.wm		_player_pos_y
         0E:D1CA  AD B9 23   			lda.l	_player_pos_y
         0E:D1CD  AC BA 23   			ldy.h	_player_pos_y
 6264                        		__neq_w.wi	128
         0E:D1D0  38         			sec
         0E:D1D1  49 80      			eor.l	#128
         0E:D1D3  D0 06      			bne	!+
         0E:D1D5  98         			tya
         0E:D1D6  49 00      			eor.h	#128
         0E:D1D8  D0 01      			bne	!+
         0E:D1DA  18         			clc
         0E:D1DB             	!:
 6265                        		__bfalse	.LL252
         0E:D1DB  90 1E      			bcc	.LL252
 6266                        	
 6267                        		.dbg	line,	"include\routines_LEVELS.c", 1191; {
 6268                        	
 6269                        		.dbg	line,	"include\routines_LEVELS.c", 1192; player_pos_y -= (i - 1);
 6270                        		__ld.um		__update_PLAYER_end - 2  /* i */
         0E:D1DD  AD 0B 23   			lda	__update_PLAYER_end - 2
         0E:D1E0  C2         			cly
 6271                        		__sub.wi	1
         0E:D1E1  38         			sec
         0E:D1E2  E9 01      			sbc.l	#1
         0E:D1E4  B0 01      			bcs	!+
         0E:D1E6  88         			dey
         0E:D1E7             	!:
 6272                        		__isub_st.wmq	_player_pos_y
         0E:D1E7  38         			sec
         0E:D1E8  49 FF      			eor	#$FF
         0E:D1EA  6D B9 23   			adc.l	_player_pos_y
         0E:D1ED  8D B9 23   			sta.l	_player_pos_y
         0E:D1F0  98         			tya
         0E:D1F1  49 FF      			eor	#$FF
         0E:D1F3  6D BA 23   			adc.h	_player_pos_y
         0E:D1F6  8D BA 23   			sta.h	_player_pos_y
 6273                        	
 6274                        		.dbg	line,	"include\routines_LEVELS.c", 1193; }
 6275                        	
 6276                        		.dbg	line,	"include\routines_LEVELS.c", 1195; else
 6277                        		__bra		.LL253
         0E:D1F9  80 20      			bra	.LL253
 6278    0E:D1FB             	.LL252:
 6279                        	
 6280                        		.dbg	line,	"include\routines_LEVELS.c", 1196; {
 6281                        	
 6282                        		.dbg	line,	"include\routines_LEVELS.c", 1197; sgx_map_pxl_y -= (i - 1);
 6283                        		__ld.um		__update_PLAYER_end - 2  /* i */
         0E:D1FB  AD 0B 23   			lda	__update_PLAYER_end - 2
         0E:D1FE  C2         			cly
 6284                        		__sub.wi	1
         0E:D1FF  38         			sec
         0E:D200  E9 01      			sbc.l	#1
         0E:D202  B0 01      			bcs	!+
         0E:D204  88         			dey
         0E:D205             	!:
 6285                        		__isub_st.wmq	_sgx_map_pxl_y
         0E:D205  38         			sec
         0E:D206  49 FF      			eor	#$FF
         0E:D208  6D 57 25   			adc.l	_sgx_map_pxl_y
         0E:D20B  8D 57 25   			sta.l	_sgx_map_pxl_y
         0E:D20E  98         			tya
         0E:D20F  49 FF      			eor	#$FF
         0E:D211  6D 58 25   			adc.h	_sgx_map_pxl_y
         0E:D214  8D 58 25   			sta.h	_sgx_map_pxl_y
 6286                        	
 6287                        		.dbg	line,	"include\routines_LEVELS.c", 1198; }
 6288    0E:D217             	.LL253	.alias		.LL250
 6289                        	
 6290                        		.dbg	line,	"include\routines_LEVELS.c", 1200; break;
 6291                        		__bra		.LL250
         0E:D217  80 02      			bra	.LL250
 6292                        	
 6293                        		.dbg	line,	"include\routines_LEVELS.c", 1201; }
 6294                        	
 6295                        		.dbg	line,	"include\routines_LEVELS.c", 1202; }
 6296    0E:D219             	.LL251	.alias		.LL248
 6297                        		__bra		.LL248
         0E:D219  80 83      			bra	.LL248
 6298    0E:D21B             	.LL250:
 6299                        	
 6300                        		.dbg	line,	"include\routines_LEVELS.c", 1204; // SET PLAYER SPRITE NEW POSITION //
 6301                        	
 6302                        		.dbg	line,	"include\routines_LEVELS.c", 1205; spr_y(player_pos_y);
 6303                        		__ld.wm		_player_pos_y
         0E:D21B  AD B9 23   			lda.l	_player_pos_y
         0E:D21E  AC BA 23   			ldy.h	_player_pos_y
 6304                        		__call		_spr_y.1
         0E:D221  20 19 E8   			call	_spr_y.1
 6305                        	
 6306                        		.dbg	line,	"include\routines_LEVELS.c", 1207; player_counter_anim = 1;
 6307                        		__st.umiq	1, _player_counter_anim
         0E:D224  A9 01      			lda.l	#1
         0E:D226  8D 14 23   			sta	_player_counter_anim
 6308                        	
 6309                        		.dbg	line,	"include\routines_LEVELS.c", 1208; player_index_jump = 0;
 6310                        		__st.umiq	0, _player_index_jump
         0E:D229  9C 15 23   			stz	_player_index_jump
 6311                        	
 6312                        		.dbg	line,	"include\routines_LEVELS.c", 1209; jump_ladder = FALSE;
 6313                        		__st.umiq	0, _jump_ladder
         0E:D22C  9C 17 23   			stz	_jump_ladder
 6314                        	
 6315                        		.dbg	line,	"include\routines_LEVELS.c", 1210; jump_max_index = 34;
 6316                        		__st.umiq	34, _jump_max_index
         0E:D22F  A9 22      			lda.l	#34
         0E:D231  8D 18 23   			sta	_jump_max_index
 6317                        	
 6318                        		.dbg	line,	"include\routines_LEVELS.c", 1211; player_state = STATE_IDLE;
 6319                        		__st.umiq	0, _player_state
         0E:D234  9C 11 23   			stz	_player_state
 6320                        	
 6321                        		.dbg	line,	"include\routines_LEVELS.c", 1212; return;
 6322                        		__bra		.LL158
         0E:D237  4C 39 DD   			bra	.LL158
 6323                        	
 6324                        		.dbg	line,	"include\routines_LEVELS.c", 1213; }
 6325                        	
 6326                        		.dbg	line,	"include\routines_LEVELS.c", 1214; }
 6327    0E:D23A             	.LL246:
 6328    0E:D23A             	.LL245:
 6329                        	
 6330                        		.dbg	line,	"include\routines_LEVELS.c", 1215; }
 6331                        	
 6332                        		.dbg	line,	"include\routines_LEVELS.c", 1220; //--------------------------------------------------------------------------------------//
 6333                        	
 6334                        		.dbg	line,	"include\routines_LEVELS.c", 1221; //                                   LADDER COLLISION                                   //
 6335                        	
 6336                        		.dbg	line,	"include\routines_LEVELS.c", 1222; //--------------------------------------------------------------------------------------//
 6337                        	
 6338                        		.dbg	line,	"include\routines_LEVELS.c", 1224; if(player_index_jump > 4)
 6339    0E:D23A             	.LL236:
 6340                        		__ld.umq	_player_index_jump
         0E:D23A  AD 15 23   			lda	_player_index_jump
 6341                        		__ugt_b.uiq	4
         0E:D23D  18         			clc			; Subtract integer+1 from A.
         0E:D23E  E9 04      			sbc	#4		; CS if A > integer.
 6342                        		__bfalse	.LL254
         0E:D240  B0 03 4C D1			bcc	.LL254
         0E:D244  D2          
 6343                        	
 6344                        		.dbg	line,	"include\routines_LEVELS.c", 1225; {
 6345                        	
 6346                        		.dbg	line,	"include\routines_LEVELS.c", 1226; check_BG( 16 , 16 );
 6347                        		__ld.wi		16
         0E:D245  A9 10      			lda.l	#16
         0E:D247  C2         			cly
 6348                        		__pusharg.wr
         0E:D248  A6 8D      			ldx	<__sp
         0E:D24A  CA         			dex
         0E:D24B  CA         			dex
         0E:D24C  95 08      			sta.l	<__stack, x
         0E:D24E  94 09      			sty.h	<__stack, x
         0E:D250  86 8D      			stx	<__sp
 6349                        		__ld.wi		16
         0E:D252  A9 10      			lda.l	#16
         0E:D254  C2         			cly
 6350                        		__pusharg.wr
         0E:D255  A6 8D      			ldx	<__sp
         0E:D257  CA         			dex
         0E:D258  CA         			dex
         0E:D259  95 08      			sta.l	<__stack, x
         0E:D25B  94 09      			sty.h	<__stack, x
         0E:D25D  86 8D      			stx	<__sp
 6351                        		__call		_check_BG
         0E:D25F  20 6D FF   			call	_check_BG
 6352                        	
 6353                        		.dbg	line,	"include\routines_LEVELS.c", 1228; // IF PLAYER HITS THE LADDER //
 6354                        	
 6355                        		.dbg	line,	"include\routines_LEVELS.c", 1229; if(map_blk_flag == TILE_LADDER)
 6356                        		__ld.umq	_map_blk_flag
         0E:D262  AD 76 2A   			lda	_map_blk_flag
 6357                        		__equ_b.uiq	2
         0E:D265  C9 02      			cmp	#2
         0E:D267  F0 01      			beq	!+
         0E:D269  18         			clc
         0E:D26A             	!:
 6358                        		__bfalse	.LL255
         0E:D26A  90 65      			bcc	.LL255
 6359                        	
 6360                        		.dbg	line,	"include\routines_LEVELS.c", 1230; {
 6361                        	
 6362                        		.dbg	line,	"include\routines_LEVELS.c", 1231; // CAMERA GOES 8 PX BACKWARD //
 6363                        	
 6364                        		.dbg	line,	"include\routines_LEVELS.c", 1232; sgx_map_pxl_x = ( (sgx_map_pxl_x >> 3) << 3 );
 6365                        		__ld.wm		_sgx_map_pxl_x
         0E:D26C  AD 55 25   			lda.l	_sgx_map_pxl_x
         0E:D26F  AC 56 25   			ldy.h	_sgx_map_pxl_x
 6366                        		__lsr.wi	3
         0E:D272  84 00      			sty	__temp
         0E:D274  20 3A E2   			jsr	lsrw3
 6367                        		__asl.wi	3
         0E:D277  84 00      			sty	__temp
         0E:D279  20 D7 E1   			jsr	aslw3
 6368                        		__st.wmq	_sgx_map_pxl_x
         0E:D27C  8D 55 25   			sta.l	_sgx_map_pxl_x
         0E:D27F  8C 56 25   			sty.h	_sgx_map_pxl_x
 6369                        	
 6370                        		.dbg	line,	"include\routines_LEVELS.c", 1234; // SO WE UPDATE THE MAP //
 6371                        	
 6372                        		.dbg	line,	"include\routines_LEVELS.c", 1235; sgx_scroll_map();
 6373                        		__call		_sgx_scroll_map
         0E:D282  20 81 FF   			call	_sgx_scroll_map
 6374                        	
 6375                        		.dbg	line,	"include\routines_LEVELS.c", 1237; // CHECK IF THE PLAYER STANDS RIGHT TO THE LADDER //
 6376                        	
 6377                        		.dbg	line,	"include\routines_LEVELS.c", 1238; check_BG( 31 , 16 );
 6378                        		__ld.wi		31
         0E:D285  A9 1F      			lda.l	#31
         0E:D287  C2         			cly
 6379                        		__pusharg.wr
         0E:D288  A6 8D      			ldx	<__sp
         0E:D28A  CA         			dex
         0E:D28B  CA         			dex
         0E:D28C  95 08      			sta.l	<__stack, x
         0E:D28E  94 09      			sty.h	<__stack, x
         0E:D290  86 8D      			stx	<__sp
 6380                        		__ld.wi		16
         0E:D292  A9 10      			lda.l	#16
         0E:D294  C2         			cly
 6381                        		__pusharg.wr
         0E:D295  A6 8D      			ldx	<__sp
         0E:D297  CA         			dex
         0E:D298  CA         			dex
         0E:D299  95 08      			sta.l	<__stack, x
         0E:D29B  94 09      			sty.h	<__stack, x
         0E:D29D  86 8D      			stx	<__sp
 6382                        		__call		_check_BG
         0E:D29F  20 6D FF   			call	_check_BG
 6383                        	
 6384                        		.dbg	line,	"include\routines_LEVELS.c", 1240; if(map_blk_flag == TILE_LADDER)
 6385                        		__ld.umq	_map_blk_flag
         0E:D2A2  AD 76 2A   			lda	_map_blk_flag
 6386                        		__equ_b.uiq	2
         0E:D2A5  C9 02      			cmp	#2
         0E:D2A7  F0 01      			beq	!+
         0E:D2A9  18         			clc
         0E:D2AA             	!:
 6387                        		__bfalse	.LL256
         0E:D2AA  90 0E      			bcc	.LL256
 6388                        	
 6389                        		.dbg	line,	"include\routines_LEVELS.c", 1241; {
 6390                        	
 6391                        		.dbg	line,	"include\routines_LEVELS.c", 1242; sgx_map_pxl_x += 8;
 6392                        		__add_st.wmiq	8, _sgx_map_pxl_x
         0E:D2AC  18         			clc
         0E:D2AD  AD 55 25   			lda.l	_sgx_map_pxl_x
         0E:D2B0  69 08      			adc.l	#8
         0E:D2B2  8D 55 25   			sta.l	_sgx_map_pxl_x
         0E:D2B5  90 03      			bcc	!+
         0E:D2B7  EE 56 25   			inc.h	_sgx_map_pxl_x
         0E:D2BA             	!:
 6393                        	
 6394                        		.dbg	line,	"include\routines_LEVELS.c", 1243; }
 6395                        	
 6396                        		.dbg	line,	"include\routines_LEVELS.c", 1245; player_counter_anim = 1;
 6397    0E:D2BA             	.LL256:
 6398                        		__st.umiq	1, _player_counter_anim
         0E:D2BA  A9 01      			lda.l	#1
         0E:D2BC  8D 14 23   			sta	_player_counter_anim
 6399                        	
 6400                        		.dbg	line,	"include\routines_LEVELS.c", 1246; player_index_jump = 0;
 6401                        		__st.umiq	0, _player_index_jump
         0E:D2BF  9C 15 23   			stz	_player_index_jump
 6402                        	
 6403                        		.dbg	line,	"include\routines_LEVELS.c", 1247; jump_ladder = TRUE;
 6404                        		__st.umiq	1, _jump_ladder
         0E:D2C2  A9 01      			lda.l	#1
         0E:D2C4  8D 17 23   			sta	_jump_ladder
 6405                        	
 6406                        		.dbg	line,	"include\routines_LEVELS.c", 1248; jump_max_index = 29;
 6407                        		__st.umiq	29, _jump_max_index
         0E:D2C7  A9 1D      			lda.l	#29
         0E:D2C9  8D 18 23   			sta	_jump_max_index
 6408                        	
 6409                        		.dbg	line,	"include\routines_LEVELS.c", 1249; player_state = STATE_HANG;
 6410                        		__st.umiq	10, _player_state
         0E:D2CC  A9 0A      			lda.l	#10
         0E:D2CE  8D 11 23   			sta	_player_state
 6411                        	
 6412                        		.dbg	line,	"include\routines_LEVELS.c", 1250; }
 6413                        	
 6414                        		.dbg	line,	"include\routines_LEVELS.c", 1251; }
 6415    0E:D2D1             	.LL255:
 6416                        	
 6417                        		.dbg	line,	"include\routines_LEVELS.c", 1254; // SET PLAYER SPRITE NEW POSITION //
 6418                        	
 6419                        		.dbg	line,	"include\routines_LEVELS.c", 1255; spr_y(player_pos_y);
 6420    0E:D2D1             	.LL254:
 6421                        		__ld.wm		_player_pos_y
         0E:D2D1  AD B9 23   			lda.l	_player_pos_y
         0E:D2D4  AC BA 23   			ldy.h	_player_pos_y
 6422                        		__call		_spr_y.1
         0E:D2D7  20 19 E8   			call	_spr_y.1
 6423                        	
 6424                        		.dbg	line,	"include\routines_LEVELS.c", 1256; }
 6425                        	
 6426                        		.dbg	line,	"include\routines_LEVELS.c", 1259; else if(player_state == STATE_JUMP_LEFT)
 6427                        		__bra		.LL257
         0E:D2DA  4C 39 DD   			bra	.LL257
 6428    0E:D2DD             	.LL221:
 6429                        		__ld.umq	_player_state
         0E:D2DD  AD 11 23   			lda	_player_state
 6430                        		__equ_b.uiq	6
         0E:D2E0  C9 06      			cmp	#6
         0E:D2E2  F0 01      			beq	!+
         0E:D2E4  18         			clc
         0E:D2E5             	!:
 6431                        		__bfalse	.LL258
         0E:D2E5  B0 03 4C 08			bcc	.LL258
         0E:D2E9  D7          
 6432                        	
 6433                        		.dbg	line,	"include\routines_LEVELS.c", 1260; {
 6434                        	
 6435                        		.dbg	line,	"include\routines_LEVELS.c", 1261; unsigned char i, camera_y_move;
 6436                        	
 6437                        		.dbg	line,	"include\routines_LEVELS.c", 1262; i = 1;
 6438                        		__st.umiq	1, __update_PLAYER_end - 4  /* i */
         0E:D2EA  A9 01      			lda.l	#1
         0E:D2EC  8D 09 23   			sta	__update_PLAYER_end - 4
 6439                        	
 6440                        		.dbg	line,	"include\routines_LEVELS.c", 1265; // UPDATE PLAYER TILES //
 6441                        	
 6442                        		.dbg	line,	"include\routines_LEVELS.c", 1266; if(player_counter_anim == 0)
 6443                        		__not.um	_player_counter_anim
         0E:D2EF  AD 14 23   			lda	_player_counter_anim
         0E:D2F2  18         			clc
         0E:D2F3  D0 01      			bne	!+
         0E:D2F5  38         			sec
         0E:D2F6             	!:
 6444                        		__bfalse	.LL259
         0E:D2F6  90 21      			bcc	.LL259
 6445                        	
 6446                        		.dbg	line,	"include\routines_LEVELS.c", 1267; {
 6447                        	
 6448                        		.dbg	line,	"include\routines_LEVELS.c", 1268; load_vram(PLAYER_VRAM_ADR, tiles_SPR_PLAYER + TILES_112 , TILES_16);
 6449                        		__st.wmiq	6144, _di
         0E:D2F8  64 F0      			stz.l	_di
         0E:D2FA  A9 18      			lda.h	#6144
         0E:D2FC  85 F1      			sta.h	_di
 6450                        		__farptr	_tiles_SPR_PLAYER + 3584, _bp_bank, _bp
         0E:D2FE  A9 A0      			lda.l	#$6000 + ($1FFF & (_tiles_SPR_PLAYER + 3584))
         0E:D300  85 EC      			sta.l	_bp
         0E:D302  A9 68      			lda.h	#$6000 + ($1FFF & (_tiles_SPR_PLAYER + 3584))
         0E:D304  85 ED      			sta.h	_bp
         0E:D306  A9 0C      			lda	#bank(_tiles_SPR_PLAYER + 3584)
         0E:D308  85 02      			sta	_bp_bank
 6451                        		__st.wmiq	256, _ax
         0E:D30A  64 F8      			stz.l	_ax
         0E:D30C  A9 01      			lda.h	#256
         0E:D30E  85 F9      			sta.h	_ax
 6452                        		 _load_vram.3
         0E:D310  82         			clx				; Offset to PCE VDC.
         0E:D311  20 63 FF   			call	load_vram_x
 6453                        	
 6454                        		.dbg	line,	"include\routines_LEVELS.c", 1270; player_counter_anim = 1;
 6455                        		__st.umiq	1, _player_counter_anim
         0E:D314  A9 01      			lda.l	#1
         0E:D316  8D 14 23   			sta	_player_counter_anim
 6456                        	
 6457                        		.dbg	line,	"include\routines_LEVELS.c", 1271; }
 6458                        	
 6459                        		.dbg	line,	"include\routines_LEVELS.c", 1274; // SELECT PLAYER SPRITE //
 6460                        	
 6461                        		.dbg	line,	"include\routines_LEVELS.c", 1275; spr_set(player_id);
 6462    0E:D319             	.LL259:
 6463                        		__ld.umq	_player_id
         0E:D319  AD 10 23   			lda	_player_id
 6464                        		__call		_spr_set.1
         0E:D31C  20 DD E7   			call	_spr_set.1
 6465                        	
 6466                        		.dbg	line,	"include\routines_LEVELS.c", 1278; //**************************************************************************************//
 6467                        	
 6468                        		.dbg	line,	"include\routines_LEVELS.c", 1279; //                                        H MOVE                                        //
 6469                        	
 6470                        		.dbg	line,	"include\routines_LEVELS.c", 1280; //**************************************************************************************//
 6471                        	
 6472                        		.dbg	line,	"include\routines_LEVELS.c", 1282; //--------------------------------------------------------------------------------------//
 6473                        	
 6474                        		.dbg	line,	"include\routines_LEVELS.c", 1283; //                                    WALL COLLISION                                    //
 6475                        	
 6476                        		.dbg	line,	"include\routines_LEVELS.c", 1284; //--------------------------------------------------------------------------------------//
 6477                        	
 6478                        		.dbg	line,	"include\routines_LEVELS.c", 1286; // CHECK COLLISION WITH BOTTOM LEFT WALL //
 6479                        	
 6480                        		.dbg	line,	"include\routines_LEVELS.c", 1287; check_BG( 8 , 31 );
 6481                        		__ld.wi		8
         0E:D31F  A9 08      			lda.l	#8
         0E:D321  C2         			cly
 6482                        		__pusharg.wr
         0E:D322  A6 8D      			ldx	<__sp
         0E:D324  CA         			dex
         0E:D325  CA         			dex
         0E:D326  95 08      			sta.l	<__stack, x
         0E:D328  94 09      			sty.h	<__stack, x
         0E:D32A  86 8D      			stx	<__sp
 6483                        		__ld.wi		31
         0E:D32C  A9 1F      			lda.l	#31
         0E:D32E  C2         			cly
 6484                        		__pusharg.wr
         0E:D32F  A6 8D      			ldx	<__sp
         0E:D331  CA         			dex
         0E:D332  CA         			dex
         0E:D333  95 08      			sta.l	<__stack, x
         0E:D335  94 09      			sty.h	<__stack, x
         0E:D337  86 8D      			stx	<__sp
 6485                        		__call		_check_BG
         0E:D339  20 6D FF   			call	_check_BG
 6486                        	
 6487                        		.dbg	line,	"include\routines_LEVELS.c", 1289; if(map_blk_flag != TILE_BG)
 6488                        		__ld.umq	_map_blk_flag
         0E:D33C  AD 76 2A   			lda	_map_blk_flag
 6489                        		__neq_b.uiq	1
         0E:D33F  38         			sec
         0E:D340  49 01      			eor	#1
         0E:D342  D0 01      			bne	!+
         0E:D344  18         			clc
         0E:D345             	!:
 6490                        		__bfalse	.LL260
         0E:D345  90 78      			bcc	.LL260
 6491                        	
 6492                        		.dbg	line,	"include\routines_LEVELS.c", 1290; {
 6493                        	
 6494                        		.dbg	line,	"include\routines_LEVELS.c", 1291; // CHECK COLLISION WITH TOP RIGHT WALL //
 6495                        	
 6496                        		.dbg	line,	"include\routines_LEVELS.c", 1292; check_BG( 8 , 15 );
 6497                        		__ld.wi		8
         0E:D347  A9 08      			lda.l	#8
         0E:D349  C2         			cly
 6498                        		__pusharg.wr
         0E:D34A  A6 8D      			ldx	<__sp
         0E:D34C  CA         			dex
         0E:D34D  CA         			dex
         0E:D34E  95 08      			sta.l	<__stack, x
         0E:D350  94 09      			sty.h	<__stack, x
         0E:D352  86 8D      			stx	<__sp
 6499                        		__ld.wi		15
         0E:D354  A9 0F      			lda.l	#15
         0E:D356  C2         			cly
 6500                        		__pusharg.wr
         0E:D357  A6 8D      			ldx	<__sp
         0E:D359  CA         			dex
         0E:D35A  CA         			dex
         0E:D35B  95 08      			sta.l	<__stack, x
         0E:D35D  94 09      			sty.h	<__stack, x
         0E:D35F  86 8D      			stx	<__sp
 6501                        		__call		_check_BG
         0E:D361  20 6D FF   			call	_check_BG
 6502                        	
 6503                        		.dbg	line,	"include\routines_LEVELS.c", 1294; if(map_blk_flag == TILE_BG)
 6504                        		__ld.umq	_map_blk_flag
         0E:D364  AD 76 2A   			lda	_map_blk_flag
 6505                        		__equ_b.uiq	1
         0E:D367  C9 01      			cmp	#1
         0E:D369  F0 01      			beq	!+
         0E:D36B  18         			clc
         0E:D36C             	!:
 6506                        		__bfalse	.LL261
         0E:D36C  90 41      			bcc	.LL261
 6507                        	
 6508                        		.dbg	line,	"include\routines_LEVELS.c", 1295; {
 6509                        	
 6510                        		.dbg	line,	"include\routines_LEVELS.c", 1296; check_TILE_DEPTH( 15 , -16 );
 6511                        		__ld.wi		15
         0E:D36E  A9 0F      			lda.l	#15
         0E:D370  C2         			cly
 6512                        		__pusharg.wr
         0E:D371  A6 8D      			ldx	<__sp
         0E:D373  CA         			dex
         0E:D374  CA         			dex
         0E:D375  95 08      			sta.l	<__stack, x
         0E:D377  94 09      			sty.h	<__stack, x
         0E:D379  86 8D      			stx	<__sp
 6513                        		__ld.wi		-16
         0E:D37B  A9 F0      			lda.l	#-16
         0E:D37D  A0 FF      			ldy.h	#-16
 6514                        		__pusharg.wr
         0E:D37F  A6 8D      			ldx	<__sp
         0E:D381  CA         			dex
         0E:D382  CA         			dex
         0E:D383  95 08      			sta.l	<__stack, x
         0E:D385  94 09      			sty.h	<__stack, x
         0E:D387  86 8D      			stx	<__sp
 6515                        		__call		_check_TILE_DEPTH
         0E:D389  20 4F FF   			call	_check_TILE_DEPTH
 6516                        	
 6517                        		.dbg	line,	"include\routines_LEVELS.c", 1298; if(map_blk_flag == TILE_EMPTY && jump_ladder == TRUE)
 6518                        		__not.um	_map_blk_flag
         0E:D38C  AD 76 2A   			lda	_map_blk_flag
         0E:D38F  18         			clc
         0E:D390  D0 01      			bne	!+
         0E:D392  38         			sec
         0E:D393             	!:
 6519                        		__bfalse	.LL263
         0E:D393  90 08      			bcc	.LL263
 6520                        		__ld.umq	_jump_ladder
         0E:D395  AD 17 23   			lda	_jump_ladder
 6521                        		__equ_b.uiq	1
         0E:D398  C9 01      			cmp	#1
         0E:D39A  F0 01      			beq	!+
         0E:D39C  18         			clc
         0E:D39D             	!:
 6522    0E:D39D             	.LL263:
 6523                        		__bfalse	.LL262
         0E:D39D  90 5F      			bcc	.LL262
 6524                        	
 6525                        		.dbg	line,	"include\routines_LEVELS.c", 1299; {
 6526                        	
 6527                        		.dbg	line,	"include\routines_LEVELS.c", 1300; jump_ladder = FALSE;
 6528                        		__st.umiq	0, _jump_ladder
         0E:D39F  9C 17 23   			stz	_jump_ladder
 6529                        	
 6530                        		.dbg	line,	"include\routines_LEVELS.c", 1301; player_index_fall = 0;
 6531                        		__st.umiq	0, _player_index_fall
         0E:D3A2  9C 16 23   			stz	_player_index_fall
 6532                        	
 6533                        		.dbg	line,	"include\routines_LEVELS.c", 1302; player_state = STATE_FALL;
 6534                        		__st.umiq	9, _player_state
         0E:D3A5  A9 09      			lda.l	#9
         0E:D3A7  8D 11 23   			sta	_player_state
 6535                        	
 6536                        		.dbg	line,	"include\routines_LEVELS.c", 1303; return;
 6537                        		__bra		.LL158
         0E:D3AA  4C 39 DD   			bra	.LL158
 6538                        	
 6539                        		.dbg	line,	"include\routines_LEVELS.c", 1304; }
 6540                        	
 6541                        		.dbg	line,	"include\routines_LEVELS.c", 1305; }
 6542    0E:D3AD             	.LL262	.alias		.LL264
 6543                        	
 6544                        		.dbg	line,	"include\routines_LEVELS.c", 1307; else
 6545                        		__bra		.LL264
         0E:D3AD  80 4F      			bra	.LL264
 6546    0E:D3AF             	.LL261:
 6547                        	
 6548                        		.dbg	line,	"include\routines_LEVELS.c", 1308; {
 6549                        	
 6550                        		.dbg	line,	"include\routines_LEVELS.c", 1309; sgx_map_pxl_x -= 2;
 6551                        		__sub_st.wmiq	2, _sgx_map_pxl_x
         0E:D3AF  38         			sec
         0E:D3B0  AD 55 25   			lda.l	_sgx_map_pxl_x
         0E:D3B3  E9 02      			sbc.l	#2
         0E:D3B5  8D 55 25   			sta.l	_sgx_map_pxl_x
         0E:D3B8  B0 03      			bcs	!+
         0E:D3BA  CE 56 25   			dec.h	_sgx_map_pxl_x
         0E:D3BD             	!:
 6552                        	
 6553                        		.dbg	line,	"include\routines_LEVELS.c", 1310; }
 6554    0E:D3BD             	.LL264	.alias		.LL265
 6555                        	
 6556                        		.dbg	line,	"include\routines_LEVELS.c", 1311; }
 6557                        	
 6558                        		.dbg	line,	"include\routines_LEVELS.c", 1313; else
 6559                        		__bra		.LL265
         0E:D3BD  80 3F      			bra	.LL265
 6560    0E:D3BF             	.LL260:
 6561                        	
 6562                        		.dbg	line,	"include\routines_LEVELS.c", 1314; {
 6563                        	
 6564                        		.dbg	line,	"include\routines_LEVELS.c", 1315; check_TILE_DEPTH( 15 , -16 );
 6565                        		__ld.wi		15
         0E:D3BF  A9 0F      			lda.l	#15
         0E:D3C1  C2         			cly
 6566                        		__pusharg.wr
         0E:D3C2  A6 8D      			ldx	<__sp
         0E:D3C4  CA         			dex
         0E:D3C5  CA         			dex
         0E:D3C6  95 08      			sta.l	<__stack, x
         0E:D3C8  94 09      			sty.h	<__stack, x
         0E:D3CA  86 8D      			stx	<__sp
 6567                        		__ld.wi		-16
         0E:D3CC  A9 F0      			lda.l	#-16
         0E:D3CE  A0 FF      			ldy.h	#-16
 6568                        		__pusharg.wr
         0E:D3D0  A6 8D      			ldx	<__sp
         0E:D3D2  CA         			dex
         0E:D3D3  CA         			dex
         0E:D3D4  95 08      			sta.l	<__stack, x
         0E:D3D6  94 09      			sty.h	<__stack, x
         0E:D3D8  86 8D      			stx	<__sp
 6569                        		__call		_check_TILE_DEPTH
         0E:D3DA  20 4F FF   			call	_check_TILE_DEPTH
 6570                        	
 6571                        		.dbg	line,	"include\routines_LEVELS.c", 1317; if(map_blk_flag == TILE_EMPTY && jump_ladder == TRUE)
 6572                        		__not.um	_map_blk_flag
         0E:D3DD  AD 76 2A   			lda	_map_blk_flag
         0E:D3E0  18         			clc
         0E:D3E1  D0 01      			bne	!+
         0E:D3E3  38         			sec
         0E:D3E4             	!:
 6573                        		__bfalse	.LL267
         0E:D3E4  90 08      			bcc	.LL267
 6574                        		__ld.umq	_jump_ladder
         0E:D3E6  AD 17 23   			lda	_jump_ladder
 6575                        		__equ_b.uiq	1
         0E:D3E9  C9 01      			cmp	#1
         0E:D3EB  F0 01      			beq	!+
         0E:D3ED  18         			clc
         0E:D3EE             	!:
 6576    0E:D3EE             	.LL267:
 6577                        		__bfalse	.LL266
         0E:D3EE  90 0E      			bcc	.LL266
 6578                        	
 6579                        		.dbg	line,	"include\routines_LEVELS.c", 1318; {
 6580                        	
 6581                        		.dbg	line,	"include\routines_LEVELS.c", 1319; jump_ladder = FALSE;
 6582                        		__st.umiq	0, _jump_ladder
         0E:D3F0  9C 17 23   			stz	_jump_ladder
 6583                        	
 6584                        		.dbg	line,	"include\routines_LEVELS.c", 1320; player_index_fall = 0;
 6585                        		__st.umiq	0, _player_index_fall
         0E:D3F3  9C 16 23   			stz	_player_index_fall
 6586                        	
 6587                        		.dbg	line,	"include\routines_LEVELS.c", 1321; player_state = STATE_FALL;
 6588                        		__st.umiq	9, _player_state
         0E:D3F6  A9 09      			lda.l	#9
         0E:D3F8  8D 11 23   			sta	_player_state
 6589                        	
 6590                        		.dbg	line,	"include\routines_LEVELS.c", 1322; return;
 6591                        		__bra		.LL158
         0E:D3FB  4C 39 DD   			bra	.LL158
 6592                        	
 6593                        		.dbg	line,	"include\routines_LEVELS.c", 1323; }
 6594                        	
 6595                        		.dbg	line,	"include\routines_LEVELS.c", 1324; }
 6596    0E:D3FE             	.LL266:
 6597    0E:D3FE             	.LL265:
 6598                        	
 6599                        		.dbg	line,	"include\routines_LEVELS.c", 1329; //**************************************************************************************//
 6600                        	
 6601                        		.dbg	line,	"include\routines_LEVELS.c", 1330; //                                        V MOVE                                        //
 6602                        	
 6603                        		.dbg	line,	"include\routines_LEVELS.c", 1331; //**************************************************************************************//
 6604                        	
 6605                        		.dbg	line,	"include\routines_LEVELS.c", 1333; // UPDATE PLAYER Y POSITION //
 6606                        	
 6607                        		.dbg	line,	"include\routines_LEVELS.c", 1334; if(jump_ladder == FALSE)
 6608                        		__not.um	_jump_ladder
         0E:D3FE  AD 17 23   			lda	_jump_ladder
         0E:D401  18         			clc
         0E:D402  D0 01      			bne	!+
         0E:D404  38         			sec
         0E:D405             	!:
 6609                        		__bfalse	.LL268
         0E:D405  90 1A      			bcc	.LL268
 6610                        	
 6611                        		.dbg	line,	"include\routines_LEVELS.c", 1335; {
 6612                        	
 6613                        		.dbg	line,	"include\routines_LEVELS.c", 1336; player_pos_y += TABLE_PLAYER_JUMP_V[player_index_jump];
 6614                        		__ldx.umq	_player_index_jump
         0E:D407  AE 15 23   			ldx	_player_index_jump
 6615                        		__ld.bax	_TABLE_PLAYER_JUMP_V
         0E:D40A  BD A0 60   			lda	_TABLE_PLAYER_JUMP_V, x
         0E:D40D  C2         			cly
         0E:D40E  10 01      			bpl	!+
         0E:D410  88         			dey
         0E:D411             	!:
 6616                        		__add_st.wmq	_player_pos_y
         0E:D411  18         			clc
         0E:D412  6D B9 23   			adc.l	_player_pos_y
         0E:D415  8D B9 23   			sta.l	_player_pos_y
         0E:D418  98         			tya
         0E:D419  6D BA 23   			adc.h	_player_pos_y
         0E:D41C  8D BA 23   			sta.h	_player_pos_y
 6617                        	
 6618                        		.dbg	line,	"include\routines_LEVELS.c", 1337; }
 6619                        	
 6620                        		.dbg	line,	"include\routines_LEVELS.c", 1339; else
 6621                        		__bra		.LL269
         0E:D41F  80 18      			bra	.LL269
 6622    0E:D421             	.LL268:
 6623                        	
 6624                        		.dbg	line,	"include\routines_LEVELS.c", 1340; {
 6625                        	
 6626                        		.dbg	line,	"include\routines_LEVELS.c", 1341; player_pos_y += TABLE_PLAYER_JUMP_LADDER[player_index_jump];
 6627                        		__ldx.umq	_player_index_jump
         0E:D421  AE 15 23   			ldx	_player_index_jump
 6628                        		__ld.bax	_TABLE_PLAYER_JUMP_LADDER
         0E:D424  BD D8 60   			lda	_TABLE_PLAYER_JUMP_LADDER, x
         0E:D427  C2         			cly
         0E:D428  10 01      			bpl	!+
         0E:D42A  88         			dey
         0E:D42B             	!:
 6629                        		__add_st.wmq	_player_pos_y
         0E:D42B  18         			clc
         0E:D42C  6D B9 23   			adc.l	_player_pos_y
         0E:D42F  8D B9 23   			sta.l	_player_pos_y
         0E:D432  98         			tya
         0E:D433  6D BA 23   			adc.h	_player_pos_y
         0E:D436  8D BA 23   			sta.h	_player_pos_y
 6630                        	
 6631                        		.dbg	line,	"include\routines_LEVELS.c", 1342; }
 6632    0E:D439             	.LL269:
 6633                        	
 6634                        		.dbg	line,	"include\routines_LEVELS.c", 1345; // IF PLAYER GOES BELOW ITS BASE Y POSITION //
 6635                        	
 6636                        		.dbg	line,	"include\routines_LEVELS.c", 1346; if(player_pos_y >= PLAYER_BASE_Y_POS)
 6637                        		__ld.wm		_player_pos_y
         0E:D439  AD B9 23   			lda.l	_player_pos_y
         0E:D43C  AC BA 23   			ldy.h	_player_pos_y
 6638                        		__sge_w.wi	128
         0E:D43F  C9 80      			cmp.l	#128		; Subtract integer from Y:A.
         0E:D441  98         			tya
         0E:D442  E9 00      			sbc.h	#128
         0E:D444  50 02      			bvc	!+
         0E:D446  49 80      			eor	#$80		; +ve if Y:A >= integer (signed).
         0E:D448  49 80      	!:		eor	#$80
         0E:D44A  0A         			asl	a
 6639                        		__bfalse	.LL270
         0E:D44B  90 4E      			bcc	.LL270
 6640                        	
 6641                        		.dbg	line,	"include\routines_LEVELS.c", 1347; {
 6642                        	
 6643                        		.dbg	line,	"include\routines_LEVELS.c", 1348; // THE CAMERA MOVES //
 6644                        	
 6645                        		.dbg	line,	"include\routines_LEVELS.c", 1349; // CALCULATE HOW MANY PIXELS THE CAMERA HAS TO MOVE DOWN //
 6646                        	
 6647                        		.dbg	line,	"include\routines_LEVELS.c", 1350; camera_y_move = player_pos_y - PLAYER_BASE_Y_POS;
 6648                        		__ld.wm		_player_pos_y
         0E:D44D  AD B9 23   			lda.l	_player_pos_y
         0E:D450  AC BA 23   			ldy.h	_player_pos_y
 6649                        		__sub.wi	128
         0E:D453  38         			sec
         0E:D454  E9 80      			sbc.l	#128
         0E:D456  B0 01      			bcs	!+
         0E:D458  88         			dey
         0E:D459             	!:
 6650                        		__st.umq	__update_PLAYER_end - 5  /* camera_y_move */
         0E:D459  8D 08 23   			sta	__update_PLAYER_end - 5
 6651                        	
 6652                        		.dbg	line,	"include\routines_LEVELS.c", 1351; sgx_map_pxl_y += camera_y_move;
 6653                        		__ld.um		__update_PLAYER_end - 5  /* camera_y_move */
         0E:D45C  AD 08 23   			lda	__update_PLAYER_end - 5
         0E:D45F  C2         			cly
 6654                        		__add_st.wmq	_sgx_map_pxl_y
         0E:D460  18         			clc
         0E:D461  6D 57 25   			adc.l	_sgx_map_pxl_y
         0E:D464  8D 57 25   			sta.l	_sgx_map_pxl_y
         0E:D467  98         			tya
         0E:D468  6D 58 25   			adc.h	_sgx_map_pxl_y
         0E:D46B  8D 58 25   			sta.h	_sgx_map_pxl_y
 6655                        	
 6656                        		.dbg	line,	"include\routines_LEVELS.c", 1353; // IF THE CAMERA HAS REACHED ITS MAX (LOWEST) POSITION //
 6657                        	
 6658                        		.dbg	line,	"include\routines_LEVELS.c", 1354; if(sgx_map_pxl_y > camera_max_y_position)
 6659                        		__ld.wm		_sgx_map_pxl_y
         0E:D46E  AD 57 25   			lda.l	_sgx_map_pxl_y
         0E:D471  AC 58 25   			ldy.h	_sgx_map_pxl_y
 6660                        		__ugt_w.wm	_camera_max_y_position
         0E:D474  18         			clc			; Subtract memory+1 from Y:A.
         0E:D475  ED BB 23   			sbc.l	_camera_max_y_position
         0E:D478  98         			tya
         0E:D479  ED BC 23   			sbc.h	_camera_max_y_position		; CS if Y:A > memory.
 6661                        		__bfalse	.LL271
         0E:D47C  90 0C      			bcc	.LL271
 6662                        	
 6663                        		.dbg	line,	"include\routines_LEVELS.c", 1355; {
 6664                        	
 6665                        		.dbg	line,	"include\routines_LEVELS.c", 1356; // THE CAMERA CAN NOT MOVE LOWER //
 6666                        	
 6667                        		.dbg	line,	"include\routines_LEVELS.c", 1357; sgx_map_pxl_y = camera_max_y_position;
 6668                        		__ld.wm		_camera_max_y_position
         0E:D47E  AD BB 23   			lda.l	_camera_max_y_position
         0E:D481  AC BC 23   			ldy.h	_camera_max_y_position
 6669                        		__st.wmq	_sgx_map_pxl_y
         0E:D484  8D 57 25   			sta.l	_sgx_map_pxl_y
         0E:D487  8C 58 25   			sty.h	_sgx_map_pxl_y
 6670                        	
 6671                        		.dbg	line,	"include\routines_LEVELS.c", 1358; }
 6672                        	
 6673                        		.dbg	line,	"include\routines_LEVELS.c", 1360; // THE PLAYER STAYS AT ITS BASE Y POSITION //
 6674                        	
 6675                        		.dbg	line,	"include\routines_LEVELS.c", 1361; player_pos_y = PLAYER_BASE_Y_POS;
 6676    0E:D48A             	.LL271:
 6677                        		__st.wmiq	128, _player_pos_y
         0E:D48A  A9 80      			lda.l	#128
         0E:D48C  8D B9 23   			sta.l	_player_pos_y
         0E:D48F  9C BA 23   			stz.h	_player_pos_y
 6678                        	
 6679                        		.dbg	line,	"include\routines_LEVELS.c", 1363; spr_y(player_pos_y);
 6680                        		__ld.wm		_player_pos_y
         0E:D492  AD B9 23   			lda.l	_player_pos_y
         0E:D495  AC BA 23   			ldy.h	_player_pos_y
 6681                        		__call		_spr_y.1
         0E:D498  20 19 E8   			call	_spr_y.1
 6682                        	
 6683                        		.dbg	line,	"include\routines_LEVELS.c", 1364; }
 6684                        	
 6685                        		.dbg	line,	"include\routines_LEVELS.c", 1367; // UPDATE JUMP INDEX IN THE ARRAY //
 6686                        	
 6687                        		.dbg	line,	"include\routines_LEVELS.c", 1368; if(player_index_jump < jump_max_index)
 6688    0E:D49B             	.LL270:
 6689                        		__ld.umq	_player_index_jump
         0E:D49B  AD 15 23   			lda	_player_index_jump
 6690                        		__ult_b.umq	_jump_max_index
         0E:D49E  CD 18 23   			cmp	_jump_max_index		; Subtract memory from A.
         0E:D4A1  6A         			ror	a		; CC if A < memory.
         0E:D4A2  49 80      			eor	#$80
         0E:D4A4  2A         			rol	a
 6691                        		__bfalse	.LL272
         0E:D4A5  90 03      			bcc	.LL272
 6692                        	
 6693                        		.dbg	line,	"include\routines_LEVELS.c", 1369; {
 6694                        	
 6695                        		.dbg	line,	"include\routines_LEVELS.c", 1370; player_index_jump += 1;
 6696                        		__add_st.umiq	1, _player_index_jump
         0E:D4A7  EE 15 23   			inc	_player_index_jump
 6697                        	
 6698                        		.dbg	line,	"include\routines_LEVELS.c", 1371; }
 6699                        	
 6700                        		.dbg	line,	"include\routines_LEVELS.c", 1376; //--------------------------------------------------------------------------------------//
 6701                        	
 6702                        		.dbg	line,	"include\routines_LEVELS.c", 1377; //                                   FLOOR COLLISION                                    //
 6703                        	
 6704                        		.dbg	line,	"include\routines_LEVELS.c", 1378; //--------------------------------------------------------------------------------------//
 6705                        	
 6706                        		.dbg	line,	"include\routines_LEVELS.c", 1380; if(player_index_jump > 14)
 6707    0E:D4AA             	.LL272:
 6708                        		__ld.umq	_player_index_jump
         0E:D4AA  AD 15 23   			lda	_player_index_jump
 6709                        		__ugt_b.uiq	14
         0E:D4AD  18         			clc			; Subtract integer+1 from A.
         0E:D4AE  E9 0E      			sbc	#14		; CS if A > integer.
 6710                        		__bfalse	.LL273
         0E:D4B0  B0 03 4C 65			bcc	.LL273
         0E:D4B4  D6          
 6711                        	
 6712                        		.dbg	line,	"include\routines_LEVELS.c", 1381; {
 6713                        	
 6714                        		.dbg	line,	"include\routines_LEVELS.c", 1382; // CHECK COLLISION WITH LEFT FLOOR //
 6715                        	
 6716                        		.dbg	line,	"include\routines_LEVELS.c", 1383; check_BG( 10 , 32 );
 6717                        		__ld.wi		10
         0E:D4B5  A9 0A      			lda.l	#10
         0E:D4B7  C2         			cly
 6718                        		__pusharg.wr
         0E:D4B8  A6 8D      			ldx	<__sp
         0E:D4BA  CA         			dex
         0E:D4BB  CA         			dex
         0E:D4BC  95 08      			sta.l	<__stack, x
         0E:D4BE  94 09      			sty.h	<__stack, x
         0E:D4C0  86 8D      			stx	<__sp
 6719                        		__ld.wi		32
         0E:D4C2  A9 20      			lda.l	#32
         0E:D4C4  C2         			cly
 6720                        		__pusharg.wr
         0E:D4C5  A6 8D      			ldx	<__sp
         0E:D4C7  CA         			dex
         0E:D4C8  CA         			dex
         0E:D4C9  95 08      			sta.l	<__stack, x
         0E:D4CB  94 09      			sty.h	<__stack, x
         0E:D4CD  86 8D      			stx	<__sp
 6721                        		__call		_check_BG
         0E:D4CF  20 6D FF   			call	_check_BG
 6722                        	
 6723                        		.dbg	line,	"include\routines_LEVELS.c", 1385; if(map_blk_flag == TILE_BG)
 6724                        		__ld.umq	_map_blk_flag
         0E:D4D2  AD 76 2A   			lda	_map_blk_flag
 6725                        		__equ_b.uiq	1
         0E:D4D5  C9 01      			cmp	#1
         0E:D4D7  F0 01      			beq	!+
         0E:D4D9  18         			clc
         0E:D4DA             	!:
 6726                        		__bfalse	.LL274
         0E:D4DA  B0 03 4C 8D			bcc	.LL274
         0E:D4DE  D5          
 6727                        	
 6728                        		.dbg	line,	"include\routines_LEVELS.c", 1386; {
 6729                        	
 6730                        		.dbg	line,	"include\routines_LEVELS.c", 1387; // CALCULATE HOW MANY PIXELS THE PLAYER MOVED INTO THE GROUND //
 6731                        	
 6732                        		.dbg	line,	"include\routines_LEVELS.c", 1388; for(i=1; i<11 ; i++)
 6733                        		__st.umiq	1, __update_PLAYER_end - 4  /* i */
         0E:D4DF  A9 01      			lda.l	#1
         0E:D4E1  8D 09 23   			sta	__update_PLAYER_end - 4
 6734    0E:D4E4             	.LL275:
 6735                        		__ld.umq	__update_PLAYER_end - 4  /* i */
         0E:D4E4  AD 09 23   			lda	__update_PLAYER_end - 4
 6736                        		__ult_b.uiq	11
         0E:D4E7  C9 0B      			cmp	#11		; Subtract integer from A.
         0E:D4E9  6A         			ror	a		; CC if A < integer.
         0E:D4EA  49 80      			eor	#$80
         0E:D4EC  2A         			rol	a
 6737                        		__btrue		.LL277
         0E:D4ED  B0 07      			bcs	.LL277
 6738                        		__bra		.LL278
         0E:D4EF  80 7D      			bra	.LL278
 6739    0E:D4F1             	.LL276:
 6740                        		__inc.umq	__update_PLAYER_end - 4  /* i */
         0E:D4F1  EE 09 23   			inc	__update_PLAYER_end - 4
 6741                        		__bra		.LL275
         0E:D4F4  80 EE      			bra	.LL275
 6742    0E:D4F6             	.LL277:
 6743                        	
 6744                        		.dbg	line,	"include\routines_LEVELS.c", 1389; {
 6745                        	
 6746                        		.dbg	line,	"include\routines_LEVELS.c", 1390; check_TILE_DEPTH( 10 , i);
 6747                        		__ld.wi		10
         0E:D4F6  A9 0A      			lda.l	#10
         0E:D4F8  C2         			cly
 6748                        		__pusharg.wr
         0E:D4F9  A6 8D      			ldx	<__sp
         0E:D4FB  CA         			dex
         0E:D4FC  CA         			dex
         0E:D4FD  95 08      			sta.l	<__stack, x
         0E:D4FF  94 09      			sty.h	<__stack, x
         0E:D501  86 8D      			stx	<__sp
 6749                        		__ld.um		__update_PLAYER_end - 4  /* i */
         0E:D503  AD 09 23   			lda	__update_PLAYER_end - 4
         0E:D506  C2         			cly
 6750                        		__pusharg.wr
         0E:D507  A6 8D      			ldx	<__sp
         0E:D509  CA         			dex
         0E:D50A  CA         			dex
         0E:D50B  95 08      			sta.l	<__stack, x
         0E:D50D  94 09      			sty.h	<__stack, x
         0E:D50F  86 8D      			stx	<__sp
 6751                        		__call		_check_TILE_DEPTH
         0E:D511  20 4F FF   			call	_check_TILE_DEPTH
 6752                        	
 6753                        		.dbg	line,	"include\routines_LEVELS.c", 1392; if(map_blk_flag == TILE_EMPTY)
 6754                        		__not.um	_map_blk_flag
         0E:D514  AD 76 2A   			lda	_map_blk_flag
         0E:D517  18         			clc
         0E:D518  D0 01      			bne	!+
         0E:D51A  38         			sec
         0E:D51B             	!:
 6755                        		__bfalse	.LL279
         0E:D51B  90 D4      			bcc	.LL279
 6756                        	
 6757                        		.dbg	line,	"include\routines_LEVELS.c", 1393; {
 6758                        	
 6759                        		.dbg	line,	"include\routines_LEVELS.c", 1394; if(player_pos_y != PLAYER_BASE_Y_POS)
 6760                        		__ld.wm		_player_pos_y
         0E:D51D  AD B9 23   			lda.l	_player_pos_y
         0E:D520  AC BA 23   			ldy.h	_player_pos_y
 6761                        		__neq_w.wi	128
         0E:D523  38         			sec
         0E:D524  49 80      			eor.l	#128
         0E:D526  D0 06      			bne	!+
         0E:D528  98         			tya
         0E:D529  49 00      			eor.h	#128
         0E:D52B  D0 01      			bne	!+
         0E:D52D  18         			clc
         0E:D52E             	!:
 6762                        		__bfalse	.LL280
         0E:D52E  90 1E      			bcc	.LL280
 6763                        	
 6764                        		.dbg	line,	"include\routines_LEVELS.c", 1395; {
 6765                        	
 6766                        		.dbg	line,	"include\routines_LEVELS.c", 1396; player_pos_y -= (i - 1);
 6767                        		__ld.um		__update_PLAYER_end - 4  /* i */
         0E:D530  AD 09 23   			lda	__update_PLAYER_end - 4
         0E:D533  C2         			cly
 6768                        		__sub.wi	1
         0E:D534  38         			sec
         0E:D535  E9 01      			sbc.l	#1
         0E:D537  B0 01      			bcs	!+
         0E:D539  88         			dey
         0E:D53A             	!:
 6769                        		__isub_st.wmq	_player_pos_y
         0E:D53A  38         			sec
         0E:D53B  49 FF      			eor	#$FF
         0E:D53D  6D B9 23   			adc.l	_player_pos_y
         0E:D540  8D B9 23   			sta.l	_player_pos_y
         0E:D543  98         			tya
         0E:D544  49 FF      			eor	#$FF
         0E:D546  6D BA 23   			adc.h	_player_pos_y
         0E:D549  8D BA 23   			sta.h	_player_pos_y
 6770                        	
 6771                        		.dbg	line,	"include\routines_LEVELS.c", 1397; }
 6772                        	
 6773                        		.dbg	line,	"include\routines_LEVELS.c", 1399; else
 6774                        		__bra		.LL281
         0E:D54C  80 20      			bra	.LL281
 6775    0E:D54E             	.LL280:
 6776                        	
 6777                        		.dbg	line,	"include\routines_LEVELS.c", 1400; {
 6778                        	
 6779                        		.dbg	line,	"include\routines_LEVELS.c", 1401; sgx_map_pxl_y -= (i - 1);
 6780                        		__ld.um		__update_PLAYER_end - 4  /* i */
         0E:D54E  AD 09 23   			lda	__update_PLAYER_end - 4
         0E:D551  C2         			cly
 6781                        		__sub.wi	1
         0E:D552  38         			sec
         0E:D553  E9 01      			sbc.l	#1
         0E:D555  B0 01      			bcs	!+
         0E:D557  88         			dey
         0E:D558             	!:
 6782                        		__isub_st.wmq	_sgx_map_pxl_y
         0E:D558  38         			sec
         0E:D559  49 FF      			eor	#$FF
         0E:D55B  6D 57 25   			adc.l	_sgx_map_pxl_y
         0E:D55E  8D 57 25   			sta.l	_sgx_map_pxl_y
         0E:D561  98         			tya
         0E:D562  49 FF      			eor	#$FF
         0E:D564  6D 58 25   			adc.h	_sgx_map_pxl_y
         0E:D567  8D 58 25   			sta.h	_sgx_map_pxl_y
 6783                        	
 6784                        		.dbg	line,	"include\routines_LEVELS.c", 1402; }
 6785    0E:D56A             	.LL281	.alias		.LL278
 6786                        	
 6787                        		.dbg	line,	"include\routines_LEVELS.c", 1404; break;
 6788                        		__bra		.LL278
         0E:D56A  80 02      			bra	.LL278
 6789                        	
 6790                        		.dbg	line,	"include\routines_LEVELS.c", 1405; }
 6791                        	
 6792                        		.dbg	line,	"include\routines_LEVELS.c", 1406; }
 6793    0E:D56C             	.LL279	.alias		.LL276
 6794                        		__bra		.LL276
         0E:D56C  80 83      			bra	.LL276
 6795    0E:D56E             	.LL278:
 6796                        	
 6797                        		.dbg	line,	"include\routines_LEVELS.c", 1408; // SET PLAYER SPRITE NEW POSITION //
 6798                        	
 6799                        		.dbg	line,	"include\routines_LEVELS.c", 1409; spr_y(player_pos_y);
 6800                        		__ld.wm		_player_pos_y
         0E:D56E  AD B9 23   			lda.l	_player_pos_y
         0E:D571  AC BA 23   			ldy.h	_player_pos_y
 6801                        		__call		_spr_y.1
         0E:D574  20 19 E8   			call	_spr_y.1
 6802                        	
 6803                        		.dbg	line,	"include\routines_LEVELS.c", 1411; player_counter_anim = 1;
 6804                        		__st.umiq	1, _player_counter_anim
         0E:D577  A9 01      			lda.l	#1
         0E:D579  8D 14 23   			sta	_player_counter_anim
 6805                        	
 6806                        		.dbg	line,	"include\routines_LEVELS.c", 1412; player_index_jump = 0;
 6807                        		__st.umiq	0, _player_index_jump
         0E:D57C  9C 15 23   			stz	_player_index_jump
 6808                        	
 6809                        		.dbg	line,	"include\routines_LEVELS.c", 1413; jump_ladder = FALSE;
 6810                        		__st.umiq	0, _jump_ladder
         0E:D57F  9C 17 23   			stz	_jump_ladder
 6811                        	
 6812                        		.dbg	line,	"include\routines_LEVELS.c", 1414; jump_max_index = 34;
 6813                        		__st.umiq	34, _jump_max_index
         0E:D582  A9 22      			lda.l	#34
         0E:D584  8D 18 23   			sta	_jump_max_index
 6814                        	
 6815                        		.dbg	line,	"include\routines_LEVELS.c", 1415; player_state = STATE_IDLE;
 6816                        		__st.umiq	0, _player_state
         0E:D587  9C 11 23   			stz	_player_state
 6817                        	
 6818                        		.dbg	line,	"include\routines_LEVELS.c", 1416; return;
 6819                        		__bra		.LL158
         0E:D58A  4C 39 DD   			bra	.LL158
 6820                        	
 6821                        		.dbg	line,	"include\routines_LEVELS.c", 1417; }
 6822                        	
 6823                        		.dbg	line,	"include\routines_LEVELS.c", 1419; else
 6824    0E:D58D             	.LL274:
 6825                        	
 6826                        		.dbg	line,	"include\routines_LEVELS.c", 1420; {
 6827                        	
 6828                        		.dbg	line,	"include\routines_LEVELS.c", 1421; // CHECK COLLISION WITH RIGHT FLOOR //
 6829                        	
 6830                        		.dbg	line,	"include\routines_LEVELS.c", 1422; check_BG( 22 , 32 );
 6831                        		__ld.wi		22
         0E:D58D  A9 16      			lda.l	#22
         0E:D58F  C2         			cly
 6832                        		__pusharg.wr
         0E:D590  A6 8D      			ldx	<__sp
         0E:D592  CA         			dex
         0E:D593  CA         			dex
         0E:D594  95 08      			sta.l	<__stack, x
         0E:D596  94 09      			sty.h	<__stack, x
         0E:D598  86 8D      			stx	<__sp
 6833                        		__ld.wi		32
         0E:D59A  A9 20      			lda.l	#32
         0E:D59C  C2         			cly
 6834                        		__pusharg.wr
         0E:D59D  A6 8D      			ldx	<__sp
         0E:D59F  CA         			dex
         0E:D5A0  CA         			dex
         0E:D5A1  95 08      			sta.l	<__stack, x
         0E:D5A3  94 09      			sty.h	<__stack, x
         0E:D5A5  86 8D      			stx	<__sp
 6835                        		__call		_check_BG
         0E:D5A7  20 6D FF   			call	_check_BG
 6836                        	
 6837                        		.dbg	line,	"include\routines_LEVELS.c", 1424; if(map_blk_flag == TILE_BG)
 6838                        		__ld.umq	_map_blk_flag
         0E:D5AA  AD 76 2A   			lda	_map_blk_flag
 6839                        		__equ_b.uiq	1
         0E:D5AD  C9 01      			cmp	#1
         0E:D5AF  F0 01      			beq	!+
         0E:D5B1  18         			clc
         0E:D5B2             	!:
 6840                        		__bfalse	.LL283
         0E:D5B2  B0 03 4C 65			bcc	.LL283
         0E:D5B6  D6          
 6841                        	
 6842                        		.dbg	line,	"include\routines_LEVELS.c", 1425; {
 6843                        	
 6844                        		.dbg	line,	"include\routines_LEVELS.c", 1426; // CALCULATE HOW MANY PIXELS THE PLAYER MOVED INTO THE GROUND //
 6845                        	
 6846                        		.dbg	line,	"include\routines_LEVELS.c", 1427; for(i=1; i<11 ; i++)
 6847                        		__st.umiq	1, __update_PLAYER_end - 4  /* i */
         0E:D5B7  A9 01      			lda.l	#1
         0E:D5B9  8D 09 23   			sta	__update_PLAYER_end - 4
 6848    0E:D5BC             	.LL284:
 6849                        		__ld.umq	__update_PLAYER_end - 4  /* i */
         0E:D5BC  AD 09 23   			lda	__update_PLAYER_end - 4
 6850                        		__ult_b.uiq	11
         0E:D5BF  C9 0B      			cmp	#11		; Subtract integer from A.
         0E:D5C1  6A         			ror	a		; CC if A < integer.
         0E:D5C2  49 80      			eor	#$80
         0E:D5C4  2A         			rol	a
 6851                        		__btrue		.LL286
         0E:D5C5  B0 07      			bcs	.LL286
 6852                        		__bra		.LL287
         0E:D5C7  80 7D      			bra	.LL287
 6853    0E:D5C9             	.LL285:
 6854                        		__inc.umq	__update_PLAYER_end - 4  /* i */
         0E:D5C9  EE 09 23   			inc	__update_PLAYER_end - 4
 6855                        		__bra		.LL284
         0E:D5CC  80 EE      			bra	.LL284
 6856    0E:D5CE             	.LL286:
 6857                        	
 6858                        		.dbg	line,	"include\routines_LEVELS.c", 1428; {
 6859                        	
 6860                        		.dbg	line,	"include\routines_LEVELS.c", 1429; check_TILE_DEPTH( 22 , i);
 6861                        		__ld.wi		22
         0E:D5CE  A9 16      			lda.l	#22
         0E:D5D0  C2         			cly
 6862                        		__pusharg.wr
         0E:D5D1  A6 8D      			ldx	<__sp
         0E:D5D3  CA         			dex
         0E:D5D4  CA         			dex
         0E:D5D5  95 08      			sta.l	<__stack, x
         0E:D5D7  94 09      			sty.h	<__stack, x
         0E:D5D9  86 8D      			stx	<__sp
 6863                        		__ld.um		__update_PLAYER_end - 4  /* i */
         0E:D5DB  AD 09 23   			lda	__update_PLAYER_end - 4
         0E:D5DE  C2         			cly
 6864                        		__pusharg.wr
         0E:D5DF  A6 8D      			ldx	<__sp
         0E:D5E1  CA         			dex
         0E:D5E2  CA         			dex
         0E:D5E3  95 08      			sta.l	<__stack, x
         0E:D5E5  94 09      			sty.h	<__stack, x
         0E:D5E7  86 8D      			stx	<__sp
 6865                        		__call		_check_TILE_DEPTH
         0E:D5E9  20 4F FF   			call	_check_TILE_DEPTH
 6866                        	
 6867                        		.dbg	line,	"include\routines_LEVELS.c", 1431; if(map_blk_flag == TILE_EMPTY)
 6868                        		__not.um	_map_blk_flag
         0E:D5EC  AD 76 2A   			lda	_map_blk_flag
         0E:D5EF  18         			clc
         0E:D5F0  D0 01      			bne	!+
         0E:D5F2  38         			sec
         0E:D5F3             	!:
 6869                        		__bfalse	.LL288
         0E:D5F3  90 D4      			bcc	.LL288
 6870                        	
 6871                        		.dbg	line,	"include\routines_LEVELS.c", 1432; {
 6872                        	
 6873                        		.dbg	line,	"include\routines_LEVELS.c", 1433; if(player_pos_y != PLAYER_BASE_Y_POS)
 6874                        		__ld.wm		_player_pos_y
         0E:D5F5  AD B9 23   			lda.l	_player_pos_y
         0E:D5F8  AC BA 23   			ldy.h	_player_pos_y
 6875                        		__neq_w.wi	128
         0E:D5FB  38         			sec
         0E:D5FC  49 80      			eor.l	#128
         0E:D5FE  D0 06      			bne	!+
         0E:D600  98         			tya
         0E:D601  49 00      			eor.h	#128
         0E:D603  D0 01      			bne	!+
         0E:D605  18         			clc
         0E:D606             	!:
 6876                        		__bfalse	.LL289
         0E:D606  90 1E      			bcc	.LL289
 6877                        	
 6878                        		.dbg	line,	"include\routines_LEVELS.c", 1434; {
 6879                        	
 6880                        		.dbg	line,	"include\routines_LEVELS.c", 1435; player_pos_y -= (i - 1);
 6881                        		__ld.um		__update_PLAYER_end - 4  /* i */
         0E:D608  AD 09 23   			lda	__update_PLAYER_end - 4
         0E:D60B  C2         			cly
 6882                        		__sub.wi	1
         0E:D60C  38         			sec
         0E:D60D  E9 01      			sbc.l	#1
         0E:D60F  B0 01      			bcs	!+
         0E:D611  88         			dey
         0E:D612             	!:
 6883                        		__isub_st.wmq	_player_pos_y
         0E:D612  38         			sec
         0E:D613  49 FF      			eor	#$FF
         0E:D615  6D B9 23   			adc.l	_player_pos_y
         0E:D618  8D B9 23   			sta.l	_player_pos_y
         0E:D61B  98         			tya
         0E:D61C  49 FF      			eor	#$FF
         0E:D61E  6D BA 23   			adc.h	_player_pos_y
         0E:D621  8D BA 23   			sta.h	_player_pos_y
 6884                        	
 6885                        		.dbg	line,	"include\routines_LEVELS.c", 1436; }
 6886                        	
 6887                        		.dbg	line,	"include\routines_LEVELS.c", 1438; else
 6888                        		__bra		.LL290
         0E:D624  80 20      			bra	.LL290
 6889    0E:D626             	.LL289:
 6890                        	
 6891                        		.dbg	line,	"include\routines_LEVELS.c", 1439; {
 6892                        	
 6893                        		.dbg	line,	"include\routines_LEVELS.c", 1440; sgx_map_pxl_y -= (i - 1);
 6894                        		__ld.um		__update_PLAYER_end - 4  /* i */
         0E:D626  AD 09 23   			lda	__update_PLAYER_end - 4
         0E:D629  C2         			cly
 6895                        		__sub.wi	1
         0E:D62A  38         			sec
         0E:D62B  E9 01      			sbc.l	#1
         0E:D62D  B0 01      			bcs	!+
         0E:D62F  88         			dey
         0E:D630             	!:
 6896                        		__isub_st.wmq	_sgx_map_pxl_y
         0E:D630  38         			sec
         0E:D631  49 FF      			eor	#$FF
         0E:D633  6D 57 25   			adc.l	_sgx_map_pxl_y
         0E:D636  8D 57 25   			sta.l	_sgx_map_pxl_y
         0E:D639  98         			tya
         0E:D63A  49 FF      			eor	#$FF
         0E:D63C  6D 58 25   			adc.h	_sgx_map_pxl_y
         0E:D63F  8D 58 25   			sta.h	_sgx_map_pxl_y
 6897                        	
 6898                        		.dbg	line,	"include\routines_LEVELS.c", 1441; }
 6899    0E:D642             	.LL290	.alias		.LL287
 6900                        	
 6901                        		.dbg	line,	"include\routines_LEVELS.c", 1443; break;
 6902                        		__bra		.LL287
         0E:D642  80 02      			bra	.LL287
 6903                        	
 6904                        		.dbg	line,	"include\routines_LEVELS.c", 1444; }
 6905                        	
 6906                        		.dbg	line,	"include\routines_LEVELS.c", 1445; }
 6907    0E:D644             	.LL288	.alias		.LL285
 6908                        		__bra		.LL285
         0E:D644  80 83      			bra	.LL285
 6909    0E:D646             	.LL287:
 6910                        	
 6911                        		.dbg	line,	"include\routines_LEVELS.c", 1447; // SET PLAYER SPRITE NEW POSITION //
 6912                        	
 6913                        		.dbg	line,	"include\routines_LEVELS.c", 1448; spr_y(player_pos_y);
 6914                        		__ld.wm		_player_pos_y
         0E:D646  AD B9 23   			lda.l	_player_pos_y
         0E:D649  AC BA 23   			ldy.h	_player_pos_y
 6915                        		__call		_spr_y.1
         0E:D64C  20 19 E8   			call	_spr_y.1
 6916                        	
 6917                        		.dbg	line,	"include\routines_LEVELS.c", 1450; player_counter_anim = 1;
 6918                        		__st.umiq	1, _player_counter_anim
         0E:D64F  A9 01      			lda.l	#1
         0E:D651  8D 14 23   			sta	_player_counter_anim
 6919                        	
 6920                        		.dbg	line,	"include\routines_LEVELS.c", 1451; player_index_jump = 0;
 6921                        		__st.umiq	0, _player_index_jump
         0E:D654  9C 15 23   			stz	_player_index_jump
 6922                        	
 6923                        		.dbg	line,	"include\routines_LEVELS.c", 1452; jump_ladder = FALSE;
 6924                        		__st.umiq	0, _jump_ladder
         0E:D657  9C 17 23   			stz	_jump_ladder
 6925                        	
 6926                        		.dbg	line,	"include\routines_LEVELS.c", 1453; jump_max_index = 34;
 6927                        		__st.umiq	34, _jump_max_index
         0E:D65A  A9 22      			lda.l	#34
         0E:D65C  8D 18 23   			sta	_jump_max_index
 6928                        	
 6929                        		.dbg	line,	"include\routines_LEVELS.c", 1454; player_state = STATE_IDLE;
 6930                        		__st.umiq	0, _player_state
         0E:D65F  9C 11 23   			stz	_player_state
 6931                        	
 6932                        		.dbg	line,	"include\routines_LEVELS.c", 1455; return;
 6933                        		__bra		.LL158
         0E:D662  4C 39 DD   			bra	.LL158
 6934                        	
 6935                        		.dbg	line,	"include\routines_LEVELS.c", 1456; }
 6936                        	
 6937                        		.dbg	line,	"include\routines_LEVELS.c", 1457; }
 6938    0E:D665             	.LL283:
 6939    0E:D665             	.LL282:
 6940                        	
 6941                        		.dbg	line,	"include\routines_LEVELS.c", 1458; }
 6942                        	
 6943                        		.dbg	line,	"include\routines_LEVELS.c", 1463; //--------------------------------------------------------------------------------------//
 6944                        	
 6945                        		.dbg	line,	"include\routines_LEVELS.c", 1464; //                                   LADDER COLLISION                                   //
 6946                        	
 6947                        		.dbg	line,	"include\routines_LEVELS.c", 1465; //--------------------------------------------------------------------------------------//
 6948                        	
 6949                        		.dbg	line,	"include\routines_LEVELS.c", 1467; if(player_index_jump > 4)
 6950    0E:D665             	.LL273:
 6951                        		__ld.umq	_player_index_jump
         0E:D665  AD 15 23   			lda	_player_index_jump
 6952                        		__ugt_b.uiq	4
         0E:D668  18         			clc			; Subtract integer+1 from A.
         0E:D669  E9 04      			sbc	#4		; CS if A > integer.
 6953                        		__bfalse	.LL291
         0E:D66B  B0 03 4C FC			bcc	.LL291
         0E:D66F  D6          
 6954                        	
 6955                        		.dbg	line,	"include\routines_LEVELS.c", 1468; {
 6956                        	
 6957                        		.dbg	line,	"include\routines_LEVELS.c", 1469; check_BG( 16 , 16 );
 6958                        		__ld.wi		16
         0E:D670  A9 10      			lda.l	#16
         0E:D672  C2         			cly
 6959                        		__pusharg.wr
         0E:D673  A6 8D      			ldx	<__sp
         0E:D675  CA         			dex
         0E:D676  CA         			dex
         0E:D677  95 08      			sta.l	<__stack, x
         0E:D679  94 09      			sty.h	<__stack, x
         0E:D67B  86 8D      			stx	<__sp
 6960                        		__ld.wi		16
         0E:D67D  A9 10      			lda.l	#16
         0E:D67F  C2         			cly
 6961                        		__pusharg.wr
         0E:D680  A6 8D      			ldx	<__sp
         0E:D682  CA         			dex
         0E:D683  CA         			dex
         0E:D684  95 08      			sta.l	<__stack, x
         0E:D686  94 09      			sty.h	<__stack, x
         0E:D688  86 8D      			stx	<__sp
 6962                        		__call		_check_BG
         0E:D68A  20 6D FF   			call	_check_BG
 6963                        	
 6964                        		.dbg	line,	"include\routines_LEVELS.c", 1471; if(map_blk_flag == TILE_LADDER)
 6965                        		__ld.umq	_map_blk_flag
         0E:D68D  AD 76 2A   			lda	_map_blk_flag
 6966                        		__equ_b.uiq	2
         0E:D690  C9 02      			cmp	#2
         0E:D692  F0 01      			beq	!+
         0E:D694  18         			clc
         0E:D695             	!:
 6967                        		__bfalse	.LL292
         0E:D695  90 65      			bcc	.LL292
 6968                        	
 6969                        		.dbg	line,	"include\routines_LEVELS.c", 1472; {
 6970                        	
 6971                        		.dbg	line,	"include\routines_LEVELS.c", 1473; // CAMERA GOES 8 PX BACKWARD //
 6972                        	
 6973                        		.dbg	line,	"include\routines_LEVELS.c", 1474; sgx_map_pxl_x = ( (sgx_map_pxl_x >> 3) << 3 );
 6974                        		__ld.wm		_sgx_map_pxl_x
         0E:D697  AD 55 25   			lda.l	_sgx_map_pxl_x
         0E:D69A  AC 56 25   			ldy.h	_sgx_map_pxl_x
 6975                        		__lsr.wi	3
         0E:D69D  84 00      			sty	__temp
         0E:D69F  20 3A E2   			jsr	lsrw3
 6976                        		__asl.wi	3
         0E:D6A2  84 00      			sty	__temp
         0E:D6A4  20 D7 E1   			jsr	aslw3
 6977                        		__st.wmq	_sgx_map_pxl_x
         0E:D6A7  8D 55 25   			sta.l	_sgx_map_pxl_x
         0E:D6AA  8C 56 25   			sty.h	_sgx_map_pxl_x
 6978                        	
 6979                        		.dbg	line,	"include\routines_LEVELS.c", 1476; // SO WE UPDATE THE MAP //
 6980                        	
 6981                        		.dbg	line,	"include\routines_LEVELS.c", 1477; sgx_scroll_map();
 6982                        		__call		_sgx_scroll_map
         0E:D6AD  20 81 FF   			call	_sgx_scroll_map
 6983                        	
 6984                        		.dbg	line,	"include\routines_LEVELS.c", 1479; // CHECK IF THE PLAYER STANDS RIGHT TO THE LADDER //
 6985                        	
 6986                        		.dbg	line,	"include\routines_LEVELS.c", 1480; check_BG( 31 , 16 );
 6987                        		__ld.wi		31
         0E:D6B0  A9 1F      			lda.l	#31
         0E:D6B2  C2         			cly
 6988                        		__pusharg.wr
         0E:D6B3  A6 8D      			ldx	<__sp
         0E:D6B5  CA         			dex
         0E:D6B6  CA         			dex
         0E:D6B7  95 08      			sta.l	<__stack, x
         0E:D6B9  94 09      			sty.h	<__stack, x
         0E:D6BB  86 8D      			stx	<__sp
 6989                        		__ld.wi		16
         0E:D6BD  A9 10      			lda.l	#16
         0E:D6BF  C2         			cly
 6990                        		__pusharg.wr
         0E:D6C0  A6 8D      			ldx	<__sp
         0E:D6C2  CA         			dex
         0E:D6C3  CA         			dex
         0E:D6C4  95 08      			sta.l	<__stack, x
         0E:D6C6  94 09      			sty.h	<__stack, x
         0E:D6C8  86 8D      			stx	<__sp
 6991                        		__call		_check_BG
         0E:D6CA  20 6D FF   			call	_check_BG
 6992                        	
 6993                        		.dbg	line,	"include\routines_LEVELS.c", 1482; if(map_blk_flag == TILE_LADDER)
 6994                        		__ld.umq	_map_blk_flag
         0E:D6CD  AD 76 2A   			lda	_map_blk_flag
 6995                        		__equ_b.uiq	2
         0E:D6D0  C9 02      			cmp	#2
         0E:D6D2  F0 01      			beq	!+
         0E:D6D4  18         			clc
         0E:D6D5             	!:
 6996                        		__bfalse	.LL293
         0E:D6D5  90 0E      			bcc	.LL293
 6997                        	
 6998                        		.dbg	line,	"include\routines_LEVELS.c", 1483; {
 6999                        	
 7000                        		.dbg	line,	"include\routines_LEVELS.c", 1484; sgx_map_pxl_x += 8;
 7001                        		__add_st.wmiq	8, _sgx_map_pxl_x
         0E:D6D7  18         			clc
         0E:D6D8  AD 55 25   			lda.l	_sgx_map_pxl_x
         0E:D6DB  69 08      			adc.l	#8
         0E:D6DD  8D 55 25   			sta.l	_sgx_map_pxl_x
         0E:D6E0  90 03      			bcc	!+
         0E:D6E2  EE 56 25   			inc.h	_sgx_map_pxl_x
         0E:D6E5             	!:
 7002                        	
 7003                        		.dbg	line,	"include\routines_LEVELS.c", 1485; }
 7004                        	
 7005                        		.dbg	line,	"include\routines_LEVELS.c", 1487; player_counter_anim = 1;
 7006    0E:D6E5             	.LL293:
 7007                        		__st.umiq	1, _player_counter_anim
         0E:D6E5  A9 01      			lda.l	#1
         0E:D6E7  8D 14 23   			sta	_player_counter_anim
 7008                        	
 7009                        		.dbg	line,	"include\routines_LEVELS.c", 1488; player_index_jump = 0;
 7010                        		__st.umiq	0, _player_index_jump
         0E:D6EA  9C 15 23   			stz	_player_index_jump
 7011                        	
 7012                        		.dbg	line,	"include\routines_LEVELS.c", 1489; jump_ladder = TRUE;
 7013                        		__st.umiq	1, _jump_ladder
         0E:D6ED  A9 01      			lda.l	#1
         0E:D6EF  8D 17 23   			sta	_jump_ladder
 7014                        	
 7015                        		.dbg	line,	"include\routines_LEVELS.c", 1490; jump_max_index = 29;
 7016                        		__st.umiq	29, _jump_max_index
         0E:D6F2  A9 1D      			lda.l	#29
         0E:D6F4  8D 18 23   			sta	_jump_max_index
 7017                        	
 7018                        		.dbg	line,	"include\routines_LEVELS.c", 1491; player_state = STATE_HANG;
 7019                        		__st.umiq	10, _player_state
         0E:D6F7  A9 0A      			lda.l	#10
         0E:D6F9  8D 11 23   			sta	_player_state
 7020                        	
 7021                        		.dbg	line,	"include\routines_LEVELS.c", 1492; }
 7022                        	
 7023                        		.dbg	line,	"include\routines_LEVELS.c", 1493; }
 7024    0E:D6FC             	.LL292:
 7025                        	
 7026                        		.dbg	line,	"include\routines_LEVELS.c", 1496; // SET PLAYER SPRITE NEW POSITION //
 7027                        	
 7028                        		.dbg	line,	"include\routines_LEVELS.c", 1497; spr_y(player_pos_y);
 7029    0E:D6FC             	.LL291:
 7030                        		__ld.wm		_player_pos_y
         0E:D6FC  AD B9 23   			lda.l	_player_pos_y
         0E:D6FF  AC BA 23   			ldy.h	_player_pos_y
 7031                        		__call		_spr_y.1
         0E:D702  20 19 E8   			call	_spr_y.1
 7032                        	
 7033                        		.dbg	line,	"include\routines_LEVELS.c", 1498; }
 7034                        	
 7035                        		.dbg	line,	"include\routines_LEVELS.c", 1501; else if(player_state == STATE_CROUCH)
 7036                        		__bra		.LL294
         0E:D705  4C 39 DD   			bra	.LL294
 7037    0E:D708             	.LL258:
 7038                        		__ld.umq	_player_state
         0E:D708  AD 11 23   			lda	_player_state
 7039                        		__equ_b.uiq	7
         0E:D70B  C9 07      			cmp	#7
         0E:D70D  F0 01      			beq	!+
         0E:D70F  18         			clc
         0E:D710             	!:
 7040                        		__bfalse	.LL295
         0E:D710  90 2F      			bcc	.LL295
 7041                        	
 7042                        		.dbg	line,	"include\routines_LEVELS.c", 1502; {
 7043                        	
 7044                        		.dbg	line,	"include\routines_LEVELS.c", 1503; if(player_counter_anim == 1)
 7045                        		__ld.umq	_player_counter_anim
         0E:D712  AD 14 23   			lda	_player_counter_anim
 7046                        		__equ_b.uiq	1
         0E:D715  C9 01      			cmp	#1
         0E:D717  F0 01      			beq	!+
         0E:D719  18         			clc
         0E:D71A             	!:
 7047                        		__bfalse	.LL296
         0E:D71A  90 1F      			bcc	.LL296
 7048                        	
 7049                        		.dbg	line,	"include\routines_LEVELS.c", 1504; {
 7050                        	
 7051                        		.dbg	line,	"include\routines_LEVELS.c", 1505; load_vram(PLAYER_VRAM_ADR, tiles_SPR_PLAYER + TILES_128 , TILES_16);
 7052                        		__st.wmiq	6144, _di
         0E:D71C  64 F0      			stz.l	_di
         0E:D71E  A9 18      			lda.h	#6144
         0E:D720  85 F1      			sta.h	_di
 7053                        		__farptr	_tiles_SPR_PLAYER + 4096, _bp_bank, _bp
         0E:D722  A9 A0      			lda.l	#$6000 + ($1FFF & (_tiles_SPR_PLAYER + 4096))
         0E:D724  85 EC      			sta.l	_bp
         0E:D726  A9 6A      			lda.h	#$6000 + ($1FFF & (_tiles_SPR_PLAYER + 4096))
         0E:D728  85 ED      			sta.h	_bp
         0E:D72A  A9 0C      			lda	#bank(_tiles_SPR_PLAYER + 4096)
         0E:D72C  85 02      			sta	_bp_bank
 7054                        		__st.wmiq	256, _ax
         0E:D72E  64 F8      			stz.l	_ax
         0E:D730  A9 01      			lda.h	#256
         0E:D732  85 F9      			sta.h	_ax
 7055                        		 _load_vram.3
         0E:D734  82         			clx				; Offset to PCE VDC.
         0E:D735  20 63 FF   			call	load_vram_x
 7056                        	
 7057                        		.dbg	line,	"include\routines_LEVELS.c", 1507; player_counter_anim = 0;
 7058                        		__st.umiq	0, _player_counter_anim
         0E:D738  9C 14 23   			stz	_player_counter_anim
 7059                        	
 7060                        		.dbg	line,	"include\routines_LEVELS.c", 1508; }
 7061                        	
 7062                        		.dbg	line,	"include\routines_LEVELS.c", 1510; recenter_CAMERA();
 7063    0E:D73B             	.LL296:
 7064                        		__call		_recenter_CAMERA
         0E:D73B  20 59 FF   			call	_recenter_CAMERA
 7065                        	
 7066                        		.dbg	line,	"include\routines_LEVELS.c", 1511; }
 7067                        	
 7068                        		.dbg	line,	"include\routines_LEVELS.c", 1514; else if(player_state == STATE_FALL)
 7069                        		__bra		.LL297
         0E:D73E  4C 39 DD   			bra	.LL297
 7070    0E:D741             	.LL295:
 7071                        		__ld.umq	_player_state
         0E:D741  AD 11 23   			lda	_player_state
 7072                        		__equ_b.uiq	9
         0E:D744  C9 09      			cmp	#9
         0E:D746  F0 01      			beq	!+
         0E:D748  18         			clc
         0E:D749             	!:
 7073                        		__bfalse	.LL298
         0E:D749  B0 03 4C 50			bcc	.LL298
         0E:D74D  D9          
 7074                        	
 7075                        		.dbg	line,	"include\routines_LEVELS.c", 1515; {
 7076                        	
 7077                        		.dbg	line,	"include\routines_LEVELS.c", 1516; unsigned char i, camera_y_move;
 7078                        	
 7079                        		.dbg	line,	"include\routines_LEVELS.c", 1517; i = 1;
 7080                        		__st.umiq	1, __update_PLAYER_end - 6  /* i */
         0E:D74E  A9 01      			lda.l	#1
         0E:D750  8D 07 23   			sta	__update_PLAYER_end - 6
 7081                        	
 7082                        		.dbg	line,	"include\routines_LEVELS.c", 1520; spr_set(player_id);
 7083                        		__ld.umq	_player_id
         0E:D753  AD 10 23   			lda	_player_id
 7084                        		__call		_spr_set.1
         0E:D756  20 DD E7   			call	_spr_set.1
 7085                        	
 7086                        		.dbg	line,	"include\routines_LEVELS.c", 1523; //--------------------------------------------------------------------------------------//
 7087                        	
 7088                        		.dbg	line,	"include\routines_LEVELS.c", 1524; //                                        V MOVE                                        //
 7089                        	
 7090                        		.dbg	line,	"include\routines_LEVELS.c", 1525; //--------------------------------------------------------------------------------------//
 7091                        	
 7092                        		.dbg	line,	"include\routines_LEVELS.c", 1527; // UPDATE PLAYER Y POSITION //
 7093                        	
 7094                        		.dbg	line,	"include\routines_LEVELS.c", 1528; player_pos_y += TABLE_PLAYER_FALL[player_index_fall];
 7095                        		__ldx.umq	_player_index_fall
         0E:D759  AE 16 23   			ldx	_player_index_fall
 7096                        		__ld.bax	_TABLE_PLAYER_FALL
         0E:D75C  BD C3 60   			lda	_TABLE_PLAYER_FALL, x
         0E:D75F  C2         			cly
         0E:D760  10 01      			bpl	!+
         0E:D762  88         			dey
         0E:D763             	!:
 7097                        		__add_st.wmq	_player_pos_y
         0E:D763  18         			clc
         0E:D764  6D B9 23   			adc.l	_player_pos_y
         0E:D767  8D B9 23   			sta.l	_player_pos_y
         0E:D76A  98         			tya
         0E:D76B  6D BA 23   			adc.h	_player_pos_y
         0E:D76E  8D BA 23   			sta.h	_player_pos_y
 7098                        	
 7099                        		.dbg	line,	"include\routines_LEVELS.c", 1531; // IF PLAYER GOES BELOW ITS BASE Y POSITION //
 7100                        	
 7101                        		.dbg	line,	"include\routines_LEVELS.c", 1532; if(player_pos_y >= PLAYER_BASE_Y_POS)
 7102                        		__ld.wm		_player_pos_y
         0E:D771  AD B9 23   			lda.l	_player_pos_y
         0E:D774  AC BA 23   			ldy.h	_player_pos_y
 7103                        		__sge_w.wi	128
         0E:D777  C9 80      			cmp.l	#128		; Subtract integer from Y:A.
         0E:D779  98         			tya
         0E:D77A  E9 00      			sbc.h	#128
         0E:D77C  50 02      			bvc	!+
         0E:D77E  49 80      			eor	#$80		; +ve if Y:A >= integer (signed).
         0E:D780  49 80      	!:		eor	#$80
         0E:D782  0A         			asl	a
 7104                        		__bfalse	.LL299
         0E:D783  90 45      			bcc	.LL299
 7105                        	
 7106                        		.dbg	line,	"include\routines_LEVELS.c", 1533; {
 7107                        	
 7108                        		.dbg	line,	"include\routines_LEVELS.c", 1534; // THE CAMERA MOVES //
 7109                        	
 7110                        		.dbg	line,	"include\routines_LEVELS.c", 1535; // CALCULATE HOW MANY PIXELS THE CAMERA HAS TO MOVE DOWN //
 7111                        	
 7112                        		.dbg	line,	"include\routines_LEVELS.c", 1536; camera_y_move = player_pos_y - PLAYER_BASE_Y_POS;
 7113                        		__ld.wm		_player_pos_y
         0E:D785  AD B9 23   			lda.l	_player_pos_y
         0E:D788  AC BA 23   			ldy.h	_player_pos_y
 7114                        		__sub.wi	128
         0E:D78B  38         			sec
         0E:D78C  E9 80      			sbc.l	#128
         0E:D78E  B0 01      			bcs	!+
         0E:D790  88         			dey
         0E:D791             	!:
 7115                        		__st.umq	__update_PLAYER_end - 7  /* camera_y_move */
         0E:D791  8D 06 23   			sta	__update_PLAYER_end - 7
 7116                        	
 7117                        		.dbg	line,	"include\routines_LEVELS.c", 1537; sgx_map_pxl_y += camera_y_move;
 7118                        		__ld.um		__update_PLAYER_end - 7  /* camera_y_move */
         0E:D794  AD 06 23   			lda	__update_PLAYER_end - 7
         0E:D797  C2         			cly
 7119                        		__add_st.wmq	_sgx_map_pxl_y
         0E:D798  18         			clc
         0E:D799  6D 57 25   			adc.l	_sgx_map_pxl_y
         0E:D79C  8D 57 25   			sta.l	_sgx_map_pxl_y
         0E:D79F  98         			tya
         0E:D7A0  6D 58 25   			adc.h	_sgx_map_pxl_y
         0E:D7A3  8D 58 25   			sta.h	_sgx_map_pxl_y
 7120                        	
 7121                        		.dbg	line,	"include\routines_LEVELS.c", 1539; // IF THE CAMERA HAS REACHED ITS MAX (LOWEST) POSITION //
 7122                        	
 7123                        		.dbg	line,	"include\routines_LEVELS.c", 1540; if(sgx_map_pxl_y > camera_max_y_position)
 7124                        		__ld.wm		_sgx_map_pxl_y
         0E:D7A6  AD 57 25   			lda.l	_sgx_map_pxl_y
         0E:D7A9  AC 58 25   			ldy.h	_sgx_map_pxl_y
 7125                        		__ugt_w.wm	_camera_max_y_position
         0E:D7AC  18         			clc			; Subtract memory+1 from Y:A.
         0E:D7AD  ED BB 23   			sbc.l	_camera_max_y_position
         0E:D7B0  98         			tya
         0E:D7B1  ED BC 23   			sbc.h	_camera_max_y_position		; CS if Y:A > memory.
 7126                        		__bfalse	.LL300
         0E:D7B4  90 0C      			bcc	.LL300
 7127                        	
 7128                        		.dbg	line,	"include\routines_LEVELS.c", 1541; {
 7129                        	
 7130                        		.dbg	line,	"include\routines_LEVELS.c", 1542; // THE CAMERA CAN NOT MOVE LOWER //
 7131                        	
 7132                        		.dbg	line,	"include\routines_LEVELS.c", 1543; sgx_map_pxl_y = camera_max_y_position;
 7133                        		__ld.wm		_camera_max_y_position
         0E:D7B6  AD BB 23   			lda.l	_camera_max_y_position
         0E:D7B9  AC BC 23   			ldy.h	_camera_max_y_position
 7134                        		__st.wmq	_sgx_map_pxl_y
         0E:D7BC  8D 57 25   			sta.l	_sgx_map_pxl_y
         0E:D7BF  8C 58 25   			sty.h	_sgx_map_pxl_y
 7135                        	
 7136                        		.dbg	line,	"include\routines_LEVELS.c", 1544; }
 7137                        	
 7138                        		.dbg	line,	"include\routines_LEVELS.c", 1546; // THE PLAYER STAYS AT ITS BASE Y POSITION //
 7139                        	
 7140                        		.dbg	line,	"include\routines_LEVELS.c", 1547; player_pos_y = PLAYER_BASE_Y_POS;
 7141    0E:D7C2             	.LL300:
 7142                        		__st.wmiq	128, _player_pos_y
         0E:D7C2  A9 80      			lda.l	#128
         0E:D7C4  8D B9 23   			sta.l	_player_pos_y
         0E:D7C7  9C BA 23   			stz.h	_player_pos_y
 7143                        	
 7144                        		.dbg	line,	"include\routines_LEVELS.c", 1548; }
 7145                        	
 7146                        		.dbg	line,	"include\routines_LEVELS.c", 1551; // UPDATE JUMP INDEX IN THE ARRAY //
 7147                        	
 7148                        		.dbg	line,	"include\routines_LEVELS.c", 1552; // ARRAY MAX ENTRY : 20//
 7149                        	
 7150                        		.dbg	line,	"include\routines_LEVELS.c", 1553; if(player_index_fall < 20)
 7151    0E:D7CA             	.LL299:
 7152                        		__ld.umq	_player_index_fall
         0E:D7CA  AD 16 23   			lda	_player_index_fall
 7153                        		__ult_b.uiq	20
         0E:D7CD  C9 14      			cmp	#20		; Subtract integer from A.
         0E:D7CF  6A         			ror	a		; CC if A < integer.
         0E:D7D0  49 80      			eor	#$80
         0E:D7D2  2A         			rol	a
 7154                        		__bfalse	.LL301
         0E:D7D3  90 03      			bcc	.LL301
 7155                        	
 7156                        		.dbg	line,	"include\routines_LEVELS.c", 1554; {
 7157                        	
 7158                        		.dbg	line,	"include\routines_LEVELS.c", 1555; player_index_fall += 1;
 7159                        		__add_st.umiq	1, _player_index_fall
         0E:D7D5  EE 16 23   			inc	_player_index_fall
 7160                        	
 7161                        		.dbg	line,	"include\routines_LEVELS.c", 1556; }
 7162                        	
 7163                        		.dbg	line,	"include\routines_LEVELS.c", 1559; check_TILE_DEPTH( 15 , 0);
 7164    0E:D7D8             	.LL301:
 7165                        		__ld.wi		15
         0E:D7D8  A9 0F      			lda.l	#15
         0E:D7DA  C2         			cly
 7166                        		__pusharg.wr
         0E:D7DB  A6 8D      			ldx	<__sp
         0E:D7DD  CA         			dex
         0E:D7DE  CA         			dex
         0E:D7DF  95 08      			sta.l	<__stack, x
         0E:D7E1  94 09      			sty.h	<__stack, x
         0E:D7E3  86 8D      			stx	<__sp
 7167                        		__ld.wi		0
         0E:D7E5  62         			cla
         0E:D7E6  C2         			cly
 7168                        		__pusharg.wr
         0E:D7E7  A6 8D      			ldx	<__sp
         0E:D7E9  CA         			dex
         0E:D7EA  CA         			dex
         0E:D7EB  95 08      			sta.l	<__stack, x
         0E:D7ED  94 09      			sty.h	<__stack, x
         0E:D7EF  86 8D      			stx	<__sp
 7169                        		__call		_check_TILE_DEPTH
         0E:D7F1  20 4F FF   			call	_check_TILE_DEPTH
 7170                        	
 7171                        		.dbg	line,	"include\routines_LEVELS.c", 1562; if(map_blk_flag == TILE_BG)
 7172                        		__ld.umq	_map_blk_flag
         0E:D7F4  AD 76 2A   			lda	_map_blk_flag
 7173                        		__equ_b.uiq	1
         0E:D7F7  C9 01      			cmp	#1
         0E:D7F9  F0 01      			beq	!+
         0E:D7FB  18         			clc
         0E:D7FC             	!:
 7174                        		__bfalse	.LL302
         0E:D7FC  B0 03 4C B2			bcc	.LL302
         0E:D800  D8          
 7175                        	
 7176                        		.dbg	line,	"include\routines_LEVELS.c", 1563; {
 7177                        	
 7178                        		.dbg	line,	"include\routines_LEVELS.c", 1564; // CALCULATE HOW MANY PIXELS THE PLAYER MOVED INTO THE GROUND //
 7179                        	
 7180                        		.dbg	line,	"include\routines_LEVELS.c", 1565; for(i=1; i<11 ; i++ )
 7181                        		__st.umiq	1, __update_PLAYER_end - 6  /* i */
         0E:D801  A9 01      			lda.l	#1
         0E:D803  8D 07 23   			sta	__update_PLAYER_end - 6
 7182    0E:D806             	.LL303:
 7183                        		__ld.umq	__update_PLAYER_end - 6  /* i */
         0E:D806  AD 07 23   			lda	__update_PLAYER_end - 6
 7184                        		__ult_b.uiq	11
         0E:D809  C9 0B      			cmp	#11		; Subtract integer from A.
         0E:D80B  6A         			ror	a		; CC if A < integer.
         0E:D80C  49 80      			eor	#$80
         0E:D80E  2A         			rol	a
 7185                        		__btrue		.LL305
         0E:D80F  B0 07      			bcs	.LL305
 7186                        		__bra		.LL306
         0E:D811  80 7D      			bra	.LL306
 7187    0E:D813             	.LL304:
 7188                        		__inc.umq	__update_PLAYER_end - 6  /* i */
         0E:D813  EE 07 23   			inc	__update_PLAYER_end - 6
 7189                        		__bra		.LL303
         0E:D816  80 EE      			bra	.LL303
 7190    0E:D818             	.LL305:
 7191                        	
 7192                        		.dbg	line,	"include\routines_LEVELS.c", 1566; {
 7193                        	
 7194                        		.dbg	line,	"include\routines_LEVELS.c", 1567; //if(player_axis == AXIS_RIGHT)
 7195                        	
 7196                        		.dbg	line,	"include\routines_LEVELS.c", 1568; //{
 7197                        	
 7198                        		.dbg	line,	"include\routines_LEVELS.c", 1569; check_TILE_DEPTH( 15 , i);//20
 7199                        		__ld.wi		15
         0E:D818  A9 0F      			lda.l	#15
         0E:D81A  C2         			cly
 7200                        		__pusharg.wr
         0E:D81B  A6 8D      			ldx	<__sp
         0E:D81D  CA         			dex
         0E:D81E  CA         			dex
         0E:D81F  95 08      			sta.l	<__stack, x
         0E:D821  94 09      			sty.h	<__stack, x
         0E:D823  86 8D      			stx	<__sp
 7201                        		__ld.um		__update_PLAYER_end - 6  /* i */
         0E:D825  AD 07 23   			lda	__update_PLAYER_end - 6
         0E:D828  C2         			cly
 7202                        		__pusharg.wr
         0E:D829  A6 8D      			ldx	<__sp
         0E:D82B  CA         			dex
         0E:D82C  CA         			dex
         0E:D82D  95 08      			sta.l	<__stack, x
         0E:D82F  94 09      			sty.h	<__stack, x
         0E:D831  86 8D      			stx	<__sp
 7203                        		__call		_check_TILE_DEPTH
         0E:D833  20 4F FF   			call	_check_TILE_DEPTH
 7204                        	
 7205                        		.dbg	line,	"include\routines_LEVELS.c", 1570; //}
 7206                        	
 7207                        		.dbg	line,	"include\routines_LEVELS.c", 1572; /*else
 7208                        	
 7209                        		.dbg	line,	"include\routines_LEVELS.c", 1573; {
 7210                        	
 7211                        		.dbg	line,	"include\routines_LEVELS.c", 1574; check_TILE_DEPTH( 10 , i);
 7212                        	
 7213                        		.dbg	line,	"include\routines_LEVELS.c", 1575; }*/
 7214                        	
 7215                        		.dbg	line,	"include\routines_LEVELS.c", 1578; if(map_blk_flag == TILE_EMPTY)
 7216                        		__not.um	_map_blk_flag
         0E:D836  AD 76 2A   			lda	_map_blk_flag
         0E:D839  18         			clc
         0E:D83A  D0 01      			bne	!+
         0E:D83C  38         			sec
         0E:D83D             	!:
 7217                        		__bfalse	.LL307
         0E:D83D  90 D4      			bcc	.LL307
 7218                        	
 7219                        		.dbg	line,	"include\routines_LEVELS.c", 1579; {
 7220                        	
 7221                        		.dbg	line,	"include\routines_LEVELS.c", 1580; if(player_pos_y != PLAYER_BASE_Y_POS)
 7222                        		__ld.wm		_player_pos_y
         0E:D83F  AD B9 23   			lda.l	_player_pos_y
         0E:D842  AC BA 23   			ldy.h	_player_pos_y
 7223                        		__neq_w.wi	128
         0E:D845  38         			sec
         0E:D846  49 80      			eor.l	#128
         0E:D848  D0 06      			bne	!+
         0E:D84A  98         			tya
         0E:D84B  49 00      			eor.h	#128
         0E:D84D  D0 01      			bne	!+
         0E:D84F  18         			clc
         0E:D850             	!:
 7224                        		__bfalse	.LL308
         0E:D850  90 1E      			bcc	.LL308
 7225                        	
 7226                        		.dbg	line,	"include\routines_LEVELS.c", 1581; {
 7227                        	
 7228                        		.dbg	line,	"include\routines_LEVELS.c", 1582; player_pos_y -= (i - 1);
 7229                        		__ld.um		__update_PLAYER_end - 6  /* i */
         0E:D852  AD 07 23   			lda	__update_PLAYER_end - 6
         0E:D855  C2         			cly
 7230                        		__sub.wi	1
         0E:D856  38         			sec
         0E:D857  E9 01      			sbc.l	#1
         0E:D859  B0 01      			bcs	!+
         0E:D85B  88         			dey
         0E:D85C             	!:
 7231                        		__isub_st.wmq	_player_pos_y
         0E:D85C  38         			sec
         0E:D85D  49 FF      			eor	#$FF
         0E:D85F  6D B9 23   			adc.l	_player_pos_y
         0E:D862  8D B9 23   			sta.l	_player_pos_y
         0E:D865  98         			tya
         0E:D866  49 FF      			eor	#$FF
         0E:D868  6D BA 23   			adc.h	_player_pos_y
         0E:D86B  8D BA 23   			sta.h	_player_pos_y
 7232                        	
 7233                        		.dbg	line,	"include\routines_LEVELS.c", 1583; }
 7234                        	
 7235                        		.dbg	line,	"include\routines_LEVELS.c", 1585; else
 7236                        		__bra		.LL309
         0E:D86E  80 20      			bra	.LL309
 7237    0E:D870             	.LL308:
 7238                        	
 7239                        		.dbg	line,	"include\routines_LEVELS.c", 1586; {
 7240                        	
 7241                        		.dbg	line,	"include\routines_LEVELS.c", 1587; sgx_map_pxl_y -= (i - 1);
 7242                        		__ld.um		__update_PLAYER_end - 6  /* i */
         0E:D870  AD 07 23   			lda	__update_PLAYER_end - 6
         0E:D873  C2         			cly
 7243                        		__sub.wi	1
         0E:D874  38         			sec
         0E:D875  E9 01      			sbc.l	#1
         0E:D877  B0 01      			bcs	!+
         0E:D879  88         			dey
         0E:D87A             	!:
 7244                        		__isub_st.wmq	_sgx_map_pxl_y
         0E:D87A  38         			sec
         0E:D87B  49 FF      			eor	#$FF
         0E:D87D  6D 57 25   			adc.l	_sgx_map_pxl_y
         0E:D880  8D 57 25   			sta.l	_sgx_map_pxl_y
         0E:D883  98         			tya
         0E:D884  49 FF      			eor	#$FF
         0E:D886  6D 58 25   			adc.h	_sgx_map_pxl_y
         0E:D889  8D 58 25   			sta.h	_sgx_map_pxl_y
 7245                        	
 7246                        		.dbg	line,	"include\routines_LEVELS.c", 1588; }
 7247    0E:D88C             	.LL309	.alias		.LL306
 7248                        	
 7249                        		.dbg	line,	"include\routines_LEVELS.c", 1591; break;
 7250                        		__bra		.LL306
         0E:D88C  80 02      			bra	.LL306
 7251                        	
 7252                        		.dbg	line,	"include\routines_LEVELS.c", 1592; }
 7253                        	
 7254                        		.dbg	line,	"include\routines_LEVELS.c", 1594; }
 7255    0E:D88E             	.LL307	.alias		.LL304
 7256                        		__bra		.LL304
         0E:D88E  80 83      			bra	.LL304
 7257    0E:D890             	.LL306:
 7258                        	
 7259                        		.dbg	line,	"include\routines_LEVELS.c", 1596; spr_y(player_pos_y);
 7260                        		__ld.wm		_player_pos_y
         0E:D890  AD B9 23   			lda.l	_player_pos_y
         0E:D893  AC BA 23   			ldy.h	_player_pos_y
 7261                        		__call		_spr_y.1
         0E:D896  20 19 E8   			call	_spr_y.1
 7262                        	
 7263                        		.dbg	line,	"include\routines_LEVELS.c", 1598; player_counter_anim = 1;
 7264                        		__st.umiq	1, _player_counter_anim
         0E:D899  A9 01      			lda.l	#1
         0E:D89B  8D 14 23   			sta	_player_counter_anim
 7265                        	
 7266                        		.dbg	line,	"include\routines_LEVELS.c", 1599; player_index_jump = 0;
 7267                        		__st.umiq	0, _player_index_jump
         0E:D89E  9C 15 23   			stz	_player_index_jump
 7268                        	
 7269                        		.dbg	line,	"include\routines_LEVELS.c", 1600; player_index_fall = 0;
 7270                        		__st.umiq	0, _player_index_fall
         0E:D8A1  9C 16 23   			stz	_player_index_fall
 7271                        	
 7272                        		.dbg	line,	"include\routines_LEVELS.c", 1601; jump_ladder = FALSE;
 7273                        		__st.umiq	0, _jump_ladder
         0E:D8A4  9C 17 23   			stz	_jump_ladder
 7274                        	
 7275                        		.dbg	line,	"include\routines_LEVELS.c", 1602; jump_max_index = 34;
 7276                        		__st.umiq	34, _jump_max_index
         0E:D8A7  A9 22      			lda.l	#34
         0E:D8A9  8D 18 23   			sta	_jump_max_index
 7277                        	
 7278                        		.dbg	line,	"include\routines_LEVELS.c", 1603; player_state = STATE_IDLE;
 7279                        		__st.umiq	0, _player_state
         0E:D8AC  9C 11 23   			stz	_player_state
 7280                        	
 7281                        		.dbg	line,	"include\routines_LEVELS.c", 1604; return;
 7282                        		__bra		.LL158
         0E:D8AF  4C 39 DD   			bra	.LL158
 7283                        	
 7284                        		.dbg	line,	"include\routines_LEVELS.c", 1605; }
 7285                        	
 7286                        		.dbg	line,	"include\routines_LEVELS.c", 1608; check_BG( 16 , 16 );
 7287    0E:D8B2             	.LL302:
 7288                        		__ld.wi		16
         0E:D8B2  A9 10      			lda.l	#16
         0E:D8B4  C2         			cly
 7289                        		__pusharg.wr
         0E:D8B5  A6 8D      			ldx	<__sp
         0E:D8B7  CA         			dex
         0E:D8B8  CA         			dex
         0E:D8B9  95 08      			sta.l	<__stack, x
         0E:D8BB  94 09      			sty.h	<__stack, x
         0E:D8BD  86 8D      			stx	<__sp
 7290                        		__ld.wi		16
         0E:D8BF  A9 10      			lda.l	#16
         0E:D8C1  C2         			cly
 7291                        		__pusharg.wr
         0E:D8C2  A6 8D      			ldx	<__sp
         0E:D8C4  CA         			dex
         0E:D8C5  CA         			dex
         0E:D8C6  95 08      			sta.l	<__stack, x
         0E:D8C8  94 09      			sty.h	<__stack, x
         0E:D8CA  86 8D      			stx	<__sp
 7292                        		__call		_check_BG
         0E:D8CC  20 6D FF   			call	_check_BG
 7293                        	
 7294                        		.dbg	line,	"include\routines_LEVELS.c", 1610; // IF PLAYER HITS THE LADDER //
 7295                        	
 7296                        		.dbg	line,	"include\routines_LEVELS.c", 1611; if(map_blk_flag == TILE_LADDER)
 7297                        		__ld.umq	_map_blk_flag
         0E:D8CF  AD 76 2A   			lda	_map_blk_flag
 7298                        		__equ_b.uiq	2
         0E:D8D2  C9 02      			cmp	#2
         0E:D8D4  F0 01      			beq	!+
         0E:D8D6  18         			clc
         0E:D8D7             	!:
 7299                        		__bfalse	.LL310
         0E:D8D7  90 6B      			bcc	.LL310
 7300                        	
 7301                        		.dbg	line,	"include\routines_LEVELS.c", 1612; {
 7302                        	
 7303                        		.dbg	line,	"include\routines_LEVELS.c", 1613; // CAMERA GOES 8 PX BACKWARD //
 7304                        	
 7305                        		.dbg	line,	"include\routines_LEVELS.c", 1614; sgx_map_pxl_x = ( (sgx_map_pxl_x >> 3) << 3 );
 7306                        		__ld.wm		_sgx_map_pxl_x
         0E:D8D9  AD 55 25   			lda.l	_sgx_map_pxl_x
         0E:D8DC  AC 56 25   			ldy.h	_sgx_map_pxl_x
 7307                        		__lsr.wi	3
         0E:D8DF  84 00      			sty	__temp
         0E:D8E1  20 3A E2   			jsr	lsrw3
 7308                        		__asl.wi	3
         0E:D8E4  84 00      			sty	__temp
         0E:D8E6  20 D7 E1   			jsr	aslw3
 7309                        		__st.wmq	_sgx_map_pxl_x
         0E:D8E9  8D 55 25   			sta.l	_sgx_map_pxl_x
         0E:D8EC  8C 56 25   			sty.h	_sgx_map_pxl_x
 7310                        	
 7311                        		.dbg	line,	"include\routines_LEVELS.c", 1616; // SO WE UPDATE THE MAP //
 7312                        	
 7313                        		.dbg	line,	"include\routines_LEVELS.c", 1617; sgx_scroll_map();
 7314                        		__call		_sgx_scroll_map
         0E:D8EF  20 81 FF   			call	_sgx_scroll_map
 7315                        	
 7316                        		.dbg	line,	"include\routines_LEVELS.c", 1619; // CHECK IF THE PLAYER STANDS RIGHT TO THE LADDER //
 7317                        	
 7318                        		.dbg	line,	"include\routines_LEVELS.c", 1620; check_BG( 31 , 16 );
 7319                        		__ld.wi		31
         0E:D8F2  A9 1F      			lda.l	#31
         0E:D8F4  C2         			cly
 7320                        		__pusharg.wr
         0E:D8F5  A6 8D      			ldx	<__sp
         0E:D8F7  CA         			dex
         0E:D8F8  CA         			dex
         0E:D8F9  95 08      			sta.l	<__stack, x
         0E:D8FB  94 09      			sty.h	<__stack, x
         0E:D8FD  86 8D      			stx	<__sp
 7321                        		__ld.wi		16
         0E:D8FF  A9 10      			lda.l	#16
         0E:D901  C2         			cly
 7322                        		__pusharg.wr
         0E:D902  A6 8D      			ldx	<__sp
         0E:D904  CA         			dex
         0E:D905  CA         			dex
         0E:D906  95 08      			sta.l	<__stack, x
         0E:D908  94 09      			sty.h	<__stack, x
         0E:D90A  86 8D      			stx	<__sp
 7323                        		__call		_check_BG
         0E:D90C  20 6D FF   			call	_check_BG
 7324                        	
 7325                        		.dbg	line,	"include\routines_LEVELS.c", 1622; if(map_blk_flag == TILE_LADDER)
 7326                        		__ld.umq	_map_blk_flag
         0E:D90F  AD 76 2A   			lda	_map_blk_flag
 7327                        		__equ_b.uiq	2
         0E:D912  C9 02      			cmp	#2
         0E:D914  F0 01      			beq	!+
         0E:D916  18         			clc
         0E:D917             	!:
 7328                        		__bfalse	.LL311
         0E:D917  90 0E      			bcc	.LL311
 7329                        	
 7330                        		.dbg	line,	"include\routines_LEVELS.c", 1623; {
 7331                        	
 7332                        		.dbg	line,	"include\routines_LEVELS.c", 1624; sgx_map_pxl_x += 8;
 7333                        		__add_st.wmiq	8, _sgx_map_pxl_x
         0E:D919  18         			clc
         0E:D91A  AD 55 25   			lda.l	_sgx_map_pxl_x
         0E:D91D  69 08      			adc.l	#8
         0E:D91F  8D 55 25   			sta.l	_sgx_map_pxl_x
         0E:D922  90 03      			bcc	!+
         0E:D924  EE 56 25   			inc.h	_sgx_map_pxl_x
         0E:D927             	!:
 7334                        	
 7335                        		.dbg	line,	"include\routines_LEVELS.c", 1625; }
 7336                        	
 7337                        		.dbg	line,	"include\routines_LEVELS.c", 1627; player_counter_anim = 1;
 7338    0E:D927             	.LL311:
 7339                        		__st.umiq	1, _player_counter_anim
         0E:D927  A9 01      			lda.l	#1
         0E:D929  8D 14 23   			sta	_player_counter_anim
 7340                        	
 7341                        		.dbg	line,	"include\routines_LEVELS.c", 1628; player_index_jump = 0;
 7342                        		__st.umiq	0, _player_index_jump
         0E:D92C  9C 15 23   			stz	_player_index_jump
 7343                        	
 7344                        		.dbg	line,	"include\routines_LEVELS.c", 1629; player_index_fall = 0;
 7345                        		__st.umiq	0, _player_index_fall
         0E:D92F  9C 16 23   			stz	_player_index_fall
 7346                        	
 7347                        		.dbg	line,	"include\routines_LEVELS.c", 1630; jump_ladder = TRUE;
 7348                        		__st.umiq	1, _jump_ladder
         0E:D932  A9 01      			lda.l	#1
         0E:D934  8D 17 23   			sta	_jump_ladder
 7349                        	
 7350                        		.dbg	line,	"include\routines_LEVELS.c", 1631; jump_max_index = 29;
 7351                        		__st.umiq	29, _jump_max_index
         0E:D937  A9 1D      			lda.l	#29
         0E:D939  8D 18 23   			sta	_jump_max_index
 7352                        	
 7353                        		.dbg	line,	"include\routines_LEVELS.c", 1632; player_state = STATE_HANG;
 7354                        		__st.umiq	10, _player_state
         0E:D93C  A9 0A      			lda.l	#10
         0E:D93E  8D 11 23   			sta	_player_state
 7355                        	
 7356                        		.dbg	line,	"include\routines_LEVELS.c", 1633; return;
 7357                        		__bra		.LL158
         0E:D941  4C 39 DD   			bra	.LL158
 7358                        	
 7359                        		.dbg	line,	"include\routines_LEVELS.c", 1634; }
 7360                        	
 7361                        		.dbg	line,	"include\routines_LEVELS.c", 1637; spr_y(player_pos_y);
 7362    0E:D944             	.LL310:
 7363                        		__ld.wm		_player_pos_y
         0E:D944  AD B9 23   			lda.l	_player_pos_y
         0E:D947  AC BA 23   			ldy.h	_player_pos_y
 7364                        		__call		_spr_y.1
         0E:D94A  20 19 E8   			call	_spr_y.1
 7365                        	
 7366                        		.dbg	line,	"include\routines_LEVELS.c", 1638; }
 7367                        	
 7368                        		.dbg	line,	"include\routines_LEVELS.c", 1641; else if(player_state == STATE_HANG)
 7369                        		__bra		.LL312
         0E:D94D  4C 39 DD   			bra	.LL312
 7370    0E:D950             	.LL298:
 7371                        		__ld.umq	_player_state
         0E:D950  AD 11 23   			lda	_player_state
 7372                        		__equ_b.uiq	10
         0E:D953  C9 0A      			cmp	#10
         0E:D955  F0 01      			beq	!+
         0E:D957  18         			clc
         0E:D958             	!:
 7373                        		__bfalse	.LL313
         0E:D958  90 32      			bcc	.LL313
 7374                        	
 7375                        		.dbg	line,	"include\routines_LEVELS.c", 1642; {
 7376                        	
 7377                        		.dbg	line,	"include\routines_LEVELS.c", 1643; recenter_CAMERA();
 7378                        		__call		_recenter_CAMERA
         0E:D95A  20 59 FF   			call	_recenter_CAMERA
 7379                        	
 7380                        		.dbg	line,	"include\routines_LEVELS.c", 1645; if(player_counter_anim == 1)
 7381                        		__ld.umq	_player_counter_anim
         0E:D95D  AD 14 23   			lda	_player_counter_anim
 7382                        		__equ_b.uiq	1
         0E:D960  C9 01      			cmp	#1
         0E:D962  F0 01      			beq	!+
         0E:D964  18         			clc
         0E:D965             	!:
 7383                        		__bfalse	.LL314
         0E:D965  B0 03 4C 39			bcc	.LL314
         0E:D969  DD          
 7384                        	
 7385                        		.dbg	line,	"include\routines_LEVELS.c", 1646; {
 7386                        	
 7387                        		.dbg	line,	"include\routines_LEVELS.c", 1647; load_vram(PLAYER_VRAM_ADR, tiles_SPR_PLAYER + TILES_144 , TILES_16);
 7388                        		__st.wmiq	6144, _di
         0E:D96A  64 F0      			stz.l	_di
         0E:D96C  A9 18      			lda.h	#6144
         0E:D96E  85 F1      			sta.h	_di
 7389                        		__farptr	_tiles_SPR_PLAYER + 4608, _bp_bank, _bp
         0E:D970  A9 A0      			lda.l	#$6000 + ($1FFF & (_tiles_SPR_PLAYER + 4608))
         0E:D972  85 EC      			sta.l	_bp
         0E:D974  A9 6C      			lda.h	#$6000 + ($1FFF & (_tiles_SPR_PLAYER + 4608))
         0E:D976  85 ED      			sta.h	_bp
         0E:D978  A9 0C      			lda	#bank(_tiles_SPR_PLAYER + 4608)
         0E:D97A  85 02      			sta	_bp_bank
 7390                        		__st.wmiq	256, _ax
         0E:D97C  64 F8      			stz.l	_ax
         0E:D97E  A9 01      			lda.h	#256
         0E:D980  85 F9      			sta.h	_ax
 7391                        		 _load_vram.3
         0E:D982  82         			clx				; Offset to PCE VDC.
         0E:D983  20 63 FF   			call	load_vram_x
 7392                        	
 7393                        		.dbg	line,	"include\routines_LEVELS.c", 1649; player_counter_anim = 0;
 7394                        		__st.umiq	0, _player_counter_anim
         0E:D986  9C 14 23   			stz	_player_counter_anim
 7395                        	
 7396                        		.dbg	line,	"include\routines_LEVELS.c", 1650; }
 7397                        	
 7398                        		.dbg	line,	"include\routines_LEVELS.c", 1651; }
 7399    0E:D989             	.LL314	.alias		.LL315
 7400                        	
 7401                        		.dbg	line,	"include\routines_LEVELS.c", 1654; else if(player_state == STATE_CLIMB_UP)
 7402                        		__bra		.LL315
         0E:D989  4C 39 DD   			bra	.LL315
 7403    0E:D98C             	.LL313:
 7404                        		__ld.umq	_player_state
         0E:D98C  AD 11 23   			lda	_player_state
 7405                        		__equ_b.uiq	11
         0E:D98F  C9 0B      			cmp	#11
         0E:D991  F0 01      			beq	!+
         0E:D993  18         			clc
         0E:D994             	!:
 7406                        		__bfalse	.LL316
         0E:D994  B0 03 4C 9E			bcc	.LL316
         0E:D998  DA          
 7407                        	
 7408                        		.dbg	line,	"include\routines_LEVELS.c", 1655; {
 7409                        	
 7410                        		.dbg	line,	"include\routines_LEVELS.c", 1656; if(player_counter_anim == 0)
 7411                        		__not.um	_player_counter_anim
         0E:D999  AD 14 23   			lda	_player_counter_anim
         0E:D99C  18         			clc
         0E:D99D  D0 01      			bne	!+
         0E:D99F  38         			sec
         0E:D9A0             	!:
 7412                        		__bfalse	.LL317
         0E:D9A0  90 1F      			bcc	.LL317
 7413                        	
 7414                        		.dbg	line,	"include\routines_LEVELS.c", 1657; {
 7415                        	
 7416                        		.dbg	line,	"include\routines_LEVELS.c", 1658; load_vram(PLAYER_VRAM_ADR, tiles_SPR_PLAYER + TILES_160 , TILES_16);
 7417                        		__st.wmiq	6144, _di
         0E:D9A2  64 F0      			stz.l	_di
         0E:D9A4  A9 18      			lda.h	#6144
         0E:D9A6  85 F1      			sta.h	_di
 7418                        		__farptr	_tiles_SPR_PLAYER + 5120, _bp_bank, _bp
         0E:D9A8  A9 A0      			lda.l	#$6000 + ($1FFF & (_tiles_SPR_PLAYER + 5120))
         0E:D9AA  85 EC      			sta.l	_bp
         0E:D9AC  A9 6E      			lda.h	#$6000 + ($1FFF & (_tiles_SPR_PLAYER + 5120))
         0E:D9AE  85 ED      			sta.h	_bp
         0E:D9B0  A9 0C      			lda	#bank(_tiles_SPR_PLAYER + 5120)
         0E:D9B2  85 02      			sta	_bp_bank
 7419                        		__st.wmiq	256, _ax
         0E:D9B4  64 F8      			stz.l	_ax
         0E:D9B6  A9 01      			lda.h	#256
         0E:D9B8  85 F9      			sta.h	_ax
 7420                        		 _load_vram.3
         0E:D9BA  82         			clx				; Offset to PCE VDC.
         0E:D9BB  20 63 FF   			call	load_vram_x
 7421                        	
 7422                        		.dbg	line,	"include\routines_LEVELS.c", 1659; }
 7423                        	
 7424                        		.dbg	line,	"include\routines_LEVELS.c", 1661; else if(player_counter_anim == 3)
 7425                        		__bra		.LL318
         0E:D9BE  4C 88 DA   			bra	.LL318
 7426    0E:D9C1             	.LL317:
 7427                        		__ld.umq	_player_counter_anim
         0E:D9C1  AD 14 23   			lda	_player_counter_anim
 7428                        		__equ_b.uiq	3
         0E:D9C4  C9 03      			cmp	#3
         0E:D9C6  F0 01      			beq	!+
         0E:D9C8  18         			clc
         0E:D9C9             	!:
 7429                        		__bfalse	.LL319
         0E:D9C9  90 1F      			bcc	.LL319
 7430                        	
 7431                        		.dbg	line,	"include\routines_LEVELS.c", 1662; {
 7432                        	
 7433                        		.dbg	line,	"include\routines_LEVELS.c", 1663; load_vram(PLAYER_VRAM_ADR, tiles_SPR_PLAYER + TILES_176 , TILES_16);
 7434                        		__st.wmiq	6144, _di
         0E:D9CB  64 F0      			stz.l	_di
         0E:D9CD  A9 18      			lda.h	#6144
         0E:D9CF  85 F1      			sta.h	_di
 7435                        		__farptr	_tiles_SPR_PLAYER + 5632, _bp_bank, _bp
         0E:D9D1  A9 A0      			lda.l	#$6000 + ($1FFF & (_tiles_SPR_PLAYER + 5632))
         0E:D9D3  85 EC      			sta.l	_bp
         0E:D9D5  A9 70      			lda.h	#$6000 + ($1FFF & (_tiles_SPR_PLAYER + 5632))
         0E:D9D7  85 ED      			sta.h	_bp
         0E:D9D9  A9 0C      			lda	#bank(_tiles_SPR_PLAYER + 5632)
         0E:D9DB  85 02      			sta	_bp_bank
 7436                        		__st.wmiq	256, _ax
         0E:D9DD  64 F8      			stz.l	_ax
         0E:D9DF  A9 01      			lda.h	#256
         0E:D9E1  85 F9      			sta.h	_ax
 7437                        		 _load_vram.3
         0E:D9E3  82         			clx				; Offset to PCE VDC.
         0E:D9E4  20 63 FF   			call	load_vram_x
 7438                        	
 7439                        		.dbg	line,	"include\routines_LEVELS.c", 1664; }
 7440                        	
 7441                        		.dbg	line,	"include\routines_LEVELS.c", 1666; else if(player_counter_anim == 6)
 7442                        		__bra		.LL320
         0E:D9E7  4C 88 DA   			bra	.LL320
 7443    0E:D9EA             	.LL319:
 7444                        		__ld.umq	_player_counter_anim
         0E:D9EA  AD 14 23   			lda	_player_counter_anim
 7445                        		__equ_b.uiq	6
         0E:D9ED  C9 06      			cmp	#6
         0E:D9EF  F0 01      			beq	!+
         0E:D9F1  18         			clc
         0E:D9F2             	!:
 7446                        		__bfalse	.LL321
         0E:D9F2  90 1E      			bcc	.LL321
 7447                        	
 7448                        		.dbg	line,	"include\routines_LEVELS.c", 1667; {
 7449                        	
 7450                        		.dbg	line,	"include\routines_LEVELS.c", 1668; load_vram(PLAYER_VRAM_ADR, tiles_SPR_PLAYER + TILES_192 , TILES_16);
 7451                        		__st.wmiq	6144, _di
         0E:D9F4  64 F0      			stz.l	_di
         0E:D9F6  A9 18      			lda.h	#6144
         0E:D9F8  85 F1      			sta.h	_di
 7452                        		__farptr	_tiles_SPR_PLAYER + 6144, _bp_bank, _bp
         0E:D9FA  A9 A0      			lda.l	#$6000 + ($1FFF & (_tiles_SPR_PLAYER + 6144))
         0E:D9FC  85 EC      			sta.l	_bp
         0E:D9FE  A9 72      			lda.h	#$6000 + ($1FFF & (_tiles_SPR_PLAYER + 6144))
         0E:DA00  85 ED      			sta.h	_bp
         0E:DA02  A9 0C      			lda	#bank(_tiles_SPR_PLAYER + 6144)
         0E:DA04  85 02      			sta	_bp_bank
 7453                        		__st.wmiq	256, _ax
         0E:DA06  64 F8      			stz.l	_ax
         0E:DA08  A9 01      			lda.h	#256
         0E:DA0A  85 F9      			sta.h	_ax
 7454                        		 _load_vram.3
         0E:DA0C  82         			clx				; Offset to PCE VDC.
         0E:DA0D  20 63 FF   			call	load_vram_x
 7455                        	
 7456                        		.dbg	line,	"include\routines_LEVELS.c", 1669; }
 7457                        	
 7458                        		.dbg	line,	"include\routines_LEVELS.c", 1671; else if(player_counter_anim == 9)
 7459                        		__bra		.LL322
         0E:DA10  80 76      			bra	.LL322
 7460    0E:DA12             	.LL321:
 7461                        		__ld.umq	_player_counter_anim
         0E:DA12  AD 14 23   			lda	_player_counter_anim
 7462                        		__equ_b.uiq	9
         0E:DA15  C9 09      			cmp	#9
         0E:DA17  F0 01      			beq	!+
         0E:DA19  18         			clc
         0E:DA1A             	!:
 7463                        		__bfalse	.LL323
         0E:DA1A  90 1E      			bcc	.LL323
 7464                        	
 7465                        		.dbg	line,	"include\routines_LEVELS.c", 1672; {
 7466                        	
 7467                        		.dbg	line,	"include\routines_LEVELS.c", 1673; load_vram(PLAYER_VRAM_ADR, tiles_SPR_PLAYER + TILES_208 , TILES_16);
 7468                        		__st.wmiq	6144, _di
         0E:DA1C  64 F0      			stz.l	_di
         0E:DA1E  A9 18      			lda.h	#6144
         0E:DA20  85 F1      			sta.h	_di
 7469                        		__farptr	_tiles_SPR_PLAYER + 6656, _bp_bank, _bp
         0E:DA22  A9 A0      			lda.l	#$6000 + ($1FFF & (_tiles_SPR_PLAYER + 6656))
         0E:DA24  85 EC      			sta.l	_bp
         0E:DA26  A9 74      			lda.h	#$6000 + ($1FFF & (_tiles_SPR_PLAYER + 6656))
         0E:DA28  85 ED      			sta.h	_bp
         0E:DA2A  A9 0C      			lda	#bank(_tiles_SPR_PLAYER + 6656)
         0E:DA2C  85 02      			sta	_bp_bank
 7470                        		__st.wmiq	256, _ax
         0E:DA2E  64 F8      			stz.l	_ax
         0E:DA30  A9 01      			lda.h	#256
         0E:DA32  85 F9      			sta.h	_ax
 7471                        		 _load_vram.3
         0E:DA34  82         			clx				; Offset to PCE VDC.
         0E:DA35  20 63 FF   			call	load_vram_x
 7472                        	
 7473                        		.dbg	line,	"include\routines_LEVELS.c", 1674; }
 7474                        	
 7475                        		.dbg	line,	"include\routines_LEVELS.c", 1676; else if(player_counter_anim == 12)
 7476                        		__bra		.LL324
         0E:DA38  80 4E      			bra	.LL324
 7477    0E:DA3A             	.LL323:
 7478                        		__ld.umq	_player_counter_anim
         0E:DA3A  AD 14 23   			lda	_player_counter_anim
 7479                        		__equ_b.uiq	12
         0E:DA3D  C9 0C      			cmp	#12
         0E:DA3F  F0 01      			beq	!+
         0E:DA41  18         			clc
         0E:DA42             	!:
 7480                        		__bfalse	.LL325
         0E:DA42  90 1E      			bcc	.LL325
 7481                        	
 7482                        		.dbg	line,	"include\routines_LEVELS.c", 1677; {
 7483                        	
 7484                        		.dbg	line,	"include\routines_LEVELS.c", 1678; load_vram(PLAYER_VRAM_ADR, tiles_SPR_PLAYER + TILES_192 , TILES_16);
 7485                        		__st.wmiq	6144, _di
         0E:DA44  64 F0      			stz.l	_di
         0E:DA46  A9 18      			lda.h	#6144
         0E:DA48  85 F1      			sta.h	_di
 7486                        		__farptr	_tiles_SPR_PLAYER + 6144, _bp_bank, _bp
         0E:DA4A  A9 A0      			lda.l	#$6000 + ($1FFF & (_tiles_SPR_PLAYER + 6144))
         0E:DA4C  85 EC      			sta.l	_bp
         0E:DA4E  A9 72      			lda.h	#$6000 + ($1FFF & (_tiles_SPR_PLAYER + 6144))
         0E:DA50  85 ED      			sta.h	_bp
         0E:DA52  A9 0C      			lda	#bank(_tiles_SPR_PLAYER + 6144)
         0E:DA54  85 02      			sta	_bp_bank
 7487                        		__st.wmiq	256, _ax
         0E:DA56  64 F8      			stz.l	_ax
         0E:DA58  A9 01      			lda.h	#256
         0E:DA5A  85 F9      			sta.h	_ax
 7488                        		 _load_vram.3
         0E:DA5C  82         			clx				; Offset to PCE VDC.
         0E:DA5D  20 63 FF   			call	load_vram_x
 7489                        	
 7490                        		.dbg	line,	"include\routines_LEVELS.c", 1679; }
 7491                        	
 7492                        		.dbg	line,	"include\routines_LEVELS.c", 1681; else if(player_counter_anim == 15)
 7493                        		__bra		.LL326
         0E:DA60  80 26      			bra	.LL326
 7494    0E:DA62             	.LL325:
 7495                        		__ld.umq	_player_counter_anim
         0E:DA62  AD 14 23   			lda	_player_counter_anim
 7496                        		__equ_b.uiq	15
         0E:DA65  C9 0F      			cmp	#15
         0E:DA67  F0 01      			beq	!+
         0E:DA69  18         			clc
         0E:DA6A             	!:
 7497                        		__bfalse	.LL327
         0E:DA6A  90 1C      			bcc	.LL327
 7498                        	
 7499                        		.dbg	line,	"include\routines_LEVELS.c", 1682; {
 7500                        	
 7501                        		.dbg	line,	"include\routines_LEVELS.c", 1683; load_vram(PLAYER_VRAM_ADR, tiles_SPR_PLAYER + TILES_176 , TILES_16);
 7502                        		__st.wmiq	6144, _di
         0E:DA6C  64 F0      			stz.l	_di
         0E:DA6E  A9 18      			lda.h	#6144
         0E:DA70  85 F1      			sta.h	_di
 7503                        		__farptr	_tiles_SPR_PLAYER + 5632, _bp_bank, _bp
         0E:DA72  A9 A0      			lda.l	#$6000 + ($1FFF & (_tiles_SPR_PLAYER + 5632))
         0E:DA74  85 EC      			sta.l	_bp
         0E:DA76  A9 70      			lda.h	#$6000 + ($1FFF & (_tiles_SPR_PLAYER + 5632))
         0E:DA78  85 ED      			sta.h	_bp
         0E:DA7A  A9 0C      			lda	#bank(_tiles_SPR_PLAYER + 5632)
         0E:DA7C  85 02      			sta	_bp_bank
 7504                        		__st.wmiq	256, _ax
         0E:DA7E  64 F8      			stz.l	_ax
         0E:DA80  A9 01      			lda.h	#256
         0E:DA82  85 F9      			sta.h	_ax
 7505                        		 _load_vram.3
         0E:DA84  82         			clx				; Offset to PCE VDC.
         0E:DA85  20 63 FF   			call	load_vram_x
 7506                        	
 7507                        		.dbg	line,	"include\routines_LEVELS.c", 1684; }
 7508                        	
 7509                        		.dbg	line,	"include\routines_LEVELS.c", 1687; player_counter_anim += 1;
 7510    0E:DA88             	.LL327:
 7511    0E:DA88             	.LL326:
 7512    0E:DA88             	.LL324:
 7513    0E:DA88             	.LL322:
 7514    0E:DA88             	.LL320:
 7515    0E:DA88             	.LL318:
 7516                        		__add_st.umiq	1, _player_counter_anim
         0E:DA88  EE 14 23   			inc	_player_counter_anim
 7517                        	
 7518                        		.dbg	line,	"include\routines_LEVELS.c", 1689; if(player_counter_anim == 17)
 7519                        		__ld.umq	_player_counter_anim
         0E:DA8B  AD 14 23   			lda	_player_counter_anim
 7520                        		__equ_b.uiq	17
         0E:DA8E  C9 11      			cmp	#17
         0E:DA90  F0 01      			beq	!+
         0E:DA92  18         			clc
         0E:DA93             	!:
 7521                        		__bfalse	.LL328
         0E:DA93  90 03      			bcc	.LL328
 7522                        	
 7523                        		.dbg	line,	"include\routines_LEVELS.c", 1690; {
 7524                        	
 7525                        		.dbg	line,	"include\routines_LEVELS.c", 1691; player_counter_anim = 0;
 7526                        		__st.umiq	0, _player_counter_anim
         0E:DA95  9C 14 23   			stz	_player_counter_anim
 7527                        	
 7528                        		.dbg	line,	"include\routines_LEVELS.c", 1692; }
 7529                        	
 7530                        		.dbg	line,	"include\routines_LEVELS.c", 1694; recenter_CAMERA();
 7531    0E:DA98             	.LL328:
 7532                        		__call		_recenter_CAMERA
         0E:DA98  20 59 FF   			call	_recenter_CAMERA
 7533                        	
 7534                        		.dbg	line,	"include\routines_LEVELS.c", 1695; }
 7535                        	
 7536                        		.dbg	line,	"include\routines_LEVELS.c", 1698; else if(player_state == STATE_CLIMB_DOWN)
 7537                        		__bra		.LL329
         0E:DA9B  4C 39 DD   			bra	.LL329
 7538    0E:DA9E             	.LL316:
 7539                        		__ld.umq	_player_state
         0E:DA9E  AD 11 23   			lda	_player_state
 7540                        		__equ_b.uiq	12
         0E:DAA1  C9 0C      			cmp	#12
         0E:DAA3  F0 01      			beq	!+
         0E:DAA5  18         			clc
         0E:DAA6             	!:
 7541                        		__bfalse	.LL330
         0E:DAA6  B0 03 4C B0			bcc	.LL330
         0E:DAAA  DB          
 7542                        	
 7543                        		.dbg	line,	"include\routines_LEVELS.c", 1699; {
 7544                        	
 7545                        		.dbg	line,	"include\routines_LEVELS.c", 1700; if(player_counter_anim == 0)
 7546                        		__not.um	_player_counter_anim
         0E:DAAB  AD 14 23   			lda	_player_counter_anim
         0E:DAAE  18         			clc
         0E:DAAF  D0 01      			bne	!+
         0E:DAB1  38         			sec
         0E:DAB2             	!:
 7547                        		__bfalse	.LL331
         0E:DAB2  90 1F      			bcc	.LL331
 7548                        	
 7549                        		.dbg	line,	"include\routines_LEVELS.c", 1701; {
 7550                        	
 7551                        		.dbg	line,	"include\routines_LEVELS.c", 1702; load_vram(PLAYER_VRAM_ADR, tiles_SPR_PLAYER + TILES_176 , TILES_16);
 7552                        		__st.wmiq	6144, _di
         0E:DAB4  64 F0      			stz.l	_di
         0E:DAB6  A9 18      			lda.h	#6144
         0E:DAB8  85 F1      			sta.h	_di
 7553                        		__farptr	_tiles_SPR_PLAYER + 5632, _bp_bank, _bp
         0E:DABA  A9 A0      			lda.l	#$6000 + ($1FFF & (_tiles_SPR_PLAYER + 5632))
         0E:DABC  85 EC      			sta.l	_bp
         0E:DABE  A9 70      			lda.h	#$6000 + ($1FFF & (_tiles_SPR_PLAYER + 5632))
         0E:DAC0  85 ED      			sta.h	_bp
         0E:DAC2  A9 0C      			lda	#bank(_tiles_SPR_PLAYER + 5632)
         0E:DAC4  85 02      			sta	_bp_bank
 7554                        		__st.wmiq	256, _ax
         0E:DAC6  64 F8      			stz.l	_ax
         0E:DAC8  A9 01      			lda.h	#256
         0E:DACA  85 F9      			sta.h	_ax
 7555                        		 _load_vram.3
         0E:DACC  82         			clx				; Offset to PCE VDC.
         0E:DACD  20 63 FF   			call	load_vram_x
 7556                        	
 7557                        		.dbg	line,	"include\routines_LEVELS.c", 1703; }
 7558                        	
 7559                        		.dbg	line,	"include\routines_LEVELS.c", 1705; else if(player_counter_anim == 3)
 7560                        		__bra		.LL332
         0E:DAD0  4C 9A DB   			bra	.LL332
 7561    0E:DAD3             	.LL331:
 7562                        		__ld.umq	_player_counter_anim
         0E:DAD3  AD 14 23   			lda	_player_counter_anim
 7563                        		__equ_b.uiq	3
         0E:DAD6  C9 03      			cmp	#3
         0E:DAD8  F0 01      			beq	!+
         0E:DADA  18         			clc
         0E:DADB             	!:
 7564                        		__bfalse	.LL333
         0E:DADB  90 1F      			bcc	.LL333
 7565                        	
 7566                        		.dbg	line,	"include\routines_LEVELS.c", 1706; {
 7567                        	
 7568                        		.dbg	line,	"include\routines_LEVELS.c", 1707; load_vram(PLAYER_VRAM_ADR, tiles_SPR_PLAYER + TILES_192 , TILES_16);
 7569                        		__st.wmiq	6144, _di
         0E:DADD  64 F0      			stz.l	_di
         0E:DADF  A9 18      			lda.h	#6144
         0E:DAE1  85 F1      			sta.h	_di
 7570                        		__farptr	_tiles_SPR_PLAYER + 6144, _bp_bank, _bp
         0E:DAE3  A9 A0      			lda.l	#$6000 + ($1FFF & (_tiles_SPR_PLAYER + 6144))
         0E:DAE5  85 EC      			sta.l	_bp
         0E:DAE7  A9 72      			lda.h	#$6000 + ($1FFF & (_tiles_SPR_PLAYER + 6144))
         0E:DAE9  85 ED      			sta.h	_bp
         0E:DAEB  A9 0C      			lda	#bank(_tiles_SPR_PLAYER + 6144)
         0E:DAED  85 02      			sta	_bp_bank
 7571                        		__st.wmiq	256, _ax
         0E:DAEF  64 F8      			stz.l	_ax
         0E:DAF1  A9 01      			lda.h	#256
         0E:DAF3  85 F9      			sta.h	_ax
 7572                        		 _load_vram.3
         0E:DAF5  82         			clx				; Offset to PCE VDC.
         0E:DAF6  20 63 FF   			call	load_vram_x
 7573                        	
 7574                        		.dbg	line,	"include\routines_LEVELS.c", 1708; }
 7575                        	
 7576                        		.dbg	line,	"include\routines_LEVELS.c", 1710; else if(player_counter_anim == 6)
 7577                        		__bra		.LL334
         0E:DAF9  4C 9A DB   			bra	.LL334
 7578    0E:DAFC             	.LL333:
 7579                        		__ld.umq	_player_counter_anim
         0E:DAFC  AD 14 23   			lda	_player_counter_anim
 7580                        		__equ_b.uiq	6
         0E:DAFF  C9 06      			cmp	#6
         0E:DB01  F0 01      			beq	!+
         0E:DB03  18         			clc
         0E:DB04             	!:
 7581                        		__bfalse	.LL335
         0E:DB04  90 1E      			bcc	.LL335
 7582                        	
 7583                        		.dbg	line,	"include\routines_LEVELS.c", 1711; {
 7584                        	
 7585                        		.dbg	line,	"include\routines_LEVELS.c", 1712; load_vram(PLAYER_VRAM_ADR, tiles_SPR_PLAYER + TILES_208 , TILES_16);
 7586                        		__st.wmiq	6144, _di
         0E:DB06  64 F0      			stz.l	_di
         0E:DB08  A9 18      			lda.h	#6144
         0E:DB0A  85 F1      			sta.h	_di
 7587                        		__farptr	_tiles_SPR_PLAYER + 6656, _bp_bank, _bp
         0E:DB0C  A9 A0      			lda.l	#$6000 + ($1FFF & (_tiles_SPR_PLAYER + 6656))
         0E:DB0E  85 EC      			sta.l	_bp
         0E:DB10  A9 74      			lda.h	#$6000 + ($1FFF & (_tiles_SPR_PLAYER + 6656))
         0E:DB12  85 ED      			sta.h	_bp
         0E:DB14  A9 0C      			lda	#bank(_tiles_SPR_PLAYER + 6656)
         0E:DB16  85 02      			sta	_bp_bank
 7588                        		__st.wmiq	256, _ax
         0E:DB18  64 F8      			stz.l	_ax
         0E:DB1A  A9 01      			lda.h	#256
         0E:DB1C  85 F9      			sta.h	_ax
 7589                        		 _load_vram.3
         0E:DB1E  82         			clx				; Offset to PCE VDC.
         0E:DB1F  20 63 FF   			call	load_vram_x
 7590                        	
 7591                        		.dbg	line,	"include\routines_LEVELS.c", 1713; }
 7592                        	
 7593                        		.dbg	line,	"include\routines_LEVELS.c", 1715; else if(player_counter_anim == 9)
 7594                        		__bra		.LL336
         0E:DB22  80 76      			bra	.LL336
 7595    0E:DB24             	.LL335:
 7596                        		__ld.umq	_player_counter_anim
         0E:DB24  AD 14 23   			lda	_player_counter_anim
 7597                        		__equ_b.uiq	9
         0E:DB27  C9 09      			cmp	#9
         0E:DB29  F0 01      			beq	!+
         0E:DB2B  18         			clc
         0E:DB2C             	!:
 7598                        		__bfalse	.LL337
         0E:DB2C  90 1E      			bcc	.LL337
 7599                        	
 7600                        		.dbg	line,	"include\routines_LEVELS.c", 1716; {
 7601                        	
 7602                        		.dbg	line,	"include\routines_LEVELS.c", 1717; load_vram(PLAYER_VRAM_ADR, tiles_SPR_PLAYER + TILES_192 , TILES_16);
 7603                        		__st.wmiq	6144, _di
         0E:DB2E  64 F0      			stz.l	_di
         0E:DB30  A9 18      			lda.h	#6144
         0E:DB32  85 F1      			sta.h	_di
 7604                        		__farptr	_tiles_SPR_PLAYER + 6144, _bp_bank, _bp
         0E:DB34  A9 A0      			lda.l	#$6000 + ($1FFF & (_tiles_SPR_PLAYER + 6144))
         0E:DB36  85 EC      			sta.l	_bp
         0E:DB38  A9 72      			lda.h	#$6000 + ($1FFF & (_tiles_SPR_PLAYER + 6144))
         0E:DB3A  85 ED      			sta.h	_bp
         0E:DB3C  A9 0C      			lda	#bank(_tiles_SPR_PLAYER + 6144)
         0E:DB3E  85 02      			sta	_bp_bank
 7605                        		__st.wmiq	256, _ax
         0E:DB40  64 F8      			stz.l	_ax
         0E:DB42  A9 01      			lda.h	#256
         0E:DB44  85 F9      			sta.h	_ax
 7606                        		 _load_vram.3
         0E:DB46  82         			clx				; Offset to PCE VDC.
         0E:DB47  20 63 FF   			call	load_vram_x
 7607                        	
 7608                        		.dbg	line,	"include\routines_LEVELS.c", 1718; }
 7609                        	
 7610                        		.dbg	line,	"include\routines_LEVELS.c", 1720; else if(player_counter_anim == 12)
 7611                        		__bra		.LL338
         0E:DB4A  80 4E      			bra	.LL338
 7612    0E:DB4C             	.LL337:
 7613                        		__ld.umq	_player_counter_anim
         0E:DB4C  AD 14 23   			lda	_player_counter_anim
 7614                        		__equ_b.uiq	12
         0E:DB4F  C9 0C      			cmp	#12
         0E:DB51  F0 01      			beq	!+
         0E:DB53  18         			clc
         0E:DB54             	!:
 7615                        		__bfalse	.LL339
         0E:DB54  90 1E      			bcc	.LL339
 7616                        	
 7617                        		.dbg	line,	"include\routines_LEVELS.c", 1721; {
 7618                        	
 7619                        		.dbg	line,	"include\routines_LEVELS.c", 1722; load_vram(PLAYER_VRAM_ADR, tiles_SPR_PLAYER + TILES_176 , TILES_16);
 7620                        		__st.wmiq	6144, _di
         0E:DB56  64 F0      			stz.l	_di
         0E:DB58  A9 18      			lda.h	#6144
         0E:DB5A  85 F1      			sta.h	_di
 7621                        		__farptr	_tiles_SPR_PLAYER + 5632, _bp_bank, _bp
         0E:DB5C  A9 A0      			lda.l	#$6000 + ($1FFF & (_tiles_SPR_PLAYER + 5632))
         0E:DB5E  85 EC      			sta.l	_bp
         0E:DB60  A9 70      			lda.h	#$6000 + ($1FFF & (_tiles_SPR_PLAYER + 5632))
         0E:DB62  85 ED      			sta.h	_bp
         0E:DB64  A9 0C      			lda	#bank(_tiles_SPR_PLAYER + 5632)
         0E:DB66  85 02      			sta	_bp_bank
 7622                        		__st.wmiq	256, _ax
         0E:DB68  64 F8      			stz.l	_ax
         0E:DB6A  A9 01      			lda.h	#256
         0E:DB6C  85 F9      			sta.h	_ax
 7623                        		 _load_vram.3
         0E:DB6E  82         			clx				; Offset to PCE VDC.
         0E:DB6F  20 63 FF   			call	load_vram_x
 7624                        	
 7625                        		.dbg	line,	"include\routines_LEVELS.c", 1723; }
 7626                        	
 7627                        		.dbg	line,	"include\routines_LEVELS.c", 1725; else if(player_counter_anim == 15)
 7628                        		__bra		.LL340
         0E:DB72  80 26      			bra	.LL340
 7629    0E:DB74             	.LL339:
 7630                        		__ld.umq	_player_counter_anim
         0E:DB74  AD 14 23   			lda	_player_counter_anim
 7631                        		__equ_b.uiq	15
         0E:DB77  C9 0F      			cmp	#15
         0E:DB79  F0 01      			beq	!+
         0E:DB7B  18         			clc
         0E:DB7C             	!:
 7632                        		__bfalse	.LL341
         0E:DB7C  90 1C      			bcc	.LL341
 7633                        	
 7634                        		.dbg	line,	"include\routines_LEVELS.c", 1726; {
 7635                        	
 7636                        		.dbg	line,	"include\routines_LEVELS.c", 1727; load_vram(PLAYER_VRAM_ADR, tiles_SPR_PLAYER + TILES_160 , TILES_16);
 7637                        		__st.wmiq	6144, _di
         0E:DB7E  64 F0      			stz.l	_di
         0E:DB80  A9 18      			lda.h	#6144
         0E:DB82  85 F1      			sta.h	_di
 7638                        		__farptr	_tiles_SPR_PLAYER + 5120, _bp_bank, _bp
         0E:DB84  A9 A0      			lda.l	#$6000 + ($1FFF & (_tiles_SPR_PLAYER + 5120))
         0E:DB86  85 EC      			sta.l	_bp
         0E:DB88  A9 6E      			lda.h	#$6000 + ($1FFF & (_tiles_SPR_PLAYER + 5120))
         0E:DB8A  85 ED      			sta.h	_bp
         0E:DB8C  A9 0C      			lda	#bank(_tiles_SPR_PLAYER + 5120)
         0E:DB8E  85 02      			sta	_bp_bank
 7639                        		__st.wmiq	256, _ax
         0E:DB90  64 F8      			stz.l	_ax
         0E:DB92  A9 01      			lda.h	#256
         0E:DB94  85 F9      			sta.h	_ax
 7640                        		 _load_vram.3
         0E:DB96  82         			clx				; Offset to PCE VDC.
         0E:DB97  20 63 FF   			call	load_vram_x
 7641                        	
 7642                        		.dbg	line,	"include\routines_LEVELS.c", 1728; }
 7643                        	
 7644                        		.dbg	line,	"include\routines_LEVELS.c", 1731; player_counter_anim += 1;
 7645    0E:DB9A             	.LL341:
 7646    0E:DB9A             	.LL340:
 7647    0E:DB9A             	.LL338:
 7648    0E:DB9A             	.LL336:
 7649    0E:DB9A             	.LL334:
 7650    0E:DB9A             	.LL332:
 7651                        		__add_st.umiq	1, _player_counter_anim
         0E:DB9A  EE 14 23   			inc	_player_counter_anim
 7652                        	
 7653                        		.dbg	line,	"include\routines_LEVELS.c", 1733; if(player_counter_anim == 17)
 7654                        		__ld.umq	_player_counter_anim
         0E:DB9D  AD 14 23   			lda	_player_counter_anim
 7655                        		__equ_b.uiq	17
         0E:DBA0  C9 11      			cmp	#17
         0E:DBA2  F0 01      			beq	!+
         0E:DBA4  18         			clc
         0E:DBA5             	!:
 7656                        		__bfalse	.LL342
         0E:DBA5  90 03      			bcc	.LL342
 7657                        	
 7658                        		.dbg	line,	"include\routines_LEVELS.c", 1734; {
 7659                        	
 7660                        		.dbg	line,	"include\routines_LEVELS.c", 1735; player_counter_anim = 0;
 7661                        		__st.umiq	0, _player_counter_anim
         0E:DBA7  9C 14 23   			stz	_player_counter_anim
 7662                        	
 7663                        		.dbg	line,	"include\routines_LEVELS.c", 1736; }
 7664                        	
 7665                        		.dbg	line,	"include\routines_LEVELS.c", 1738; recenter_CAMERA();
 7666    0E:DBAA             	.LL342:
 7667                        		__call		_recenter_CAMERA
         0E:DBAA  20 59 FF   			call	_recenter_CAMERA
 7668                        	
 7669                        		.dbg	line,	"include\routines_LEVELS.c", 1739; }
 7670                        	
 7671                        		.dbg	line,	"include\routines_LEVELS.c", 1742; else if(player_state == STATE_JUMP_LADDER)
 7672                        		__bra		.LL343
         0E:DBAD  4C 39 DD   			bra	.LL343
 7673    0E:DBB0             	.LL330:
 7674                        		__ld.umq	_player_state
         0E:DBB0  AD 11 23   			lda	_player_state
 7675                        		__equ_b.uiq	13
         0E:DBB3  C9 0D      			cmp	#13
         0E:DBB5  F0 01      			beq	!+
         0E:DBB7  18         			clc
         0E:DBB8             	!:
 7676                        		__bfalse	.LL344
         0E:DBB8  B0 03 4C 39			bcc	.LL344
         0E:DBBC  DD          
 7677                        	
 7678                        		.dbg	line,	"include\routines_LEVELS.c", 1743; {
 7679                        	
 7680                        		.dbg	line,	"include\routines_LEVELS.c", 1744; unsigned char i;
 7681                        	
 7682                        		.dbg	line,	"include\routines_LEVELS.c", 1745; i = 1;
 7683                        		__st.umiq	1, __update_PLAYER_end - 8  /* i */
         0E:DBBD  A9 01      			lda.l	#1
         0E:DBBF  8D 05 23   			sta	__update_PLAYER_end - 8
 7684                        	
 7685                        		.dbg	line,	"include\routines_LEVELS.c", 1748; if(player_counter_anim == 0)
 7686                        		__not.um	_player_counter_anim
         0E:DBC2  AD 14 23   			lda	_player_counter_anim
         0E:DBC5  18         			clc
         0E:DBC6  D0 01      			bne	!+
         0E:DBC8  38         			sec
         0E:DBC9             	!:
 7687                        		__bfalse	.LL345
         0E:DBC9  90 21      			bcc	.LL345
 7688                        	
 7689                        		.dbg	line,	"include\routines_LEVELS.c", 1749; {
 7690                        	
 7691                        		.dbg	line,	"include\routines_LEVELS.c", 1750; load_vram(PLAYER_VRAM_ADR, tiles_SPR_PLAYER + TILES_112 , TILES_16);
 7692                        		__st.wmiq	6144, _di
         0E:DBCB  64 F0      			stz.l	_di
         0E:DBCD  A9 18      			lda.h	#6144
         0E:DBCF  85 F1      			sta.h	_di
 7693                        		__farptr	_tiles_SPR_PLAYER + 3584, _bp_bank, _bp
         0E:DBD1  A9 A0      			lda.l	#$6000 + ($1FFF & (_tiles_SPR_PLAYER + 3584))
         0E:DBD3  85 EC      			sta.l	_bp
         0E:DBD5  A9 68      			lda.h	#$6000 + ($1FFF & (_tiles_SPR_PLAYER + 3584))
         0E:DBD7  85 ED      			sta.h	_bp
         0E:DBD9  A9 0C      			lda	#bank(_tiles_SPR_PLAYER + 3584)
         0E:DBDB  85 02      			sta	_bp_bank
 7694                        		__st.wmiq	256, _ax
         0E:DBDD  64 F8      			stz.l	_ax
         0E:DBDF  A9 01      			lda.h	#256
         0E:DBE1  85 F9      			sta.h	_ax
 7695                        		 _load_vram.3
         0E:DBE3  82         			clx				; Offset to PCE VDC.
         0E:DBE4  20 63 FF   			call	load_vram_x
 7696                        	
 7697                        		.dbg	line,	"include\routines_LEVELS.c", 1752; player_counter_anim = 1;
 7698                        		__st.umiq	1, _player_counter_anim
         0E:DBE7  A9 01      			lda.l	#1
         0E:DBE9  8D 14 23   			sta	_player_counter_anim
 7699                        	
 7700                        		.dbg	line,	"include\routines_LEVELS.c", 1753; }
 7701                        	
 7702                        		.dbg	line,	"include\routines_LEVELS.c", 1756; player_pos_y += TABLE_PLAYER_JUMP_V[player_index_jump];
 7703    0E:DBEC             	.LL345:
 7704                        		__ldx.umq	_player_index_jump
         0E:DBEC  AE 15 23   			ldx	_player_index_jump
 7705                        		__ld.bax	_TABLE_PLAYER_JUMP_V
         0E:DBEF  BD A0 60   			lda	_TABLE_PLAYER_JUMP_V, x
         0E:DBF2  C2         			cly
         0E:DBF3  10 01      			bpl	!+
         0E:DBF5  88         			dey
         0E:DBF6             	!:
 7706                        		__add_st.wmq	_player_pos_y
         0E:DBF6  18         			clc
         0E:DBF7  6D B9 23   			adc.l	_player_pos_y
         0E:DBFA  8D B9 23   			sta.l	_player_pos_y
         0E:DBFD  98         			tya
         0E:DBFE  6D BA 23   			adc.h	_player_pos_y
         0E:DC01  8D BA 23   			sta.h	_player_pos_y
 7707                        	
 7708                        		.dbg	line,	"include\routines_LEVELS.c", 1758; // CHECK COLLISION WITH CEILING //
 7709                        	
 7710                        		.dbg	line,	"include\routines_LEVELS.c", 1759; check_BG( 15 , 8 );
 7711                        		__ld.wi		15
         0E:DC04  A9 0F      			lda.l	#15
         0E:DC06  C2         			cly
 7712                        		__pusharg.wr
         0E:DC07  A6 8D      			ldx	<__sp
         0E:DC09  CA         			dex
         0E:DC0A  CA         			dex
         0E:DC0B  95 08      			sta.l	<__stack, x
         0E:DC0D  94 09      			sty.h	<__stack, x
         0E:DC0F  86 8D      			stx	<__sp
 7713                        		__ld.wi		8
         0E:DC11  A9 08      			lda.l	#8
         0E:DC13  C2         			cly
 7714                        		__pusharg.wr
         0E:DC14  A6 8D      			ldx	<__sp
         0E:DC16  CA         			dex
         0E:DC17  CA         			dex
         0E:DC18  95 08      			sta.l	<__stack, x
         0E:DC1A  94 09      			sty.h	<__stack, x
         0E:DC1C  86 8D      			stx	<__sp
 7715                        		__call		_check_BG
         0E:DC1E  20 6D FF   			call	_check_BG
 7716                        	
 7717                        		.dbg	line,	"include\routines_LEVELS.c", 1761; if(map_blk_flag == TILE_BG)
 7718                        		__ld.umq	_map_blk_flag
         0E:DC21  AD 76 2A   			lda	_map_blk_flag
 7719                        		__equ_b.uiq	1
         0E:DC24  C9 01      			cmp	#1
         0E:DC26  F0 01      			beq	!+
         0E:DC28  18         			clc
         0E:DC29             	!:
 7720                        		__bfalse	.LL346
         0E:DC29  90 5A      			bcc	.LL346
 7721                        	
 7722                        		.dbg	line,	"include\routines_LEVELS.c", 1762; {
 7723                        	
 7724                        		.dbg	line,	"include\routines_LEVELS.c", 1763; for(i=1 ; i<8 ; i++)
 7725                        		__st.umiq	1, __update_PLAYER_end - 8  /* i */
         0E:DC2B  A9 01      			lda.l	#1
         0E:DC2D  8D 05 23   			sta	__update_PLAYER_end - 8
 7726    0E:DC30             	.LL347:
 7727                        		__ld.umq	__update_PLAYER_end - 8  /* i */
         0E:DC30  AD 05 23   			lda	__update_PLAYER_end - 8
 7728                        		__ult_b.uiq	8
         0E:DC33  C9 08      			cmp	#8		; Subtract integer from A.
         0E:DC35  6A         			ror	a		; CC if A < integer.
         0E:DC36  49 80      			eor	#$80
         0E:DC38  2A         			rol	a
 7729                        		__btrue		.LL349
         0E:DC39  B0 07      			bcs	.LL349
 7730                        		__bra		.LL350
         0E:DC3B  80 48      			bra	.LL350
 7731    0E:DC3D             	.LL348:
 7732                        		__inc.umq	__update_PLAYER_end - 8  /* i */
         0E:DC3D  EE 05 23   			inc	__update_PLAYER_end - 8
 7733                        		__bra		.LL347
         0E:DC40  80 EE      			bra	.LL347
 7734    0E:DC42             	.LL349:
 7735                        	
 7736                        		.dbg	line,	"include\routines_LEVELS.c", 1764; {
 7737                        	
 7738                        		.dbg	line,	"include\routines_LEVELS.c", 1765; check_BG( 15 , 8 + i );
 7739                        		__ld.wi		15
         0E:DC42  A9 0F      			lda.l	#15
         0E:DC44  C2         			cly
 7740                        		__pusharg.wr
         0E:DC45  A6 8D      			ldx	<__sp
         0E:DC47  CA         			dex
         0E:DC48  CA         			dex
         0E:DC49  95 08      			sta.l	<__stack, x
         0E:DC4B  94 09      			sty.h	<__stack, x
         0E:DC4D  86 8D      			stx	<__sp
 7741                        		__ld.wi		8
         0E:DC4F  A9 08      			lda.l	#8
         0E:DC51  C2         			cly
 7742                        		__add.um	__update_PLAYER_end - 8  /* i */
         0E:DC52  18         			clc
         0E:DC53  6D 05 23   			adc	__update_PLAYER_end - 8
         0E:DC56  90 01      			bcc	!+
         0E:DC58  C8         			iny
         0E:DC59             	!:
 7743                        		__pusharg.wr
         0E:DC59  A6 8D      			ldx	<__sp
         0E:DC5B  CA         			dex
         0E:DC5C  CA         			dex
         0E:DC5D  95 08      			sta.l	<__stack, x
         0E:DC5F  94 09      			sty.h	<__stack, x
         0E:DC61  86 8D      			stx	<__sp
 7744                        		__call		_check_BG
         0E:DC63  20 6D FF   			call	_check_BG
 7745                        	
 7746                        		.dbg	line,	"include\routines_LEVELS.c", 1766; {
 7747                        	
 7748                        		.dbg	line,	"include\routines_LEVELS.c", 1767; if(map_blk_flag == TILE_EMPTY)
 7749                        		__not.um	_map_blk_flag
         0E:DC66  AD 76 2A   			lda	_map_blk_flag
         0E:DC69  18         			clc
         0E:DC6A  D0 01      			bne	!+
         0E:DC6C  38         			sec
         0E:DC6D             	!:
 7750                        		__bfalse	.LL351
         0E:DC6D  90 CE      			bcc	.LL351
 7751                        	
 7752                        		.dbg	line,	"include\routines_LEVELS.c", 1768; {
 7753                        	
 7754                        		.dbg	line,	"include\routines_LEVELS.c", 1769; player_pos_y += i;
 7755                        		__ld.um		__update_PLAYER_end - 8  /* i */
         0E:DC6F  AD 05 23   			lda	__update_PLAYER_end - 8
         0E:DC72  C2         			cly
 7756                        		__add_st.wmq	_player_pos_y
         0E:DC73  18         			clc
         0E:DC74  6D B9 23   			adc.l	_player_pos_y
         0E:DC77  8D B9 23   			sta.l	_player_pos_y
         0E:DC7A  98         			tya
         0E:DC7B  6D BA 23   			adc.h	_player_pos_y
         0E:DC7E  8D BA 23   			sta.h	_player_pos_y
 7757                        	
 7758                        		.dbg	line,	"include\routines_LEVELS.c", 1770; break;
 7759                        		__bra		.LL350
         0E:DC81  80 02      			bra	.LL350
 7760                        	
 7761                        		.dbg	line,	"include\routines_LEVELS.c", 1771; }
 7762                        	
 7763                        		.dbg	line,	"include\routines_LEVELS.c", 1772; }
 7764    0E:DC83             	.LL351	.alias		.LL348
 7765                        	
 7766                        		.dbg	line,	"include\routines_LEVELS.c", 1773; }
 7767                        		__bra		.LL348
         0E:DC83  80 B8      			bra	.LL348
 7768    0E:DC85             	.LL350:
 7769                        	
 7770                        		.dbg	line,	"include\routines_LEVELS.c", 1774; }
 7771                        	
 7772                        		.dbg	line,	"include\routines_LEVELS.c", 1776; spr_set(player_id);
 7773    0E:DC85             	.LL346:
 7774                        		__ld.umq	_player_id
         0E:DC85  AD 10 23   			lda	_player_id
 7775                        		__call		_spr_set.1
         0E:DC88  20 DD E7   			call	_spr_set.1
 7776                        	
 7777                        		.dbg	line,	"include\routines_LEVELS.c", 1777; spr_y(player_pos_y);
 7778                        		__ld.wm		_player_pos_y
         0E:DC8B  AD B9 23   			lda.l	_player_pos_y
         0E:DC8E  AC BA 23   			ldy.h	_player_pos_y
 7779                        		__call		_spr_y.1
         0E:DC91  20 19 E8   			call	_spr_y.1
 7780                        	
 7781                        		.dbg	line,	"include\routines_LEVELS.c", 1781; if(player_index_jump < 34)
 7782                        		__ld.umq	_player_index_jump
         0E:DC94  AD 15 23   			lda	_player_index_jump
 7783                        		__ult_b.uiq	34
         0E:DC97  C9 22      			cmp	#34		; Subtract integer from A.
         0E:DC99  6A         			ror	a		; CC if A < integer.
         0E:DC9A  49 80      			eor	#$80
         0E:DC9C  2A         			rol	a
 7784                        		__bfalse	.LL352
         0E:DC9D  90 03      			bcc	.LL352
 7785                        	
 7786                        		.dbg	line,	"include\routines_LEVELS.c", 1782; {
 7787                        	
 7788                        		.dbg	line,	"include\routines_LEVELS.c", 1783; player_index_jump += 1;
 7789                        		__add_st.umiq	1, _player_index_jump
         0E:DC9F  EE 15 23   			inc	_player_index_jump
 7790                        	
 7791                        		.dbg	line,	"include\routines_LEVELS.c", 1784; }
 7792                        	
 7793                        		.dbg	line,	"include\routines_LEVELS.c", 1789; //--------------------------------------------------------------------------------------//
 7794                        	
 7795                        		.dbg	line,	"include\routines_LEVELS.c", 1790; //                                   LADDER COLLISION                                   //
 7796                        	
 7797                        		.dbg	line,	"include\routines_LEVELS.c", 1791; //--------------------------------------------------------------------------------------//
 7798                        	
 7799                        		.dbg	line,	"include\routines_LEVELS.c", 1793; if(player_index_jump > 18)
 7800    0E:DCA2             	.LL352:
 7801                        		__ld.umq	_player_index_jump
         0E:DCA2  AD 15 23   			lda	_player_index_jump
 7802                        		__ugt_b.uiq	18
         0E:DCA5  18         			clc			; Subtract integer+1 from A.
         0E:DCA6  E9 12      			sbc	#18		; CS if A > integer.
 7803                        		__bfalse	.LL353
         0E:DCA8  B0 03 4C 39			bcc	.LL353
         0E:DCAC  DD          
 7804                        	
 7805                        		.dbg	line,	"include\routines_LEVELS.c", 1794; {
 7806                        	
 7807                        		.dbg	line,	"include\routines_LEVELS.c", 1795; // CHECK COLLISION WITH LADDERS //
 7808                        	
 7809                        		.dbg	line,	"include\routines_LEVELS.c", 1796; check_BG( 16 , 8 );
 7810                        		__ld.wi		16
         0E:DCAD  A9 10      			lda.l	#16
         0E:DCAF  C2         			cly
 7811                        		__pusharg.wr
         0E:DCB0  A6 8D      			ldx	<__sp
         0E:DCB2  CA         			dex
         0E:DCB3  CA         			dex
         0E:DCB4  95 08      			sta.l	<__stack, x
         0E:DCB6  94 09      			sty.h	<__stack, x
         0E:DCB8  86 8D      			stx	<__sp
 7812                        		__ld.wi		8
         0E:DCBA  A9 08      			lda.l	#8
         0E:DCBC  C2         			cly
 7813                        		__pusharg.wr
         0E:DCBD  A6 8D      			ldx	<__sp
         0E:DCBF  CA         			dex
         0E:DCC0  CA         			dex
         0E:DCC1  95 08      			sta.l	<__stack, x
         0E:DCC3  94 09      			sty.h	<__stack, x
         0E:DCC5  86 8D      			stx	<__sp
 7814                        		__call		_check_BG
         0E:DCC7  20 6D FF   			call	_check_BG
 7815                        	
 7816                        		.dbg	line,	"include\routines_LEVELS.c", 1798; // IF PLAYER HITS THE LADDER //
 7817                        	
 7818                        		.dbg	line,	"include\routines_LEVELS.c", 1799; if(map_blk_flag == TILE_LADDER)
 7819                        		__ld.umq	_map_blk_flag
         0E:DCCA  AD 76 2A   			lda	_map_blk_flag
 7820                        		__equ_b.uiq	2
         0E:DCCD  C9 02      			cmp	#2
         0E:DCCF  F0 01      			beq	!+
         0E:DCD1  18         			clc
         0E:DCD2             	!:
 7821                        		__bfalse	.LL354
         0E:DCD2  90 65      			bcc	.LL354
 7822                        	
 7823                        		.dbg	line,	"include\routines_LEVELS.c", 1800; {
 7824                        	
 7825                        		.dbg	line,	"include\routines_LEVELS.c", 1801; // CAMERA GOES 8 PX BACKWARD //
 7826                        	
 7827                        		.dbg	line,	"include\routines_LEVELS.c", 1802; sgx_map_pxl_x = ( (sgx_map_pxl_x >> 3) << 3 );
 7828                        		__ld.wm		_sgx_map_pxl_x
         0E:DCD4  AD 55 25   			lda.l	_sgx_map_pxl_x
         0E:DCD7  AC 56 25   			ldy.h	_sgx_map_pxl_x
 7829                        		__lsr.wi	3
         0E:DCDA  84 00      			sty	__temp
         0E:DCDC  20 3A E2   			jsr	lsrw3
 7830                        		__asl.wi	3
         0E:DCDF  84 00      			sty	__temp
         0E:DCE1  20 D7 E1   			jsr	aslw3
 7831                        		__st.wmq	_sgx_map_pxl_x
         0E:DCE4  8D 55 25   			sta.l	_sgx_map_pxl_x
         0E:DCE7  8C 56 25   			sty.h	_sgx_map_pxl_x
 7832                        	
 7833                        		.dbg	line,	"include\routines_LEVELS.c", 1804; // SO WE UPDATE THE MAP //
 7834                        	
 7835                        		.dbg	line,	"include\routines_LEVELS.c", 1805; sgx_scroll_map();
 7836                        		__call		_sgx_scroll_map
         0E:DCEA  20 81 FF   			call	_sgx_scroll_map
 7837                        	
 7838                        		.dbg	line,	"include\routines_LEVELS.c", 1807; // CHECK IF THE PLAYER STANDS RIGHT TO THE LADDER //
 7839                        	
 7840                        		.dbg	line,	"include\routines_LEVELS.c", 1808; check_BG( 31 , 8 );
 7841                        		__ld.wi		31
         0E:DCED  A9 1F      			lda.l	#31
         0E:DCEF  C2         			cly
 7842                        		__pusharg.wr
         0E:DCF0  A6 8D      			ldx	<__sp
         0E:DCF2  CA         			dex
         0E:DCF3  CA         			dex
         0E:DCF4  95 08      			sta.l	<__stack, x
         0E:DCF6  94 09      			sty.h	<__stack, x
         0E:DCF8  86 8D      			stx	<__sp
 7843                        		__ld.wi		8
         0E:DCFA  A9 08      			lda.l	#8
         0E:DCFC  C2         			cly
 7844                        		__pusharg.wr
         0E:DCFD  A6 8D      			ldx	<__sp
         0E:DCFF  CA         			dex
         0E:DD00  CA         			dex
         0E:DD01  95 08      			sta.l	<__stack, x
         0E:DD03  94 09      			sty.h	<__stack, x
         0E:DD05  86 8D      			stx	<__sp
 7845                        		__call		_check_BG
         0E:DD07  20 6D FF   			call	_check_BG
 7846                        	
 7847                        		.dbg	line,	"include\routines_LEVELS.c", 1810; if(map_blk_flag == TILE_LADDER)
 7848                        		__ld.umq	_map_blk_flag
         0E:DD0A  AD 76 2A   			lda	_map_blk_flag
 7849                        		__equ_b.uiq	2
         0E:DD0D  C9 02      			cmp	#2
         0E:DD0F  F0 01      			beq	!+
         0E:DD11  18         			clc
         0E:DD12             	!:
 7850                        		__bfalse	.LL355
         0E:DD12  90 0E      			bcc	.LL355
 7851                        	
 7852                        		.dbg	line,	"include\routines_LEVELS.c", 1811; {
 7853                        	
 7854                        		.dbg	line,	"include\routines_LEVELS.c", 1812; sgx_map_pxl_x += 8;
 7855                        		__add_st.wmiq	8, _sgx_map_pxl_x
         0E:DD14  18         			clc
         0E:DD15  AD 55 25   			lda.l	_sgx_map_pxl_x
         0E:DD18  69 08      			adc.l	#8
         0E:DD1A  8D 55 25   			sta.l	_sgx_map_pxl_x
         0E:DD1D  90 03      			bcc	!+
         0E:DD1F  EE 56 25   			inc.h	_sgx_map_pxl_x
         0E:DD22             	!:
 7856                        	
 7857                        		.dbg	line,	"include\routines_LEVELS.c", 1813; }
 7858                        	
 7859                        		.dbg	line,	"include\routines_LEVELS.c", 1815; player_counter_anim = 1;
 7860    0E:DD22             	.LL355:
 7861                        		__st.umiq	1, _player_counter_anim
         0E:DD22  A9 01      			lda.l	#1
         0E:DD24  8D 14 23   			sta	_player_counter_anim
 7862                        	
 7863                        		.dbg	line,	"include\routines_LEVELS.c", 1816; player_index_jump = 0;
 7864                        		__st.umiq	0, _player_index_jump
         0E:DD27  9C 15 23   			stz	_player_index_jump
 7865                        	
 7866                        		.dbg	line,	"include\routines_LEVELS.c", 1817; jump_ladder = TRUE;
 7867                        		__st.umiq	1, _jump_ladder
         0E:DD2A  A9 01      			lda.l	#1
         0E:DD2C  8D 17 23   			sta	_jump_ladder
 7868                        	
 7869                        		.dbg	line,	"include\routines_LEVELS.c", 1818; jump_max_index = 29;
 7870                        		__st.umiq	29, _jump_max_index
         0E:DD2F  A9 1D      			lda.l	#29
         0E:DD31  8D 18 23   			sta	_jump_max_index
 7871                        	
 7872                        		.dbg	line,	"include\routines_LEVELS.c", 1819; player_state = STATE_HANG;
 7873                        		__st.umiq	10, _player_state
         0E:DD34  A9 0A      			lda.l	#10
         0E:DD36  8D 11 23   			sta	_player_state
 7874                        	
 7875                        		.dbg	line,	"include\routines_LEVELS.c", 1820; }
 7876                        	
 7877                        		.dbg	line,	"include\routines_LEVELS.c", 1821; }
 7878    0E:DD39             	.LL354:
 7879                        	
 7880                        		.dbg	line,	"include\routines_LEVELS.c", 1822; }
 7881    0E:DD39             	.LL353:
 7882                        	
 7883                        		.dbg	line,	"include\routines_LEVELS.c", 1824; }
 7884    0E:DD39             	.LL344:
 7885    0E:DD39             	.LL343:
 7886    0E:DD39             	.LL329:
 7887    0E:DD39             	.LL315:
 7888    0E:DD39             	.LL312:
 7889    0E:DD39             	.LL297:
 7890    0E:DD39             	.LL294:
 7891    0E:DD39             	.LL257:
 7892    0E:DD39             	.LL220:
 7893    0E:DD39             	.LL194:
 7894    0E:DD39             	.LL163:
 7895    0E:DD39             	.LL158:
 7896                        		__return	0
         0E:DD39  4C EF FF   			jmp	leave_proc
 7897                        		.dbg	clear
 7898                        		.endp
 7899               6820     		.data
 7900               2305     		.bss
 7901    F8:2305             	__update_PLAYER_loc:
 7902    F8:2305             			ds	8
 7903    F8:230D             	__update_PLAYER_end:
 7904               E309     		.code
 7905                        		.pceas
 7906                        	
 7907                        		.dbg	line,	"main.c", 24; #include "include/init.c"
 7908                        		.dbg	line,	"include\init.c", 1; #include "huc.h"
 7909                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 1; #ifndef _hucc_legacy_h
 7910                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 2; #define _hucc_legacy_h
 7911                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 4; /****************************************************************************
 7912                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 5; ; ***************************************************************************
 7913                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 6; ;
 7914                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 7; ; huc.h
 7915                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 8; ;
 7916                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 9; ; HuCC wrapper file to include a default set of HuC-compatible functions.
 7917                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 10; ;
 7918                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 11; ; Copyright John Brandwood 2024.
 7919                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 12; ;
 7920                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 13; ; Distributed under the Boost Software License, Version 1.0.
 7921                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 14; ; (See accompanying file LICENSE_1_0.txt or copy at
 7922                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 15; ;  http://www.boost.org/LICENSE_1_0.txt)
 7923                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 16; ;
 7924                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 17; ; ***************************************************************************
 7925                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 18; ; ***************************************************************************
 7926                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 19; ;
 7927                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 20; ; When the HuCC compiler is invoked with the "--legacy" option to compile old
 7928                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 21; ; projects, then this "huc.h" file is automatically included.
 7929                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 22; ;
 7930                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 23; ; This file includes a set of the individual HuCC headers which correspond to
 7931                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 24; ; HuC's built-in functions and MagicKit library.
 7932                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 25; ;
 7933                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 26; ; New HuCC projects should, preferably, include the specific headers that are
 7934                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 27; ; needed, which will then allow them to replace parts of the standard library
 7935                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 28; ; with newer functions, or they can just manually include this "huc.h" file.
 7936                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 29; ;
 7937                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 30; ; ***************************************************************************
 7938                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 31; ; **************************************************************************/
 7939                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 33; #include "hucc-systemcard.h"
 7940                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 34; #include "hucc-baselib.h"
 7941                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 35; #include "hucc-gfx.h"
 7942                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 36; #include "hucc-string.h"
 7943                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 37; #include "hucc-old-scroll.h"
 7944                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 38; #include "hucc-old-spr.h"
 7945                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 39; #include "hucc-old-map.h"
 7946                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 40; #include "hucc-old-line.h"
 7947                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 42; #endif // _hucc_legacy_h
 7948                        		.dbg	line,	"include\init.c", 2; #include "hucc-scroll.h"
 7949                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 1; #ifndef _hucc_scroll_h
 7950                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 2; #define _hucc_scroll_h
 7951                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 4; /****************************************************************************
 7952                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 5; ; ***************************************************************************
 7953                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 6; ;
 7954                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 7; ; hucc-scroll.h
 7955                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 8; ;
 7956                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 9; ; Routines for a fast split-screen scrolling system.
 7957                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 10; ;
 7958                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 11; ; Copyright John Brandwood 2024.
 7959                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 12; ;
 7960                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 13; ; Distributed under the Boost Software License, Version 1.0.
 7961                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 14; ; (See accompanying file LICENSE_1_0.txt or copy at
 7962                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 15; ;  http://www.boost.org/LICENSE_1_0.txt)
 7963                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 16; ;
 7964                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 17; ; ***************************************************************************
 7965                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 18; ; ***************************************************************************
 7966                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 19; ;
 7967                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 20; ; The maximum number of splits for each screen layer is set in your project's
 7968                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 21; ; "hucc-config.inc" file, with the library having a limit of 128-per-layer.
 7969                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 22; ;
 7970                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 23; ; Your first active split must be defined to start at screen line 0, and then
 7971                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 24; ; the rest of the active splits must be in increasing line order to match the
 7972                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 25; ; way that the PC Engine displays the output image.
 7973                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 26; ;
 7974                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 27; ; You can have disabled splits interleaved with your active splits.
 7975                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 28; ;
 7976                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 29; ; Splits that are normally disabled can be used to create full screen effects
 7977                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 30; ; such as bouncing the screen up and down by adding blank areas at the top or
 7978                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 31; ; bottom of the screen, and then rapidly changing the height of those areas.
 7979                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 32; ;
 7980                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 33; ; ***************************************************************************
 7981                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 34; ; **************************************************************************/
 7982                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 36; // *************
 7983                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 37; // VDC bits for display_flags ...
 7984                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 38; // *************
 7985                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 40; #ifndef BKG_OFF
 7986                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 41; #define BKG_OFF 0x00
 7987                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 42; #endif
 7988                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 44; #ifndef SPR_OFF
 7989                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 45; #define SPR_OFF 0x00
 7990                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 46; #endif
 7991                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 48; #ifndef BKG_ON
 7992                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 49; #define BKG_ON 0x80
 7993                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 50; #endif
 7994                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 52; #ifndef SPR_ON
 7995                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 53; #define SPR_ON 0x40
 7996                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 54; #endif
 7997                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 56; // *************
 7998                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 57; // Functions in hucc-scroll.asm ...
 7999                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 58; // *************
 8000                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 60; #ifdef __HUCC__
 8001                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 62; #asmdef	HUCC_USES_NEW_SCROLL 1
 8002                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 64; extern void __fastcall scroll_split( unsigned char index<_al>, unsigned char screen_line<_ah>, unsigned int bat_x<_bx>, unsigned int bat_y<_cx>, unsigned char display_flags<_dl> );
 8003                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 65; extern void __fastcall sgx_scroll_split( unsigned char index<_al>, unsigned char screen_line<_ah>, unsigned int bat_x<_bx>, unsigned int bat_y<_cx>, unsigned char display_flags<_dl> );
 8004                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 67; extern void __fastcall disable_split( unsigned char index<acc> );
 8005                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 68; extern void __fastcall sgx_disable_split( unsigned char index<acc> );
 8006                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 70; extern void __fastcall __macro disable_all_splits( void );
 8007                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 71; extern void __fastcall __macro sgx_disable_all_splits( void );
 8008                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 73; #asm
 8009                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 74; .macro	_disable_all_splits
 8010                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 75; ldy	#HUCC_PCE_SPLITS - 1
 8011                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 76; !loop:		tya
 8012                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 77; call	_disable_split.1
 8013                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 78; dey
 8014                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 79; bpl	!loop-
 8015                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 80; .endm
 8016                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 82; .macro	_sgx_disable_all_splits
 8017                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 83; ldy	#HUCC_SGX_SPLITS - 1
 8018                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 84; !loop:		tya
 8019                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 85; call	_sgx_disable_split.1
 8020                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 86; dey
 8021                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 87; bpl	!loop-
 8022                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 88; .endm
 8023                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 89; #endasm
 8024                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 91; #endif // __HUCC__
 8025                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 93; #endif // _hucc_scroll_h
 8026                        		.dbg	line,	"include\init.c", 3; #include "hucc-chrmap.h"
 8027                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 1; #ifndef _hucc_chrmap_h
 8028                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 2; #define _hucc_chrmap_h
 8029                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 4; /****************************************************************************
 8030                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 5; ; ***************************************************************************
 8031                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 6; ;
 8032                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 7; ; hucc-chrmap.h
 8033                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 8; ;
 8034                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 9; ; A simple map system based on 8x8 characters (aka "tiles") in BAT format.
 8035                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 10; ;
 8036                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 11; ; Copyright John Brandwood 2025.
 8037                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 12; ;
 8038                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 13; ; Distributed under the Boost Software License, Version 1.0.
 8039                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 14; ; (See accompanying file LICENSE_1_0.txt or copy at
 8040                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 15; ;  http://www.boost.org/LICENSE_1_0.txt)
 8041                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 16; ;
 8042                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 17; ; ***************************************************************************
 8043                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 18; ; ***************************************************************************
 8044                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 19; ;
 8045                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 20; ; The maximum X and Y size for chrmaps is 256 characters (2048 pixels).
 8046                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 21; ;
 8047                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 22; ; The maximum total size for a chrmap is 16KBytes, which allows for maps up
 8048                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 23; ; to 256x32 tiles (2048x256 pixels).
 8049                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 24; ;
 8050                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 25; ; ***************************************************************************
 8051                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 26; ; **************************************************************************/
 8052                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 28; // *************
 8053                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 29; // This code extends the blkmap library ...
 8054                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 30; // *************
 8055                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 32; #include "hucc-blkmap.h"
 8056                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 34; // *************
 8057                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 35; // Functions in chrmap.asm ...
 8058                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 36; // *************
 8059                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 38; #ifdef __HUCC__
 8060                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 40; #asmdef	HUCC_USES_CHRMAP 1
 8061                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 42; extern void __fastcall __nop set_chrmap( unsigned char __far *chrmap<vdc_map_bank:vdc_map_addr>, unsigned char tiles_w<vdc_map_line_w> );
 8062                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 44; extern void __fastcall draw_bat( void );
 8063                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 45; extern void __fastcall scroll_bat( void );
 8064                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 47; extern void __fastcall blit_bat( unsigned char tile_x<map_bat_x>, unsigned char tile_y<map_bat_y>, unsigned char tile_w<map_draw_x>, unsigned char tile_h<map_draw_y> );
 8065                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 49; #ifdef _SGX
 8066                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 51; extern void __fastcall __nop sgx_set_chrmap( unsigned char __far *chrmap<sgx_map_bank:sgx_map_addr>, unsigned char tiles_w<sgx_map_line_w> );
 8067                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 53; extern void __fastcall sgx_draw_bat( void );
 8068                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 54; extern void __fastcall sgx_scroll_bat( void );
 8069                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 56; extern void __fastcall sgx_blit_bat( unsigned char tile_x<map_bat_x>, unsigned char tile_y<map_bat_y>, unsigned char tile_w<map_draw_x>, unsigned char tile_h<map_draw_y> );
 8070                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 58; #endif
 8071                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 60; #endif // __HUCC__
 8072                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 62; #endif // _hucc_chrmap_h
 8073                        		.dbg	line,	"include\init.c", 4; #include "hucc-blkmap.h"
 8074                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 1; #ifndef _hucc_blkmap_h
 8075                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 2; #define _hucc_blkmap_h
 8076                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 4; /****************************************************************************
 8077                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 5; ; ***************************************************************************
 8078                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 6; ;
 8079                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 7; ; hucc-blkmap.h
 8080                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 8; ;
 8081                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 9; ; A map system based on 16x16 meta-tiles (aka "blocks", aka CHR/BLK/MAP).
 8082                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 10; ;
 8083                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 11; ; Copyright John Brandwood 2025.
 8084                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 12; ;
 8085                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 13; ; Distributed under the Boost Software License, Version 1.0.
 8086                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 14; ; (See accompanying file LICENSE_1_0.txt or copy at
 8087                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 15; ;  http://www.boost.org/LICENSE_1_0.txt)
 8088                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 16; ;
 8089                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 17; ; ***************************************************************************
 8090                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 18; ; ***************************************************************************
 8091                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 19; ;
 8092                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 20; ; The maximum X and Y size for blkmaps is 128 blocks (2048 pixels).
 8093                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 21; ;
 8094                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 22; ; The maximum total size for a blkmap is 16KBytes, which allows for maps up
 8095                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 23; ; to 128x128 blocks (2048x2048 pixels).
 8096                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 24; ;
 8097                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 25; ; Huge multi-screen blkmaps are also supported (optionally).
 8098                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 26; ;
 8099                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 27; ; The maximum X and Y for multi-screen maps is 128 screens (32768 pixels).
 8100                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 28; ;
 8101                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 29; ; The maximum total size for a multi-screen map is 8KBytes, which allows for
 8102                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 30; ; a total of 1024 screens.
 8103                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 31; ;
 8104                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 32; ; ***************************************************************************
 8105                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 33; ; **************************************************************************/
 8106                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 35; // *************
 8107                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 36; // Functions in blkmap.asm ...
 8108                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 37; // *************
 8109                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 39; #ifdef __HUCC__
 8110                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 41; #asmdef	HUCC_USES_BLKMAP 1
 8111                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 43; // Current top-left of drawn map in pixels.
 8112                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 44; extern unsigned int   vdc_map_pxl_x;
 8113                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 45; extern unsigned int   vdc_map_pxl_y;
 8114                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 47; // Width and height to draw/scroll in characters (not tiles).
 8115                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 48; extern unsigned char  vdc_map_draw_w;
 8116                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 49; extern unsigned char  vdc_map_draw_h;
 8117                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 51; // Width of map (or multi-screen BAT) in tiles.
 8118                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 52; extern unsigned char  vdc_map_line_w;
 8119                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 54; // Width of map in screens (if multi-screen map).
 8120                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 55; extern unsigned char  vdc_map_scrn_w;
 8121                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 57; // Extra information returned by get_map_block() and sgx_get_map_block(),
 8122                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 58; // which are the collision flags and the mask/overlay sprite for the BLK.
 8123                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 59; extern unsigned char  map_blk_flag;
 8124                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 60; extern unsigned char  map_blk_mask;
 8125                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 62; extern unsigned char  vdc_scr_bank;
 8126                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 63; extern unsigned char *vdc_scr_addr;
 8127                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 65; extern unsigned char  vdc_map_bank;
 8128                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 66; extern unsigned char *vdc_map_addr;
 8129                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 68; extern unsigned char  vdc_blk_bank;
 8130                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 69; extern unsigned char *vdc_blk_addr;
 8131                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 71; extern unsigned char  vdc_tbl_bank;
 8132                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 72; extern unsigned char *vdc_tbl_addr;
 8133                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 74; extern void __fastcall set_blocks( unsigned char __far *blk_def<vdc_blk_bank:vdc_blk_addr>, unsigned char __far *flg_def<vdc_tbl_bank:vdc_tbl_addr>, unsigned char number_of_blocks<_al> );
 8134                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 75; extern void __fastcall __macro set_blkmap( unsigned char __far *blk_map<vdc_map_bank:vdc_map_addr>, unsigned char blocks_w<vdc_map_line_w> );
 8135                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 76; extern void __fastcall __macro set_multimap( unsigned char __far *multi_map<vdc_scr_bank:vdc_scr_addr>, unsigned char screens_w<vdc_map_scrn_w> );
 8136                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 78; extern void __fastcall draw_map( void );
 8137                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 79; extern void __fastcall scroll_map( void );
 8138                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 81; extern void __fastcall blit_map( unsigned char tile_x<map_bat_x>, unsigned char tile_y<map_bat_y>, unsigned char tile_w<map_draw_x>, unsigned char tile_h<map_draw_y> );
 8139                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 83; extern unsigned char __fastcall get_map_block( unsigned int x<map_pxl_x>, unsigned int y<map_pxl_y> );
 8140                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 85; #asm
 8141                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 86; .macro	_set_blkmap.2
 8142                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 87; stz	vdc_scr_bank
 8143                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 88; .endm
 8144                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 90; .macro	_set_multimap.2
 8145                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 91; lda	vdc_bat_width
 8146                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 92; lsr	a
 8147                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 93; sta	vdc_map_line_w
 8148                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 94; .endm
 8149                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 96; .macro	SCREEN
 8150                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 97; db	(((\1) & $1FFF) | $6000) >> 8, bank(\1)
 8151                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 98; db	(((\2) & $1FFF) | $4000) >> 8, bank(\2)
 8152                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 99; db	(((\3) & $1FFF) | $6000) >> 8, bank(\3)
 8153                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 100; dw	(\4)
 8154                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 101; .endm
 8155                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 102; #endasm
 8156                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 104; #ifdef _SGX
 8157                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 106; // Current top-left of drawn map in pixels.
 8158                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 107; extern unsigned int   sgx_map_pxl_x;
 8159                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 108; extern unsigned int   sgx_map_pxl_y;
 8160                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 110; // Width and height to draw/scroll in characters (not tiles).
 8161                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 111; extern unsigned char  sgx_map_draw_w;
 8162                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 112; extern unsigned char  sgx_map_draw_h;
 8163                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 114; // Width of map (or multi-screen BAT) in tiles.
 8164                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 115; extern unsigned char  sgx_map_line_w;
 8165                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 117; // Width of map in screens (if multi-screen map).
 8166                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 118; extern unsigned char  sgx_map_scrn_w;
 8167                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 120; extern unsigned char  sgx_scr_bank;
 8168                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 121; extern unsigned char *sgx_scr_addr;
 8169                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 123; extern unsigned char  sgx_map_bank;
 8170                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 124; extern unsigned char *sgx_map_addr;
 8171                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 126; extern unsigned char  sgx_blk_bank;
 8172                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 127; extern unsigned char *sgx_blk_addr;
 8173                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 129; extern unsigned char  sgx_tbl_bank;
 8174                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 130; extern unsigned char *sgx_tbl_addr;
 8175                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 132; extern void __fastcall sgx_set_blocks( unsigned char __far *blk_def<sgx_blk_bank:sgx_blk_addr>, unsigned char __far *flg_def<sgx_tbl_bank:sgx_tbl_addr>, unsigned char number_of_blocks<_al> );
 8176                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 133; extern void __fastcall __macro sgx_set_blkmap( unsigned char __far *blk_map<sgx_map_bank:sgx_map_addr>, unsigned char blocks_w<sgx_map_line_w> );
 8177                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 134; extern void __fastcall __macro sgx_set_multimap( unsigned char __far *multi_map<sgx_scr_bank:sgx_scr_addr>, unsigned char screens_w<sgx_map_scrn_w> );
 8178                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 136; extern void __fastcall sgx_draw_map( void );
 8179                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 137; extern void __fastcall sgx_scroll_map( void );
 8180                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 139; extern void __fastcall sgx_blit_map( unsigned char tile_x<map_bat_x>, unsigned char tile_y<map_bat_y>, unsigned char tile_w<map_draw_x>, unsigned char tile_h<map_draw_y> );
 8181                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 141; extern unsigned char __fastcall sgx_get_map_block( unsigned int x<map_pxl_x>, unsigned int y<map_pxl_y> );
 8182                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 143; #asm
 8183                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 144; .macro	_sgx_set_blkmap.2
 8184                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 145; stz	sgx_scr_bank
 8185                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 146; .endm
 8186                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 148; .macro	_sgx_set_multimap.2
 8187                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 149; lda	sgx_bat_width
 8188                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 150; lsr	a
 8189                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 151; sta	sgx_map_line_w
 8190                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 152; .endm
 8191                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 153; #endasm
 8192                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 155; #endif
 8193                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 157; #endif // __HUCC__
 8194                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 159; #endif // _hucc_blkmap_h
 8195                        		.dbg	line,	"include\init.c", 13; void init_VARIABLES()
 8196                        		.dbg	line,	"include\init.c", 14; {
 8197                        	;***********************
 8198                        	;***********************
 8199                        	
 8200                        		.hucc
 8201    02:C32F             		.proc		_init_VARIABLES
 8202                        		__enter		_init_VARIABLES
 8203                        	
 8204                        		.dbg	line,	"include\init.c", 15; sequence_id = SEQUENCE_GAME;
 8205                        		__st.umiq	2, _sequence_id
         02:C32F  A9 02      			lda.l	#2
         02:C331  8D 0D 23   			sta	_sequence_id
 8206                        	
 8207                        		.dbg	line,	"include\init.c", 17; level_id = 1;
 8208                        		__st.umiq	1, _level_id
         02:C334  A9 01      			lda.l	#1
         02:C336  8D 0F 23   			sta	_level_id
 8209                        	
 8210                        		.dbg	line,	"include\init.c", 19; key_number = 0;
 8211                        		__st.umiq	0, _key_number
         02:C339  9C 1A 23   			stz	_key_number
 8212                        	
 8213                        		.dbg	line,	"include\init.c", 20; potion_number = 0;
 8214                        		__st.umiq	0, _potion_number
         02:C33C  9C 1B 23   			stz	_potion_number
 8215                        	
 8216                        		.dbg	line,	"include\init.c", 21; zenny_number = 200;
 8217                        		__st.umiq	200, _zenny_number
         02:C33F  A9 C8      			lda.l	#200
         02:C341  8D 1C 23   			sta	_zenny_number
 8218                        	
 8219                        		.dbg	line,	"include\init.c", 23; minutes = 1;
 8220                        		__st.umiq	1, _minutes
         02:C344  A9 01      			lda.l	#1
         02:C346  8D 1D 23   			sta	_minutes
 8221                        	
 8222                        		.dbg	line,	"include\init.c", 24; seconds = 59;
 8223                        		__st.umiq	59, _seconds
         02:C349  A9 3B      			lda.l	#59
         02:C34B  8D 1E 23   			sta	_seconds
 8224                        	
 8225                        		.dbg	line,	"include\init.c", 25; time_counter = 0;
 8226                        		__st.umiq	0, _time_counter
         02:C34E  9C 1F 23   			stz	_time_counter
 8227                        	
 8228                        		.dbg	line,	"include\init.c", 27; sequence_loaded = FALSE;
 8229                        		__st.umiq	0, _sequence_loaded
         02:C351  9C 0E 23   			stz	_sequence_loaded
 8230                        	
 8231                        		.dbg	line,	"include\init.c", 28; }
 8232    02:C354             	.LL356:
 8233                        		__return	0
         02:C354  4C EF FF   			jmp	leave_proc
 8234                        		.dbg	clear
 8235                        		.endp
 8236                        		.pceas
 8237                        	
 8238                        		.dbg	line,	"include\init.c", 31; void init_PLAYER()
 8239                        		.dbg	line,	"include\init.c", 32; {
 8240                        	;***********************
 8241                        	;***********************
 8242                        	
 8243                        		.hucc
 8244    02:C3A1             		.proc		_init_PLAYER
 8245                        		__enter		_init_PLAYER
 8246                        	
 8247                        		.dbg	line,	"include\init.c", 33; player_id = 2;
 8248                        		__st.umiq	2, _player_id
         02:C3A1  A9 02      			lda.l	#2
         02:C3A3  8D 10 23   			sta	_player_id
 8249                        	
 8250                        		.dbg	line,	"include\init.c", 34; player_axis = AXIS_RIGHT;
 8251                        		__st.umiq	0, _player_axis
         02:C3A6  9C 12 23   			stz	_player_axis
 8252                        	
 8253                        		.dbg	line,	"include\init.c", 35; player_previous_axis = player_axis;
 8254                        		__ld.um		_player_axis
         02:C3A9  AD 12 23   			lda	_player_axis
         02:C3AC  C2         			cly
 8255                        		__st.umq	_player_previous_axis
         02:C3AD  8D 13 23   			sta	_player_previous_axis
 8256                        	
 8257                        		.dbg	line,	"include\init.c", 36; player_counter_anim = 0;
 8258                        		__st.umiq	0, _player_counter_anim
         02:C3B0  9C 14 23   			stz	_player_counter_anim
 8259                        	
 8260                        		.dbg	line,	"include\init.c", 37; player_index_jump = 0;
 8261                        		__st.umiq	0, _player_index_jump
         02:C3B3  9C 15 23   			stz	_player_index_jump
 8262                        	
 8263                        		.dbg	line,	"include\init.c", 38; player_index_fall = 0;
 8264                        		__st.umiq	0, _player_index_fall
         02:C3B6  9C 16 23   			stz	_player_index_fall
 8265                        	
 8266                        		.dbg	line,	"include\init.c", 39; player_state = STATE_IDLE;
 8267                        		__st.umiq	0, _player_state
         02:C3B9  9C 11 23   			stz	_player_state
 8268                        	
 8269                        		.dbg	line,	"include\init.c", 40; }
 8270    02:C3BC             	.LL357:
 8271                        		__return	0
         02:C3BC  4C EF FF   			jmp	leave_proc
 8272                        		.dbg	clear
 8273                        		.endp
 8274                        		.pceas
 8275                        	
 8276                        		.dbg	line,	"include\init.c", 45; void load_OBJECT_TILES()
 8277                        		.dbg	line,	"include\init.c", 46; {
 8278                        	;***********************
 8279                        	;***********************
 8280                        	
 8281                        		.hucc
 8282    0E:DD3C             		.proc		_load_OBJECT_TILES
 8283                        		__enter		_load_OBJECT_TILES
 8284                        	
 8285                        		.dbg	line,	"include\init.c", 47; load_vram(POT1_VRAM_ADR, tiles_SPR_POT , SIZEOF(tiles_SPR_POT) >> 1);
 8286                        		__st.wmiq	7168, _di
         0E:DD3C  64 F0      			stz.l	_di
         0E:DD3E  A9 1C      			lda.h	#7168
         0E:DD40  85 F1      			sta.h	_di
 8287                        		__farptr	_tiles_SPR_POT, _bp_bank, _bp
         0E:DD42  A9 20      			lda.l	#$6000 + ($1FFF & (_tiles_SPR_POT))
         0E:DD44  85 EC      			sta.l	_bp
         0E:DD46  A9 70      			lda.h	#$6000 + ($1FFF & (_tiles_SPR_POT))
         0E:DD48  85 ED      			sta.h	_bp
         0E:DD4A  A9 0D      			lda	#bank(_tiles_SPR_POT)
         0E:DD4C  85 02      			sta	_bp_bank
 8288                        		__ld.wi		___sizeof__tiles_SPR_POT
         0E:DD4E  A9 00      			lda.l	#___sizeof__tiles_SPR_POT
         0E:DD50  A0 04      			ldy.h	#___sizeof__tiles_SPR_POT
 8289                        		__lsr.wi	1
         0E:DD52  42         			say
         0E:DD53  4A         			lsr	a
         0E:DD54  42         			say
         0E:DD55  6A         			ror	a
 8290                        		__st.wmq	_ax
         0E:DD56  85 F8      			sta.l	_ax
         0E:DD58  84 F9      			sty.h	_ax
 8291                        		 _load_vram.3
         0E:DD5A  82         			clx				; Offset to PCE VDC.
         0E:DD5B  20 63 FF   			call	load_vram_x
 8292                        	
 8293                        		.dbg	line,	"include\init.c", 48; load_vram(POW_VRAM_ADR, tiles_SPR_POW , TILES_4);
 8294                        		__st.wmiq	7680, _di
         0E:DD5E  64 F0      			stz.l	_di
         0E:DD60  A9 1E      			lda.h	#7680
         0E:DD62  85 F1      			sta.h	_di
 8295                        		__farptr	_tiles_SPR_POW, _bp_bank, _bp
         0E:DD64  A9 20      			lda.l	#$6000 + ($1FFF & (_tiles_SPR_POW))
         0E:DD66  85 EC      			sta.l	_bp
         0E:DD68  A9 74      			lda.h	#$6000 + ($1FFF & (_tiles_SPR_POW))
         0E:DD6A  85 ED      			sta.h	_bp
         0E:DD6C  A9 0D      			lda	#bank(_tiles_SPR_POW)
         0E:DD6E  85 02      			sta	_bp_bank
 8296                        		__st.wmiq	64, _ax
         0E:DD70  A9 40      			lda.l	#64
         0E:DD72  85 F8      			sta.l	_ax
         0E:DD74  64 F9      			stz.h	_ax
 8297                        		 _load_vram.3
         0E:DD76  82         			clx				; Offset to PCE VDC.
         0E:DD77  20 63 FF   			call	load_vram_x
 8298                        	
 8299                        		.dbg	line,	"include\init.c", 49; load_vram(GRAY_KEY_VRAM_ADR, tiles_SPR_GRAY_KEY , TILES_4);
 8300                        		__st.wmiq	7744, _di
         0E:DD7A  A9 40      			lda.l	#7744
         0E:DD7C  85 F0      			sta.l	_di
         0E:DD7E  A9 1E      			lda.h	#7744
         0E:DD80  85 F1      			sta.h	_di
 8301                        		__farptr	_tiles_SPR_GRAY_KEY, _bp_bank, _bp
         0E:DD82  A9 A0      			lda.l	#$6000 + ($1FFF & (_tiles_SPR_GRAY_KEY))
         0E:DD84  85 EC      			sta.l	_bp
         0E:DD86  A9 6D      			lda.h	#$6000 + ($1FFF & (_tiles_SPR_GRAY_KEY))
         0E:DD88  85 ED      			sta.h	_bp
         0E:DD8A  A9 0D      			lda	#bank(_tiles_SPR_GRAY_KEY)
         0E:DD8C  85 02      			sta	_bp_bank
 8302                        		__st.wmiq	64, _ax
         0E:DD8E  A9 40      			lda.l	#64
         0E:DD90  85 F8      			sta.l	_ax
         0E:DD92  64 F9      			stz.h	_ax
 8303                        		 _load_vram.3
         0E:DD94  82         			clx				; Offset to PCE VDC.
         0E:DD95  20 63 FF   			call	load_vram_x
 8304                        	
 8305                        		.dbg	line,	"include\init.c", 50; load_vram(GOLD_KEY_VRAM_ADR, tiles_SPR_GOLD_KEY , TILES_4);
 8306                        		__st.wmiq	7808, _di
         0E:DD98  A9 80      			lda.l	#7808
         0E:DD9A  85 F0      			sta.l	_di
         0E:DD9C  A9 1E      			lda.h	#7808
         0E:DD9E  85 F1      			sta.h	_di
 8307                        		__farptr	_tiles_SPR_GOLD_KEY, _bp_bank, _bp
         0E:DDA0  A9 20      			lda.l	#$6000 + ($1FFF & (_tiles_SPR_GOLD_KEY))
         0E:DDA2  85 EC      			sta.l	_bp
         0E:DDA4  A9 6E      			lda.h	#$6000 + ($1FFF & (_tiles_SPR_GOLD_KEY))
         0E:DDA6  85 ED      			sta.h	_bp
         0E:DDA8  A9 0D      			lda	#bank(_tiles_SPR_GOLD_KEY)
         0E:DDAA  85 02      			sta	_bp_bank
 8308                        		__st.wmiq	64, _ax
         0E:DDAC  A9 40      			lda.l	#64
         0E:DDAE  85 F8      			sta.l	_ax
         0E:DDB0  64 F9      			stz.h	_ax
 8309                        		 _load_vram.3
         0E:DDB2  82         			clx				; Offset to PCE VDC.
         0E:DDB3  20 63 FF   			call	load_vram_x
 8310                        	
 8311                        		.dbg	line,	"include\init.c", 51; load_vram(LIFE_VRAM_ADR, tiles_SPR_LIFE , TILES_4);
 8312                        		__st.wmiq	7872, _di
         0E:DDB6  A9 C0      			lda.l	#7872
         0E:DDB8  85 F0      			sta.l	_di
         0E:DDBA  A9 1E      			lda.h	#7872
         0E:DDBC  85 F1      			sta.h	_di
 8313                        		__farptr	_tiles_SPR_LIFE, _bp_bank, _bp
         0E:DDBE  A9 20      			lda.l	#$6000 + ($1FFF & (_tiles_SPR_LIFE))
         0E:DDC0  85 EC      			sta.l	_bp
         0E:DDC2  A9 6F      			lda.h	#$6000 + ($1FFF & (_tiles_SPR_LIFE))
         0E:DDC4  85 ED      			sta.h	_bp
         0E:DDC6  A9 0D      			lda	#bank(_tiles_SPR_LIFE)
         0E:DDC8  85 02      			sta	_bp_bank
 8314                        		__st.wmiq	64, _ax
         0E:DDCA  A9 40      			lda.l	#64
         0E:DDCC  85 F8      			sta.l	_ax
         0E:DDCE  64 F9      			stz.h	_ax
 8315                        		 _load_vram.3
         0E:DDD0  82         			clx				; Offset to PCE VDC.
         0E:DDD1  20 63 FF   			call	load_vram_x
 8316                        	
 8317                        		.dbg	line,	"include\init.c", 52; load_vram(COIN_1_VRAM_ADR, tiles_SPR_COIN_1 , TILES_4);
 8318                        		__st.wmiq	7936, _di
         0E:DDD4  64 F0      			stz.l	_di
         0E:DDD6  A9 1F      			lda.h	#7936
         0E:DDD8  85 F1      			sta.h	_di
 8319                        		__farptr	_tiles_SPR_COIN_1, _bp_bank, _bp
         0E:DDDA  A9 A0      			lda.l	#$6000 + ($1FFF & (_tiles_SPR_COIN_1))
         0E:DDDC  85 EC      			sta.l	_bp
         0E:DDDE  A9 69      			lda.h	#$6000 + ($1FFF & (_tiles_SPR_COIN_1))
         0E:DDE0  85 ED      			sta.h	_bp
         0E:DDE2  A9 0D      			lda	#bank(_tiles_SPR_COIN_1)
         0E:DDE4  85 02      			sta	_bp_bank
 8320                        		__st.wmiq	64, _ax
         0E:DDE6  A9 40      			lda.l	#64
         0E:DDE8  85 F8      			sta.l	_ax
         0E:DDEA  64 F9      			stz.h	_ax
 8321                        		 _load_vram.3
         0E:DDEC  82         			clx				; Offset to PCE VDC.
         0E:DDED  20 63 FF   			call	load_vram_x
 8322                        	
 8323                        		.dbg	line,	"include\init.c", 53; load_vram(COIN_5_VRAM_ADR, tiles_SPR_COIN_5 , TILES_4);
 8324                        		__st.wmiq	8000, _di
         0E:DDF0  A9 40      			lda.l	#8000
         0E:DDF2  85 F0      			sta.l	_di
         0E:DDF4  A9 1F      			lda.h	#8000
         0E:DDF6  85 F1      			sta.h	_di
 8325                        		__farptr	_tiles_SPR_COIN_5, _bp_bank, _bp
         0E:DDF8  A9 20      			lda.l	#$6000 + ($1FFF & (_tiles_SPR_COIN_5))
         0E:DDFA  85 EC      			sta.l	_bp
         0E:DDFC  A9 6A      			lda.h	#$6000 + ($1FFF & (_tiles_SPR_COIN_5))
         0E:DDFE  85 ED      			sta.h	_bp
         0E:DE00  A9 0D      			lda	#bank(_tiles_SPR_COIN_5)
         0E:DE02  85 02      			sta	_bp_bank
 8326                        		__st.wmiq	64, _ax
         0E:DE04  A9 40      			lda.l	#64
         0E:DE06  85 F8      			sta.l	_ax
         0E:DE08  64 F9      			stz.h	_ax
 8327                        		 _load_vram.3
         0E:DE0A  82         			clx				; Offset to PCE VDC.
         0E:DE0B  20 63 FF   			call	load_vram_x
 8328                        	
 8329                        		.dbg	line,	"include\init.c", 54; load_vram(COIN_10_VRAM_ADR, tiles_SPR_COIN_10 , TILES_4);
 8330                        		__st.wmiq	8064, _di
         0E:DE0E  A9 80      			lda.l	#8064
         0E:DE10  85 F0      			sta.l	_di
         0E:DE12  A9 1F      			lda.h	#8064
         0E:DE14  85 F1      			sta.h	_di
 8331                        		__farptr	_tiles_SPR_COIN_10, _bp_bank, _bp
         0E:DE16  A9 A0      			lda.l	#$6000 + ($1FFF & (_tiles_SPR_COIN_10))
         0E:DE18  85 EC      			sta.l	_bp
         0E:DE1A  A9 6A      			lda.h	#$6000 + ($1FFF & (_tiles_SPR_COIN_10))
         0E:DE1C  85 ED      			sta.h	_bp
         0E:DE1E  A9 0D      			lda	#bank(_tiles_SPR_COIN_10)
         0E:DE20  85 02      			sta	_bp_bank
 8332                        		__st.wmiq	64, _ax
         0E:DE22  A9 40      			lda.l	#64
         0E:DE24  85 F8      			sta.l	_ax
         0E:DE26  64 F9      			stz.h	_ax
 8333                        		 _load_vram.3
         0E:DE28  82         			clx				; Offset to PCE VDC.
         0E:DE29  20 63 FF   			call	load_vram_x
 8334                        	
 8335                        		.dbg	line,	"include\init.c", 55; load_vram(COIN_50_VRAM_ADR, tiles_SPR_COIN_50 , TILES_4);
 8336                        		__st.wmiq	8128, _di
         0E:DE2C  A9 C0      			lda.l	#8128
         0E:DE2E  85 F0      			sta.l	_di
         0E:DE30  A9 1F      			lda.h	#8128
         0E:DE32  85 F1      			sta.h	_di
 8337                        		__farptr	_tiles_SPR_COIN_50, _bp_bank, _bp
         0E:DE34  A9 20      			lda.l	#$6000 + ($1FFF & (_tiles_SPR_COIN_50))
         0E:DE36  85 EC      			sta.l	_bp
         0E:DE38  A9 6B      			lda.h	#$6000 + ($1FFF & (_tiles_SPR_COIN_50))
         0E:DE3A  85 ED      			sta.h	_bp
         0E:DE3C  A9 0D      			lda	#bank(_tiles_SPR_COIN_50)
         0E:DE3E  85 02      			sta	_bp_bank
 8338                        		__st.wmiq	64, _ax
         0E:DE40  A9 40      			lda.l	#64
         0E:DE42  85 F8      			sta.l	_ax
         0E:DE44  64 F9      			stz.h	_ax
 8339                        		 _load_vram.3
         0E:DE46  82         			clx				; Offset to PCE VDC.
         0E:DE47  20 63 FF   			call	load_vram_x
 8340                        	
 8341                        		.dbg	line,	"include\init.c", 56; load_vram(COIN_100_VRAM_ADR, tiles_SPR_COIN_100 , TILES_4);
 8342                        		__st.wmiq	8192, _di
         0E:DE4A  64 F0      			stz.l	_di
         0E:DE4C  A9 20      			lda.h	#8192
         0E:DE4E  85 F1      			sta.h	_di
 8343                        		__farptr	_tiles_SPR_COIN_100, _bp_bank, _bp
         0E:DE50  A9 A0      			lda.l	#$6000 + ($1FFF & (_tiles_SPR_COIN_100))
         0E:DE52  85 EC      			sta.l	_bp
         0E:DE54  A9 6B      			lda.h	#$6000 + ($1FFF & (_tiles_SPR_COIN_100))
         0E:DE56  85 ED      			sta.h	_bp
         0E:DE58  A9 0D      			lda	#bank(_tiles_SPR_COIN_100)
         0E:DE5A  85 02      			sta	_bp_bank
 8344                        		__st.wmiq	64, _ax
         0E:DE5C  A9 40      			lda.l	#64
         0E:DE5E  85 F8      			sta.l	_ax
         0E:DE60  64 F9      			stz.h	_ax
 8345                        		 _load_vram.3
         0E:DE62  82         			clx				; Offset to PCE VDC.
         0E:DE63  20 63 FF   			call	load_vram_x
 8346                        	
 8347                        		.dbg	line,	"include\init.c", 57; load_vram(COIN_500_VRAM_ADR, tiles_SPR_COIN_500 , TILES_4);
 8348                        		__st.wmiq	8256, _di
         0E:DE66  A9 40      			lda.l	#8256
         0E:DE68  85 F0      			sta.l	_di
         0E:DE6A  A9 20      			lda.h	#8256
         0E:DE6C  85 F1      			sta.h	_di
 8349                        		__farptr	_tiles_SPR_COIN_500, _bp_bank, _bp
         0E:DE6E  A9 20      			lda.l	#$6000 + ($1FFF & (_tiles_SPR_COIN_500))
         0E:DE70  85 EC      			sta.l	_bp
         0E:DE72  A9 6C      			lda.h	#$6000 + ($1FFF & (_tiles_SPR_COIN_500))
         0E:DE74  85 ED      			sta.h	_bp
         0E:DE76  A9 0D      			lda	#bank(_tiles_SPR_COIN_500)
         0E:DE78  85 02      			sta	_bp_bank
 8350                        		__st.wmiq	64, _ax
         0E:DE7A  A9 40      			lda.l	#64
         0E:DE7C  85 F8      			sta.l	_ax
         0E:DE7E  64 F9      			stz.h	_ax
 8351                        		 _load_vram.3
         0E:DE80  82         			clx				; Offset to PCE VDC.
         0E:DE81  20 63 FF   			call	load_vram_x
 8352                        	
 8353                        		.dbg	line,	"include\init.c", 58; load_vram(COIN_1000_VRAM_ADR, tiles_SPR_COIN_1000 , TILES_4);
 8354                        		__st.wmiq	8320, _di
         0E:DE84  A9 80      			lda.l	#8320
         0E:DE86  85 F0      			sta.l	_di
         0E:DE88  A9 20      			lda.h	#8320
         0E:DE8A  85 F1      			sta.h	_di
 8355                        		__farptr	_tiles_SPR_COIN_1000, _bp_bank, _bp
         0E:DE8C  A9 A0      			lda.l	#$6000 + ($1FFF & (_tiles_SPR_COIN_1000))
         0E:DE8E  85 EC      			sta.l	_bp
         0E:DE90  A9 6C      			lda.h	#$6000 + ($1FFF & (_tiles_SPR_COIN_1000))
         0E:DE92  85 ED      			sta.h	_bp
         0E:DE94  A9 0D      			lda	#bank(_tiles_SPR_COIN_1000)
         0E:DE96  85 02      			sta	_bp_bank
 8356                        		__st.wmiq	64, _ax
         0E:DE98  A9 40      			lda.l	#64
         0E:DE9A  85 F8      			sta.l	_ax
         0E:DE9C  64 F9      			stz.h	_ax
 8357                        		 _load_vram.3
         0E:DE9E  82         			clx				; Offset to PCE VDC.
         0E:DE9F  20 63 FF   			call	load_vram_x
 8358                        	
 8359                        		.dbg	line,	"include\init.c", 59; load_vram(STAR_VRAM_ADR, tiles_SPR_STAR , TILES_4);
 8360                        		__st.wmiq	8384, _di
         0E:DEA2  A9 C0      			lda.l	#8384
         0E:DEA4  85 F0      			sta.l	_di
         0E:DEA6  A9 20      			lda.h	#8384
         0E:DEA8  85 F1      			sta.h	_di
 8361                        		__farptr	_tiles_SPR_STAR, _bp_bank, _bp
         0E:DEAA  A9 A0      			lda.l	#$6000 + ($1FFF & (_tiles_SPR_STAR))
         0E:DEAC  85 EC      			sta.l	_bp
         0E:DEAE  A9 74      			lda.h	#$6000 + ($1FFF & (_tiles_SPR_STAR))
         0E:DEB0  85 ED      			sta.h	_bp
         0E:DEB2  A9 0D      			lda	#bank(_tiles_SPR_STAR)
         0E:DEB4  85 02      			sta	_bp_bank
 8362                        		__st.wmiq	64, _ax
         0E:DEB6  A9 40      			lda.l	#64
         0E:DEB8  85 F8      			sta.l	_ax
         0E:DEBA  64 F9      			stz.h	_ax
 8363                        		 _load_vram.3
         0E:DEBC  82         			clx				; Offset to PCE VDC.
         0E:DEBD  20 63 FF   			call	load_vram_x
 8364                        	
 8365                        		.dbg	line,	"include\init.c", 60; load_vram(OCTOPUS_VRAM_ADR, tiles_SPR_OCTOPUS , TILES_4);
 8366                        		__st.wmiq	8448, _di
         0E:DEC0  64 F0      			stz.l	_di
         0E:DEC2  A9 21      			lda.h	#8448
         0E:DEC4  85 F1      			sta.h	_di
 8367                        		__farptr	_tiles_SPR_OCTOPUS, _bp_bank, _bp
         0E:DEC6  A9 A0      			lda.l	#$6000 + ($1FFF & (_tiles_SPR_OCTOPUS))
         0E:DEC8  85 EC      			sta.l	_bp
         0E:DECA  A9 6F      			lda.h	#$6000 + ($1FFF & (_tiles_SPR_OCTOPUS))
         0E:DECC  85 ED      			sta.h	_bp
         0E:DECE  A9 0D      			lda	#bank(_tiles_SPR_OCTOPUS)
         0E:DED0  85 02      			sta	_bp_bank
 8368                        		__st.wmiq	64, _ax
         0E:DED2  A9 40      			lda.l	#64
         0E:DED4  85 F8      			sta.l	_ax
         0E:DED6  64 F9      			stz.h	_ax
 8369                        		 _load_vram.3
         0E:DED8  82         			clx				; Offset to PCE VDC.
         0E:DED9  20 63 FF   			call	load_vram_x
 8370                        	
 8371                        		.dbg	line,	"include\init.c", 61; load_vram(FRUIT_VRAM_ADR, tiles_SPR_FRUIT , TILES_4);
 8372                        		__st.wmiq	8512, _di
         0E:DEDC  A9 40      			lda.l	#8512
         0E:DEDE  85 F0      			sta.l	_di
         0E:DEE0  A9 21      			lda.h	#8512
         0E:DEE2  85 F1      			sta.h	_di
 8373                        		__farptr	_tiles_SPR_FRUIT, _bp_bank, _bp
         0E:DEE4  A9 20      			lda.l	#$6000 + ($1FFF & (_tiles_SPR_FRUIT))
         0E:DEE6  85 EC      			sta.l	_bp
         0E:DEE8  A9 6D      			lda.h	#$6000 + ($1FFF & (_tiles_SPR_FRUIT))
         0E:DEEA  85 ED      			sta.h	_bp
         0E:DEEC  A9 0D      			lda	#bank(_tiles_SPR_FRUIT)
         0E:DEEE  85 02      			sta	_bp_bank
 8374                        		__st.wmiq	64, _ax
         0E:DEF0  A9 40      			lda.l	#64
         0E:DEF2  85 F8      			sta.l	_ax
         0E:DEF4  64 F9      			stz.h	_ax
 8375                        		 _load_vram.3
         0E:DEF6  82         			clx				; Offset to PCE VDC.
         0E:DEF7  20 63 FF   			call	load_vram_x
 8376                        	
 8377                        		.dbg	line,	"include\init.c", 62; load_vram(BARREL_VRAM_ADR, tiles_SPR_BARREL , TILES_4);
 8378                        		__st.wmiq	8576, _di
         0E:DEFA  A9 80      			lda.l	#8576
         0E:DEFC  85 F0      			sta.l	_di
         0E:DEFE  A9 21      			lda.h	#8576
         0E:DF00  85 F1      			sta.h	_di
 8379                        		__farptr	_tiles_SPR_BARREL, _bp_bank, _bp
         0E:DF02  A9 20      			lda.l	#$6000 + ($1FFF & (_tiles_SPR_BARREL))
         0E:DF04  85 EC      			sta.l	_bp
         0E:DF06  A9 7D      			lda.h	#$6000 + ($1FFF & (_tiles_SPR_BARREL))
         0E:DF08  85 ED      			sta.h	_bp
         0E:DF0A  A9 0C      			lda	#bank(_tiles_SPR_BARREL)
         0E:DF0C  85 02      			sta	_bp_bank
 8380                        		__st.wmiq	64, _ax
         0E:DF0E  A9 40      			lda.l	#64
         0E:DF10  85 F8      			sta.l	_ax
         0E:DF12  64 F9      			stz.h	_ax
 8381                        		 _load_vram.3
         0E:DF14  82         			clx				; Offset to PCE VDC.
         0E:DF15  20 63 FF   			call	load_vram_x
 8382                        	
 8383                        		.dbg	line,	"include\init.c", 63; load_vram(HOURGLASS_VRAM_ADR, tiles_SPR_HOURGLASS , TILES_4);
 8384                        		__st.wmiq	8640, _di
         0E:DF18  A9 C0      			lda.l	#8640
         0E:DF1A  85 F0      			sta.l	_di
         0E:DF1C  A9 21      			lda.h	#8640
         0E:DF1E  85 F1      			sta.h	_di
 8385                        		__farptr	_tiles_SPR_HOURGLASS, _bp_bank, _bp
         0E:DF20  A9 A0      			lda.l	#$6000 + ($1FFF & (_tiles_SPR_HOURGLASS))
         0E:DF22  85 EC      			sta.l	_bp
         0E:DF24  A9 6E      			lda.h	#$6000 + ($1FFF & (_tiles_SPR_HOURGLASS))
         0E:DF26  85 ED      			sta.h	_bp
         0E:DF28  A9 0D      			lda	#bank(_tiles_SPR_HOURGLASS)
         0E:DF2A  85 02      			sta	_bp_bank
 8386                        		__st.wmiq	64, _ax
         0E:DF2C  A9 40      			lda.l	#64
         0E:DF2E  85 F8      			sta.l	_ax
         0E:DF30  64 F9      			stz.h	_ax
 8387                        		 _load_vram.3
         0E:DF32  82         			clx				; Offset to PCE VDC.
         0E:DF33  20 63 FF   			call	load_vram_x
 8388                        	
 8389                        		.dbg	line,	"include\init.c", 64; load_vram(BAMBOO_VRAM_ADR, tiles_SPR_BAMBOO , TILES_4);
 8390                        		__st.wmiq	8704, _di
         0E:DF36  64 F0      			stz.l	_di
         0E:DF38  A9 22      			lda.h	#8704
         0E:DF3A  85 F1      			sta.h	_di
 8391                        		__farptr	_tiles_SPR_BAMBOO, _bp_bank, _bp
         0E:DF3C  A9 20      			lda.l	#$6000 + ($1FFF & (_tiles_SPR_BAMBOO))
         0E:DF3E  85 EC      			sta.l	_bp
         0E:DF40  A9 75      			lda.h	#$6000 + ($1FFF & (_tiles_SPR_BAMBOO))
         0E:DF42  85 ED      			sta.h	_bp
         0E:DF44  A9 0D      			lda	#bank(_tiles_SPR_BAMBOO)
         0E:DF46  85 02      			sta	_bp_bank
 8392                        		__st.wmiq	64, _ax
         0E:DF48  A9 40      			lda.l	#64
         0E:DF4A  85 F8      			sta.l	_ax
         0E:DF4C  64 F9      			stz.h	_ax
 8393                        		 _load_vram.3
         0E:DF4E  82         			clx				; Offset to PCE VDC.
         0E:DF4F  20 63 FF   			call	load_vram_x
 8394                        	
 8395                        		.dbg	line,	"include\init.c", 65; load_vram(YASHICHI_VRAM_ADR, tiles_SPR_YASHICHI , TILES_4);
 8396                        		__st.wmiq	8768, _di
         0E:DF52  A9 40      			lda.l	#8768
         0E:DF54  85 F0      			sta.l	_di
         0E:DF56  A9 22      			lda.h	#8768
         0E:DF58  85 F1      			sta.h	_di
 8397                        		__farptr	_tiles_SPR_YASHICHI, _bp_bank, _bp
         0E:DF5A  A9 A0      			lda.l	#$6000 + ($1FFF & (_tiles_SPR_YASHICHI))
         0E:DF5C  85 EC      			sta.l	_bp
         0E:DF5E  A9 75      			lda.h	#$6000 + ($1FFF & (_tiles_SPR_YASHICHI))
         0E:DF60  85 ED      			sta.h	_bp
         0E:DF62  A9 0D      			lda	#bank(_tiles_SPR_YASHICHI)
         0E:DF64  85 02      			sta	_bp_bank
 8398                        		__st.wmiq	64, _ax
         0E:DF66  A9 40      			lda.l	#64
         0E:DF68  85 F8      			sta.l	_ax
         0E:DF6A  64 F9      			stz.h	_ax
 8399                        		 _load_vram.3
         0E:DF6C  82         			clx				; Offset to PCE VDC.
         0E:DF6D  20 63 FF   			call	load_vram_x
 8400                        	
 8401                        		.dbg	line,	"include\init.c", 66; load_vram(ELEPHANT_VRAM_ADR, tiles_SPR_ELEPHANT , TILES_4);
 8402                        		__st.wmiq	8832, _di
         0E:DF70  A9 80      			lda.l	#8832
         0E:DF72  85 F0      			sta.l	_di
         0E:DF74  A9 22      			lda.h	#8832
         0E:DF76  85 F1      			sta.h	_di
 8403                        		__farptr	_tiles_SPR_ELEPHANT, _bp_bank, _bp
         0E:DF78  A9 20      			lda.l	#$6000 + ($1FFF & (_tiles_SPR_ELEPHANT))
         0E:DF7A  85 EC      			sta.l	_bp
         0E:DF7C  A9 76      			lda.h	#$6000 + ($1FFF & (_tiles_SPR_ELEPHANT))
         0E:DF7E  85 ED      			sta.h	_bp
         0E:DF80  A9 0D      			lda	#bank(_tiles_SPR_ELEPHANT)
         0E:DF82  85 02      			sta	_bp_bank
 8404                        		__st.wmiq	64, _ax
         0E:DF84  A9 40      			lda.l	#64
         0E:DF86  85 F8      			sta.l	_ax
         0E:DF88  64 F9      			stz.h	_ax
 8405                        		 _load_vram.3
         0E:DF8A  82         			clx				; Offset to PCE VDC.
         0E:DF8B  20 63 FF   			call	load_vram_x
 8406                        	
 8407                        		.dbg	line,	"include\init.c", 67; load_vram(DRAGONFLY_VRAM_ADR, tiles_SPR_DRAGONFLY , TILES_4);
 8408                        		__st.wmiq	8896, _di
         0E:DF8E  A9 C0      			lda.l	#8896
         0E:DF90  85 F0      			sta.l	_di
         0E:DF92  A9 22      			lda.h	#8896
         0E:DF94  85 F1      			sta.h	_di
 8409                        		__farptr	_tiles_SPR_DRAGONFLY, _bp_bank, _bp
         0E:DF96  A9 A0      			lda.l	#$6000 + ($1FFF & (_tiles_SPR_DRAGONFLY))
         0E:DF98  85 EC      			sta.l	_bp
         0E:DF9A  A9 76      			lda.h	#$6000 + ($1FFF & (_tiles_SPR_DRAGONFLY))
         0E:DF9C  85 ED      			sta.h	_bp
         0E:DF9E  A9 0D      			lda	#bank(_tiles_SPR_DRAGONFLY)
         0E:DFA0  85 02      			sta	_bp_bank
 8410                        		__st.wmiq	64, _ax
         0E:DFA2  A9 40      			lda.l	#64
         0E:DFA4  85 F8      			sta.l	_ax
         0E:DFA6  64 F9      			stz.h	_ax
 8411                        		 _load_vram.3
         0E:DFA8  82         			clx				; Offset to PCE VDC.
         0E:DFA9  20 63 FF   			call	load_vram_x
 8412                        	
 8413                        		.dbg	line,	"include\init.c", 68; load_vram(COW_VRAM_ADR, tiles_SPR_COW , TILES_4);
 8414                        		__st.wmiq	8960, _di
         0E:DFAC  64 F0      			stz.l	_di
         0E:DFAE  A9 23      			lda.h	#8960
         0E:DFB0  85 F1      			sta.h	_di
 8415                        		__farptr	_tiles_SPR_COW, _bp_bank, _bp
         0E:DFB2  A9 20      			lda.l	#$6000 + ($1FFF & (_tiles_SPR_COW))
         0E:DFB4  85 EC      			sta.l	_bp
         0E:DFB6  A9 77      			lda.h	#$6000 + ($1FFF & (_tiles_SPR_COW))
         0E:DFB8  85 ED      			sta.h	_bp
         0E:DFBA  A9 0D      			lda	#bank(_tiles_SPR_COW)
         0E:DFBC  85 02      			sta	_bp_bank
 8416                        		__st.wmiq	64, _ax
         0E:DFBE  A9 40      			lda.l	#64
         0E:DFC0  85 F8      			sta.l	_ax
         0E:DFC2  64 F9      			stz.h	_ax
 8417                        		 _load_vram.3
         0E:DFC4  82         			clx				; Offset to PCE VDC.
         0E:DFC5  20 63 FF   			call	load_vram_x
 8418                        	
 8419                        		.dbg	line,	"include\init.c", 69; load_vram(MOBICHAN_VRAM_ADR, tiles_SPR_MOBICHAN , TILES_4);
 8420                        		__st.wmiq	9024, _di
         0E:DFC8  A9 40      			lda.l	#9024
         0E:DFCA  85 F0      			sta.l	_di
         0E:DFCC  A9 23      			lda.h	#9024
         0E:DFCE  85 F1      			sta.h	_di
 8421                        		__farptr	_tiles_SPR_MOBICHAN, _bp_bank, _bp
         0E:DFD0  A9 A0      			lda.l	#$6000 + ($1FFF & (_tiles_SPR_MOBICHAN))
         0E:DFD2  85 EC      			sta.l	_bp
         0E:DFD4  A9 77      			lda.h	#$6000 + ($1FFF & (_tiles_SPR_MOBICHAN))
         0E:DFD6  85 ED      			sta.h	_bp
         0E:DFD8  A9 0D      			lda	#bank(_tiles_SPR_MOBICHAN)
         0E:DFDA  85 02      			sta	_bp_bank
 8422                        		__st.wmiq	64, _ax
         0E:DFDC  A9 40      			lda.l	#64
         0E:DFDE  85 F8      			sta.l	_ax
         0E:DFE0  64 F9      			stz.h	_ax
 8423                        		 _load_vram.3
         0E:DFE2  82         			clx				; Offset to PCE VDC.
         0E:DFE3  20 63 FF   			call	load_vram_x
 8424                        	
 8425                        		.dbg	line,	"include\init.c", 70; }
 8426    0E:DFE6             	.LL358:
 8427                        		__return	0
         0E:DFE6  4C EF FF   			jmp	leave_proc
 8428                        		.dbg	clear
 8429                        		.endp
 8430                        		.pceas
 8431                        	
 8432                        		.dbg	line,	"include\init.c", 73; void load_CHEST_TILES()
 8433                        		.dbg	line,	"include\init.c", 74; {
 8434                        	;***********************
 8435                        	;***********************
 8436                        	
 8437                        		.hucc
 8438    02:C357             		.proc		_load_CHEST_TILES
 8439                        		__enter		_load_CHEST_TILES
 8440                        	
 8441                        		.dbg	line,	"include\init.c", 75; load_vram(CHEST_VRAM_ADR, tiles_SPR_CHEST , SIZEOF(tiles_SPR_CHEST) >> 1);
 8442                        		__st.wmiq	9216, _di
         02:C357  64 F0      			stz.l	_di
         02:C359  A9 24      			lda.h	#9216
         02:C35B  85 F1      			sta.h	_di
 8443                        		__farptr	_tiles_SPR_CHEST, _bp_bank, _bp
         02:C35D  A9 A0      			lda.l	#$6000 + ($1FFF & (_tiles_SPR_CHEST))
         02:C35F  85 EC      			sta.l	_bp
         02:C361  A9 7D      			lda.h	#$6000 + ($1FFF & (_tiles_SPR_CHEST))
         02:C363  85 ED      			sta.h	_bp
         02:C365  A9 0C      			lda	#bank(_tiles_SPR_CHEST)
         02:C367  85 02      			sta	_bp_bank
 8444                        		__ld.wi		___sizeof__tiles_SPR_CHEST
         02:C369  A9 00      			lda.l	#___sizeof__tiles_SPR_CHEST
         02:C36B  A0 0C      			ldy.h	#___sizeof__tiles_SPR_CHEST
 8445                        		__lsr.wi	1
         02:C36D  42         			say
         02:C36E  4A         			lsr	a
         02:C36F  42         			say
         02:C370  6A         			ror	a
 8446                        		__st.wmq	_ax
         02:C371  85 F8      			sta.l	_ax
         02:C373  84 F9      			sty.h	_ax
 8447                        		 _load_vram.3
         02:C375  82         			clx				; Offset to PCE VDC.
         02:C376  20 63 FF   			call	load_vram_x
 8448                        	
 8449                        		.dbg	line,	"include\init.c", 76; }
 8450    02:C379             	.LL359:
 8451                        		__return	0
         02:C379  4C EF FF   			jmp	leave_proc
 8452                        		.dbg	clear
 8453                        		.endp
 8454                        		.pceas
 8455                        	
 8456                        		.dbg	line,	"include\init.c", 79; void load_NPC_TILES()
 8457                        		.dbg	line,	"include\init.c", 80; {
 8458                        	;***********************
 8459                        	;***********************
 8460                        	
 8461                        		.hucc
 8462    02:C37C             		.proc		_load_NPC_TILES
 8463                        		__enter		_load_NPC_TILES
 8464                        	
 8465                        		.dbg	line,	"include\init.c", 81; load_vram(NPC_VRAM_ADR, tiles_SPR_NPC , SIZEOF(tiles_SPR_NPC) >> 1);
 8466                        		__st.wmiq	10752, _di
         02:C37C  64 F0      			stz.l	_di
         02:C37E  A9 2A      			lda.h	#10752
         02:C380  85 F1      			sta.h	_di
 8467                        		__farptr	_tiles_SPR_NPC, _bp_bank, _bp
         02:C382  A9 20      			lda.l	#$6000 + ($1FFF & (_tiles_SPR_NPC))
         02:C384  85 EC      			sta.l	_bp
         02:C386  A9 7C      			lda.h	#$6000 + ($1FFF & (_tiles_SPR_NPC))
         02:C388  85 ED      			sta.h	_bp
         02:C38A  A9 0D      			lda	#bank(_tiles_SPR_NPC)
         02:C38C  85 02      			sta	_bp_bank
 8468                        		__ld.wi		___sizeof__tiles_SPR_NPC
         02:C38E  A9 00      			lda.l	#___sizeof__tiles_SPR_NPC
         02:C390  A0 0C      			ldy.h	#___sizeof__tiles_SPR_NPC
 8469                        		__lsr.wi	1
         02:C392  42         			say
         02:C393  4A         			lsr	a
         02:C394  42         			say
         02:C395  6A         			ror	a
 8470                        		__st.wmq	_ax
         02:C396  85 F8      			sta.l	_ax
         02:C398  84 F9      			sty.h	_ax
 8471                        		 _load_vram.3
         02:C39A  82         			clx				; Offset to PCE VDC.
         02:C39B  20 63 FF   			call	load_vram_x
 8472                        	
 8473                        		.dbg	line,	"include\init.c", 82; }
 8474    02:C39E             	.LL360:
 8475                        		__return	0
         02:C39E  4C EF FF   			jmp	leave_proc
 8476                        		.dbg	clear
 8477                        		.endp
 8478                        		.pceas
 8479                        	
 8480                        		.dbg	line,	"include\init.c", 85; void init_OBJECT_LV1()
 8481                        		.dbg	line,	"include\init.c", 86; {
 8482                        	;***********************
 8483                        	;***********************
 8484                        	
 8485                        		.hucc
 8486    01:D622             		.proc		_init_OBJECT_LV1
 8487                        		__enter		_init_OBJECT_LV1
 8488                        	
 8489                        		.dbg	line,	"include\init.c", 87; signed char i;
 8490                        	
 8491                        		.dbg	line,	"include\init.c", 89; for(i=0 ; i<level_object_number ; i++)
 8492                        		__st.umiq	0, __init_OBJECT_LV1_end - 1  /* i */
         01:D622  9C 10 25   			stz	__init_OBJECT_LV1_end - 1
 8493    01:D625             	.LL362:
 8494                        		__ld.bm		__init_OBJECT_LV1_end - 1  /* i */
         01:D625  AD 10 25   			lda	__init_OBJECT_LV1_end - 1
         01:D628  C2         			cly
         01:D629  10 01      			bpl	!+
         01:D62B  88         			dey
         01:D62C             	!:
 8495                        		__slt_w.um	_level_object_number
         01:D62C  CD 21 23   			cmp	_level_object_number		; Subtract memory from Y:A.
         01:D62F  98         			tya
         01:D630  E9 00      			sbc	#0
         01:D632  50 02      			bvc	!+
         01:D634  49 80      			eor	#$80		; -ve if Y:A < memory (signed).
         01:D636  0A         	!:		asl	a
 8496                        		__btrue		.LL364
         01:D637  B0 08      			bcs	.LL364
 8497                        		__bra		.LL365
         01:D639  4C 53 D7   			bra	.LL365
 8498    01:D63C             	.LL363:
 8499                        		__inc.umq	__init_OBJECT_LV1_end - 1  /* i */
         01:D63C  EE 10 25   			inc	__init_OBJECT_LV1_end - 1
 8500                        		__bra		.LL362
         01:D63F  80 E4      			bra	.LL362
 8501    01:D641             	.LL364:
 8502                        	
 8503                        		.dbg	line,	"include\init.c", 90; {
 8504                        	
 8505                        		.dbg	line,	"include\init.c", 91; // SET OBJECT PROPERTIES //
 8506                        	
 8507                        		.dbg	line,	"include\init.c", 92; list_object_type[i] = TABLE_OBJECT_TYPE_LV1[i];
 8508                        		__ldx.bmq	__init_OBJECT_LV1_end - 1  /* i */
         01:D641  AE 10 25   			ldx	__init_OBJECT_LV1_end - 1
 8509                        		__ld.uax	_TABLE_OBJECT_TYPE_LV1
         01:D644  BD 25 60   			lda	_TABLE_OBJECT_TYPE_LV1, x
         01:D647  C2         			cly
 8510                        		__ldx.bmq	__init_OBJECT_LV1_end - 1  /* i */
         01:D648  AE 10 25   			ldx	__init_OBJECT_LV1_end - 1
 8511                        		__st.uaxq	_list_object_type
         01:D64B  9D 23 23   			sta	_list_object_type, x
 8512                        	
 8513                        		.dbg	line,	"include\init.c", 93; list_object_x_pos_ref[i] = TABLE_OBJECT_X_POS_REF_LV1[i];
 8514                        		__ld2x.bmq	__init_OBJECT_LV1_end - 1  /* i */
         01:D64E  AD 10 25   			lda	__init_OBJECT_LV1_end - 1
         01:D651  0A         			asl	a
         01:D652  AA         			tax
 8515                        		__ld.wax	_TABLE_OBJECT_X_POS_REF_LV1
         01:D653  BD 3C 60   			lda.l	_TABLE_OBJECT_X_POS_REF_LV1, x
         01:D656  BC 3D 60   			ldy.h	_TABLE_OBJECT_X_POS_REF_LV1, x
 8516                        		__ld2x.bm	__init_OBJECT_LV1_end - 1  /* i */
         01:D659  AA         			tax
         01:D65A  AD 10 25   			lda	__init_OBJECT_LV1_end - 1
         01:D65D  0A         			asl	a
         01:D65E  22         			sax
 8517                        		__st.waxq	_list_object_x_pos_ref
         01:D65F  9D 21 24   			sta.l	_list_object_x_pos_ref, x
         01:D662  98         			tya
         01:D663  9D 22 24   			sta.h	_list_object_x_pos_ref, x
 8518                        	
 8519                        		.dbg	line,	"include\init.c", 94; list_object_y_pos_ref[i] = TABLE_OBJECT_Y_POS_REF_LV1[i];
 8520                        		__ld2x.bmq	__init_OBJECT_LV1_end - 1  /* i */
         01:D666  AD 10 25   			lda	__init_OBJECT_LV1_end - 1
         01:D669  0A         			asl	a
         01:D66A  AA         			tax
 8521                        		__ld.wax	_TABLE_OBJECT_Y_POS_REF_LV1
         01:D66B  BD 6A 60   			lda.l	_TABLE_OBJECT_Y_POS_REF_LV1, x
         01:D66E  BC 6B 60   			ldy.h	_TABLE_OBJECT_Y_POS_REF_LV1, x
 8522                        		__ld2x.bm	__init_OBJECT_LV1_end - 1  /* i */
         01:D671  AA         			tax
         01:D672  AD 10 25   			lda	__init_OBJECT_LV1_end - 1
         01:D675  0A         			asl	a
         01:D676  22         			sax
 8523                        		__st.waxq	_list_object_y_pos_ref
         01:D677  9D 53 24   			sta.l	_list_object_y_pos_ref, x
         01:D67A  98         			tya
         01:D67B  9D 54 24   			sta.h	_list_object_y_pos_ref, x
 8524                        	
 8525                        		.dbg	line,	"include\init.c", 95; list_object_x_pos[i] = -16;
 8526                        		__ld2x.bmq	__init_OBJECT_LV1_end - 1  /* i */
         01:D67E  AD 10 25   			lda	__init_OBJECT_LV1_end - 1
         01:D681  0A         			asl	a
         01:D682  AA         			tax
 8527                        		__st.waxiq	-16, _list_object_x_pos
         01:D683  A9 F0      			lda.l	#-16
         01:D685  9D BD 23   			sta.l	_list_object_x_pos, x
         01:D688  A9 FF      			lda.h	#-16
         01:D68A  9D BE 23   			sta.h	_list_object_x_pos, x
 8528                        	
 8529                        		.dbg	line,	"include\init.c", 96; list_object_y_pos[i] = -16;
 8530                        		__ld2x.bmq	__init_OBJECT_LV1_end - 1  /* i */
         01:D68D  AD 10 25   			lda	__init_OBJECT_LV1_end - 1
         01:D690  0A         			asl	a
         01:D691  AA         			tax
 8531                        		__st.waxiq	-16, _list_object_y_pos
         01:D692  A9 F0      			lda.l	#-16
         01:D694  9D EF 23   			sta.l	_list_object_y_pos, x
         01:D697  A9 FF      			lda.h	#-16
         01:D699  9D F0 23   			sta.h	_list_object_y_pos, x
 8532                        	
 8533                        		.dbg	line,	"include\init.c", 97; list_object_state[i] = STATE_ACTIVE;
 8534                        		__ldx.bmq	__init_OBJECT_LV1_end - 1  /* i */
         01:D69C  AE 10 25   			ldx	__init_OBJECT_LV1_end - 1
 8535                        		__st.uaxiq	0, _list_object_state
         01:D69F  9E 3C 23   			stz	_list_object_state, x
 8536                        	
 8537                        		.dbg	line,	"include\init.c", 100; // SET OBJECT SPRITE //
 8538                        	
 8539                        		.dbg	line,	"include\init.c", 101; spr_set(i + object_start_index);
 8540                        		__ld.bm		__init_OBJECT_LV1_end - 1  /* i */
         01:D6A2  AD 10 25   			lda	__init_OBJECT_LV1_end - 1
         01:D6A5  C2         			cly
         01:D6A6  10 01      			bpl	!+
         01:D6A8  88         			dey
         01:D6A9             	!:
 8541                        		__add.um	_object_start_index
         01:D6A9  18         			clc
         01:D6AA  6D 20 23   			adc	_object_start_index
         01:D6AD  90 01      			bcc	!+
         01:D6AF  C8         			iny
         01:D6B0             	!:
 8542                        		__call		_spr_set.1
         01:D6B0  20 DD E7   			call	_spr_set.1
 8543                        	
 8544                        		.dbg	line,	"include\init.c", 102; spr_x(list_object_x_pos[i]);
 8545                        		__ld2x.bmq	__init_OBJECT_LV1_end - 1  /* i */
         01:D6B3  AD 10 25   			lda	__init_OBJECT_LV1_end - 1
         01:D6B6  0A         			asl	a
         01:D6B7  AA         			tax
 8546                        		__ld.wax	_list_object_x_pos
         01:D6B8  BD BD 23   			lda.l	_list_object_x_pos, x
         01:D6BB  BC BE 23   			ldy.h	_list_object_x_pos, x
 8547                        		__call		_spr_x.1
         01:D6BE  20 0A E8   			call	_spr_x.1
 8548                        	
 8549                        		.dbg	line,	"include\init.c", 103; spr_y(list_object_y_pos[i]);
 8550                        		__ld2x.bmq	__init_OBJECT_LV1_end - 1  /* i */
         01:D6C1  AD 10 25   			lda	__init_OBJECT_LV1_end - 1
         01:D6C4  0A         			asl	a
         01:D6C5  AA         			tax
 8551                        		__ld.wax	_list_object_y_pos
         01:D6C6  BD EF 23   			lda.l	_list_object_y_pos, x
         01:D6C9  BC F0 23   			ldy.h	_list_object_y_pos, x
 8552                        		__call		_spr_y.1
         01:D6CC  20 19 E8   			call	_spr_y.1
 8553                        	
 8554                        		.dbg	line,	"include\init.c", 104; spr_pri(FALSE);
 8555                        		__ld.uiq	0
         01:D6CF  62         			cla
 8556                        		__call		_spr_pri.1
         01:D6D0  20 5C E8   			call	_spr_pri.1
 8557                        	
 8558                        		.dbg	line,	"include\init.c", 107; if(list_object_type[i] == TYPE_HOURGLASS)
 8559                        		__ldx.bmq	__init_OBJECT_LV1_end - 1  /* i */
         01:D6D3  AE 10 25   			ldx	__init_OBJECT_LV1_end - 1
 8560                        		__not.uax	_list_object_type
         01:D6D6  BD 23 23   			lda	_list_object_type, x
         01:D6D9  18         			clc
         01:D6DA  D0 01      			bne	!+
         01:D6DC  38         			sec
         01:D6DD             	!:
 8561                        		__bfalse	.LL366
         01:D6DD  90 1D      			bcc	.LL366
 8562                        	
 8563                        		.dbg	line,	"include\init.c", 108; {
 8564                        	
 8565                        		.dbg	line,	"include\init.c", 109; list_object_energy[i] = 0;
 8566                        		__ldx.bmq	__init_OBJECT_LV1_end - 1  /* i */
         01:D6DF  AE 10 25   			ldx	__init_OBJECT_LV1_end - 1
 8567                        		__st.uaxiq	0, _list_object_energy
         01:D6E2  9E 55 23   			stz	_list_object_energy, x
 8568                        	
 8569                        		.dbg	line,	"include\init.c", 110; spr_pal(18);
 8570                        		__ld.uiq	18
         01:D6E5  A9 12      			lda	#18
 8571                        		__call		_spr_pal.1
         01:D6E7  20 4D E8   			call	_spr_pal.1
 8572                        	
 8573                        		.dbg	line,	"include\init.c", 111; spr_pattern(HOURGLASS_VRAM_ADR);
 8574                        		__ld.wi		8640
         01:D6EA  A9 C0      			lda.l	#8640
         01:D6EC  A0 21      			ldy.h	#8640
 8575                        		__call		_spr_pattern.1
         01:D6EE  20 26 E8   			call	_spr_pattern.1
 8576                        	
 8577                        		.dbg	line,	"include\init.c", 112; spr_ctrl(FLIP_MAS|SIZE_MAS, NO_FLIP|SZ_16x16);
 8578                        		__st.umiq	185, _al
         01:D6F1  A9 B9      			lda.l	#185
         01:D6F3  85 F8      			sta	_al
 8579                        		__ld.uiq	0
         01:D6F5  62         			cla
 8580                        		__call		_spr_ctrl.2
         01:D6F6  20 3C E8   			call	_spr_ctrl.2
 8581                        	
 8582                        		.dbg	line,	"include\init.c", 113; }
 8583                        	
 8584                        		.dbg	line,	"include\init.c", 115; else if(list_object_type[i] == TYPE_POT)
 8585                        		__bra		.LL367
         01:D6F9  4C 3C D6   			bra	.LL367
 8586    01:D6FC             	.LL366:
 8587                        		__ldx.bmq	__init_OBJECT_LV1_end - 1  /* i */
         01:D6FC  AE 10 25   			ldx	__init_OBJECT_LV1_end - 1
 8588                        		__ld.uaxq	_list_object_type
         01:D6FF  BD 23 23   			lda	_list_object_type, x
 8589                        		__equ_b.uiq	1
         01:D702  C9 01      			cmp	#1
         01:D704  F0 01      			beq	!+
         01:D706  18         			clc
         01:D707             	!:
 8590                        		__bfalse	.LL368
         01:D707  90 1E      			bcc	.LL368
 8591                        	
 8592                        		.dbg	line,	"include\init.c", 116; {
 8593                        	
 8594                        		.dbg	line,	"include\init.c", 117; list_object_energy[i] = 2;
 8595                        		__ldx.bmq	__init_OBJECT_LV1_end - 1  /* i */
         01:D709  AE 10 25   			ldx	__init_OBJECT_LV1_end - 1
 8596                        		__st.uaxiq	2, _list_object_energy
         01:D70C  A9 02      			lda.l	#2
         01:D70E  9D 55 23   			sta	_list_object_energy, x
 8597                        	
 8598                        		.dbg	line,	"include\init.c", 118; spr_pal(17);
 8599                        		__ld.uiq	17
         01:D711  A9 11      			lda	#17
 8600                        		__call		_spr_pal.1
         01:D713  20 4D E8   			call	_spr_pal.1
 8601                        	
 8602                        		.dbg	line,	"include\init.c", 119; spr_pattern(POT1_VRAM_ADR);
 8603                        		__ld.wi		7168
         01:D716  62         			cla
         01:D717  A0 1C      			ldy.h	#7168
 8604                        		__call		_spr_pattern.1
         01:D719  20 26 E8   			call	_spr_pattern.1
 8605                        	
 8606                        		.dbg	line,	"include\init.c", 120; spr_ctrl(FLIP_MAS|SIZE_MAS, NO_FLIP|SZ_16x16);
 8607                        		__st.umiq	185, _al
         01:D71C  A9 B9      			lda.l	#185
         01:D71E  85 F8      			sta	_al
 8608                        		__ld.uiq	0
         01:D720  62         			cla
 8609                        		__call		_spr_ctrl.2
         01:D721  20 3C E8   			call	_spr_ctrl.2
 8610                        	
 8611                        		.dbg	line,	"include\init.c", 121; }
 8612                        	
 8613                        		.dbg	line,	"include\init.c", 123; else if(list_object_type[i] == TYPE_POW)
 8614                        		__bra		.LL369
         01:D724  4C 3C D6   			bra	.LL369
 8615    01:D727             	.LL368:
 8616                        		__ldx.bmq	__init_OBJECT_LV1_end - 1  /* i */
         01:D727  AE 10 25   			ldx	__init_OBJECT_LV1_end - 1
 8617                        		__ld.uaxq	_list_object_type
         01:D72A  BD 23 23   			lda	_list_object_type, x
 8618                        		__equ_b.uiq	2
         01:D72D  C9 02      			cmp	#2
         01:D72F  F0 01      			beq	!+
         01:D731  18         			clc
         01:D732             	!:
 8619                        		__bfalse	.LL370
         01:D732  B0 03 4C 3C			bcc	.LL370
         01:D736  D6          
 8620                        	
 8621                        		.dbg	line,	"include\init.c", 124; {
 8622                        	
 8623                        		.dbg	line,	"include\init.c", 125; list_object_energy[i] = 0;
 8624                        		__ldx.bmq	__init_OBJECT_LV1_end - 1  /* i */
         01:D737  AE 10 25   			ldx	__init_OBJECT_LV1_end - 1
 8625                        		__st.uaxiq	0, _list_object_energy
         01:D73A  9E 55 23   			stz	_list_object_energy, x
 8626                        	
 8627                        		.dbg	line,	"include\init.c", 126; spr_pal(18);
 8628                        		__ld.uiq	18
         01:D73D  A9 12      			lda	#18
 8629                        		__call		_spr_pal.1
         01:D73F  20 4D E8   			call	_spr_pal.1
 8630                        	
 8631                        		.dbg	line,	"include\init.c", 127; spr_pattern(POW_VRAM_ADR);
 8632                        		__ld.wi		7680
         01:D742  62         			cla
         01:D743  A0 1E      			ldy.h	#7680
 8633                        		__call		_spr_pattern.1
         01:D745  20 26 E8   			call	_spr_pattern.1
 8634                        	
 8635                        		.dbg	line,	"include\init.c", 128; spr_ctrl(FLIP_MAS|SIZE_MAS, NO_FLIP|SZ_16x16);
 8636                        		__st.umiq	185, _al
         01:D748  A9 B9      			lda.l	#185
         01:D74A  85 F8      			sta	_al
 8637                        		__ld.uiq	0
         01:D74C  62         			cla
 8638                        		__call		_spr_ctrl.2
         01:D74D  20 3C E8   			call	_spr_ctrl.2
 8639                        	
 8640                        		.dbg	line,	"include\init.c", 129; }
 8641                        	
 8642                        		.dbg	line,	"include\init.c", 130; }
 8643    01:D750             	.LL370	.alias		.LL363
 8644    01:D750             	.LL369	.alias		.LL363
 8645    01:D750             	.LL367	.alias		.LL363
 8646                        		__bra		.LL363
         01:D750  4C 3C D6   			bra	.LL363
 8647    01:D753             	.LL365:
 8648                        	
 8649                        		.dbg	line,	"include\init.c", 131; }
 8650    01:D753             	.LL361:
 8651                        		__return	0
         01:D753  4C EF FF   			jmp	leave_proc
 8652                        		.dbg	clear
 8653                        		.endp
 8654                        		.pceas
 8655                        	
 8656                        		.dbg	line,	"include\init.c", 134; void init_CHEST_LV1()
 8657                        		.dbg	line,	"include\init.c", 135; {
 8658                        	;***********************
 8659                        	;***********************
 8660                        	
 8661                        		.hucc
 8662    01:DB03             		.proc		_init_CHEST_LV1
 8663                        		__enter		_init_CHEST_LV1
 8664                        	
 8665                        		.dbg	line,	"include\init.c", 136; signed char i;
 8666                        	
 8667                        		.dbg	line,	"include\init.c", 138; for(i=0 ; i<level_chest_number ; i++)
 8668                        		__st.umiq	0, __init_CHEST_LV1_end - 1  /* i */
         01:DB03  9C 10 25   			stz	__init_CHEST_LV1_end - 1
 8669    01:DB06             	.LL372:
 8670                        		__ld.bm		__init_CHEST_LV1_end - 1  /* i */
         01:DB06  AD 10 25   			lda	__init_CHEST_LV1_end - 1
         01:DB09  C2         			cly
         01:DB0A  10 01      			bpl	!+
         01:DB0C  88         			dey
         01:DB0D             	!:
 8671                        		__slt_w.um	_level_chest_number
         01:DB0D  CD 90 23   			cmp	_level_chest_number		; Subtract memory from Y:A.
         01:DB10  98         			tya
         01:DB11  E9 00      			sbc	#0
         01:DB13  50 02      			bvc	!+
         01:DB15  49 80      			eor	#$80		; -ve if Y:A < memory (signed).
         01:DB17  0A         	!:		asl	a
 8672                        		__btrue		.LL374
         01:DB18  B0 08      			bcs	.LL374
 8673                        		__bra		.LL375
         01:DB1A  4C BE DB   			bra	.LL375
 8674    01:DB1D             	.LL373:
 8675                        		__inc.umq	__init_CHEST_LV1_end - 1  /* i */
         01:DB1D  EE 10 25   			inc	__init_CHEST_LV1_end - 1
 8676                        		__bra		.LL372
         01:DB20  80 E4      			bra	.LL372
 8677    01:DB22             	.LL374:
 8678                        	
 8679                        		.dbg	line,	"include\init.c", 139; {
 8680                        	
 8681                        		.dbg	line,	"include\init.c", 140; // SET CHEST PROPERTIES //
 8682                        	
 8683                        		.dbg	line,	"include\init.c", 141; list_chest_x_pos_ref[i] = TABLE_CHEST_X_POS_REF_LV1[i];
 8684                        		__ld2x.bmq	__init_CHEST_LV1_end - 1  /* i */
         01:DB22  AD 10 25   			lda	__init_CHEST_LV1_end - 1
         01:DB25  0A         			asl	a
         01:DB26  AA         			tax
 8685                        		__ld.wax	_TABLE_CHEST_X_POS_REF_LV1
         01:DB27  BD 98 60   			lda.l	_TABLE_CHEST_X_POS_REF_LV1, x
         01:DB2A  BC 99 60   			ldy.h	_TABLE_CHEST_X_POS_REF_LV1, x
 8686                        		__ld2x.bm	__init_CHEST_LV1_end - 1  /* i */
         01:DB2D  AA         			tax
         01:DB2E  AD 10 25   			lda	__init_CHEST_LV1_end - 1
         01:DB31  0A         			asl	a
         01:DB32  22         			sax
 8687                        		__st.waxq	_list_chest_x_pos_ref
         01:DB33  9D A5 24   			sta.l	_list_chest_x_pos_ref, x
         01:DB36  98         			tya
         01:DB37  9D A6 24   			sta.h	_list_chest_x_pos_ref, x
 8688                        	
 8689                        		.dbg	line,	"include\init.c", 142; list_chest_y_pos_ref[i] = TABLE_CHEST_Y_POS_REF_LV1[i];
 8690                        		__ld2x.bmq	__init_CHEST_LV1_end - 1  /* i */
         01:DB3A  AD 10 25   			lda	__init_CHEST_LV1_end - 1
         01:DB3D  0A         			asl	a
         01:DB3E  AA         			tax
 8691                        		__ld.wax	_TABLE_CHEST_Y_POS_REF_LV1
         01:DB3F  BD 9C 60   			lda.l	_TABLE_CHEST_Y_POS_REF_LV1, x
         01:DB42  BC 9D 60   			ldy.h	_TABLE_CHEST_Y_POS_REF_LV1, x
 8692                        		__ld2x.bm	__init_CHEST_LV1_end - 1  /* i */
         01:DB45  AA         			tax
         01:DB46  AD 10 25   			lda	__init_CHEST_LV1_end - 1
         01:DB49  0A         			asl	a
         01:DB4A  22         			sax
 8693                        		__st.waxq	_list_chest_y_pos_ref
         01:DB4B  9D B5 24   			sta.l	_list_chest_y_pos_ref, x
         01:DB4E  98         			tya
         01:DB4F  9D B6 24   			sta.h	_list_chest_y_pos_ref, x
 8694                        	
 8695                        		.dbg	line,	"include\init.c", 143; list_chest_x_pos[i] = -32;
 8696                        		__ld2x.bmq	__init_CHEST_LV1_end - 1  /* i */
         01:DB52  AD 10 25   			lda	__init_CHEST_LV1_end - 1
         01:DB55  0A         			asl	a
         01:DB56  AA         			tax
 8697                        		__st.waxiq	-32, _list_chest_x_pos
         01:DB57  A9 E0      			lda.l	#-32
         01:DB59  9D 85 24   			sta.l	_list_chest_x_pos, x
         01:DB5C  A9 FF      			lda.h	#-32
         01:DB5E  9D 86 24   			sta.h	_list_chest_x_pos, x
 8698                        	
 8699                        		.dbg	line,	"include\init.c", 144; list_chest_y_pos[i] = -32;
 8700                        		__ld2x.bmq	__init_CHEST_LV1_end - 1  /* i */
         01:DB61  AD 10 25   			lda	__init_CHEST_LV1_end - 1
         01:DB64  0A         			asl	a
         01:DB65  AA         			tax
 8701                        		__st.waxiq	-32, _list_chest_y_pos
         01:DB66  A9 E0      			lda.l	#-32
         01:DB68  9D 95 24   			sta.l	_list_chest_y_pos, x
         01:DB6B  A9 FF      			lda.h	#-32
         01:DB6D  9D 96 24   			sta.h	_list_chest_y_pos, x
 8702                        	
 8703                        		.dbg	line,	"include\init.c", 145; list_chest_state[i] = STATE_ACTIVE;
 8704                        		__ldx.bmq	__init_CHEST_LV1_end - 1  /* i */
         01:DB70  AE 10 25   			ldx	__init_CHEST_LV1_end - 1
 8705                        		__st.uaxiq	0, _list_chest_state
         01:DB73  9E 92 23   			stz	_list_chest_state, x
 8706                        	
 8707                        		.dbg	line,	"include\init.c", 148; // SET CHEST SPRITE //
 8708                        	
 8709                        		.dbg	line,	"include\init.c", 149; spr_set(i + chest_start_index);
 8710                        		__ld.bm		__init_CHEST_LV1_end - 1  /* i */
         01:DB76  AD 10 25   			lda	__init_CHEST_LV1_end - 1
         01:DB79  C2         			cly
         01:DB7A  10 01      			bpl	!+
         01:DB7C  88         			dey
         01:DB7D             	!:
 8711                        		__add.um	_chest_start_index
         01:DB7D  18         			clc
         01:DB7E  6D 8F 23   			adc	_chest_start_index
         01:DB81  90 01      			bcc	!+
         01:DB83  C8         			iny
         01:DB84             	!:
 8712                        		__call		_spr_set.1
         01:DB84  20 DD E7   			call	_spr_set.1
 8713                        	
 8714                        		.dbg	line,	"include\init.c", 150; spr_x(list_chest_x_pos[i]);
 8715                        		__ld2x.bmq	__init_CHEST_LV1_end - 1  /* i */
         01:DB87  AD 10 25   			lda	__init_CHEST_LV1_end - 1
         01:DB8A  0A         			asl	a
         01:DB8B  AA         			tax
 8716                        		__ld.wax	_list_chest_x_pos
         01:DB8C  BD 85 24   			lda.l	_list_chest_x_pos, x
         01:DB8F  BC 86 24   			ldy.h	_list_chest_x_pos, x
 8717                        		__call		_spr_x.1
         01:DB92  20 0A E8   			call	_spr_x.1
 8718                        	
 8719                        		.dbg	line,	"include\init.c", 151; spr_y(list_chest_y_pos[i]);
 8720                        		__ld2x.bmq	__init_CHEST_LV1_end - 1  /* i */
         01:DB95  AD 10 25   			lda	__init_CHEST_LV1_end - 1
         01:DB98  0A         			asl	a
         01:DB99  AA         			tax
 8721                        		__ld.wax	_list_chest_y_pos
         01:DB9A  BD 95 24   			lda.l	_list_chest_y_pos, x
         01:DB9D  BC 96 24   			ldy.h	_list_chest_y_pos, x
 8722                        		__call		_spr_y.1
         01:DBA0  20 19 E8   			call	_spr_y.1
 8723                        	
 8724                        		.dbg	line,	"include\init.c", 152; spr_pri(FALSE);
 8725                        		__ld.uiq	0
         01:DBA3  62         			cla
 8726                        		__call		_spr_pri.1
         01:DBA4  20 5C E8   			call	_spr_pri.1
 8727                        	
 8728                        		.dbg	line,	"include\init.c", 155; spr_pal(18);
 8729                        		__ld.uiq	18
         01:DBA7  A9 12      			lda	#18
 8730                        		__call		_spr_pal.1
         01:DBA9  20 4D E8   			call	_spr_pal.1
 8731                        	
 8732                        		.dbg	line,	"include\init.c", 156; spr_pattern(CHEST_VRAM_ADR);
 8733                        		__ld.wi		9216
         01:DBAC  62         			cla
         01:DBAD  A0 24      			ldy.h	#9216
 8734                        		__call		_spr_pattern.1
         01:DBAF  20 26 E8   			call	_spr_pattern.1
 8735                        	
 8736                        		.dbg	line,	"include\init.c", 157; spr_ctrl(FLIP_MAS|SIZE_MAS, NO_FLIP|SZ_32x32);
 8737                        		__st.umiq	185, _al
         01:DBB2  A9 B9      			lda.l	#185
         01:DBB4  85 F8      			sta	_al
 8738                        		__ld.uiq	17
         01:DBB6  A9 11      			lda	#17
 8739                        		__call		_spr_ctrl.2
         01:DBB8  20 3C E8   			call	_spr_ctrl.2
 8740                        	
 8741                        		.dbg	line,	"include\init.c", 158; }
 8742                        		__bra		.LL373
         01:DBBB  4C 1D DB   			bra	.LL373
 8743    01:DBBE             	.LL375:
 8744                        	
 8745                        		.dbg	line,	"include\init.c", 159; }
 8746    01:DBBE             	.LL371:
 8747                        		__return	0
         01:DBBE  4C EF FF   			jmp	leave_proc
 8748                        		.dbg	clear
 8749                        		.endp
 8750                        		.pceas
 8751                        	
 8752                        		.dbg	line,	"include\init.c", 162; void init_NPC_LV1()
 8753                        		.dbg	line,	"include\init.c", 163; {
 8754                        	;***********************
 8755                        	;***********************
 8756                        	
 8757                        		.hucc
 8758    01:DBC1             		.proc		_init_NPC_LV1
 8759                        		__enter		_init_NPC_LV1
 8760                        	
 8761                        		.dbg	line,	"include\init.c", 164; signed char i;
 8762                        	
 8763                        		.dbg	line,	"include\init.c", 166; for(i=0 ; i<level_npc_number ; i++)
 8764                        		__st.umiq	0, __init_NPC_LV1_end - 1  /* i */
         01:DBC1  9C 10 25   			stz	__init_NPC_LV1_end - 1
 8765    01:DBC4             	.LL377:
 8766                        		__ld.bm		__init_NPC_LV1_end - 1  /* i */
         01:DBC4  AD 10 25   			lda	__init_NPC_LV1_end - 1
         01:DBC7  C2         			cly
         01:DBC8  10 01      			bpl	!+
         01:DBCA  88         			dey
         01:DBCB             	!:
 8767                        		__slt_w.um	_level_npc_number
         01:DBCB  CD A3 23   			cmp	_level_npc_number		; Subtract memory from Y:A.
         01:DBCE  98         			tya
         01:DBCF  E9 00      			sbc	#0
         01:DBD1  50 02      			bvc	!+
         01:DBD3  49 80      			eor	#$80		; -ve if Y:A < memory (signed).
         01:DBD5  0A         	!:		asl	a
 8768                        		__btrue		.LL379
         01:DBD6  B0 08      			bcs	.LL379
 8769                        		__bra		.LL380
         01:DBD8  4C 7C DC   			bra	.LL380
 8770    01:DBDB             	.LL378:
 8771                        		__inc.umq	__init_NPC_LV1_end - 1  /* i */
         01:DBDB  EE 10 25   			inc	__init_NPC_LV1_end - 1
 8772                        		__bra		.LL377
         01:DBDE  80 E4      			bra	.LL377
 8773    01:DBE0             	.LL379:
 8774                        	
 8775                        		.dbg	line,	"include\init.c", 167; {
 8776                        	
 8777                        		.dbg	line,	"include\init.c", 168; // SET CHEST PROPERTIES //
 8778                        	
 8779                        		.dbg	line,	"include\init.c", 169; list_npc_x_pos_ref[i] = TABLE_NPC_X_POS_REF_LV1[i];
 8780                        		__ld2x.bmq	__init_NPC_LV1_end - 1  /* i */
         01:DBE0  AD 10 25   			lda	__init_NPC_LV1_end - 1
         01:DBE3  0A         			asl	a
         01:DBE4  AA         			tax
 8781                        		__ld.wax	_TABLE_NPC_X_POS_REF_LV1
         01:DBE5  BD 1D 60   			lda.l	_TABLE_NPC_X_POS_REF_LV1, x
         01:DBE8  BC 1E 60   			ldy.h	_TABLE_NPC_X_POS_REF_LV1, x
 8782                        		__ld2x.bm	__init_NPC_LV1_end - 1  /* i */
         01:DBEB  AA         			tax
         01:DBEC  AD 10 25   			lda	__init_NPC_LV1_end - 1
         01:DBEF  0A         			asl	a
         01:DBF0  22         			sax
 8783                        		__st.waxq	_list_npc_x_pos_ref
         01:DBF1  9D E9 24   			sta.l	_list_npc_x_pos_ref, x
         01:DBF4  98         			tya
         01:DBF5  9D EA 24   			sta.h	_list_npc_x_pos_ref, x
 8784                        	
 8785                        		.dbg	line,	"include\init.c", 170; list_npc_y_pos_ref[i] = TABLE_NPC_Y_POS_REF_LV1[i];
 8786                        		__ld2x.bmq	__init_NPC_LV1_end - 1  /* i */
         01:DBF8  AD 10 25   			lda	__init_NPC_LV1_end - 1
         01:DBFB  0A         			asl	a
         01:DBFC  AA         			tax
 8787                        		__ld.wax	_TABLE_NPC_Y_POS_REF_LV1
         01:DBFD  BD 21 60   			lda.l	_TABLE_NPC_Y_POS_REF_LV1, x
         01:DC00  BC 22 60   			ldy.h	_TABLE_NPC_Y_POS_REF_LV1, x
 8788                        		__ld2x.bm	__init_NPC_LV1_end - 1  /* i */
         01:DC03  AA         			tax
         01:DC04  AD 10 25   			lda	__init_NPC_LV1_end - 1
         01:DC07  0A         			asl	a
         01:DC08  22         			sax
 8789                        		__st.waxq	_list_npc_y_pos_ref
         01:DC09  9D FB 24   			sta.l	_list_npc_y_pos_ref, x
         01:DC0C  98         			tya
         01:DC0D  9D FC 24   			sta.h	_list_npc_y_pos_ref, x
 8790                        	
 8791                        		.dbg	line,	"include\init.c", 171; list_npc_x_pos[i] = -32;
 8792                        		__ld2x.bmq	__init_NPC_LV1_end - 1  /* i */
         01:DC10  AD 10 25   			lda	__init_NPC_LV1_end - 1
         01:DC13  0A         			asl	a
         01:DC14  AA         			tax
 8793                        		__st.waxiq	-32, _list_npc_x_pos
         01:DC15  A9 E0      			lda.l	#-32
         01:DC17  9D C5 24   			sta.l	_list_npc_x_pos, x
         01:DC1A  A9 FF      			lda.h	#-32
         01:DC1C  9D C6 24   			sta.h	_list_npc_x_pos, x
 8794                        	
 8795                        		.dbg	line,	"include\init.c", 172; list_npc_y_pos[i] = -32;
 8796                        		__ld2x.bmq	__init_NPC_LV1_end - 1  /* i */
         01:DC1F  AD 10 25   			lda	__init_NPC_LV1_end - 1
         01:DC22  0A         			asl	a
         01:DC23  AA         			tax
 8797                        		__st.waxiq	-32, _list_npc_y_pos
         01:DC24  A9 E0      			lda.l	#-32
         01:DC26  9D D7 24   			sta.l	_list_npc_y_pos, x
         01:DC29  A9 FF      			lda.h	#-32
         01:DC2B  9D D8 24   			sta.h	_list_npc_y_pos, x
 8798                        	
 8799                        		.dbg	line,	"include\init.c", 173; list_npc_state[i] = STATE_ACTIVE;
 8800                        		__ldx.bmq	__init_NPC_LV1_end - 1  /* i */
         01:DC2E  AE 10 25   			ldx	__init_NPC_LV1_end - 1
 8801                        		__st.uaxiq	0, _list_npc_state
         01:DC31  9E A5 23   			stz	_list_npc_state, x
 8802                        	
 8803                        		.dbg	line,	"include\init.c", 176; // SET CHEST SPRITE //
 8804                        	
 8805                        		.dbg	line,	"include\init.c", 177; spr_set(i + npc_start_index);
 8806                        		__ld.bm		__init_NPC_LV1_end - 1  /* i */
         01:DC34  AD 10 25   			lda	__init_NPC_LV1_end - 1
         01:DC37  C2         			cly
         01:DC38  10 01      			bpl	!+
         01:DC3A  88         			dey
         01:DC3B             	!:
 8807                        		__add.um	_npc_start_index
         01:DC3B  18         			clc
         01:DC3C  6D A2 23   			adc	_npc_start_index
         01:DC3F  90 01      			bcc	!+
         01:DC41  C8         			iny
         01:DC42             	!:
 8808                        		__call		_spr_set.1
         01:DC42  20 DD E7   			call	_spr_set.1
 8809                        	
 8810                        		.dbg	line,	"include\init.c", 178; spr_x(list_npc_x_pos[i]);
 8811                        		__ld2x.bmq	__init_NPC_LV1_end - 1  /* i */
         01:DC45  AD 10 25   			lda	__init_NPC_LV1_end - 1
         01:DC48  0A         			asl	a
         01:DC49  AA         			tax
 8812                        		__ld.wax	_list_npc_x_pos
         01:DC4A  BD C5 24   			lda.l	_list_npc_x_pos, x
         01:DC4D  BC C6 24   			ldy.h	_list_npc_x_pos, x
 8813                        		__call		_spr_x.1
         01:DC50  20 0A E8   			call	_spr_x.1
 8814                        	
 8815                        		.dbg	line,	"include\init.c", 179; spr_y(list_npc_y_pos[i]);
 8816                        		__ld2x.bmq	__init_NPC_LV1_end - 1  /* i */
         01:DC53  AD 10 25   			lda	__init_NPC_LV1_end - 1
         01:DC56  0A         			asl	a
         01:DC57  AA         			tax
 8817                        		__ld.wax	_list_npc_y_pos
         01:DC58  BD D7 24   			lda.l	_list_npc_y_pos, x
         01:DC5B  BC D8 24   			ldy.h	_list_npc_y_pos, x
 8818                        		__call		_spr_y.1
         01:DC5E  20 19 E8   			call	_spr_y.1
 8819                        	
 8820                        		.dbg	line,	"include\init.c", 180; spr_pri(FALSE);
 8821                        		__ld.uiq	0
         01:DC61  62         			cla
 8822                        		__call		_spr_pri.1
         01:DC62  20 5C E8   			call	_spr_pri.1
 8823                        	
 8824                        		.dbg	line,	"include\init.c", 183; spr_pal(17);
 8825                        		__ld.uiq	17
         01:DC65  A9 11      			lda	#17
 8826                        		__call		_spr_pal.1
         01:DC67  20 4D E8   			call	_spr_pal.1
 8827                        	
 8828                        		.dbg	line,	"include\init.c", 184; spr_pattern(NPC_VRAM_ADR);
 8829                        		__ld.wi		10752
         01:DC6A  62         			cla
         01:DC6B  A0 2A      			ldy.h	#10752
 8830                        		__call		_spr_pattern.1
         01:DC6D  20 26 E8   			call	_spr_pattern.1
 8831                        	
 8832                        		.dbg	line,	"include\init.c", 185; spr_ctrl(FLIP_MAS|SIZE_MAS, NO_FLIP|SZ_32x32);
 8833                        		__st.umiq	185, _al
         01:DC70  A9 B9      			lda.l	#185
         01:DC72  85 F8      			sta	_al
 8834                        		__ld.uiq	17
         01:DC74  A9 11      			lda	#17
 8835                        		__call		_spr_ctrl.2
         01:DC76  20 3C E8   			call	_spr_ctrl.2
 8836                        	
 8837                        		.dbg	line,	"include\init.c", 186; }
 8838                        		__bra		.LL378
         01:DC79  4C DB DB   			bra	.LL378
 8839    01:DC7C             	.LL380:
 8840                        	
 8841                        		.dbg	line,	"include\init.c", 187; }
 8842    01:DC7C             	.LL376:
 8843                        		__return	0
         01:DC7C  4C EF FF   			jmp	leave_proc
 8844                        		.dbg	clear
 8845                        		.endp
 8846                        		.pceas
 8847                        	
 8848                        		.dbg	line,	"include\init.c", 192; void init_LEVEL()
 8849                        		.dbg	line,	"include\init.c", 193; {
 8850                        	;***********************
 8851                        	;***********************
 8852                        	
 8853                        		.hucc
 8854    01:CCF0             		.proc		_init_LEVEL
 8855                        		__enter		_init_LEVEL
 8856                        	
 8857                        		.dbg	line,	"include\init.c", 194; if(level_id == 1)
 8858                        		__ld.umq	_level_id
         01:CCF0  AD 0F 23   			lda	_level_id
 8859                        		__equ_b.uiq	1
         01:CCF3  C9 01      			cmp	#1
         01:CCF5  F0 01      			beq	!+
         01:CCF7  18         			clc
         01:CCF8             	!:
 8860                        		__bfalse	.LL382
         01:CCF8  B0 03 4C 66			bcc	.LL382
         01:CCFC  D0          
 8861                        	
 8862                        		.dbg	line,	"include\init.c", 195; {
 8863                        	
 8864                        		.dbg	line,	"include\init.c", 196; //signed char i;
 8865                        	
 8866                        		.dbg	line,	"include\init.c", 198; // VSYNC //
 8867                        	
 8868                        		.dbg	line,	"include\init.c", 199; vsync();
 8869                        		__call		_vsync
         01:CCFD  20 09 E3   			call	_vsync
 8870                        	
 8871                        		.dbg	line,	"include\init.c", 201; // LOAD DEFAULT FONT //
 8872                        	
 8873                        		.dbg	line,	"include\init.c", 202; load_default_font();
 8874                        		 _load_default_font
         01:CD00  82         			clx				; Offset to PCE VDC.
         01:CD01  20 C7 FF   			call	huc_monofont_x
 8875                        	
 8876                        		.dbg	line,	"include\init.c", 207; // SET VDC 1 SCREEN SIZE (IN TILES) - 64x32 = 512x256 PIXELS
 8877                        	
 8878                        		.dbg	line,	"include\init.c", 208; set_screen_size(SCR_SIZE_64x32);
 8879                        		__st.umiq	1, _al
         01:CD04  A9 01      			lda.l	#1
         01:CD06  85 F8      			sta	_al
 8880                        		__call		_set_screen_size.1
         01:CD08  20 45 FF   			call	_set_screen_size.1
 8881                        	
 8882                        		.dbg	line,	"include\init.c", 211; // SET VDC 2 SCREEN SIZE (IN TILES) - 64x32 = 512x256 PIXELS
 8883                        	
 8884                        		.dbg	line,	"include\init.c", 212; sgx_set_screen_size(SCR_SIZE_64x32);
 8885                        		__st.umiq	1, _al
         01:CD0B  A9 01      			lda.l	#1
         01:CD0D  85 F8      			sta	_al
 8886                        		__call		_sgx_set_screen_size.1
         01:CD0F  20 3B FF   			call	_sgx_set_screen_size.1
 8887                        	
 8888                        		.dbg	line,	"include\init.c", 215; // INIT SPRITE ATTRIBUTE TABLE //
 8889                        	
 8890                        		.dbg	line,	"include\init.c", 216; init_satb();
 8891                        		__call		_init_satb
         01:CD12  20 B7 E7   			call	_init_satb
 8892                        	
 8893                        		.dbg	line,	"include\init.c", 220; //**************************************************************************************//
 8894                        	
 8895                        		.dbg	line,	"include\init.c", 221; //                                                                                      //
 8896                        	
 8897                        		.dbg	line,	"include\init.c", 222; //                                      VARIABLES                                       //
 8898                        	
 8899                        		.dbg	line,	"include\init.c", 223; //                                                                                      //
 8900                        	
 8901                        		.dbg	line,	"include\init.c", 224; //**************************************************************************************//
 8902                        	
 8903                        		.dbg	line,	"include\init.c", 226; camera_max_y_position = 768;
 8904                        		__st.wmiq	768, _camera_max_y_position
         01:CD15  9C BB 23   			stz.l	_camera_max_y_position
         01:CD18  A9 03      			lda.h	#768
         01:CD1A  8D BC 23   			sta.h	_camera_max_y_position
 8905                        	
 8906                        		.dbg	line,	"include\init.c", 227; jump_max_index = 34;
 8907                        		__st.umiq	34, _jump_max_index
         01:CD1D  A9 22      			lda.l	#34
         01:CD1F  8D 18 23   			sta	_jump_max_index
 8908                        	
 8909                        		.dbg	line,	"include\init.c", 228; level_object_number = OBJECT_NUMBER_LV1;
 8910                        		__st.umiq	23, _level_object_number
         01:CD22  A9 17      			lda.l	#23
         01:CD24  8D 21 23   			sta	_level_object_number
 8911                        	
 8912                        		.dbg	line,	"include\init.c", 229; level_chest_number = CHEST_NUMBER_LV1;
 8913                        		__st.umiq	2, _level_chest_number
         01:CD27  A9 02      			lda.l	#2
         01:CD29  8D 90 23   			sta	_level_chest_number
 8914                        	
 8915                        		.dbg	line,	"include\init.c", 230; level_npc_number = NPC_NUMBER_LV1;
 8916                        		__st.umiq	2, _level_npc_number
         01:CD2C  A9 02      			lda.l	#2
         01:CD2E  8D A3 23   			sta	_level_npc_number
 8917                        	
 8918                        		.dbg	line,	"include\init.c", 231; object_start_index = OBJECT_START_INDEX_LV1;
 8919                        		__st.umiq	3, _object_start_index
         01:CD31  A9 03      			lda.l	#3
         01:CD33  8D 20 23   			sta	_object_start_index
 8920                        	
 8921                        		.dbg	line,	"include\init.c", 232; chest_start_index = CHEST_START_INDEX_LV1;
 8922                        		__st.umiq	26, _chest_start_index
         01:CD36  A9 1A      			lda.l	#26
         01:CD38  8D 8F 23   			sta	_chest_start_index
 8923                        	
 8924                        		.dbg	line,	"include\init.c", 233; npc_start_index = NPC_START_INDEX_LV1;
 8925                        		__st.umiq	28, _npc_start_index
         01:CD3B  A9 1C      			lda.l	#28
         01:CD3D  8D A2 23   			sta	_npc_start_index
 8926                        	
 8927                        		.dbg	line,	"include\init.c", 234; jump_ladder = FALSE;
 8928                        		__st.umiq	0, _jump_ladder
         01:CD40  9C 17 23   			stz	_jump_ladder
 8929                        	
 8930                        		.dbg	line,	"include\init.c", 239; //**************************************************************************************//
 8931                        	
 8932                        		.dbg	line,	"include\init.c", 240; //                                                                                      //
 8933                        	
 8934                        		.dbg	line,	"include\init.c", 241; //                                        VDC 2                                         //
 8935                        	
 8936                        		.dbg	line,	"include\init.c", 242; //                                                                                      //
 8937                        	
 8938                        		.dbg	line,	"include\init.c", 243; //**************************************************************************************//
 8939                        	
 8940                        		.dbg	line,	"include\init.c", 245; //--------------------------------------------------------------------------------------//
 8941                        	
 8942                        		.dbg	line,	"include\init.c", 246; //                                    LOAD TILESET                                      //
 8943                        	
 8944                        		.dbg	line,	"include\init.c", 247; //--------------------------------------------------------------------------------------//
 8945                        	
 8946                        		.dbg	line,	"include\init.c", 249; sgx_load_vram( 0x1000, tileset_LV1_BG_B, SIZEOF(tileset_LV1_BG_B) >> 1 );
 8947                        		__st.wmiq	4096, _di
         01:CD43  64 F0      			stz.l	_di
         01:CD45  A9 10      			lda.h	#4096
         01:CD47  85 F1      			sta.h	_di
 8948                        		__farptr	_tileset_LV1_BG_B, _bp_bank, _bp
         01:CD49  A9 C0      			lda.l	#$6000 + ($1FFF & (_tileset_LV1_BG_B))
         01:CD4B  85 EC      			sta.l	_bp
         01:CD4D  A9 6E      			lda.h	#$6000 + ($1FFF & (_tileset_LV1_BG_B))
         01:CD4F  85 ED      			sta.h	_bp
         01:CD51  A9 03      			lda	#bank(_tileset_LV1_BG_B)
         01:CD53  85 02      			sta	_bp_bank
 8949                        		__ld.wi		___sizeof__tileset_LV1_BG_B
         01:CD55  A9 E0      			lda.l	#___sizeof__tileset_LV1_BG_B
         01:CD57  A0 72      			ldy.h	#___sizeof__tileset_LV1_BG_B
 8950                        		__lsr.wi	1
         01:CD59  42         			say
         01:CD5A  4A         			lsr	a
         01:CD5B  42         			say
         01:CD5C  6A         			ror	a
 8951                        		__st.wmq	_ax
         01:CD5D  85 F8      			sta.l	_ax
         01:CD5F  84 F9      			sty.h	_ax
 8952                        		 _sgx_load_vram.3
         01:CD61  A2 10      			ldx	#SGX_VDC_OFFSET		; Offset to SGX VDC.
         01:CD63  20 63 FF   			call	load_vram_x
 8953                        	
 8954                        		.dbg	line,	"include\init.c", 252; //--------------------------------------------------------------------------------------//
 8955                        	
 8956                        		.dbg	line,	"include\init.c", 253; //                               LOAD WALL & DOOR TILES                                 //
 8957                        	
 8958                        		.dbg	line,	"include\init.c", 254; //--------------------------------------------------------------------------------------//
 8959                        	
 8960                        		.dbg	line,	"include\init.c", 256; sgx_load_vram( LV1_WALL_VRAM_ADR, tileset_LV1_WALL, SIZEOF(tileset_LV1_WALL) >> 1 );
 8961                        		__st.wmiq	4096, _di
         01:CD66  64 F0      			stz.l	_di
         01:CD68  A9 10      			lda.h	#4096
         01:CD6A  85 F1      			sta.h	_di
 8962                        		__farptr	_tileset_LV1_WALL, _bp_bank, _bp
         01:CD6C  A9 40      			lda.l	#$6000 + ($1FFF & (_tileset_LV1_WALL))
         01:CD6E  85 EC      			sta.l	_bp
         01:CD70  A9 61      			lda.h	#$6000 + ($1FFF & (_tileset_LV1_WALL))
         01:CD72  85 ED      			sta.h	_bp
         01:CD74  A9 03      			lda	#bank(_tileset_LV1_WALL)
         01:CD76  85 02      			sta	_bp_bank
 8963                        		__ld.wi		___sizeof__tileset_LV1_WALL
         01:CD78  A9 00      			lda.l	#___sizeof__tileset_LV1_WALL
         01:CD7A  A0 02      			ldy.h	#___sizeof__tileset_LV1_WALL
 8964                        		__lsr.wi	1
         01:CD7C  42         			say
         01:CD7D  4A         			lsr	a
         01:CD7E  42         			say
         01:CD7F  6A         			ror	a
 8965                        		__st.wmq	_ax
         01:CD80  85 F8      			sta.l	_ax
         01:CD82  84 F9      			sty.h	_ax
 8966                        		 _sgx_load_vram.3
         01:CD84  A2 10      			ldx	#SGX_VDC_OFFSET		; Offset to SGX VDC.
         01:CD86  20 63 FF   			call	load_vram_x
 8967                        	
 8968                        		.dbg	line,	"include\init.c", 257; sgx_load_vram( LV1_DOOR_VRAM_ADR, tileset_LV1_DOOR_OPEN, SIZEOF(tileset_LV1_DOOR_OPEN) >> 1 );
 8969                        		__st.wmiq	4352, _di
         01:CD89  64 F0      			stz.l	_di
         01:CD8B  A9 11      			lda.h	#4352
         01:CD8D  85 F1      			sta.h	_di
 8970                        		__farptr	_tileset_LV1_DOOR_OPEN, _bp_bank, _bp
         01:CD8F  A9 40      			lda.l	#$6000 + ($1FFF & (_tileset_LV1_DOOR_OPEN))
         01:CD91  85 EC      			sta.l	_bp
         01:CD93  A9 63      			lda.h	#$6000 + ($1FFF & (_tileset_LV1_DOOR_OPEN))
         01:CD95  85 ED      			sta.h	_bp
         01:CD97  A9 03      			lda	#bank(_tileset_LV1_DOOR_OPEN)
         01:CD99  85 02      			sta	_bp_bank
 8971                        		__ld.wi		___sizeof__tileset_LV1_DOOR_OPEN
         01:CD9B  A9 00      			lda.l	#___sizeof__tileset_LV1_DOOR_OPEN
         01:CD9D  A0 03      			ldy.h	#___sizeof__tileset_LV1_DOOR_OPEN
 8972                        		__lsr.wi	1
         01:CD9F  42         			say
         01:CDA0  4A         			lsr	a
         01:CDA1  42         			say
         01:CDA2  6A         			ror	a
 8973                        		__st.wmq	_ax
         01:CDA3  85 F8      			sta.l	_ax
         01:CDA5  84 F9      			sty.h	_ax
 8974                        		 _sgx_load_vram.3
         01:CDA7  A2 10      			ldx	#SGX_VDC_OFFSET		; Offset to SGX VDC.
         01:CDA9  20 63 FF   			call	load_vram_x
 8975                        	
 8976                        		.dbg	line,	"include\init.c", 260; //--------------------------------------------------------------------------------------//
 8977                        	
 8978                        		.dbg	line,	"include\init.c", 261; //                                     SET MULTIMAP                                     //
 8979                        	
 8980                        		.dbg	line,	"include\init.c", 262; //--------------------------------------------------------------------------------------//
 8981                        	
 8982                        		.dbg	line,	"include\init.c", 264; // multimap is 2 screens wide //
 8983                        	
 8984                        		.dbg	line,	"include\init.c", 265; sgx_set_multimap( multimap_LV1_BG_B , 5 );
 8985                        		__farptr	_multimap_LV1_BG_B, sgx_scr_bank, sgx_scr_addr
         01:CDAC  A9 00      			lda.l	#$6000 + ($1FFF & (_multimap_LV1_BG_B))
         01:CDAE  8D 93 2A   			sta.l	sgx_scr_addr
         01:CDB1  A9 71      			lda.h	#$6000 + ($1FFF & (_multimap_LV1_BG_B))
         01:CDB3  8D 94 2A   			sta.h	sgx_scr_addr
         01:CDB6  A9 09      			lda	#bank(_multimap_LV1_BG_B)
         01:CDB8  8D 95 2A   			sta	sgx_scr_bank
 8986                        		__st.umiq	5, sgx_map_scrn_w
         01:CDBB  A9 05      			lda.l	#5
         01:CDBD  8D 54 25   			sta	sgx_map_scrn_w
 8987                        		 _sgx_set_multimap.2
         01:CDC0  AD 4C 25   			lda	sgx_bat_width
         01:CDC3  4A         			lsr	a
         01:CDC4  8D 53 25   			sta	sgx_map_line_w
 8988                        	
 8989                        		.dbg	line,	"include\init.c", 268; //--------------------------------------------------------------------------------------//
 8990                        	
 8991                        		.dbg	line,	"include\init.c", 269; //                                    DRAW TILEMAP                                      //
 8992                        	
 8993                        		.dbg	line,	"include\init.c", 270; //--------------------------------------------------------------------------------------//
 8994                        	
 8995                        		.dbg	line,	"include\init.c", 272; // The blkmap is drawn using global variables for the top-left coordinate
 8996                        	
 8997                        		.dbg	line,	"include\init.c", 273; // in pixels, and the draw width and height in terms of 8x8 characters.
 8998                        	
 8999                        		.dbg	line,	"include\init.c", 275; sgx_map_pxl_x = 96;
 9000                        		__st.wmiq	96, _sgx_map_pxl_x
         01:CDC7  A9 60      			lda.l	#96
         01:CDC9  8D 55 25   			sta.l	_sgx_map_pxl_x
         01:CDCC  9C 56 25   			stz.h	_sgx_map_pxl_x
 9001                        	
 9002                        		.dbg	line,	"include\init.c", 276; sgx_map_pxl_y = 768;
 9003                        		__st.wmiq	768, _sgx_map_pxl_y
         01:CDCF  9C 57 25   			stz.l	_sgx_map_pxl_y
         01:CDD2  A9 03      			lda.h	#768
         01:CDD4  8D 58 25   			sta.h	_sgx_map_pxl_y
 9004                        	
 9005                        		.dbg	line,	"include\init.c", 278; sgx_map_draw_w = 63;
 9006                        		__st.umiq	63, _sgx_map_draw_w
         01:CDD7  A9 3F      			lda.l	#63
         01:CDD9  8D 51 25   			sta	_sgx_map_draw_w
 9007                        	
 9008                        		.dbg	line,	"include\init.c", 279; sgx_map_draw_h = 29;
 9009                        		__st.umiq	29, _sgx_map_draw_h
         01:CDDC  A9 1D      			lda.l	#29
         01:CDDE  8D 52 25   			sta	_sgx_map_draw_h
 9010                        	
 9011                        		.dbg	line,	"include\init.c", 281; sgx_draw_map();
 9012                        		__call		_sgx_draw_map
         01:CDE1  20 31 FF   			call	_sgx_draw_map
 9013                        	
 9014                        		.dbg	line,	"include\init.c", 286; //**************************************************************************************//
 9015                        	
 9016                        		.dbg	line,	"include\init.c", 287; //                                                                                      //
 9017                        	
 9018                        		.dbg	line,	"include\init.c", 288; //                                        VDC 1                                         //
 9019                        	
 9020                        		.dbg	line,	"include\init.c", 289; //                                                                                      //
 9021                        	
 9022                        		.dbg	line,	"include\init.c", 290; //**************************************************************************************//
 9023                        	
 9024                        		.dbg	line,	"include\init.c", 292; //--------------------------------------------------------------------------------------//
 9025                        	
 9026                        		.dbg	line,	"include\init.c", 293; //                                      LOAD FONT                                       //
 9027                        	
 9028                        		.dbg	line,	"include\init.c", 294; //--------------------------------------------------------------------------------------//
 9029                        	
 9030                        		.dbg	line,	"include\init.c", 296; load_vram( NUMBERS_FONT_VRAM_ADR, tileset_NUMBERS_FONT, SIZEOF(tileset_NUMBERS_FONT) >> 1 );
 9031                        		__st.wmiq	2304, _di
         01:CDE4  64 F0      			stz.l	_di
         01:CDE6  A9 09      			lda.h	#2304
         01:CDE8  85 F1      			sta.h	_di
 9032                        		__farptr	_tileset_NUMBERS_FONT, _bp_bank, _bp
         01:CDEA  A9 00      			lda.l	#$6000 + ($1FFF & (_tileset_NUMBERS_FONT))
         01:CDEC  85 EC      			sta.l	_bp
         01:CDEE  A9 60      			lda.h	#$6000 + ($1FFF & (_tileset_NUMBERS_FONT))
         01:CDF0  85 ED      			sta.h	_bp
         01:CDF2  A9 03      			lda	#bank(_tileset_NUMBERS_FONT)
         01:CDF4  85 02      			sta	_bp_bank
 9033                        		__ld.wi		___sizeof__tileset_NUMBERS_FONT
         01:CDF6  A9 40      			lda.l	#___sizeof__tileset_NUMBERS_FONT
         01:CDF8  A0 01      			ldy.h	#___sizeof__tileset_NUMBERS_FONT
 9034                        		__lsr.wi	1
         01:CDFA  42         			say
         01:CDFB  4A         			lsr	a
         01:CDFC  42         			say
         01:CDFD  6A         			ror	a
 9035                        		__st.wmq	_ax
         01:CDFE  85 F8      			sta.l	_ax
         01:CE00  84 F9      			sty.h	_ax
 9036                        		 _load_vram.3
         01:CE02  82         			clx				; Offset to PCE VDC.
         01:CE03  20 63 FF   			call	load_vram_x
 9037                        	
 9038                        		.dbg	line,	"include\init.c", 298; set_font_pal(15);
 9039                        		__ld.uiq	15
         01:CE06  A9 0F      			lda	#15
 9040                        		__call		_set_font_pal.1
         01:CE08  20 09 E6   			call	_set_font_pal.1
 9041                        	
 9042                        		.dbg	line,	"include\init.c", 301; //--------------------------------------------------------------------------------------//
 9043                        	
 9044                        		.dbg	line,	"include\init.c", 302; //                                    LOAD TILESET                                      //
 9045                        	
 9046                        		.dbg	line,	"include\init.c", 303; //--------------------------------------------------------------------------------------//
 9047                        	
 9048                        		.dbg	line,	"include\init.c", 305; load_vram( 0x1000, tileset_LV1_BG_A, SIZEOF(tileset_LV1_BG_A) >> 1 );
 9049                        		__st.wmiq	4096, _di
         01:CE0B  64 F0      			stz.l	_di
         01:CE0D  A9 10      			lda.h	#4096
         01:CE0F  85 F1      			sta.h	_di
 9050                        		__farptr	_tileset_LV1_BG_A, _bp_bank, _bp
         01:CE11  A9 A0      			lda.l	#$6000 + ($1FFF & (_tileset_LV1_BG_A))
         01:CE13  85 EC      			sta.l	_bp
         01:CE15  A9 71      			lda.h	#$6000 + ($1FFF & (_tileset_LV1_BG_A))
         01:CE17  85 ED      			sta.h	_bp
         01:CE19  A9 09      			lda	#bank(_tileset_LV1_BG_A)
         01:CE1B  85 02      			sta	_bp_bank
 9051                        		__ld.wi		___sizeof__tileset_LV1_BG_A
         01:CE1D  A9 E0      			lda.l	#___sizeof__tileset_LV1_BG_A
         01:CE1F  A0 06      			ldy.h	#___sizeof__tileset_LV1_BG_A
 9052                        		__lsr.wi	1
         01:CE21  42         			say
         01:CE22  4A         			lsr	a
         01:CE23  42         			say
         01:CE24  6A         			ror	a
 9053                        		__st.wmq	_ax
         01:CE25  85 F8      			sta.l	_ax
         01:CE27  84 F9      			sty.h	_ax
 9054                        		 _load_vram.3
         01:CE29  82         			clx				; Offset to PCE VDC.
         01:CE2A  20 63 FF   			call	load_vram_x
 9055                        	
 9056                        		.dbg	line,	"include\init.c", 308; //--------------------------------------------------------------------------------------//
 9057                        	
 9058                        		.dbg	line,	"include\init.c", 309; //                                 LOAD LIFABAR TILES                                   //
 9059                        	
 9060                        		.dbg	line,	"include\init.c", 310; //--------------------------------------------------------------------------------------//
 9061                        	
 9062                        		.dbg	line,	"include\init.c", 312; load_vram( LIFEBAR_1_VRAM_ADR, tileset_LIFE_RED, SIZEOF(tileset_LIFE_RED) >> 1 );
 9063                        		__st.wmiq	4096, _di
         01:CE2D  64 F0      			stz.l	_di
         01:CE2F  A9 10      			lda.h	#4096
         01:CE31  85 F1      			sta.h	_di
 9064                        		__farptr	_tileset_LIFE_RED, _bp_bank, _bp
         01:CE33  A9 40      			lda.l	#$6000 + ($1FFF & (_tileset_LIFE_RED))
         01:CE35  85 EC      			sta.l	_bp
         01:CE37  A9 69      			lda.h	#$6000 + ($1FFF & (_tileset_LIFE_RED))
         01:CE39  85 ED      			sta.h	_bp
         01:CE3B  A9 03      			lda	#bank(_tileset_LIFE_RED)
         01:CE3D  85 02      			sta	_bp_bank
 9065                        		__ld.wi		___sizeof__tileset_LIFE_RED
         01:CE3F  A9 40      			lda.l	#___sizeof__tileset_LIFE_RED
         01:CE41  A0 00      			ldy.h	#___sizeof__tileset_LIFE_RED
 9066                        		__lsr.wi	1
         01:CE43  42         			say
         01:CE44  4A         			lsr	a
         01:CE45  42         			say
         01:CE46  6A         			ror	a
 9067                        		__st.wmq	_ax
         01:CE47  85 F8      			sta.l	_ax
         01:CE49  84 F9      			sty.h	_ax
 9068                        		 _load_vram.3
         01:CE4B  82         			clx				; Offset to PCE VDC.
         01:CE4C  20 63 FF   			call	load_vram_x
 9069                        	
 9070                        		.dbg	line,	"include\init.c", 313; load_vram( LIFEBAR_2_VRAM_ADR, tileset_LIFE_ORANGE, SIZEOF(tileset_LIFE_ORANGE) >> 1 );
 9071                        		__st.wmiq	4128, _di
         01:CE4F  A9 20      			lda.l	#4128
         01:CE51  85 F0      			sta.l	_di
         01:CE53  A9 10      			lda.h	#4128
         01:CE55  85 F1      			sta.h	_di
 9072                        		__farptr	_tileset_LIFE_ORANGE, _bp_bank, _bp
         01:CE57  A9 80      			lda.l	#$6000 + ($1FFF & (_tileset_LIFE_ORANGE))
         01:CE59  85 EC      			sta.l	_bp
         01:CE5B  A9 69      			lda.h	#$6000 + ($1FFF & (_tileset_LIFE_ORANGE))
         01:CE5D  85 ED      			sta.h	_bp
         01:CE5F  A9 03      			lda	#bank(_tileset_LIFE_ORANGE)
         01:CE61  85 02      			sta	_bp_bank
 9073                        		__ld.wi		___sizeof__tileset_LIFE_ORANGE
         01:CE63  A9 40      			lda.l	#___sizeof__tileset_LIFE_ORANGE
         01:CE65  A0 00      			ldy.h	#___sizeof__tileset_LIFE_ORANGE
 9074                        		__lsr.wi	1
         01:CE67  42         			say
         01:CE68  4A         			lsr	a
         01:CE69  42         			say
         01:CE6A  6A         			ror	a
 9075                        		__st.wmq	_ax
         01:CE6B  85 F8      			sta.l	_ax
         01:CE6D  84 F9      			sty.h	_ax
 9076                        		 _load_vram.3
         01:CE6F  82         			clx				; Offset to PCE VDC.
         01:CE70  20 63 FF   			call	load_vram_x
 9077                        	
 9078                        		.dbg	line,	"include\init.c", 314; load_vram( LIFEBAR_3_VRAM_ADR, tileset_LIFE_YELLOW, SIZEOF(tileset_LIFE_YELLOW) >> 1 );
 9079                        		__st.wmiq	4160, _di
         01:CE73  A9 40      			lda.l	#4160
         01:CE75  85 F0      			sta.l	_di
         01:CE77  A9 10      			lda.h	#4160
         01:CE79  85 F1      			sta.h	_di
 9080                        		__farptr	_tileset_LIFE_YELLOW, _bp_bank, _bp
         01:CE7B  A9 C0      			lda.l	#$6000 + ($1FFF & (_tileset_LIFE_YELLOW))
         01:CE7D  85 EC      			sta.l	_bp
         01:CE7F  A9 69      			lda.h	#$6000 + ($1FFF & (_tileset_LIFE_YELLOW))
         01:CE81  85 ED      			sta.h	_bp
         01:CE83  A9 03      			lda	#bank(_tileset_LIFE_YELLOW)
         01:CE85  85 02      			sta	_bp_bank
 9081                        		__ld.wi		___sizeof__tileset_LIFE_YELLOW
         01:CE87  A9 40      			lda.l	#___sizeof__tileset_LIFE_YELLOW
         01:CE89  A0 00      			ldy.h	#___sizeof__tileset_LIFE_YELLOW
 9082                        		__lsr.wi	1
         01:CE8B  42         			say
         01:CE8C  4A         			lsr	a
         01:CE8D  42         			say
         01:CE8E  6A         			ror	a
 9083                        		__st.wmq	_ax
         01:CE8F  85 F8      			sta.l	_ax
         01:CE91  84 F9      			sty.h	_ax
 9084                        		 _load_vram.3
         01:CE93  82         			clx				; Offset to PCE VDC.
         01:CE94  20 63 FF   			call	load_vram_x
 9085                        	
 9086                        		.dbg	line,	"include\init.c", 315; load_vram( LIFEBAR_4_VRAM_ADR, tileset_LIFE_YELLOW, SIZEOF(tileset_LIFE_YELLOW) >> 1 );
 9087                        		__st.wmiq	4192, _di
         01:CE97  A9 60      			lda.l	#4192
         01:CE99  85 F0      			sta.l	_di
         01:CE9B  A9 10      			lda.h	#4192
         01:CE9D  85 F1      			sta.h	_di
 9088                        		__farptr	_tileset_LIFE_YELLOW, _bp_bank, _bp
         01:CE9F  A9 C0      			lda.l	#$6000 + ($1FFF & (_tileset_LIFE_YELLOW))
         01:CEA1  85 EC      			sta.l	_bp
         01:CEA3  A9 69      			lda.h	#$6000 + ($1FFF & (_tileset_LIFE_YELLOW))
         01:CEA5  85 ED      			sta.h	_bp
         01:CEA7  A9 03      			lda	#bank(_tileset_LIFE_YELLOW)
         01:CEA9  85 02      			sta	_bp_bank
 9089                        		__ld.wi		___sizeof__tileset_LIFE_YELLOW
         01:CEAB  A9 40      			lda.l	#___sizeof__tileset_LIFE_YELLOW
         01:CEAD  A0 00      			ldy.h	#___sizeof__tileset_LIFE_YELLOW
 9090                        		__lsr.wi	1
         01:CEAF  42         			say
         01:CEB0  4A         			lsr	a
         01:CEB1  42         			say
         01:CEB2  6A         			ror	a
 9091                        		__st.wmq	_ax
         01:CEB3  85 F8      			sta.l	_ax
         01:CEB5  84 F9      			sty.h	_ax
 9092                        		 _load_vram.3
         01:CEB7  82         			clx				; Offset to PCE VDC.
         01:CEB8  20 63 FF   			call	load_vram_x
 9093                        	
 9094                        		.dbg	line,	"include\init.c", 316; load_vram( LIFEBAR_5_VRAM_ADR, tileset_LIFE_EMPTY, SIZEOF(tileset_LIFE_EMPTY) >> 1 );
 9095                        		__st.wmiq	4224, _di
         01:CEBB  A9 80      			lda.l	#4224
         01:CEBD  85 F0      			sta.l	_di
         01:CEBF  A9 10      			lda.h	#4224
         01:CEC1  85 F1      			sta.h	_di
 9096                        		__farptr	_tileset_LIFE_EMPTY, _bp_bank, _bp
         01:CEC3  A9 00      			lda.l	#$6000 + ($1FFF & (_tileset_LIFE_EMPTY))
         01:CEC5  85 EC      			sta.l	_bp
         01:CEC7  A9 6A      			lda.h	#$6000 + ($1FFF & (_tileset_LIFE_EMPTY))
         01:CEC9  85 ED      			sta.h	_bp
         01:CECB  A9 03      			lda	#bank(_tileset_LIFE_EMPTY)
         01:CECD  85 02      			sta	_bp_bank
 9097                        		__ld.wi		___sizeof__tileset_LIFE_EMPTY
         01:CECF  A9 40      			lda.l	#___sizeof__tileset_LIFE_EMPTY
         01:CED1  A0 00      			ldy.h	#___sizeof__tileset_LIFE_EMPTY
 9098                        		__lsr.wi	1
         01:CED3  42         			say
         01:CED4  4A         			lsr	a
         01:CED5  42         			say
         01:CED6  6A         			ror	a
 9099                        		__st.wmq	_ax
         01:CED7  85 F8      			sta.l	_ax
         01:CED9  84 F9      			sty.h	_ax
 9100                        		 _load_vram.3
         01:CEDB  82         			clx				; Offset to PCE VDC.
         01:CEDC  20 63 FF   			call	load_vram_x
 9101                        	
 9102                        		.dbg	line,	"include\init.c", 319; //--------------------------------------------------------------------------------------//
 9103                        	
 9104                        		.dbg	line,	"include\init.c", 320; //                               LOAD WEAPON + ARMOR TILES                              //
 9105                        	
 9106                        		.dbg	line,	"include\init.c", 321; //--------------------------------------------------------------------------------------//
 9107                        	
 9108                        		.dbg	line,	"include\init.c", 323; load_vram( WEAPON_VRAM_ADR, tileset_WEAPON_1, SIZEOF(tileset_WEAPON_1) >> 1 );
 9109                        		__st.wmiq	4256, _di
         01:CEDF  A9 A0      			lda.l	#4256
         01:CEE1  85 F0      			sta.l	_di
         01:CEE3  A9 10      			lda.h	#4256
         01:CEE5  85 F1      			sta.h	_di
 9110                        		__farptr	_tileset_WEAPON_1, _bp_bank, _bp
         01:CEE7  A9 40      			lda.l	#$6000 + ($1FFF & (_tileset_WEAPON_1))
         01:CEE9  85 EC      			sta.l	_bp
         01:CEEB  A9 6C      			lda.h	#$6000 + ($1FFF & (_tileset_WEAPON_1))
         01:CEED  85 ED      			sta.h	_bp
         01:CEEF  A9 03      			lda	#bank(_tileset_WEAPON_1)
         01:CEF1  85 02      			sta	_bp_bank
 9111                        		__ld.wi		___sizeof__tileset_WEAPON_1
         01:CEF3  A9 80      			lda.l	#___sizeof__tileset_WEAPON_1
         01:CEF5  A0 00      			ldy.h	#___sizeof__tileset_WEAPON_1
 9112                        		__lsr.wi	1
         01:CEF7  42         			say
         01:CEF8  4A         			lsr	a
         01:CEF9  42         			say
         01:CEFA  6A         			ror	a
 9113                        		__st.wmq	_ax
         01:CEFB  85 F8      			sta.l	_ax
         01:CEFD  84 F9      			sty.h	_ax
 9114                        		 _load_vram.3
         01:CEFF  82         			clx				; Offset to PCE VDC.
         01:CF00  20 63 FF   			call	load_vram_x
 9115                        	
 9116                        		.dbg	line,	"include\init.c", 324; load_vram( ARMOR_VRAM_ADR, tileset_ARMOR_2, SIZEOF(tileset_ARMOR_2) >> 1 );
 9117                        		__st.wmiq	4320, _di
         01:CF03  A9 E0      			lda.l	#4320
         01:CF05  85 F0      			sta.l	_di
         01:CF07  A9 10      			lda.h	#4320
         01:CF09  85 F1      			sta.h	_di
 9118                        		__farptr	_tileset_ARMOR_2, _bp_bank, _bp
         01:CF0B  A9 C0      			lda.l	#$6000 + ($1FFF & (_tileset_ARMOR_2))
         01:CF0D  85 EC      			sta.l	_bp
         01:CF0F  A9 6A      			lda.h	#$6000 + ($1FFF & (_tileset_ARMOR_2))
         01:CF11  85 ED      			sta.h	_bp
         01:CF13  A9 03      			lda	#bank(_tileset_ARMOR_2)
         01:CF15  85 02      			sta	_bp_bank
 9119                        		__ld.wi		___sizeof__tileset_ARMOR_2
         01:CF17  A9 80      			lda.l	#___sizeof__tileset_ARMOR_2
         01:CF19  A0 00      			ldy.h	#___sizeof__tileset_ARMOR_2
 9120                        		__lsr.wi	1
         01:CF1B  42         			say
         01:CF1C  4A         			lsr	a
         01:CF1D  42         			say
         01:CF1E  6A         			ror	a
 9121                        		__st.wmq	_ax
         01:CF1F  85 F8      			sta.l	_ax
         01:CF21  84 F9      			sty.h	_ax
 9122                        		 _load_vram.3
         01:CF23  82         			clx				; Offset to PCE VDC.
         01:CF24  20 63 FF   			call	load_vram_x
 9123                        	
 9124                        		.dbg	line,	"include\init.c", 327; //--------------------------------------------------------------------------------------//
 9125                        	
 9126                        		.dbg	line,	"include\init.c", 328; //                                     SET MULTIMAP                                     //
 9127                        	
 9128                        		.dbg	line,	"include\init.c", 329; //--------------------------------------------------------------------------------------//
 9129                        	
 9130                        		.dbg	line,	"include\init.c", 331; // multimap is 2 screens wide //
 9131                        	
 9132                        		.dbg	line,	"include\init.c", 332; set_multimap( multimap_LV1_BG_A , 5 );
 9133                        		__farptr	_multimap_LV1_BG_A, vdc_scr_bank, vdc_scr_addr
         01:CF27  A9 00      			lda.l	#$6000 + ($1FFF & (_multimap_LV1_BG_A))
         01:CF29  8D 83 2A   			sta.l	vdc_scr_addr
         01:CF2C  A9 78      			lda.h	#$6000 + ($1FFF & (_multimap_LV1_BG_A))
         01:CF2E  8D 84 2A   			sta.h	vdc_scr_addr
         01:CF31  A9 0B      			lda	#bank(_multimap_LV1_BG_A)
         01:CF33  8D 85 2A   			sta	vdc_scr_bank
 9134                        		__st.umiq	5, vdc_map_scrn_w
         01:CF36  A9 05      			lda.l	#5
         01:CF38  8D 44 25   			sta	vdc_map_scrn_w
 9135                        		 _set_multimap.2
         01:CF3B  AD 3C 25   			lda	vdc_bat_width
         01:CF3E  4A         			lsr	a
         01:CF3F  8D 43 25   			sta	vdc_map_line_w
 9136                        	
 9137                        		.dbg	line,	"include\init.c", 335; //--------------------------------------------------------------------------------------//
 9138                        	
 9139                        		.dbg	line,	"include\init.c", 336; //                                    DRAW TILEMAP                                      //
 9140                        	
 9141                        		.dbg	line,	"include\init.c", 337; //--------------------------------------------------------------------------------------//
 9142                        	
 9143                        		.dbg	line,	"include\init.c", 339; // The blkmap is drawn using global variables for the top-left coordinate
 9144                        	
 9145                        		.dbg	line,	"include\init.c", 340; // in pixels, and the draw width and height in terms of 8x8 characters.
 9146                        	
 9147                        		.dbg	line,	"include\init.c", 342; vdc_map_pxl_x = 0;
 9148                        		__st.wmiq	0, _vdc_map_pxl_x
         01:CF42  9C 45 25   			stz.l	_vdc_map_pxl_x
         01:CF45  9C 46 25   			stz.h	_vdc_map_pxl_x
 9149                        	
 9150                        		.dbg	line,	"include\init.c", 343; vdc_map_pxl_y = 0;
 9151                        		__st.wmiq	0, _vdc_map_pxl_y
         01:CF48  9C 47 25   			stz.l	_vdc_map_pxl_y
         01:CF4B  9C 48 25   			stz.h	_vdc_map_pxl_y
 9152                        	
 9153                        		.dbg	line,	"include\init.c", 345; vdc_map_draw_w = 32;
 9154                        		__st.umiq	32, _vdc_map_draw_w
         01:CF4E  A9 20      			lda.l	#32
         01:CF50  8D 41 25   			sta	_vdc_map_draw_w
 9155                        	
 9156                        		.dbg	line,	"include\init.c", 346; vdc_map_draw_h = 28;
 9157                        		__st.umiq	28, _vdc_map_draw_h
         01:CF53  A9 1C      			lda.l	#28
         01:CF55  8D 42 25   			sta	_vdc_map_draw_h
 9158                        	
 9159                        		.dbg	line,	"include\init.c", 348; draw_map();
 9160                        		__call		_draw_map
         01:CF58  20 27 FF   			call	_draw_map
 9161                        	
 9162                        		.dbg	line,	"include\init.c", 350; display_KEY();
 9163                        		__call		_display_KEY
         01:CF5B  20 8B FF   			call	_display_KEY
 9164                        	
 9165                        		.dbg	line,	"include\init.c", 351; display_POTION();
 9166                        		__call		_display_POTION
         01:CF5E  20 1D FF   			call	_display_POTION
 9167                        	
 9168                        		.dbg	line,	"include\init.c", 352; display_ZENNY();
 9169                        		__call		_display_ZENNY
         01:CF61  20 13 FF   			call	_display_ZENNY
 9170                        	
 9171                        		.dbg	line,	"include\init.c", 357; //**************************************************************************************//
 9172                        	
 9173                        		.dbg	line,	"include\init.c", 358; //                                                                                      //
 9174                        	
 9175                        		.dbg	line,	"include\init.c", 359; //                                  SETUP SCROLL_SPLIT                                  //
 9176                        	
 9177                        		.dbg	line,	"include\init.c", 360; //                                                                                      //
 9178                        	
 9179                        		.dbg	line,	"include\init.c", 361; //**************************************************************************************//
 9180                        	
 9181                        		.dbg	line,	"include\init.c", 363; //--------------------------------------------------------------------------------------//
 9182                        	
 9183                        		.dbg	line,	"include\init.c", 364; //                                        VDC 2                                         //
 9184                        	
 9185                        		.dbg	line,	"include\init.c", 365; //--------------------------------------------------------------------------------------//
 9186                        	
 9187                        		.dbg	line,	"include\init.c", 367; sgx_scroll_map();
 9188                        		__call		_sgx_scroll_map
         01:CF64  20 81 FF   			call	_sgx_scroll_map
 9189                        	
 9190                        		.dbg	line,	"include\init.c", 369; sgx_scroll_split(0,   0, sgx_map_pxl_x & (BAT_SIZE_W - 1), sgx_map_pxl_y & (BAT_SIZE_H - 1), BKG_ON | SPR_ON);
 9191                        		__st.umiq	0, _al
         01:CF67  64 F8      			stz	_al
 9192                        		__st.umiq	0, _ah
         01:CF69  64 F9      			stz	_ah
 9193                        		__ld.wm		_sgx_map_pxl_x
         01:CF6B  AD 55 25   			lda.l	_sgx_map_pxl_x
         01:CF6E  AC 56 25   			ldy.h	_sgx_map_pxl_x
 9194                        		__and.wi	2047
         01:CF71  29 FF      			and.l	#2047
         01:CF73  42         			say
         01:CF74  29 07      			and.h	#2047
         01:CF76  42         			say
 9195                        		__st.wmq	_bx
         01:CF77  85 FA      			sta.l	_bx
         01:CF79  84 FB      			sty.h	_bx
 9196                        		__ld.wm		_sgx_map_pxl_y
         01:CF7B  AD 57 25   			lda.l	_sgx_map_pxl_y
         01:CF7E  AC 58 25   			ldy.h	_sgx_map_pxl_y
 9197                        		__and.wi	255
         01:CF81  29 FF      			and	#255
         01:CF83  C2         			cly
 9198                        		__st.wmq	_cx
         01:CF84  85 FC      			sta.l	_cx
         01:CF86  84 FD      			sty.h	_cx
 9199                        		__st.umiq	192, _dl
         01:CF88  A9 C0      			lda.l	#192
         01:CF8A  85 FE      			sta	_dl
 9200                        		__call		_sgx_scroll_split.5
         01:CF8C  20 77 FF   			call	_sgx_scroll_split.5
 9201                        	
 9202                        		.dbg	line,	"include\init.c", 374; //--------------------------------------------------------------------------------------//
 9203                        	
 9204                        		.dbg	line,	"include\init.c", 375; //                                   LOAD BG PALETTES                                   //
 9205                        	
 9206                        		.dbg	line,	"include\init.c", 376; //--------------------------------------------------------------------------------------//
 9207                        	
 9208                        		.dbg	line,	"include\init.c", 378; // LOAD ALL PALETTES AT BG PALETTE 0 //
 9209                        	
 9210                        		.dbg	line,	"include\init.c", 379; load_palette( 0, palette_LV1, 16 );
 9211                        		__st.umiq	0, _al
         01:CF8F  64 F8      			stz	_al
 9212                        		__farptr	_palette_LV1, _bp_bank, _bp
         01:CF91  A9 A0      			lda.l	#$6000 + ($1FFF & (_palette_LV1))
         01:CF93  85 EC      			sta.l	_bp
         01:CF95  A9 78      			lda.h	#$6000 + ($1FFF & (_palette_LV1))
         01:CF97  85 ED      			sta.h	_bp
         01:CF99  A9 0B      			lda	#bank(_palette_LV1)
         01:CF9B  85 02      			sta	_bp_bank
 9213                        		__st.umiq	16, _ah
         01:CF9D  A9 10      			lda.l	#16
         01:CF9F  85 F9      			sta	_ah
 9214                        		__call		_load_palette.3
         01:CFA1  20 09 FF   			call	_load_palette.3
 9215                        	
 9216                        		.dbg	line,	"include\init.c", 384; //**************************************************************************************//
 9217                        	
 9218                        		.dbg	line,	"include\init.c", 385; //                                                                                      //
 9219                        	
 9220                        		.dbg	line,	"include\init.c", 386; //                                       SPRITES                                        //
 9221                        	
 9222                        		.dbg	line,	"include\init.c", 387; //                                                                                      //
 9223                        	
 9224                        		.dbg	line,	"include\init.c", 388; //**************************************************************************************//
 9225                        	
 9226                        		.dbg	line,	"include\init.c", 390; //--------------------------------------------------------------------------------------//
 9227                        	
 9228                        		.dbg	line,	"include\init.c", 391; //                                        PLAYER                                        //
 9229                        	
 9230                        		.dbg	line,	"include\init.c", 392; //--------------------------------------------------------------------------------------//
 9231                        	
 9232                        		.dbg	line,	"include\init.c", 394; // LOAD PLAYER TILES //
 9233                        	
 9234                        		.dbg	line,	"include\init.c", 395; // 0x2000
 9235                        	
 9236                        		.dbg	line,	"include\init.c", 396; // 32 TILES = 512 //
 9237                        	
 9238                        		.dbg	line,	"include\init.c", 397; // LOAD PLAYER FIRST FRAME OF ANIMATION (IDLE)
 9239                        	
 9240                        		.dbg	line,	"include\init.c", 398; load_vram(PLAYER_VRAM_ADR, tiles_SPR_PLAYER , TILES_16);
 9241                        		__st.wmiq	6144, _di
         01:CFA4  64 F0      			stz.l	_di
         01:CFA6  A9 18      			lda.h	#6144
         01:CFA8  85 F1      			sta.h	_di
 9242                        		__farptr	_tiles_SPR_PLAYER, _bp_bank, _bp
         01:CFAA  A9 A0      			lda.l	#$6000 + ($1FFF & (_tiles_SPR_PLAYER))
         01:CFAC  85 EC      			sta.l	_bp
         01:CFAE  A9 7A      			lda.h	#$6000 + ($1FFF & (_tiles_SPR_PLAYER))
         01:CFB0  85 ED      			sta.h	_bp
         01:CFB2  A9 0B      			lda	#bank(_tiles_SPR_PLAYER)
         01:CFB4  85 02      			sta	_bp_bank
 9243                        		__st.wmiq	256, _ax
         01:CFB6  64 F8      			stz.l	_ax
         01:CFB8  A9 01      			lda.h	#256
         01:CFBA  85 F9      			sta.h	_ax
 9244                        		 _load_vram.3
         01:CFBC  82         			clx				; Offset to PCE VDC.
         01:CFBD  20 63 FF   			call	load_vram_x
 9245                        	
 9246                        		.dbg	line,	"include\init.c", 401; // SELECT PLAYER CORE SPRITE //
 9247                        	
 9248                        		.dbg	line,	"include\init.c", 402; spr_set(player_id); // ID : 2
 9249                        		__ld.umq	_player_id
         01:CFC0  AD 10 23   			lda	_player_id
 9250                        		__call		_spr_set.1
         01:CFC3  20 DD E7   			call	_spr_set.1
 9251                        	
 9252                        		.dbg	line,	"include\init.c", 405; player_pos_x = 112;
 9253                        		__st.wmiq	112, _player_pos_x
         01:CFC6  A9 70      			lda.l	#112
         01:CFC8  8D B7 23   			sta.l	_player_pos_x
         01:CFCB  9C B8 23   			stz.h	_player_pos_x
 9254                        	
 9255                        		.dbg	line,	"include\init.c", 406; player_pos_y = PLAYER_BASE_Y_POS;
 9256                        		__st.wmiq	128, _player_pos_y
         01:CFCE  A9 80      			lda.l	#128
         01:CFD0  8D B9 23   			sta.l	_player_pos_y
         01:CFD3  9C BA 23   			stz.h	_player_pos_y
 9257                        	
 9258                        		.dbg	line,	"include\init.c", 409; spr_x(player_pos_x);
 9259                        		__ld.wm		_player_pos_x
         01:CFD6  AD B7 23   			lda.l	_player_pos_x
         01:CFD9  AC B8 23   			ldy.h	_player_pos_x
 9260                        		__call		_spr_x.1
         01:CFDC  20 0A E8   			call	_spr_x.1
 9261                        	
 9262                        		.dbg	line,	"include\init.c", 410; spr_y(player_pos_y);
 9263                        		__ld.wm		_player_pos_y
         01:CFDF  AD B9 23   			lda.l	_player_pos_y
         01:CFE2  AC BA 23   			ldy.h	_player_pos_y
 9264                        		__call		_spr_y.1
         01:CFE5  20 19 E8   			call	_spr_y.1
 9265                        	
 9266                        		.dbg	line,	"include\init.c", 412; // SET TILES DATA FOR THE PLAYER //
 9267                        	
 9268                        		.dbg	line,	"include\init.c", 413; spr_pattern(PLAYER_VRAM_ADR);
 9269                        		__ld.wi		6144
         01:CFE8  62         			cla
         01:CFE9  A0 18      			ldy.h	#6144
 9270                        		__call		_spr_pattern.1
         01:CFEB  20 26 E8   			call	_spr_pattern.1
 9271                        	
 9272                        		.dbg	line,	"include\init.c", 416; spr_ctrl(FLIP_MAS|SIZE_MAS, NO_FLIP|SZ_32x32);
 9273                        		__st.umiq	185, _al
         01:CFEE  A9 B9      			lda.l	#185
         01:CFF0  85 F8      			sta	_al
 9274                        		__ld.uiq	17
         01:CFF2  A9 11      			lda	#17
 9275                        		__call		_spr_ctrl.2
         01:CFF4  20 3C E8   			call	_spr_ctrl.2
 9276                        	
 9277                        		.dbg	line,	"include\init.c", 419; spr_pal(0);
 9278                        		__ld.uiq	0
         01:CFF7  62         			cla
 9279                        		__call		_spr_pal.1
         01:CFF8  20 4D E8   			call	_spr_pal.1
 9280                        	
 9281                        		.dbg	line,	"include\init.c", 420; spr_pri(TRUE);
 9282                        		__ld.uiq	1
         01:CFFB  A9 01      			lda	#1
 9283                        		__call		_spr_pri.1
         01:CFFD  20 5C E8   			call	_spr_pri.1
 9284                        	
 9285                        		.dbg	line,	"include\init.c", 423; //--------------------------------------------------------------------------------------//
 9286                        	
 9287                        		.dbg	line,	"include\init.c", 424; //                                       OBJECTS                                        //
 9288                        	
 9289                        		.dbg	line,	"include\init.c", 425; //--------------------------------------------------------------------------------------//
 9290                        	
 9291                        		.dbg	line,	"include\init.c", 427; load_OBJECT_TILES();
 9292                        		__call		_load_OBJECT_TILES
         01:D000  20 FF FE   			call	_load_OBJECT_TILES
 9293                        	
 9294                        		.dbg	line,	"include\init.c", 428; init_OBJECT_LV1();
 9295                        		__call		_init_OBJECT_LV1
         01:D003  20 F5 FE   			call	_init_OBJECT_LV1
 9296                        	
 9297                        		.dbg	line,	"include\init.c", 429; scroll_object();
 9298                        		__call		_scroll_object
         01:D006  20 EB FE   			call	_scroll_object
 9299                        	
 9300                        		.dbg	line,	"include\init.c", 432; //--------------------------------------------------------------------------------------//
 9301                        	
 9302                        		.dbg	line,	"include\init.c", 433; //                                        CHESTS                                        //
 9303                        	
 9304                        		.dbg	line,	"include\init.c", 434; //--------------------------------------------------------------------------------------//
 9305                        	
 9306                        		.dbg	line,	"include\init.c", 436; load_CHEST_TILES();
 9307                        		__call		_load_CHEST_TILES
         01:D009  20 E1 FE   			call	_load_CHEST_TILES
 9308                        	
 9309                        		.dbg	line,	"include\init.c", 437; init_CHEST_LV1();
 9310                        		__call		_init_CHEST_LV1
         01:D00C  20 D7 FE   			call	_init_CHEST_LV1
 9311                        	
 9312                        		.dbg	line,	"include\init.c", 438; scroll_chest();
 9313                        		__call		_scroll_chest
         01:D00F  20 CD FE   			call	_scroll_chest
 9314                        	
 9315                        		.dbg	line,	"include\init.c", 441; //--------------------------------------------------------------------------------------//
 9316                        	
 9317                        		.dbg	line,	"include\init.c", 442; //                                         NPCS                                         //
 9318                        	
 9319                        		.dbg	line,	"include\init.c", 443; //--------------------------------------------------------------------------------------//
 9320                        	
 9321                        		.dbg	line,	"include\init.c", 445; load_NPC_TILES();
 9322                        		__call		_load_NPC_TILES
         01:D012  20 C3 FE   			call	_load_NPC_TILES
 9323                        	
 9324                        		.dbg	line,	"include\init.c", 446; init_NPC_LV1();
 9325                        		__call		_init_NPC_LV1
         01:D015  20 B9 FE   			call	_init_NPC_LV1
 9326                        	
 9327                        		.dbg	line,	"include\init.c", 452; // UPDATE PCE SAT //
 9328                        	
 9329                        		.dbg	line,	"include\init.c", 453; satb_update();
 9330                        		__call		_satb_update
         01:D018  20 AF FE   			call	_satb_update
 9331                        	
 9332                        		.dbg	line,	"include\init.c", 458; //--------------------------------------------------------------------------------------//
 9333                        	
 9334                        		.dbg	line,	"include\init.c", 459; //                                LOAD SPRITES PALETTES                                 //
 9335                        	
 9336                        		.dbg	line,	"include\init.c", 460; //--------------------------------------------------------------------------------------//
 9337                        	
 9338                        		.dbg	line,	"include\init.c", 462; load_palette( 16, palette_PLAYER,    1 );
 9339                        		__st.umiq	16, _al
         01:D01B  A9 10      			lda.l	#16
         01:D01D  85 F8      			sta	_al
 9340                        		__farptr	_palette_PLAYER, _bp_bank, _bp
         01:D01F  A9 A0      			lda.l	#$6000 + ($1FFF & (_palette_PLAYER))
         01:D021  85 EC      			sta.l	_bp
         01:D023  A9 7A      			lda.h	#$6000 + ($1FFF & (_palette_PLAYER))
         01:D025  85 ED      			sta.h	_bp
         01:D027  A9 0C      			lda	#bank(_palette_PLAYER)
         01:D029  85 02      			sta	_bp_bank
 9341                        		__st.umiq	1, _ah
         01:D02B  A9 01      			lda.l	#1
         01:D02D  85 F9      			sta	_ah
 9342                        		__call		_load_palette.3
         01:D02F  20 09 FF   			call	_load_palette.3
 9343                        	
 9344                        		.dbg	line,	"include\init.c", 463; load_palette( 17, palette_objects_1, 1 );
 9345                        		__st.umiq	17, _al
         01:D032  A9 11      			lda.l	#17
         01:D034  85 F8      			sta	_al
 9346                        		__farptr	_palette_objects_1, _bp_bank, _bp
         01:D036  A9 20      			lda.l	#$6000 + ($1FFF & (_palette_objects_1))
         01:D038  85 EC      			sta.l	_bp
         01:D03A  A9 78      			lda.h	#$6000 + ($1FFF & (_palette_objects_1))
         01:D03C  85 ED      			sta.h	_bp
         01:D03E  A9 0D      			lda	#bank(_palette_objects_1)
         01:D040  85 02      			sta	_bp_bank
 9347                        		__st.umiq	1, _ah
         01:D042  A9 01      			lda.l	#1
         01:D044  85 F9      			sta	_ah
 9348                        		__call		_load_palette.3
         01:D046  20 09 FF   			call	_load_palette.3
 9349                        	
 9350                        		.dbg	line,	"include\init.c", 464; load_palette( 18, palette_objects_2, 1 );
 9351                        		__st.umiq	18, _al
         01:D049  A9 12      			lda.l	#18
         01:D04B  85 F8      			sta	_al
 9352                        		__farptr	_palette_objects_2, _bp_bank, _bp
         01:D04D  A9 20      			lda.l	#$6000 + ($1FFF & (_palette_objects_2))
         01:D04F  85 EC      			sta.l	_bp
         01:D051  A9 7A      			lda.h	#$6000 + ($1FFF & (_palette_objects_2))
         01:D053  85 ED      			sta.h	_bp
         01:D055  A9 0D      			lda	#bank(_palette_objects_2)
         01:D057  85 02      			sta	_bp_bank
 9353                        		__st.umiq	1, _ah
         01:D059  A9 01      			lda.l	#1
         01:D05B  85 F9      			sta	_ah
 9354                        		__call		_load_palette.3
         01:D05D  20 09 FF   			call	_load_palette.3
 9355                        	
 9356                        		.dbg	line,	"include\init.c", 472; // VSYNC //
 9357                        	
 9358                        		.dbg	line,	"include\init.c", 473; vsync();
 9359                        		__call		_vsync
         01:D060  20 09 E3   			call	_vsync
 9360                        	
 9361                        		.dbg	line,	"include\init.c", 475; // ENABLE DISPLAY //
 9362                        	
 9363                        		.dbg	line,	"include\init.c", 476; disp_on();
 9364                        		__call		_disp_on
         01:D063  20 16 E4   			call	_disp_on
 9365                        	
 9366                        		.dbg	line,	"include\init.c", 477; }
 9367                        	
 9368                        		.dbg	line,	"include\init.c", 478; }
 9369    01:D066             	.LL382:
 9370    01:D066             	.LL381:
 9371                        		__return	0
         01:D066  4C EF FF   			jmp	leave_proc
 9372                        		.dbg	clear
 9373                        		.endp
 9374                        		.pceas
 9375                        	
 9376                        		.dbg	line,	"main.c", 31; main()
 9377                        		.dbg	line,	"main.c", 32; {
 9378                        	;***********************
 9379                        	;***********************
 9380                        	
 9381                        		.hucc
 9382    01:DC7F             		.proc		_main
 9383                        		__enter		_main
 9384                        	
 9385                        		.dbg	line,	"main.c", 33; if(!sgx_detect())
 9386                        		 _sgx_detect
         01:DC7F  AD E8 22   			lda	sgx_detected
         01:DC82  C2         			cly
 9387                        		__not.wr
         01:DC83  84 00      			sty	__temp
         01:DC85  05 00      			ora	__temp
         01:DC87  18         			clc
         01:DC88  D0 01      			bne	!+
         01:DC8A  38         			sec
         01:DC8B             	!:
 9388                        		__bfalse	.LL384
         01:DC8B  90 14      			bcc	.LL384
 9389                        	
 9390                        		.dbg	line,	"main.c", 34; {
 9391                        	
 9392                        		.dbg	line,	"main.c", 35; put_string("Halt: SGX hardware not found", 2, 13);
 9393                        		__ld.wi		__const1+0
         01:DC8D  62         			cla
         01:DC8E  A0 60      			ldy.h	#__const1+0
 9394                        		__st.wmq	_bp
         01:DC90  85 EC      			sta.l	_bp
         01:DC92  84 ED      			sty.h	_bp
 9395                        		__st.umiq	2, _dil
         01:DC94  A9 02      			lda.l	#2
         01:DC96  85 F0      			sta	_dil
 9396                        		__st.umiq	13, _dih
         01:DC98  A9 0D      			lda.l	#13
         01:DC9A  85 F1      			sta	_dih
 9397                        		__call		_put_string.3
         01:DC9C  20 68 E6   			call	_put_string.3
 9398                        	
 9399                        		.dbg	line,	"main.c", 37; for(;;)
 9400    01:DC9F             	.LL385	.alias		.LL387
 9401    01:DC9F             	.LL386	.alias		.LL387
 9402    01:DC9F             	.LL387:
 9403                        	
 9404                        		.dbg	line,	"main.c", 38; {
 9405                        	
 9406                        		.dbg	line,	"main.c", 39; // INFINITE LOOP //
 9407                        	
 9408                        		.dbg	line,	"main.c", 40; }
 9409                        		__bra		.LL387
         01:DC9F  80 FE      			bra	.LL387
 9410    01:DCA1             	.LL388:
 9411                        	
 9412                        		.dbg	line,	"main.c", 41; }
 9413                        	
 9414                        		.dbg	line,	"main.c", 46; init_VARIABLES();
 9415    01:DCA1             	.LL384:
 9416                        		__call		_init_VARIABLES
         01:DCA1  20 A5 FE   			call	_init_VARIABLES
 9417                        	
 9418                        		.dbg	line,	"main.c", 49; init_PLAYER();
 9419                        		__call		_init_PLAYER
         01:DCA4  20 9B FE   			call	_init_PLAYER
 9420                        	
 9421                        		.dbg	line,	"main.c", 54; //**************************************************************************************//
 9422                        	
 9423                        		.dbg	line,	"main.c", 55; //                                                                                      //
 9424                        	
 9425                        		.dbg	line,	"main.c", 56; //                                      TITLE                                           //
 9426                        	
 9427                        		.dbg	line,	"main.c", 57; //                                                                                      //
 9428                        	
 9429                        		.dbg	line,	"main.c", 58; //**************************************************************************************//
 9430                        	
 9431                        		.dbg	line,	"main.c", 59; for(;;)
 9432    01:DCA7             	.LL389:
 9433    01:DCA7             	.LL390:
 9434    01:DCA7             	.LL391:
 9435                        	
 9436                        		.dbg	line,	"main.c", 60; {
 9437                        	
 9438                        		.dbg	line,	"main.c", 62; if(sequence_id == SEQUENCE_TITLE)
 9439                        		__not.um	_sequence_id
         01:DCA7  AD 0D 23   			lda	_sequence_id
         01:DCAA  18         			clc
         01:DCAB  D0 01      			bne	!+
         01:DCAD  38         			sec
         01:DCAE             	!:
 9440                        		__bfalse	.LL393
         01:DCAE  90 02      			bcc	.LL393
 9441                        	
 9442                        		.dbg	line,	"main.c", 63; {
 9443                        	
 9444                        		.dbg	line,	"main.c", 65; }
 9445                        	
 9446                        		.dbg	line,	"main.c", 68; else if(sequence_id == SEQUENCE_GAME)
 9447                        		__bra		.LL394
         01:DCB0  80 F5      			bra	.LL394
 9448    01:DCB2             	.LL393:
 9449                        		__ld.umq	_sequence_id
         01:DCB2  AD 0D 23   			lda	_sequence_id
 9450                        		__equ_b.uiq	2
         01:DCB5  C9 02      			cmp	#2
         01:DCB7  F0 01      			beq	!+
         01:DCB9  18         			clc
         01:DCBA             	!:
 9451                        		__bfalse	.LL395
         01:DCBA  90 EB      			bcc	.LL395
 9452                        	
 9453                        		.dbg	line,	"main.c", 69; {
 9454                        	
 9455                        		.dbg	line,	"main.c", 70; // LOADING LOGO SCREEN //
 9456                        	
 9457                        		.dbg	line,	"main.c", 71; if(sequence_loaded == FALSE)
 9458                        		__not.um	_sequence_loaded
         01:DCBC  AD 0E 23   			lda	_sequence_loaded
         01:DCBF  18         			clc
         01:DCC0  D0 01      			bne	!+
         01:DCC2  38         			sec
         01:DCC3             	!:
 9459                        		__bfalse	.LL396
         01:DCC3  90 0A      			bcc	.LL396
 9460                        	
 9461                        		.dbg	line,	"main.c", 72; {
 9462                        	
 9463                        		.dbg	line,	"main.c", 73; init_LEVEL();
 9464                        		__call		_init_LEVEL
         01:DCC5  20 91 FE   			call	_init_LEVEL
 9465                        	
 9466                        		.dbg	line,	"main.c", 75; sequence_loaded = TRUE;
 9467                        		__st.umiq	1, _sequence_loaded
         01:DCC8  A9 01      			lda.l	#1
         01:DCCA  8D 0E 23   			sta	_sequence_loaded
 9468                        	
 9469                        		.dbg	line,	"main.c", 76; }
 9470                        	
 9471                        		.dbg	line,	"main.c", 79; else
 9472                        		__bra		.LL397
         01:DCCD  80 D8      			bra	.LL397
 9473    01:DCCF             	.LL396:
 9474                        	
 9475                        		.dbg	line,	"main.c", 80; {
 9476                        	
 9477                        		.dbg	line,	"main.c", 81; if(level_id == 1)
 9478                        		__ld.umq	_level_id
         01:DCCF  AD 0F 23   			lda	_level_id
 9479                        		__equ_b.uiq	1
         01:DCD2  C9 01      			cmp	#1
         01:DCD4  F0 01      			beq	!+
         01:DCD6  18         			clc
         01:DCD7             	!:
 9480                        		__bfalse	.LL398
         01:DCD7  90 23      			bcc	.LL398
 9481                        	
 9482                        		.dbg	line,	"main.c", 82; {
 9483                        	
 9484                        		.dbg	line,	"main.c", 83; vsync();
 9485                        		__call		_vsync
         01:DCD9  20 09 E3   			call	_vsync
 9486                        	
 9487                        		.dbg	line,	"main.c", 85; update_PLAYER();
 9488                        		__call		_update_PLAYER
         01:DCDC  20 87 FE   			call	_update_PLAYER
 9489                        	
 9490                        		.dbg	line,	"main.c", 86; 
 9491                        	
 9492                        		.dbg	line,	"main.c", 87; //put_number(onscreen_object_number + onscreen_chest_number,1,0,0);
 9493                        	
 9494                        		.dbg	line,	"main.c", 89; joypad_DIR();
 9495                        		__call		_joypad_DIR
         01:DCDF  20 7D FE   			call	_joypad_DIR
 9496                        	
 9497                        		.dbg	line,	"main.c", 90; joypad_BUTTONS();
 9498                        		__call		_joypad_BUTTONS
         01:DCE2  20 73 FE   			call	_joypad_BUTTONS
 9499                        	
 9500                        		.dbg	line,	"main.c", 92; scroll_object();
 9501                        		__call		_scroll_object
         01:DCE5  20 EB FE   			call	_scroll_object
 9502                        	
 9503                        		.dbg	line,	"main.c", 93; scroll_chest();
 9504                        		__call		_scroll_chest
         01:DCE8  20 CD FE   			call	_scroll_chest
 9505                        	
 9506                        		.dbg	line,	"main.c", 94; scroll_npc();
 9507                        		__call		_scroll_npc
         01:DCEB  20 69 FE   			call	_scroll_npc
 9508                        	
 9509                        		.dbg	line,	"main.c", 96; check_OBJECTS();
 9510                        		__call		_check_OBJECTS
         01:DCEE  20 5F FE   			call	_check_OBJECTS
 9511                        	
 9512                        		.dbg	line,	"main.c", 98; satb_update();
 9513                        		__call		_satb_update
         01:DCF1  20 AF FE   			call	_satb_update
 9514                        	
 9515                        		.dbg	line,	"main.c", 100; scroll_BG();
 9516                        		__call		_scroll_BG
         01:DCF4  20 55 FE   			call	_scroll_BG
 9517                        	
 9518                        		.dbg	line,	"main.c", 102; display_TIME();
 9519                        		__call		_display_TIME
         01:DCF7  20 4B FE   			call	_display_TIME
 9520                        	
 9521                        		.dbg	line,	"main.c", 103; }
 9522                        	
 9523                        		.dbg	line,	"main.c", 105; else if(level_id == 2)
 9524                        		__bra		.LL399
         01:DCFA  80 AB      			bra	.LL399
 9525    01:DCFC             	.LL398:
 9526                        		__ld.umq	_level_id
         01:DCFC  AD 0F 23   			lda	_level_id
 9527                        		__equ_b.uiq	2
         01:DCFF  C9 02      			cmp	#2
         01:DD01  F0 01      			beq	!+
         01:DD03  18         			clc
         01:DD04             	!:
 9528                        		__bfalse	.LL400
         01:DD04  90 02      			bcc	.LL400
 9529                        	
 9530                        		.dbg	line,	"main.c", 106; {
 9531                        	
 9532                        		.dbg	line,	"main.c", 107; //sequence_LV2();
 9533                        	
 9534                        		.dbg	line,	"main.c", 108; }
 9535                        	
 9536                        		.dbg	line,	"main.c", 110; else if(level_id == 3)
 9537                        		__bra		.LL401
         01:DD06  80 9F      			bra	.LL401
 9538    01:DD08             	.LL400:
 9539                        		__ld.umq	_level_id
         01:DD08  AD 0F 23   			lda	_level_id
 9540                        		__equ_b.uiq	3
         01:DD0B  C9 03      			cmp	#3
         01:DD0D  F0 01      			beq	!+
         01:DD0F  18         			clc
         01:DD10             	!:
 9541                        		__bfalse	.LL402
         01:DD10  90 02      			bcc	.LL402
 9542                        	
 9543                        		.dbg	line,	"main.c", 111; {
 9544                        	
 9545                        		.dbg	line,	"main.c", 112; //sequence_LV3();
 9546                        	
 9547                        		.dbg	line,	"main.c", 113; }
 9548                        	
 9549                        		.dbg	line,	"main.c", 115; else if(level_id == 4)
 9550                        		__bra		.LL403
         01:DD12  80 93      			bra	.LL403
 9551    01:DD14             	.LL402:
 9552                        		__ld.umq	_level_id
         01:DD14  AD 0F 23   			lda	_level_id
 9553                        		__equ_b.uiq	4
         01:DD17  C9 04      			cmp	#4
         01:DD19  F0 01      			beq	!+
         01:DD1B  18         			clc
         01:DD1C             	!:
 9554                        		__bfalse	.LL404
         01:DD1C  90 02      			bcc	.LL404
 9555                        	
 9556                        		.dbg	line,	"main.c", 116; {
 9557                        	
 9558                        		.dbg	line,	"main.c", 117; //sequence_LV4();
 9559                        	
 9560                        		.dbg	line,	"main.c", 118; }
 9561                        	
 9562                        		.dbg	line,	"main.c", 120; else if(level_id == 5)
 9563                        		__bra		.LL405
         01:DD1E  80 87      			bra	.LL405
 9564    01:DD20             	.LL404:
 9565                        		__ld.umq	_level_id
         01:DD20  AD 0F 23   			lda	_level_id
 9566                        		__equ_b.uiq	5
         01:DD23  C9 05      			cmp	#5
         01:DD25  F0 01      			beq	!+
         01:DD27  18         			clc
         01:DD28             	!:
 9567                        		__bfalse	.LL406
         01:DD28  B0 03 4C A7			bcc	.LL406
         01:DD2C  DC          
 9568                        	
 9569                        		.dbg	line,	"main.c", 121; {
 9570                        	
 9571                        		.dbg	line,	"main.c", 122; //sequence_LV5();
 9572                        	
 9573                        		.dbg	line,	"main.c", 123; }
 9574                        	
 9575                        		.dbg	line,	"main.c", 124; }
 9576    01:DD2D             	.LL406	.alias		.LL391
 9577    01:DD2D             	.LL405	.alias		.LL391
 9578    01:DD2D             	.LL403	.alias		.LL391
 9579    01:DD2D             	.LL401	.alias		.LL391
 9580    01:DD2D             	.LL399	.alias		.LL391
 9581    01:DD2D             	.LL397	.alias		.LL391
 9582                        	
 9583                        		.dbg	line,	"main.c", 125; }
 9584                        	
 9585                        		.dbg	line,	"main.c", 126; }
 9586    01:DD2D             	.LL395	.alias		.LL391
 9587    01:DD2D             	.LL394	.alias		.LL391
 9588                        		__bra		.LL391
         01:DD2D  4C A7 DC   			bra	.LL391
 9589    01:DD30             	.LL392:
 9590                        	
 9591                        		.dbg	line,	"main.c", 129; }
 9592    01:DD30             	.LL383:
 9593                        		__return	1
         01:DD30  AA         			tax
         01:DD31  4C EF FF   			jmp	leave_proc
 9594                        		.dbg	clear
 9595                        		.endp
 9596                        		.pceas
 9597                        	
 9598                        		.dbg	clear
 9599               6000     		.rodata
 9600    01:6000             	__const1:
 9601    01:6000  48 61 6C 74			db	'H','a','l','t',':',' ','S','G'
         01:6004  3A 20 53 47 
 9602    01:6008  58 20 68 61			db	'X',' ','h','a','r','d','w','a'
         01:600C  72 64 77 61 
 9603    01:6010  72 65 20 6E			db	'r','e',' ','n','o','t',' ','f'
         01:6014  6F 74 20 66 
 9604    01:6018  6F 75 6E 64			db	'o','u','n','d',$00
         01:601C  00          
 9605    01:601D             	_TABLE_NPC_X_POS_REF_LV1:
 9606    01:601D  90 03      			dw	912
 9607    01:601F  D0 04      			dw	1232
 9608    01:6021             	_TABLE_NPC_Y_POS_REF_LV1:
 9609    01:6021  40 02      			dw	576
 9610    01:6023  90 01      			dw	400
 9611    01:6025             	_TABLE_OBJECT_TYPE_LV1:
 9612    01:6025  00         			db	0
 9613    01:6026  01         			db	1
 9614    01:6027  01         			db	1
 9615    01:6028  01         			db	1
 9616    01:6029  01         			db	1
 9617    01:602A  01         			db	1
 9618    01:602B  01         			db	1
 9619    01:602C  02         			db	2
 9620    01:602D  01         			db	1
 9621    01:602E  01         			db	1
 9622    01:602F  01         			db	1
 9623    01:6030  01         			db	1
 9624    01:6031  01         			db	1
 9625    01:6032  01         			db	1
 9626    01:6033  01         			db	1
 9627    01:6034  01         			db	1
 9628    01:6035  01         			db	1
 9629    01:6036  01         			db	1
 9630    01:6037  01         			db	1
 9631    01:6038  01         			db	1
 9632    01:6039  01         			db	1
 9633    01:603A  01         			db	1
 9634    01:603B  01         			db	1
 9635    01:603C             	_TABLE_OBJECT_X_POS_REF_LV1:
 9636    01:603C  90 06      			dw	1680
 9637    01:603E  00 05      			dw	1280
 9638    01:6040  C0 05      			dw	1472
 9639    01:6042  A0 05      			dw	1440
 9640    01:6044  90 04      			dw	1168
 9641    01:6046  B0 04      			dw	1200
 9642    01:6048  C0 03      			dw	960
 9643    01:604A  D8 03      			dw	984
 9644    01:604C  50 05      			dw	1360
 9645    01:604E  70 05      			dw	1392
 9646    01:6050  10 06      			dw	1552
 9647    01:6052  90 06      			dw	1680
 9648    01:6054  B0 06      			dw	1712
 9649    01:6056  D0 06      			dw	1744
 9650    01:6058  E0 04      			dw	1248
 9651    01:605A  00 05      			dw	1280
 9652    01:605C  90 04      			dw	1168
 9653    01:605E  10 04      			dw	1040
 9654    01:6060  80 02      			dw	640
 9655    01:6062  A0 02      			dw	672
 9656    01:6064  50 01      			dw	336
 9657    01:6066  70 01      			dw	368
 9658    01:6068  A0 01      			dw	416
 9659    01:606A             	_TABLE_OBJECT_Y_POS_REF_LV1:
 9660    01:606A  80 01      			dw	384
 9661    01:606C  A0 01      			dw	416
 9662    01:606E  E0 01      			dw	480
 9663    01:6070  F0 01      			dw	496
 9664    01:6072  30 02      			dw	560
 9665    01:6074  30 02      			dw	560
 9666    01:6076  50 02      			dw	592
 9667    01:6078  50 02      			dw	592
 9668    01:607A  50 02      			dw	592
 9669    01:607C  50 02      			dw	592
 9670    01:607E  C0 02      			dw	704
 9671    01:6080  D0 02      			dw	720
 9672    01:6082  D0 02      			dw	720
 9673    01:6084  D0 02      			dw	720
 9674    01:6086  E0 02      			dw	736
 9675    01:6088  E0 02      			dw	736
 9676    01:608A  F0 02      			dw	752
 9677    01:608C  50 03      			dw	848
 9678    01:608E  70 03      			dw	880
 9679    01:6090  70 03      			dw	880
 9680    01:6092  80 03      			dw	896
 9681    01:6094  80 03      			dw	896
 9682    01:6096  80 03      			dw	896
 9683    01:6098             	_TABLE_CHEST_X_POS_REF_LV1:
 9684    01:6098  30 04      			dw	1072
 9685    01:609A  30 03      			dw	816
 9686    01:609C             	_TABLE_CHEST_Y_POS_REF_LV1:
 9687    01:609C  40 03      			dw	832
 9688    01:609E  50 03      			dw	848
 9689    01:60A0             	_TABLE_PLAYER_JUMP_V:
 9690    01:60A0  FC         			db	-4
 9691    01:60A1  FB         			db	-5
 9692    01:60A2  F6         			db	-10
 9693    01:60A3  FC         			db	-4
 9694    01:60A4  FC         			db	-4
 9695    01:60A5  F9         			db	-7
 9696    01:60A6  FA         			db	-6
 9697    01:60A7  FD         			db	-3
 9698    01:60A8  FB         			db	-5
 9699    01:60A9  FE         			db	-2
 9700    01:60AA  FC         			db	-4
 9701    01:60AB  FF         			db	-1
 9702    01:60AC  FF         			db	-1
 9703    01:60AD  FF         			db	-1
 9704    01:60AE  FF         			db	-1
 9705    01:60AF  00         			db	0
 9706    01:60B0  00         			db	0
 9707    01:60B1  00         			db	0
 9708    01:60B2  00         			db	0
 9709    01:60B3  01         			db	1
 9710    01:60B4  01         			db	1
 9711    01:60B5  01         			db	1
 9712    01:60B6  01         			db	1
 9713    01:60B7  04         			db	4
 9714    01:60B8  02         			db	2
 9715    01:60B9  05         			db	5
 9716    01:60BA  03         			db	3
 9717    01:60BB  06         			db	6
 9718    01:60BC  07         			db	7
 9719    01:60BD  04         			db	4
 9720    01:60BE  04         			db	4
 9721    01:60BF  0A         			db	10
 9722    01:60C0  04         			db	4
 9723    01:60C1  04         			db	4
 9724    01:60C2  05         			db	5
 9725    01:60C3             	_TABLE_PLAYER_FALL:
 9726    01:60C3  00         			db	0
 9727    01:60C4  00         			db	0
 9728    01:60C5  00         			db	0
 9729    01:60C6  00         			db	0
 9730    01:60C7  01         			db	1
 9731    01:60C8  01         			db	1
 9732    01:60C9  01         			db	1
 9733    01:60CA  01         			db	1
 9734    01:60CB  02         			db	2
 9735    01:60CC  02         			db	2
 9736    01:60CD  02         			db	2
 9737    01:60CE  02         			db	2
 9738    01:60CF  03         			db	3
 9739    01:60D0  03         			db	3
 9740    01:60D1  03         			db	3
 9741    01:60D2  04         			db	4
 9742    01:60D3  04         			db	4
 9743    01:60D4  04         			db	4
 9744    01:60D5  04         			db	4
 9745    01:60D6  04         			db	4
 9746    01:60D7  05         			db	5
 9747    01:60D8             	_TABLE_PLAYER_JUMP_LADDER:
 9748    01:60D8  FC         			db	-4
 9749    01:60D9  FC         			db	-4
 9750    01:60DA  FD         			db	-3
 9751    01:60DB  FD         			db	-3
 9752    01:60DC  FD         			db	-3
 9753    01:60DD  FE         			db	-2
 9754    01:60DE  FE         			db	-2
 9755    01:60DF  FE         			db	-2
 9756    01:60E0  FF         			db	-1
 9757    01:60E1  FF         			db	-1
 9758    01:60E2  FF         			db	-1
 9759    01:60E3  FF         			db	-1
 9760    01:60E4  FF         			db	-1
 9761    01:60E5  00         			db	0
 9762    01:60E6  00         			db	0
 9763    01:60E7  00         			db	0
 9764    01:60E8  00         			db	0
 9765    01:60E9  01         			db	1
 9766    01:60EA  01         			db	1
 9767    01:60EB  01         			db	1
 9768    01:60EC  01         			db	1
 9769    01:60ED  01         			db	1
 9770    01:60EE  02         			db	2
 9771    01:60EF  02         			db	2
 9772    01:60F0  02         			db	2
 9773    01:60F1  03         			db	3
 9774    01:60F2  03         			db	3
 9775    01:60F3  03         			db	3
 9776    01:60F4  04         			db	4
 9777    01:60F5  04         			db	4
 9778                        	
 9779               230D     		.bss
 9780    F8:230D             	_sequence_id:
 9781    F8:230D             			ds	1
 9782    F8:230E             	_sequence_loaded:
 9783    F8:230E             			ds	1
 9784    F8:230F             	_level_id:
 9785    F8:230F             			ds	1
 9786    F8:2310             	_player_id:
 9787    F8:2310             			ds	1
 9788    F8:2311             	_player_state:
 9789    F8:2311             			ds	1
 9790    F8:2312             	_player_axis:
 9791    F8:2312             			ds	1
 9792    F8:2313             	_player_previous_axis:
 9793    F8:2313             			ds	1
 9794    F8:2314             	_player_counter_anim:
 9795    F8:2314             			ds	1
 9796    F8:2315             	_player_index_jump:
 9797    F8:2315             			ds	1
 9798    F8:2316             	_player_index_fall:
 9799    F8:2316             			ds	1
 9800    F8:2317             	_jump_ladder:
 9801    F8:2317             			ds	1
 9802    F8:2318             	_jump_max_index:
 9803    F8:2318             			ds	1
 9804    F8:2319             	_life_number:
 9805    F8:2319             			ds	1
 9806    F8:231A             	_key_number:
 9807    F8:231A             			ds	1
 9808    F8:231B             	_potion_number:
 9809    F8:231B             			ds	1
 9810    F8:231C             	_zenny_number:
 9811    F8:231C             			ds	1
 9812    F8:231D             	_minutes:
 9813    F8:231D             			ds	1
 9814    F8:231E             	_seconds:
 9815    F8:231E             			ds	1
 9816    F8:231F             	_time_counter:
 9817    F8:231F             			ds	1
 9818    F8:2320             	_object_start_index:
 9819    F8:2320             			ds	1
 9820    F8:2321             	_level_object_number:
 9821    F8:2321             			ds	1
 9822    F8:2322             	_onscreen_object_number:
 9823    F8:2322             			ds	1
 9824    F8:2323             	_list_object_type:
 9825    F8:2323             			ds	25
 9826    F8:233C             	_list_object_state:
 9827    F8:233C             			ds	25
 9828    F8:2355             	_list_object_energy:
 9829    F8:2355             			ds	25
 9830    F8:236E             	_list_reward_type:
 9831    F8:236E             			ds	25
 9832    F8:2387             	_list_onscreen_object:
 9833    F8:2387             			ds	8
 9834    F8:238F             	_chest_start_index:
 9835    F8:238F             			ds	1
 9836    F8:2390             	_level_chest_number:
 9837    F8:2390             			ds	1
 9838    F8:2391             	_onscreen_chest_number:
 9839    F8:2391             			ds	1
 9840    F8:2392             	_list_chest_state:
 9841    F8:2392             			ds	8
 9842    F8:239A             	_list_onscreen_chest:
 9843    F8:239A             			ds	8
 9844    F8:23A2             	_npc_start_index:
 9845    F8:23A2             			ds	1
 9846    F8:23A3             	_level_npc_number:
 9847    F8:23A3             			ds	1
 9848    F8:23A4             	_onscreen_npc_number:
 9849    F8:23A4             			ds	1
 9850    F8:23A5             	_list_npc_state:
 9851    F8:23A5             			ds	9
 9852    F8:23AE             	_list_onscreen_npc:
 9853    F8:23AE             			ds	9
 9854    F8:23B7             	_player_pos_x:
 9855    F8:23B7             			ds	2
 9856    F8:23B9             	_player_pos_y:
 9857    F8:23B9             			ds	2
 9858    F8:23BB             	_camera_max_y_position:
 9859    F8:23BB             			ds	2
 9860    F8:23BD             	_list_object_x_pos:
 9861    F8:23BD             			ds	50
 9862    F8:23EF             	_list_object_y_pos:
 9863    F8:23EF             			ds	50
 9864    F8:2421             	_list_object_x_pos_ref:
 9865    F8:2421             			ds	50
 9866    F8:2453             	_list_object_y_pos_ref:
 9867    F8:2453             			ds	50
 9868    F8:2485             	_list_chest_x_pos:
 9869    F8:2485             			ds	16
 9870    F8:2495             	_list_chest_y_pos:
 9871    F8:2495             			ds	16
 9872    F8:24A5             	_list_chest_x_pos_ref:
 9873    F8:24A5             			ds	16
 9874    F8:24B5             	_list_chest_y_pos_ref:
 9875    F8:24B5             			ds	16
 9876    F8:24C5             	_list_npc_x_pos:
 9877    F8:24C5             			ds	18
 9878    F8:24D7             	_list_npc_y_pos:
 9879    F8:24D7             			ds	18
 9880    F8:24E9             	_list_npc_x_pos_ref:
 9881    F8:24E9             			ds	18
 9882    F8:24FB             	_list_npc_y_pos_ref:
 9883    F8:24FB             			ds	18
 9884                        	
 9885                        	
 9886                        	;0 error(s) in compilation
 9887                        	;	literal pool:29
 9888                        	;	constant pool:217
 9889                        	;	global pool:449
 9890                        	;	Macro pool:247
 9891    F8:250D             	leaf_loc:
 9892    F8:250D             			ds	4
 9893    F8:2511             	__scroll_object_end:
 9894    F8:2511             	__scroll_chest_end:
 9895    F8:2511             	__scroll_npc_end:
 9896    F8:2511             	__check_TILE_DEPTH_end:
 9897    F8:2511             	__check_BG_end:
 9898    F8:2511             	__recenter_CAMERA_end:
 9899    F8:2511             	__init_OBJECT_LV1_end:
 9900    F8:2511             	__init_CHEST_LV1_end:
 9901    F8:2511             	__init_NPC_LV1_end:
 9902                        	
 9903    F8:2511             	__bss_init:
 9904                        	
 9905    F8:2511             	__heap_start:
                             #[2]   "..\..\..\include\hucc\hucc-final.asm"
    1                        	; ***************************************************************************
    2                        	; ***************************************************************************
    3                        	;
    4                        	; hucc-final.asm
    5                        	;
    6                        	; PCEAS auto-includes this file at the end of every pass in HuCC or SDCC.
    7                        	;
    8                        	; Copyright John Brandwood 2024.
    9                        	;
   10                        	; Distributed under the Boost Software License, Version 1.0.
   11                        	; (See accompanying file LICENSE_1_0.txt or copy at
   12                        	;  http://www.boost.org/LICENSE_1_0.txt)
   13                        	;
   14                        	; ***************************************************************************
   15                        	; ***************************************************************************
   16                        	;
   17                        	; This is used to select which assembly-language library files to include in
   18                        	; a HuCC project, using labels defined in the compiler's header files.
   19                        	;
   20                        	; ***************************************************************************
   21                        	; ***************************************************************************
   22                        	
   23                        			; Allow projects to customize what is included at the end
   24                        			; of a pass without replacing the entire "hucc-final.asm".
   25                        	
   26               E309     			.code
   27               0000     			.bank	CORE_BANK
   28               E309     			.page	CORE_PAGE
   29                        	
                             #[3]   "..\..\..\include\hucc\hucc-final-extra.asm"
   30                        			include	"hucc-final-extra.asm"
    1                        	; ***************************************************************************
    2                        	; ***************************************************************************
    3                        	;
    4                        	; hucc-final-extra.asm
    5                        	;
    6                        	; hucc-final.asm includes this file at the end of every pass in HuCC or SDCC.
    7                        	;
    8                        	; Copyright John Brandwood 2024.
    9                        	;
   10                        	; Distributed under the Boost Software License, Version 1.0.
   11                        	; (See accompanying file LICENSE_1_0.txt or copy at
   12                        	;  http://www.boost.org/LICENSE_1_0.txt)
   13                        	;
   14                        	; ***************************************************************************
   15                        	; ***************************************************************************
   16                        	;
   17                        	; This is used to select which assembly-language library files to include in
   18                        	; a HuCC project, using labels defined in the compiler's header files.
   19                        	;
   20                        	; ***************************************************************************
   21                        	; ***************************************************************************
                             #[2]   "..\..\..\include\hucc\hucc-final.asm"
   31                        	
   32                        			; Libraries required for basic functionality.
   33                        	
   34               E309     			.code
   35               0000     			.bank	CORE_BANK
   36               E309     			.page	CORE_PAGE
   37                        	
                             #[3]   "..\..\..\include\hucc\common.asm"
   38                        			include	"common.asm"		; Common helpers.
    1                        	; ***************************************************************************
    2                        	; ***************************************************************************
    3                        	;
    4                        	; common.asm
    5                        	;
    6                        	; Small, generic, PCE subroutines that are commonly useful when developing.
    7                        	;
    8                        	; These should be located in permanently-accessible memory!
    9                        	;
   10                        	; Copyright John Brandwood 2021-2024.
   11                        	;
   12                        	; Distributed under the Boost Software License, Version 1.0.
   13                        	; (See accompanying file LICENSE_1_0.txt or copy at
   14                        	;  http://www.boost.org/LICENSE_1_0.txt)
   15                        	;
   16                        	; ***************************************************************************
   17                        	; ***************************************************************************
   18                        	
   19                        	
   20                        	
   21                        	; ***************************************************************************
   22                        	; ***************************************************************************
   23                        	;
   24                        	; Wait for the next VBLANK IRQ.
   25                        	;
   26                        	
   27    00:E309  AD 41 22   	wait_vsync:	lda	irq_cnt			; System Card variable, changed
   28    00:E30C  CD 41 22   	.loop:		cmp	irq_cnt			; every VBLANK interrupt.
   29    00:E30F  F0 FB      			beq	.loop
   30               0001     		.ifdef	HUCC
   31    00:E311  8D EB 22   			sta	old_cnt			; Remember the frame count.
   32                        		.endif
   33    00:E314  60         			rts
   34                        	
   35                        	
   36                        	
   37                        	; ***************************************************************************
   38                        	; ***************************************************************************
   39                        	;
   40                        	; Delay for the next Y VBLANK IRQs.
   41                        	;
   42                        	
   43               0001     		.ifdef	HUCC
   44    00:E315             	_vsync		.alias	wait_vsync
   45                        	
   46    00:E315  AD 41 22   	_vsync.1:	lda	irq_cnt			; HuCC's vsync(n) was defined
   47    00:E318  38         			sec				; as frames from the previous
   48    00:E319  ED EB 22   			sbc	old_cnt			; vsync() call, 1 to 255.
   49    00:E31C  38         			sec
   50    00:E31D  E5 F8      			sbc	<_al
   51    00:E31F  90 02      			bcc	!+
   52    00:E321  A9 FF      			lda	#$FF
   53    00:E323  49 FF      	!:		eor	#$FF
   54    00:E325  1A         			inc	a
   55    00:E326  A8         			tay
   56                        		.endif
   57                        	
   58    00:E327  44 E0      	wait_nvsync:	bsr	wait_vsync		; # of VBLANK IRQs to wait in
   59    00:E329  88         			dey				; the Y register.
   60    00:E32A  D0 FB      			bne	wait_nvsync
   61    00:E32C  60         			rts
   62                        	
   63                        	
   64                        	
   65               0000     		.ifndef	HUCC
  101                        		.endif
  102                        	
  103                        	
  104                        	
  105                        	; ***************************************************************************
  106                        	; ***************************************************************************
  107                        	;
  108                        	; Map the _bp data far-pointer into MPR3 (& MPR4).
  109                        	;
  110                        	; Because the 16KB RAM region at $2000-$5FFF is composed of two separate
  111                        	; banks, with the 2nd bank having no specific relation to the 1st, there
  112                        	; is no way to deal with a bank-increment, so do not map that region.
  113                        	;
  114                        	; N.B. Library code relies on this preserving X and V!
  115                        	;
  116                        	
  117    00:E32D  98         	map_bp_to_mpr3:	tya				; Put bank into MPR3.
  118    00:E32E  F0 0A      			beq	!+
  119    00:E330  53 08      			tam3
  120    00:E332  A5 ED      			lda.h	<_bp			; Do not remap a ptr to RAM,
  121    00:E334  29 1F      			and	#$1F			; Remap ptr to MPR3.
  122    00:E336  09 60      			ora	#$60
  123    00:E338  85 ED      			sta.h	<_bp
  124    00:E33A  60         	!:		rts
  125                        	
  126    00:E33B  98         	map_bp_to_mpr34:tya				; Put bank into MPR3.
  127    00:E33C  F0 0D      			beq	!+
  128    00:E33E  53 08      			tam3
  129    00:E340  1A         			inc	a			; Put next into MPR4.
  130    00:E341  53 10      			tam4
  131    00:E343  A5 ED      			lda.h	<_bp			; Do not remap a ptr to RAM,
  132    00:E345  29 1F      			and	#$1F			; Remap ptr to MPR3.
  133    00:E347  09 60      			ora	#$60
  134    00:E349  85 ED      			sta.h	<_bp
  135    00:E34B  60         	!:		rts
  136                        	
  137                        	
  138                        	
  139                        	; ***************************************************************************
  140                        	; ***************************************************************************
  141                        	;
  142                        	; Increment the hi-byte of _bp and change TMA3 if necessary.
  143                        	;
  144                        	; N.B. Library code relies on this preserving A,X,Y and V!
  145                        	;
  146                        	
  147    00:E34C  E6 ED      	inc.h_bp_mpr3:	inc.h	<_bp			; Increment hi-byte of _bp.
  148    00:E34E  10 0B      			bpl	!+			; OK if within MPR0-MPR3.
  149    00:E350  48         			pha				; Increment the bank in MPR3,
  150    00:E351  43 08      			tma3				; usually when pointer moves
  151    00:E353  1A         			inc	a			; from $7FFF -> $8000.
  152    00:E354  53 08      			tam3
  153    00:E356  A9 60      			lda	#$60
  154    00:E358  85 ED      			sta.h	<_bp
  155    00:E35A  68         			pla
  156    00:E35B  60         	!:		rts
  157                        	
  158                        	
  159                        	
  160                        	; ***************************************************************************
  161                        	; ***************************************************************************
  162                        	;
  163                        	; Increment the hi-byte of _bp and change TMA3 and TMA4 if necessary.
  164                        	;
  165                        	; N.B. Library code relies on this preserving A,X,Y and V!
  166                        	;
  167                        	
  168    00:E35C  E6 ED      	inc.h_bp_mpr34:	inc.h	<_bp			; Increment hi-byte of _bp.
  169    00:E35E  10 0D      			bpl	!+			; OK if within MPR0-MPR3.
  170    00:E360  48         			pha				; Increment the bank in MPR3,
  171    00:E361  43 10      			tma4				; usually when pointer moves
  172    00:E363  53 08      			tam3				; from $7FFF -> $8000.
  173    00:E365  1A         			inc	a
  174    00:E366  53 10      			tam4
  175    00:E368  A9 60      			lda	#$60
  176    00:E36A  85 ED      			sta.h	<_bp
  177    00:E36C  68         			pla
  178    00:E36D  60         	!:		rts
  179                        	
  180                        	
  181                        	
  182                        	; ***************************************************************************
  183                        	; ***************************************************************************
  184                        	;
  185                        	; Put the _di data pointer into the VDC's MARR or MAWR register.
  186                        	;
  187                        	; N.B. Library code relies on this preserving Y!
  188                        	;
  189                        	
  190               0001     		.if	SUPPORT_SGX
  191    00:E36E  A2 10      	sgx_di_to_marr:	ldx	#SGX_VDC_OFFSET		; Offset to SGX VDC.
  192    00:E370  F0         			db	$F0			; Turn "clx" into a "beq".
  193                        		.endif
  194                        	
  195    00:E371  82         	vdc_di_to_marr:	clx				; Offset to PCE VDC.
  196                        	
  197    00:E372  A9 01      	set_di_to_marr	lda	#VDC_MARR		; Set VDC or SGX destination
  198    00:E374  95 F7      			sta	<vdc_reg, x		; address.
  199    00:E376  9D 00 02   			sta	VDC_AR, x
  200    00:E379  80 09      			bra	!+
  201                        	
  202               0001     		.if	SUPPORT_SGX
  203    00:E37B  A2 10      	sgx_di_to_mawr:	ldx	#SGX_VDC_OFFSET		; Offset to SGX VDC.
  204    00:E37D  F0         			db	$F0			; Turn "clx" into a "beq".
  205                        		.endif
  206                        	
  207    00:E37E  82         	vdc_di_to_mawr:	clx				; Offset to PCE VDC.
  208                        	
  209    00:E37F             	set_di_to_mawr;	lda	#VDC_MAWR		; Set VDC or SGX destination
  210    00:E37F  74 F7      			stz	<vdc_reg, x		; address.
  211    00:E381  9E 00 02   			stz	VDC_AR, x
  212                        	
  213    00:E384  A5 F0      	!:		lda	<_di + 0
  214    00:E386  9D 02 02   			sta	VDC_DL, x
  215    00:E389  A5 F1      			lda	<_di + 1
  216    00:E38B  9D 03 02   			sta	VDC_DH, x
  217                        	
  218    00:E38E  A9 02      			lda	#VDC_VWR		; Select the VRR/VWR data
  219    00:E390  95 F7      			sta	<vdc_reg, x		; register.
  220    00:E392  9D 00 02   			sta	VDC_AR, x
  221    00:E395  60         			rts
  222                        	
  223                        	
  224                        	
  225                        	; ***************************************************************************
  226                        	; ***************************************************************************
  227                        	;
  228                        	; Increment the hi-byte of _di and change TMA4 if necessary.
  229                        	;
  230                        	
  231               0000     		.if	0				; Save memory, for now.
  250                        		.endif
  251                        	
  252                        	
  253                        	
  254                        	; ***************************************************************************
  255                        	; ***************************************************************************
  256                        	;
  257                        	; Far-call a function in another bank.
  258                        	;
  259                        	; This is a potential alternative procedure call trampoline that uses only 10
  260                        	; bytes of common memory per bank of procedures, instead of 10 bytes for each
  261                        	; individual procedure call, BUT it uses the X register as a procedure-index,
  262                        	; and it needs a table of addresses at the end of every procedure bank.
  263                        	;
  264                        	; To use this ...
  265                        	;
  266                        	;  ldx #procedure-index
  267                        	;  jsr far_call_nn
  268                        	;
  269                        	; The called .PROC routine must exit with "jmp leave_proc" and not "rts".
  270                        	;
  271                        	; leave_proc:	pla
  272                        	;		tam6
  273                        	;		tya
  274                        	;		rts
  275                        	;
  276                        	; N.B. This costs 21 cycles vs 18 for the .newproc trampoline code (when you
  277                        	;      exclude preserving YA in zero-page).
  278                        	;
  279                        	; N.B. This was written as an excerise, and definitely not for HuC!
  280                        	;
  281                        	
  282               0000     		.if	0
  295                        		.endif					; 21
                             #[2]   "..\..\..\include\hucc\hucc-final.asm"
                             #[3]   "..\..\..\include\hucc\vce.asm"
   39                        			include	"vce.asm"		; Useful VCE routines.
    1                        	; ***************************************************************************
    2                        	; ***************************************************************************
    3                        	;
    4                        	; vce.asm
    5                        	;
    6                        	; Useful routines for operating the HuC6260 Video Color Encoder
    7                        	;
    8                        	; These should be located in permanently-accessible memory!
    9                        	;
   10                        	; Copyright John Brandwood 2021-2025.
   11                        	;
   12                        	; Distributed under the Boost Software License, Version 1.0.
   13                        	; (See accompanying file LICENSE_1_0.txt or copy at
   14                        	;  http://www.boost.org/LICENSE_1_0.txt)
   15                        	;
   16                        	; ***************************************************************************
   17                        	; ***************************************************************************
   18                        	
   19                        	;
   20                        	; Configure Library ...
   21                        	;
   22                        	
   23               0000     		.ifndef VCE_SPLIT_CROSS
   25                        		.endif
   26                        	
   27                        	
   28                        	
   29                        	; ***************************************************************************
   30                        	; ***************************************************************************
   31                        	;
   32                        	; xfer_palettes - Update the VCE with the queued palettes changes.
   33                        	;
   34                        	; This is normally called in a developer's vsync_hook handler, but it can
   35                        	; be called manually as long as it will not also be called in an interrupt.
   36                        	;
   37                        	; The queued transfers are split into 32-byte chunks so that an HSYNC and/or
   38                        	; TIMER IRQ is not delayed for too long during the VBLANK.
   39                        	;
   40                        	
   41    00:E396  A9 80      	xfer_palettes:	lda	#$80			; Acquire color mutex to avoid
   42    00:E398  0C 11 25   			tsb	color_mutex		; conflict with a delayed VBL.
   43    00:E39B  30 5F      			bmi	.busy
   44                        	
   45    00:E39D  AC 12 25   			ldy	color_queue_r		; Are there any palette xfers
   46    00:E3A0  CC 13 25   			cpy	color_queue_w		; queued up?
   47    00:E3A3  F0 54      			beq	.exit
   48                        	
   49    00:E3A5  08         			php				; Enable interrupts so that an
   50    00:E3A6  58         			cli				; HSYNC or TIMER IRQ can occur.
   51                        	
   52    00:E3A7  43 08      			tma3				; Preserve MPR3 & MPR4 because
   53    00:E3A9  48         			pha				; this normally runs in the
   54    00:E3AA  43 10      			tma4				; VBLANK IRQ.
   55    00:E3AC  48         			pha
   56                        	
   57               0001     		.if	!CDROM
   58    00:E3AD  73 02 E4 86			tii	.tia_func, color_tia, 8 ; Copy TIA to RAM.
         00:E3B1  22 08 00    
   59                        		.endif
   60                        	
   61    00:E3B4  B9 14 25   	.next_item:	lda	color_index, y		; Get the next set of palettes
   62    00:E3B7  0A         			asl	a			; from the queue.
   63    00:E3B8  0A         			asl	a
   64    00:E3B9  0A         			asl	a
   65    00:E3BA  0A         			asl	a
   66    00:E3BB  8D 02 04   			sta	VCE_CTA + 0
   67    00:E3BE  62         			cla
   68    00:E3BF  2A         			rol	a
   69    00:E3C0  8D 03 04   			sta	VCE_CTA + 1
   70                        	
   71    00:E3C3  BE 1C 25   			ldx	color_count,y		; How many palettes to xfer?
   72                        	
   73    00:E3C6  B9 34 25   			lda	color_bank, y		; Map data into MPR3 & MPR4.
   74    00:E3C9  53 08      			tam3
   75    00:E3CB  1A         			inc	a
   76    00:E3CC  53 10      			tam4
   77    00:E3CE  B9 2C 25   			lda	color_addr_h, y
   78    00:E3D1  8D 88 22   			sta	.ram_tia + 2
   79    00:E3D4  B9 24 25   			lda	color_addr_l, y
   80    00:E3D7  8D 87 22   	.palette_loop:	sta	.ram_tia + 1
   81                        	
   82               0000     		.if	CDROM
   84                        		.else
   85    00:E3DA  20 86 22   			jsr	.ram_tia		; Copy 32-bytes to the VCE.
   86                        		.endif
   87                        	
   88    00:E3DD  18         			clc				; Increment the data ptr to
   89    00:E3DE  69 20      			adc	#32			; the next 32-byte palette.
   90    00:E3E0  B0 1B      			bcs	.next_page
   91                        	
   92    00:E3E2  CA         	.next_palette:	dex				; Any palettes left to xfer?
   93    00:E3E3  D0 F2      			bne	.palette_loop
   94                        	
   95    00:E3E5  C8         			iny				; Increment the queue index.
   96    00:E3E6  98         			tya
   97    00:E3E7  29 07      			and	#7
   98    00:E3E9  A8         			tay
   99                        	
  100    00:E3EA  CC 13 25   			cpy	color_queue_w		; Any more items in the queue?
  101    00:E3ED  D0 C5      			bne	.next_item
  102    00:E3EF  8C 12 25   			sty	color_queue_r		; Signal the queue is empty.
  103                        	
  104    00:E3F2  68         			pla				; Restore MPR3 & MPR4.
  105    00:E3F3  53 10      			tam4
  106    00:E3F5  68         			pla
  107    00:E3F6  53 08      			tam3
  108                        	
  109    00:E3F8  28         			plp				; Restore interrupt state.
  110                        	
  111    00:E3F9  9C 11 25   	.exit:		stz	color_mutex		; Release color mutex.
  112                        	
  113    00:E3FC  60         	.busy:		rts
  114                        	
  115    00:E3FD  EE 88 22   	.next_page:	inc	.ram_tia + 2
  116    00:E400  80 E0      			bra	.next_palette
  117                        	
  118               0001     		.if	!CDROM
  119               2286     	.ram_tia	=	color_tia		; Use a TIA in RAM.
  120                        	
  121    00:E402  E3 00 00 04	.tia_func:	tia	0, VCE_CTW, 32
         00:E406  04 20 00    
  122    00:E409  60         			rts
  123                        		.endif	!CDROM
  124                        	
  125               2511     			.bss
  126                        	
  127    F8:2511             	color_mutex:	ds	1			; Mutex for VCE changes.
  128    F8:2512             	color_queue_r:	ds	1			; Ring buffer read index.
  129    F8:2513             	color_queue_w:	ds	1			; Ring buffer write index.
  130    F8:2514             	color_index:	ds	8			; Ring buffer - Palette index.
  131    F8:251C             	color_count:	ds	8			; Ring buffer - Palette count.
  132    F8:2524             	color_addr_l:	ds	8			; Ring buffer - Data Ptr (lo).
  133    F8:252C             	color_addr_h:	ds	8			; Ring buffer - Data Ptr (hi).
  134    F8:2534             	color_bank:	ds	8			; Ring buffer - Data Ptr (bank).
  135                        	
  136               E40A     			.code
  137                        	
  138                        	
  139                        	
  140                        	; ***************************************************************************
  141                        	; ***************************************************************************
  142                        	;
  143                        	; load_palettes - Queue a set of palettes to upload to the VCE next VBLANK.
  144                        	;
  145                        	; Args: _al = Palette index (0..15 for BG, 16..31 for SPR).
  146                        	; Args: _ah = Palette count (1..32).
  147                        	; Args: _bp = Pointer to palette data.
  148                        	; Args:   Y = Bank to map into MPR3 & MPR4, or zero to leave unchanged.
  149                        	;
  150                        	; N.B. Y==0 is only useful if the palette data is permanently mapped!
  151                        	;
  152                        	
  153                        	load_palettes	.proc
  179                        			.endp
  180                        	
  181                        	
  182                        	
  183                        	; ***************************************************************************
  184                        	; ***************************************************************************
  185                        	;
  186                        	; clear_vce - Clear all 512 of the VCE's palette entries.
  187                        	;
  188                        	
  189    02:C3BF             	clear_vce	.proc
  190                        	
  191    02:C3BF  08         			php				; Disable interrupts to avoid
  192    02:C3C0  78         			sei				; VBLANK palette upload.
  193    02:C3C1  C2         			cly
  194    02:C3C2  9C 02 04   			stz	VCE_CTA+0		; Set VCE write address.
  195    02:C3C5  9C 03 04   			stz	VCE_CTA+1
  196    02:C3C8  9C 04 04   	.loop:		stz	VCE_CTW+0		; Set lo-byte of color.
  197    02:C3CB  9C 05 04   			stz	VCE_CTW+1		; Write 1 color value.
  198    02:C3CE  9C 04 04   			stz	VCE_CTW+0		; Set lo-byte of color.
  199    02:C3D1  9C 05 04   			stz	VCE_CTW+1		; Write 1 color value.
  200    02:C3D4  88         			dey
  201    02:C3D5  D0 F1      			bne	.loop
  202    02:C3D7  28         			plp
  203                        	
  204                        			leave				; All done, phew!
         02:C3D8  4C EF FF   			jmp	leave_proc
  205                        	
  206                        			.endp
  207                        	
  208               0001     		.ifdef	HUCC
  209    00:E40A             			.alias	_clear_palette		= clear_vce
  210                        		.endif
  211                        	
  212                        	
  213                        	
  214                        	; ***************************************************************************
  215                        	; ***************************************************************************
  216                        	;
  217                        	; read_palettes - Read palettes from the VCE into a buffer in RAM.
  218                        	;
  219                        	; Args: _al = Palette index (0..15 for BG, 16..31 for SPR).
  220                        	; Args: _ah = Palette count (1..32).
  221                        	; Args: _di = Pointer to palette data destination in RAM.
  222                        	;
  223                        	; The transfer is split into 32-byte chunks so that an HSYNC and/or TIMER
  224                        	; IRQ is not delayed for too long while executing.
  225                        	;
  226                        	
  227                        	read_palettes	.proc
  281                        			.endp
  282                        	
  283               0001     		.ifdef	HUCC
  284    00:E40A             			.alias	_read_palette.3		= read_palettes
  285                        		.endif
  286                        	
  287                        	
  288                        	
  289                        	vce_fade_funcs	.procgroup
  516                        			.endprocgroup
  517                        	
  518                        	
  519                        	
  520                        	; ***************************************************************************
  521                        	; ***************************************************************************
  522                        	;
  523                        	; cross_fade_to - Cross fade a palette in RAM towards a reference palette.
  524                        	;
  525                        	; Args: _al = Number of colors (1..256).
  526                        	; Args: _di = Pointer to faded palette destination in RAM.
  527                        	; Args: _bp = Pointer to reference palette data.
  528                        	; Args:   Y = Bank to map into MPR3 & MPR4, or zero to leave unchanged.
  529                        	;
  530                        	; N.B. Y==0 is only useful if the reference palette data is already mapped!
  531                        	;
  532                        	; N.B. This only updates the palette in RAM by 1 RGB step, so it will need
  533                        	;      to be called 7 times to guarantee that you've reached the target.
  534                        	;
  535                        	
  536                        	cross_fade_to	.proc
  658                        			.endp
                             #[2]   "..\..\..\include\hucc\hucc-final.asm"
                             #[3]   "..\..\..\include\hucc\vdc.asm"
   40                        			include	"vdc.asm"		; Useful VDC routines.
    1                        	; ***************************************************************************
    2                        	; ***************************************************************************
    3                        	;
    4                        	; vdc.asm
    5                        	;
    6                        	; Useful routines for operating the HuC6270 Video Display Controller.
    7                        	;
    8                        	; These should be located in permanently-accessible memory!
    9                        	;
   10                        	; Copyright John Brandwood 2021-2025.
   11                        	;
   12                        	; Distributed under the Boost Software License, Version 1.0.
   13                        	; (See accompanying file LICENSE_1_0.txt or copy at
   14                        	;  http://www.boost.org/LICENSE_1_0.txt)
   15                        	;
   16                        	; ***************************************************************************
   17                        	; ***************************************************************************
   18                        	
   19                        	;
   20                        	; Include dependancies ...
   21                        	;
   22                        	
   23                        			include "common.asm"		; Common helpers.
   24                        			include "vce.asm"		; Useful VCE routines.
   25                        	
   26                        	;
   27                        	; Choose how much to transfer to VRAM in a single chunk, normally 16-bytes.
   28                        	;
   29                        	; The cycle timings for a TIA-to-VRAM depend upon how the VDC's MWR CPU slots
   30                        	; line up to the CPU's writes, and how long the VDC has to halt the CPU while
   31                        	; it fetches the next scanline's sprite data.
   32                        	;
   33                        	; These cycle timings are for 0 sprites (best) and 16 sprites (worst) ...
   34                        	;
   35                        	; 32-byte TIA takes 270..364 cycles in 5MHz, 242..312 cycles in 7MHz. (8.44 cycles-per-byte best-case at 5MHz.)
   36                        	; 24-byte TIA takes 210..298 cycles in 5MHz, 186..256 cycles in 7MHz. (8.75 cycles-per-byte best-case at 5MHz.)
   37                        	; 16-byte TIA takes 142..234 cycles in 5MHz, 128..200 cycles in 7MHz. (8.88 cycles-per-byte best-case at 5MHz.)
   38                        	;
   39                        	; If a user wishes to be able to put RCR interrupts one-line-after-another,
   40                        	; then it is only safe to use 32-byte chunks if there are no TIMER or IRQ2
   41                        	; interrupts ... which is almost-impossible to rely on in library code!
   42                        	;
   43                        	
   44               0000     		.ifndef	VRAM_XFER_SIZE
   46                        		.endif
   47                        	
   48                        	;
   49                        	; Enable BG & SPR layers, and RCR interrupt.
   50                        	;
   51                        	
   52    00:E40A  A9 04      	set_rcron:	lda	#$04			; Enable RCR interrupt.
   53    00:E40C  80 0A      			bra	!+
   54                        	
   55    00:E40E  A9 80      	set_bgon:	lda	#$80			; Enable BG layer.
   56    00:E410  80 06      			bra	!+
   57                        	
   58    00:E412  A9 40      	set_spron:	lda	#$40			; Enable SPR layer.
   59    00:E414  80 02      			bra	!+
   60                        	
   61    00:E416  A9 C0      	set_dspon:	lda	#$C0			; Enable BG & SPR layers.
   62                        	
   63    00:E418  04 F3      	!:		tsb	<vdc_crl		; These take effect when
   64               0001     		.if	SUPPORT_SGX			; the next VBLANK occurs.
   65    00:E41A  04 03      			tsb	<sgx_crl
   66                        		.endif
   67    00:E41C  60         			rts
   68                        	
   69                        	;
   70                        	; Disable BG & SPR layers, and RCR interrupt.
   71                        	;
   72                        	
   73    00:E41D  A9 04      	set_rcroff:	lda	#$04			; Disable RCR interrupt.
   74    00:E41F  80 0A      			bra	!+
   75                        	
   76    00:E421  A9 80      	set_bgoff:	lda	#$80			; Disable BG layer.
   77    00:E423  80 06      			bra	!+
   78                        	
   79    00:E425  A9 40      	set_sproff:	lda	#$40			; Disable SPR layer.
   80    00:E427  80 02      			bra	!+
   81                        	
   82    00:E429  A9 C0      	set_dspoff:	lda	#$C0			; Disable BG & SPR layers.
   83                        	
   84    00:E42B  14 F3      	!:		trb	<vdc_crl		; These take effect when
   85               0001     		.if	SUPPORT_SGX			; the next VBLANK occurs.
   86    00:E42D  14 03      			trb	<sgx_crl
   87                        		.endif
   88    00:E42F  60         			rts
   89                        	
   90                        	
   91                        	
   92                        	; ***************************************************************************
   93                        	; ***************************************************************************
   94                        	;
   95                        	; Put the _di data pointer into the VDC's MARR or MAWR register.
   96                        	;
   97                        	; N.B. Library code relies on this preserving Y!
   98                        	;
   99                        	; Args: _di + 0 = BAT X coordinate.
  100                        	; Args: _di + 1 = BAT Y coordinate.
  101                        	;
  102                        	; Here because it relies on the "vdc_bat_width" that is defined in this file.
  103                        	;
  104                        	
  105               0001     		.if	SUPPORT_SGX
  106    00:E430  A2 10      	sgx_di_xy_marr:	ldx	#SGX_VDC_OFFSET		; Offset to SGX VDC.
  107    00:E432  F0         			db	$F0			; Turn "clx" into a "beq".
  108                        		.endif
  109                        	
  110    00:E433  82         	vdc_di_xy_marr:	clx				; Offset to PCE VDC.
  111                        	
  112    00:E434  62         	set_di_xy_mawr:	cla
  113    00:E435  3C 3C 25   			bit	vdc_bat_width, x	; Set by set_bat_size().
  114    00:E438  30 08      			bmi	.w128
  115    00:E43A  70 03      			bvs	.w64
  116    00:E43C  46 F1      	.w32:		lsr.h	<_di
  117    00:E43E  6A         			ror	a
  118    00:E43F  46 F1      	.w64:		lsr.h	<_di
  119    00:E441  6A         			ror	a
  120    00:E442  46 F1      	.w128:		lsr.h	<_di
  121    00:E444  6A         			ror	a
  122    00:E445  05 F0      			ora.l	<_di
  123    00:E447  85 F0      			sta.l	<_di
  124    00:E449  4C 7F E3   			jmp	set_di_to_mawr		; In "common.asm".
  125                        	
  126                        	
  127                        	
  128    02:C1C6             	vdc_clear_vram	.procgroup			; These routines share code!
  129                        	
  130                        	; ***************************************************************************
  131                        	; ***************************************************************************
  132                        	;
  133                        	; clear_vram_sgx - Clear all of VRAM in the SGX VDC.
  134                        	; clear_vram_vdc - Clear all of VRAM in the PCE VDC.
  135                        	;
  136                        	; Args: _ax = word value to write to the BAT.
  137                        	; Args: _bl = hi-byte of size of BAT (# of words).
  138                        	;
  139                        	
  140               0001     		.if	SUPPORT_SGX
  141    02:C1C6             	clear_vram_sgx	.proc
  142                        	
  143    02:C1C6  A2 10      			ldx	#SGX_VDC_OFFSET		; Offset to SGX VDC.
  144    02:C1C8  F0         			db	$F0			; Turn "clx" into a "beq".
  145                        	
  146    02:C1C9             			.ref	clear_vram_vdc		; Need clear_vram_vdc
  147                        			.endp
  148                        		.endif
  149                        	
  150    02:C1C9             	clear_vram_vdc	.proc
  151                        	
  152    02:C1C9  82         			clx				; Offset to PCE VDC.
  153                        	
  154    02:C1CA  20 37 FE   	clear_vram_x:	call	clear_bat_x		; Clear the BAT.
  155                        	
  156    02:C1CD  A9 80      			lda	#$80			; Xvert hi-byte of # words
  157    02:C1CF  38         			sec				; in screen to loop count.
  158    02:C1D0  E5 FA      			sbc	<_bl
  159    02:C1D2  4A         			lsr	a
  160                        	
  161                        	;		cly				; Clear the rest of VRAM.
  162    02:C1D3  9E 02 02   			stz	VDC_DL, x
  163    02:C1D6  9E 03 02   	.clr_loop:	stz	VDC_DH, x		; Seperate writes to minimize
  164    02:C1D9  88         			dey				; VDC MWR penalty.
  165    02:C1DA  9E 03 02   			stz	VDC_DH, x
  166    02:C1DD  D0 F7      			bne	.clr_loop
  167    02:C1DF  3A         			dec	a
  168    02:C1E0  D0 F4      			bne	.clr_loop
  169                        	
  170                        			leave				; All done, phew!
         02:C1E2  4C EF FF   			jmp	leave_proc
  171                        	
  172                        			.endp
  173                        	
  174                        	
  175                        	
  176                        	; ***************************************************************************
  177                        	; ***************************************************************************
  178                        	;
  179                        	; clear_bat_sgx - Clear the BAT in the SGX VDC.
  180                        	; clear_bat_vdc - Clear the BAT in the PCE VDC.
  181                        	;
  182                        	; Args: _ax = word value to write to the BAT.
  183                        	; Args: _bl = hi-byte of size of BAT (# of words).
  184                        	;
  185                        	
  186               0001     		.if	SUPPORT_SGX
  187                        	clear_bat_sgx	.proc
  193                        			.endp
  194                        		.endif
  195                        	
  196    02:C1E5             	clear_bat_vdc	.proc
  197                        	
  198    02:C1E5  82         			clx				; Offset to PCE VDC.
  199                        	
  200    02:C1E6             			.ref	clear_bat_x		; Need clear_bat_x
  201                        			.endp
  202                        	
  203    02:C1E6             	clear_bat_x	.proc				; HuCC uses this entry point.
  204                        	
  205    02:C1E6  64 F0      			stz	<_di + 0		; Set VDC or SGX destination
  206    02:C1E8  64 F1      			stz	<_di + 1		; address.
  207    02:C1EA  20 7F E3   			jsr	set_di_to_mawr
  208                        	
  209    02:C1ED  A5 FA      			lda	<_bl			; Xvert hi-byte of # words
  210    02:C1EF  4A         			lsr	a			; in screen to loop count.
  211                        	
  212    02:C1F0  C2         			cly
  213    02:C1F1  48         	.bat_loop:	pha
  214    02:C1F2  A5 F8      			lda	<_ax + 0
  215    02:C1F4  9D 02 02   			sta	VDC_DL, x
  216    02:C1F7  A5 F9      			lda	<_ax + 1
  217    02:C1F9  9D 03 02   	.bat_pair:	sta	VDC_DH, x		; Seperate writes to minimize
  218    02:C1FC  88         			dey				; VDC MWR penalty.
  219    02:C1FD  9D 03 02   			sta	VDC_DH, x
  220    02:C200  D0 F7      			bne	.bat_pair
  221                        	
  222    02:C202  68         			pla
  223    02:C203  3A         			dec	a
  224    02:C204  D0 EB      			bne	.bat_loop
  225                        	
  226                        			leave
         02:C206  4C EF FF   			jmp	leave_proc
  227                        	
  228                        			.endp
  229                        	
  230                        			.endprocgroup
  231                        	
  232                        	;
  233                        	;
  234                        	;
  235                        	
  236    01:D965             	vdc_set_mode	.procgroup			; These routines share code!
  237                        	
  238                        	; ***************************************************************************
  239                        	; ***************************************************************************
  240                        	;
  241                        	; set_mode_sgx - Set video hardware registers from a data table.
  242                        	; set_mode_vdc - Set video hardware registers from a data table.
  243                        	;
  244                        	; Args: _bp, Y = _farptr to data table mapped into MPR3 & MPR4.
  245                        	;
  246                        	
  247               0001     		.if	SUPPORT_SGX
  248    01:D965             	set_mode_sgx	.proc
  249                        	
  250    01:D965  A2 10      			ldx	#SGX_VDC_OFFSET		; Offset to SGX VDC.
  251    01:D967  F0         			db	$F0			; Turn "clx" into a "beq".
  252                        	
  253                        			.endp
  254                        		.endif
  255                        	
  256    01:D968             	set_mode_vdc	.proc
  257                        	
  258    01:D968  82         			clx				; Offset to PCE VDC.
  259                        	
  260    01:D969  F7 F8      			smb7	<_al			; Signal no set_bat_size() yet.
  261                        	
  262    01:D96B  43 08      			tma3				; Preserve MPR3.
  263    01:D96D  48         			pha
  264    01:D96E  43 10      			tma4				; Preserve MPR4.
  265    01:D970  48         			pha
  266                        	
  267    01:D971  20 3B E3   			jsr	map_bp_to_mpr34		; Map data to MPR3 & MPR4.
  268                        	
  269    01:D974  08         			php				; Disable interrupts.
  270    01:D975  78         			sei
  271                        	
  272    01:D976  C2         			cly				; Table size is < 256 bytes.
  273                        	
  274    01:D977  B1 EC      	.loop:		lda	[_bp], y		; Get the register #, +ve for
  275    01:D979  F0 46      			beq	.done			; VDC, -128 for VCE_CR.
  276    01:D97B  10 0C      			bpl	.set_vdc_reg
  277                        	
  278                        			; Set the VCE_CR register.
  279                        	
  280    01:D97D  C8         	.set_vce_cr:	iny
  281                        	
  282    01:D97E  B1 EC      			lda	[_bp], y		; Get lo-byte of register.
  283    01:D980  C8         			iny
  284    01:D981  8D 44 22   			sta	vce_cr			; No SGX shadow for this!
  285    01:D984  8D 00 04   			sta	VCE_CR			; Set the VCE clock speed.
  286    01:D987  80 EE      			bra	.loop			; Do not set VDC_MWR reg bits!
  287                        	
  288                        			; Set a VDC register.
  289                        	
  290    01:D989  C8         	.set_vdc_reg:	iny
  291    01:D98A  9D 00 02   			sta	VDC_AR, x		; Set which VDC register.
  292                        	
  293    01:D98D  C9 05      			cmp	#VDC_CR			; CS if VDC_CR or higher.
  294    01:D98F  F0 14      			beq	.skip_cc
  295    01:D991  18         			clc				; CC if not VDC_CR.
  296                        	
  297    01:D992  49 09      			eor	#VDC_MWR		; Check if this the VDC_MWR
  298    01:D994  D0 0F      			bne	.skip_cc		; without changing CC.
  299                        	
  300    01:D996  B1 EC      			lda	[_bp], y		; Remember the BAT size so that
  301    01:D998  8D 42 22   			sta	vdc_mwr			; set_bat_size() can be called.
  302    01:D99B  4A         			lsr	a
  303    01:D99C  4A         			lsr	a
  304    01:D99D  4A         			lsr	a
  305    01:D99E  4A         			lsr	a
  306    01:D99F  85 F8      			sta	<_al
  307    01:D9A1  C8         			iny
  308    01:D9A2  C8         			iny
  309    01:D9A3  80 D2      			bra	.loop
  310                        	
  311    01:D9A5  B1 EC      	.skip_cc:	lda	[_bp], y		; Get lo-byte of register.
  312    01:D9A7  C8         			iny
  313    01:D9A8  90 08      			bcc	.not_vdc_cr
  314                        	
  315               0001     		.if	SUPPORT_SGX
  316    01:D9AA  E0 00      			cpx	#0			; Writing to the VDC or SGX?
  317    01:D9AC  F0 02      			beq	.save_crl
  318    01:D9AE  29 F7      			and	#$F7			; We only need 1 vblank IRQ!
  319                        		.endif
  320                        	
  321    01:D9B0  95 F3      	.save_crl:	sta	<vdc_crl, x		; Save VDC_CR shadow register.
  322                        	
  323    01:D9B2  9D 02 02   	.not_vdc_cr:	sta	VDC_DL, x		; Write to VDC.
  324                        	
  325    01:D9B5  B1 EC      			lda	[_bp], y		; Get hi-byte of register.
  326    01:D9B7  C8         			iny
  327    01:D9B8  9D 03 02   			sta	VDC_DH, x
  328    01:D9BB  90 BA      			bcc	.loop			; Next register, please!
  329                        	
  330    01:D9BD  95 F4      			sta	<vdc_crh, x		; Save VDC_CR shadow register.
  331                        	
  332    01:D9BF  80 B6      			bra	.loop			; Next register, please!
  333                        	
  334                        			; All registers set!
  335                        	
  336    01:D9C1  A9 02      	.done:		lda	#VDC_VWR		; Leave with VDC_VWR set.
  337    01:D9C3  95 F7      			sta	<vdc_reg, x
  338                        	;		lda	<vdc_reg, x		; Restore previous VDC_AR from
  339    01:D9C5  9D 00 02   			sta	VDC_AR, x		; the shadow variable.
  340                        	
  341    01:D9C8  28         			plp				; Restore interrupts.
  342                        	
  343    01:D9C9  68         			pla				; Restore MPR4.
  344    01:D9CA  53 10      			tam4
  345    01:D9CC  68         			pla				; Restore MPR3.
  346    01:D9CD  53 08      			tam3
  347                        	
  348    01:D9CF  7F F8 07   			bbr7	<_al, set_bat_size	; Update if BAT size changed.
  349                        	
  350                        			leave				; All done, phew!
         01:D9D2  4C EF FF   			jmp	leave_proc
  351                        	
  352    01:D9D5             			.ref	set_bat_vdc
  353                        			.endp
  354                        	
  355                        	
  356                        	
  357                        	; ***************************************************************************
  358                        	; ***************************************************************************
  359                        	;
  360                        	; set_bat_sgx - Change the SGX BAT size and initialize variables based on it.
  361                        	; set_bat_vdc - Change the PCE BAT size and initialize variables based on it.
  362                        	;
  363                        	; Args: _al = new size (0-7).
  364                        	;
  365                        	; (VDC_MWR_32x32  >> 4) or in HuCC, SCR_SIZE_32x32.
  366                        	; (VDC_MWR_32x64  >> 4) or in HuCC, SCR_SIZE_32x64.
  367                        	; (VDC_MWR_64x32  >> 4) or in HuCC, SCR_SIZE_64x32.
  368                        	; (VDC_MWR_64x64  >> 4) or in HuCC, SCR_SIZE_64x64.
  369                        	; (VDC_MWR_128x32 >> 4) or in HuCC, SCR_SIZE_128x32.
  370                        	; (VDC_MWR_128x64 >> 4) or in HuCC, SCR_SIZE_128x64.
  371                        	;
  372                        	
  373               0001     		.if	SUPPORT_SGX
  374    01:D9D5             	set_bat_sgx	.proc
  375                        	
  376    01:D9D5  A2 10      			ldx	#SGX_VDC_OFFSET		; Offset to SGX VDC.
  377    01:D9D7  F0         			db	$F0			; Turn "clx" into a "beq".
  378                        	
  379    01:D9D8             			.ref	set_bat_vdc
  380                        			.endp
  381                        		.endif
  382                        	
  383    01:D9D8             	set_bat_vdc	.proc
  384                        	
  385    01:D9D8  82         			clx				; Offset to PCE VDC.
  386                        	
  387    01:D9D9  A5 F8      	set_bat_size:	lda	<_al			; Get BAT size value.
  388    01:D9DB  29 07      			and	#7			; Sanitize screen size value.
  389    01:D9DD  A8         			tay
  390    01:D9DE  0A         			asl	a			; Put it in bits 4..6.
  391    01:D9DF  0A         			asl	a
  392    01:D9E0  0A         			asl	a
  393    01:D9E1  0A         			asl	a
  394    01:D9E2  85 00      			sta	<__temp
  395                        	
  396    01:D9E4  B9 24 DA   			lda	.width, y
  397    01:D9E7  9D 3C 25   			sta	vdc_bat_width, x
  398    01:D9EA  3A         			dec	a
  399    01:D9EB  9D 3E 25   			sta	vdc_bat_x_mask, x
  400                        	
  401    01:D9EE  B9 2C DA   			lda	.height, y
  402    01:D9F1  9D 3D 25   			sta	vdc_bat_height, x
  403    01:D9F4  3A         			dec	a
  404    01:D9F5  9D 3F 25   			sta	vdc_bat_y_mask, x
  405                        	
  406    01:D9F8  B9 34 DA   			lda	.limit, y
  407    01:D9FB  9D 40 25   			sta	vdc_bat_limit, x
  408                        	
  409    01:D9FE  B9 3C DA   			lda	.increment, y		; Put the VRAM increment for a
  410    01:DA01  95 F4      			sta	<vdc_crh, x		; line into vdc_crh for later.
  411                        	
  412    01:DA03  08         			php
  413    01:DA04  78         			sei
  414                        	
  415    01:DA05  A9 09      			lda	#VDC_MWR
  416    01:DA07  9D 00 02   			sta	VDC_AR, x
  417                        	
  418    01:DA0A  AD 42 22   			lda	vdc_mwr			; Get the MWR access width bits.
  419    01:DA0D  29 8F      			and	#%10001111
  420    01:DA0F  05 00      			ora	<__temp
  421               0001     		.if	SUPPORT_SGX
  422    01:DA11  E0 00      			cpx	#PCE_VDC_OFFSET		; This has no SGX shadow!
  423    01:DA13  D0 03      			bne	!+
  424                        		.endif
  425    01:DA15  8D 42 22   			sta	vdc_mwr
  426    01:DA18  9D 02 02   	!:		sta	VDC_DL, x
  427                        	
  428    01:DA1B  B5 F7      			lda	<vdc_reg, x		; Restore previous VDC_AR from
  429    01:DA1D  9D 00 02   			sta	VDC_AR, x		; the shadow variable.
  430                        	
  431    01:DA20  28         			plp
  432                        	
  433                        			leave
         01:DA21  4C EF FF   			jmp	leave_proc
  434                        	
  435    01:DA24  20 40 80 80	.width:		db	$20,$40,$80,$80,$20,$40,$80,$80
         01:DA28  20 40 80 80 
  436    01:DA2C  20 20 20 20	.height:	db	$20,$20,$20,$20,$40,$40,$40,$40
         01:DA30  40 40 40 40 
  437    01:DA34  03 07 0F 0F	.limit:		db	$03,$07,$0F,$0F,$07,$0F,$1F,$1F
         01:DA38  07 0F 1F 1F 
  438    01:DA3C  08 10 18 18	.increment	db	$08,$10,$18,$18,$08,$10,$18,$18
         01:DA40  08 10 18 18 
  439                        	
  440               253C     			.bss
  441                        	
  442                        	; **************
  443                        	; 16-bytes of VDC BAT information.
  444                        	;
  445                        	; N.B. MUST be 16-bytes before the SGX versions to use PCE_VDC_OFFSET.
  446                        	;
  447                        	; N.B. Declared inside this .proc so that they can be stripped if unused.
  448                        	
  449                        	; Initialized by set_bat_vdc.
  450    F8:253C             	vdc_bat_width:	ds	1	; $20, $40, $80
  451    F8:253D             	vdc_bat_height:	ds	1	; $20, $40
  452    F8:253E             	vdc_bat_x_mask:	ds	1	; $1F, $3F, $7F
  453    F8:253F             	vdc_bat_y_mask:	ds	1	; $1F, $3F
  454    F8:2540             	vdc_bat_limit:	ds	1	; (>$03FF), (>$07FF), (>$0FFF), (>$1FFF)
  455                        	
  456                        	; From blkmap.asm just to avoid wasting .bss space with padding.
  457    F8:2541             	vdc_map_draw_w:	ds	1	; (SCR_WIDTH / 8) + 1
  458    F8:2542             	vdc_map_draw_h:	ds	1	; (SCR_HEIGHT / 8) + 1
  459    F8:2543             	vdc_map_line_w:	ds	1	; Line width of map data in tiles.
  460    F8:2544             	vdc_map_scrn_w:	ds	1	; Line width of map data in screens.
  461    F8:2545             	vdc_map_pxl_x:	ds	2	; Current top-left X in pixels.
  462    F8:2547             	vdc_map_pxl_y:	ds	2	; Current top-left Y in pixels.
  463    F8:2549             	vdc_map_option:	ds	1	; Flags to disable BAT alignment.
  464                        	
  465                        	; From hucc-old-spr.asm just to avoid wasting .bss space with padding.
  466    F8:254A             	spr_max:	ds	1
  467    F8:254B             	spr_clr:	ds	1
  468                        	
  469               0001     		.if	SUPPORT_SGX
  470                        	
  471                        	; **************
  472                        	; 16-bytes of SGX BAT information.
  473                        	;
  474                        	; N.B. MUST be 16-bytes after the VDC versions to use SGX_VDC_OFFSET.
  475                        	;
  476                        	; N.B. Declared inside this .proc so that they can be stripped if unused.
  477                        	
  478                        	; Initialized by set_bat_sgx.
  479    F8:254C             	sgx_bat_width:	ds	1	; $20, $40, $80
  480    F8:254D             	sgx_bat_height:	ds	1	; $20, $40
  481    F8:254E             	sgx_bat_x_mask:	ds	1	; $1F, $3F, $7F
  482    F8:254F             	sgx_bat_y_mask:	ds	1	; $1F, $3F
  483    F8:2550             	sgx_bat_limit:	ds	1	; (>$03FF), (>$07FF), (>$0FFF), (>$1FFF)
  484                        	
  485                        	; From blkmap.asm just to avoid wasting .bss space with padding.
  486    F8:2551             	sgx_map_draw_w:	ds	1	; (SCR_WIDTH / 8) + 1
  487    F8:2552             	sgx_map_draw_h:	ds	1	; (SCR_HEIGHT / 8) + 1
  488    F8:2553             	sgx_map_line_w:	ds	1	; Line width of map data in tiles.
  489    F8:2554             	sgx_map_scrn_w:	ds	1	; Line width of map data in screens.
  490    F8:2555             	sgx_map_pxl_x:	ds	2	; Current top-left X in pixels.
  491    F8:2557             	sgx_map_pxl_y:	ds	2	; Current top-left Y in pixels.
  492    F8:2559             	sgx_map_option:	ds	1	; Flags to disable BAT alignment.
  493                        	
  494                        	; From hucc-old-spr.asm just to avoid wasting .bss space with padding.
  495    F8:255A             	sgx_spr_max:	ds	1
  496    F8:255B             	sgx_spr_clr:	ds	1
  497                        	
  498                        		.endif
  499                        	
  500               DA44     			.code
  501                        	
  502                        			.endp
  503                        	
  504                        			.endprocgroup
  505                        	
  506                        	
  507                        	
  508                        	; ***************************************************************************
  509                        	; ***************************************************************************
  510                        	;
  511                        	; sgx_detect - Detect whether we're running on a SuperGrafx (and init VPC).
  512                        	;
  513                        	; Returns: X,C-flag, and "sgx_detected" = NZ, CS if detected.
  514                        	;
  515                        	; ***************************************************************************
  516                        	;
  517                        	; https://web.archive.org/web/20161129055659/http://cgfm2.emuviews.com/txt/sgxtech.txt
  518                        	;
  519                        	; ***************************************************************************
  520                        	;
  521                        	; HuC6202 VIDEO PRIORITY CONTROLLER (huge thanks to Charles MacDonald!)
  522                        	;
  523                        	; The VPC has no access to sprite priority data, it can only sort pixels
  524                        	; based upon which VDC and whether they are "sprite" or "background".
  525                        	;
  526                        	; This can sometimes lead to unexpected results with low-priority sprites.
  527                        	;
  528                        	; VPC registers $0008 and $0009 make up four 4-bit values that define the
  529                        	; enabled layers and priority setting for the four possible window areas.
  530                        	;
  531                        	; Bits 3-0 of $0008 are for the region where Window 1 and 2 overlap
  532                        	; Bits 7-4 of $0008 are for the region occupied by only Window 2
  533                        	; Bits 3-0 of $0009 are for the region occupied by only Window 1
  534                        	; Bits 7-4 of $0009 are for the region where no Window is present
  535                        	;
  536                        	;  Each 4-bit value has the same format:
  537                        	;
  538                        	;  Bit 0: VDC #1 graphics are 0=disabled, 1=enabled
  539                        	;  Bit 1: VDC #2 graphics are 0=disabled, 1=enabled
  540                        	;  Bit 2: Bit 0 of priority setting
  541                        	;  Bit 3: Bit 1 of priority setting
  542                        	;
  543                        	;   Priority Setting 0b00xx: (useful when VDC #1 is a fullscreen HUD)
  544                        	;
  545                        	;    FRONT
  546                        	;     SP1 = VDC #1 (pce) sprite pixels
  547                        	;     BG1 = VDC #1 (pce) background pixels
  548                        	;     SP2 = VDC #2 (sgx) sprite pixels
  549                        	;     BG2 = VDC #2 (sgx) background pixels
  550                        	;    BACK
  551                        	;
  552                        	;   Priority Setting 0b01xx: (useful for parallax backgrounds)
  553                        	;
  554                        	;    FRONT
  555                        	;     SP1 = VDC #1 (pce) sprite pixels
  556                        	;     SP2 = VDC #2 (sgx) sprite pixels
  557                        	;     BG1 = VDC #1 (pce) background pixels
  558                        	;     BG2 = VDC #2 (sgx) background pixels
  559                        	;    BACK
  560                        	;
  561                        	;   Priority Setting 0b10xx: (only useful for special effects)
  562                        	;
  563                        	;    FRONT
  564                        	;     BG1 = VDC #1 (pce) background pixels (transparent where sprites)
  565                        	;     BG2 = VDC #2 (sgx) background pixels
  566                        	;     SP1 = VDC #1 (pce) sprite pixels
  567                        	;     SP2 = VDC #2 (sgx) sprite pixels
  568                        	;    BACK
  569                        	
  570               0001     		.if	SUPPORT_SGX
  571               0001     		.if	1
  572    02:C209             	sgx_detect	.proc
  573                        	
  574    02:C209  A0 7F      			ldy	#$7F			; Use VRAM address $7F7F
  575    02:C20B  84 F0      			sty.l	<_di			; because it won't cause
  576    02:C20D  84 F1      			sty.h	<_di			; a screen glitch.
  577                        	
  578    02:C20F  20 7B E3   			jsr	sgx_di_to_mawr		; Write $0001 to SGX VRAM.
  579    02:C212  A0 01      			ldy	#$01
  580    02:C214  8C 12 02   			sty	SGX_DL
  581    02:C217  9C 13 02   			stz	SGX_DH
  582                        	
  583    02:C21A  20 7E E3   			jsr	vdc_di_to_mawr		; Write $0000 to VDC VRAM.
  584    02:C21D  9C 02 02   			stz	VDC_DL
  585    02:C220  9C 03 02   			stz	VDC_DH
  586                        	
  587    02:C223  20 6E E3   			jsr	sgx_di_to_marr		; Check value in SGX VRAM.
  588    02:C226  AC 12 02   			ldy	SGX_DL			; $01 if found, $00 if not.
  589    02:C229  8C E8 22   			sty	sgx_detected
  590    02:C22C  F0 10      			beq	!+			; Skip the rest if not SGX.
  591                        	
  592    02:C22E  20 7B E3   			jsr	sgx_di_to_mawr		; Write $0000 to SGX VRAM
  593    02:C231  9C 12 02   			stz	SGX_DL			; to clean VRAM contents.
  594    02:C234  9C 13 02   			stz	SGX_DH
  595                        	
  596    02:C237  73 44 C2 08			tii	.vpc_mode, VPC_CR, 8	; Initialize the HuC6202 VPC.
         02:C23B  02 08 00    
  597                        	
  598    02:C23E  98         	!:		tya
  599    02:C23F  AA         			tax				; "leave" copies X back to A.
  600    02:C240  4A         			lsr	a			; Also CC if PCE, CS if SGX.
  601                        	
  602                        			leave				; All done, phew!
         02:C241  4C EF FF   			jmp	leave_proc
  603                        		.else
  618                        		.endif
  619                        	
  620               0000     		.ifndef	SGX_PARALLAX
  622                        		.endif
  623                        	
  624               0001     		.if	SGX_PARALLAX
  625    02:C244  00 70      	.vpc_mode:	dw	$7000			; Use SGX as a parallax layer
  626    02:C246  00 00      			dw	$0000			; behind a VDC background.
  627    02:C248  00 00      			dw	$0000
  628    02:C24A  00 00      			dw	$0000
  629                        		.else
  634                        		.endif	SGX_PARALLAX
  635                        	
  636                        			.endp
  637                        	
  638               0000     		.ifndef	CORE_VERSION			; CORE has this in the kernel.
  642                        		.endif	CORE_VERSION
  643                        	
  644                        		.endif	SUPPORT_SGX
  645                        	
  646                        	
  647                        	
  648                        	
  649                        	vdc_copy_to	.procgroup			; These routines share code!
  799                        			.endprocgroup
  800                        	
  801                        	
  802                        	
  803                        	; ***************************************************************************
  804                        	; ***************************************************************************
  805                        	;
  806                        	; init_240x208 - An example of initializing screen and VRAM.
  807                        	;
  808                        	; This can be used as-is, or copied to your own program and modified.
  809                        	;
  810                        	
  811                        	init_240x208	.proc
  892                        			.endp
  893                        	
  894                        	
  895                        	
  896                        	; ***************************************************************************
  897                        	; ***************************************************************************
  898                        	;
  899                        	; init_256x224 - An example of initializing screen and VRAM.
  900                        	;
  901                        	; This can be used as-is, or copied to your own program and modified.
  902                        	;
  903                        	
  904                        	init_256x224	.proc
  985                        			.endp
  986                        	
  987                        	
  988                        	
  989                        	; ***************************************************************************
  990                        	; ***************************************************************************
  991                        	;
  992                        	; init_352x224 - An example of initializing screen and VRAM.
  993                        	;
  994                        	; This can be used as-is, or copied to your own program and modified.
  995                        	;
  996                        	
  997                        	init_352x224	.proc
 1078                        			.endp
 1079                        	
 1080                        	
 1081                        	
 1082                        	; ***************************************************************************
 1083                        	; ***************************************************************************
 1084                        	;
 1085                        	; init_512x224 - An example of initializing screen and VRAM.
 1086                        	;
 1087                        	; This can be used as-is, or copied to your own program and modified.
 1088                        	;
 1089                        	
 1090                        	init_512x224	.proc
 1171                        			.endp
 1172                        	
 1173                        	
 1174                        	
 1175                        	; ***************************************************************************
 1176                        	; ***************************************************************************
 1177                        	;
 1178                        	; init_320x208 - An example of initializing screen and VRAM.
 1179                        	;
 1180                        	; This can be used as-is, or copied to your own program and modified.
 1181                        	;
 1182                        	; This resolution is rarely-seen, but it has no overscan, so it has a use.
 1183                        	;
 1184                        	
 1185                        	init_320x208	.proc
 1266                        			.endp
                             #[2]   "..\..\..\include\hucc\hucc-final.asm"
   41                        	
                             #[3]   "..\..\..\include\hucc\hucc-math.asm"
   42                        			include	"hucc-math.asm"		; HuCC multiply and divide.
    1                        	; ***************************************************************************
    2                        	; ***************************************************************************
    3                        	;
    4                        	; hucc-math.asm
    5                        	;
    6                        	; Basic (i.e. very slow) 8-bit and 16-bit multiply and divide routines.
    7                        	;
    8                        	; Copyright John Brandwood 2021-2024.
    9                        	;
   10                        	; Distributed under the Boost Software License, Version 1.0.
   11                        	; (See accompanying file LICENSE_1_0.txt or copy at
   12                        	;  http://www.boost.org/LICENSE_1_0.txt)
   13                        	;
   14                        	; ***************************************************************************
   15                        	; ***************************************************************************
   16                        	;
   17                        	; This is basically a set of SDCC-compatible routines, but using Y:A for the
   18                        	; primary register instead of X:A.
   19                        	;
   20                        	; Using Y:A makes the routines instantly usable with HuCC, and it also makes
   21                        	; them usable with SDCC with just an "sxy" before and after the call.
   22                        	;
   23                        	; ***************************************************************************
   24                        	; ***************************************************************************
   25                        	
   26               E44C     			.code
   27                        	
   28               2000     	multiplier	=	__temp
   29               2094     	multiplicand	=	___SDCC_m6502_ret0
   30               2094     	product		=	multiplicand
   31                        	
   32               2000     	__mulint_PARM_2	=	multiplier
   33                        	
   34               2000     	divisor		=	__temp
   35               2094     	dividend	=	___SDCC_m6502_ret0
   36               2094     	quotient	=	dividend
   37               2096     	remainder	=	___SDCC_m6502_ret2
   38                        	
   39               2000     	__moduint_PARM_2 =	divisor
   40               2000     	__modsint_PARM_2 =	divisor
   41               2000     	__divuint_PARM_2 =	divisor
   42               2000     	__divsint_PARM_2 =	divisor
   43                        	
   44                        	
   45                        	
   46                        	; ***************************************************************************
   47                        	; int
   48                        	; _mulint (int a, int b)
   49                        	;
   50                        	; 1st parameter in Y:A (multiplicand)
   51                        	; 2nd parameter in __mulint_PARM_2 (multiplier)
   52                        	; result in Y:A
   53                        	;
   54                        	; N.B. signed and unsigned multiply only differ in the top 16 of the 32bits!
   55                        	
   56    00:E44C  85 94      	__mulint:	sta	<multiplicand + 0
   57    00:E44E  84 95      			sty	<multiplicand + 1
   58                        	
   59    00:E450  A2 10      			ldx	#16			; Loop 16 times.
   60                        	
   61    00:E452  46 95      			lsr	<multiplicand + 1	; Divide multiplicand by 2
   62    00:E454  66 94      			ror	<multiplicand + 0	; and clear the 16th bit.
   63                        	
   64    00:E456  62         			cla				; Clear top word of product.
   65    00:E457  85 96      			sta.l	<multiplicand + 2
   66    00:E459  90 0B      			bcc	.rotate
   67                        	
   68    00:E45B  A8         	.add:		tay				; Add the 16-bit multiplier to
   69    00:E45C  18         			clc				; top 16-bits of the product.
   70    00:E45D  A5 96      			lda	<multiplicand + 2
   71    00:E45F  65 00      			adc.l	<multiplier
   72    00:E461  85 96      			sta	<multiplicand + 2
   73    00:E463  98         			tya
   74    00:E464  65 01      			adc.h	<multiplier
   75                        	
   76    00:E466  6A         	.rotate:	ror	a			; Rotate product into the top
   77    00:E467  66 96      			ror	<multiplicand + 2	; bits of the multiplicand ...
   78    00:E469  66 95      			ror	<multiplicand + 1	; and divide multiplicand by 2.
   79    00:E46B  66 94      			ror	<multiplicand + 0
   80                        	
   81    00:E46D  CA         			dex
   82    00:E46E  B0 EB      			bcs	.add			; Add multiplier to top word?
   83    00:E470  D0 F4      			bne	.rotate			; Completed 16 bits?
   84                        	
   85    00:E472  85 97      			sta	<multiplicand + 3	; Save top byte of product.
   86                        	
   87    00:E474  A5 94      			lda.l	<multiplicand		; Return the bottom 16-bits of
   88    00:E476  A4 95      			ldy.h	<multiplicand		; the 32-bit product.
   89                        	
   90    00:E478  60         			rts
   91                        	
   92                        	
   93                        	
   94                        	; ***************************************************************************
   95                        	; unsigned int
   96                        	; _divuint (unsigned int x, unsigned int y)
   97                        	;
   98                        	; 1st parameter in Y:A (unsigned dividend)
   99                        	; 2nd parameter in __divuint_PARM_2 (unsigned divisor)
  100                        	; result in Y:A
  101                        	
  102    00:E479  20 81 E4   	__divuint:	jsr	__moduint		; Call the basic uint division.
  103                        	
  104    00:E47C  A5 94      			lda.l	<quotient		; Then get the result from where
  105    00:E47E  A4 95      			ldy.h	<quotient		; it was calculated.
  106    00:E480  60         			rts
  107                        	
  108                        	
  109                        	
  110                        	; ***************************************************************************
  111                        	; unsigned int
  112                        	; _moduint (unsigned int x, unsigned int y)
  113                        	;
  114                        	; 1st parameter in Y:A (unsigned dividend)
  115                        	; 2nd parameter in __moduint_PARM_2 (unsigned divisor)
  116                        	; result in Y:A
  117                        	;
  118                        	; If the dividend has more bits than the divisor, then we need to check the
  119                        	; 17th bit of the remainder!
  120                        	
  121               0000     		.if	0
  176                        		.else
  177                        	
  178    00:E481  85 94      	__moduint:	sta.l	<dividend		; 1st SDCC parameter in Y:A.
  179    00:E483  84 95      			sty.h	<dividend
  180                        	
  181    00:E485  A5 00      	divmoduint:	lda.l	<divisor		; Check for a divide-by-zero.
  182    00:E487  05 01      			ora.h	<divisor
  183    00:E489  F0 FE      	.zero:		beq	.zero
  184                        	
  185    00:E48B  A2 11      			ldx	#16 + 1
  186                        	
  187    00:E48D  C2         			cly				; Clear remainder.
  188    00:E48E  84 97      			sty.h	<remainder
  189                        	
  190    00:E490  98         	.skip:		tya				; Restore remainder lo-byte.
  191                        	
  192    00:E491  26 94      	.loop:		rol.l	<dividend		; Quotient bit -> dividend LSB.
  193    00:E493  26 95      			rol.h	<dividend		; Rotate dividend, MSB -> C.
  194                        	
  195    00:E495  CA         			dex
  196    00:E496  F0 14      			beq	.finished
  197                        	
  198    00:E498  2A         			rol	a			; Rotate C into remainder.
  199    00:E499  26 97      			rol.h	<remainder
  200                        	;		php				; Preserve remainder 17th bit.
  201                        	
  202    00:E49B  A8         			tay				; Preserve remainder lo-byte.
  203                        	
  204    00:E49C  C5 00      			cmp.l	<divisor		; Test divisor.
  205    00:E49E  A5 97      			lda.h	<remainder
  206    00:E4A0  E5 01      			sbc.h	<divisor
  207    00:E4A2  90 EC      			bcc	.skip			; CC if divisor > remainder.
  208                        	
  209                        	;		cmp.l	<divisor		; If the dividend has more bits
  210                        	;		lda.h	<remainder		; than the divisor then we need
  211                        	;		sbc.h	<divisor		; to check the remainder hi-bit.
  212                        	;		bcs	.subtract		; CS if divisor <= remainder.
  213                        	;		plp				; Restore remainder 17th bit.
  214                        	;		bcc	.skip			; CC if divisor > remainder.
  215                        	;		db	$90			; Turn "plp" into "bcc" to skip.
  216                        	;.subtract:	plp				; Discard remainder 17th bit.
  217                        	;		sec
  218                        	
  219    00:E4A4  85 97      			sta.h	<remainder		; Subtract divisor.
  220    00:E4A6  98         			tya
  221    00:E4A7  E5 00      			sbc.l	<divisor
  222    00:E4A9  38         			sec				
  223    00:E4AA  80 E5      			bra	.loop
  224                        	
  225    00:E4AC  A4 97      	.finished:	ldy.h	<remainder		; Get the remainder hi-byte.
  226                        	
  227    00:E4AE  60         			rts
  228                        	
  229                        		.endif
  230                        	
  231                        	
  232                        	
  233                        	; ***************************************************************************
  234                        	; int
  235                        	; _divsint (int x, int y)
  236                        	;
  237                        	; 1st parameter in Y:A (signed dividend)
  238                        	; 2nd parameter in __divsint_PARM_2 (signed divisor)
  239                        	; result in Y:A
  240                        	
  241    00:E4AF  20 B7 E4   	__divsint:	jsr	__modsint		; Call the basic sint division.
  242                        	
  243    00:E4B2  A5 94      			lda.l	<quotient		; Then get the result from where
  244    00:E4B4  A4 95      			ldy.h	<quotient		; it was calculated.
  245    00:E4B6  60         			rts
  246                        	
  247                        	
  248                        	
  249                        	; ***************************************************************************
  250                        	; int
  251                        	; _modsint (int x, int y)
  252                        	;
  253                        	; 1st parameter in Y:A (signed dividend)
  254                        	; 2nd parameter in __modsint_PARM_2 (signed divisor)
  255                        	; result in Y:A
  256                        	
  257    00:E4B7  84 95      	__modsint:	sty.h	<dividend
  258                        	
  259    00:E4B9  C0 80      			cpy	#$80			; Remainder -ve if dividend
  260    00:E4BB  08         			php				; was -ve.
  261    00:E4BC  90 03      			bcc	!+
  262    00:E4BE  20 0E E5   			jsr	neg_yacs		; Negate the dividend.
  263                        	
  264    00:E4C1  85 94      	!:		sta.l	<dividend		; Store the dividend.
  265    00:E4C3  A5 95      			lda.h	<dividend
  266    00:E4C5  84 95      			sty.h	<dividend
  267                        	
  268    00:E4C7  45 01      			eor.h	<divisor		; Quotient is -ve if divisor
  269    00:E4C9  08         			php				; and dividend signs differ.
  270                        	
  271    00:E4CA  A5 01      			lda.h	<divisor		; Is the divisor -ve?
  272    00:E4CC  10 0B      			bpl	!+
  273                        	
  274    00:E4CE  38         			sec				; Negate the divisor.
  275    00:E4CF  62         			cla
  276    00:E4D0  E5 00      			sbc.l	<divisor
  277    00:E4D2  85 00      			sta.l	<divisor
  278    00:E4D4  62         			cla
  279    00:E4D5  E5 01      			sbc.h	<divisor
  280    00:E4D7  85 01      			sta.h	<divisor
  281                        	
  282    00:E4D9  20 85 E4   	!:		jsr	divmoduint		; Do the unsigned division.
  283                        	
  284    00:E4DC  28         	.result:	plp				; Should the quotient be -ve?
  285    00:E4DD  10 0D      			bpl	.remainder
  286                        	
  287    00:E4DF  AA         			tax				; Preserve remainder lo-byte.
  288                        	
  289    00:E4E0  38         			sec				; Then negate the quotient.
  290    00:E4E1  62         			cla
  291    00:E4E2  E5 94      			sbc.l	<dividend
  292    00:E4E4  85 94      			sta.l	<dividend
  293    00:E4E6  62         			cla
  294    00:E4E7  E5 95      			sbc.h	<dividend
  295    00:E4E9  85 95      			sta.h	<dividend
  296                        	
  297    00:E4EB  8A         			txa				; Restore remainder lo-byte.
  298                        	
  299    00:E4EC  28         	.remainder:	plp				; Was the dividend -ve?
  300    00:E4ED  B0 1F      			bcs	neg_yacs		; Then negate the remainder.
  301    00:E4EF  60         			rts
  302                        	
  303                        	
  304                        	
  305                        	; ***************************************************************************
  306                        	; unsigned int
  307                        	; _muluchar (unsigned char x, unsigned char y)
  308                        	;
  309                        	; 1st parameter in A (unsigned multiplicand)
  310                        	; 2nd parameter in Y (unsigned multiplier)
  311                        	; result in Y:A
  312                        	
  313    00:E4F0  84 00      	__muluchar:	sty	<multiplier
  314                        	
  315    00:E4F2  A0 08      	muluchar_a:	ldy	#8			; Loop 8 times.
  316                        	
  317    00:E4F4  4A         			lsr	a			; Divide multiplicand by 2
  318    00:E4F5  85 94      			sta	<multiplicand		; and clear the 8th bit.
  319                        	
  320    00:E4F7  62         			cla				; Clear top byte of product.
  321    00:E4F8  90 03      			bcc	.rotate
  322                        	
  323    00:E4FA  18         	.add:		clc				; Add the 8-bit multiplier to
  324    00:E4FB  65 00      			adc	<multiplier		; top 8-bits of the product.
  325                        	
  326    00:E4FD  6A         	.rotate:	ror	a			; Rotate product into the top
  327    00:E4FE  66 94      			ror	<multiplicand		; bits of the multiplicand.
  328                        	
  329    00:E500  88         			dey
  330    00:E501  B0 F7      			bcs	.add			; Add multiplier to top byte?
  331    00:E503  D0 F8      			bne	.rotate			; Completed 8 bits?
  332                        	
  333    00:E505  A8         			tay				; Return the 16-bit product.
  334    00:E506  A5 94      			lda	<multiplicand
  335                        	
  336    00:E508  60         			rts
  337                        	
  338                        	
  339                        	
  340                        	; ***************************************************************************
  341                        	; signed int
  342                        	; abs (signed int x)
  343                        	;
  344                        	; 1st parameter in Y:A (signed)
  345                        	; result in Y:A
  346                        	
  347    00:E509  C0 80      	_abs:		cpy	#$80			; Is the hi-byte -ve?
  348    00:E50B  90 0B      			bcc	!+
  349                        	
  350    00:E50D  38         	neg_ya:		sec
  351    00:E50E  49 FF      	neg_yacs:	eor	#$FF
  352    00:E510  69 00      			adc	#0
  353    00:E512  42         			say
  354    00:E513  49 FF      			eor	#$FF
  355    00:E515  69 00      			adc	#0
  356    00:E517  42         			say
  357    00:E518  60         	!:		rts
  358                        	
  359    00:E519             	_abs.1		.alias	_abs
  360                        	
  361                        	
  362                        	
  363                        	; ***************************************************************************
  364                        	; signed int
  365                        	; _mulschar (signed char x, signed char y)
  366                        	;
  367                        	; 1st parameter in A (signed multiplicand)
  368                        	; 2nd parameter in Y (signed multiplier)
  369                        	; result in Y:A
  370                        	;
  371                        	; N.B. Y and A get swapped to make the code shorter.
  372                        	
  373    00:E519  85 94      	__mulschar:	sta	<multiplicand		; Remember multiplicand sign.
  374                        	
  375    00:E51B  C9 80      			cmp	#$80			; Is the multiplicand -ve?
  376    00:E51D  90 03      			bcc	!+
  377    00:E51F  49 FF      			eor	#$FF			; Negate the multiplicand.
  378    00:E521  1A         			inc	a
  379    00:E522  85 00      	!:		sta	<multiplier		; Then save it as multiplier.
  380                        	
  381    00:E524  98         			tya				; Product -ve if multiplicand
  382    00:E525  45 94      			eor	<multiplicand		; and multiplier signs differ.
  383    00:E527  08         			php				; Remember product sign.
  384                        	
  385    00:E528  98         			tya				; Is the multiplicand -ve?
  386    00:E529  10 03      			bpl	!+
  387    00:E52B  49 FF      			eor	#$FF			; Negate the multiplicand.
  388    00:E52D  1A         			inc	a
  389                        	
  390    00:E52E  20 F2 E4   	!:		jsr	muluchar_a		; Multiplier already saved.
  391                        	
  392    00:E531  28         			plp				; Is the product -ve?
  393    00:E532  30 D9      			bmi	neg_ya
  394    00:E534  60         			rts
  395                        	
  396                        	
  397                        	
  398                        	; ***************************************************************************
  399                        	; unsigned int
  400                        	; _mulsuchar (signed char x, signed char y)
  401                        	;
  402                        	; 1st parameter in A (unsigned multiplicand)
  403                        	; 2nd parameter in Y (signed multiplier)
  404                        	; result in Y:A
  405                        	;
  406                        	; N.B. Y and A get swapped to make the code shorter.
  407                        	
  408    00:E535  42         	__mulsuchar:	say				; Put the signed param in A.
  409                        			; drop through to __muluschar
  410                        	
  411                        	
  412                        	
  413                        	; ***************************************************************************
  414                        	; signed int
  415                        	; _muluschar (unsigned char x, unsigned char y)
  416                        	;
  417                        	; 1st parameter in A (signed multiplicand)
  418                        	; 2nd parameter in Y (unsigned multiplier)
  419                        	; result in Y:A
  420                        	
  421    00:E536  C9 80      	__muluschar:	cmp	#$80			; Is multiplicand -ve?
  422    00:E538  08         			php				; Remember the sign.
  423    00:E539  90 03      			bcc	!+
  424    00:E53B  49 FF      			eor	#$FF			; Negate multiplicand.
  425    00:E53D  1A         			inc	a
  426                        	
  427    00:E53E  20 F0 E4   	!:		jsr	__muluchar		; Do the unsigned multiply.
  428                        	
  429    00:E541  28         			plp				; Was multiplicand -ve?
  430    00:E542  B0 CA      			bcs	neg_yacs		; Then negate the product.
  431    00:E544  60         			rts
  432                        	
  433                        	
  434                        	
  435                        	; ***************************************************************************
  436                        	; unsigned int
  437                        	; _moduchar (unsigned char x, unsigned char y)
  438                        	;
  439                        	; 1st parameter in A (unsigned dividend)
  440                        	; 2nd parameter in Y (unsigned divisor)
  441                        	; result in Y:A
  442                        	
  443    00:E545  84 00      	__moduchar:	sty.l	<divisor
  444                        	
  445    00:E547  0A         	divmodu8_a:	asl	a			; Rotate dividend, MSB -> C.
  446    00:E548  85 94      			sta.l	<dividend
  447    00:E54A  64 95      			stz.h	<dividend		; Clear quotient hi-byte.
  448                        	
  449    00:E54C  A0 08      			ldy	#8
  450    00:E54E  62         			cla				; Clear remainder.
  451    00:E54F  2A         	.loop:		rol	a			; Rotate C into remainder.
  452    00:E550  C5 00      			cmp	<divisor		; Test divisor.
  453    00:E552  90 02      			bcc	.skip			; CC if divisor > remainder.
  454    00:E554  E5 00      			sbc	<divisor		; Subtract divisor.
  455    00:E556  26 94      	.skip:		rol	<dividend		; Quotient bit -> dividend LSB.
  456    00:E558  88         			dey
  457    00:E559  D0 F4      			bne	.loop
  458                        	
  459    00:E55B  C2         			cly				; Clear hi-byte of return.
  460    00:E55C  60         			rts				; Return the 16-bit remainder.
  461                        	
  462                        	
  463                        	
  464                        	; ***************************************************************************
  465                        	; unsigned int
  466                        	; _divuchar (unsigned char x, unsigned char y)
  467                        	;
  468                        	; 1st parameter in A (unsigned dividend)
  469                        	; 2nd parameter in Y (unsigned divisor)
  470                        	; result in Y:A
  471                        	
  472    00:E55D  20 45 E5   	__divuchar:	jsr	__moduchar
  473                        	
  474    00:E560  A5 94      			lda	<dividend		; Get the dividend lo-byte.
  475    00:E562  60         			rts				; Return the 16-bit dividend.
  476                        	
  477                        	
  478                        	
  479                        	; ***************************************************************************
  480                        	; signed int
  481                        	; _modschar (signed char x, signed char y)
  482                        	;
  483                        	; 1st parameter in A (signed dividend)
  484                        	; 2nd parameter in Y (signed divisor)
  485                        	; result in Y:A
  486                        	
  487    00:E563  AA         	__modschar:	tax				; Preserve the dividend.
  488    00:E564  08         			php				; Remember remainder sign.
  489                        	
  490    00:E565  84 00      			sty	<divisor		; Quotient negative if divisor
  491    00:E567  45 00      			eor	<divisor		; and dividend signs differ.
  492    00:E569  08         			php				; Remember the quotient sign.
  493                        	
  494    00:E56A  98         			tya				; Is the divisor -ve?
  495    00:E56B  10 05      			bpl	!+
  496    00:E56D  49 FF      			eor	#$FF			; Negate the divisor.
  497    00:E56F  1A         			inc	a
  498    00:E570  85 00      			sta	<divisor
  499                        	
  500    00:E572  8A         	!:		txa				; Is the dividend -ve?
  501    00:E573  10 03      			bpl	divmods8_a
  502                        	
  503    00:E575  49 FF      	divmods8_neg:	eor	#$FF			; Negate the dividend.
  504    00:E577  1A         			inc	a
  505                        	
  506    00:E578  20 47 E5   	divmods8_a:	jsr	divmodu8_a		; Do the unsigned division.
  507                        	
  508    00:E57B  28         			plp				; Should the quotient be -ve?
  509    00:E57C  10 0C      			bpl	!+
  510                        	
  511    00:E57E  AA         			tax				; Preserve remainder lo-byte.
  512                        	
  513    00:E57F  38         			sec				; Negate the quotient.
  514    00:E580  62         			cla
  515    00:E581  E5 94      			sbc.l	<dividend
  516    00:E583  85 94      			sta.l	<dividend
  517    00:E585  A9 FF      			lda	#$FF
  518    00:E587  85 95      			sta.h	<dividend
  519                        	
  520    00:E589  8A         			txa				; Restore remainder lo-byte.
  521                        	
  522    00:E58A  28         	!:		plp				; Was the dividend -ve?
  523    00:E58B  10 05      			bpl	!+
  524                        	
  525    00:E58D  49 FF      			eor	#$FF			; Then negate the remainder.
  526    00:E58F  1A         			inc	a
  527    00:E590  A0 FF      			ldy	#$FF
  528                        	
  529    00:E592  60         	!:		rts
  530                        	
  531                        	
  532                        	
  533                        	; ***************************************************************************
  534                        	; signed int
  535                        	; _moduschar (unsigned char x, unsigned char y)
  536                        	;
  537                        	; 1st parameter in A (signed dividend)
  538                        	; 2nd parameter in Y (unsigned divisor)
  539                        	; result in Y:A
  540                        	
  541    00:E593  84 00      	__moduschar:	sty.l	<divisor
  542                        	
  543    00:E595  A8         			tay				; Is the dividend -ve?
  544    00:E596  08         			php				; Remember remainder sign.
  545    00:E597  08         			php				; Remember quotient sign.
  546    00:E598  30 DB      			bmi	divmods8_neg
  547    00:E59A  80 DC      			bra	divmods8_a
  548                        	
  549                        	
  550                        	
  551                        	; ***************************************************************************
  552                        	; unsigned int
  553                        	; _modsuchar (signed char x, signed char y)
  554                        	;
  555                        	; 1st parameter in A (unsigned dividend)
  556                        	; 2nd parameter in Y (signed divisor)
  557                        	; result in Y:A
  558                        	
  559    00:E59C  AA         	__modsuchar:	tax				; Preserve the dividend.
  560    00:E59D  08         			php				; Remember remainder sign.
  561                        	
  562    00:E59E  98         			tya				; Check the divisor sign.
  563    00:E59F  08         			php				; Remember quotient sign.
  564    00:E5A0  10 03      			bpl	!+
  565    00:E5A2  49 FF      			eor	#$FF			; Negate the divisor.
  566    00:E5A4  1A         			inc	a
  567    00:E5A5  85 00      	!:		sta.l	<divisor
  568                        	
  569    00:E5A7  8A         			txa				; Restore the dividend.
  570    00:E5A8  80 CE      			bra	divmods8_a
  571                        	
  572                        	
  573                        	
  574                        	; ***************************************************************************
  575                        	; signed int
  576                        	; _divschar (signed char x, signed char y)
  577                        	;
  578                        	; 1st parameter in A (signed dividend)
  579                        	; 2nd parameter in Y (signed divisor)
  580                        	; result in Y:A
  581                        	
  582    00:E5AA  20 63 E5   	__divschar:	jsr	__modschar
  583                        	
  584    00:E5AD  A5 94      			lda.l	<dividend
  585    00:E5AF  A4 95      			ldy.h	<dividend
  586    00:E5B1  60         			rts
  587                        	
  588                        	
  589                        	
  590                        	; ***************************************************************************
  591                        	; signed int
  592                        	; _divuschar (unsigned char x, unsigned char y)
  593                        	;
  594                        	; 1st parameter in A (signed dividend)
  595                        	; 2nd parameter in Y (unsigned divisor)
  596                        	; result in Y:A
  597                        	
  598    00:E5B2  20 93 E5   	__divuschar:	jsr	__moduschar
  599                        	
  600    00:E5B5  A5 94      			lda.l	<dividend
  601    00:E5B7  A4 95      			ldy.h	<dividend
  602    00:E5B9  60         			rts
  603                        	
  604                        	
  605                        	
  606                        	; ***************************************************************************
  607                        	; unsigned int
  608                        	; _divsuchar (signed char x, signed char y)
  609                        	;
  610                        	; 1st parameter in A (unsigned dividend)
  611                        	; 2nd parameter in Y (signed divisor)
  612                        	; result in Y:A
  613                        	
  614    00:E5BA  20 9C E5   	__divsuchar:	jsr	__modsuchar
  615                        	
  616    00:E5BD  A5 94      			lda.l	<dividend
  617    00:E5BF  A4 95      			ldy.h	<dividend
  618    00:E5C1  60         			rts
                             #[2]   "..\..\..\include\hucc\hucc-final.asm"
   43                        	
   44                        			; Define in hucc-config.inc to remove this.
   45                        	
   46               0001     		.ifndef	HUCC_NO_DEFAULT_RANDOM
                             #[3]   "..\..\..\include\hucc\random.asm"
   47                        			include	"random.asm"		; Random number generator.
    1                        	; ***************************************************************************
    2                        	; ***************************************************************************
    3                        	;
    4                        	; random.asm
    5                        	;
    6                        	; Pseudo-random number generator (https://github.com/bbbradsmith/prng_6502)
    7                        	;
    8                        	; Copyright Brad Smith 2019.
    9                        	;
   10                        	; License:
   11                        	;
   12                        	; This code and may be used, reused, and modified for any purpose, commercial
   13                        	; or non-commercial.
   14                        	;
   15                        	; Attribution in released binaries or documentation is appreciated but not
   16                        	; required.
   17                        	;
   18                        	; ***************************************************************************
   19                        	; ***************************************************************************
   20                        	;
   21                        	; This is a linear feedback shift register (LFSR) in Galois form, which is
   22                        	; iterated 8 times to produce an 8-bit pseudo-random number.
   23                        	;
   24                        	; Two widths of LFSR are provided:
   25                        	;
   26                        	;  24-bit requires 3 bytes, and repeats after 16777215 calls.
   27                        	;  32-bit requires 4 bytes, and repeats after 4294967295 calls.
   28                        	;
   29                        	; Usage:
   30                        	;
   31                        	;  Initialize the zero-page "random" variable to any value other than 0.
   32                        	;  The size of "random" is 3 or 4 bytes, depending on the width of LFSR
   33                        	;  chosen.
   34                        	;
   35                        	;  Call one of the RNG functions and an 8-bit result will be returned in the
   36                        	;  A-register (with flags), and the Y-register will be clobbered.
   37                        	;
   38                        	;  Do not mix RNGs of different width in the same program, unless you can
   39                        	;  give them each separate "random" state storage.
   40                        	;
   41                        	; ***************************************************************************
   42                        	; ***************************************************************************
   43                        	
   44                        	
   45               0001     		.ifndef	_KICKC				; Variables defined in C?
   46               2098     			.zp
   47    F8:2098             	random:		.ds	4			; Seed is 3 or 4 bytes.
   48               E5C2     			.code
   49                        		.endif	_KICKC
   50                        	
   51                        	
   52                        	
   53                        	; ***************************************************************************
   54                        	; ***************************************************************************
   55                        	;
   56                        	; init_random - Initialize a 32-bit LFSR using an 8-bit seed value in Y.
   57                        	;
   58                        	; The LFSR is initialized to n'th entry of a standard CRC-32 lookup-table,
   59                        	; which gives it a decent distribution of bits.
   60                        	;
   61                        	; Since seed is an 8-bit value, there are 255 (256-1) possible starting
   62                        	; states for the LFSR, because 0 would generate a 0 state.
   63                        	;
   64                        	; CRC-32 code by Paul Guertin. See http://6502.org/source/integers/crc.htm
   65                        	;
   66                        	
   67    02:C2C9             	init_random	.proc
   68                        	
   69    02:C2C9  A9 01      			lda	#1			; Init CRC-32 table value.
   70    02:C2CB  85 98      			sta	<random + 0
   71    02:C2CD  98         			tya				; Get and check the seed value.
   72    02:C2CE  D0 01      			bne	.reverse_seed
   73    02:C2D0  3A         			dec	a			; Which must be non-zero!
   74    02:C2D1  4A         	.reverse_seed:	lsr	a			; Reverse the bits so that small changes
   75    02:C2D2  26 98      			rol	<random + 0		; in the seed make larger differences in
   76    02:C2D4  90 FB      			bcc	.reverse_seed		; the initial state.
   77                        	
   78    02:C2D6  64 99      			stz	<random + 1		; A contains the high byte of the CRC-32.
   79    02:C2D8  64 9A      			stz	<random + 2		; The other three bytes are in memory.
   80    02:C2DA  62         			cla
   81                        	
   82    02:C2DB  A0 08      			ldy	#8			; Y counts bits in a byte.
   83    02:C2DD  4A         	.bit_loop:	lsr	a			; The CRC-32 algorithm is similar to CRC-16
   84    02:C2DE  66 9A      			ror	<random + 2		; except that it is reversed (originally for
   85    02:C2E0  66 99      			ror	<random + 1		; hardware reasons). This is why we shift
   86    02:C2E2  66 98      			ror	<random + 0		; right instead of left here.
   87    02:C2E4  90 16      			bcc	.no_add			; Do nothing if no overflow,
   88    02:C2E6  49 ED      			eor	#$ED			; else add CRC-32 polynomial $EDB88320.
   89                        	
   90    02:C2E8  48         			pha				; Save high byte while we do others.
   91    02:C2E9  A5 9A      			lda	<random + 2
   92    02:C2EB  49 B8      			eor	#$B8			; Most reference books give the CRC-32 poly
   93    02:C2ED  85 9A      			sta	<random + 2		; as $04C11DB7. This is actually the same if
   94    02:C2EF  A5 99      			lda	<random + 1		; you write it in binary and read it right-
   95    02:C2F1  49 83      			eor	#$83			; to-left instead of left-to-right. Doing it
   96    02:C2F3  85 99      			sta	<random + 1		; this way means we won't have to explicitly
   97    02:C2F5  A5 98      			lda	<random + 0		; reverse things afterwards.
   98    02:C2F7  49 20      			eor	#$20
   99    02:C2F9  85 98      			sta	<random + 0
  100    02:C2FB  68         			pla				; Restore high byte.
  101                        	
  102    02:C2FC  88         	.no_add:	dey				; Do next bit.
  103    02:C2FD  D0 DE      			bne	.bit_loop
  104                        	
  105    02:C2FF  85 9B      			sta	<random + 3		; Save CRC-32 high-byte.
  106                        	
  107                        			leave				; All done!
         02:C301  4C EF FF   			jmp	leave_proc
  108                        	
  109                        			.endp
  110                        	
  111                        	
  112                        	
  113                        	; ***************************************************************************
  114                        	; ***************************************************************************
  115                        	;
  116                        	; get_random - 8-bit LFSR pseudo-random number with a 24-bit cycle.
  117                        	;
  118                        	; The pseudo-random sequence repeats after (2^24)-1 calls.
  119                        	;
  120                        	; Written by Wim Couwenberg, see ...
  121                        	;
  122                        	; "https://wimcouwenberg.wordpress.com/2020/11/15/ ...
  123                        	;  a-fast-24-bit-prng-algorithm-for-the-6502-processor/"
  124                        	;
  125                        	; Takes 68 cycles on the HuC6280, incl JSR & RTS.
  126                        	;
  127                        	; N.B. HuCC library code relies on this preserving X and Y!
  128                        	;
  129                        	
  130    00:E5C2  C2         	_rand8:		cly				; Entry point for HuCC.
  131                        	
  132    00:E5C3  A5 98      	get_random:	lda	<random + 0		; Operation 7 (with carry clear).
  133    00:E5C5  0A         			asl	a
  134    00:E5C6  45 99      			eor	<random + 1
  135    00:E5C8  85 99      			sta	<random + 1
  136    00:E5CA  2A         			rol	a             		; Operation 9.
  137    00:E5CB  45 9A      			eor	<random + 2
  138    00:E5CD  85 9A      			sta	<random + 2
  139    00:E5CF  45 98      			eor	<random + 0		; Operation 5.
  140    00:E5D1  85 98      			sta	<random + 0
  141    00:E5D3  A5 99      			lda	<random + 1		; Operation 15.
  142    00:E5D5  6A         			ror	a
  143    00:E5D6  45 9A      			eor	<random + 2
  144    00:E5D8  85 9A      			sta	<random + 2
  145    00:E5DA  45 99      			eor	<random + 1		; Operation 6.
  146    00:E5DC  85 99      			sta	<random + 1
  147    00:E5DE  60         			rts
  148                        	
  149                        	
  150                        	
  151               0000     		.if	0
  316                        		.endif
                             #[2]   "..\..\..\include\hucc\hucc-final.asm"
   48                        		.endif
   49                        	
   50                        			; Optional libraries that get used when their header files
   51                        			; are included in a HuCC project.
   52                        			;
   53                        			; When the HuCC compiler is invoked with the "--legacy"
   54                        			; option to compile old projects, then the "huc.h" file
   55                        			; is automatically included, which then includes a list
   56                        			; of specific headers corresponding to HuC's library.
   57                        	
   58               0001     		.ifdef	HUCC_USES_GFX
                             #[3]   "..\..\..\include\hucc\hucc-gfx.asm"
   59                        			include	"hucc-gfx.asm"		; Set in hucc_gfx.h
    1                        	; ***************************************************************************
    2                        	; ***************************************************************************
    3                        	;
    4                        	; huc-gfx.asm
    5                        	;
    6                        	; Based on the original HuC and MagicKit functions by David Michel and the
    7                        	; other original HuC developers.
    8                        	;
    9                        	; Modifications copyright John Brandwood 2024-2025.
   10                        	;
   11                        	; Distributed under the Boost Software License, Version 1.0.
   12                        	; (See accompanying file LICENSE_1_0.txt or copy at
   13                        	;  http://www.boost.org/LICENSE_1_0.txt)
   14                        	;
   15                        	; ***************************************************************************
   16                        	; ***************************************************************************
   17                        	
   18                        	;
   19                        	; Include dependancies ...
   20                        	;
   21                        	
   22                        			include "common.asm"		; Common helpers.
   23                        			include "vce.asm"		; Useful VCE routines.
   24                        			include "vdc.asm"		; Useful VCE routines.
   25                        	
   26                        	
   27                        	
   28                        	; ***************************************************************************
   29                        	; ***************************************************************************
   30                        	;
   31                        	; void __fastcall disp_on( void );
   32                        	; void __fastcall disp_off( void );
   33                        	
   34    00:E5DF             			.alias	_disp_on		= set_dspon
   35    00:E5DF             			.alias	_disp_off		= set_dspoff
   36                        	
   37                        	
   38                        	
   39                        	; ***************************************************************************
   40                        	; ***************************************************************************
   41                        	;
   42                        	; void __fastcall set_screen_size( unsigned char value<_al> );
   43                        	; void __fastcall sgx_set_screen_size( unsigned char value<_al> );
   44                        	;
   45                        	
   46    00:E5DF             			.alias	_set_screen_size.1	= set_bat_vdc
   47    00:E5DF             			.alias	_sgx_set_screen_size.1	= set_bat_sgx
   48                        	
   49                        	
   50                        	
   51                        	; ***************************************************************************
   52                        	; ***************************************************************************
   53                        	;
   54                        	; void __fastcall init_256x224( void );
   55                        	
   56    02:C0CE             	_init_256x224	.proc
   57                        	
   58               0800     	.BAT_SIZE	=	64 * 32
   59               0080     	.CHR_0x20	=	.BAT_SIZE / 16		; 1st tile # after the BAT.
   60               7F00     	.SAT_ADDR	=	$7F00			; SAT takes 16 tiles of VRAM.
   61                        	
   62    02:C0CE  08         			php				; Disable interrupts.
   63    02:C0CF  78         			sei
   64                        	
   65    02:C0D0  20 2D FE   			call	clear_vce		; Clear all palettes.
   66                        	
   67    02:C0D3  A9 80      			lda.l	#.CHR_0x20		; CHR # of ASCII ' '.
   68    02:C0D5  85 F8      			sta.l	<_ax
   69    02:C0D7  A9 00      			lda.h	#.CHR_0x20
   70    02:C0D9  85 F9      			sta.h	<_ax
   71                        	
   72    02:C0DB  A9 08      			lda	#>.BAT_SIZE		; Size of BAT in words.
   73    02:C0DD  85 FA      			sta	<_bl
   74                        	
   75    02:C0DF  20 41 FE   			call	clear_vram_vdc		; Clear VRAM.
   76               0001     		.if	SUPPORT_SGX
   77    02:C0E2  20 23 FE   			call	clear_vram_sgx
   78                        		.endif
   79                        	
   80    02:C0E5  A9 09      			lda	#<.mode_256x224		; Disable BKG & SPR layers but
   81    02:C0E7  85 EC      			sta.l	<_bp			; enable RCR & VBLANK IRQ.
   82    02:C0E9  A9 C1      			lda	#>.mode_256x224
   83    02:C0EB  85 ED      			sta.h	<_bp
   84                        	
   85               0001     		.if	SUPPORT_SGX
   86    02:C0ED  20 19 FE   			call	sgx_detect		; Are we really on an SGX?
   87    02:C0F0  90 05      			bcc	!+
   88    02:C0F2  A0 02      			ldy	#^.mode_256x224		; Set SGX 1st, with no VBL.
   89    02:C0F4  20 0F FE   			call	set_mode_sgx
   90                        		.endif
   91    02:C0F7  A0 02      	!:		ldy	#^.mode_256x224		; Set VDC 2nd, VBL allowed.
   92    02:C0F9  20 05 FE   			call	set_mode_vdc
   93                        	
   94               0001     		.if	SUPPORT_SGX
   95    02:C0FC  2C 10 02   			bit	SGX_SR			; Purge any overdue RCR.
   96                        		.endif
   97    02:C0FF  2C 00 02   			bit	VDC_SR			; Purge any overdue VBL.
   98    02:C102  28         			plp				; Restore interrupts.
   99                        	
  100    02:C103  20 09 E3   			call	wait_vsync		; Wait for the next VBLANK.
  101                        	
  102                        			leave				; All done, phew!
         02:C106  4C EF FF   			jmp	leave_proc
  103                        	
  104                        			; A standard 256x224 screen with overscan.
  105                        	
  106    02:C109  80         	.mode_256x224:	db	$80			; VCE Control Register.
  107    02:C10A  04         			db	VCE_CR_5MHz + XRES_SOFT	;   Video Clock + Artifact Reduction
  108                        	
  109    02:C10B  09         			db	VDC_MWR			; Memory-access Width Register
  110    02:C10C  10 00      			dw	VDC_MWR_64x32 + VDC_MWR_1CYCLE
  111    02:C10E  0A         			db	VDC_HSR			; Horizontal Sync Register
  112    02:C10F  02 02      			dw	VDC_HSR_256
  113    02:C111  0B         			db	VDC_HDR			; Horizontal Display Register
  114    02:C112  1F 04      			dw	VDC_HDR_256
  115    02:C114  0C         			db	VDC_VPR			; Vertical Sync Register
  116    02:C115  02 17      			dw	VDC_VPR_224
  117    02:C117  0D         			db	VDC_VDW			; Vertical Display Register
  118    02:C118  DF 00      			dw	VDC_VDW_224
  119    02:C11A  0E         			db	VDC_VCR			; Vertical Display END position Register
  120    02:C11B  FF 00      			dw	VDC_VCR_224
  121    02:C11D  0F         			db	VDC_DCR			; DMA Control Register
  122    02:C11E  10 00      			dw	$0010			;   Enable automatic VRAM->SATB
  123    02:C120  13         			db	VDC_DVSSR		; VRAM->SATB address $7F00
  124    02:C121  00 7F      			dw	.SAT_ADDR
  125    02:C123  07         			db	VDC_BXR			; Background X-Scroll Register
  126    02:C124  00 00      			dw	$0000
  127    02:C126  08         			db	VDC_BYR			; Background Y-Scroll Register
  128    02:C127  00 00      			dw	$0000
  129    02:C129  06         			db	VDC_RCR			; Raster Counter Register
  130    02:C12A  00 00      			dw	$0000			;   Never occurs!
  131    02:C12C  05         			db	VDC_CR			; Control Register
  132    02:C12D  0C 00      			dw	$000C			;   Enable VSYNC & RCR IRQ
  133    02:C12F  00         			db	0
  134                        	
  135                        			.endp
  136                        	
  137                        	
  138                        	
  139                        	; ***************************************************************************
  140                        	; ***************************************************************************
  141                        	;
  142                        	; void __fastcall init_240x208( void );
  143                        	
  144                        	_init_240x208	.proc
  223                        			.endp
  224                        	
  225                        	
  226                        	
  227                        	; ***************************************************************************
  228                        	; ***************************************************************************
  229                        	;
  230                        	; void __fastcall _macro set_xres( unsigned int x_pixels<_ax> );
  231                        	; void __fastcall _macro sgx_set_xres( unsigned int x_pixels<_ax> );
  232                        	;
  233                        	; void __fastcall set_xres( unsigned int x_pixels<_ax>, unsigned char blur_flag<_bl> );
  234                        	; void __fastcall sgx_set_xres( unsigned int x_pixels<_ax>, unsigned char blur_flag<_bl> );
  235                        	;
  236                        	; blur_flag = XRES_SOFT (default if not specified), XRES_SHARP or XRES_KEEP
  237                        	
  238                        	set_xres_group	.procgroup			; These routines share code!
  337                        			.endprocgroup	; set_xres_group
  338                        	
  339                        	
  340                        	
  341                        	; ***************************************************************************
  342                        	; ***************************************************************************
  343                        	;
  344                        	; HuC VRAM Functions
  345                        	;
  346                        	; ***************************************************************************
  347                        	; ***************************************************************************
  348                        	
  349                        	
  350    02:C000             	load_vram_group	.procgroup			; These routines share code!
  351                        	
  352                        	; ***************************************************************************
  353                        	; ***************************************************************************
  354                        	;
  355                        	; void __fastcall load_vram( unsigned int vram<_di>, unsigned char __far *data<_bp_bank:_bp>, unsigned int num_words<_ax> );
  356                        	; void __fastcall sgx_load_vram( unsigned int vram<_di>, unsigned char __far *data<_bp_bank:_bp>, unsigned int num_words<_ax> );
  357                        	;
  358                        	; void __fastcall far_load_vram( unsigned int vram<_di>, unsigned int num_words<_ax> );
  359                        	; void __fastcall sgx_far_load_vram( unsigned int vram<_di>, unsigned int num_words<_ax> );
  360                        	;
  361                        	; load_vram_sgx -  copy a block of memory to VRAM
  362                        	; load_vram_vdc -  copy a block of memory to VRAM
  363                        	;
  364                        	; _bp		= BAT memory location
  365                        	; _bp_bank	= BAT bank
  366                        	; _di		= VRAM base address
  367                        	; _ax		= nb of words to copy
  368                        	; ----
  369                        	; N.B. BAT data *must* be word-aligned!
  370                        	
  371               0000     		.ifndef	VRAM_XFER_SIZE
  373                        		.endif
  374                        	
  375    02:C000             	load_vram_x	.proc
  376                        	
  377    02:C000  43 08      			tma3
  378    02:C002  48         			pha
  379    02:C003  43 10      			tma4
  380    02:C005  48         			pha
  381                        	
  382    02:C006  A4 02      			ldy	<_bp_bank
  383    02:C008  20 3B E3   			jsr	map_bp_to_mpr34		; Map data to MPR3 & MPR4.
  384                        	
  385    02:C00B  20 7F E3   			jsr	set_di_to_mawr
  386                        	
  387                        	;		tii	.vdc_tai, ram_tia, 8
  388                        	
  389               0001     		.if	SUPPORT_SGX
  390    02:C00E  8A         			txa				; Select which VDC to write
  391    02:C00F  1A         			inc	a			; to.
  392    02:C010  1A         			inc	a
  393    02:C011  8D F3 22   			sta.l	ram_tia_dst
  394                        		.endif
  395                        	
  396    02:C014  A9 10      			lda	#VRAM_XFER_SIZE		; Split into 16-byte chunks
  397    02:C016  8D F5 22   			sta.l	ram_tia_len		; for stable IRQ response.
  398                        	
  399    02:C019  A6 EC      			ldx.l	<_bp
  400    02:C01B  8E F1 22   			stx.l	ram_tia_src
  401    02:C01E  A4 ED      			ldy.h	<_bp
  402    02:C020  8C F2 22   			sty.h	ram_tia_src
  403                        	
  404    02:C023  A5 F8      			lda.l	<_ax			; Length in words.
  405    02:C025  48         			pha				; Preserve length.l
  406                        	
  407    02:C026  46 F9      			lsr.h	<_ax
  408    02:C028  6A         			ror	a
  409    02:C029  46 F9      			lsr.h	<_ax
  410    02:C02B  6A         			ror	a
  411    02:C02C  46 F9      			lsr.h	<_ax
  412    02:C02E  6A         			ror	a
  413               0000     		.if	VRAM_XFER_SIZE == 32
  416                        		.endif
  417                        	
  418    02:C02F  22         			sax				; x=chunks-lo
  419    02:C030  F0 1F      			beq	.next_block		; a=source-lo, y=source-hi
  420                        	
  421    02:C032  20 F0 22   	.chunk_loop:	jsr	ram_tia			; transfer 16-bytes
  422                        	
  423    02:C035  18         			clc				; increment source
  424    02:C036  69 10      			adc	#VRAM_XFER_SIZE
  425    02:C038  8D F1 22   			sta.l	ram_tia_src
  426    02:C03B  90 11      			bcc	.same_page
  427    02:C03D  C8         			iny
  428    02:C03E  10 0B      			bpl	.same_bank		; remap_data
  429                        	
  430    02:C040  42         			say
  431    02:C041  43 10      			tma4
  432    02:C043  53 08      			tam3
  433    02:C045  1A         			inc	a
  434    02:C046  53 10      			tam4
  435    02:C048  A9 60      			lda	#$60
  436    02:C04A  42         			say
  437                        	
  438    02:C04B  8C F2 22   	.same_bank:	sty.h	ram_tia_src
  439                        	
  440    02:C04E  CA         	.same_page:	dex
  441    02:C04F  D0 E1      			bne	.chunk_loop
  442                        	
  443    02:C051  C6 F9      	.next_block:	dec.h	<_ax
  444    02:C053  10 DD      			bpl	.chunk_loop
  445                        	
  446    02:C055  68         			pla				; Restore length.l
  447    02:C056  29 07      			and	#VRAM_XFER_SIZE / 2 - 1
  448    02:C058  F0 07      			beq	.done
  449                        	
  450    02:C05A  0A         			asl	a			; Convert words to bytes.
  451    02:C05B  8D F5 22   			sta.l	ram_tia_len
  452                        	
  453    02:C05E  20 F0 22   			jsr	ram_tia			; transfer remainder
  454                        	
  455    02:C061  68         	.done:		pla
  456    02:C062  53 10      			tam4
  457    02:C064  68         			pla
  458    02:C065  53 08      			tam3
  459                        	
  460                        			leave
         02:C067  4C EF FF   			jmp	leave_proc
  461                        	
  462                        			.endp
  463                        	
  464                        			.endprocgroup	; load_vram_group
  465                        	
  466                        	
  467                        	
  468                        	; ***************************************************************************
  469                        	; ***************************************************************************
  470                        	;
  471                        	; void __fastcall load_bat( unsigned int vram<_di>, unsigned char __far *data<_bp_bank:_bp>, unsigned char tiles_w<_al>, unsigned char tiles_h<_ah> );
  472                        	; void __fastcall sgx_load_bat( unsigned int vram<_di>, unsigned char __far *data<_bp_bank:_bp>, unsigned char tiles_w<_al>, unsigned char tiles_h<_ah> );
  473                        	;
  474                        	; void __fastcall far_load_bat( unsigned int vram<_di>, unsigned char tiles_w<_al>, unsigned char tiles_h<_ah> );
  475                        	; void __fastcall sgx_far_load_bat( unsigned int vram<_di>, unsigned char tiles_w<_al>, unsigned char tiles_h<_ah> );
  476                        	;
  477                        	; load_bat_sgx - transfer a BAT to VRAM
  478                        	; load_bat_vdc - transfer a BAT to VRAM
  479                        	;
  480                        	; transfer a BAT to VRAM
  481                        	; ----
  482                        	; _bp		= BAT memory location
  483                        	; _bp_bank	= BAT bank
  484                        	; _di		= VRAM base address
  485                        	; _al		= nb of column to copy
  486                        	; _ah		= nb of row
  487                        	; ----
  488                        	; N.B. BAT data *must* be word-aligned!
  489                        	
  490               20EC     	_gfx_load_bat_PARM_2	=	_bp
  491               20F0     	_gfx_load_bat_PARM_3	=	_di
  492               20F8     	_gfx_load_bat_PARM_4	=	_al
  493               20F9     	_gfx_load_bat_PARM_5	=	_ah
  494                        	
  495    02:C24C             	load_bat_group	.procgroup			; These routines share code!
  496                        	
  497               0001     		.if	SUPPORT_SGX
  498                        			.proc	_sgx_load_bat.4
  505                        			.endp
  506                        		.endif
  507                        	
  508    02:C24C             			.proc	_load_bat.4
  509    02:C24C             			.alias	_far_load_bat.3		= _load_bat.4
  510                        	
  511    02:C24C  82         			clx				; Offset to PCE VDC.
  512                        	
  513    02:C24D  43 08      			tma3
  514    02:C24F  48         			pha
  515                        	
  516    02:C250  A4 02      			ldy	<_bp_bank
  517    02:C252  20 2D E3   			jsr	map_bp_to_mpr3		; Map data to MPR3.
  518                        	
  519    02:C255  A4 EC      			ldy.l	<_bp
  520    02:C257  64 EC      			stz.l	<_bp
  521                        	
  522    02:C259  20 7F E3   	.line_loop:	jsr	set_di_to_mawr
  523                        	
  524    02:C25C  A5 F8      			lda	<_al
  525    02:C25E  85 00      			sta	<__temp
  526    02:C260  B1 EC      	.tile_loop:	lda	[_bp], y
  527    02:C262  9D 02 02   			sta	VDC_DL, x
  528    02:C265  C8         			iny
  529    02:C266  B1 EC      			lda	[_bp], y
  530    02:C268  9D 03 02   			sta	VDC_DH, x
  531    02:C26B  C8         			iny
  532    02:C26C  D0 03      			bne	!+
  533    02:C26E  20 4C E3   			jsr	inc.h_bp_mpr3
  534    02:C271  C6 00      	!:		dec	<__temp
  535    02:C273  D0 EB      			bne	.tile_loop
  536                        	
  537    02:C275  BD 3C 25   			lda	vdc_bat_width, x
  538    02:C278  18         			clc
  539    02:C279  65 F0      			adc.l	<_di
  540    02:C27B  85 F0      			sta.l	<_di
  541    02:C27D  90 02      			bcc	!+
  542    02:C27F  E6 F1      			inc.h	<_di
  543                        	
  544    02:C281  C6 F9      	!:		dec	<_ah
  545    02:C283  D0 D4      			bne	.line_loop
  546                        	
  547    02:C285  68         			pla
  548    02:C286  53 08      			tam3
  549                        	
  550                        			leave
         02:C288  4C EF FF   			jmp	leave_proc
  551                        	
  552                        			.endp
  553                        	
  554                        			.endprocgroup	; load_bat_group
  555                        	
  556                        	
  557                        	
  558                        	; ***************************************************************************
  559                        	; ***************************************************************************
  560                        	;
  561                        	; void __fastcall load_palette( unsigned char palette<_al>, unsigned char __far *data<_bp_bank:_bp>, unsigned char num_palettes<_ah> );
  562                        	;
  563                        	; void __fastcall far_load_palette( unsigned char palette<_al>, unsigned char num_palettes<_ah> );
  564                        	
  565    02:C304             			.proc	_load_palette.3
  566    02:C304             			.alias	_far_load_palette.2	= _load_palette.3
  567                        	
  568    02:C304  AC 13 25   			ldy	color_queue_w		; Get the queue's write index.
  569                        	
  570    02:C307  A5 EC      			lda.l	<_bp			; Add this set of palettes to
  571    02:C309  99 24 25   			sta	color_addr_l, y		; the queue.
  572    02:C30C  A5 ED      			lda.h	<_bp
  573    02:C30E  99 2C 25   			sta	color_addr_h, y
  574    02:C311  A5 02      			lda	<_bp_bank
  575    02:C313  99 34 25   			sta	color_bank, y
  576    02:C316  A5 F8      			lda	<_al
  577    02:C318  99 14 25   			sta	color_index, y
  578    02:C31B  A5 F9      			lda	<_ah
  579    02:C31D  99 1C 25   			sta	color_count, y
  580                        	
  581    02:C320  C8         			iny				; Increment the queue index.
  582    02:C321  98         			tya
  583    02:C322  29 07      			and	#7
  584                        	
  585    02:C324  CD 12 25   	.wait:		cmp	color_queue_r		; If the queue is full, wait
  586    02:C327  F0 FB      			beq	.wait			; for the next VBLANK.
  587                        	
  588    02:C329  8D 13 25   			sta	color_queue_w		; Signal item is in the queue.
  589                        	
  590                        			leave				; All done, phew!
         02:C32C  4C EF FF   			jmp	leave_proc
  591                        	
  592                        			.endp
  593                        	
  594                        	
  595                        	
  596               0000     		.if	0
  620                        		.endif
  621                        	
  622                        	
  623                        	
  624                        	; ***************************************************************************
  625                        	; ***************************************************************************
  626                        	;
  627                        	; void __fastcall load_background( unsigned char __far *tiles<_bp_bank:_bp>, unsigned char __far *palettes<__fbank:__fptr>, unsigned char __far *bat<_cl:_bx>, unsigned char w<_dl>, unsigned char w<_dh> );
  628                        	
  629                        			.proc	_load_background.5
  667                        			.endp
  668                        	
  669                        	
  670                        	
  671                        	; ***************************************************************************
  672                        	; ***************************************************************************
  673                        	;
  674                        	; void __fastcall vram2vram( unsigned int vram_dst<_ax>, unsigned int vram_src<_bx>, unsigned int word_len<_cx> );
  675                        	; void __fastcall sgx_vram2vram( unsigned int vram_dst<_ax>, unsigned int vram_src<_bx>, unsigned int word_len<_cx> );
  676                        	;
  677                        	
  678               0001     		.if	SUPPORT_SGX
  679                        			.proc	_sgx_vram2vram.3
  685                        			.endp
  686                        		.endif
  687                        	
  688    02:C28B             			.proc	_vram2vram.3
  689                        	
  690    02:C28B  82         			clx				; Offset to PCE VDC.
  691                        	
  692    02:C28C  08         			php
  693    02:C28D  78         			sei
  694    02:C28E  A9 11      			lda	#VDC_DESR
  695    02:C290  9D 00 02   			sta	VDC_AR, x
  696    02:C293  A5 F8      			lda.l	<_ax
  697    02:C295  9D 02 02   			sta	VDC_DL, x
  698    02:C298  A5 F9      			lda.h	<_ax
  699    02:C29A  9D 03 02   			sta	VDC_DH, x
  700                        	
  701    02:C29D  A9 10      			lda	#VDC_SOUR
  702    02:C29F  9D 00 02   			sta	VDC_AR, x
  703    02:C2A2  A5 FA      			lda.l	<_bx
  704    02:C2A4  9D 02 02   			sta	VDC_DL, x
  705    02:C2A7  A5 FB      			lda.h	<_bx
  706    02:C2A9  9D 03 02   			sta	VDC_DH, x
  707                        	
  708    02:C2AC  A9 12      			lda	#VDC_LENR
  709    02:C2AE  9D 00 02   			sta	VDC_AR, x
  710    02:C2B1  18         			clc
  711    02:C2B2  A5 FC      			lda.l	<_cx
  712    02:C2B4  69 FF      			adc	#$FF
  713    02:C2B6  9D 02 02   			sta	VDC_DL, x
  714    02:C2B9  A5 FD      			lda.h	<_cx
  715    02:C2BB  69 FF      			adc	#$FF
  716    02:C2BD  9D 03 02   			sta	VDC_DH, x
  717                        	
  718    02:C2C0  B5 F7      			lda	<vdc_reg, x
  719    02:C2C2  8D 00 02   			sta	VDC_AR
  720    02:C2C5  28         			plp
  721                        	
  722                        			leave
         02:C2C6  4C EF FF   			jmp	leave_proc
  723                        	
  724                        			.endp
  725                        	
  726                        	
  727                        	
  728                        	; ***************************************************************************
  729                        	; ***************************************************************************
  730                        	;
  731                        	; HuC Font Functions
  732                        	;
  733                        	; ***************************************************************************
  734                        	; ***************************************************************************
  735                        	
  736                        	
  737                        	
  738               255C     			.bss
  739                        	
  740                        	; **************
  741                        	; 16-bytes of VDC BAT information.
  742                        	;
  743                        	; N.B. MUST be 16-bytes before the SGX versions to use PCE_VDC_OFFSET.
  744                        	
  745    F8:255C             	_vdc_font_base:	ds	2	; Tile number of ASCII '\0'.
  746                        	
  747                        	; From hucc-printf.asm just to avoid wasting .bss space with padding.
  748    F8:255E             	_vdc_tty_x_lhs:	ds	1	; TTY minimum X position.
  749    F8:255F             	_vdc_tty_y_top:	ds	1	; TTY minimum Y position.
  750    F8:2560             	_vdc_tty_x:	ds	1	; TTY current X position.
  751    F8:2561             	_vdc_tty_y:	ds	1	; TTY current Y position.
  752                        	
  753               0001     		.if	SUPPORT_SGX
  754                        	
  755                        	; **************
  756                        	; 16-bytes of SGX BAT information.
  757                        	;
  758                        	; N.B. MUST be 16-bytes after the VDC versions to use SGX_VDC_OFFSET.
  759                        	
  760    F8:2562             			ds	10	; Padding to ensure the 16-byte delta.
  761                        	
  762    F8:256C             	_sgx_font_base:	ds	2	; Tile number of ASCII '\0'.
  763                        	
  764                        	; From hucc-printf.asm just to avoid wasting .bss space with padding.
  765    F8:256E             	_sgx_tty_x_lhs:	ds	1	; TTY minimum X position.
  766    F8:256F             	_sgx_tty_y_top:	ds	1	; TTY minimum Y position.
  767    F8:2570             	_sgx_tty_x:	ds	1	; TTY current X position.
  768    F8:2571             	_sgx_tty_y:	ds	1	; TTY current Y position.
  769                        	
  770                        		.endif
  771                        	
  772                        	;_font_base	.alias	vdc_font_base
  773                        	
  774               E5DF     			.code
  775                        	
  776                        	
  777                        	
  778                        	; ***************************************************************************
  779                        	; ***************************************************************************
  780                        	;
  781                        	; void __fastcall set_font_addr( unsigned int vram<acc> );
  782                        	; void __fastcall sgx_set_font_addr( unsigned int vram<acc> );
  783                        	
  784               0001     		.if	SUPPORT_SGX
  785    00:E5DF             	_sgx_set_font_addr.1:
  786    00:E5DF  A2 10      			ldx	#SGX_VDC_OFFSET		; Offset to SGX VDC.
  787    00:E5E1  F0         			db	$F0			; Turn "clx" into a "beq".
  788                        		.endif
  789                        	
  790    00:E5E2             	_set_font_addr.1:
  791    00:E5E2  82         			clx				; Offset to PCE VDC.
  792                        	
  793    00:E5E3  84 00      	set_font_addr:	sty	<__temp
  794    00:E5E5  46 00      			lsr	<__temp
  795    00:E5E7  6A         			ror	a
  796    00:E5E8  46 00      			lsr	<__temp
  797    00:E5EA  6A         			ror	a
  798    00:E5EB  46 00      			lsr	<__temp
  799    00:E5ED  6A         			ror	a
  800    00:E5EE  46 00      			lsr	<__temp
  801    00:E5F0  6A         			ror	a
  802    00:E5F1  38         			sec
  803    00:E5F2  E9 20      			sbc	#$20
  804    00:E5F4  9D 5C 25   			sta.l	_vdc_font_base,x
  805    00:E5F7  B0 02      			bcs	!+
  806    00:E5F9  C6 00      			dec	<__temp
  807                        	
  808    00:E5FB  BD 5D 25   	!:		lda.h	_vdc_font_base, x
  809    00:E5FE  29 F0      			and	#$F0
  810    00:E600  05 00      			ora	<__temp
  811    00:E602  9D 5D 25   			sta.h	_vdc_font_base, x
  812    00:E605  60         			rts
  813                        	
  814                        	
  815                        	
  816                        	; ***************************************************************************
  817                        	; ***************************************************************************
  818                        	;
  819                        	; void __fastcall set_font_pal( unsigned char palette<acc> );
  820                        	; void __fastcall sgx_set_font_pal( unsigned char palette<acc> );
  821                        	
  822               0001     		.if	SUPPORT_SGX
  823    00:E606             	_sgx_set_font_pal.1:
  824    00:E606  A2 10      			ldx	#SGX_VDC_OFFSET		; Offset to SGX VDC.
  825    00:E608  F0         			db	$F0			; Turn "clx" into a "beq".
  826                        		.endif
  827                        	
  828    00:E609             	_set_font_pal:					; For compatibility with HuC.
  829    00:E609             	_set_font_pal.1:
  830    00:E609  82         			clx				; Offset to PCE VDC.
  831    00:E60A  0A         			asl	a
  832    00:E60B  0A         			asl	a
  833    00:E60C  0A         			asl	a
  834    00:E60D  0A         			asl	a
  835    00:E60E  85 00      			sta	<__temp
  836                        	
  837    00:E610  BD 5D 25   			lda.h	_vdc_font_base, x
  838    00:E613  29 0F      			and	#$0F
  839    00:E615  05 00      			ora	<__temp
  840    00:E617  9D 5D 25   			sta.h	_vdc_font_base, x
  841    00:E61A  60         			rts
  842                        	
  843                        	
  844                        	
  845                        	; ***************************************************************************
  846                        	; ***************************************************************************
  847                        	;
  848                        	; void __fastcall load_font( char far *font<_bp_bank:_bp>, unsigned char count<_al> );
  849                        	;
  850                        	; void __fastcall load_font( char far *font<_bp_bank:_bp>, unsigned char count<_al>, unsigned int vram<acc> );
  851                        	; void __fastcall sgx_load_font( char far *font<_bp_bank:_bp>, unsigned char count<_al>, unsigned int vram<acc> );
  852                        	;
  853                        	; void __fastcall far_load_font( unsigned char count<_al>, unsigned int vram<acc> );
  854                        	; void __fastcall sgx_far_load_font( unsigned char count<_al>, unsigned int vram<acc> );
  855                        	
  856    00:E61B  AC 40 25   	_load_font.2:	ldy	vdc_bat_limit		; Load the font directly
  857    00:E61E  C8         			iny				; after the BAT (stupid!).
  858    00:E61F  62         			cla
  859    00:E620  80 03      			bra	_load_font.3
  860                        	
  861               0001     		.if	SUPPORT_SGX
  862    00:E622             	_sgx_load_font.3:
  863    00:E622  A2 10      			ldx	#SGX_VDC_OFFSET		; Offset to SGX VDC.
  864    00:E624  F0         			db	$F0			; Turn "clx" into a "beq".
  865                        		.endif
  866                        	
  867    00:E625  82         	_load_font.3:	clx				; Offset to PCE VDC.
  868                        	
  869    00:E626  85 F0      			sta.l	<_di			; Load the font directly
  870    00:E628  84 F1      			sty.h	<_di			; after the BAT (stupid!).
  871                        	
  872    00:E62A  20 E3 E5   			jsr	set_font_addr		; Set xxx_font_base from addr.
  873                        	
  874    00:E62D  A5 F8      			lda	<__al			; Convert #tiles into #words.
  875    00:E62F  64 F9      			stz	<__ah
  876    00:E631  0A         			asl	a
  877    00:E632  26 F9      			rol	<__ah
  878    00:E634  0A         			asl	a
  879    00:E635  26 F9      			rol	<__ah
  880    00:E637  0A         			asl	a
  881    00:E638  26 F9      			rol	<__ah
  882    00:E63A  0A         			asl	a
  883    00:E63B  26 F9      			rol	<__ah
  884    00:E63D  85 F8      			sta	<__al
  885    00:E63F  4C 63 FF   			jmp	load_vram_x
  886                        	
  887    00:E642             			.alias	_far_load_font.2	= _load_font.3
  888    00:E642             			.alias	_sgx_far_load_font.2	= _sgx_load_font.3
  889                        	
  890                        	
  891                        	
  892                        	; ***************************************************************************
  893                        	; ***************************************************************************
  894                        	;
  895                        	; void __fastcall cls();
  896                        	; void __fastcall sgx_cls();
  897                        	;
  898                        	; void __fastcall cls( int tile<acc> );
  899                        	; void __fastcall sgx_cls( int tile<acc> );
  900                        	
  901               0001     		.if	SUPPORT_SGX
  902    00:E642  A2 10      	_sgx_cls:	ldx	#SGX_VDC_OFFSET		; Offset to SGX VDC.
  903    00:E644  F0         			db	$F0			; Turn "clx" into a "beq".
  904                        		.endif
  905                        	
  906    00:E645  82         	_cls:		clx				; Offset to PCE VDC.
  907                        	
  908    00:E646  BD 5C 25   	clear_tty_x:	lda.l	_vdc_font_base, x
  909    00:E649  BC 5D 25   			ldy.h	_vdc_font_base, x
  910    00:E64C  18         			clc
  911    00:E64D  69 20      			adc	#' '
  912    00:E64F  90 07      			bcc	!+
  913    00:E651  C8         			iny
  914    00:E652  80 04      			bra	!+
  915                        	
  916               0001     		.if	SUPPORT_SGX
  917    00:E654  A2 10      	_sgx_cls.1:	ldx	#SGX_VDC_OFFSET		; Offset to SGX VDC.
  918    00:E656  F0         			db	$F0			; Turn "clx" into a "beq".
  919                        		.endif
  920                        	
  921    00:E657  82         	_cls.1:		clx
  922                        	
  923    00:E658  85 F8      	!:		sta.l	<_ax			; VRAM word to write.
  924    00:E65A  84 F9      			sty.h	<_ax
  925    00:E65C  BD 40 25   			lda	vdc_bat_limit, x	; BAT size hi-byte.
  926    00:E65F  1A         			inc	a
  927    00:E660  85 FA      			sta	<_bl
  928    00:E662  4C 37 FE   			jmp	clear_bat_x
  929                        	
  930                        	
  931                        	
  932                        	; ***************************************************************************
  933                        	; ***************************************************************************
  934                        	;
  935                        	; void __fastcall __macro load_default_font( void );
  936                        	; void __fastcall __macro sgx_load_default_font( void );
  937                        	;
  938                        	; Args: _bp, _bp_bank = _farptr to font data mapped into MPR3 & MPR4.
  939                        	; Args: _di = VRAM destination address.
  940                        	; Args: monofont_fg = font color (0..15)
  941                        	; Args: monofont_bg = background color (0..15)
  942                        	; Args: _al = number of tiles (aka characters) 0==256
  943                        	
  944    01:C960             	huc_monofont_x	.proc
  945                        	
  946               2572     			.bss
  947    F8:2572             	monofont_fg:	.ds	1
  948    F8:2573             	monofont_bg:	.ds	1
  949               C960     			.code
  950                        	
  951    01:C960  BC 40 25   			ldy	vdc_bat_limit, x	; BAT limit mask hi-byte.
  952    01:C963  C8         			iny
  953    01:C964  62         			cla
  954    01:C965  85 F0      			sta.l	<_di			; Load the font directly
  955    01:C967  84 F1      			sty.h	<_di			; after the BAT (stupid!).
  956                        	
  957    01:C969  20 E3 E5   			jsr	set_font_addr		; Set xxx_font_base from addr.
  958                        	
  959    01:C96C  A9 F0      			lda.l	#.font
  960    01:C96E  85 EC      			sta.l	<_bp
  961    01:C970  A9 C9      			lda.h	#.font
  962    01:C972  85 ED      			sta.h	<_bp
  963                        	
  964    01:C974  A9 60      			lda	#$60			; #characters.
  965    01:C976  85 F8      			sta	<_al
  966                        	
  967    01:C978  20 7F E3   			jsr	set_di_to_mawr
  968                        	
  969    01:C97B  AD 72 25   			lda	monofont_fg		; Foreground pixel color.
  970    01:C97E  85 00      			sta	<__temp
  971    01:C980  AD 73 25   			lda	monofont_bg		; Background pixel color.
  972    01:C983  DA         			phx
  973    01:C984  A2 FC      			ldx.l	#_cx			; Create a bit mask for each
  974    01:C986  9E 00 20   	.bg_loop:	stz	$2000, x		; plane of the background.
  975    01:C989  4A         			lsr	a
  976    01:C98A  90 03      			bcc	.bg_plane
  977    01:C98C  DE 00 20   			dec	$2000, x
  978    01:C98F  E8         	.bg_plane:	inx
  979    01:C990  D0 F4      			bne	.bg_loop
  980    01:C992  FA         			plx
  981                        	
  982    01:C993  C2         	.tile_loop:	cly
  983                        	
  984    01:C994  B1 EC      	.plane01:	lda	[_bp], y		; Get font byte.
  985    01:C996  8F 00 06   			bbs0	<__temp, .set_plane0
  986    01:C999  49 FF      	.clr_plane0:	eor	#$FF			; Clr font bits in background.
  987    01:C99B  25 FC      			and	<_cx + 0
  988    01:C99D  80 02      			bra	.put_plane0
  989    01:C99F  05 FC      	.set_plane0:	ora	<_cx + 0		; Set font bits in background.
  990    01:C9A1  9D 02 02   	.put_plane0:	sta	VDC_DL, x
  991                        	
  992    01:C9A4  B1 EC      			lda	[_bp], y		; Get font byte.
  993    01:C9A6  9F 00 06   			bbs1	<__temp, .set_plane1
  994    01:C9A9  49 FF      	.clr_plane1:	eor	#$FF			; Clr font bits in background.
  995    01:C9AB  25 FD      			and	<_cx + 1
  996    01:C9AD  80 02      			bra	.put_plane1
  997    01:C9AF  05 FD      	.set_plane1:	ora	<_cx + 1		; Set font bits in background.
  998    01:C9B1  9D 03 02   	.put_plane1:	sta	VDC_DH, x
  999                        	
 1000    01:C9B4  C8         			iny
 1001    01:C9B5  C0 08      			cpy	#8
 1002    01:C9B7  90 DB      			bcc	.plane01
 1003                        	
 1004    01:C9B9  C2         			cly
 1005                        	
 1006    01:C9BA  B1 EC      	.plane23:	lda	[_bp], y		; Get font byte.
 1007    01:C9BC  AF 00 06   			bbs2	<__temp, .set_plane2
 1008    01:C9BF  49 FF      	.clr_plane2:	eor	#$FF			; Clr font bits in background.
 1009    01:C9C1  25 FE      			and	<_cx + 2
 1010    01:C9C3  80 02      			bra	.put_plane2
 1011    01:C9C5  05 FE      	.set_plane2:	ora	<_cx + 2		; Set font bits in background.
 1012    01:C9C7  9D 02 02   	.put_plane2:	sta	VDC_DL, x
 1013                        	
 1014    01:C9CA  B1 EC      			lda	[_bp], y		; Get font byte.
 1015    01:C9CC  BF 00 06   			bbs3	<__temp, .set_plane3
 1016    01:C9CF  49 FF      	.clr_plane3:	eor	#$FF			; Clr font bits in background.
 1017    01:C9D1  25 FF      			and	<_cx + 3
 1018    01:C9D3  80 02      			bra	.put_plane3
 1019    01:C9D5  05 FF      	.set_plane3:	ora	<_cx + 3		; Set font bits in background.
 1020    01:C9D7  9D 03 02   	.put_plane3:	sta	VDC_DH, x
 1021                        	
 1022    01:C9DA  C8         			iny
 1023    01:C9DB  C0 08      			cpy	#8
 1024    01:C9DD  90 DB      			bcc	.plane23
 1025                        	
 1026    01:C9DF  A5 EC      			lda.l	<_bp
 1027    01:C9E1  69 07      			adc	#8-1
 1028    01:C9E3  85 EC      			sta.l	<_bp
 1029    01:C9E5  90 02      			bcc	!+
 1030    01:C9E7  E6 ED      			inc.h	<_bp
 1031                        	
 1032    01:C9E9  C6 F8      	!:		dec	<_al
 1033    01:C9EB  D0 A6      			bne	.tile_loop
 1034                        	
 1035                        			leave				; All done, phew!
         01:C9ED  4C EF FF   			jmp	leave_proc
 1036                        	
 1037    01:C9F0             	.font:		incbin	"data/font8x8-bold-short-iso646-fr.dat", 128
 1038                        	
 1039                        			.endp
 1040                        	
 1041                        	
 1042                        	
 1043                        	; ***************************************************************************
 1044                        	; ***************************************************************************
 1045                        	;
 1046                        	; HuC Text Output
 1047                        	;
 1048                        	; ***************************************************************************
 1049                        	; ***************************************************************************
 1050                        	
 1051                        	
 1052                        	
 1053    01:DA44             	vdc_tty_out	.procgroup			; These routines share code!
 1054                        	
 1055                        	; ***************************************************************************
 1056                        	; ***************************************************************************
 1057                        	;
 1058                        	; void __fastcall put_char( unsigned char digit<_bl>, unsigned char bat_x<_dil>, unsigned char bat_y<_dih> );
 1059                        	
 1060               0001     		.if	SUPPORT_SGX
 1061                        	put_char_sgx	.proc
 1067                        			.endp
 1068                        		.endif
 1069                        	
 1070    01:DA44             	put_char_vdc	.proc
 1071                        	
 1072    01:DA44  82         			clx				; Offset to PCE VDC.
 1073                        	
 1074    01:DA45  20 34 E4   			jsr	set_di_xy_mawr
 1075                        	
 1076    01:DA48  62         			cla				; Push EOL marker.
 1077    01:DA49  48         			pha
 1078                        	
 1079    01:DA4A  A5 FA      			lda	<_bl
 1080    01:DA4C  48         			pha				; Push character to output.
 1081    01:DA4D  80 58      			bra	!output+
 1082                        	
 1083    01:DA4F             			.ref	put_hex_vdc		; Need put_number_vdc
 1084                        			.endp
 1085                        	
 1086    01:DA4F             			.alias	_put_char.3		= put_char_vdc
 1087                        	
 1088                        	
 1089                        	
 1090                        	; ***************************************************************************
 1091                        	; ***************************************************************************
 1092                        	;
 1093                        	; void __fastcall put_digit( unsigned char digit<_bl>, unsigned char bat_x<_dil>, unsigned char bat_y<_dih> );
 1094                        	
 1095               0001     		.if	SUPPORT_SGX
 1096                        	put_digit_sgx	.proc
 1102                        			.endp
 1103                        		.endif
 1104                        	
 1105    01:DA4F             	put_digit_vdc	.proc
 1106                        	
 1107    01:DA4F  82         			clx				; Offset to PCE VDC.
 1108                        	
 1109    01:DA50  20 34 E4   			jsr	set_di_xy_mawr
 1110                        	
 1111    01:DA53  62         			cla				; Push EOL marker.
 1112    01:DA54  48         			pha
 1113                        	
 1114    01:DA55  A5 FA      			lda	<_bl			; Convert hex digit to ASCII.
 1115    01:DA57  29 0F      			and	#$0F
 1116    01:DA59  C9 0A      			cmp	#10
 1117    01:DA5B  90 02      			bcc	!+
 1118    01:DA5D  69 06      			adc	#6
 1119    01:DA5F  69 30      	!:		adc	#'0'
 1120    01:DA61  48         			pha				; Push character to output.
 1121    01:DA62  80 43      			bra	!output+
 1122                        	
 1123    01:DA64             			.ref	put_hex_vdc		; Need put_number_vdc
 1124                        			.endp
 1125                        	
 1126    01:DA64             			.alias	_put_digit.3		= put_digit_vdc
 1127                        	
 1128                        	
 1129                        	
 1130                        	; ***************************************************************************
 1131                        	; ***************************************************************************
 1132                        	;
 1133                        	; void __fastcall put_hex( unsigned int number<_bx>, unsigned char length<_cl>, unsigned char bat_x<_dil>, unsigned char bat_y<_dih> );
 1134                        	
 1135               0001     		.if	SUPPORT_SGX
 1136                        	put_hex_sgx	.proc
 1141                        			.endp
 1142                        		.endif
 1143                        	
 1144    01:DA64             	put_hex_vdc	.proc
 1145                        	
 1146    01:DA64  82         			clx				; Offset to PCE VDC.
 1147                        	
 1148    01:DA65  20 34 E4   			jsr	set_di_xy_mawr
 1149                        	
 1150    01:DA68  A4 FC      			ldy	<_cl			; Total #characters to print,
 1151    01:DA6A  F0 3E      			beq	!exit+			; NOT minimum #characters!
 1152                        	
 1153    01:DA6C  86 00      			stx	<__temp			; Preserve which VDC.
 1154                        	
 1155    01:DA6E  82         			clx				; Push EOL marker.
 1156    01:DA6F  DA         			phx
 1157                        	
 1158    01:DA70  B5 FA      	.hex_byte:	lda.l	<_bx, x			; Convert hex digit to ASCII.
 1159    01:DA72  29 0F      			and	#$0F
 1160    01:DA74  C9 0A      			cmp	#10
 1161    01:DA76  90 02      			bcc	!+
 1162    01:DA78  69 06      			adc	#6
 1163    01:DA7A  69 30      	!:		adc	#'0'
 1164    01:DA7C  48         			pha				; Push character to output.
 1165    01:DA7D  88         			dey
 1166    01:DA7E  F0 15      			beq	.hex_done
 1167                        	
 1168    01:DA80  B5 FA      			lda.l	<_bx, x			; Convert hex digit to ASCII.
 1169    01:DA82  4A         			lsr	a
 1170    01:DA83  4A         			lsr	a
 1171    01:DA84  4A         			lsr	a
 1172    01:DA85  4A         			lsr	a
 1173    01:DA86  C9 0A      			cmp	#10
 1174    01:DA88  90 02      			bcc	!+
 1175    01:DA8A  69 06      			adc	#6
 1176    01:DA8C  69 30      	!:		adc	#'0'
 1177    01:DA8E  48         			pha				; Push character to output.
 1178    01:DA8F  88         			dey
 1179    01:DA90  F0 03      			beq	.hex_done
 1180                        	
 1181    01:DA92  E8         			inx
 1182    01:DA93  80 DB      			bra	.hex_byte
 1183                        	
 1184    01:DA95  A6 00      	.hex_done:	ldx	<__temp			; Restore which VDC.
 1185    01:DA97  80 0E      			bra	!output+
 1186                        	
 1187    01:DA99  18         	.write:		clc
 1188    01:DA9A  7D 5C 25   			adc.l	_vdc_font_base, x
 1189    01:DA9D  9D 02 02   			sta	VDC_DL, x
 1190    01:DAA0  62         			cla
 1191    01:DAA1  7D 5D 25   			adc.h	_vdc_font_base, x
 1192    01:DAA4  9D 03 02   			sta	VDC_DH, x
 1193                        	
 1194    01:DAA7  68         	!output:	pla				; Pop the digits and output.
 1195    01:DAA8  D0 EF      			bne	.write
 1196                        	
 1197                        	!exit:		leave				; All done!
         01:DAAA  4C EF FF   			jmp	leave_proc
 1198                        	
 1199                        			.endp
 1200                        	
 1201    01:DAAD             			.alias	_put_hex.4 = put_hex_vdc
 1202                        	
 1203                        	
 1204                        	
 1205                        	; ***************************************************************************
 1206                        	; ***************************************************************************
 1207                        	;
 1208                        	; void __fastcall put_number( unsigned int number<_bx>, unsigned char length<_cl>, unsigned char bat_x<_dil>, unsigned char bat_y<_dih> );
 1209                        	
 1210               0001     		.if	SUPPORT_SGX
 1211                        	put_number_sgx	.proc
 1216                        			.endp
 1217                        		.endif
 1218                        	
 1219    01:DAAD             	put_number_vdc	.proc
 1220                        	
 1221    01:DAAD  82         			clx				; Offset to PCE VDC.
 1222                        	
 1223    01:DAAE  20 34 E4   			jsr	set_di_xy_mawr
 1224                        	
 1225    01:DAB1  A4 FC      			ldy	<_cl			; Total #characters to print,
 1226    01:DAB3  F0 F5      			beq	!exit-			; NOT minimum #characters!
 1227                        	
 1228    01:DAB5  86 00      			stx	<__temp			; Preserve which VDC.
 1229                        	
 1230    01:DAB7  82         			clx				; Push EOL marker.
 1231    01:DAB8  DA         			phx
 1232                        	
 1233    01:DAB9  A6 FB      			ldx.h	<_bx			; Is the number -ve?
 1234    01:DABB  86 FC      			stx	<_cl			; Remember this.
 1235    01:DABD  10 10      			bpl	.divide_by_ten
 1236                        	
 1237    01:DABF  38         			sec				; Make the number +ve.
 1238    01:DAC0  A5 FA      			lda.l	<_bx
 1239    01:DAC2  49 FF      			eor	#$FF
 1240    01:DAC4  69 00      			adc	#0
 1241    01:DAC6  85 FA      			sta.l	<_bx
 1242    01:DAC8  8A         			txa
 1243    01:DAC9  49 FF      			eor	#$FF
 1244    01:DACB  69 00      			adc	#0
 1245    01:DACD  85 FB      			sta.h	<_bx
 1246                        	
 1247    01:DACF  A2 10      	.divide_by_ten:	ldx	#16
 1248    01:DAD1  62         			cla				; Clear Remainder.
 1249    01:DAD2  06 FA      			asl.l	<_bx			; Rotate Dividend, MSB -> C.
 1250    01:DAD4  26 FB      			rol.h	<_bx
 1251    01:DAD6  2A         	.divide_loop:	rol	a			; Rotate C into Remainder.
 1252    01:DAD7  C9 0A      			cmp	#10			; Test Divisor.
 1253    01:DAD9  90 02      			bcc	.divide_less		; CC if Divisor > Remainder.
 1254    01:DADB  E9 0A      			sbc	#10			; Subtract Divisor.
 1255    01:DADD  26 FA      	.divide_less:	rol.l	<_bx			; Quotient bit -> Dividend LSB.
 1256    01:DADF  26 FB      			rol.h	<_bx			; Rotate Dividend, MSB -> C.
 1257    01:DAE1  CA         			dex
 1258    01:DAE2  D0 F2      			bne	.divide_loop
 1259                        	
 1260    01:DAE4  18         			clc
 1261    01:DAE5  69 30      			adc	#'0'			; Always leaves C clr.
 1262    01:DAE7  48         			pha				; Push character to output.
 1263    01:DAE8  88         			dey
 1264    01:DAE9  F0 10      			beq	!pad+
 1265    01:DAEB  A5 FA      			lda.l	<_bx			; Repeat while non-zero.
 1266    01:DAED  05 FB      			ora.h	<_bx
 1267    01:DAEF  D0 DE      			bne	.divide_by_ten
 1268                        	
 1269    01:DAF1  A6 00      			ldx	<__temp			; Restore which VDC.
 1270                        	
 1271    01:DAF3  A5 FC      			lda	<_cl			; Was the number -ve?
 1272    01:DAF5  10 04      			bpl	!pad+
 1273    01:DAF7  A9 2D      			lda	#'-'			; Output a leading '-'.
 1274    01:DAF9  48         			pha
 1275    01:DAFA  88         			dey
 1276                        	
 1277    01:DAFB  A9 20      	!pad:		lda	#' '			; Add padding characters.
 1278    01:DAFD  88         	.loop:		dey
 1279    01:DAFE  30 A7      			bmi	!output-
 1280    01:DB00  48         			pha
 1281    01:DB01  80 FA      			bra	.loop
 1282                        	
 1283    01:DB03             			.ref	put_hex_vdc		; Need put_number_vdc
 1284                        	
 1285                        			.endp
 1286                        	
 1287    01:DB03             			.alias	_put_number.4 = put_number_vdc
 1288                        	
 1289                        	
 1290                        	
 1291                        	; ***************************************************************************
 1292                        	; ***************************************************************************
 1293                        	;
 1294                        	; void __fastcall put_raw( unsigned int data<_bx>, unsigned char bat_x<_dil>, unsigned char bat_y<_dih> );
 1295                        	
 1296               0001     		.if	SUPPORT_SGX
 1297                        	put_raw_sgx	.proc
 1302                        			.endp
 1303                        		.endif
 1304                        	
 1305                        	put_raw_vdc	.proc
 1318                        			.endp
 1319                        	
 1320    01:DB03             			.alias	_put_raw.3		= put_raw_vdc
 1321                        	
 1322                        			.endprocgroup			; vdc_tty_out
 1323                        	
 1324                        	
 1325                        	
 1326                        	; ***************************************************************************
 1327                        	; ***************************************************************************
 1328                        	;
 1329                        	; void __fastcall put_string( unsigned char *string<_bp>, unsigned char bat_x<_dil>, unsigned char bat_y<_dih> );
 1330                        	;
 1331                        	; N.B. This is not a .proc right now because it is called from procedures
 1332                        	; that contain embedded strings, and the string aren't banked in before
 1333                        	; printing (yet).
 1334                        	
 1335               0001     		.if	SUPPORT_SGX
 1336    00:E665             	_sgx_put_string.3:
 1337    00:E665  A2 10      			ldx	#SGX_VDC_OFFSET		; Offset to SGX VDC.
 1338    00:E667  F0         			db	$F0			; Turn "clx" into a "beq".
 1339                        		.endif
 1340                        	
 1341    00:E668  82         	_put_string.3:	clx				; Offset to PCE VDC.
 1342                        	
 1343    00:E669  20 34 E4   			jsr	set_di_xy_mawr
 1344                        	
 1345    00:E66C  C2         			cly
 1346    00:E66D  B1 EC      	.chr_loop:	lda	[_bp], y
 1347    00:E66F  F0 15      			beq	.done
 1348                        	
 1349    00:E671  18         			clc
 1350    00:E672  7D 5C 25   			adc.l	_vdc_font_base, x
 1351    00:E675  9D 02 02   			sta	VDC_DL, x
 1352    00:E678  62         			cla
 1353    00:E679  7D 5D 25   			adc.h	_vdc_font_base, x
 1354    00:E67C  9D 03 02   			sta	VDC_DH, x
 1355                        	
 1356    00:E67F  C8         			iny
 1357    00:E680  D0 EB      			bne	.chr_loop
 1358    00:E682  E6 ED      			inc.h	<_bp
 1359    00:E684  80 E7      			bra	.chr_loop
 1360                        	
 1361    00:E686  60         	.done:		rts
 1362                        	
 1363                        	
 1364                        	
 1365                        	; ***************************************************************************
 1366                        	; ***************************************************************************
 1367                        	;
 1368                        	; void __fastcall set_color_rgb( unsigned int index<VCE_CTA>, unsigned char r<_al>, unsigned char g<_ah>, unsigned char b<acc> );
 1369                        	;
 1370                        	; r:	red	RED:	bit 3-5
 1371                        	; g:	green	GREEN:	bit 6-8
 1372                        	; b:	blue	BLUE:	bit 0-2
 1373                        	
 1374    00:E687             	_set_color_rgb.4:
 1375                        	;		and	#7
 1376    00:E687  85 00      			sta	<__temp
 1377    00:E689  A5 F8      			lda	<_al
 1378                        	;		and	#7
 1379    00:E68B  0A         			asl	a
 1380    00:E68C  0A         			asl	a
 1381    00:E68D  0A         			asl	a
 1382    00:E68E  05 00      			ora	<__temp
 1383    00:E690  0A         			asl	a
 1384    00:E691  0A         			asl	a
 1385    00:E692  85 00      			sta	<__temp
 1386    00:E694  A5 F9      			lda	<_ah
 1387                        	;		and	#7
 1388    00:E696  4A         			lsr	a
 1389    00:E697  66 00      			ror	<__temp
 1390    00:E699  4A         			lsr	a
 1391    00:E69A  66 00      			ror	<__temp
 1392    00:E69C  A8         			tay
 1393    00:E69D  A5 00      			lda	<__temp
 1394    00:E69F  8D 04 04   			sta.l	VCE_CTW
 1395    00:E6A2  8C 05 04   			sty.h	VCE_CTW
 1396    00:E6A5  60         			rts
                             #[2]   "..\..\..\include\hucc\hucc-final.asm"
   60                        		.endif
   61                        	
   62               0001     		.ifdef	HUCC_USES_STRING		; Set in hucc_string.h
                             #[3]   "..\..\..\include\hucc\hucc-string.asm"
   63                        			include	"hucc-string.asm"
    1                        	; ***************************************************************************
    2                        	; ***************************************************************************
    3                        	;
    4                        	; hucc-string.asm
    5                        	;
    6                        	; Not-quite-standard, but fast, replacements for <string.h>.
    7                        	;
    8                        	; Copyright John Brandwood 2024.
    9                        	;
   10                        	; Distributed under the Boost Software License, Version 1.0.
   11                        	; (See accompanying file LICENSE_1_0.txt or copy at
   12                        	;  http://www.boost.org/LICENSE_1_0.txt)
   13                        	;
   14                        	; ***************************************************************************
   15                        	; ***************************************************************************
   16                        	;
   17                        	; !!! WARNING : non-standard return values !!!
   18                        	;
   19                        	; Strings are limited to a maximum of 255 characters (+ the terminator)!
   20                        	;
   21                        	; The memcpy(), strcpy() and strcat() functions do NOT return the destination
   22                        	; address, and they are declared "void" to check that the value is not used.
   23                        	;
   24                        	; mempcpy() is provided which returns the end address instead of the starting
   25                        	; address, because this is typically more useful.
   26                        	;
   27                        	; Please note that both memcpy() and memset() are implemented using a TII for
   28                        	; speed, and so the length should be < 16 bytes if used in time-critical bits
   29                        	; of code (such as when using a split screen) because they delay interrupts.
   30                        	;
   31                        	; strncpy() and strncat() are not provided, because strncpy() was not created
   32                        	; for the purpose of avoiding string overruns, and strncat() is just a poorly
   33                        	; designed function.
   34                        	;
   35                        	; POSIX strlcpy() and strlcat() are provided instead, but once again they are
   36                        	; slightly non-standard in that the return value when there is an overflow is
   37                        	; the buffer size (so that the overflow can be detected), instead of the full
   38                        	; size of the destination string that was too big to fit in the buffer.
   39                        	;
   40                        	; ***************************************************************************
   41                        	; ***************************************************************************
   42                        	
   43                        	
   44                        	
   45                        	; ***************************************************************************
   46                        	; ***************************************************************************
   47                        	;
   48                        	; void __fastcall strcpy( char *destination<_di>, char *source<_bp> );
   49                        	; void __fastcall strcat( char *destination<_di>, char *source<_bp> );
   50                        	;
   51                        	; unsigned int __fastcall strlcpy( char *destination<_di>, char *source<_bp>, unsigned char size<acc> );
   52                        	; unsigned int __fastcall strlcat( char *destination<_di>, char *source<_bp>, unsigned char size<acc> );
   53                        	; unsigned int __fastcall strlen( char *source<_bp> );
   54                        	;
   55                        	; NOT WORKING YET (needs compiler changes) ...
   56                        	;
   57                        	; void __fastcall strcpy( char *destination<_di>, char __far *source<_bp_bank:_bp> );
   58                        	; void __fastcall strcat( char *destination<_di>, char __far *source<_bp_bank:_bp> );
   59                        	;
   60                        	; unsigned int __fastcall strlcpy( char *destination<_di>, char __far *source<_bp_bank:_bp>, unsigned char size<acc> );
   61                        	; unsigned int __fastcall strlcat( char *destination<_di>, char __far *source<_bp_bank:_bp>, unsigned char size<acc> );
   62                        	; unsigned int __fastcall strlen( char __far *source<_bp_bank:_bp> );
   63                        	
   64    00:E6A6  62         	_strcat:	cla				; Max string length == 256!
   65    00:E6A7  A0 01      			ldy.h	#256
   66                        	
   67    00:E6A9  AA         	_strlcat:	tax				; X = buffer length (1..256).
   68                        	
   69               0000     		.ifdef	_DEBUG
   74                        		.endif
   75                        	
   76    00:E6AA  43 08      			tma3				; Preserve MPR3 and MPR4.
   77    00:E6AC  48         			pha
   78    00:E6AD  43 10      			tma4
   79    00:E6AF  48         			pha
   80                        	
   81                        	;		ldy	<_bp_bank		; Map the source string.
   82                        	;		beq	.no_bank
   83                        	;		jsr	map_bp_to_mpr34
   84                        	
   85    00:E6B0  C2         	.no_bank:	cly
   86                        	
   87    00:E6B1  B1 F0      	.find:		lda	[_di], y		; Find the end of the string.
   88    00:E6B3  F0 08      			beq	.adjust
   89    00:E6B5  C8         			iny
   90    00:E6B6  CA         			dex
   91    00:E6B7  D0 F8      			bne	.find
   92    00:E6B9  98         			tya				; A:Y = buffer length.
   93    00:E6BA  62         			cla
   94    00:E6BB  80 28      			bra	str_overflow
   95                        	
   96    00:E6BD  98         	.adjust:	tya				; Subtract Y from _bp so that
   97    00:E6BE  49 FF      			eor	#$FF			; _bp and _di use the same Y.
   98    00:E6C0  38         			sec
   99    00:E6C1  65 EC      			adc.l	<_bp
  100    00:E6C3  85 EC      			sta.l	<_bp
  101    00:E6C5  B0 0F      			bcs	str_copy
  102    00:E6C7  C6 ED      			dec.h	<_bp
  103    00:E6C9  80 0B      			bra	str_copy
  104                        	
  105                        			;
  106                        	
  107    00:E6CB  62         	_strcpy:	cla				; Max string length == 256!
  108    00:E6CC  A0 01      			ldy.h	#256
  109                        	
  110    00:E6CE  AA         	_strlcpy:	tax				; X = buffer length (1..256).
  111                        	
  112               0000     		.ifdef	_DEBUG
  117                        		.endif
  118                        	
  119    00:E6CF  43 08      			tma3				; Preserve MPR3 and MPR4.
  120    00:E6D1  48         			pha
  121    00:E6D2  43 10      			tma4
  122    00:E6D4  48         			pha
  123                        	
  124                        	;		ldy	<_bp_bank		; Map the source string.
  125                        	;		beq	.no_bank
  126                        	;		jsr	map_bp_to_mpr34
  127                        	
  128    00:E6D5  C2         	.no_bank:	cly
  129                        	
  130    00:E6D6  B1 EC      	str_copy:	lda	[_bp], y
  131    00:E6D8  91 F0      			sta	[_di], y
  132    00:E6DA  F0 1E      			beq	str_exit		; A:Y = string length.
  133    00:E6DC  C8         			iny
  134    00:E6DD  CA         			dex
  135    00:E6DE  D0 F6      			bne	str_copy
  136                        	
  137    00:E6E0  88         			dey
  138    00:E6E1  62         			cla
  139    00:E6E2  91 F0      			sta	[_di], y
  140    00:E6E4  C8         			iny				; A:Y = buffer length.
  141    00:E6E5  D0 13      	str_overflow:	bne	str_exit
  142    00:E6E7  1A         			inc	a			; A:Y = buffer length = 256.
  143    00:E6E8  80 10      			bra	str_exit
  144                        	
  145                        			;
  146                        	
  147    00:E6EA  43 08      	_strlen:	tma3
  148    00:E6EC  48         			pha
  149    00:E6ED  43 10      			tma4
  150    00:E6EF  48         			pha
  151                        	
  152                        	;		ldy	<_bp_bank
  153                        	;		beq	.no_bank
  154                        	;		jsr	map_bp_to_mpr34
  155                        	
  156    00:E6F0  C2         	.no_bank:	cly
  157                        	
  158    00:E6F1  B1 EC      	.find:		lda	[_bp], y
  159    00:E6F3  F0 05      			beq	str_exit
  160    00:E6F5  C8         			iny
  161    00:E6F6  D0 F9      			bne	.find
  162    00:E6F8  A9 01      			lda.h	#256			; A:Y = overflow length = 256.
  163                        	
  164    00:E6FA  AA         	str_exit:	tax				; X:Y = string or buffer length.
  165                        	
  166    00:E6FB  68         			pla				; Restore MPR3 and MPR4.
  167    00:E6FC  53 10      			tam4
  168    00:E6FE  68         			pla
  169    00:E6FF  53 08      			tam3
  170                        	
  171    00:E701  8A         			txa				; A:Y = string or buffer length.
  172    00:E702  42         			say				; Y:A = string or buffer length.
  173                        	
  174    00:E703  60         			rts
  175                        	
  176    00:E704             			.alias	_strlen.1		= _strlen
  177    00:E704             			.alias	_strcpy.2		= _strcpy
  178    00:E704             			.alias	_strcat.2		= _strcat
  179    00:E704             			.alias	_strlcpy.3		= _strlcpy
  180    00:E704             			.alias	_strlcat.3		= _strlcat
  181                        	
  182                        	
  183                        	
  184                        	; ***************************************************************************
  185                        	; ***************************************************************************
  186                        	;
  187                        	; void __fastcall memcpy( unsigned char *destination<ram_tii_dst>, unsigned char  *source<ram_tii_src>, unsigned int count<acc> );
  188                        	; unsigned char * __fastcall mempcpy( unsigned char *destination<ram_tii_dst>, unsigned char  *source<ram_tii_src>, unsigned int count<acc> );
  189                        	;
  190                        	; void __fastcall farmemcpy( unsigned char *destination<ram_tii_dst>, unsigned char __far *source<_bp_bank:ram_tii_src>, unsigned int count<acc> );
  191                        	; unsigned char * __fastcall farmempcpy( unsigned char *destination<ram_tii_dst>, unsigned char __far *source<_bp_bank:ram_tii_src>, unsigned int count<acc> );
  192                        	;
  193                        	; void __fastcall far_memcpy( unsigned char *destination<ram_tii_dst>, unsigned int count<acc> );
  194                        	; unsigned char * __fastcall far_mempcpy( unsigned char *destination<ram_tii_dst>, unsigned int count<acc> );
  195                        	;
  196                        	
  197    00:E704             	_memcpy.3:
  198    00:E704  64 02      	_mempcpy.3:	stz	<_bp_bank		; Map the source memory.
  199                        	
  200    00:E706             	_farmemcpy.3:
  201    00:E706  8C FE 22   	_farmempcpy.3:	sty.h	ram_tii_len		; Check for zero length.
  202    00:E709  8D FD 22   			sta.l	ram_tii_len
  203    00:E70C  0D FE 22   			ora.h	ram_tii_len
  204    00:E70F  F0 18      			beq	.zero_length
  205                        	
  206    00:E711  43 08      			tma3				; Preserve MPR3 and MPR4.
  207    00:E713  48         			pha
  208    00:E714  43 10      			tma4
  209    00:E716  48         			pha
  210                        	
  211    00:E717  A5 02      			lda	<_bp_bank		; Map the source memory.
  212    00:E719  F0 05      			beq	.no_bank
  213                        	
  214    00:E71B  53 08      			tam3				; Put bank into MPR3.
  215    00:E71D  1A         			inc	a
  216    00:E71E  53 10      			tam4				; Put next into MPR4.
  217                        	
  218                        	;		lda.h	ram_tii_src		; Remap ptr to MPR3.
  219                        	;		and	#$1F
  220                        	;		ora	#$60
  221                        	;		sta.h	ram_tii_src
  222                        	
  223    00:E720  20 F8 22   	.no_bank:	jsr	ram_tii			; Copy the memory.
  224                        	
  225    00:E723  68         			pla				; Restore MPR3 and MPR4.
  226    00:E724  53 10      			tam4
  227    00:E726  68         			pla
  228    00:E727  53 08      			tam3
  229                        	
  230    00:E729  18         	.zero_length:	clc				; Return the end address
  231    00:E72A  AD FB 22   			lda.l	ram_tii_dst		; like mempcpy().
  232    00:E72D  6D FD 22   			adc.l	ram_tii_len
  233    00:E730  A8         			tay
  234    00:E731  AD FC 22   			lda.h	ram_tii_dst
  235    00:E734  6D FE 22   			adc.h	ram_tii_len
  236    00:E737  42         			say
  237                        	
  238    00:E738  60         			rts
  239                        	
  240    00:E739             			.alias	_far_memcpy.2		= _farmemcpy.3
  241    00:E739             			.alias	_far_mempcpy.2		= _farmempcpy.3
  242                        	
  243                        	
  244                        	
  245                        	; ***************************************************************************
  246                        	; ***************************************************************************
  247                        	;
  248                        	; void __fastcall memset( unsigned char *destination<ram_tii_src>, unsigned char value<_al>, unsigned int count<acc> );
  249                        	
  250    00:E739  C9 00      	_memset:	cmp	#0			; Decrement the length, check
  251    00:E73B  D0 05      			bne	!+			; for zero and set C. 
  252    00:E73D  C0 00      			cpy	#0
  253    00:E73F  F0 23      			beq	.zero_length
  254    00:E741  88         			dey
  255    00:E742  3A         	!:		dec	a
  256    00:E743  8D FD 22   			sta.l	ram_tii_len
  257    00:E746  8C FE 22   			sty.h	ram_tii_len
  258                        	
  259    00:E749  AD F9 22   			lda.l	ram_tii_src		; ram_tii_dst = ram_tii_src + 1
  260    00:E74C  85 88      			sta.l	<__ptr
  261    00:E74E  69 00      			adc	#0
  262    00:E750  8D FB 22   			sta.l	ram_tii_dst
  263    00:E753  AD FA 22   			lda.h	ram_tii_src
  264    00:E756  85 89      			sta.h	<__ptr
  265    00:E758  69 00      			adc	#0
  266    00:E75A  8D FC 22   			sta.h	ram_tii_dst
  267                        	
  268    00:E75D  A5 F8      			lda	<_al			; Set the fill value.
  269    00:E75F  92 88      			sta	[__ptr]
  270                        	
  271    00:E761  4C F8 22   			jmp	ram_tii			; Copy the memory.
  272                        	
  273    00:E764  60         	.zero_length:	rts
  274                        	
  275    00:E765             			.alias	_memset.3		= _memset
  276                        	
  277                        	
  278                        	
  279                        	; ***************************************************************************
  280                        	; ***************************************************************************
  281                        	;
  282                        	; int __fastcall strcmp( char *string1<_di>, char *string2<_bp> );
  283                        	; int __fastcall strncmp( char *string1<_di>, char *string2<_bp>, unsigned int count<_ax> );
  284                        	;
  285                        	; int __fastcall __macro memcmp( unsigned char *string1<_di>, unsigned char *string2<_bp>, unsigned int count<_ax> );
  286                        	; int __fastcall farmemcmp( unsigned char *string1<_di>, unsigned char __far *string2<_bp_bank:_bp>, unsigned int count<_ax> );
  287                        	; int __fastcall far_memcmp( unsigned char *string1<_di>, unsigned int count<_ax> );
  288                        	;
  289                        	;  0 	if strings are equal
  290                        	;  1 	if the first non-matching character in string1 > string2 (in ASCII).
  291                        	; -1 	if the first non-matching character in string1 < string2 (in ASCII).
  292                        	
  293    02:C130             	hucc_memcmp	.procgroup
  294                        	
  295                        	_strcmp.2	.proc
  300                        			.endp				; Fall through.
  301                        	
  302    02:C130             	_strncmp.3	.proc
  303    02:C130  64 02      			stz	<_bp_bank		; Assume strings are mapped.
  304    02:C132  89 40      			bit	#$40			; Set the V bit for strcmp.
  305    02:C134  50         			db	$50			; Turn "clv" into "bvc".
  306    02:C135             			.ref	_farmemcmp.3		; Don't strip _farmemcmp.3!
  307                        			.endp				; Fall through.
  308                        	
  309    02:C135             	_farmemcmp.3	.proc
  310    02:C135  B8         			clv				; Clr the V bit for memcmp.
  311                        	
  312    02:C136  43 08      			tma3				; Preserve MPR3 and MPR4.
  313    02:C138  48         			pha
  314    02:C139  43 10      			tma4
  315    02:C13B  48         			pha
  316                        	
  317    02:C13C  A4 02      			ldy	<_bp_bank		; Map string2.
  318    02:C13E  F0 03      			beq	.no_bank
  319                        	
  320    02:C140  20 3B E3   			jsr	map_bp_to_mpr34
  321                        	
  322    02:C143  C2         	.no_bank:	cly
  323                        	
  324    02:C144  A6 F8      			ldx.l	<_ax			; Increment length.l
  325    02:C146  E8         			inx
  326    02:C147  CA         	.loop:		dex				; Decrement length.l
  327    02:C148  F0 17      			beq	.page
  328    02:C14A  B1 F0      	.test:		lda	[_di], y		; string1 - string2
  329    02:C14C  D1 EC      			cmp	[_bp], y
  330    02:C14E  90 1E      			bcc	.return_neg		; string1 < string2 
  331    02:C150  D0 17      			bne	.return_pos		; string1 > string2
  332    02:C152  50 04      			bvc	!+			; Only check for end-of-string
  333    02:C154  C9 00      			cmp	#0			; if the V flag is set.
  334    02:C156  F0 0D      			beq	.return_same
  335    02:C158  C8         	!:		iny
  336    02:C159  D0 EC      			bne	.loop
  337    02:C15B  E6 F1      			inc.h	<_di
  338    02:C15D  E6 ED      			inc.h	<_bp			; Limited to 8KB maximum!
  339                        	;		jsr	inc.h_bp_mpr34
  340    02:C15F  80 E6      			bra	.loop
  341                        	
  342    02:C161  C6 F9      	.page:		dec.h	<_ax			; Decrement length.h 
  343    02:C163  10 E5      			bpl	.test			; Limit comparison to 32KB.
  344                        	;		bra	cmp_same
  345                        	
  346    02:C165  82         	.return_same:	clx				; Return code in Y:X, X -> A.
  347    02:C166  C2         			cly
  348    02:C167  80 09      			bra	!+
  349                        	
  350    02:C169  A2 01      	.return_pos:	ldx	#$01			; Return code in Y:X, X -> A.
  351    02:C16B  C2         			cly
  352    02:C16C  80 04      			bra	!+
  353                        	
  354    02:C16E  A2 FF      	.return_neg:	ldx	#$FF			; Return code in Y:X, X -> A.
  355    02:C170  A0 FF      			ldy	#$FF
  356                        	
  357    02:C172  68         	!:		pla				; Restore MPR3 and MPR4.
  358    02:C173  53 10      			tam4
  359    02:C175  68         			pla
  360    02:C176  53 08      			tam3
  361                        	
  362                        			leave				; Return and copy X -> A.
         02:C178  4C EF FF   			jmp	leave_proc
  363                        	
  364                        			.endp
  365                        	
  366                        			.endprocgroup			; hucc_memcmp
  367                        	
  368    00:E765             			.alias	_far_memcmp.2		= _farmemcmp.3
                             #[2]   "..\..\..\include\hucc\hucc-final.asm"
   64                        		.endif
   65                        	
   66               0001     		.ifdef	HUCC_USES_NEW_SCROLL		; Set in hucc_scroll.h
                             #[3]   "..\..\..\include\hucc\hucc-scroll.asm"
   67                        			include	"hucc-scroll.asm"
    1                        	; ***************************************************************************
    2                        	; ***************************************************************************
    3                        	;
    4                        	; hucc-scroll.asm
    5                        	;
    6                        	; Routines for a fast split-screen scrolling system.
    7                        	;
    8                        	; Copyright John Brandwood 2024.
    9                        	;
   10                        	; Distributed under the Boost Software License, Version 1.0.
   11                        	; (See accompanying file LICENSE_1_0.txt or copy at
   12                        	;  http://www.boost.org/LICENSE_1_0.txt)
   13                        	;
   14                        	; ***************************************************************************
   15                        	; ***************************************************************************
   16                        	;
   17                        	; The maximum number of splits for each screen layer is set in your project's
   18                        	; "hucc-config.inc" file, with the library having a limit of 128-per-layer.
   19                        	;
   20                        	; Your first active split must be defined to start at screen line 0, and then
   21                        	; the rest of the active splits must be in increasing line order to match the
   22                        	; way that the PC Engine displays the output image.
   23                        	;
   24                        	; You can have disabled splits interleaved with your active splits.
   25                        	;
   26                        	; Splits that are normally disabled can be used to create full screen effects
   27                        	; such as bouncing the screen up and down by adding blank areas at the top or
   28                        	; bottom of the screen, and then rapidly changing the height of those areas.
   29                        	;
   30                        	; ***************************************************************************
   31                        	; ***************************************************************************
   32                        	
   33                        	
   34                        	
   35               0000     		.ifndef	HUCC_PCE_SPLITS
   37                        		.endif
   38                        	
   39               0000     		.ifndef	HUCC_SGX_SPLITS
   41                        		.endif
   42                        	
   43               0000     		.if	(HUCC_PCE_SPLITS < 2) || (HUCC_PCE_SPLITS > 128)
   45                        		.endif
   46                        	
   47               0000     		.if	(HUCC_SGX_SPLITS < 2) || (HUCC_SGX_SPLITS > 128)
   49                        		.endif
   50                        	
   51               0144     	HUCC_1ST_RCR	=	$144
   52               00E0     	HUCC_SCR_HEIGHT	=	224
   53                        	
   54               E765     			.code
   55                        	
   56                        	
   57                        	
   58                        	; ***************************************************************************
   59                        	; ***************************************************************************
   60                        	;
   61                        	; void __fastcall scroll_split( unsigned char index<_al>, unsigned char screen_line<_ah>, unsigned int bat_x<_bx>, unsigned int bat_y<_cx>, unsigned char display_flags<_dl> );
   62                        	; void __fastcall sgx_scroll_split( unsigned char index<_al>, unsigned char screen_line<_ah>, unsigned int bat_x<_bx>, unsigned int bat_y<_cx>, unsigned char display_flags<_dl> );
   63                        	;
   64                        	; set screen scrolling
   65                        	
   66                        			.proc	_scroll_split.5
  143                        			.endp
  144                        	
  145               0001     		.if	SUPPORT_SGX
  146                        	
  147    01:DDD1             			.proc	_sgx_scroll_split.5
  148                        	
  149    01:DDD1  08         			php				; Disable interrupts while
  150    01:DDD2  78         			sei				; updating this structure.
  151                        	
  152    01:DDD3  A6 F8      			ldx	<_al			; Region number.
  153    01:DDD5  E0 08      			cpx	#HUCC_SGX_SPLITS
  154    01:DDD7  B0 FE      	.hang:		bcs	.hang			; Better a hang than a crash!
  155                        	
  156    01:DDD9  BD F5 25   			lda	sgx_region_sel, x	; Update the parameter copy
  157    01:DDDC  5D FD 25   			eor	sgx_region_new, x	; that is not displayed now.
  158    01:DDDF  D0 3B      			bne	.regionA
  159                        	
  160    01:DDE1  A5 F9      	.regionB:	lda	<_ah			; Scanline (i.e. top).
  161    01:DDE3  C9 E0      			cmp	#HUCC_SCR_HEIGHT	; Skip if offscreen.
  162    01:DDE5  B0 31      			bcs	!done+
  163    01:DDE7  9D 1D 26   			sta	sgx_regionB_rcr, x
  164                        	
  165    01:DDEA  C9 00      			cmp	#0			; Either Y at top of the frame
  166    01:DDEC  F0 01      			beq	!+			; or Y-1 because the RCR code
  167    01:DDEE  18         			clc				; sets it on the line before.
  168    01:DDEF  A5 FC      	!:		lda.l	<_cx
  169    01:DDF1  E9 00      			sbc	#0
  170    01:DDF3  9D 4D 26   			sta	sgx_regionB_yl, x
  171    01:DDF6  A5 FD      			lda.h	<_cx
  172    01:DDF8  E9 00      			sbc	#0
  173    01:DDFA  9D 5D 26   			sta	sgx_regionB_yh, x
  174                        	
  175    01:DDFD  A5 FA      			lda.l	<_bx
  176    01:DDFF  9D 2D 26   			sta	sgx_regionB_xl, x
  177    01:DE02  A5 FB      			lda.h	<_bx
  178    01:DE04  9D 3D 26   			sta	sgx_regionB_xh, x
  179                        	
  180    01:DE07  A5 FE      			lda	<_dl
  181    01:DE09  29 C0      			and	#$C0			; Flags (mark it as enabled).
  182    01:DE0B  09 0C      			ora	#$0C
  183    01:DE0D  9D 0D 26   			sta	sgx_regionB_crl, x
  184                        	
  185    01:DE10  A9 01      			lda	#1			; Mark that we've changed the
  186    01:DE12  9D FD 25   			sta	sgx_region_new, x	; selected region.
  187    01:DE15  9D F5 25   			sta	sgx_region_sel, x
  188                        	
  189    01:DE18  28         	!done:		plp				; Restore interrupts.
  190                        			leave				; All done!
         01:DE19  4C EF FF   			jmp	leave_proc
  191                        	
  192    01:DE1C  A5 F9      	.regionA:	lda	<_ah			; Scanline (i.e. top).
  193    01:DE1E  C9 E0      			cmp	#HUCC_SCR_HEIGHT	; Skip if offscreen.
  194    01:DE20  B0 31      			bcs	!done+
  195    01:DE22  9D 15 26   			sta	sgx_regionA_rcr, x
  196                        	
  197    01:DE25  C9 00      			cmp	#0			; Either Y at top of the frame
  198    01:DE27  F0 01      			beq	!+			; or Y-1 because the RCR code
  199    01:DE29  18         			clc				; sets it on the line before.
  200    01:DE2A  A5 FC      	!:		lda.l	<_cx
  201    01:DE2C  E9 00      			sbc	#0
  202    01:DE2E  9D 45 26   			sta	sgx_regionA_yl, x
  203    01:DE31  A5 FD      			lda.h	<_cx
  204    01:DE33  E9 00      			sbc	#0
  205    01:DE35  9D 55 26   			sta	sgx_regionA_yh, x
  206                        	
  207    01:DE38  A5 FA      			lda.l	<_bx
  208    01:DE3A  9D 25 26   			sta	sgx_regionA_xl, x
  209    01:DE3D  A5 FB      			lda.h	<_bx
  210    01:DE3F  9D 35 26   			sta	sgx_regionA_xh, x
  211                        	
  212    01:DE42  A5 FE      			lda	<_dl
  213    01:DE44  29 C0      			and	#$C0			; Flags (mark it as enabled).
  214    01:DE46  09 0C      			ora	#$0C
  215    01:DE48  9D 05 26   			sta	sgx_regionA_crl, x
  216                        	
  217    01:DE4B  A9 01      			lda	#1			; Mark that we've changed the
  218    01:DE4D  9D FD 25   			sta	sgx_region_new, x	; selected region.
  219    01:DE50  9E F5 25   			stz	sgx_region_sel, x
  220                        	
  221    01:DE53  28         	!done:		plp				; Restore interrupts.
  222                        			leave				; All done!
         01:DE54  4C EF FF   			jmp	leave_proc
  223                        	
  224                        			.endp
  225                        	
  226                        		.endif	SUPPORT_SGX
  227                        	
  228                        	
  229                        	
  230                        	; ***************************************************************************
  231                        	; ***************************************************************************
  232                        	;
  233                        	; void __fastcall disable_split( unsigned char index<acc> );
  234                        	; void __fastcall sgx_disable_split( unsigned char index<acc> );
  235                        	;
  236                        	; disable screen scrolling for a scroll region
  237                        	
  238    00:E765             	_disable_split.1:
  239    00:E765  08         			php				; Disable interrupts while
  240    00:E766  78         			sei				; updating this structure.
  241                        	
  242    00:E767  C9 08      			cmp	#HUCC_PCE_SPLITS	; Better a hang than a crash!
  243    00:E769  B0 FE      	.hang:		bcs	.hang
  244    00:E76B  AA         			tax
  245                        	
  246    00:E76C  BD 74 25   			lda	vdc_region_sel, x	; Update the parameter copy
  247    00:E76F  5D 7C 25   			eor	vdc_region_new, x	; that is not displayed now.
  248    00:E772  D0 0D      			bne	.regionA
  249                        	
  250    00:E774  9E 8C 25   	.regionB:	stz	vdc_regionB_crl, x	; Region disabled if $00.
  251                        	
  252    00:E777  A9 01      			lda	#1			; Mark that we've changed the
  253    00:E779  9D 7C 25   			sta	vdc_region_new, x	; selected region.
  254    00:E77C  9D 74 25   			sta	vdc_region_sel, x
  255                        	
  256    00:E77F  28         			plp				; Restore interrupts.
  257    00:E780  60         			rts
  258                        	
  259    00:E781  9E 84 25   	.regionA:	stz	vdc_regionA_crl, x	; Region disabled if $00.
  260                        	
  261    00:E784  A9 01      			lda	#1			; Mark that we've changed the
  262    00:E786  9D 7C 25   			sta	vdc_region_new, x	; selected region.
  263    00:E789  9E 74 25   			stz	vdc_region_sel, x
  264                        	
  265    00:E78C  28         			plp				; Restore interrupts.
  266    00:E78D  60         			rts
  267                        	
  268               0001     		.if	SUPPORT_SGX
  269                        	
  270    00:E78E             	_sgx_disable_split.1:
  271    00:E78E  08         			php				; Disable interrupts while
  272    00:E78F  78         			sei				; updating this structure.
  273                        	
  274    00:E790  C9 08      			cmp	#HUCC_SGX_SPLITS	; Better a hang than a crash!
  275    00:E792  B0 FE      	.hang:		bcs	.hang
  276    00:E794  AA         			tax
  277                        	
  278    00:E795  BD F5 25   			lda	sgx_region_sel, x	; Update the parameter copy
  279    00:E798  5D FD 25   			eor	sgx_region_new, x	; that is not displayed now.
  280    00:E79B  D0 0D      			bne	.regionA
  281                        	
  282    00:E79D  9E 0D 26   	.regionB:	stz	sgx_regionB_crl, x	; Region disabled if $00.
  283                        	
  284    00:E7A0  A9 01      			lda	#1			; Mark that we've changed the
  285    00:E7A2  9D FD 25   			sta	sgx_region_new, x	; selected region.
  286    00:E7A5  9D F5 25   			sta	sgx_region_sel, x
  287                        	
  288    00:E7A8  28         			plp				; Restore interrupts.
  289    00:E7A9  60         			rts
  290                        	
  291    00:E7AA  9E 05 26   	.regionA:	stz	sgx_regionA_crl, x	; Region disabled if $00.
  292                        	
  293    00:E7AD  A9 01      			lda	#1			; Mark that we've changed the
  294    00:E7AF  9D FD 25   			sta	sgx_region_new, x	; selected region.
  295    00:E7B2  9E F5 25   			stz	sgx_region_sel, x
  296                        	
  297    00:E7B5  28         			plp				; Restore interrupts.
  298    00:E7B6  60         			rts
  299                        	
  300                        		.endif	SUPPORT_SGX
  301                        	
  302                        	
  303                        	
  304                        	; ***************************************************************************
  305                        	; ***************************************************************************
  306                        	;
  307                        	; vbl_init_scroll
  308                        	;
  309                        	; From Charles MacDonald's pcetech.txt ...
  310                        	;
  311                        	;  Raster Compare Register (RCR):
  312                        	;
  313                        	;  The range of the RCR is 263 lines, relative to the start of the active
  314                        	;  display period. (defined by VSW, VDS, and VCR) The VDC treats the first
  315                        	;  scanline of the active display period as $0040, so the valid ranges for
  316                        	;  the RCR register are $0040 to $0146.
  317                        	;
  318                        	;  For example, assume VSW=$02, VDS=$17. This positions the first line of
  319                        	;  the active display period at line 25 of the frame. An RCR value of $0040
  320                        	;  (zero) causes an interrupt at line 25, and a value of $0146 (262) causes an
  321                        	;  interrupt at line 24 of the next frame.
  322                        	;
  323                        	;  Any other RCR values that are out of range ($00-$3F, $147-$3FF) will never
  324                        	;  result in a successful line compare.
  325                        	;
  326                        	; Processing time:
  327                        	;
  328                        	; Old HuC rcr_init: 2148 cycles if all 8 regions pre-sorted
  329                        	; Old HuC rcr_init: 4346 cycles if all 8 regions need sorting
  330                        	;
  331                        	; New HuCC vbl_init_scroll:   8 disabled splits:  290 cycles
  332                        	; New HuCC vbl_init_scroll:   8  enabled splits:  384 cycles
  333                        	;
  334                        	; New HuCC vbl_init_scroll:  16 disabled splits:  506 cycles
  335                        	; New HuCC vbl_init_scroll:  16  enabled splits:  672 cycles
  336                        	;
  337                        	; New HuCC vbl_init_scroll:  32 disabled splits:  953 cycles
  338                        	; New HuCC vbl_init_scroll:  32  enabled splits: 1263 cycles
  339                        	;
  340                        	; New HuCC vbl_init_scroll:  64 disabled splits: 1802 cycles
  341                        	; New HuCC vbl_init_scroll:  64  enabled splits: 2400 cycles
  342                        	;
  343                        	; New HuCC vbl_init_scroll: 128 disabled splits: 3530 cycles
  344                        	; New HuCC vbl_init_scroll: 128  enabled splits: 4704 cycles
  345                        	;
  346                        	; Memory used is 16 bytes per scroll per VDC!
  347                        	
  348               2574     			.bss
  349                        	
  350    F8:2574             	vdc_region_sel:	.ds	HUCC_PCE_SPLITS		; Use A or B region next frame?
  351    F8:257C             	vdc_region_new:	.ds	HUCC_PCE_SPLITS		; 1 if vdc_region_sel modified.
  352                        	
  353    F8:2584             	vdc_regionA_crl:.ds	HUCC_PCE_SPLITS		; Two copies of each setting
  354    F8:258C             	vdc_regionB_crl:.ds	HUCC_PCE_SPLITS		; HUCC_PCE_SPLITS bytes apart,
  355    F8:2594             	vdc_regionA_rcr:.ds	HUCC_PCE_SPLITS		; one setting for the current
  356    F8:259C             	vdc_regionB_rcr:.ds	HUCC_PCE_SPLITS		; frame, and one setting that
  357    F8:25A4             	vdc_regionA_xl:	.ds	HUCC_PCE_SPLITS		; gets modified and then used
  358    F8:25AC             	vdc_regionB_xl:	.ds	HUCC_PCE_SPLITS		; on the next frame after the
  359    F8:25B4             	vdc_regionA_xh:	.ds	HUCC_PCE_SPLITS		; change is made.
  360    F8:25BC             	vdc_regionB_xh:	.ds	HUCC_PCE_SPLITS		; Regions will have different
  361    F8:25C4             	vdc_regionA_yl:	.ds	HUCC_PCE_SPLITS		; A or B currently active!
  362    F8:25CC             	vdc_regionB_yl:	.ds	HUCC_PCE_SPLITS
  363    F8:25D4             	vdc_regionA_yh:	.ds	HUCC_PCE_SPLITS
  364    F8:25DC             	vdc_regionB_yh:	.ds	HUCC_PCE_SPLITS
  365                        	
  366    F8:25E4             	vdc_next_region:.ds	1			; Linked list of region indexes
  367    F8:25E5             	vdc_regionA_nxt:.ds	HUCC_PCE_SPLITS		; for the current frame.
  368    F8:25ED             	vdc_regionB_nxt:.ds	HUCC_PCE_SPLITS
  369                        	
  370               0001     		.if	SUPPORT_SGX
  371                        	
  372    F8:25F5             	sgx_region_sel:	.ds	HUCC_SGX_SPLITS		; Use A or B region next frame?
  373    F8:25FD             	sgx_region_new:	.ds	HUCC_SGX_SPLITS		; 1 if sgx_region_sel modified.
  374                        	
  375    F8:2605             	sgx_regionA_crl:.ds	HUCC_SGX_SPLITS		; Two copies of each setting
  376    F8:260D             	sgx_regionB_crl:.ds	HUCC_SGX_SPLITS		; HUCC_SGX_SPLITS bytes apart,
  377    F8:2615             	sgx_regionA_rcr:.ds	HUCC_SGX_SPLITS		; one setting for the current
  378    F8:261D             	sgx_regionB_rcr:.ds	HUCC_SGX_SPLITS		; frame, and one setting that
  379    F8:2625             	sgx_regionA_xl:	.ds	HUCC_SGX_SPLITS		; gets modified and then used
  380    F8:262D             	sgx_regionB_xl:	.ds	HUCC_SGX_SPLITS		; on the next frame after the
  381    F8:2635             	sgx_regionA_xh:	.ds	HUCC_SGX_SPLITS		; change is made.
  382    F8:263D             	sgx_regionB_xh:	.ds	HUCC_SGX_SPLITS		; Regions will have different
  383    F8:2645             	sgx_regionA_yl:	.ds	HUCC_SGX_SPLITS		; A or B currently active!
  384    F8:264D             	sgx_regionB_yl:	.ds	HUCC_SGX_SPLITS
  385    F8:2655             	sgx_regionA_yh:	.ds	HUCC_SGX_SPLITS
  386    F8:265D             	sgx_regionB_yh:	.ds	HUCC_SGX_SPLITS
  387                        	
  388    F8:2665             	sgx_next_region:.ds	1			; Linked list of region indexes
  389    F8:2666             	sgx_regionA_nxt:.ds	HUCC_SGX_SPLITS		; for the current frame.
  390    F8:266E             	sgx_regionB_nxt:.ds	HUCC_SGX_SPLITS
  391                        	
  392                        		.endif
  393                        	
  394               E7B7     			.code
  395                        	
  396    01:DE57             	vbl_init_scroll	.proc
  397                        	
  398    01:DE57  62         			cla				; A = previous active index
  399    01:DE58  A2 08      			ldx	#HUCC_PCE_SPLITS	; so $00 for end-of-screen.
  400                        	
  401    01:DE5A  18         			clc				; For regionB indexes.
  402                        	
  403    01:DE5B  CA         	!next_region:	dex				; All regions updated?
  404    01:DE5C  30 20      			bmi	!save_first+
  405                        	
  406    01:DE5E  9E 7C 25   			stz	vdc_region_new, x	; Clear region modified flag.
  407                        	
  408    01:DE61  BC 74 25   			ldy	vdc_region_sel, x	; 0=regionA or 1=regionB.
  409    01:DE64  F0 0D      			beq	!use_regionA+
  410                        	
  411    01:DE66  BC 8C 25   	!use_regionB:	ldy	vdc_regionB_crl, x	; Region disabled if $00.
  412    01:DE69  F0 F0      			beq	!next_region-
  413    01:DE6B  9D ED 25   			sta	vdc_regionB_nxt, x	; Save index of next region.
  414    01:DE6E  8A         			txa				; A = current region index.
  415    01:DE6F  69 08      			adc	#HUCC_PCE_SPLITS	; Always leaves CC!
  416    01:DE71  80 E8      			bra	!next_region-
  417                        	
  418    01:DE73  BC 84 25   	!use_regionA:	ldy	vdc_regionA_crl, x	; Region disabled if $00.
  419    01:DE76  F0 E3      			beq	!next_region-
  420    01:DE78  9D E5 25   			sta	vdc_regionA_nxt, x	; Save index of next region.
  421    01:DE7B  8A         			txa				; A = current region index.
  422    01:DE7C  80 DD      			bra	!next_region-
  423                        	
  424    01:DE7E  8D E4 25   	!save_first:	sta	vdc_next_region		; Save index of 1st region.
  425                        	
  426    01:DE81  AA         			tax				; NZ if first active region
  427    01:DE82  D0 03      			bne	!init_first+		; is not region 0.
  428    01:DE84  98         			tya				; NZ if region 0 is active.
  429    01:DE85  F0 0F      			beq	!+			; If no active leave RCR=0.
  430                        	
  431    01:DE87  A9 06      	!init_first:	lda	#VDC_RCR		; 1st RCR always happens just
  432    01:DE89  8D 00 02   			sta	VDC_AR			; before the display starts.
  433    01:DE8C  A9 44      			lda.l	#HUCC_1ST_RCR
  434    01:DE8E  8D 02 02   			sta	VDC_DL
  435    01:DE91  A9 01      			lda.h	#HUCC_1ST_RCR
  436    01:DE93  8D 03 02   			sta	VDC_DH
  437                        	
  438               0001     		.if	SUPPORT_SGX
  439                        	
  440    01:DE96  62         	!:		cla				; A = previous active index
  441    01:DE97  A2 08      			ldx	#HUCC_SGX_SPLITS	; so $00 for end-of-screen.
  442                        	
  443    01:DE99  18         			clc				; For regionB indexes.
  444                        	
  445    01:DE9A  CA         	!next_region:	dex				; All regions updated?
  446    01:DE9B  30 20      			bmi	!save_first+
  447                        	
  448    01:DE9D  9E FD 25   			stz	sgx_region_new, x	; Clear region modified flag.
  449                        	
  450    01:DEA0  BC F5 25   			ldy	sgx_region_sel, x	; 0=regionA or 1=regionB.
  451    01:DEA3  F0 0D      			beq	!use_regionA+
  452                        	
  453    01:DEA5  BC 0D 26   	!use_regionB:	ldy	sgx_regionB_crl, x	; Region disabled if $00.
  454    01:DEA8  F0 F0      			beq	!next_region-
  455    01:DEAA  9D 6E 26   			sta	sgx_regionB_nxt, x	; Save index of next region.
  456    01:DEAD  8A         			txa				; A = current region index.
  457    01:DEAE  69 08      			adc	#HUCC_SGX_SPLITS	; Always leaves CC!
  458    01:DEB0  80 E8      			bra	!next_region-
  459                        	
  460    01:DEB2  BC 05 26   	!use_regionA:	ldy	sgx_regionA_crl, x	; Region disabled if $00.
  461    01:DEB5  F0 E3      			beq	!next_region-
  462    01:DEB7  9D 66 26   			sta	sgx_regionA_nxt, x	; Save index of next region.
  463    01:DEBA  8A         			txa				; A = current region index.
  464    01:DEBB  80 DD      			bra	!next_region-
  465                        	
  466    01:DEBD  8D 65 26   	!save_first:	sta	sgx_next_region		; Save index of 1st region.
  467                        	
  468    01:DEC0  AA         			tax				; NZ if first active region
  469    01:DEC1  D0 03      			bne	!init_first+		; is not region 0.
  470    01:DEC3  98         			tya				; NZ if region 0 is active.
  471    01:DEC4  F0 0F      			beq	!+			; If no active leave RCR=0.
  472                        	
  473    01:DEC6  A9 06      	!init_first:	lda	#VDC_RCR		; 1st RCR always happens just
  474    01:DEC8  8D 10 02   			sta	SGX_AR			; before the display starts.
  475    01:DECB  A9 44      			lda.l	#HUCC_1ST_RCR
  476    01:DECD  8D 12 02   			sta	SGX_DL
  477    01:DED0  A9 01      			lda.h	#HUCC_1ST_RCR
  478    01:DED2  8D 13 02   			sta	SGX_DH
  479                        	
  480                        		.endif	SUPPORT_SGX
  481                        	
  482                        	!:		leave				; All done!
         01:DED5  4C EF FF   			jmp	leave_proc
  483                        	
  484                        			.endp
  485                        	
  486                        	
  487                        	
  488               0001     		.if	SUPPORT_SGX
  489                        	
  490                        	; ***************************************************************************
  491                        	; ***************************************************************************
  492                        	;
  493                        	; VDC_RCR_MACRO and SGX_RCR_MACRO
  494                        	;
  495                        	; A 16-byte TIA takes 142..234 cycles in 5MHz, 128..200 cycles in 7MHz.
  496                        	; A 32-byte TIA takes 270..364 cycles in 5MHz, 242..312 cycles in 7MHz. (527 DUO)
  497                        	;
  498                        	; You need to write the last RCR setting within 540 cycles in order to catch
  499                        	; the next line (at 256/336/512 resolution).
  500                        	;
  501                        	; That gives 305 cycles from the RCR to write the last setting, or there
  502                        	; will be a visible glitch on the screen.
  503                        	
  504               0000     		.ifndef	USING_RCR_MACROS
  506                        		.endif
  507                        	
  508                        	;		;;;				; 8 (cycles for the INT)
  509                        	;		bbs1	<irq_vec, .hook		; 8
  510                        	;		jmp	[irq1_hook]		; 7
  511                        	
  512                        	;		;;;				; 8 (cycles for the INT)
  513                        	;		jmp	irq1_handler		; 4
  514                        	
  515                        	;irq1_handler:	pha				; 3 Save all registers.
  516                        	;		phx				; 3
  517                        	;		phy				; 3
  518                        	;
  519                        	;		lda	VDC_SR			; 6 Acknowledge the VDC's IRQ.
  520                        	;		sta	<vdc_sr			; 4 Remember what caused it.
  521                        	;
  522                        	;		ldx	SGX_SR			; 6 Read SGX_SR after VDC_SR in
  523                        	;		stx	<sgx_sr			; 4 case this is not an SGX!
  524                        	;
  525                        	;!:		and	#$04			; 2 Is this an HSYNC interrupt?
  526                        	;		beq	!+			; 2
  527                        	
  528                        			.macro	VDC_RCR_MACRO
  529                        	
  530                        			st0	#VDC_RCR		; 5
  531                        	
  532                        			ldx	vdc_next_region		; 5 X and Y can be greater than
  533                        			ldy	vdc_regionA_nxt, x	; 5 HUCC_PCE_SPLITS if regionB!
  534                        			clc				; 2
  535                        			bne	!set_next_rcr+		; 4 Stop RCR if next line is 0.
  536                        	
  537                        			and	const_0000		; 5 A=$00 with the same #cycles
  538                        			bra	!clr_next_rcr+		; 4 as if the branch were taken.
  539                        	
  540                        	!set_next_rcr:	lda	vdc_regionA_rcr, y	; 5 Set next RCR 1 line before
  541                        			adc	#64-1			; 2 the region begins, or 0 to
  542                        	!clr_next_rcr:	sta	VDC_DL			; 6 disable.
  543                        			cla				; 2
  544                        			rol	a			; 2
  545                        			sta	VDC_DH			; 6
  546                        	
  547                        			st0	#VDC_BYR		; 5 Do BYR first to mitigate the
  548                        			lda	vdc_regionA_yl, x	; 5 glitch if the IRQ is delayed.
  549                        			sta	VDC_DL			; 6 = 105 cycles from RCR on SGX
  550                        			lda	vdc_regionA_yh, x	; 5
  551                        			sta	VDC_DH			; 6
  552                        	
  553                        			st0	#VDC_CR			; 5
  554                        			lda	vdc_regionA_crl, x	; 5
  555                        	;		asl	a
  556                        			sta	VDC_DL			; 6
  557                        	
  558                        			st0	#VDC_BXR		; 2
  559                        			lda	vdc_regionA_xl, x	; 5
  560                        			sta	VDC_DL			; 6
  561                        			lda	vdc_regionA_xh, x	; 5
  562                        			sta	VDC_DH			; 6 = 156 cycles from RCR if DUO
  563                        	
  564                        	;		bcc	!+
  565                        	;		lda	vdc_regionA_yh, x	; 5
  566                        	;		sta.l	VCE_CTW			; 6
  567                        	
  568                        			sty	vdc_next_region		; 5
  569                        	
  570                        			.endm
  571                        	
  572                        	;!:		bbr2	<sgx_sr, !+		; 6 Is this an HSYNC interrupt?
  573                        	
  574                        			.macro	SGX_RCR_MACRO
  575                        	
  576                        			lda	#VDC_RCR		; 2
  577                        			sta	SGX_AR			; 6
  578                        	
  579                        			ldx	sgx_next_region		; 5 X and Y can be greater than
  580                        			ldy	sgx_regionA_nxt, x	; 5 HUCC_SGX_SPLITS if regionB!
  581                        			clc				; 2
  582                        			bne	!set_next_rcr+		; 4 Stop RCR if next line is 0.
  583                        	
  584                        			and	const_0000		; 5 A=$00 with the same #cycles
  585                        			bra	!clr_next_rcr+		; 4 as if the branch were taken.
  586                        	
  587                        	!set_next_rcr:	lda	sgx_regionA_rcr, y	; 5 Set next RCR 1 line before
  588                        			adc	#64-1			; 2 the region begins, or 0 to
  589                        	!clr_next_rcr:	sta	SGX_DL			; 6 disable.
  590                        			cla				; 2
  591                        			rol	a			; 2
  592                        			sta	SGX_DH			; 6
  593                        	
  594                        			lda	#VDC_BYR		; 2 Do BYR first to mitigate the
  595                        			sta	SGX_AR			; 6 glitch if the IRQ is delayed.
  596                        			lda	sgx_regionA_yl, x	; 5
  597                        			sta	SGX_DL			; 6
  598                        			lda	sgx_regionA_yh, x	; 5
  599                        			sta	SGX_DH			; 6
  600                        	
  601                        			lda	#VDC_CR			; 2
  602                        			sta	SGX_AR			; 6
  603                        			lda	sgx_regionA_crl, x	; 5
  604                        			sta	SGX_DL			; 6
  605                        	
  606                        			lda	#VDC_BXR		; 2
  607                        			sta	SGX_AR			; 6
  608                        			lda	sgx_regionA_xl, x	; 5
  609                        			sta	SGX_DL			; 6
  610                        			lda	sgx_regionA_xh, x	; 5
  611                        			sta	SGX_DH			; 6 = 293 cycles (282 if no YH)
  612                        	
  613                        			sty	sgx_next_region		; 5
  614                        	
  615                        			.endm
  616                        	
  617                        		.else	SUPPORT_SGX
  697                        		.endif	SUPPORT_SGX
                             #[2]   "..\..\..\include\hucc\hucc-final.asm"
   68                        		.else
   72                        		.endif	HUCC_USES_NEW_SCROLL
   73                        	
   74               0001     		.ifdef	HUCC_USES_OLD_SPR		; Set in hucc_old_spr.h
                             #[3]   "..\..\..\include\hucc\hucc-old-spr.asm"
   75                        			include	"hucc-old-spr.asm"
    1                        	; ***************************************************************************
    2                        	; ***************************************************************************
    3                        	;
    4                        	; hucc-old-spr.asm
    5                        	;
    6                        	; Based on the original HuC and MagicKit functions by David Michel and the
    7                        	; other original HuC developers.
    8                        	;
    9                        	; Modifications copyright John Brandwood 2024.
   10                        	;
   11                        	; Distributed under the Boost Software License, Version 1.0.
   12                        	; (See accompanying file LICENSE_1_0.txt or copy at
   13                        	;  http://www.boost.org/LICENSE_1_0.txt)
   14                        	;
   15                        	; ***************************************************************************
   16                        	; ***************************************************************************
   17                        	
   18                        	;
   19                        	; Include dependancies ...
   20                        	;
   21                        	
   22                        			include "common.asm"		; Common helpers.
   23                        			include "vce.asm"		; Useful VCE routines.
   24                        			include "vdc.asm"		; Useful VCE routines.
   25                        	
   26                        	
   27                        	
   28                        	; ***************************************************************************
   29                        	; ***************************************************************************
   30                        	;
   31                        	; HuC Sprite Functions
   32                        	;
   33                        	; ***************************************************************************
   34                        	; ***************************************************************************
   35                        	
   36               209C     			.zp
   37    F8:209C             	spr_ptr:	ds	2
   38               2676     			.bss
   39    F8:2676             	spr_sat:	ds	512
   40               E7B7     			.code
   41                        	
   42               0001     		.if	SUPPORT_SGX
   43               209E     			.zp
   44    F8:209E             	sgx_spr_ptr:	ds	2
   45               2876     			.bss
   46    F8:2876             	sgx_spr_sat:	ds	512	; N.B. Directly after spr_sat!
   47               E7B7     			.code
   48                        		.endif
   49                        	
   50                        	; Moved to hucc-old-map.asm just to save space. This NEEDS to be changed!
   51                        	;
   52                        	;		.bss
   53                        	;spr_max:	ds	1
   54                        	;spr_clr:	ds	1
   55                        	;	.if	SUPPORT_SGX
   56                        	;sgx_spr_max:	ds	1
   57                        	;sgx_spr_clr:	ds	1
   58                        	;	.endif
   59                        	;		.code
   60                        	
   61                        	
   62                        	
   63                        	; ***************************************************************************
   64                        	; ***************************************************************************
   65                        	;
   66                        	; void __fastcall init_satb( void );
   67                        	; void __fastcall reset_satb( void );
   68                        	;
   69                        	; void __fastcall sgx_init_satb( void );
   70                        	; void __fastcall sgx_reset_satb( void );
   71                        	
   72    00:E7B7             	_reset_satb:
   73    00:E7B7  C2         	_init_satb:	cly
   74    00:E7B8  62         			cla
   75    00:E7B9  99 76 26   	!:		sta	spr_sat + $0000, y
   76    00:E7BC  99 76 27   			sta	spr_sat + $0100, y
   77    00:E7BF  C8         			iny
   78    00:E7C0  D0 F7      			bne	!-
   79    00:E7C2  8C 4A 25   			sty	spr_max
   80    00:E7C5  C8         			iny
   81    00:E7C6  8C 4B 25   			sty	spr_clr
   82    00:E7C9  60         			rts
   83                        	
   84               0001     		.if	SUPPORT_SGX
   85    00:E7CA             	_sgx_reset_satb:
   86    00:E7CA  C2         	_sgx_init_satb:	cly
   87    00:E7CB  62         			cla
   88    00:E7CC  99 76 28   	!:		sta	sgx_spr_sat + $0000, y
   89    00:E7CF  99 76 29   			sta	sgx_spr_sat + $0100, y
   90    00:E7D2  C8         			iny
   91    00:E7D3  D0 F7      			bne	!-
   92    00:E7D5  8C 5A 25   			sty	sgx_spr_max
   93    00:E7D8  C8         			iny
   94    00:E7D9  8C 5B 25   			sty	sgx_spr_clr
   95    00:E7DC  60         			rts
   96                        		.endif
   97                        	
   98                        	
   99                        	
  100                        	; ***************************************************************************
  101                        	; ***************************************************************************
  102                        	;
  103                        	; void __fastcall satb_update( void );
  104                        	; void __fastcall sgx_satb_update( void );
  105                        	
  106    02:C17B             	old_satb_group	.procgroup
  107                        	
  108               0001     		.if	SUPPORT_SGX
  109                        			.proc	_sgx_satb_update
  115                        			.endp
  116                        		.endif
  117                        	
  118    02:C17B             			.proc	_satb_update
  119                        	
  120    02:C17B  82         			clx				; Offset to PCE VDC.
  121                        	
  122    02:C17C  A9 7F      			lda.h	#$7F00			; HuC puts the SAT here in VRAM
  123                        	;		lda.h	#$0800			; but we put it here instead
  124    02:C17E  64 F0      			stz.l	<_di
  125    02:C180  85 F1      			sta.h	<_di
  126    02:C182  20 7F E3   			jsr	set_di_to_mawr
  127                        	
  128               0001     		.if	SUPPORT_SGX
  129    02:C185  8A         			txa				; Select which VDC to write
  130    02:C186  1A         			inc	a			; to.
  131    02:C187  1A         			inc	a
  132    02:C188  8D F3 22   			sta.l	ram_tia_dst
  133                        		.endif
  134                        	
  135    02:C18B  A9 10      			lda	#VRAM_XFER_SIZE		; Split into 16-byte chunks
  136    02:C18D  8D F5 22   			sta.l	ram_tia_len		; for stable IRQ response.
  137                        	
  138    02:C190  BC 4A 25   			ldy	spr_max, x		; Highest sprite that was set.
  139    02:C193  C8         			iny
  140                        	
  141    02:C194  BD 4B 25   			lda	spr_clr, x
  142    02:C197  F0 05      			beq	!+
  143    02:C199  9E 4B 25   			stz	spr_clr, x
  144    02:C19C  A0 40      			ldy	#64
  145                        	
  146    02:C19E  98         	!:		tya
  147    02:C19F  F0 22      			beq	.exit
  148                        	
  149    02:C1A1  3A         			dec	a			; round up to the next group of 2 sprites
  150    02:C1A2  4A         			lsr	a
  151               0000     		.if	VRAM_XFER_SIZE == 32
  153                        		.endif
  154    02:C1A3  1A         			inc	a
  155    02:C1A4  A8         			tay
  156                        	
  157    02:C1A5  A9 26      			lda.h	#spr_sat
  158                        	
  159               0001     		.if	SUPPORT_SGX
  160    02:C1A7  E0 00      			cpx	#0
  161    02:C1A9  F0 02      			beq	!+
  162                        	
  163    02:C1AB  A9 28      			lda.h	#sgx_spr_sat
  164                        		.endif
  165                        	
  166    02:C1AD  8D F2 22   	!:		sta.h	ram_tia_src
  167                        	
  168    02:C1B0  A9 76      			lda.l	#spr_sat		; Same for SGX and PCE!
  169    02:C1B2  8D F1 22   	.chunk_loop:	sta.l	ram_tia_src
  170                        	
  171    02:C1B5  20 F0 22   			jsr	ram_tia			; transfer 16-bytes
  172                        	
  173    02:C1B8  18         			clc				; increment source
  174    02:C1B9  69 10      			adc	#VRAM_XFER_SIZE
  175    02:C1BB  90 03      			bcc	.same_page
  176    02:C1BD  EE F2 22   			inc.h	ram_tia_src
  177                        	
  178    02:C1C0  88         	.same_page:	dey
  179    02:C1C1  D0 EF      			bne	.chunk_loop
  180                        	
  181                        	.exit:		leave
         02:C1C3  4C EF FF   			jmp	leave_proc
  182                        	
  183                        			.endp
  184                        	
  185                        			.endprocgroup	; old_satb_group
  186                        	
  187                        	
  188                        	
  189                        	; ***************************************************************************
  190                        	; ***************************************************************************
  191                        	;
  192                        	; void __fastcall spr_set( unsigned char num<acc> );
  193                        	
  194    00:E7DD  CD 4A 25   	_spr_set.1:	cmp	spr_max
  195    00:E7E0  90 03      			bcc	!+
  196    00:E7E2  8D 4A 25   			sta	spr_max
  197    00:E7E5  A0 26      	!:		ldy.h	#spr_sat
  198    00:E7E7  0A         			asl	a
  199    00:E7E8  0A         			asl	a
  200    00:E7E9  0A         			asl	a
  201    00:E7EA  90 02      			bcc	!+
  202    00:E7EC  C8         			iny
  203    00:E7ED  18         			clc
  204    00:E7EE  69 76      	!:		adc.l	#spr_sat
  205    00:E7F0  85 9C      			sta.l	<spr_ptr
  206    00:E7F2  90 01      			bcc	!+
  207    00:E7F4  C8         			iny
  208    00:E7F5  84 9D      	!:		sty.h	<spr_ptr
  209    00:E7F7  60         			rts
  210                        	
  211                        	
  212                        	
  213                        	; ***************************************************************************
  214                        	; ***************************************************************************
  215                        	;
  216                        	; void __fastcall spr_hide( void );
  217                        	
  218    00:E7F8  A0 01      	_spr_hide:	ldy	#1
  219    00:E7FA  B1 9C      			lda	[spr_ptr], y
  220    00:E7FC  09 02      			ora	#2
  221    00:E7FE  91 9C      			sta	[spr_ptr], y
  222    00:E800  60         			rts
  223                        	
  224                        	
  225                        	
  226                        	; ***************************************************************************
  227                        	; ***************************************************************************
  228                        	;
  229                        	; void __fastcall spr_show( void );
  230                        	
  231    00:E801  A0 01      	_spr_show:	ldy	#1
  232    00:E803  B1 9C      			lda	[spr_ptr], y
  233    00:E805  29 01      			and	#1
  234    00:E807  91 9C      			sta	[spr_ptr], y
  235    00:E809  60         			rts
  236                        	
  237                        	
  238                        	
  239                        	; ***************************************************************************
  240                        	; ***************************************************************************
  241                        	;
  242                        	; void __fastcall spr_x( unsigned int value<acc> );
  243                        	
  244    00:E80A  02         	_spr_x.1:	sxy
  245    00:E80B  18         			clc
  246    00:E80C  69 20      			adc	#32
  247    00:E80E  A0 02      			ldy	#2
  248    00:E810  91 9C      			sta	[spr_ptr], y
  249    00:E812  8A         			txa
  250    00:E813  69 00      			adc	#0
  251    00:E815  C8         			iny
  252    00:E816  91 9C      			sta	[spr_ptr], y
  253    00:E818  60         			rts
  254                        	
  255                        	
  256                        	
  257                        	; ***************************************************************************
  258                        	; ***************************************************************************
  259                        	;
  260                        	; void __fastcall spr_y( unsigned int value<acc> );
  261                        	
  262    00:E819  18         	_spr_y.1:	clc
  263    00:E81A  69 40      			adc	#64
  264    00:E81C  92 9C      			sta	[spr_ptr]
  265    00:E81E  98         			tya
  266    00:E81F  69 00      			adc	#0
  267    00:E821  A0 01      			ldy	#1
  268    00:E823  91 9C      			sta	[spr_ptr], y
  269    00:E825  60         			rts
  270                        			
  271                        	
  272                        	
  273                        	; ***************************************************************************
  274                        	; ***************************************************************************
  275                        	;
  276                        	; void __fastcall spr_pattern( unsigned int vaddr<acc> );
  277                        	
  278    00:E826  84 00      	_spr_pattern.1:	sty	<__temp		;     zp=fedcba98 a=76543210
  279    00:E828  0A         			asl	a		; c=f zp=edcba987 a=6543210_
  280    00:E829  26 00      			rol	<__temp
  281    00:E82B  2A         			rol	a		; c=e zp=dcba9876 a=543210_f
  282    00:E82C  26 00      			rol	<__temp
  283    00:E82E  2A         			rol	a		; c=d zp=cba98765 a=43210_fe
  284    00:E82F  26 00      			rol	<__temp
  285    00:E831  2A         			rol	a		; c=4 zp=cba98765 a=3210_fed
  286    00:E832  A0 05      			ldy	#5
  287    00:E834  91 9C      			sta	[spr_ptr], y
  288    00:E836  A5 00      			lda	<__temp
  289    00:E838  88         			dey
  290    00:E839  91 9C      			sta	[spr_ptr], y
  291    00:E83B  60         			rts
  292                        	
  293                        	
  294                        	
  295                        	; ***************************************************************************
  296                        	; ***************************************************************************
  297                        	;
  298                        	; void __fastcall spr_ctrl( unsigned char mask<_al>, unsigned char value<acc> );
  299                        	
  300    00:E83C  25 F8      	_spr_ctrl.2:	and	<_al
  301    00:E83E  85 00      			sta	<__temp
  302    00:E840  A5 F8      			lda	<_al
  303    00:E842  49 FF      			eor	#$FF
  304    00:E844  A0 07      			ldy	#7
  305    00:E846  31 9C      			and	[spr_ptr], y
  306    00:E848  05 00      			ora	<__temp
  307    00:E84A  91 9C      			sta	[spr_ptr], y
  308    00:E84C  60         			rts
  309                        	
  310                        	
  311                        	
  312                        	; ***************************************************************************
  313                        	; ***************************************************************************
  314                        	;
  315                        	; void __fastcall spr_pal( unsigned char palette<acc> )
  316                        	
  317    00:E84D  29 0F      	_spr_pal.1:	and	#$0F
  318    00:E84F  85 00      			sta	<__temp
  319    00:E851  A0 06      			ldy	#6
  320    00:E853  B1 9C      			lda	[spr_ptr], y
  321    00:E855  29 F0      			and	#$F0
  322    00:E857  05 00      			ora	<__temp
  323    00:E859  91 9C      			sta	[spr_ptr], y
  324    00:E85B  60         			rts
  325                        	
  326                        	
  327                        	
  328                        	; ***************************************************************************
  329                        	; ***************************************************************************
  330                        	;
  331                        	; void __fastcall spr_pri( unsigned char priority<acc> )
  332                        	
  333    00:E85C  C9 01      	_spr_pri.1:	cmp	#1
  334    00:E85E  A0 06      			ldy	#6
  335    00:E860  B1 9C      			lda	[spr_ptr], y
  336    00:E862  29 7F      			and	#$7F
  337    00:E864  90 02      			bcc	!+
  338    00:E866  09 80      			ora	#$80
  339    00:E868  91 9C      	!:		sta	[spr_ptr], y
  340    00:E86A  60         			rts
  341                        	
  342                        	
  343                        	
  344                        	; ***************************************************************************
  345                        	; ***************************************************************************
  346                        	;
  347                        	; unsigned int __fastcall spr_get_x( void );
  348                        	
  349    00:E86B  38         	_spr_get_x:	sec
  350    00:E86C  A0 02      			ldy	#2
  351    00:E86E  B1 9C      			lda	[spr_ptr], y
  352    00:E870  E9 20      			sbc	#32
  353    00:E872  AA         			tax
  354    00:E873  C8         			iny
  355    00:E874  B1 9C      			lda	[spr_ptr], y
  356    00:E876  E9 00      			sbc	#0
  357    00:E878  A8         			tay
  358    00:E879  8A         			txa
  359    00:E87A  60         			rts
  360                        	
  361                        	
  362                        	
  363                        	; ***************************************************************************
  364                        	; ***************************************************************************
  365                        	;
  366                        	; unsigned int __fastcall spr_get_y( void );
  367                        	
  368    00:E87B  38         	_spr_get_y:	sec
  369    00:E87C  B2 9C      			lda	[spr_ptr]
  370    00:E87E  E9 40      			sbc	#64
  371    00:E880  AA         			tax
  372    00:E881  A0 01      			ldy	#1
  373    00:E883  B1 9C      			lda	[spr_ptr], y
  374    00:E885  E9 00      			sbc	#0
  375    00:E887  A8         			tay
  376    00:E888  8A         			txa
  377    00:E889  60         			rts
  378                        	
  379                        	
  380                        	
  381               0001     		.if	SUPPORT_SGX
  382                        	
  383                        	; ***************************************************************************
  384                        	; ***************************************************************************
  385                        	;
  386                        	; void __fastcall sgx_spr_set( unsigned char num<acc> );
  387                        	
  388    00:E88A  CD 5A 25   	_sgx_spr_set.1:	cmp	sgx_spr_max
  389    00:E88D  90 03      			bcc	!+
  390    00:E88F  8D 5A 25   			sta	sgx_spr_max
  391    00:E892  A0 28      	!:		ldy.h	#sgx_spr_sat
  392    00:E894  0A         			asl	a
  393    00:E895  0A         			asl	a
  394    00:E896  0A         			asl	a
  395    00:E897  90 02      			bcc	!+
  396    00:E899  C8         			iny
  397    00:E89A  18         			clc
  398    00:E89B  69 76      	!:		adc.l	#sgx_spr_sat
  399    00:E89D  85 9E      			sta.l	<sgx_spr_ptr
  400    00:E89F  90 01      			bcc	!+
  401    00:E8A1  C8         			iny
  402    00:E8A2  84 9F      	!:		sty.h	<sgx_spr_ptr
  403    00:E8A4  60         			rts
  404                        	
  405                        	
  406                        	
  407                        	; ***************************************************************************
  408                        	; ***************************************************************************
  409                        	;
  410                        	; void __fastcall sgx_spr_hide( void );
  411                        	
  412    00:E8A5  A0 01      	_sgx_spr_hide:	ldy	#1
  413    00:E8A7  B1 9E      			lda	[sgx_spr_ptr], y
  414    00:E8A9  09 02      			ora	#2
  415    00:E8AB  91 9E      			sta	[sgx_spr_ptr], y
  416    00:E8AD  60         			rts
  417                        	
  418                        	
  419                        	
  420                        	; ***************************************************************************
  421                        	; ***************************************************************************
  422                        	;
  423                        	; void __fastcall sgx_spr_show( void );
  424                        	
  425    00:E8AE  A0 01      	_sgx_spr_show:	ldy	#1
  426    00:E8B0  B1 9E      			lda	[sgx_spr_ptr], y
  427    00:E8B2  29 01      			and	#1
  428    00:E8B4  91 9E      			sta	[sgx_spr_ptr], y
  429    00:E8B6  60         			rts
  430                        	
  431                        	
  432                        	
  433                        	; ***************************************************************************
  434                        	; ***************************************************************************
  435                        	;
  436                        	; void __fastcall sgx_spr_x( unsigned int value<acc> );
  437                        	
  438    00:E8B7  02         	_sgx_spr_x.1:	sxy
  439    00:E8B8  18         			clc
  440    00:E8B9  69 20      			adc	#32
  441    00:E8BB  A0 02      			ldy	#2
  442    00:E8BD  91 9E      			sta	[sgx_spr_ptr], y
  443    00:E8BF  8A         			txa
  444    00:E8C0  69 00      			adc	#0
  445    00:E8C2  C8         			iny
  446    00:E8C3  91 9E      			sta	[sgx_spr_ptr], y
  447    00:E8C5  60         			rts
  448                        	
  449                        	
  450                        	
  451                        	; ***************************************************************************
  452                        	; ***************************************************************************
  453                        	;
  454                        	; void __fastcall sgx_spr_y( unsigned int value<acc> );
  455                        	
  456    00:E8C6  18         	_sgx_spr_y.1:	clc
  457    00:E8C7  69 40      			adc	#64
  458    00:E8C9  92 9E      			sta	[sgx_spr_ptr]
  459    00:E8CB  98         			tya
  460    00:E8CC  69 00      			adc	#0
  461    00:E8CE  A0 01      			ldy	#1
  462    00:E8D0  91 9E      			sta	[sgx_spr_ptr], y
  463    00:E8D2  60         			rts
  464                        			
  465                        	
  466                        	
  467                        	; ***************************************************************************
  468                        	; ***************************************************************************
  469                        	;
  470                        	; void __fastcall sgx_spr_pattern( unsigned int vaddr<acc> );
  471                        	
  472    00:E8D3             	_sgx_spr_pattern.1:
  473    00:E8D3  84 00      			sty	<__temp		;     zp=fedcba98 a=76543210
  474    00:E8D5  0A         			asl	a		; c=f zp=edcba987 a=6543210_
  475    00:E8D6  26 00      			rol	<__temp
  476    00:E8D8  2A         			rol	a		; c=e zp=dcba9876 a=543210_f
  477    00:E8D9  26 00      			rol	<__temp
  478    00:E8DB  2A         			rol	a		; c=d zp=cba98765 a=43210_fe
  479    00:E8DC  26 00      			rol	<__temp
  480    00:E8DE  2A         			rol	a		; c=4 zp=cba98765 a=3210_fed
  481    00:E8DF  A0 05      			ldy	#5
  482    00:E8E1  91 9E      			sta	[sgx_spr_ptr], y
  483    00:E8E3  A5 00      			lda	<__temp
  484    00:E8E5  88         			dey
  485    00:E8E6  91 9E      			sta	[sgx_spr_ptr], y
  486    00:E8E8  60         			rts
  487                        	
  488                        	
  489                        	
  490                        	; ***************************************************************************
  491                        	; ***************************************************************************
  492                        	;
  493                        	; void __fastcall sgx_spr_ctrl( unsigned char mask<_al>, unsigned char value<acc> );
  494                        	
  495    00:E8E9  25 F8      	_sgx_spr_ctrl.2:and	<_al
  496    00:E8EB  85 00      			sta	<__temp
  497    00:E8ED  A5 F8      			lda	<_al
  498    00:E8EF  49 FF      			eor	#$FF
  499    00:E8F1  A0 07      			ldy	#7
  500    00:E8F3  31 9E      			and	[sgx_spr_ptr], y
  501    00:E8F5  05 00      			ora	<__temp
  502    00:E8F7  91 9E      			sta	[sgx_spr_ptr], y
  503    00:E8F9  60         			rts
  504                        	
  505                        	
  506                        	
  507                        	; ***************************************************************************
  508                        	; ***************************************************************************
  509                        	;
  510                        	; void __fastcall sgx_spr_pal( unsigned char palette<acc> )
  511                        	
  512    00:E8FA  29 0F      	_sgx_spr_pal.1:	and	#$0F
  513    00:E8FC  85 00      			sta	<__temp
  514    00:E8FE  A0 06      			ldy	#6
  515    00:E900  B1 9E      			lda	[sgx_spr_ptr], y
  516    00:E902  29 F0      			and	#$F0
  517    00:E904  05 00      			ora	<__temp
  518    00:E906  91 9E      			sta	[sgx_spr_ptr], y
  519    00:E908  60         			rts
  520                        	
  521                        	
  522                        	
  523                        	; ***************************************************************************
  524                        	; ***************************************************************************
  525                        	;
  526                        	; void __fastcall sgx_spr_pri( unsigned char priority<acc> )
  527                        	
  528    00:E909  C9 01      	_sgx_spr_pri.1:	cmp	#1
  529    00:E90B  A0 06      			ldy	#6
  530    00:E90D  B1 9E      			lda	[sgx_spr_ptr], y
  531    00:E90F  29 7F      			and	#$7F
  532    00:E911  90 02      			bcc	!+
  533    00:E913  09 80      			ora	#$80
  534    00:E915  91 9E      	!:		sta	[sgx_spr_ptr], y
  535    00:E917  60         			rts
  536                        	
  537                        	
  538                        	
  539                        	; ***************************************************************************
  540                        	; ***************************************************************************
  541                        	;
  542                        	; unsigned int __fastcall sgx_spr_get_x( void );
  543                        	
  544    00:E918  38         	_sgx_spr_get_x:	sec
  545    00:E919  A0 02      			ldy	#2
  546    00:E91B  B1 9E      			lda	[sgx_spr_ptr], y
  547    00:E91D  E9 20      			sbc	#32
  548    00:E91F  AA         			tax
  549    00:E920  C8         			iny
  550    00:E921  B1 9E      			lda	[sgx_spr_ptr], y
  551    00:E923  E9 00      			sbc	#0
  552    00:E925  A8         			tay
  553    00:E926  8A         			txa
  554    00:E927  60         			rts
  555                        	
  556                        	
  557                        	
  558                        	; ***************************************************************************
  559                        	; ***************************************************************************
  560                        	;
  561                        	; unsigned int __fastcall sgx_spr_get_y( void );
  562                        	
  563    00:E928  38         	_sgx_spr_get_y:	sec
  564    00:E929  B2 9E      			lda	[sgx_spr_ptr]
  565    00:E92B  E9 40      			sbc	#64
  566    00:E92D  AA         			tax
  567    00:E92E  A0 01      			ldy	#1
  568    00:E930  B1 9E      			lda	[sgx_spr_ptr], y
  569    00:E932  E9 00      			sbc	#0
  570    00:E934  A8         			tay
  571    00:E935  8A         			txa
  572    00:E936  60         			rts
  573                        	
  574                        		.endif	SUPPORT_SGX
                             #[2]   "..\..\..\include\hucc\hucc-final.asm"
   76                        		.endif
   77                        	
   78               0001     		.ifdef	HUCC_USES_BLKMAP		; Set in hucc_blkmap.h
                             #[3]   "..\..\..\include\hucc\blkmap.asm"
   79                        			include	"blkmap.asm"
    1                        	; ***************************************************************************
    2                        	; ***************************************************************************
    3                        	;
    4                        	; blkmap.asm
    5                        	;
    6                        	; A map system based on 16x16 meta-tiles (aka "blocks", aka CHR/BLK/MAP).
    7                        	;
    8                        	; Copyright John Brandwood 2025.
    9                        	;
   10                        	; Distributed under the Boost Software License, Version 1.0.
   11                        	; (See accompanying file LICENSE_1_0.txt or copy at
   12                        	;  http://www.boost.org/LICENSE_1_0.txt)
   13                        	;
   14                        	; ***************************************************************************
   15                        	; ***************************************************************************
   16                        	;
   17                        	; The maximum X and Y size for blkmaps is 128 blocks (2048 pixels).
   18                        	;
   19                        	; The maximum total size for a blkmap is 16KBytes, which allows for maps up
   20                        	; to 128x128 blocks (2048x2048 pixels).
   21                        	;
   22                        	; Huge multi-screen blkmaps are also supported (optionally).
   23                        	;
   24                        	; The maximum X and Y for multi-screen maps is 128 screens (32768 pixels).
   25                        	;
   26                        	; The maximum total size for a multi-screen map is 8KBytes, which allows for
   27                        	; a total of 1024 screens.
   28                        	;
   29                        	; ***************************************************************************
   30                        	; ***************************************************************************
   31                        	
   32                        	;
   33                        	; Include dependancies ...
   34                        	;
   35                        	
   36                        			include "common.asm"		; Common helpers.
   37                        			include "vce.asm"		; Useful VCE routines.
   38                        			include "vdc.asm"		; Useful VCE routines.
   39                        	
   40                        	;
   41                        	; Support large blkmaps up to 16KBytes instead of the regular 8KBytes?
   42                        	;
   43                        	; The maximum X and Y size for regular blkmaps is 128 tiles (2048 pixels).
   44                        	;
   45                        	; This allows for individual maps up to 128x128 tiles (2048x2048 pixels) vs
   46                        	; default limit of 128x64 or 64x128.
   47                        	;
   48                        	
   49               0000     		.ifndef	BLKMAP_LARGEMAP
   51                        		.endif
   52                        	
   53                        	;
   54                        	; Support huge multi-screen maps, up to 32768 pixels wide/high?
   55                        	;
   56                        	; These are sectorized maps split into individual BAT-sized "screens", with
   57                        	; a maximum of 1024 screens per map.
   58                        	;
   59                        	; The BAT size that is used when drawing *must* be the same as the BAT size
   60                        	; that was chosen when creating the multi-screen map.
   61                        	;
   62                        	; Each screen can use a unique set of block definitions, or it might choose
   63                        	; to share the same block definitions that are used on another screen.
   64                        	;
   65                        	; Each screen may choose which 8KByte banks of character data to select for
   66                        	; the 4 banks (32KBytes) of VRAM that its block definitions use, with a max
   67                        	; of 16 banks of characters per multi-screen map.
   68                        	;
   69                        	; Loading those character banks dynamically is an exercise for the user!
   70                        	;
   71                        	; Enabling support adds extra library code, and slightly slows down the use
   72                        	; of regular blkmaps.
   73                        	;
   74                        	
   75               0000     		.ifndef	BLKMAP_MULTISCR
   77                        		.endif
   78                        	
   79                        	;
   80                        	; Block definitions can either use character data from VRAM $1000..$7FFF or
   81                        	; they can be limited to use the 32KByte of characters in VRAM $1000..$4FFF
   82                        	; which then frees up 2-bits for flag information for each character in the
   83                        	; block.
   84                        	;
   85                        	; These 2-bits are perfect for using as collision information in game maps,
   86                        	; allowing storage of states like transparent, solid, up-slope, down-slope.
   87                        	;
   88                        	; Typically this flag information is set by the map conversion tools from a
   89                        	; seperate "collision" map layer.
   90                        	;
   91                        	
   92               0000     		.ifndef	BLKDEF_CHR_FLAG
   94                        		.endif
   95                        	
   96                        	;
   97                        	; Block definitions are accessed in MPR2 ($4000..$5FFF), and must not cross
   98                        	; the bank boundary.
   99                        	;
  100                        	; When working this way, 8 pointers in ZP are used to access the individual
  101                        	; bytes in the block definition. This is fine when using a regular map on a
  102                        	; PC Engine, but it is awfully slow when using multi-screen maps or drawing
  103                        	; maps on both VDC chips in a SuperGRAFX because the pointer values must be
  104                        	; constantly changed.
  105                        	;
  106                        	; When using multi-screen maps, or when developing a SuperGRAFX game, or if
  107                        	; developing a CDROM game, then it is usually preferable to store the block
  108                        	; definitions with 2KByte alignment, especially if they are normally stored
  109                        	; compressed and then decompressed into a 2KByte buffer in RAM when needed.
  110                        	;
  111                        	; This option controls whether the definitions are stored 2KByte aligned or
  112                        	; if pointers should be used instead.
  113                        	;
  114                        	
  115               0000     		.ifndef	BLKDEF_POINTERS
  117                        		.endif
  118                        	
  119                        	;
  120                        	; Add a timing bar to the scroll_map() to see how long the drawing takes?
  121                        	;
  122                        	
  123               0000     		.ifndef	BLKMAP_TIMETEST
  125                        		.endif
  126                        	
  127                        	;
  128                        	;
  129                        	;
  130                        	
  131               0000     		.if	BLKDEF_POINTERS
  144                        		.else
  145                        	
  146                        		; If the block definititions are 2KByte aligned.
  147                        	
  148               4000     	BLK_4000_TL_L	=	$4000
  149               4100     	BLK_4000_TR_L	=	$4100
  150               4200     	BLK_4000_BL_L	=	$4200
  151               4300     	BLK_4000_BR_L	=	$4300
  152               4400     	BLK_4000_TL_H	=	$4400
  153               4500     	BLK_4000_TR_H	=	$4500
  154               4600     	BLK_4000_BL_H	=	$4600
  155               4700     	BLK_4000_BR_H	=	$4700
  156                        	
  157               4800     	BLK_4800_TL_L	=	$4800
  158               4900     	BLK_4800_TR_L	=	$4900
  159               4A00     	BLK_4800_BL_L	=	$4A00
  160               4B00     	BLK_4800_BR_L	=	$4B00
  161               4C00     	BLK_4800_TL_H	=	$4C00
  162               4D00     	BLK_4800_TR_H	=	$4D00
  163               4E00     	BLK_4800_BL_H	=	$4E00
  164               4F00     	BLK_4800_BR_H	=	$4F00
  165                        	
  166               5000     	BLK_5000_TL_L	=	$5000
  167               5100     	BLK_5000_TR_L	=	$5100
  168               5200     	BLK_5000_BL_L	=	$5200
  169               5300     	BLK_5000_BR_L	=	$5300
  170               5400     	BLK_5000_TL_H	=	$5400
  171               5500     	BLK_5000_TR_H	=	$5500
  172               5600     	BLK_5000_BL_H	=	$5600
  173               5700     	BLK_5000_BR_H	=	$5700
  174                        	
  175               5800     	BLK_5800_TL_L	=	$5800
  176               5900     	BLK_5800_TR_L	=	$5900
  177               5A00     	BLK_5800_BL_L	=	$5A00
  178               5B00     	BLK_5800_BR_L	=	$5B00
  179               5C00     	BLK_5800_TL_H	=	$5C00
  180               5D00     	BLK_5800_TR_H	=	$5D00
  181               5E00     	BLK_5800_BL_H	=	$5E00
  182               5F00     	BLK_5800_BR_H	=	$5F00
  183                        	
  184                        		.endif
  185                        	
  186               0080     	MAP_UNALIGNED_X	=	$80
  187               0040     	MAP_UNALIGNED_Y	=	$40
  188                        	
  189                        	;
  190                        	;
  191                        	;
  192                        	
  193               2A76     			.bss
  194                        	
  195                        	; **************
  196                        	; 8-byte (or 2-byte) entry for each SCREEN in the MULTI_MAP.
  197                        	
  198               0000     			.rsset	0
  199               0000     		.if	BLKDEF_POINTERS
  202                        		.else
  203               0000     	SCR_MAP_PAGE	.rs	1	; 256-byte aligned.
  204               0001     	SCR_MAP_BANK	.rs	1
  205               0002     	SCR_BLK_PAGE	.rs	1	; >$4000, >$4800, >$5000, or >$5800.
  206               0003     	SCR_BLK_BANK	.rs	1
  207               0004     	SCR_TBL_PAGE	.rs	1	; 256-byte aligned.
  208               0005     	SCR_TBL_BANK	.rs	1
  209               0006     	SCR_CHR_12	.rs	1	; Which CHR banks are used by the BLK, with
  210               0007     	SCR_CHR_34	.rs	1	; a max of 16 CHR banks per MULTI_MAP.
  211                        		.endif
  212                        	
  213                        			; A simple macro to help build a multi-screen map.
  214                        	
  215               0000     		.ifndef	SCREEN
  224                        		.endif
  225                        	
  226    F8:2A76             	map_blk_flag:	ds	1	; Returned from _get_map_block().
  227    F8:2A77             	map_blk_mask:	ds	1	; Returned from _get_map_block().
  228                        	
  229                        	; **************
  230                        	; 16-bytes of VDC blkmap info.
  231                        	;
  232                        	; N.B. MUST be 16-bytes before the SGX versions to use PCE_VDC_OFFSET.
  233                        	
  234    F8:2A78             	vdc_old_chr_x:	ds	1	; Previous top-left X in CHR (lo-byte only).
  235    F8:2A79             	vdc_old_chr_y:	ds	1	; Previous top-left Y in CHR (lo-byte only).
  236                        	
  237    F8:2A7A             	vdc_tbl_addr:	ds	2	; 256-byte aligned.
  238    F8:2A7C             	vdc_tbl_bank:	ds	1
  239                        	
  240    F8:2A7D             	vdc_blk_addr:	ds	2	; 2KBytes of data, 256-byte aligned.
  241    F8:2A7F             	vdc_blk_bank:	ds	1
  242                        	
  243    F8:2A80             	vdc_map_addr:	ds	2	; Mapped into MPR3..MPR5, max 16KBytes.
  244    F8:2A82             	vdc_map_bank:	ds	1
  245                        	
  246    F8:2A83             	vdc_scr_addr:	ds	2	; 8KByte maximum size.
  247    F8:2A85             	vdc_scr_bank:	ds	1
  248    F8:2A86             	vdc_scr_chr12:	ds	1	; Which CHR banks are used by the BLK, with
  249    F8:2A87             	vdc_scr_chr34:	ds	1	; a max of 16 banks per multi-screen map.
  250                        	
  251               0001     		.if	SUPPORT_SGX
  252                        	
  253                        	; **************
  254                        	; 16-bytes of SGX blkmap info.
  255                        	;
  256                        	; N.B. MUST be 16-bytes after the VDC versions to use SGX_VDC_OFFSET.
  257                        	
  258    F8:2A88             	sgx_old_chr_x:	ds	1	; Previous top-left X in CHR (lo-byte only).
  259    F8:2A89             	sgx_old_chr_y:	ds	1	; Previous top-left Y in CHR (lo-byte only).
  260                        	
  261    F8:2A8A             	sgx_tbl_addr:	ds	2	; 256-byte aligned.
  262    F8:2A8C             	sgx_tbl_bank:	ds	1
  263                        	
  264    F8:2A8D             	sgx_blk_addr:	ds	2	; 2KBytes of data, 256-byte aligned.
  265    F8:2A8F             	sgx_blk_bank:	ds	1
  266                        	
  267    F8:2A90             	sgx_map_addr:	ds	2	; Mapped into MPR3..MPR4, max 8KBytes.
  268    F8:2A92             	sgx_map_bank:	ds	1
  269                        	
  270    F8:2A93             	sgx_scr_addr:	ds	2	; 8KByte maximum size.
  271    F8:2A95             	sgx_scr_bank:	ds	1
  272    F8:2A96             	sgx_scr_chr12:	ds	1	; Which CHR banks are used by the BLK, with
  273    F8:2A97             	sgx_scr_chr34:	ds	1	; a max of 16 banks per multi-screen map.
  274                        	
  275                        		.endif	SUPPORT_SGX
  276                        	
  277               0000     		.if	0
  310                        		.endif	0
  311                        	
  312                        	; **************
  313                        	; Aliases for the asm variable names in HuCC.
  314                        	;
  315                        	
  316               0001     		.ifdef	HUCC
  317                        	
  318    F8:2A98             	_map_blk_flag	.alias	map_blk_flag
  319    F8:2A98             	_map_blk_mask	.alias	map_blk_mask
  320                        	
  321    F8:2A98             	_vdc_map_draw_w	.alias	vdc_map_draw_w
  322    F8:2A98             	_vdc_map_draw_h	.alias	vdc_map_draw_h
  323    F8:2A98             	_vdc_map_pxl_x	.alias	vdc_map_pxl_x
  324    F8:2A98             	_vdc_map_pxl_y	.alias	vdc_map_pxl_y
  325    F8:2A98             	_vdc_old_chr_x	.alias	vdc_old_chr_x
  326    F8:2A98             	_vdc_old_chr_y	.alias	vdc_old_chr_y
  327    F8:2A98             	_vdc_tbl_addr	.alias	vdc_tbl_addr
  328    F8:2A98             	_vdc_tbl_bank	.alias	vdc_tbl_bank
  329    F8:2A98             	_vdc_blk_addr	.alias	vdc_blk_addr
  330    F8:2A98             	_vdc_blk_bank	.alias	vdc_blk_bank
  331    F8:2A98             	_vdc_map_line_w	.alias	vdc_map_line_w
  332    F8:2A98             	_vdc_map_scrn_w	.alias	vdc_map_scrn_w
  333    F8:2A98             	_vdc_map_addr	.alias	vdc_map_addr
  334    F8:2A98             	_vdc_map_bank	.alias	vdc_map_bank
  335    F8:2A98             	_vdc_scr_addr	.alias	vdc_scr_addr
  336    F8:2A98             	_vdc_scr_bank	.alias	vdc_scr_bank
  337    F8:2A98             	_vdc_scr_chr12	.alias	vdc_scr_chr12
  338    F8:2A98             	_vdc_scr_chr34	.alias	vdc_scr_chr34
  339                        	
  340               0001     		.if	SUPPORT_SGX
  341    F8:2A98             	_sgx_map_draw_w	.alias	sgx_map_draw_w
  342    F8:2A98             	_sgx_map_draw_h	.alias	sgx_map_draw_h
  343    F8:2A98             	_sgx_map_pxl_x	.alias	sgx_map_pxl_x
  344    F8:2A98             	_sgx_map_pxl_y	.alias	sgx_map_pxl_y
  345    F8:2A98             	_sgx_old_chr_x	.alias	sgx_old_chr_x
  346    F8:2A98             	_sgx_old_chr_y	.alias	sgx_old_chr_y
  347    F8:2A98             	_sgx_tbl_addr	.alias	sgx_tbl_addr
  348    F8:2A98             	_sgx_tbl_bank	.alias	sgx_tbl_bank
  349    F8:2A98             	_sgx_blk_addr	.alias	sgx_blk_addr
  350    F8:2A98             	_sgx_blk_bank	.alias	sgx_blk_bank
  351    F8:2A98             	_sgx_map_line_w	.alias	sgx_map_line_w
  352    F8:2A98             	_sgx_map_scrn_w	.alias	sgx_map_scrn_w
  353    F8:2A98             	_sgx_map_addr	.alias	sgx_map_addr
  354    F8:2A98             	_sgx_map_bank	.alias	sgx_map_bank
  355    F8:2A98             	_sgx_scr_addr	.alias	sgx_scr_addr
  356    F8:2A98             	_sgx_scr_bank	.alias	sgx_scr_bank
  357    F8:2A98             	_sgx_scr_chr12	.alias	sgx_scr_chr12
  358    F8:2A98             	_sgx_scr_chr34	.alias	sgx_scr_chr34
  359                        		.endif	SUPPORT_SGX
  360                        	
  361                        		.endif	HUCC
  362                        	
  363                        	; **************
  364                        	; Temporary variables for drawing, using common zero-page locations.
  365                        	;
  366                        	
  367               20F8     	map_bat_x	=	_al	; Set by draw_map(), scroll_map() if drawing
  368               20F9     	map_bat_y	=	_ah	; aligned, or as parameters to blit_map().
  369                        	
  370               20FA     	map_draw_w	=	_bl	; Set by draw_map(), scroll_map(), but given
  371               20FB     	map_draw_h	=	_bh	; as parameters to blit_map().
  372                        	
  373               20FC     	map_pxl_x	=	_cx	; Set by draw_map(), scroll_map() and also by
  374               20FC     	map_chr_x	=	_cl	; blit__map(), from current vdc_map_pxl_x.
  375               20FD     	map_scrn_x	=	_ch
  376                        	
  377               20FE     	map_pxl_y	=	_dx	; Set by draw_map(), scroll_map() and also by
  378               20FE     	map_chr_y	=	_dl	; blit__map(), from current vdc_map_pxl_y.
  379               20FF     	map_scrn_y	=	_dh
  380                        	
  381               20EE     	map_line	=	_si	; Start of map data line being drawn.
  382                        	
  383               2000     	map_count	=	__temp + 0
  384               2001     	map_drawn	=	__temp + 1
  385                        	
  386               E937     			.code
  387                        	
  388                        	
  389                        	
  390    01:C0F6             	blkmap_group	.procgroup
  391                        	
  392                        	; ***************************************************************************
  393                        	; ***************************************************************************
  394                        	;
  395                        	; _set_blocks - Initialize the block definition pointers.
  396                        	; _sgx_set_blocks - Initialize the block definition pointers.
  397                        	;
  398                        	; void __fastcall set_blocks( unsigned char __far *blk_def<vdc_blk_bank:vdc_blk_addr>, unsigned char __far *flg_def<vdc_tbl_bank:vdc_tbl_addr>, unsigned char number_of_blk<_al> );
  399                        	; void __fastcall sgx_set_blocks( unsigned char __far *blk_def<sgx_blk_bank:sgx_blk_addr>, unsigned char __far *flg_def<sgx_tbl_bank:sgx_tbl_addr>, unsigned char number_of_blk<_al> );
  400                        	;
  401                        	
  402               0001     		.if	SUPPORT_SGX
  403                        	
  404                        			.proc	_sgx_set_blocks.3
  410                        			.endp
  411                        		.endif
  412                        	
  413    01:C0F6             			.proc	_set_blocks.3
  414                        	
  415    01:C0F6  82         			clx				; Offset to PCE VDC.
  416                        	
  417    01:C0F7  BD 7B 2A   			lda.h	vdc_tbl_addr, x		; Remap the address to MPR2.
  418    01:C0FA  29 1F      			and	#$1F
  419    01:C0FC  09 40      			ora	#$40
  420    01:C0FE  9D 7B 2A   			sta.h	vdc_tbl_addr, x
  421                        	
  422    01:C101  BD 7E 2A   			lda.h	vdc_blk_addr, x		; Remap the address to MPR2.
  423    01:C104  29 1F      			and	#$1F
  424    01:C106  09 40      			ora	#$40
  425    01:C108  9D 7E 2A   			sta.h	vdc_blk_addr, x
  426                        	
  427               0000     		.if	BLKDEF_POINTERS
  479                        		.endif	BLKDEF_POINTERS
  480                        	
  481                        			leave
         01:C10B  4C EF FF   			jmp	leave_proc
  482                        	
  483                        			.endp
  484                        	
  485                        	
  486                        	
  487                        	; ***************************************************************************
  488                        	; ***************************************************************************
  489                        	;
  490                        	; _draw_map - Draw the entire screen at the current coordinates.
  491                        	; _sgx_draw_map - Draw the entire screen at the current coordinates.
  492                        	;
  493                        	; void __fastcall draw_map( void );
  494                        	; void __fastcall sgx_draw_map( void );
  495                        	;
  496                        	
  497               0001     		.if	SUPPORT_SGX
  498                        	
  499    01:C10E             	_sgx_draw_map	.proc
  500                        	
  501    01:C10E  A2 10      			ldx	#SGX_VDC_OFFSET		; Offset to SGX VDC.
  502    01:C110  F0         			db	$F0			; Turn "clx" into a "beq".
  503                        	
  504    01:C111             			.ref	_draw_map
  505                        			.endp
  506                        		.endif
  507                        	
  508    01:C111             	_draw_map	.proc
  509                        	
  510    01:C111  82         			clx				; Offset to PCE VDC.
  511                        	
  512    01:C112  43 04      			tma2				; Preserve MPR2..MPR4.
  513    01:C114  48         			pha
  514    01:C115  43 08      			tma3
  515    01:C117  48         			pha
  516    01:C118  43 10      			tma4
  517    01:C11A  48         			pha
  518               0000     		.if	BLKMAP_LARGEMAP
  521                        		.endif
  522                        	
  523    01:C11B  20 1D C2   			jsr	map_pxl_2_chr		; Set up the draw coordinates.
  524                        	
  525    01:C11E  A5 FC      			lda	<map_chr_x		; Reset previous X position.
  526    01:C120  9D 78 2A   			sta	vdc_old_chr_x, x
  527                        	
  528    01:C123  A5 FE      			lda	<map_chr_y		; Reset previous Y position,
  529    01:C125  1A         			inc	a			; ready to draw multiple rows.
  530    01:C126  9D 79 2A   			sta	vdc_old_chr_y, x
  531                        	
  532    01:C129  BD 41 25   			lda	vdc_map_draw_w, x	; Draw the whole screen.
  533    01:C12C  85 FA      			sta	<map_draw_w
  534    01:C12E  BD 42 25   			lda	vdc_map_draw_h, x
  535    01:C131  85 FB      			sta	<map_draw_h
  536                        	
  537    01:C133  20 73 C4   			jsr	map_scroll_y		; Draw N row of CHR to the BAT.
  538                        	
  539               0000     		.if	BLKMAP_LARGEMAP
  542                        		.endif
  543    01:C136  68         			pla				; Restore MPR2..MPR4.
  544    01:C137  53 10      			tam4
  545    01:C139  68         			pla
  546    01:C13A  53 08      			tam3
  547    01:C13C  68         			pla
  548    01:C13D  53 04      			tam2
  549                        	
  550                        			leave
         01:C13F  4C EF FF   			jmp	leave_proc
  551                        	
  552                        			.endp
  553                        	
  554                        	
  555                        	
  556                        	; ***************************************************************************
  557                        	; ***************************************************************************
  558                        	;
  559                        	; _scroll_map - Draw a single row of CHR into the BAT to update the edge.
  560                        	; _sgx_scroll_map - Draw a single row of CHR into the BAT to update the edge.
  561                        	;
  562                        	; void __fastcall scroll_map( void );
  563                        	; void __fastcall sgx_scroll_map( void );
  564                        	;
  565                        	
  566               0001     		.if	SUPPORT_SGX
  567                        	
  568    01:C142             	_sgx_scroll_map	.proc
  569                        	
  570    01:C142  A2 10      			ldx	#SGX_VDC_OFFSET		; Offset to SGX VDC.
  571    01:C144  F0         			db	$F0			; Turn "clx" into a "beq".
  572                        	
  573    01:C145             			.ref	_scroll_map
  574                        			.endp
  575                        		.endif
  576                        	
  577    01:C145             	_scroll_map	.proc
  578                        	
  579    01:C145  82         			clx				; Offset to PCE VDC.
  580                        	
  581               0000     		.if	BLKMAP_TIMETEST
  587                        		.endif
  588                        	
  589    01:C146  43 04      			tma2				; Preserve MPR2..MPR4.
  590    01:C148  48         			pha
  591    01:C149  43 08      			tma3
  592    01:C14B  48         			pha
  593    01:C14C  43 10      			tma4
  594    01:C14E  48         			pha
  595               0000     		.if	BLKMAP_LARGEMAP
  598                        		.endif
  599                        	
  600    01:C14F  20 1D C2   			jsr	map_pxl_2_chr		; Set up the draw coordinates.
  601                        	
  602               0001     		.if	BLKMAP_MULTISCR
  603    01:C152  A5 FD      			lda	<map_scrn_x		; map_scroll_x can change this!
  604    01:C154  48         			pha
  605                        		.endif
  606                        	
  607    01:C155  BD 42 25   			lda	vdc_map_draw_h, x	; Draw new LHS or RHS if needed.
  608    01:C158  85 FB      			sta	<map_draw_h
  609                        	;		lda	#1			; map_scroll_x only ever draws a
  610                        	;		sta	<map_draw_w		; single column.
  611    01:C15A  20 54 C3   			jsr	map_scroll_x
  612                        	
  613    01:C15D  BD 78 2A   			lda	vdc_old_chr_x, x	; Restore map_chr_x which could
  614    01:C160  85 FC      			sta	<map_chr_x		; be changed by map_scroll_x.
  615                        	
  616               0001     		.if	BLKMAP_MULTISCR
  617    01:C162  68         			pla				; Restore before map_scroll_y.
  618    01:C163  85 FD      			sta	<map_scrn_x
  619                        		.endif
  620                        	
  621    01:C165  BD 41 25   			lda	vdc_map_draw_w, x	; Draw new TOP or BTM if needed.
  622    01:C168  85 FA      			sta	<map_draw_w
  623    01:C16A  A9 01      			lda	#1
  624    01:C16C  85 FB      			sta	<map_draw_h
  625    01:C16E  20 73 C4   			jsr	map_scroll_y
  626                        	
  627               0000     		.if	BLKMAP_LARGEMAP
  630                        		.endif
  631    01:C171  68         			pla				; Restore MPR2..MPR4.
  632    01:C172  53 10      			tam4
  633    01:C174  68         			pla
  634    01:C175  53 08      			tam3
  635    01:C177  68         			pla
  636    01:C178  53 04      			tam2
  637                        	
  638               0000     		.if	BLKMAP_TIMETEST
  640                        		.endif
  641                        	
  642                        			leave
         01:C17A  4C EF FF   			jmp	leave_proc
  643                        	
  644                        			.endp
  645                        	
  646                        	
  647                        	
  648                        	; ***************************************************************************
  649                        	; ***************************************************************************
  650                        	;
  651                        	; _blit_map - Draw a map rectangle to specific BAT coordinates.
  652                        	; _sgx_blit_map - Draw a map rectangle to specific BAT coordinates.
  653                        	;
  654                        	; void __fastcall blit_map( unsigned char tile_x<map_bat_x>, unsigned char tile_y<map_bat_y>, unsigned char tile_w<map_draw_x>, unsigned char tile_h<map_draw_y> );
  655                        	; void __fastcall sgx_blit_map( unsigned char tile_x<map_bat_x>, unsigned char tile_y<map_bat_y>, unsigned char tile_w<map_draw_x>, unsigned char tile_h<map_draw_y> );
  656                        	;
  657                        	; Normally you'd just use _draw_map() and _scroll_map(), but for those folks
  658                        	; who really wish to take manual control, you can use this.
  659                        	;
  660                        	
  661               0001     		.if	SUPPORT_SGX
  662                        	
  663                        	_sgx_blit_map	.proc
  669                        			.endp
  670                        		.endif
  671                        	
  672    01:C17D             	_blit_map	.proc
  673                        	
  674    01:C17D  82         			clx				; Offset to PCE VDC.
  675                        	
  676    01:C17E  BD 85 2A   			lda	vdc_scr_bank, x		; Skip this if a multi-screen
  677    01:C181  D0 36      			bne	.exit			; blkmap.
  678                        	
  679    01:C183  43 04      			tma2				; Preserve MPR2..MPR4.
  680    01:C185  48         			pha
  681    01:C186  43 08      			tma3
  682    01:C188  48         			pha
  683    01:C189  43 10      			tma4
  684    01:C18B  48         			pha
  685               0000     		.if	BLKMAP_LARGEMAP
  688                        		.endif
  689                        	
  690    01:C18C  BD 49 25   			lda	vdc_map_option, x	; Preserve current map options.
  691    01:C18F  48         			pha
  692    01:C190  09 C0      			ora	#MAP_UNALIGNED_X | MAP_UNALIGNED_Y
  693    01:C192  9D 49 25   			sta	vdc_map_option, x
  694                        	
  695    01:C195  20 1D C2   			jsr	map_pxl_2_chr		; Set up the draw coordinates.
  696                        	
  697    01:C198  A5 FA      			lda	<map_draw_w		; Are we drawing just 1 column?
  698    01:C19A  C9 01      			cmp	#1
  699    01:C19C  F0 1E      			beq	.draw_column
  700                        	
  701                        			; Draw N rows.
  702                        	
  703    01:C19E  A5 FC      	.draw_rows:	lda	<map_chr_x		; Reset previous X position.
  704    01:C1A0  9D 78 2A   			sta	vdc_old_chr_x, x
  705                        	
  706    01:C1A3  A5 FE      			lda	<map_chr_y		; Reset previous Y position,
  707    01:C1A5  1A         			inc	a			; ready to draw rows upwards.
  708    01:C1A6  9D 79 2A   			sta	vdc_old_chr_y, x
  709                        	
  710    01:C1A9  20 73 C4   			jsr	map_scroll_y		; Draw a row of CHR to the BAT.
  711                        	
  712                        			; Drawing completed.
  713                        	
  714    01:C1AC  68         	.finished:	pla				; Restore previous map options.
  715    01:C1AD  9D 49 25   			sta	vdc_map_option, x
  716                        	
  717               0000     		.if	BLKMAP_LARGEMAP
  720                        		.endif
  721    01:C1B0  68         			pla				; Restore MPR2..MPR4.
  722    01:C1B1  53 10      			tam4
  723    01:C1B3  68         			pla
  724    01:C1B4  53 08      			tam3
  725    01:C1B6  68         			pla
  726    01:C1B7  53 04      			tam2
  727                        	
  728                        	.exit:		leave
         01:C1B9  4C EF FF   			jmp	leave_proc
  729                        	
  730                        			; Draw 1 column.
  731                        	
  732    01:C1BC  A5 FC      	.draw_column:	lda	<map_chr_x		; Reset previous X position.
  733    01:C1BE  1A         			inc	a			; ready to draw 1 column.
  734    01:C1BF  9D 78 2A   			sta	vdc_old_chr_x, x
  735                        	
  736    01:C1C2  A5 FE      			lda	<map_chr_y		; Reset previous Y position.
  737    01:C1C4  9D 79 2A   			sta	vdc_old_chr_y, x
  738                        	
  739    01:C1C7  20 54 C3   			jsr	map_scroll_x		; Draw a single column of CHR.
  740                        	
  741    01:C1CA  80 E0      			bra	.finished
  742                        	
  743                        			.endp
  744                        	
  745                        	
  746                        	
  747                        	; ***************************************************************************
  748                        	; ***************************************************************************
  749                        	;
  750                        	; _get_map_block - Get the block number used at a map pixel coordinate.
  751                        	; _sgx_get_map_block - Get the block number used at a map pixel coordinate.
  752                        	;
  753                        	; unsigned char __fastcall _get_map_block( unsigned int x<map_pxl_x>, unsigned int y<map_pxl_y> );
  754                        	; unsigned char __fastcall _sgx_get_map_block( unsigned int x<map_pxl_x>, unsigned int y<map_pxl_y> );
  755                        	;
  756                        	
  757               0001     		.if	SUPPORT_SGX
  758                        	
  759                        			.proc	_sgx_get_map_block.2
  765                        			.endp
  766                        		.endif
  767                        	
  768    01:C1CC             			.proc	_get_map_block.2
  769                        	
  770    01:C1CC  82         			clx				; Offset to PCE VDC.
  771                        	
  772    01:C1CD  43 04      			tma2				; Preserve MPR2..MPR4.
  773    01:C1CF  48         			pha
  774    01:C1D0  43 08      			tma3
  775    01:C1D2  48         			pha
  776    01:C1D3  43 10      			tma4
  777    01:C1D5  48         			pha
  778               0000     		.if	BLKMAP_LARGEMAP
  781                        		.endif
  782                        	
  783    01:C1D6  20 31 C2   			jsr	xvt_pxl_2_chr		; Set up the query coordinates.
  784                        	
  785    01:C1D9  20 5F C2   			jsr	map_chr_2_data		; Page in the map address.
  786                        	
  787    01:C1DC  B2 EC      			lda	[_bp]			; Read the BLK from the map.
  788    01:C1DE  A8         			tay
  789                        	
  790    01:C1DF  A5 FC      			lda	<map_chr_x		; Calc the BLK address offset
  791    01:C1E1  4A         			lsr	a			; use depending upon even/odd
  792    01:C1E2  A5 FE      			lda	<map_chr_y		; CHR coordinates (not BAT to
  793    01:C1E4  29 01      			and	#1			; support unaligned drawing).
  794    01:C1E6  2A         			rol	a
  795    01:C1E7  09 04      			ora	#4			; Offset to BLK table top byte.
  796    01:C1E9  7D 7E 2A   			adc.h	vdc_blk_addr, x		; What is the BLK data address?
  797    01:C1EC  85 ED      			sta.h	<_bp			; $4000, $4800, $5000 or $5800.
  798    01:C1EE  64 EC      			stz.l	<_bp
  799    01:C1F0  B1 EC      			lda	[_bp], y		; Read the collision flags from
  800    01:C1F2  29 0C      			and	#%00001100		; the top byte of the CHR.
  801    01:C1F4  4A         			lsr	a
  802    01:C1F5  4A         			lsr	a
  803    01:C1F6  4A         			lsr	a			; Swizzle the bottom bit to get
  804    01:C1F7  90 02      			bcc	!+			; the same bit order as used in
  805    01:C1F9  09 02      			ora	#2			; .HALTMAP layer.
  806    01:C1FB  8D 76 2A   	!:		sta	map_blk_flag
  807                        	
  808    01:C1FE  BD 7C 2A   			lda	vdc_tbl_bank, x		; Is there a table of flags?
  809    01:C201  F0 09      			beq	!+
  810    01:C203  53 08      			tam3
  811                        	;		inc	a
  812                        	;		tam4
  813                        	;		lda.l	vdc_tbl_addr, x
  814                        	;		sta.l	<_bp
  815    01:C205  BD 7B 2A   			lda.h	vdc_tbl_addr, x		; If so, it must be aligned!
  816    01:C208  85 ED      			sta.h	<_bp
  817    01:C20A  B1 EC      			lda	[_bp], y		; Read the .MASKMAP/.OVERMAP
  818    01:C20C  8D 77 2A   	!:		sta	map_blk_mask		; flag value for this BLK.
  819                        	
  820               0000     		.if	BLKMAP_LARGEMAP
  823                        		.endif
  824    01:C20F  68         			pla				; Restore MPR2..MPR4.
  825    01:C210  53 10      			tam4
  826    01:C212  68         			pla
  827    01:C213  53 08      			tam3
  828    01:C215  68         			pla
  829    01:C216  53 04      			tam2
  830                        	
  831    01:C218  02         			sxy				; Put the BLK number in X.
  832    01:C219  C2         			cly
  833                        	
  834                        			leave				; All done!
         01:C21A  4C EF FF   			jmp	leave_proc
  835                        	
  836                        			.endp
  837                        	
  838                        	
  839                        	
  840                        	; ***************************************************************************
  841                        	; ***************************************************************************
  842                        	;
  843                        	; map_pxl_2_chr - Convert PXL to CHR, BLK and SCR coordinates.
  844                        	;
  845                        	
  846    01:C21D  BD 47 25   	map_pxl_2_chr:	lda.l	vdc_map_pxl_y, x	; Get current map Y coordinate.
  847    01:C220  85 FE      			sta.l	<map_pxl_y
  848    01:C222  BD 48 25   			lda.h	vdc_map_pxl_y, x
  849    01:C225  85 FF      			sta.h	<map_pxl_y
  850                        	
  851    01:C227  BD 45 25   			lda.l	vdc_map_pxl_x, x	; Get current map X coordinate.
  852    01:C22A  85 FC      			sta.l	<map_pxl_x
  853    01:C22C  BD 46 25   			lda.h	vdc_map_pxl_x, x
  854    01:C22F  85 FD      			sta.h	<map_pxl_x
  855                        	
  856    01:C231  A5 FD      	xvt_pxl_2_chr:	lda.h	<map_pxl_x		; Xvert map_pxl_x to map_chr_x.
  857               0001     		.if	BLKMAP_MULTISCR
  858    01:C233  A8         			tay				; Xvert map_pxl_x to map_scrn_x.
  859    01:C234  3C 3C 25   			bit	vdc_bat_width, x
  860    01:C237  70 03      			bvs	.w64
  861    01:C239  10 02      			bpl	.w32
  862    01:C23B  4A         	.w128:		lsr	a
  863    01:C23C  4A         	.w64:		lsr	a
  864    01:C23D  85 FD      	.w32:		sta	<map_scrn_x
  865    01:C23F  98         			tya
  866                        		.endif
  867    01:C240  4A         			lsr	a
  868    01:C241  66 FC      			ror.l	<map_pxl_x
  869    01:C243  4A         			lsr	a
  870    01:C244  66 FC      			ror.l	<map_pxl_x
  871    01:C246  4A         			lsr	a
  872    01:C247  66 FC      			ror.l	<map_pxl_x		; Max map width is 256 CHR.
  873                        	
  874    01:C249  A5 FF      			lda.h	<map_pxl_y		; Xvert map_pxl_y to map_chr_y.
  875               0001     		.if	BLKMAP_MULTISCR
  876    01:C24B  A8         			tay				; Xvert map_pxl_y to map_scrn_y.
  877    01:C24C  3C 3D 25   			bit	vdc_bat_height, x
  878    01:C24F  50 01      			bvc	.h32
  879    01:C251  4A         	.h64:		lsr	a
  880    01:C252  85 FF      	.h32:		sta	<map_scrn_y
  881    01:C254  98         			tya
  882                        		.endif
  883    01:C255  4A         			lsr	a
  884    01:C256  66 FE      			ror.l	<map_pxl_y
  885    01:C258  4A         			lsr	a
  886    01:C259  66 FE      			ror.l	<map_pxl_y
  887    01:C25B  4A         			lsr	a
  888    01:C25C  66 FE      			ror.l	<map_pxl_y		; Max map width is 256 CHR.
  889                        	
  890    01:C25E  60         			rts
  891                        	
  892                        	
  893                        	
  894                        	; ***************************************************************************
  895                        	; ***************************************************************************
  896                        	;
  897                        	; map_chr_2_data - Page in the MAP address for the CHR coordinates.
  898                        	;
  899                        	
  900    01:C25F             	map_chr_2_data:
  901                        	
  902               0001     		.if	BLKMAP_MULTISCR
  903                        	
  904                        			; Initialization for a multi-screen map.
  905                        	
  906    01:C25F  BD 85 2A   			lda	vdc_scr_bank, x		; Skip this if regular blkmap.
  907    01:C262  F0 3A      			beq	.regular
  908                        	
  909    01:C264  A5 FC      	.multiscreen:	lda	<map_chr_x		; Compare old_x with cur_x.
  910    01:C266  3D 3E 25   			and	vdc_bat_x_mask, x
  911    01:C269  85 F8      			sta	<map_bat_x		; Save BAT X chr coordinate.
  912                        	
  913    01:C26B  A5 FE      			lda	<map_chr_y		; Save BAT Y chr coordinate.
  914    01:C26D  3D 3F 25   			and	vdc_bat_y_mask, x
  915    01:C270  85 F9      			sta	<map_bat_y
  916    01:C272  4A         			lsr	a			; Map BLK Y coordinate.
  917    01:C273  85 EF      			sta.h	<map_line
  918    01:C275  62         			cla
  919    01:C276  3C 3C 25   			bit	vdc_bat_width, x
  920    01:C279  30 08      			bmi	.w128
  921    01:C27B  70 03      			bvs	.w64
  922    01:C27D  46 EF      	.w32:		lsr.h	<map_line
  923    01:C27F  6A         			ror	a
  924    01:C280  46 EF      	.w64:		lsr.h	<map_line
  925    01:C282  6A         			ror	a
  926    01:C283  46 EF      	.w128:		lsr.h	<map_line
  927    01:C285  6A         			ror	a
  928    01:C286  46 EF      			lsr.h	<map_line		; Hi-byte of (BLK Y * width).
  929    01:C288  6A         			ror	a
  930    01:C289  85 EE      			sta.l	<map_line		; Lo-byte of (BLK Y * width).
  931                        	
  932    01:C28B  20 DF C2   			jsr	map_set_screen		; Put BLK & MAP in MPR2-MPR5.
  933                        	
  934    01:C28E  A5 F8      			lda	<map_bat_x		; Calc map data pointer.
  935    01:C290  4A         			lsr	a			; Map BLK X coordinate.
  936    01:C291  05 EE      			ora.l	<map_line
  937    01:C293  85 EC      			sta.l	<_bp
  938    01:C295  A5 EF      			lda.h	<map_line
  939    01:C297  18         			clc
  940    01:C298  7D 81 2A   			adc.h	vdc_map_addr, x		; N.B. 256-byte aligned!
  941    01:C29B  85 ED      			sta.h	<_bp
  942                        	
  943    01:C29D  60         			rts
  944                        	
  945                        		.endif	BLKMAP_MULTISCR
  946                        	
  947                        			; Initialization for a regular map.
  948                        	
  949    01:C29E  A5 FC      	.regular:	lda	<map_chr_x		; Compare old_x with cur_x.
  950                        	;		bit	vdc_map_option, x	; Set bit7 to disable aligning
  951                        	;		bmi	!+			; BAT X with the map X.
  952    01:C2A0  3D 3E 25   			and	vdc_bat_x_mask, x
  953    01:C2A3  85 F8      			sta	<map_bat_x		; Save BAT X chr coordinate.
  954                        	
  955    01:C2A5  A5 FE      	!:		lda	<map_chr_y		; A = map CHR Y coordinate.
  956    01:C2A7  A8         			tay
  957    01:C2A8  4A         			lsr	a
  958    01:C2A9  42         			say				; Y = map BLK Y coordinate.
  959                        	
  960                        	;		bit	vdc_map_option, x	; Set bit6 to disable aligning
  961                        	;		bvs	!+			; BAT Y with the map Y.
  962    01:C2AA  3D 3F 25   			and	vdc_bat_y_mask, x
  963    01:C2AD  85 F9      			sta	<map_bat_y		; Save BAT Y chr coordinate.
  964                        	
  965               0000     		.if	BLKMAP_LARGEMAP
  970                        		.endif
  971                        	
  972    01:C2AF  BD 43 25   	!:		lda	vdc_map_line_w, x	; Map width in BLK.
  973               0000     		.if	FAST_MULTIPLY
  986                        		.else
  987    01:C2B2  84 EF      			sty.h	<map_line		; Takes 144..176 cycles.
  988    01:C2B4  A0 08      			ldy	#8
  989    01:C2B6  4A         			lsr	a
  990    01:C2B7  85 EE      			sta.l	<map_line
  991    01:C2B9  62         			cla
  992    01:C2BA  90 03      			bcc	.rotate
  993    01:C2BC  18         	.add:		clc
  994    01:C2BD  65 EF      			adc.h	<map_line
  995    01:C2BF  6A         	.rotate:	ror	a
  996    01:C2C0  66 EE      			ror.l	<map_line		; Lo-byte of (BLK Y * width).
  997    01:C2C2  88         			dey
  998    01:C2C3  B0 F7      			bcs	.add
  999    01:C2C5  D0 F8      			bne	.rotate
 1000    01:C2C7  A8         			tay				; Hi-byte of (BLK Y * width).
 1001                        		.endif
 1002                        	
 1003    01:C2C8  A5 FC      	!:		lda	<map_chr_x		; Map CHR X coordinate.
 1004    01:C2CA  4A         			lsr	a			; Map BLK X coordinate.
 1005    01:C2CB  18         			clc
 1006    01:C2CC  65 EE      			adc.l	<map_line		; Lo-byte of (BLK Y * width).
 1007    01:C2CE  90 01      			bcc	!+
 1008    01:C2D0  C8         			iny				; Hi-byte of (BLK Y * width).
 1009                        	
 1010    01:C2D1  18         	!:		clc				; Calc map data pointer.
 1011    01:C2D2  7D 80 2A   			adc.l	vdc_map_addr, x
 1012    01:C2D5  85 EC      			sta.l	<_bp			; Maximum map size is 16KBytes
 1013    01:C2D7  98         			tya				; so we don't need to consider
 1014    01:C2D8  7D 81 2A   			adc.h	vdc_map_addr, x		; bank overflow.
 1015    01:C2DB  85 ED      			sta.h	<_bp
 1016                        	
 1017    01:C2DD  80 66      			bra	map_set_banks		; Put BLK & MAP in MPR2-MPR5.
 1018                        	
 1019                        	
 1020                        	
 1021               0001     		.if	BLKMAP_MULTISCR
 1022                        	
 1023                        	; ***************************************************************************
 1024                        	; ***************************************************************************
 1025                        	;
 1026                        	; map_set_screen -
 1027                        	;
 1028                        	; Maximum X and Y dimension of 128 screens (32768 pixels).
 1029                        	; Maximum 8KByte total size of screen data (1024 screens).
 1030                        	;
 1031                        	
 1032    01:C2DF  A4 FF      	map_set_screen:	ldy	<map_scrn_y		; Map SCR Y coordinate.
 1033    01:C2E1  BD 44 25   			lda	vdc_map_scrn_w, x	; Map width in SCREENS.
 1034                        	
 1035               0000     		.if	FAST_MULTIPLY
 1048                        		.else
 1049    01:C2E4  84 ED      			sty.h	<_bp			; Takes 144..176 cycles.
 1050    01:C2E6  A0 08      			ldy	#8
 1051    01:C2E8  4A         			lsr	a
 1052    01:C2E9  85 EC      			sta.l	<_bp
 1053    01:C2EB  62         			cla
 1054    01:C2EC  90 03      			bcc	.rotate
 1055    01:C2EE  18         	.add:		clc
 1056    01:C2EF  65 ED      			adc.h	<_bp
 1057    01:C2F1  6A         	.rotate:	ror	a
 1058    01:C2F2  66 EC      			ror.l	<_bp			; Lo-byte of (SCR Y * width).
 1059    01:C2F4  88         			dey
 1060    01:C2F5  B0 F7      			bcs	.add
 1061    01:C2F7  D0 F8      			bne	.rotate
 1062    01:C2F9  A8         			tay				; Hi-byte of (SCR Y * width).
 1063                        		.endif
 1064                        	
 1065    01:C2FA  A5 FD      			lda	<map_scrn_x		; Map SCR X coordinate.
 1066    01:C2FC  18         			clc
 1067    01:C2FD  65 EC      			adc.l	<_bp
 1068    01:C2FF  90 01      			bcc	!+
 1069    01:C301  C8         			iny
 1070                        	
 1071    01:C302  84 ED      	!:		sty.h	<_bp			; 2 bytes per screen entry, max
 1072    01:C304  0A         			asl	a			; 8KByte screen table.
 1073    01:C305  26 ED      			rol.h	<_bp
 1074               0001     		.if	BLKDEF_POINTERS == 0
 1075    01:C307  0A         			asl	a			; 8 bytes per screen entry when
 1076    01:C308  26 ED      			rol.h	<_bp			; not using BLK pointers.
 1077    01:C30A  0A         			asl	a
 1078    01:C30B  26 ED      			rol.h	<_bp
 1079                        		.endif
 1080                        	
 1081    01:C30D  7D 83 2A   			adc.l	vdc_scr_addr, x		; Calc screen data pointer.
 1082    01:C310  85 EC      			sta.l	<_bp			; Maximum data size is 8KBytes
 1083    01:C312  A5 ED      			lda.h	<_bp			; so we don't need to consider
 1084    01:C314  7D 84 2A   			adc.h	vdc_scr_addr, x		; bank overflow.
 1085    01:C317  85 ED      			sta.h	<_bp
 1086                        	
 1087    01:C319  BD 85 2A   			lda	vdc_scr_bank, x		; Map the SCR data in MPR3..MPR4.
 1088    01:C31C  53 08      			tam3
 1089    01:C31E  1A         			inc	a
 1090    01:C31F  53 10      			tam4
 1091                        	
 1092    01:C321  C2         			cly
 1093    01:C322  B1 EC      			lda	[_bp], y		; Get SCR_MAP_PAGE.
 1094    01:C324  9D 81 2A   			sta.h	vdc_map_addr, x
 1095    01:C327  C8         			iny
 1096    01:C328  B1 EC      			lda	[_bp], y		; Get SCR_MAP_BANK.
 1097    01:C32A  9D 82 2A   			sta	vdc_map_bank, x
 1098                        	
 1099               0001     		.if	BLKDEF_POINTERS == 0
 1100    01:C32D  C8         			iny
 1101    01:C32E  B1 EC      			lda	[_bp], y		; Get SCR_BLK_PAGE.
 1102    01:C330  9D 7E 2A   			sta.h	vdc_blk_addr, x
 1103    01:C333  C8         			iny
 1104    01:C334  B1 EC      			lda	[_bp], y		; Get SCR_BLK_BANK.
 1105    01:C336  9D 7F 2A   			sta	vdc_blk_bank, x
 1106    01:C339  C8         			iny
 1107    01:C33A  B1 EC      			lda	[_bp], y		; Get SCR_TBL_PAGE.
 1108    01:C33C  9D 7B 2A   			sta.h	vdc_tbl_addr, x
 1109    01:C33F  C8         			iny
 1110    01:C340  B1 EC      			lda	[_bp], y		; Get SCR_TBL_BANK.
 1111    01:C342  9D 7C 2A   			sta	vdc_tbl_bank, x
 1112               0000     		.if	0				; These are not currently used.
 1119                        		.endif
 1120                        		.endif
 1121                        	
 1122                        	;		lda	vdc_bat_width, x	; Set up the map width.
 1123                        	;		lsr	a			; This should have been set
 1124                        	;		sta	vdc_map_line_w, x	; with the multi-screen map.
 1125                        	
 1126                        	;		jmp	map_set_banks		; Put BLK & MAP in MPR2-MPR5.
 1127                        	
 1128                        			; Fall through to map_set_banks.
 1129                        	
 1130                        		.endif	BLKMAP_MULTISCR
 1131                        	
 1132                        	
 1133                        	
 1134                        	; ***************************************************************************
 1135                        	; ***************************************************************************
 1136                        	;
 1137                        	; map_set_banks - Put BLK & MAP in MPR2-MPR5.
 1138                        	;
 1139                        	
 1140    01:C345  BD 7F 2A   	map_set_banks:	lda	vdc_blk_bank, x		; Put the BLK into MPR2.
 1141    01:C348  53 04      			tam2
 1142                        	
 1143    01:C34A  BD 82 2A   			lda	vdc_map_bank, x		; Put the MAP into MPR3-MPR5.
 1144    01:C34D  53 08      			tam3
 1145    01:C34F  1A         			inc	a
 1146    01:C350  53 10      			tam4
 1147               0000     		.if	BLKMAP_LARGEMAP
 1156                        		.endif
 1157                        	
 1158    01:C352  60         	!:		rts
 1159                        	
 1160                        	
 1161                        	
 1162                        	; ***************************************************************************
 1163                        	; ***************************************************************************
 1164                        	;
 1165                        	; map_scroll_x - Update the BAT when X coordinate changes.
 1166                        	;
 1167                        	; N.B. This will alter map_chr_x and map_scrn_x if moved in +ve direction!
 1168                        	;
 1169                        	; N.B. This only ever draws a single column!
 1170                        	;
 1171                        	
 1172    01:C353  60         	!no_change:	rts
 1173                        	
 1174    01:C354             	map_scroll_x:
 1175                        	
 1176               0001     		.if	BLKMAP_MULTISCR
 1177                        	
 1178                        			; Initialization for a multi-screen map.
 1179                        	
 1180    01:C354  BD 85 2A   			lda	vdc_scr_bank, x		; Skip this if regular blkmap.
 1181    01:C357  F0 56      			beq	.regular
 1182                        	
 1183    01:C359  A5 FC      	.multiscreen:	lda	<map_chr_x		; Compare old_x with cur_x.
 1184    01:C35B  DD 78 2A   			cmp	vdc_old_chr_x, x
 1185               0001     		.if	BLKMAP_TIMETEST == 0
 1186    01:C35E  F0 F3      			beq	!no_change-		; Do nothing if no change.
 1187                        		.endif
 1188    01:C360  9D 78 2A   			sta	vdc_old_chr_x, x
 1189    01:C363  30 11      			bmi	!+			; Test the sign of the change.
 1190                        	
 1191    01:C365  18         			clc				; Draw RHS if chr_x >= old_x.
 1192    01:C366  3D 3E 25   			and	vdc_bat_x_mask, x
 1193    01:C369  7D 41 25   			adc	vdc_map_draw_w, x	; Usually (SCR_WIDTH / 8) + 1.
 1194    01:C36C  3A         			dec	a
 1195    01:C36D  85 FC      			sta	<map_chr_x		; Update CHR X chr coordinate.
 1196    01:C36F  3C 3C 25   			bit	vdc_bat_width, x
 1197    01:C372  F0 02      			beq	!+
 1198    01:C374  E6 FD      			inc	<map_scrn_x		; Wrapped to the next screen.
 1199                        	
 1200    01:C376  3D 3E 25   	!:		and	vdc_bat_x_mask, x
 1201    01:C379  85 F8      			sta	<map_bat_x		; Save BAT X chr coordinate.
 1202                        	
 1203    01:C37B  A5 FE      			lda	<map_chr_y		; Save BAT Y chr coordinate.
 1204    01:C37D  3D 3F 25   			and	vdc_bat_y_mask, x
 1205    01:C380  85 F9      			sta	<map_bat_y
 1206    01:C382  4A         			lsr	a			; Map BLK Y coordinate.
 1207    01:C383  85 EF      			sta.h	<map_line
 1208    01:C385  62         			cla
 1209    01:C386  3C 3C 25   			bit	vdc_bat_width, x
 1210    01:C389  30 08      			bmi	.w128
 1211    01:C38B  70 03      			bvs	.w64
 1212    01:C38D  46 EF      	.w32:		lsr.h	<map_line
 1213    01:C38F  6A         			ror	a
 1214    01:C390  46 EF      	.w64:		lsr.h	<map_line
 1215    01:C392  6A         			ror	a
 1216    01:C393  46 EF      	.w128:		lsr.h	<map_line
 1217    01:C395  6A         			ror	a
 1218    01:C396  46 EF      			lsr.h	<map_line		; Hi-byte of (BLK Y * width).
 1219    01:C398  6A         			ror	a
 1220    01:C399  85 EE      			sta.l	<map_line		; Lo-byte of (BLK Y * width).
 1221                        	
 1222    01:C39B  20 DF C2   			jsr	map_set_screen		; Put BLK & MAP in MPR2-MPR5.
 1223                        	
 1224    01:C39E  A5 F8      			lda	<map_bat_x		; Calc map data pointer.
 1225    01:C3A0  4A         			lsr	a			; Map BLK X coordinate.
 1226    01:C3A1  05 EE      			ora.l	<map_line
 1227    01:C3A3  85 EC      			sta.l	<_bp
 1228    01:C3A5  A5 EF      			lda.h	<map_line
 1229    01:C3A7  18         			clc
 1230    01:C3A8  7D 81 2A   			adc.h	vdc_map_addr, x		; N.B. 256-byte aligned!
 1231    01:C3AB  85 ED      			sta.h	<_bp
 1232                        	
 1233    01:C3AD  80 5D      			bra	.draw_col		; Now draw it.
 1234                        	
 1235                        		.endif	BLKMAP_MULTISCR
 1236                        	
 1237                        			; Initialization for a regular map.
 1238                        	
 1239    01:C3AF  A5 FC      	.regular:	lda	<map_chr_x		; Compare old_x with cur_x.
 1240    01:C3B1  DD 78 2A   			cmp	vdc_old_chr_x, x
 1241               0001     		.if	BLKMAP_TIMETEST == 0
 1242    01:C3B4  F0 9D      			beq	!no_change-		; Do nothing if no change.
 1243                        		.endif
 1244    01:C3B6  9D 78 2A   			sta	vdc_old_chr_x, x
 1245    01:C3B9  30 07      			bmi	!+			; Test the sign of the change.
 1246                        	
 1247    01:C3BB  18         			clc				; Draw RHS if chr_x >= old_x.
 1248    01:C3BC  7D 41 25   			adc	vdc_map_draw_w, x	; Usually (SCR_WIDTH / 8) + 1.
 1249    01:C3BF  3A         			dec	a
 1250    01:C3C0  85 FC      			sta	<map_chr_x		; Update CHR X chr coordinate.
 1251                        	
 1252    01:C3C2  3C 49 25   	!:		bit	vdc_map_option, x	; Set bit7 to disable aligning
 1253    01:C3C5  30 05      			bmi	!+			; BAT X with the map X.
 1254    01:C3C7  3D 3E 25   			and	vdc_bat_x_mask, x
 1255    01:C3CA  85 F8      			sta	<map_bat_x		; Save BAT X chr coordinate.
 1256                        	
 1257    01:C3CC  A5 FE      	!:		lda	<map_chr_y		; A = map CHR Y coordinate.
 1258    01:C3CE  A8         			tay
 1259    01:C3CF  4A         			lsr	a
 1260    01:C3D0  42         			say				; Y = map BLK Y coordinate.
 1261                        	
 1262    01:C3D1  3C 49 25   			bit	vdc_map_option, x	; Set bit6 to disable aligning
 1263    01:C3D4  70 05      			bvs	!+			; BAT Y with the map Y.
 1264    01:C3D6  3D 3F 25   			and	vdc_bat_y_mask, x
 1265    01:C3D9  85 F9      			sta	<map_bat_y		; Save BAT Y chr coordinate.
 1266                        	
 1267               0000     		.if	BLKMAP_LARGEMAP
 1272                        		.endif
 1273                        	
 1274    01:C3DB  BD 43 25   	!:		lda	vdc_map_line_w, x	; Map width in BLK.
 1275               0000     		.if	FAST_MULTIPLY
 1288                        		.else
 1289    01:C3DE  84 EF      			sty.h	<map_line		; Takes 144..176 cycles.
 1290    01:C3E0  A0 08      			ldy	#8
 1291    01:C3E2  4A         			lsr	a
 1292    01:C3E3  85 EE      			sta.l	<map_line
 1293    01:C3E5  62         			cla
 1294    01:C3E6  90 03      			bcc	.rotate
 1295    01:C3E8  18         	.add:		clc
 1296    01:C3E9  65 EF      			adc.h	<map_line
 1297    01:C3EB  6A         	.rotate:	ror	a
 1298    01:C3EC  66 EE      			ror.l	<map_line		; Lo-byte of (BLK Y * width).
 1299    01:C3EE  88         			dey
 1300    01:C3EF  B0 F7      			bcs	.add
 1301    01:C3F1  D0 F8      			bne	.rotate
 1302    01:C3F3  A8         			tay				; Hi-byte of (BLK Y * width).
 1303                        		.endif
 1304                        	
 1305    01:C3F4  A5 FC      	!:		lda	<map_chr_x		; Map CHR X coordinate.
 1306    01:C3F6  4A         			lsr	a			; Map BLK X coordinate.
 1307    01:C3F7  18         			clc
 1308    01:C3F8  65 EE      			adc.l	<map_line		; Lo-byte of (BLK Y * width).
 1309    01:C3FA  90 01      			bcc	!+
 1310    01:C3FC  C8         			iny				; Hi-byte of (BLK Y * width).
 1311                        	
 1312    01:C3FD  18         	!:		clc				; Calc map data pointer.
 1313    01:C3FE  7D 80 2A   			adc.l	vdc_map_addr, x
 1314    01:C401  85 EC      			sta.l	<_bp			; Maximum map size is 16KBytes
 1315    01:C403  98         			tya				; so we don't need to consider
 1316    01:C404  7D 81 2A   			adc.h	vdc_map_addr, x		; bank overflow.
 1317    01:C407  85 ED      			sta.h	<_bp
 1318                        	
 1319    01:C409  20 45 C3   			jsr	map_set_banks		; Put BLK & MAP in MPR2-MPR5.
 1320                        	
 1321                        			; Draw the first part of the column.
 1322                        	
 1323    01:C40C  A5 F8      	.draw_col:	lda	<map_bat_x		; Set the BAT VRAM destination
 1324    01:C40E  85 F0      			sta.l	<_di			; coordinates.
 1325    01:C410  A5 F9      			lda	<map_bat_y
 1326    01:C412  85 F1      			sta.h	<_di
 1327                        	
 1328    01:C414  5D 3F 25   			eor	vdc_bat_y_mask, x	; Calc CHR before wrap.
 1329    01:C417  1A         			inc	a
 1330    01:C418  DD 42 25   			cmp	vdc_map_draw_h, x	; Usually (SCR_HEIGHT / 8) + 1.
 1331    01:C41B  90 03      			bcc	!+
 1332    01:C41D  BD 42 25   			lda	vdc_map_draw_h, x	; Maximum CHR to draw.
 1333    01:C420  85 00      	!:		sta	<map_count		; Set number of CHR to draw.
 1334    01:C422  85 01      			sta	<map_drawn		; Preserve number of CHR drawn.
 1335                        	
 1336    01:C424  A9 05      			lda	#VDC_CR			; Set VDC auto-increment from
 1337    01:C426  95 F7      			sta	<vdc_reg, x		; the BAT width, which is set
 1338    01:C428  9D 00 02   			sta	VDC_AR, x		; up by set_screen_size().
 1339    01:C42B  B5 F4      			lda	<vdc_crh, x
 1340    01:C42D  9D 03 02   			sta	VDC_DH, x
 1341                        	
 1342    01:C430  20 72 C7   			jsr	blk_col_strip		; Draw top of vertical strip.
 1343                        	
 1344                        			; Wrap around and draw the rest of the column (if needed).
 1345                        	
 1346    01:C433  38         			sec				; Are there any more CHR that
 1347    01:C434  BD 42 25   			lda	vdc_map_draw_h, x	; need to be drawn?
 1348    01:C437  E5 01      			sbc	<map_drawn
 1349    01:C439  F0 2C      			beq	.done
 1350                        	
 1351    01:C43B  85 00      			sta	<map_count		; Set number of CHR to draw.
 1352                        	
 1353    01:C43D  A5 FE      			lda	<map_chr_y		; Update CHR Y coordinate for
 1354    01:C43F  48         			pha				; drawing unaligned tiles.
 1355    01:C440  18         			clc
 1356    01:C441  65 01      			adc	<map_drawn
 1357    01:C443  85 FE      			sta	<map_chr_y
 1358                        	
 1359               0001     		.if	BLKMAP_MULTISCR
 1360    01:C445  BD 85 2A   			lda	vdc_scr_bank, x		; Skip this if regular blkmap.
 1361    01:C448  F0 0F      			beq	!+
 1362                        	
 1363    01:C44A  E6 FF      			inc	<map_scrn_y		; Wrapped to the next screen.
 1364                        	
 1365    01:C44C  20 DF C2   			jsr	map_set_screen		; Put BLK & MAP in MPR2-MPR5.
 1366                        	
 1367    01:C44F  A5 F8      			lda	<map_bat_x		; Calc map data pointer.
 1368    01:C451  4A         			lsr	a			; Map BLK X coordinate.
 1369    01:C452  85 EC      			sta.l	<_bp
 1370    01:C454  BD 81 2A   			lda.h	vdc_map_addr, x		; N.B. 256-byte aligned!
 1371    01:C457  85 ED      			sta.h	<_bp
 1372                        		.endif
 1373                        	
 1374    01:C459  A5 F8      	!:		lda	<map_bat_x		; Set the BAT VRAM destination
 1375    01:C45B  85 F0      			sta.l	<_di			; coordinates.
 1376    01:C45D  64 F1      			stz.h	<_di			; Reset 1st row to draw.
 1377                        	
 1378    01:C45F  20 72 C7   			jsr	blk_col_strip		; Draw btm of vertical strip.
 1379                        	
 1380               0001     		.if	BLKMAP_MULTISCR
 1381    01:C462  C6 FF      			dec	<map_scrn_y		; Restore, no check if should.
 1382                        		.endif
 1383                        	
 1384    01:C464  68         			pla				; Restore CHR Y coordinate, we
 1385    01:C465  85 FE      			sta	<map_chr_y		; might draw another column!
 1386                        	
 1387    01:C467  A9 05      	.done:		lda	#VDC_CR			; Set VDC auto-increment to 1.
 1388    01:C469  95 F7      			sta	<vdc_reg, x
 1389    01:C46B  9D 00 02   			sta	VDC_AR, x
 1390    01:C46E  9E 03 02   			stz	VDC_DH, x
 1391                        	
 1392    01:C471  60         			rts
 1393                        	
 1394                        	
 1395                        	
 1396                        	; ***************************************************************************
 1397                        	; ***************************************************************************
 1398                        	;
 1399                        	; map_scroll_y - Update the BAT when Y coordinate changes.
 1400                        	;
 1401                        	; N.B. This will alter map_chr_y and map_scrn_y if moved in +ve direction!
 1402                        	;
 1403                        	; N.B. This draws multiple rows when called from _draw_map or _blit_map.
 1404                        	;
 1405                        	
 1406    01:C472  60         	!no_change:	rts
 1407                        	
 1408    01:C473             	map_scroll_y:
 1409                        	
 1410               0001     		.if	BLKMAP_MULTISCR
 1411                        	
 1412                        			; Initialization for a multi-screen map.
 1413                        	
 1414    01:C473  BD 85 2A   			lda	vdc_scr_bank, x		; Skip this if regular blkmap.
 1415    01:C476  F0 56      			beq	.regular
 1416                        	
 1417    01:C478  A5 FE      	.multiscr:	lda	<map_chr_y		; Compare old_y with cur_y.
 1418    01:C47A  DD 79 2A   			cmp	vdc_old_chr_y, x
 1419               0001     		.if	BLKMAP_TIMETEST == 0
 1420    01:C47D  F0 F3      			beq	!no_change-		; Do nothing if no change.
 1421                        		.endif
 1422    01:C47F  9D 79 2A   			sta	vdc_old_chr_y, x
 1423    01:C482  30 11      			bmi	!+			; Test the sign of the change.
 1424                        	
 1425    01:C484  18         			clc				; Draw bottom if chr_y >= old_y.
 1426    01:C485  3D 3F 25   			and	vdc_bat_y_mask, x
 1427    01:C488  7D 42 25   			adc	vdc_map_draw_h, x	; Usually (SCR_HEIGHT / 8) + 1.
 1428    01:C48B  3A         			dec	a
 1429    01:C48C  85 FE      			sta	<map_chr_y		; Update CHR Y chr coordinate.
 1430    01:C48E  3C 3D 25   			bit	vdc_bat_height, x
 1431    01:C491  F0 02      			beq	!+
 1432    01:C493  E6 FF      			inc	<map_scrn_y		; Wrapped to the next screen.
 1433                        	
 1434    01:C495  3D 3F 25   	!:		and	vdc_bat_y_mask, x
 1435    01:C498  85 F9      			sta	<map_bat_y		; Save BAT Y chr coordinate.
 1436                        	
 1437    01:C49A  4A         			lsr	a			; Map BLK Y coordinate.
 1438    01:C49B  85 EF      			sta.h	<map_line
 1439    01:C49D  62         			cla
 1440    01:C49E  3C 3C 25   			bit	vdc_bat_width, x
 1441    01:C4A1  30 08      			bmi	.w128
 1442    01:C4A3  70 03      			bvs	.w64
 1443    01:C4A5  46 EF      	.w32:		lsr.h	<map_line
 1444    01:C4A7  6A         			ror	a
 1445    01:C4A8  46 EF      	.w64:		lsr.h	<map_line
 1446    01:C4AA  6A         			ror	a
 1447    01:C4AB  46 EF      	.w128:		lsr.h	<map_line
 1448    01:C4AD  6A         			ror	a
 1449    01:C4AE  46 EF      			lsr.h	<map_line		; Hi-byte of (BLK Y * width).
 1450    01:C4B0  6A         			ror	a
 1451    01:C4B1  85 EE      			sta.l	<map_line		; Lo-byte of (BLK Y * width).
 1452                        	
 1453    01:C4B3  A5 FC      			lda	<map_chr_x
 1454    01:C4B5  3D 3E 25   			and	vdc_bat_x_mask, x
 1455    01:C4B8  85 F8      			sta	<map_bat_x		; Save BAT X chr coordinate.
 1456                        	
 1457                        			; Loop to here if drawing multiple multi-screen rows.
 1458                        	
 1459    01:C4BA  20 DF C2   	.multiscr_row:	jsr	map_set_screen		; Put BLK & MAP in MPR2-MPR5.
 1460                        	
 1461    01:C4BD  A5 F8      			lda	<map_bat_x		; Calc map data pointer.
 1462    01:C4BF  4A         			lsr	a			; Map BLK X coordinate.
 1463    01:C4C0  05 EE      			ora.l	<map_line
 1464    01:C4C2  85 EC      			sta.l	<_bp
 1465    01:C4C4  A5 EF      			lda.h	<map_line
 1466    01:C4C6  18         			clc
 1467    01:C4C7  7D 81 2A   			adc.h	vdc_map_addr, x		; N.B. 256-byte aligned!
 1468    01:C4CA  85 ED      			sta.h	<_bp
 1469                        	
 1470    01:C4CC  80 60      			bra	.draw_row		; Now draw it.
 1471                        	
 1472                        		.endif	BLKMAP_MULTISCR
 1473                        	
 1474                        			; Initialization for a regular blkmap.
 1475                        	
 1476    01:C4CE  A5 FE      	.regular:	lda	<map_chr_y		; Compare old_y with cur_y.
 1477    01:C4D0  DD 79 2A   			cmp	vdc_old_chr_y, x
 1478               0001     		.if	BLKMAP_TIMETEST == 0
 1479    01:C4D3  F0 9D      			beq	!no_change-		; Do nothing if no change.
 1480                        		.endif
 1481    01:C4D5  9D 79 2A   			sta	vdc_old_chr_y, x
 1482    01:C4D8  30 07      			bmi	!+			; Test the sign of the change.
 1483                        	
 1484    01:C4DA  18         			clc				; Draw bottom if chr_y >= old_y.
 1485    01:C4DB  7D 42 25   			adc	vdc_map_draw_h, x	; Usually (SCR_HEIGHT / 8) + 1.
 1486    01:C4DE  3A         			dec	a
 1487    01:C4DF  85 FE      			sta	<map_chr_y		; Update CHR Y chr coordinate.
 1488                        	
 1489    01:C4E1  A8         	!:		tay				; A = map CHR Y coordinate.
 1490    01:C4E2  4A         			lsr	a
 1491    01:C4E3  42         			say				; Y = map BLK Y coordinate.
 1492                        	
 1493    01:C4E4  3C 49 25   			bit	vdc_map_option, x	; Set bit6 to disable aligning
 1494    01:C4E7  70 05      			bvs	!+			; BAT Y with the map Y.
 1495    01:C4E9  3D 3F 25   			and	vdc_bat_y_mask, x
 1496    01:C4EC  85 F9      			sta	<map_bat_y		; Save BAT Y chr coordinate.
 1497                        	
 1498    01:C4EE  3C 49 25   	!:		bit	vdc_map_option, x	; Set bit7 to disable aligning
 1499    01:C4F1  30 07      			bmi	!+			; BAT X with the map X.
 1500    01:C4F3  A5 FC      			lda	<map_chr_x
 1501    01:C4F5  3D 3E 25   			and	vdc_bat_x_mask, x
 1502    01:C4F8  85 F8      			sta	<map_bat_x		; Save BAT X chr coordinate.
 1503    01:C4FA             	!:
 1504                        	
 1505               0000     		.if	BLKMAP_LARGEMAP
 1510                        		.endif
 1511                        	
 1512    01:C4FA  BD 43 25   			lda	vdc_map_line_w, x	; Map width in BLK.
 1513               0000     		.if	FAST_MULTIPLY
 1526                        		.else
 1527    01:C4FD  84 EF      			sty.h	<map_line		; Takes 144..176 cycles.
 1528    01:C4FF  A0 08      			ldy	#8
 1529    01:C501  4A         			lsr	a
 1530    01:C502  85 EE      			sta.l	<map_line
 1531    01:C504  62         			cla
 1532    01:C505  90 03      			bcc	.rotate
 1533    01:C507  18         	.add:		clc
 1534    01:C508  65 EF      			adc.h	<map_line
 1535    01:C50A  6A         	.rotate:	ror	a
 1536    01:C50B  66 EE      			ror.l	<map_line		; Lo-byte of (BLK Y * width).
 1537    01:C50D  88         			dey
 1538    01:C50E  B0 F7      			bcs	.add
 1539    01:C510  D0 F8      			bne	.rotate
 1540    01:C512  85 EF      			sta.h	<map_line		; Hi-byte of (BLK Y * width).
 1541                        		.endif
 1542                        	
 1543    01:C514  20 45 C3   			jsr	map_set_banks		; Put BLK & MAP in MPR2-MPR5.
 1544                        	
 1545                        			; Loop to here if drawing multiple regular blkmap rows.
 1546                        	
 1547    01:C517  A4 EF      	.regular_row:	ldy.h	<map_line		; Hi-byte of (BLK Y * width).
 1548    01:C519  A5 FC      			lda	<map_chr_x		; Map CHR X coordinate.
 1549    01:C51B  4A         			lsr	a			; Map BLK X coordinate.
 1550    01:C51C  18         			clc
 1551    01:C51D  65 EE      			adc.l	<map_line		; Lo-byte of (BLK Y * width).
 1552    01:C51F  90 01      			bcc	!+
 1553    01:C521  C8         			iny
 1554    01:C522  18         	!:		clc				; Calc map data pointer.
 1555    01:C523  7D 80 2A   			adc.l	vdc_map_addr, x
 1556    01:C526  85 EC      			sta.l	<_bp			; Maximum map size is 16KBytes
 1557    01:C528  98         			tya				; so we don't need to consider
 1558    01:C529  7D 81 2A   			adc.h	vdc_map_addr, x		; bank overflow.
 1559    01:C52C  85 ED      			sta.h	<_bp
 1560                        	
 1561                        			; Draw the first part of the row.
 1562                        	
 1563    01:C52E  A5 F9      	.draw_row:	lda	<map_bat_y		; Set the BAT VRAM destination
 1564    01:C530  85 F1      			sta.h	<_di			; coordinates.
 1565    01:C532  A5 F8      			lda	<map_bat_x
 1566    01:C534  85 F0      			sta.l	<_di
 1567                        	
 1568    01:C536  5D 3E 25   			eor	vdc_bat_x_mask, x	; Calc CHR before wrap.
 1569    01:C539  1A         			inc	a
 1570    01:C53A  C5 FA      			cmp	<map_draw_w		; Usually (SCR_WIDTH / 8) + 1.
 1571    01:C53C  90 02      			bcc	!+
 1572    01:C53E  A5 FA      			lda	<map_draw_w		; Maximum CHR to draw.
 1573    01:C540  85 00      	!:		sta	<map_count		; Set number of CHR to draw.
 1574    01:C542  85 01      			sta	<map_drawn		; Preserve number of CHR drawn.
 1575                        	
 1576    01:C544  20 B4 C5   			jsr	blk_row_strip		; Draw lhs of horizontal strip.
 1577                        	
 1578                        			; Wrap around and draw the rest of the row (if needed).
 1579                        	
 1580    01:C547  38         			sec				; Are there any more CHR that
 1581    01:C548  A5 FA      			lda	<map_draw_w		; need to be drawn?
 1582    01:C54A  E5 01      			sbc	<map_drawn
 1583    01:C54C  F0 2E      			beq	.done_row
 1584                        	
 1585    01:C54E  85 00      			sta	<map_count		; Set number of CHR to draw.
 1586                        	
 1587    01:C550  A5 FC      			lda	<map_chr_x		; Update CHR X coordinate for
 1588    01:C552  48         			pha				; drawing unaligned tiles.
 1589    01:C553  18         			clc
 1590    01:C554  65 01      			adc	<map_drawn
 1591    01:C556  85 FC      			sta	<map_chr_x
 1592                        	
 1593               0001     		.if	BLKMAP_MULTISCR
 1594    01:C558  BD 85 2A   			lda	vdc_scr_bank, x		; Skip this if regular blkmap.
 1595    01:C55B  F0 11      			beq	!+
 1596                        	
 1597    01:C55D  E6 FD      			inc	<map_scrn_x		; Wrapped to the next screen.
 1598                        	
 1599    01:C55F  20 DF C2   			jsr	map_set_screen		; Locate screen's BLK and MAP.
 1600                        	
 1601    01:C562  18         			clc				; Calc map data pointer.
 1602    01:C563  A5 EE      			lda.l	<map_line
 1603    01:C565  85 EC      			sta.l	<_bp
 1604    01:C567  A5 EF      			lda.h	<map_line
 1605    01:C569  7D 81 2A   			adc.h	vdc_map_addr, x		; N.B. 256-byte aligned!
 1606    01:C56C  85 ED      			sta.h	<_bp
 1607                        		.endif
 1608                        	
 1609    01:C56E  A5 F9      	!:		lda	<map_bat_y		; Set the BAT VRAM destination
 1610    01:C570  85 F1      			sta.h	<_di			; coordinates.
 1611    01:C572  64 F0      			stz.l	<_di			; Reset 1st column to draw.
 1612                        	
 1613    01:C574  20 B4 C5   			jsr	blk_row_strip		; Draw rhs of horizontal strip.
 1614                        	
 1615               0001     		.if	BLKMAP_MULTISCR
 1616    01:C577  C6 FD      			dec	<map_scrn_x		; Restore, no check if should.
 1617                        		.endif	BLKMAP_MULTISCR
 1618                        	
 1619    01:C579  68         			pla				; Restore CHR X coordinate, we
 1620    01:C57A  85 FC      			sta	<map_chr_x		; might draw another row!
 1621                        	
 1622    01:C57C  C6 FB      	.done_row:	dec	<map_draw_h		; Are all desired rows drawn?
 1623    01:C57E  F0 33      			beq	.finished
 1624                        	
 1625    01:C580  E6 FE      			inc	<map_chr_y		; Move CHR Y down by 1.
 1626                        	
 1627    01:C582  A5 FE      			lda	<map_chr_y		; If new BLK then ...
 1628    01:C584  4A         			lsr	a
 1629    01:C585  B0 0B      			bcs	!+
 1630    01:C587  BD 43 25   			lda	vdc_map_line_w, x	; Move the map line pointer to
 1631    01:C58A  65 EE      			adc.l	<map_line		; the next line.
 1632    01:C58C  85 EE      			sta.l	<map_line
 1633    01:C58E  90 02      			bcc	!+
 1634    01:C590  E6 EF      			inc.h	<map_line
 1635                        	
 1636    01:C592  A5 F9      	!:		lda	<map_bat_y		; Move BAT Y down by 1.
 1637    01:C594  1A         			inc	a
 1638    01:C595  3D 3F 25   			and	vdc_bat_y_mask, x
 1639    01:C598  85 F9      			sta	<map_bat_y
 1640                        	
 1641               0001     		.if	BLKMAP_MULTISCR
 1642    01:C59A  BC 85 2A   			ldy	vdc_scr_bank, x		; Skip this if regular blkmap.
 1643    01:C59D  D0 03 4C 17			beq	.regular_row
         01:C5A1  C5          
 1644                        	
 1645    01:C5A2  A8         			tay				; If wrapped to the top line of
 1646    01:C5A3  D0 0B      			bne	!+			; of the BAT then increment the
 1647    01:C5A5  E6 FF      			inc	<map_scrn_y		; screen.
 1648                        	
 1649    01:C5A7  BD 40 25   			lda	vdc_bat_limit, x	; The map line must wrap around
 1650    01:C5AA  4A         			lsr	a			; too. This is simple since its
 1651    01:C5AB  4A         			lsr	a			; size (in bytes) is 1/4 of the
 1652    01:C5AC  25 EF      			and.h	<map_line		; BAT size (in words) and it is
 1653    01:C5AE  85 EF      			sta.h	<map_line		; a power-of-2.
 1654                        	
 1655    01:C5B0  4C BA C4   	!:		jmp	.multiscr_row		; Draw next row.
 1656                        		.else
 1658                        		.endif	BLKMAP_MULTISCR
 1659                        	
 1660    01:C5B3  60         	.finished:	rts
 1661                        	
 1662                        	
 1663                        	
 1664               0000     		.if	BLKDEF_POINTERS
 1858                        		.else	BLKDEF_POINTERS
 1859                        	
 1860                        	
 1861                        	
 1862                        	; ***************************************************************************
 1863                        	; ***************************************************************************
 1864                        	;
 1865                        	; blk_row_strip - Draw a single row of CHR into the BAT.
 1866                        	;
 1867                        	
 1868    01:C5B4  20 34 E4   	blk_row_strip:	jsr	set_di_xy_mawr		; Set the BAT VRAM destination.
 1869                        	
 1870    01:C5B7  A5 FC      			lda	<map_chr_x		; Select what drawing code to
 1871    01:C5B9  4A         			lsr	a			; use depending upon even/odd
 1872    01:C5BA  A5 FE      			lda	<map_chr_y		; CHR coordinates (not BAT to
 1873    01:C5BC  29 01      			and	#1			; support unaligned drawing).
 1874    01:C5BE  2A         			rol	a
 1875    01:C5BF  0A         			asl	a
 1876    01:C5C0  1D 7E 2A   			ora.h	vdc_blk_addr, x		; What is the BLK data address?
 1877    01:C5C3  29 1E      			and	#%00011110		; $4000, $4800, $5000 or $5800.
 1878    01:C5C5  A8         			tay
 1879    01:C5C6  B9 D3 C5   			lda.h	.jump_table, y		; Push the address of the code.
 1880    01:C5C9  48         			pha
 1881    01:C5CA  B9 D2 C5   			lda.l	.jump_table, y
 1882    01:C5CD  48         			pha
 1883                        	
 1884    01:C5CE  B2 EC      			lda	[_bp]			; Get the first BLK number.
 1885    01:C5D0  A8         			tay
 1886                        	
 1887    01:C5D1  60         			rts				; Jump to the drawing code.
 1888                        	
 1889    01:C5D2  F4 C5      	.jump_table:	dw	b4000_top_even - 1
 1890    01:C5D4  07 C6      			dw	b4000_top_odd - 1
 1891    01:C5D6  24 C6      			dw	b4000_btm_even - 1
 1892    01:C5D8  37 C6      			dw	b4000_btm_odd - 1
 1893                        	
 1894    01:C5DA  54 C6      			dw	b4800_top_even - 1
 1895    01:C5DC  67 C6      			dw	b4800_top_odd - 1
 1896    01:C5DE  84 C6      			dw	b4800_btm_even - 1
 1897    01:C5E0  97 C6      			dw	b4800_btm_odd - 1
 1898                        	
 1899    01:C5E2  B4 C6      			dw	b5000_top_even - 1
 1900    01:C5E4  C7 C6      			dw	b5000_top_odd - 1
 1901    01:C5E6  E4 C6      			dw	b5000_btm_even - 1
 1902    01:C5E8  F7 C6      			dw	b5000_btm_odd - 1
 1903                        	
 1904    01:C5EA  14 C7      			dw	b5800_top_even - 1
 1905    01:C5EC  27 C7      			dw	b5800_top_odd - 1
 1906    01:C5EE  44 C7      			dw	b5800_btm_even - 1
 1907    01:C5F0  57 C7      			dw	b5800_btm_odd - 1
 1908                        	
 1909                        			; top horizontal (32+2 rept)
 1910                        			;
 1911                        			; 89 cycles per block * 17 -> 1513 cycles
 1912                        	
 1913    01:C5F2  B2 EC      	!repeat:	lda	[_bp]			; 7
 1914    01:C5F4  A8         			tay				; 2
 1915                        	
 1916    01:C5F5  B9 00 40   	b4000_top_even:	lda	BLK_4000_TL_L, y	; 5
 1917    01:C5F8  9D 02 02   			sta	VDC_DL, x		; 6
 1918    01:C5FB  B9 00 44   			lda	BLK_4000_TL_H, y	; 5
 1919               0001     		.if	BLKDEF_CHR_FLAG
 1920    01:C5FE  29 F3      			and	#%11110011		; 2
 1921                        		.endif
 1922    01:C600  1A         			inc	a			; 2
 1923    01:C601  9D 03 02   			sta	VDC_DH, x		; 6
 1924                        	
 1925    01:C604  C6 00      			dec	<map_count		; 6
 1926    01:C606  F0 19      			beq	!end+			; 2
 1927                        	
 1928    01:C608  B9 00 41   	b4000_top_odd:	lda	BLK_4000_TR_L, y	; 5
 1929    01:C60B  9D 02 02   			sta	VDC_DL, x		; 6
 1930    01:C60E  B9 00 45   			lda	BLK_4000_TR_H, y	; 5
 1931               0001     		.if	BLKDEF_CHR_FLAG
 1932    01:C611  29 F3      			and	#%11110011		; 2
 1933                        		.endif
 1934    01:C613  1A         			inc	a			; 2
 1935    01:C614  9D 03 02   			sta	VDC_DH, x		; 6
 1936                        	
 1937    01:C617  E6 EC      			inc.l	<_bp			; 6
 1938    01:C619  D0 02      			bne	!+			; 2/4
 1939    01:C61B  E6 ED      			inc.h	<_bp			; 6
 1940                        	
 1941    01:C61D  C6 00      	!:		dec	<map_count		; 6
 1942    01:C61F  D0 D1      			bne	!repeat-		; 4
 1943                        	
 1944    01:C621  60         	!end:		rts
 1945                        	
 1946                        			; btm horizontal (32+2 rept)
 1947                        			;
 1948                        			; 89 cycles per block * 17 -> 1513 cycles
 1949                        	
 1950    01:C622  B2 EC      	!repeat:	lda	[_bp]			; 7
 1951    01:C624  A8         			tay				; 2
 1952                        	
 1953    01:C625  B9 00 42   	b4000_btm_even:	lda	BLK_4000_BL_L, y	; 5
 1954    01:C628  9D 02 02   			sta	VDC_DL, x		; 6
 1955    01:C62B  B9 00 46   			lda	BLK_4000_BL_H, y	; 5
 1956               0001     		.if	BLKDEF_CHR_FLAG
 1957    01:C62E  29 F3      			and	#%11110011		; 2
 1958                        		.endif
 1959    01:C630  1A         			inc	a			; 2
 1960    01:C631  9D 03 02   			sta	VDC_DH, x		; 6
 1961                        	
 1962    01:C634  C6 00      			dec	<map_count		; 6
 1963    01:C636  F0 19      			beq	!end+			; 2
 1964                        	
 1965    01:C638  B9 00 43   	b4000_btm_odd:	lda	BLK_4000_BR_L, y	; 5
 1966    01:C63B  9D 02 02   			sta	VDC_DL, x		; 6
 1967    01:C63E  B9 00 47   			lda	BLK_4000_BR_H, y	; 5
 1968               0001     		.if	BLKDEF_CHR_FLAG
 1969    01:C641  29 F3      			and	#%11110011		; 2
 1970                        		.endif
 1971    01:C643  1A         			inc	a			; 2
 1972    01:C644  9D 03 02   			sta	VDC_DH, x		; 6
 1973                        	
 1974    01:C647  E6 EC      			inc.l	<_bp			; 6
 1975    01:C649  D0 02      			bne	!+			; 2/4
 1976    01:C64B  E6 ED      			inc.h	<_bp			; 6
 1977                        	
 1978    01:C64D  C6 00      	!:		dec	<map_count		; 6
 1979    01:C64F  D0 D1      			bne	!repeat-		; 4
 1980                        	
 1981    01:C651  60         	!end:		rts
 1982                        	
 1983                        			; top horizontal (32+2 rept)
 1984                        			;
 1985                        			; 89 cycles per block * 17 -> 1513 cycles
 1986                        	
 1987    01:C652  B2 EC      	!repeat:	lda	[_bp]			; 7
 1988    01:C654  A8         			tay				; 2
 1989                        	
 1990    01:C655  B9 00 48   	b4800_top_even:	lda	BLK_4800_TL_L, y	; 5
 1991    01:C658  9D 02 02   			sta	VDC_DL, x		; 6
 1992    01:C65B  B9 00 4C   			lda	BLK_4800_TL_H, y	; 5
 1993               0001     		.if	BLKDEF_CHR_FLAG
 1994    01:C65E  29 F3      			and	#%11110011		; 2
 1995                        		.endif
 1996    01:C660  1A         			inc	a			; 2
 1997    01:C661  9D 03 02   			sta	VDC_DH, x		; 6
 1998                        	
 1999    01:C664  C6 00      			dec	<map_count		; 6
 2000    01:C666  F0 19      			beq	!end+			; 2
 2001                        	
 2002    01:C668  B9 00 49   	b4800_top_odd:	lda	BLK_4800_TR_L, y	; 5
 2003    01:C66B  9D 02 02   			sta	VDC_DL, x		; 6
 2004    01:C66E  B9 00 4D   			lda	BLK_4800_TR_H, y	; 5
 2005               0001     		.if	BLKDEF_CHR_FLAG
 2006    01:C671  29 F3      			and	#%11110011		; 2
 2007                        		.endif
 2008    01:C673  1A         			inc	a			; 2
 2009    01:C674  9D 03 02   			sta	VDC_DH, x		; 6
 2010                        	
 2011    01:C677  E6 EC      			inc.l	<_bp			; 6
 2012    01:C679  D0 02      			bne	!+			; 2/4
 2013    01:C67B  E6 ED      			inc.h	<_bp			; 6
 2014                        	
 2015    01:C67D  C6 00      	!:		dec	<map_count		; 6
 2016    01:C67F  D0 D1      			bne	!repeat-		; 4
 2017                        	
 2018    01:C681  60         	!end:		rts
 2019                        	
 2020                        			; btm horizontal (32+2 rept)
 2021                        			;
 2022                        			; 89 cycles per block * 17 -> 1513 cycles
 2023                        	
 2024    01:C682  B2 EC      	!repeat:	lda	[_bp]			; 7
 2025    01:C684  A8         			tay				; 2
 2026                        	
 2027    01:C685  B9 00 4A   	b4800_btm_even:	lda	BLK_4800_BL_L, y	; 5
 2028    01:C688  9D 02 02   			sta	VDC_DL, x		; 6
 2029    01:C68B  B9 00 4E   			lda	BLK_4800_BL_H, y	; 5
 2030               0001     		.if	BLKDEF_CHR_FLAG
 2031    01:C68E  29 F3      			and	#%11110011		; 2
 2032                        		.endif
 2033    01:C690  1A         			inc	a			; 2
 2034    01:C691  9D 03 02   			sta	VDC_DH, x		; 6
 2035                        	
 2036    01:C694  C6 00      			dec	<map_count		; 6
 2037    01:C696  F0 19      			beq	!end+			; 2
 2038                        	
 2039    01:C698  B9 00 4B   	b4800_btm_odd:	lda	BLK_4800_BR_L, y	; 5
 2040    01:C69B  9D 02 02   			sta	VDC_DL, x		; 6
 2041    01:C69E  B9 00 4F   			lda	BLK_4800_BR_H, y	; 5
 2042               0001     		.if	BLKDEF_CHR_FLAG
 2043    01:C6A1  29 F3      			and	#%11110011		; 2
 2044                        		.endif
 2045    01:C6A3  1A         			inc	a			; 2
 2046    01:C6A4  9D 03 02   			sta	VDC_DH, x		; 6
 2047                        	
 2048    01:C6A7  E6 EC      			inc.l	<_bp			; 6
 2049    01:C6A9  D0 02      			bne	!+			; 2/4
 2050    01:C6AB  E6 ED      			inc.h	<_bp			; 6
 2051                        	
 2052    01:C6AD  C6 00      	!:		dec	<map_count		; 6
 2053    01:C6AF  D0 D1      			bne	!repeat-		; 4
 2054                        	
 2055    01:C6B1  60         	!end:		rts
 2056                        	
 2057                        			; top horizontal (32+2 rept)
 2058                        			;
 2059                        			; 89 cycles per block * 17 -> 1513 cycles
 2060                        	
 2061    01:C6B2  B2 EC      	!repeat:	lda	[_bp]			; 7
 2062    01:C6B4  A8         			tay				; 2
 2063                        	
 2064    01:C6B5  B9 00 50   	b5000_top_even:	lda	BLK_5000_TL_L, y	; 5
 2065    01:C6B8  9D 02 02   			sta	VDC_DL, x		; 6
 2066    01:C6BB  B9 00 54   			lda	BLK_5000_TL_H, y	; 5
 2067               0001     		.if	BLKDEF_CHR_FLAG
 2068    01:C6BE  29 F3      			and	#%11110011		; 2
 2069                        		.endif
 2070    01:C6C0  1A         			inc	a			; 2
 2071    01:C6C1  9D 03 02   			sta	VDC_DH, x		; 6
 2072                        	
 2073    01:C6C4  C6 00      			dec	<map_count		; 6
 2074    01:C6C6  F0 19      			beq	!end+			; 2
 2075                        	
 2076    01:C6C8  B9 00 51   	b5000_top_odd:	lda	BLK_5000_TR_L, y	; 5
 2077    01:C6CB  9D 02 02   			sta	VDC_DL, x		; 6
 2078    01:C6CE  B9 00 55   			lda	BLK_5000_TR_H, y	; 5
 2079               0001     		.if	BLKDEF_CHR_FLAG
 2080    01:C6D1  29 F3      			and	#%11110011		; 2
 2081                        		.endif
 2082    01:C6D3  1A         			inc	a			; 2
 2083    01:C6D4  9D 03 02   			sta	VDC_DH, x		; 6
 2084                        	
 2085    01:C6D7  E6 EC      			inc.l	<_bp			; 6
 2086    01:C6D9  D0 02      			bne	!+			; 2/4
 2087    01:C6DB  E6 ED      			inc.h	<_bp			; 6
 2088                        	
 2089    01:C6DD  C6 00      	!:		dec	<map_count		; 6
 2090    01:C6DF  D0 D1      			bne	!repeat-		; 4
 2091                        	
 2092    01:C6E1  60         	!end:		rts
 2093                        	
 2094                        			; btm horizontal (32+2 rept)
 2095                        			;
 2096                        			; 89 cycles per block * 17 -> 1513 cycles
 2097                        	
 2098    01:C6E2  B2 EC      	!repeat:	lda	[_bp]			; 7
 2099    01:C6E4  A8         			tay				; 2
 2100                        	
 2101    01:C6E5  B9 00 52   	b5000_btm_even:	lda	BLK_5000_BL_L, y	; 5
 2102    01:C6E8  9D 02 02   			sta	VDC_DL, x		; 6
 2103    01:C6EB  B9 00 56   			lda	BLK_5000_BL_H, y	; 5
 2104               0001     		.if	BLKDEF_CHR_FLAG
 2105    01:C6EE  29 F3      			and	#%11110011		; 2
 2106                        		.endif
 2107    01:C6F0  1A         			inc	a			; 2
 2108    01:C6F1  9D 03 02   			sta	VDC_DH, x		; 6
 2109                        	
 2110    01:C6F4  C6 00      			dec	<map_count		; 6
 2111    01:C6F6  F0 19      			beq	!end+			; 2
 2112                        	
 2113    01:C6F8  B9 00 53   	b5000_btm_odd:	lda	BLK_5000_BR_L, y	; 5
 2114    01:C6FB  9D 02 02   			sta	VDC_DL, x		; 6
 2115    01:C6FE  B9 00 57   			lda	BLK_5000_BR_H, y	; 5
 2116               0001     		.if	BLKDEF_CHR_FLAG
 2117    01:C701  29 F3      			and	#%11110011		; 2
 2118                        		.endif
 2119    01:C703  1A         			inc	a			; 2
 2120    01:C704  9D 03 02   			sta	VDC_DH, x		; 6
 2121                        	
 2122    01:C707  E6 EC      			inc.l	<_bp			; 6
 2123    01:C709  D0 02      			bne	!+			; 2/4
 2124    01:C70B  E6 ED      			inc.h	<_bp			; 6
 2125                        	
 2126    01:C70D  C6 00      	!:		dec	<map_count		; 6
 2127    01:C70F  D0 D1      			bne	!repeat-		; 4
 2128                        	
 2129    01:C711  60         	!end:		rts
 2130                        	
 2131                        			; top horizontal (32+2 rept)
 2132                        			;
 2133                        			; 89 cycles per block * 17 -> 1513 cycles
 2134                        	
 2135    01:C712  B2 EC      	!repeat:	lda	[_bp]			; 7
 2136    01:C714  A8         			tay				; 2
 2137                        	
 2138    01:C715  B9 00 58   	b5800_top_even:	lda	BLK_5800_TL_L, y	; 5
 2139    01:C718  9D 02 02   			sta	VDC_DL, x		; 6
 2140    01:C71B  B9 00 5C   			lda	BLK_5800_TL_H, y	; 5
 2141               0001     		.if	BLKDEF_CHR_FLAG
 2142    01:C71E  29 F3      			and	#%11110011		; 2
 2143                        		.endif
 2144    01:C720  1A         			inc	a			; 2
 2145    01:C721  9D 03 02   			sta	VDC_DH, x		; 6
 2146                        	
 2147    01:C724  C6 00      			dec	<map_count		; 6
 2148    01:C726  F0 19      			beq	!end+			; 2
 2149                        	
 2150    01:C728  B9 00 59   	b5800_top_odd:	lda	BLK_5800_TR_L, y	; 5
 2151    01:C72B  9D 02 02   			sta	VDC_DL, x		; 6
 2152    01:C72E  B9 00 5D   			lda	BLK_5800_TR_H, y	; 5
 2153               0001     		.if	BLKDEF_CHR_FLAG
 2154    01:C731  29 F3      			and	#%11110011		; 2
 2155                        		.endif
 2156    01:C733  1A         			inc	a			; 2
 2157    01:C734  9D 03 02   			sta	VDC_DH, x		; 6
 2158                        	
 2159    01:C737  E6 EC      			inc.l	<_bp			; 6
 2160    01:C739  D0 02      			bne	!+			; 2/4
 2161    01:C73B  E6 ED      			inc.h	<_bp			; 6
 2162                        	
 2163    01:C73D  C6 00      	!:		dec	<map_count		; 6
 2164    01:C73F  D0 D1      			bne	!repeat-		; 4
 2165                        	
 2166    01:C741  60         	!end:		rts
 2167                        	
 2168                        			; btm horizontal (32+2 rept)
 2169                        			;
 2170                        			; 89 cycles per block * 17 -> 1513 cycles
 2171                        	
 2172    01:C742  B2 EC      	!repeat:	lda	[_bp]		; 7
 2173    01:C744  A8         			tay				; 2
 2174                        	
 2175    01:C745  B9 00 5A   	b5800_btm_even:	lda	BLK_5800_BL_L, y	; 5
 2176    01:C748  9D 02 02   			sta	VDC_DL, x		; 6
 2177    01:C74B  B9 00 5E   			lda	BLK_5800_BL_H, y	; 5
 2178               0001     		.if	BLKDEF_CHR_FLAG
 2179    01:C74E  29 F3      			and	#%11110011		; 2
 2180                        		.endif
 2181    01:C750  1A         			inc	a			; 2
 2182    01:C751  9D 03 02   			sta	VDC_DH, x		; 6
 2183                        	
 2184    01:C754  C6 00      			dec	<map_count		; 6
 2185    01:C756  F0 19      			beq	!end+			; 2
 2186                        	
 2187    01:C758  B9 00 5B   	b5800_btm_odd:	lda	BLK_5800_BR_L, y	; 5
 2188    01:C75B  9D 02 02   			sta	VDC_DL, x		; 6
 2189    01:C75E  B9 00 5F   			lda	BLK_5800_BR_H, y	; 5
 2190               0001     		.if	BLKDEF_CHR_FLAG
 2191    01:C761  29 F3      			and	#%11110011		; 2
 2192                        		.endif
 2193    01:C763  1A         			inc	a			; 2
 2194    01:C764  9D 03 02   			sta	VDC_DH, x		; 6
 2195                        	
 2196    01:C767  E6 EC      			inc.l	<_bp			; 6
 2197    01:C769  D0 02      			bne	!+			; 2/4
 2198    01:C76B  E6 ED      			inc.h	<_bp			; 6
 2199                        	
 2200    01:C76D  C6 00      	!:		dec	<map_count		; 6
 2201    01:C76F  D0 D1      			bne	!repeat-		; 4
 2202                        	
 2203    01:C771  60         	!end:		rts
 2204                        	
 2205                        	
 2206                        	
 2207                        	; ***************************************************************************
 2208                        	; ***************************************************************************
 2209                        	;
 2210                        	; blk_col_strip - Draw a single column of CHR into the BAT.
 2211                        	;
 2212                        	
 2213    01:C772  20 34 E4   	blk_col_strip:	jsr	set_di_xy_mawr		; Set the BAT VRAM destination.
 2214                        	
 2215    01:C775  A5 FC      			lda	<map_chr_x		; Select what drawing code to
 2216    01:C777  4A         			lsr	a			; use depending upon even/odd
 2217    01:C778  A5 FE      			lda	<map_chr_y		; CHR coordinates (not BAT to
 2218    01:C77A  29 01      			and	#1			; support unaligned drawing).
 2219    01:C77C  2A         			rol	a
 2220    01:C77D  0A         			asl	a			; N.B. Always leaves C clear.
 2221    01:C77E  1D 7E 2A   			ora.h	vdc_blk_addr, x		; What is the BLK data address?
 2222    01:C781  29 1E      			and	#%00011110		; $4000, $4800, $5000 or $5800.
 2223    01:C783  A8         			tay
 2224    01:C784  B9 91 C7   			lda.h	.jump_table, y		; Push the address of the code.
 2225    01:C787  48         			pha
 2226    01:C788  B9 90 C7   			lda.l	.jump_table, y
 2227    01:C78B  48         			pha
 2228                        	
 2229    01:C78C  B2 EC      			lda	[_bp]			; Get the first BLK number.
 2230    01:C78E  A8         			tay
 2231                        	
 2232    01:C78F  60         			rts				; Jump to the drawing code.
 2233                        	
 2234    01:C790  B2 C7      	.jump_table:	dw	b4000_lhs_even - 1
 2235    01:C792  E8 C7      			dw	b4000_rhs_even - 1
 2236    01:C794  C5 C7      			dw	b4000_lhs_odd - 1
 2237    01:C796  FB C7      			dw	b4000_rhs_odd - 1
 2238                        	
 2239    01:C798  1E C8      			dw	b4800_lhs_even - 1
 2240    01:C79A  54 C8      			dw	b4800_rhs_even - 1
 2241    01:C79C  31 C8      			dw	b4800_lhs_odd - 1
 2242    01:C79E  67 C8      			dw	b4800_rhs_odd - 1
 2243                        	
 2244    01:C7A0  8A C8      			dw	b5000_lhs_even - 1
 2245    01:C7A2  C0 C8      			dw	b5000_rhs_even - 1
 2246    01:C7A4  9D C8      			dw	b5000_lhs_odd - 1
 2247    01:C7A6  D3 C8      			dw	b5000_rhs_odd - 1
 2248                        	
 2249    01:C7A8  F6 C8      			dw	b5800_lhs_even - 1
 2250    01:C7AA  2C C9      			dw	b5800_rhs_even - 1
 2251    01:C7AC  09 C9      			dw	b5800_lhs_odd - 1
 2252    01:C7AE  3F C9      			dw	b5800_rhs_odd - 1
 2253                        	
 2254                        			; lhs vertical (28+2 rept)
 2255                        			;
 2256                        			; N.B. C is always clear on entry.
 2257                        			;
 2258                        			; 100 cycles per block * 15 -> 1500 cycles
 2259                        	
 2260    01:C7B0  B2 EC      	!repeat:	lda	[_bp]			; 7
 2261    01:C7B2  A8         			tay				; 2
 2262                        	
 2263    01:C7B3  B9 00 40   	b4000_lhs_even:	lda	BLK_4000_TL_L, y	; 5
 2264    01:C7B6  9D 02 02   			sta	VDC_DL, x		; 6
 2265    01:C7B9  B9 00 44   			lda	BLK_4000_TL_H, y	; 5
 2266               0001     		.if	BLKDEF_CHR_FLAG
 2267    01:C7BC  29 F3      			and	#%11110011		; 2
 2268                        		.endif
 2269    01:C7BE  1A         			inc	a			; 2
 2270    01:C7BF  9D 03 02   			sta	VDC_DH, x		; 6
 2271                        	
 2272    01:C7C2  C6 00      			dec	<map_count		; 6
 2273    01:C7C4  F0 1F      			beq	!end+			; 2
 2274                        	
 2275    01:C7C6  B9 00 42   	b4000_lhs_odd:	lda	BLK_4000_BL_L, y	; 5
 2276    01:C7C9  9D 02 02   			sta	VDC_DL, x		; 6
 2277    01:C7CC  B9 00 46   			lda	BLK_4000_BL_H, y	; 5
 2278               0001     		.if	BLKDEF_CHR_FLAG
 2279    01:C7CF  29 F3      			and	#%11110011		; 2
 2280                        		.endif
 2281    01:C7D1  1A         			inc	a			; 2
 2282    01:C7D2  9D 03 02   			sta	VDC_DH, x		; 6
 2283                        	
 2284    01:C7D5  BD 43 25   			lda	vdc_map_line_w, x	; 5
 2285    01:C7D8  65 EC      			adc.l	<_bp			; 4
 2286    01:C7DA  85 EC      			sta.l	<_bp			; 4
 2287    01:C7DC  90 03      			bcc	!+			; 2/4
 2288    01:C7DE  E6 ED      			inc.h	<_bp			; 6
 2289    01:C7E0  18         			clc				; 2
 2290                        	
 2291    01:C7E1  C6 00      	!:		dec	<map_count		; 6
 2292    01:C7E3  D0 CB      			bne	!repeat-		; 4
 2293                        	
 2294    01:C7E5  60         	!end:		rts
 2295                        	
 2296                        			; rhs vertical (28+2 rept)
 2297                        			;
 2298                        			; N.B. C is always clear on entry.
 2299                        			;
 2300                        			; 100 cycles per block * 15 -> 1500 cycles
 2301                        	
 2302    01:C7E6  B2 EC      	!repeat:	lda	[_bp]			; 7
 2303    01:C7E8  A8         			tay				; 2
 2304                        	
 2305    01:C7E9  B9 00 41   	b4000_rhs_even:	lda	BLK_4000_TR_L, y	; 5
 2306    01:C7EC  9D 02 02   			sta	VDC_DL, x		; 6
 2307    01:C7EF  B9 00 45   			lda	BLK_4000_TR_H, y	; 5
 2308               0001     		.if	BLKDEF_CHR_FLAG
 2309    01:C7F2  29 F3      			and	#%11110011		; 2
 2310                        		.endif
 2311    01:C7F4  1A         			inc	a			; 2
 2312    01:C7F5  9D 03 02   			sta	VDC_DH, x		; 6
 2313                        	
 2314    01:C7F8  C6 00      			dec	<map_count		; 6
 2315    01:C7FA  F0 1F      			beq	!end+			; 2
 2316                        	
 2317    01:C7FC  B9 00 43   	b4000_rhs_odd:	lda	BLK_4000_BR_L, y	; 5
 2318    01:C7FF  9D 02 02   			sta	VDC_DL, x		; 6
 2319    01:C802  B9 00 47   			lda	BLK_4000_BR_H, y	; 5
 2320               0001     		.if	BLKDEF_CHR_FLAG
 2321    01:C805  29 F3      			and	#%11110011		; 2
 2322                        		.endif
 2323    01:C807  1A         			inc	a			; 2
 2324    01:C808  9D 03 02   			sta	VDC_DH, x		; 6
 2325                        	
 2326    01:C80B  BD 43 25   			lda	vdc_map_line_w, x	; 5
 2327    01:C80E  65 EC      			adc.l	<_bp			; 4
 2328    01:C810  85 EC      			sta.l	<_bp			; 4
 2329    01:C812  90 03      			bcc	!+			; 2/4
 2330    01:C814  E6 ED      			inc.h	<_bp			; 6
 2331    01:C816  18         			clc				; 2
 2332                        	
 2333    01:C817  C6 00      	!:		dec	<map_count		; 6
 2334    01:C819  D0 CB      			bne	!repeat-		; 4
 2335                        	
 2336    01:C81B  60         	!end:		rts
 2337                        	
 2338                        			; lhs vertical (28+2 rept)
 2339                        			;
 2340                        			; N.B. C is always clear on entry.
 2341                        			;
 2342                        			; 100 cycles per block * 15 -> 1500 cycles
 2343                        	
 2344    01:C81C  B2 EC      	!repeat:	lda	[_bp]			; 7
 2345    01:C81E  A8         			tay				; 2
 2346                        	
 2347    01:C81F  B9 00 48   	b4800_lhs_even:	lda	BLK_4800_TL_L, y	; 5
 2348    01:C822  9D 02 02   			sta	VDC_DL, x		; 6
 2349    01:C825  B9 00 4C   			lda	BLK_4800_TL_H, y	; 5
 2350               0001     		.if	BLKDEF_CHR_FLAG
 2351    01:C828  29 F3      			and	#%11110011		; 2
 2352                        		.endif
 2353    01:C82A  1A         			inc	a			; 2
 2354    01:C82B  9D 03 02   			sta	VDC_DH, x		; 6
 2355                        	
 2356    01:C82E  C6 00      			dec	<map_count		; 6
 2357    01:C830  F0 1F      			beq	!end+			; 2
 2358                        	
 2359    01:C832  B9 00 4A   	b4800_lhs_odd:	lda	BLK_4800_BL_L, y	; 5
 2360    01:C835  9D 02 02   			sta	VDC_DL, x		; 6
 2361    01:C838  B9 00 4E   			lda	BLK_4800_BL_H, y	; 5
 2362               0001     		.if	BLKDEF_CHR_FLAG
 2363    01:C83B  29 F3      			and	#%11110011		; 2
 2364                        		.endif
 2365    01:C83D  1A         			inc	a			; 2
 2366    01:C83E  9D 03 02   			sta	VDC_DH, x		; 6
 2367                        	
 2368    01:C841  BD 43 25   			lda	vdc_map_line_w, x	; 5
 2369    01:C844  65 EC      			adc.l	<_bp			; 4
 2370    01:C846  85 EC      			sta.l	<_bp			; 4
 2371    01:C848  90 03      			bcc	!+			; 2/4
 2372    01:C84A  E6 ED      			inc.h	<_bp			; 6
 2373    01:C84C  18         			clc				; 2
 2374                        	
 2375    01:C84D  C6 00      	!:		dec	<map_count		; 6
 2376    01:C84F  D0 CB      			bne	!repeat-		; 4
 2377                        	
 2378    01:C851  60         	!end:		rts
 2379                        	
 2380                        			; rhs vertical (28+2 rept)
 2381                        			;
 2382                        			; N.B. C is always clear on entry.
 2383                        			;
 2384                        			; 100 cycles per block * 15 -> 1500 cycles
 2385                        	
 2386    01:C852  B2 EC      	!repeat:	lda	[_bp]			; 7
 2387    01:C854  A8         			tay				; 2
 2388                        	
 2389    01:C855  B9 00 49   	b4800_rhs_even:	lda	BLK_4800_TR_L, y	; 5
 2390    01:C858  9D 02 02   			sta	VDC_DL, x		; 6
 2391    01:C85B  B9 00 4D   			lda	BLK_4800_TR_H, y	; 5
 2392               0001     		.if	BLKDEF_CHR_FLAG
 2393    01:C85E  29 F3      			and	#%11110011		; 2
 2394                        		.endif
 2395    01:C860  1A         			inc	a			; 2
 2396    01:C861  9D 03 02   			sta	VDC_DH, x		; 6
 2397                        	
 2398    01:C864  C6 00      			dec	<map_count		; 6
 2399    01:C866  F0 1F      			beq	!end+			; 2
 2400                        	
 2401    01:C868  B9 00 4B   	b4800_rhs_odd:	lda	BLK_4800_BR_L, y	; 5
 2402    01:C86B  9D 02 02   			sta	VDC_DL, x		; 6
 2403    01:C86E  B9 00 4F   			lda	BLK_4800_BR_H, y	; 5
 2404               0001     		.if	BLKDEF_CHR_FLAG
 2405    01:C871  29 F3      			and	#%11110011		; 2
 2406                        		.endif
 2407    01:C873  1A         			inc	a			; 2
 2408    01:C874  9D 03 02   			sta	VDC_DH, x		; 6
 2409                        	
 2410    01:C877  BD 43 25   			lda	vdc_map_line_w, x	; 5
 2411    01:C87A  65 EC      			adc.l	<_bp			; 4
 2412    01:C87C  85 EC      			sta.l	<_bp			; 4
 2413    01:C87E  90 03      			bcc	!+			; 2/4
 2414    01:C880  E6 ED      			inc.h	<_bp			; 6
 2415    01:C882  18         			clc				; 2
 2416                        	
 2417    01:C883  C6 00      	!:		dec	<map_count		; 6
 2418    01:C885  D0 CB      			bne	!repeat-		; 4
 2419                        	
 2420    01:C887  60         	!end:		rts
 2421                        	
 2422                        			; lhs vertical (28+2 rept)
 2423                        			;
 2424                        			; N.B. C is always clear on entry.
 2425                        			;
 2426                        			; 100 cycles per block * 15 -> 1500 cycles
 2427                        	
 2428    01:C888  B2 EC      	!repeat:	lda	[_bp]			; 7
 2429    01:C88A  A8         			tay				; 2
 2430                        	
 2431    01:C88B  B9 00 50   	b5000_lhs_even:	lda	BLK_5000_TL_L, y	; 5
 2432    01:C88E  9D 02 02   			sta	VDC_DL, x		; 6
 2433    01:C891  B9 00 54   			lda	BLK_5000_TL_H, y	; 5
 2434               0001     		.if	BLKDEF_CHR_FLAG
 2435    01:C894  29 F3      			and	#%11110011		; 2
 2436                        		.endif
 2437    01:C896  1A         			inc	a			; 2
 2438    01:C897  9D 03 02   			sta	VDC_DH, x		; 6
 2439                        	
 2440    01:C89A  C6 00      			dec	<map_count		; 6
 2441    01:C89C  F0 1F      			beq	!end+			; 2
 2442                        	
 2443    01:C89E  B9 00 52   	b5000_lhs_odd:	lda	BLK_5000_BL_L, y	; 5
 2444    01:C8A1  9D 02 02   			sta	VDC_DL, x		; 6
 2445    01:C8A4  B9 00 56   			lda	BLK_5000_BL_H, y	; 5
 2446               0001     		.if	BLKDEF_CHR_FLAG
 2447    01:C8A7  29 F3      			and	#%11110011		; 2
 2448                        		.endif
 2449    01:C8A9  1A         			inc	a			; 2
 2450    01:C8AA  9D 03 02   			sta	VDC_DH, x		; 6
 2451                        	
 2452    01:C8AD  BD 43 25   			lda	vdc_map_line_w, x	; 5
 2453    01:C8B0  65 EC      			adc.l	<_bp			; 4
 2454    01:C8B2  85 EC      			sta.l	<_bp			; 4
 2455    01:C8B4  90 03      			bcc	!+			; 2/4
 2456    01:C8B6  E6 ED      			inc.h	<_bp			; 6
 2457    01:C8B8  18         			clc				; 2
 2458                        	
 2459    01:C8B9  C6 00      	!:		dec	<map_count		; 6
 2460    01:C8BB  D0 CB      			bne	!repeat-		; 4
 2461                        	
 2462    01:C8BD  60         	!end:		rts
 2463                        	
 2464                        			; rhs vertical (28+2 rept)
 2465                        			;
 2466                        			; N.B. C is always clear on entry.
 2467                        			;
 2468                        			; 100 cycles per block * 15 -> 1500 cycles
 2469                        	
 2470    01:C8BE  B2 EC      	!repeat:	lda	[_bp]			; 7
 2471    01:C8C0  A8         			tay				; 2
 2472                        	
 2473    01:C8C1  B9 00 51   	b5000_rhs_even:	lda	BLK_5000_TR_L, y	; 5
 2474    01:C8C4  9D 02 02   			sta	VDC_DL, x		; 6
 2475    01:C8C7  B9 00 55   			lda	BLK_5000_TR_H, y	; 5
 2476               0001     		.if	BLKDEF_CHR_FLAG
 2477    01:C8CA  29 F3      			and	#%11110011		; 2
 2478                        		.endif
 2479    01:C8CC  1A         			inc	a			; 2
 2480    01:C8CD  9D 03 02   			sta	VDC_DH, x		; 6
 2481                        	
 2482    01:C8D0  C6 00      			dec	<map_count		; 6
 2483    01:C8D2  F0 1F      			beq	!end+			; 2
 2484                        	
 2485    01:C8D4  B9 00 53   	b5000_rhs_odd:	lda	BLK_5000_BR_L, y	; 5
 2486    01:C8D7  9D 02 02   			sta	VDC_DL, x		; 6
 2487    01:C8DA  B9 00 57   			lda	BLK_5000_BR_H, y	; 5
 2488               0001     		.if	BLKDEF_CHR_FLAG
 2489    01:C8DD  29 F3      			and	#%11110011		; 2
 2490                        		.endif
 2491    01:C8DF  1A         			inc	a			; 2
 2492    01:C8E0  9D 03 02   			sta	VDC_DH, x		; 6
 2493                        	
 2494    01:C8E3  BD 43 25   			lda	vdc_map_line_w, x	; 5
 2495    01:C8E6  65 EC      			adc.l	<_bp			; 4
 2496    01:C8E8  85 EC      			sta.l	<_bp			; 4
 2497    01:C8EA  90 03      			bcc	!+			; 2/4
 2498    01:C8EC  E6 ED      			inc.h	<_bp			; 6
 2499    01:C8EE  18         			clc				; 2
 2500                        	
 2501    01:C8EF  C6 00      	!:		dec	<map_count		; 6
 2502    01:C8F1  D0 CB      			bne	!repeat-		; 4
 2503                        	
 2504    01:C8F3  60         	!end:		rts
 2505                        	
 2506                        			; lhs vertical (28+2 rept)
 2507                        			;
 2508                        			; N.B. C is always clear on entry.
 2509                        			;
 2510                        			; 100 cycles per block * 15 -> 1500 cycles
 2511                        	
 2512    01:C8F4  B2 EC      	!repeat:	lda	[_bp]			; 7
 2513    01:C8F6  A8         			tay				; 2
 2514                        	
 2515    01:C8F7  B9 00 58   	b5800_lhs_even:	lda	BLK_5800_TL_L, y	; 5
 2516    01:C8FA  9D 02 02   			sta	VDC_DL, x		; 6
 2517    01:C8FD  B9 00 5C   			lda	BLK_5800_TL_H, y	; 5
 2518               0001     		.if	BLKDEF_CHR_FLAG
 2519    01:C900  29 F3      			and	#%11110011		; 2
 2520                        		.endif
 2521    01:C902  1A         			inc	a			; 2
 2522    01:C903  9D 03 02   			sta	VDC_DH, x		; 6
 2523                        	
 2524    01:C906  C6 00      			dec	<map_count		; 6
 2525    01:C908  F0 1F      			beq	!end+			; 2
 2526                        	
 2527    01:C90A  B9 00 5A   	b5800_lhs_odd:	lda	BLK_5800_BL_L, y	; 5
 2528    01:C90D  9D 02 02   			sta	VDC_DL, x		; 6
 2529    01:C910  B9 00 5E   			lda	BLK_5800_BL_H, y	; 5
 2530               0001     		.if	BLKDEF_CHR_FLAG
 2531    01:C913  29 F3      			and	#%11110011		; 2
 2532                        		.endif
 2533    01:C915  1A         			inc	a			; 2
 2534    01:C916  9D 03 02   			sta	VDC_DH, x		; 6
 2535                        	
 2536    01:C919  BD 43 25   			lda	vdc_map_line_w, x	; 5
 2537    01:C91C  65 EC      			adc.l	<_bp			; 4
 2538    01:C91E  85 EC      			sta.l	<_bp			; 4
 2539    01:C920  90 03      			bcc	!+			; 2/4
 2540    01:C922  E6 ED      			inc.h	<_bp			; 6
 2541    01:C924  18         			clc				; 2
 2542                        	
 2543    01:C925  C6 00      	!:		dec	<map_count		; 6
 2544    01:C927  D0 CB      			bne	!repeat-		; 4
 2545                        	
 2546    01:C929  60         	!end:		rts
 2547                        	
 2548                        			; rhs vertical (28+2 rept)
 2549                        			;
 2550                        			; N.B. C is always clear on entry.
 2551                        			;
 2552                        			; 100 cycles per block * 15 -> 1500 cycles
 2553                        	
 2554    01:C92A  B2 EC      	!repeat:	lda	[_bp]			; 7
 2555    01:C92C  A8         			tay				; 2
 2556                        	
 2557    01:C92D  B9 00 59   	b5800_rhs_even:	lda	BLK_5800_TR_L, y	; 5
 2558    01:C930  9D 02 02   			sta	VDC_DL, x		; 6
 2559    01:C933  B9 00 5D   			lda	BLK_5800_TR_H, y	; 5
 2560               0001     		.if	BLKDEF_CHR_FLAG
 2561    01:C936  29 F3      			and	#%11110011		; 2
 2562                        		.endif
 2563    01:C938  1A         			inc	a			; 2
 2564    01:C939  9D 03 02   			sta	VDC_DH, x		; 6
 2565                        	
 2566    01:C93C  C6 00      			dec	<map_count		; 6
 2567    01:C93E  F0 1F      			beq	!end+			; 2
 2568                        	
 2569    01:C940  B9 00 5B   	b5800_rhs_odd:	lda	BLK_5800_BR_L, y	; 5
 2570    01:C943  9D 02 02   			sta	VDC_DL, x		; 6
 2571    01:C946  B9 00 5F   			lda	BLK_5800_BR_H, y	; 5
 2572               0001     		.if	BLKDEF_CHR_FLAG
 2573    01:C949  29 F3      			and	#%11110011		; 2
 2574                        		.endif
 2575    01:C94B  1A         			inc	a			; 2
 2576    01:C94C  9D 03 02   			sta	VDC_DH, x		; 6
 2577                        	
 2578    01:C94F  BD 43 25   			lda	vdc_map_line_w, x	; 5
 2579    01:C952  65 EC      			adc.l	<_bp			; 4
 2580    01:C954  85 EC      			sta.l	<_bp			; 4
 2581    01:C956  90 03      			bcc	!+			; 2/4
 2582    01:C958  E6 ED      			inc.h	<_bp			; 6
 2583    01:C95A  18         			clc				; 2
 2584                        	
 2585    01:C95B  C6 00      	!:		dec	<map_count		; 6
 2586    01:C95D  D0 CB      			bne	!repeat-		; 4
 2587                        	
 2588    01:C95F  60         	!end:		rts
 2589                        	
 2590                        		.endif	BLKDEF_POINTERS
 2591                        	
 2592                        		.endprocgroup	; blkmap_group
                             #[2]   "..\..\..\include\hucc\hucc-final.asm"
   80                        		.else
   84                        		.endif	HUCC_USES_BLKMAP
   85                        	
   86               0001     		.ifdef	HUCC_USES_CHRMAP		; Set in hucc_chrmap.h
                             #[3]   "..\..\..\include\hucc\chrmap.asm"
   87                        			include	"chrmap.asm"
    1                        	; ***************************************************************************
    2                        	; ***************************************************************************
    3                        	;
    4                        	; chrmap.asm
    5                        	;
    6                        	; A simple map system based on 8x8 characters (aka "tiles") in BAT format.
    7                        	;
    8                        	; Copyright John Brandwood 2025.
    9                        	;
   10                        	; Distributed under the Boost Software License, Version 1.0.
   11                        	; (See accompanying file LICENSE_1_0.txt or copy at
   12                        	;  http://www.boost.org/LICENSE_1_0.txt)
   13                        	;
   14                        	; ***************************************************************************
   15                        	; ***************************************************************************
   16                        	;
   17                        	; The maximum X and Y size for chrmaps is 256 characters (2048 pixels).
   18                        	;
   19                        	; The maximum total size for a chrmap is 16KBytes, which allows for maps up
   20                        	; to 256x32 tiles (2048x256 pixels).
   21                        	;
   22                        	; ***************************************************************************
   23                        	; ***************************************************************************
   24                        	
   25                        	;
   26                        	; Include dependancies ...
   27                        	;
   28                        	
   29                        			include "blkmap.asm"		; This defines the variables.
   30                        	
   31                        	;
   32                        	; Chrmaps in BAT format normally address all of VRAM from $0400..$7FFF, but
   33                        	; they can be limited to use the 32KByte of characters in VRAM $1000..$4FFF
   34                        	; which then frees up 2-bits for flag information for each character in the
   35                        	; BAT entry.
   36                        	;
   37                        	; These 2-bits are perfect for using as collision information in game maps,
   38                        	; allowing storage of states like transparent, solid, up-slope, down-slope.
   39                        	;
   40                        	; Typically this flag information is set by the map conversion tools from a
   41                        	; seperate "collision" map layer.
   42                        	;
   43                        	
   44               0000     		.ifndef	CHRMAP_BAT_FLAG
   46                        		.endif
   47                        	
   48                        	;
   49                        	;
   50                        	;
   51                        	
   52                        	
   53                        	
   54    09:DC97             	chrmap_group	.procgroup
   55                        	
   56                        	; ***************************************************************************
   57                        	; ***************************************************************************
   58                        	;
   59                        	; _draw_bat - Draw the entire screen at the current coordinates.
   60                        	; _sgx_draw_bat - Draw the entire screen at the current coordinates.
   61                        	;
   62                        	; void __fastcall draw_bat( void );
   63                        	; void __fastcall sgx_draw_bat( void );
   64                        	;
   65                        	
   66               0001     		.if	SUPPORT_SGX
   67                        	
   68                        	_sgx_draw_bat	.proc
   74                        			.endp
   75                        		.endif
   76                        	
   77    09:DC97             	_draw_bat	.proc
   78                        	
   79    09:DC97  82         			clx				; Offset to PCE VDC.
   80                        	
   81    09:DC98  43 08      			tma3				; Preserve MPR3..MPR5.
   82    09:DC9A  48         			pha
   83    09:DC9B  43 10      			tma4
   84    09:DC9D  48         			pha
   85    09:DC9E  43 20      			tma5
   86    09:DCA0  48         			pha
   87                        	
   88    09:DCA1  20 44 DD   			jsr	bat_pxl_2_chr		; Set up the draw coordinates.
   89                        	
   90    09:DCA4  A5 FC      			lda	<map_chr_x		; Reset previous X position.
   91    09:DCA6  9D 78 2A   			sta	vdc_old_chr_x, x
   92                        	
   93    09:DCA9  A5 FE      			lda	<map_chr_y		; Reset previous Y position,
   94    09:DCAB  1A         			inc	a			; ready to draw rows upwards.
   95    09:DCAC  9D 79 2A   			sta	vdc_old_chr_y, x
   96                        	
   97    09:DCAF  BD 41 25   			lda	vdc_map_draw_w, x	; Draw the whole screen.
   98    09:DCB2  85 FA      			sta	<map_draw_w
   99    09:DCB4  BD 42 25   			lda	vdc_map_draw_h, x
  100    09:DCB7  85 FB      			sta	<map_draw_h
  101                        	
  102    09:DCB9  20 27 DE   			jsr	bat_scroll_y		; Draw N row of CHR to the BAT.
  103                        	
  104    09:DCBC  68         			pla				; Restore MPR3..MPR5.
  105    09:DCBD  53 20      			tam5
  106    09:DCBF  68         			pla
  107    09:DCC0  53 10      			tam4
  108    09:DCC2  68         			pla
  109    09:DCC3  53 08      			tam3
  110                        	
  111                        			leave
         09:DCC5  4C EF FF   			jmp	leave_proc
  112                        	
  113                        			.endp
  114                        	
  115                        	
  116                        	
  117                        	; ***************************************************************************
  118                        	; ***************************************************************************
  119                        	;
  120                        	; _scroll_bat - Draw a single row of CHR into the BAT to update the edge.
  121                        	; _sgx_scroll_bat - Draw a single row of CHR into the BAT to update the edge.
  122                        	;
  123                        	; void __fastcall scroll_bat( void );
  124                        	; void __fastcall sgx_scroll_bat( void );
  125                        	;
  126                        	
  127               0001     		.if	SUPPORT_SGX
  128                        	
  129                        	_sgx_scroll_bat	.proc
  135                        			.endp
  136                        		.endif
  137                        	
  138    09:DCC8             	_scroll_bat	.proc
  139                        	
  140    09:DCC8  82         			clx				; Offset to PCE VDC.
  141                        	
  142    09:DCC9  43 08      			tma3				; Preserve MPR3..MPR5.
  143    09:DCCB  48         			pha
  144    09:DCCC  43 10      			tma4
  145    09:DCCE  48         			pha
  146    09:DCCF  43 20      			tma5
  147    09:DCD1  48         			pha
  148                        	
  149    09:DCD2  20 44 DD   			jsr	bat_pxl_2_chr		; Set up the draw coordinates.
  150                        	
  151    09:DCD5  BD 42 25   			lda	vdc_map_draw_h, x	; Draw new LHS or RHS if needed.
  152    09:DCD8  85 FB      			sta	<map_draw_h
  153                        	;		lda	#1			; bat_scroll_x only ever draws a
  154                        	;		sta	<map_draw_w		; single column.
  155    09:DCDA  20 68 DD   			jsr	bat_scroll_x
  156                        	
  157    09:DCDD  BD 78 2A   			lda	vdc_old_chr_x, x	; Restore map_chr_x which could
  158    09:DCE0  85 FC      			sta	<map_chr_x		; be changed by bat_scroll_x.
  159                        	
  160    09:DCE2  BD 41 25   			lda	vdc_map_draw_w, x	; Draw new TOP or BTM if needed.
  161    09:DCE5  85 FA      			sta	<map_draw_w
  162    09:DCE7  A9 01      			lda	#1
  163    09:DCE9  85 FB      			sta	<map_draw_h
  164    09:DCEB  20 27 DE   			jsr	bat_scroll_y
  165                        	
  166    09:DCEE  68         			pla				; Restore MPR3..MPR5.
  167    09:DCEF  53 20      			tam5
  168    09:DCF1  68         			pla
  169    09:DCF2  53 10      			tam4
  170    09:DCF4  68         			pla
  171    09:DCF5  53 08      			tam3
  172                        	
  173                        			leave
         09:DCF7  4C EF FF   			jmp	leave_proc
  174                        	
  175                        			.endp
  176                        	
  177                        	
  178                        	
  179                        	; ***************************************************************************
  180                        	; ***************************************************************************
  181                        	;
  182                        	; _blit_bat - Draw a map rectangle to specific BAT coordinates.
  183                        	; _sgx_blit_bat - Draw a map rectangle to specific BAT coordinates.
  184                        	;
  185                        	; void __fastcall blit_bat( unsigned char tile_x<map_bat_x>, unsigned char tile_y<map_bat_y>, unsigned char tile_w<map_draw_x>, unsigned char tile_h<map_draw_y> );
  186                        	; void __fastcall sgx_blit_bat( unsigned char tile_x<map_bat_x>, unsigned char tile_y<map_bat_y>, unsigned char tile_w<map_draw_x>, unsigned char tile_h<map_draw_y> );
  187                        	;
  188                        	; Normally you'd just use _draw_bat() and _scroll_bat(), but for those folks
  189                        	; who really wish to take manual control, you can use this.
  190                        	;
  191                        	
  192               0001     		.if	SUPPORT_SGX
  193                        	
  194                        	_sgx_blit_bat	.proc
  200                        			.endp
  201                        		.endif
  202                        	
  203    09:DCFA             	_blit_bat	.proc
  204                        	
  205    09:DCFA  82         			clx				; Offset to PCE VDC.
  206                        	
  207    09:DCFB  43 08      			tma3				; Preserve MPR3..MPR5.
  208    09:DCFD  48         			pha
  209    09:DCFE  43 10      			tma4
  210    09:DD00  48         			pha
  211    09:DD01  43 20      			tma5
  212    09:DD03  48         			pha
  213                        	
  214    09:DD04  BD 49 25   			lda	vdc_map_option, x	; Preserve current map options.
  215    09:DD07  48         			pha
  216    09:DD08  09 C0      			ora	#MAP_UNALIGNED_X | MAP_UNALIGNED_Y
  217    09:DD0A  9D 49 25   			sta	vdc_map_option, x
  218                        	
  219    09:DD0D  20 44 DD   			jsr	bat_pxl_2_chr		; Set up the draw coordinates.
  220                        	
  221    09:DD10  A5 FA      			lda	<map_draw_w		; Are we drawing just 1 column?
  222    09:DD12  C9 01      			cmp	#1
  223    09:DD14  F0 1E      			beq	.draw_column
  224                        	
  225                        			; Draw N rows.
  226                        	
  227    09:DD16  A5 FC      	.draw_rows:	lda	<map_chr_x		; Reset previous X position.
  228    09:DD18  9D 78 2A   			sta	vdc_old_chr_x, x
  229                        	
  230    09:DD1B  A5 FE      			lda	<map_chr_y		; Reset previous Y position,
  231    09:DD1D  1A         			inc	a			; ready to draw rows upwards.
  232    09:DD1E  9D 79 2A   			sta	vdc_old_chr_y, x
  233                        	
  234    09:DD21  20 27 DE   			jsr	bat_scroll_y		; Draw a row of CHR to the BAT.
  235                        	
  236                        			; Drawing completed.
  237                        	
  238    09:DD24  68         	.finished:	pla				; Restore previous map options.
  239    09:DD25  9D 49 25   			sta	vdc_map_option, x
  240                        	
  241    09:DD28  68         			pla				; Restore MPR3..MPR5.
  242    09:DD29  53 20      			tam5
  243    09:DD2B  68         			pla
  244    09:DD2C  53 10      			tam4
  245    09:DD2E  68         			pla
  246    09:DD2F  53 08      			tam3
  247                        	
  248                        	.exit:		leave
         09:DD31  4C EF FF   			jmp	leave_proc
  249                        	
  250                        			; Draw 1 column.
  251                        	
  252    09:DD34  A5 FC      	.draw_column:	lda	<map_chr_x		; Reset previous X position.
  253    09:DD36  1A         			inc	a			; ready to draw 1 column.
  254    09:DD37  9D 78 2A   			sta	vdc_old_chr_x, x
  255                        	
  256    09:DD3A  A5 FE      			lda	<map_chr_y		; Reset previous Y position.
  257    09:DD3C  9D 79 2A   			sta	vdc_old_chr_y, x
  258                        	
  259    09:DD3F  20 68 DD   			jsr	bat_scroll_x		; Draw a single column of CHR.
  260                        	
  261    09:DD42  80 E0      			bra	.finished
  262                        	
  263                        			.endp
  264                        	
  265                        	
  266                        	
  267                        	; ***************************************************************************
  268                        	; ***************************************************************************
  269                        	;
  270                        	
  271    09:DD44  BD 45 25   	bat_pxl_2_chr:	lda.l	vdc_map_pxl_x, x	; Get current map X coordinate.
  272    09:DD47  85 FC      			sta.l	<map_pxl_x
  273    09:DD49  BD 46 25   			lda.h	vdc_map_pxl_x, x	; Xvert map_pxl_x to map_chr_x.
  274    09:DD4C  4A         			lsr	a
  275    09:DD4D  66 FC      			ror.l	<map_pxl_x
  276    09:DD4F  4A         			lsr	a
  277    09:DD50  66 FC      			ror.l	<map_pxl_x
  278    09:DD52  4A         			lsr	a
  279    09:DD53  66 FC      			ror.l	<map_pxl_x		; Max map width is 256 CHR.
  280                        	
  281    09:DD55  BD 47 25   			lda.l	vdc_map_pxl_y, x	; Get current map Y coordinate.
  282    09:DD58  85 FE      			sta.l	<map_pxl_y
  283    09:DD5A  BD 48 25   			lda.h	vdc_map_pxl_y, x	; Xvert map_pxl_y to map_chr_y.
  284    09:DD5D  4A         			lsr	a
  285    09:DD5E  66 FE      			ror.l	<map_pxl_y
  286    09:DD60  4A         			lsr	a
  287    09:DD61  66 FE      			ror.l	<map_pxl_y
  288    09:DD63  4A         			lsr	a
  289    09:DD64  66 FE      			ror.l	<map_pxl_y		; Max map width is 256 CHR.
  290                        	
  291    09:DD66  60         			rts
  292                        	
  293                        	
  294                        	
  295                        	; ***************************************************************************
  296                        	; ***************************************************************************
  297                        	;
  298                        	; bat_scroll_x - Update the BAT when X coordinate changes.
  299                        	;
  300                        	; N.B. This only ever draws a single column!
  301                        	;
  302                        	
  303    09:DD67  60         	!no_change:	rts
  304                        	
  305    09:DD68  A5 FC      	bat_scroll_x:	lda	<map_chr_x		; Compare old_x with cur_x.
  306    09:DD6A  DD 78 2A   			cmp	vdc_old_chr_x, x
  307    09:DD6D  F0 F8      			beq	!no_change-		; Do nothing if no change.
  308    09:DD6F  9D 78 2A   			sta	vdc_old_chr_x, x
  309    09:DD72  30 05      			bmi	.moved			; Test the sign of the change.
  310                        	
  311    09:DD74  18         			clc				; Draw RHS if chr_x >= old_x.
  312    09:DD75  7D 41 25   			adc	vdc_map_draw_w, x	; Usually (SCR_WIDTH / 8) + 1.
  313    09:DD78  3A         			dec	a
  314                        	
  315    09:DD79  48         	.moved:		pha				; Push chr_x in map section.
  316                        	
  317    09:DD7A  3C 49 25   			bit	vdc_map_option, x	; Set bit7 to disable aligning
  318    09:DD7D  30 05      			bmi	!+			; BAT X with the map X.
  319    09:DD7F  3D 3E 25   			and	vdc_bat_x_mask, x
  320    09:DD82  85 F8      			sta	<map_bat_x		; Save BAT X chr coordinate.
  321                        	
  322    09:DD84  A5 FE      	!:		lda	<map_chr_y		; Y = chr_y in map section.
  323    09:DD86  A8         			tay
  324                        	
  325    09:DD87  3C 49 25   			bit	vdc_map_option, x	; Set bit6 to disable aligning
  326    09:DD8A  70 05      			bvs	!+			; BAT Y with the map Y.
  327    09:DD8C  3D 3F 25   			and	vdc_bat_y_mask, x
  328    09:DD8F  85 F9      			sta	<map_bat_y		; Save BAT Y chr coordinate.
  329                        	
  330               0000     		.if	FAST_MULTIPLY
  333                        		.endif
  334                        	
  335    09:DD91  BD 43 25   	!:		lda	vdc_map_line_w, x	; Map width in CHR (0 == 256).
  336    09:DD94  D0 05      			bne	!+
  337                        	
  338    09:DD96  64 EE      			stz.l	<map_line		; Multiply by 256 is easy!
  339    09:DD98  98         			tya
  340    09:DD99  80 15      			bra	.double
  341                        	
  342               0000     		.if	FAST_MULTIPLY
  354                        		.else
  355    09:DD9B  84 EF      	!:		sty.h	<map_line		; Takes 144..176 cycles.
  356    09:DD9D  A0 08      			ldy	#8
  357    09:DD9F  4A         			lsr	a
  358    09:DDA0  85 EE      			sta.l	<map_line
  359    09:DDA2  62         			cla
  360    09:DDA3  90 03      			bcc	.rotate
  361    09:DDA5  18         	.add:		clc
  362    09:DDA6  65 EF      			adc.h	<map_line
  363    09:DDA8  6A         	.rotate:	ror	a
  364    09:DDA9  66 EE      			ror.l	<map_line		; Lo-byte of (CHR Y * width).
  365    09:DDAB  88         			dey
  366    09:DDAC  B0 F7      			bcs	.add
  367    09:DDAE  D0 F8      			bne	.rotate
  368                        		.endif
  369                        	
  370    09:DDB0  06 EE      	.double:	asl.l	<map_line		; Lo-byte of (CHR Y * width * 2).
  371    09:DDB2  2A         			rol	a
  372    09:DDB3  A8         			tay				; Hi-byte of (CHR Y * width * 2).
  373                        	
  374    09:DDB4  BD 82 2A   			lda	vdc_map_bank, x		; Put the MAP into MPR3-MPR5.
  375    09:DDB7  53 08      			tam3				; Allow for 16KByte chrmap.
  376    09:DDB9  1A         			inc	a
  377    09:DDBA  53 10      			tam4
  378    09:DDBC  1A         			inc	a
  379    09:DDBD  53 20      			tam5
  380                        	
  381    09:DDBF  68         			pla				; Pop chr_x in map section.
  382    09:DDC0  0A         			asl	a			; 2-bytes for a BAT value.
  383    09:DDC1  90 02      			bcc	!+
  384    09:DDC3  C8         			iny				; Hi-byte of (CHR Y * width * 2).
  385    09:DDC4  18         			clc
  386    09:DDC5  65 EE      	!:		adc.l	<map_line		; Lo-byte of (CHR Y * width * 2).
  387    09:DDC7  90 01      			bcc	!+
  388    09:DDC9  C8         			iny
  389                        	
  390    09:DDCA  18         	!:		clc				; Calc map data pointer.
  391    09:DDCB  7D 80 2A   			adc.l	vdc_map_addr, x
  392    09:DDCE  85 EC      			sta.l	<_bp			; Maximum map size is 16KBytes
  393    09:DDD0  98         			tya				; so we don't need to consider
  394    09:DDD1  7D 81 2A   			adc.h	vdc_map_addr, x		; bank overflow.
  395    09:DDD4  85 ED      			sta.h	<_bp
  396                        	
  397    09:DDD6  C2         			cly				; Calculate the map line delta
  398    09:DDD7  BD 43 25   			lda	vdc_map_line_w, x	; in bytes.
  399    09:DDDA  D0 01      			bne	!+
  400    09:DDDC  C8         			iny
  401    09:DDDD  0A         	!:		asl	a
  402    09:DDDE  85 EE      			sta.l	<map_line
  403    09:DDE0  98         			tya
  404    09:DDE1  2A         			rol	a
  405    09:DDE2  85 EF      			sta.h	<map_line
  406                        	
  407                        			; Draw the first part of the column.
  408                        	
  409    09:DDE4  A5 F8      	.draw_col:	lda	<map_bat_x		; Set the BAT VRAM destination
  410    09:DDE6  85 F0      			sta.l	<_di			; coordinates.
  411    09:DDE8  A5 F9      			lda	<map_bat_y
  412    09:DDEA  85 F1      			sta.h	<_di
  413                        	
  414    09:DDEC  5D 3F 25   			eor	vdc_bat_y_mask, x	; Calc CHR before wrap.
  415    09:DDEF  1A         			inc	a
  416    09:DDF0  C5 FB      			cmp	<map_draw_h		; Usually (SCR_HEIGHT / 8) + 1.
  417    09:DDF2  90 02      			bcc	!+
  418    09:DDF4  A5 FB      			lda	<map_draw_h		; Maximum CHR to draw.
  419    09:DDF6  85 00      	!:		sta	<map_count		; Set number of CHR to draw.
  420    09:DDF8  85 01      			sta	<map_drawn		; Preserve number of CHR drawn.
  421                        	
  422    09:DDFA  A9 05      			lda	#VDC_CR			; Set VDC auto-increment from
  423    09:DDFC  95 F7      			sta	<vdc_reg, x		; the BAT width, which is set
  424    09:DDFE  9D 00 02   			sta	VDC_AR, x		; up by set_screen_size().
  425    09:DE01  B5 F4      			lda	<vdc_crh, x
  426    09:DE03  9D 03 02   			sta	VDC_DH, x
  427                        	
  428    09:DE06  20 08 DF   			jsr	bat_col_strip		; Draw top of vertical strip.
  429                        	
  430                        			; Wrap around and draw the rest of the column (if needed).
  431                        	
  432    09:DE09  38         			sec				; Are there any more CHR that
  433    09:DE0A  A5 FB      			lda	<map_draw_h		; need to be drawn?
  434    09:DE0C  E5 01      			sbc	<map_drawn
  435    09:DE0E  F0 0B      			beq	.done
  436                        	
  437    09:DE10  85 00      			sta	<map_count		; Set number of CHR to draw.
  438                        	
  439    09:DE12  A5 F8      			lda	<map_bat_x		; Set the BAT VRAM destination
  440    09:DE14  85 F0      			sta.l	<_di			; coordinates.
  441    09:DE16  64 F1      			stz.h	<_di			; Reset 1st row to draw.
  442                        	
  443    09:DE18  20 08 DF   			jsr	bat_col_strip		; Draw btm of vertical strip.
  444                        	
  445    09:DE1B  A9 05      	.done:		lda	#VDC_CR			; Set VDC auto-increment to 1.
  446    09:DE1D  95 F7      			sta	<vdc_reg, x
  447    09:DE1F  9D 00 02   			sta	VDC_AR, x
  448    09:DE22  9E 03 02   			stz	VDC_DH, x
  449                        	
  450    09:DE25  60         			rts
  451                        	
  452                        	
  453                        	
  454                        	; ***************************************************************************
  455                        	; ***************************************************************************
  456                        	;
  457                        	; bat_scroll_y - Update the BAT when Y coordinate changes.
  458                        	;
  459                        	; N.B. This draws multiple rows when called from _draw_bat or _blit_bat.
  460                        	;
  461                        	
  462    09:DE26  60         	!no_change:	rts
  463                        	
  464    09:DE27  A5 FE      	bat_scroll_y:	lda	<map_chr_y		; Compare old_y with cur_y.
  465    09:DE29  DD 79 2A   			cmp	vdc_old_chr_y, x
  466    09:DE2C  F0 F8      			beq	!no_change-		; Do nothing if no change.
  467    09:DE2E  9D 79 2A   			sta	vdc_old_chr_y, x
  468    09:DE31  30 05      			bmi	.moved			; Test the sign of the change.
  469                        	
  470    09:DE33  18         			clc				; Draw bottom if chr_y >= old_y.
  471    09:DE34  7D 42 25   			adc	vdc_map_draw_h, x	; Usually (SCR_HEIGHT / 8) + 1.
  472    09:DE37  3A         			dec	a
  473                        	
  474    09:DE38  A8         	.moved:		tay				; Y = chr_y in map section.
  475                        	
  476    09:DE39  3C 49 25   			bit	vdc_map_option, x	; Set bit6 to disable aligning
  477    09:DE3C  70 05      			bvs	!+			; BAT Y with the map Y.
  478    09:DE3E  3D 3F 25   			and	vdc_bat_y_mask, x
  479    09:DE41  85 F9      			sta	<map_bat_y		; Save BAT Y chr coordinate.
  480                        	
  481    09:DE43  3C 49 25   	!:		bit	vdc_map_option, x	; Set bit7 to disable aligning
  482    09:DE46  30 07      			bmi	!+			; BAT X with the map X.
  483    09:DE48  A5 FC      			lda	<map_chr_x
  484    09:DE4A  3D 3E 25   			and	vdc_bat_x_mask, x
  485    09:DE4D  85 F8      			sta	<map_bat_x		; Save BAT X chr coordinate.
  486                        	
  487               0000     		.if	FAST_MULTIPLY
  490                        		.endif
  491                        	
  492    09:DE4F  BD 43 25   	!:		lda	vdc_map_line_w, x	; Map width in CHR (0 == 256).
  493    09:DE52  D0 05      			bne	!+
  494                        	
  495    09:DE54  64 EE      			stz.l	<map_line		; Multiply by 256 is easy!
  496    09:DE56  98         			tya
  497    09:DE57  80 15      			bra	.double
  498                        	
  499               0000     		.if	FAST_MULTIPLY
  511                        		.else
  512    09:DE59  84 EF      	!:		sty.h	<map_line		; Takes 144..176 cycles.
  513    09:DE5B  A0 08      			ldy	#8
  514    09:DE5D  4A         			lsr	a
  515    09:DE5E  85 EE      			sta.l	<map_line
  516    09:DE60  62         			cla
  517    09:DE61  90 03      			bcc	.rotate
  518    09:DE63  18         	.add:		clc
  519    09:DE64  65 EF      			adc.h	<map_line
  520    09:DE66  6A         	.rotate:	ror	a
  521    09:DE67  66 EE      			ror.l	<map_line		; Lo-byte of (CHR Y * width).
  522    09:DE69  88         			dey
  523    09:DE6A  B0 F7      			bcs	.add
  524    09:DE6C  D0 F8      			bne	.rotate
  525                        		.endif
  526                        	
  527    09:DE6E  06 EE      	.double:	asl.l	<map_line		; Lo-byte of (CHR Y * width * 2).
  528    09:DE70  2A         			rol	a
  529    09:DE71  85 EF      			sta.h	<map_line		; Hi-byte of (CHR Y * width * 2).
  530    09:DE73  A8         			tay
  531                        	
  532    09:DE74  BD 82 2A   			lda	vdc_map_bank, x		; Put the MAP into MPR3-MPR5.
  533    09:DE77  53 08      			tam3				; Allow for 16KByte chrmap.
  534    09:DE79  1A         			inc	a
  535    09:DE7A  53 10      			tam4
  536    09:DE7C  1A         			inc	a
  537    09:DE7D  53 20      			tam5
  538                        	
  539                        			; Loop to here if drawing multiple rows.
  540                        	
  541    09:DE7F  A5 FC      	.next_row:	lda	<map_chr_x		; Map CHR X coordinate.
  542    09:DE81  0A         			asl	a			; 2-bytes for a BAT value!
  543    09:DE82  90 02      			bcc	!+
  544    09:DE84  C8         			iny				; Hi-byte of (CHR Y * width * 2).
  545    09:DE85  18         			clc
  546    09:DE86  65 EE      	!:		adc.l	<map_line		; Lo-byte of (CHR Y * width * 2).
  547    09:DE88  90 01      			bcc	!+
  548    09:DE8A  C8         			iny
  549    09:DE8B  18         	!:		clc				; Calc map data pointer.
  550    09:DE8C  7D 80 2A   			adc.l	vdc_map_addr, x
  551    09:DE8F  85 EC      			sta.l	<_bp			; Maximum map size is 16KBytes
  552    09:DE91  98         			tya				; so we don't need to consider
  553    09:DE92  7D 81 2A   			adc.h	vdc_map_addr, x		; bank overflow.
  554    09:DE95  85 ED      			sta.h	<_bp
  555                        	
  556                        			; Draw the first part of the row.
  557                        	
  558    09:DE97  A5 F9      	.draw_row:	lda	<map_bat_y		; Set the BAT VRAM destination
  559    09:DE99  85 F1      			sta.h	<_di			; coordinates.
  560    09:DE9B  A5 F8      			lda	<map_bat_x
  561    09:DE9D  85 F0      			sta.l	<_di
  562                        	
  563    09:DE9F  5D 3E 25   			eor	vdc_bat_x_mask, x	; Calc CHR before wrap.
  564    09:DEA2  1A         			inc	a
  565    09:DEA3  C5 FA      			cmp	<map_draw_w		; Usually (SCR_WIDTH / 8) + 1.
  566    09:DEA5  90 02      			bcc	!+
  567    09:DEA7  A5 FA      			lda	<map_draw_w		; Maximum CHR to draw.
  568    09:DEA9  85 00      	!:		sta	<map_count		; Set number of CHR to draw.
  569    09:DEAB  85 01      			sta	<map_drawn		; Preserve number of CHR drawn.
  570                        	
  571    09:DEAD  20 E7 DE   			jsr	bat_row_strip		; Draw lhs of horizontal strip.
  572                        	
  573                        			; Wrap around and draw the rest of the row (if needed).
  574                        	
  575    09:DEB0  38         			sec				; Are there any more CHR that
  576    09:DEB1  A5 FA      			lda	<map_draw_w		; need to be drawn?
  577    09:DEB3  E5 01      			sbc	<map_drawn
  578    09:DEB5  F0 0B      			beq	.done_row
  579                        	
  580    09:DEB7  85 00      			sta	<map_count		; Set number of CHR to draw.
  581                        	
  582    09:DEB9  A5 F9      			lda	<map_bat_y		; Set the BAT VRAM destination
  583    09:DEBB  85 F1      			sta.h	<_di			; coordinates.
  584    09:DEBD  64 F0      			stz.l	<_di			; Reset 1st column to draw.
  585                        	
  586    09:DEBF  20 E7 DE   			jsr	bat_row_strip		; Draw rhs of horizontal strip.
  587                        	
  588    09:DEC2  C6 FB      	.done_row:	dec	<map_draw_h		; Are all desired rows drawn?
  589    09:DEC4  F0 20      			beq	.finished
  590                        	
  591    09:DEC6  A5 F9      			lda	<map_bat_y		; Move BAT Y down by 1.
  592    09:DEC8  1A         			inc	a
  593    09:DEC9  3D 3F 25   			and	vdc_bat_y_mask, x
  594    09:DECC  85 F9      			sta	<map_bat_y
  595                        	
  596    09:DECE  A4 EF      			ldy.h	<map_line		; Move the map line pointer to
  597    09:DED0  C8         			iny				; the next line.
  598    09:DED1  BD 43 25   			lda	vdc_map_line_w, x
  599    09:DED4  F0 0B      			beq	!++			; vdc_map_line_w == 0 == 256.
  600    09:DED6  0A         			asl	a			; 2-bytes for a BAT value!
  601    09:DED7  B0 01      			bcs	!+
  602    09:DED9  88         			dey				; Fix if vdc_map_line_w <= 127.
  603    09:DEDA  18         	!:		clc
  604    09:DEDB  65 EE      			adc.l	<map_line
  605    09:DEDD  85 EE      			sta.l	<map_line
  606    09:DEDF  90 01      			bcc	!++
  607    09:DEE1  C8         	!:		iny
  608    09:DEE2  84 EF      	!:		sty.h	<map_line		; Needed for .next_row!
  609                        	
  610    09:DEE4  80 99      			bra	.next_row		; Draw next row.
  611                        	
  612    09:DEE6  60         	.finished:	rts
  613                        	
  614                        	
  615                        	
  616                        	; ***************************************************************************
  617                        	; ***************************************************************************
  618                        	;
  619                        	; bat_row_strip - Draw a single row of CHR into the BAT.
  620                        	;
  621                        	
  622    09:DEE7  20 34 E4   	bat_row_strip:	jsr	set_di_xy_mawr		; Set the BAT VRAM destination.
  623                        	
  624    09:DEEA  C2         			cly				; 2
  625    09:DEEB  B1 EC      	.repeat:	lda	[_bp], y		; 7
  626    09:DEED  9D 02 02   			sta	VDC_DL, x		; 6
  627    09:DEF0  C8         			iny				; 2
  628    09:DEF1  B1 EC      			lda	[_bp], y		; 7
  629               0000     		.if	CHRMAP_BAT_FLAG
  634                        		.endif
  635    09:DEF3  9D 03 02   			sta	VDC_DH, x		; 6
  636    09:DEF6  C8         			iny				; 2
  637                        	
  638    09:DEF7  C6 00      	!:		dec	<map_count		; 6
  639    09:DEF9  D0 F0      			bne	.repeat			; 4
  640                        	
  641    09:DEFB  98         			tya				; 2
  642    09:DEFC  F0 07      			beq	!+			; 2/4
  643    09:DEFE  18         			clc				; 2
  644    09:DEFF  65 EC      			adc.l	<_bp			; 4
  645    09:DF01  85 EC      			sta.l	<_bp			; 4
  646    09:DF03  90 02      			bcc	.done			; 2/4
  647    09:DF05  E6 ED      	!:		inc.h	<_bp			; 6
  648                        	
  649    09:DF07  60         	.done:		rts
  650                        	
  651                        	
  652                        	
  653                        	; ***************************************************************************
  654                        	; ***************************************************************************
  655                        	;
  656                        	; bat_col_strip - Draw a single column of CHR into the BAT.
  657                        	;
  658                        	
  659    09:DF08  20 34 E4   	bat_col_strip:	jsr	set_di_xy_mawr		; Set the BAT VRAM destination.
  660                        	
  661    09:DF0B  A0 01      			ldy	#1			; 2
  662    09:DF0D  B2 EC      	.repeat:	lda	[_bp]			; 7
  663    09:DF0F  9D 02 02   			sta	VDC_DL, x		; 6
  664    09:DF12  B1 EC      			lda	[_bp], y		; 7
  665               0000     		.if	CHRMAP_BAT_FLAG
  670                        		.endif
  671    09:DF14  9D 03 02   			sta	VDC_DH, x		; 6
  672                        	
  673    09:DF17  18         			clc				; 2
  674    09:DF18  A5 EE      			lda.l	<map_line		; 4
  675    09:DF1A  65 EC      			adc.l	<_bp			; 4
  676    09:DF1C  85 EC      			sta.l	<_bp			; 4
  677    09:DF1E  A5 EF      			lda.h	<map_line		; 4
  678    09:DF20  65 ED      			adc.h	<_bp			; 4
  679    09:DF22  85 ED      			sta.h	<_bp			; 4
  680                        	
  681    09:DF24  C6 00      			dec	<map_count		; 6
  682    09:DF26  D0 E5      			bne	.repeat			; 4
  683                        	
  684    09:DF28  60         			rts
  685                        	
  686                        		.endprocgroup	; chrmap_group
                             #[2]   "..\..\..\include\hucc\hucc-final.asm"
   88                        		.endif	HUCC_USES_CHRMAP
   89                        	
   90               0001     		.ifdef	HUCC_USES_OLD_LINE		; Set in hucc_old_line.h
                             #[3]   "..\..\..\include\hucc\hucc-old-line.asm"
   91                        			include	"hucc-old-line.asm"
    1                        	; ***************************************************************************
    2                        	; ***************************************************************************
    3                        	;
    4                        	; hucc-old-line.asm
    5                        	;
    6                        	; Based on the original HuC and MagicKit functions by David Michel and the
    7                        	; other original HuC developers.
    8                        	;
    9                        	; Modifications copyright John Brandwood 2024-2025.
   10                        	;
   11                        	; Distributed under the Boost Software License, Version 1.0.
   12                        	; (See accompanying file LICENSE_1_0.txt or copy at
   13                        	;  http://www.boost.org/LICENSE_1_0.txt)
   14                        	;
   15                        	; ***************************************************************************
   16                        	; ***************************************************************************
   17                        	
   18                        	
   19                        	
   20                        	; ***************************************************************************
   21                        	; ***************************************************************************
   22                        	;
   23                        	; void __fastcall gfx_init( unsigned int start_vram_addr<_ax> );
   24                        	;
   25                        	; initialize graphics mode
   26                        	; - points graphics map to tiles at start_vram_addr
   27                        	
   28                        	_gfx_init.1	.proc
   73                        			.endp
   74                        	
   75                        	
   76                        	
   77                        	; ***************************************************************************
   78                        	; ***************************************************************************
   79                        	;
   80                        	; void __fastcall gfx_clear( unsigned int start_vram_addr<_di> );
   81                        	;
   82                        	; Clear the values in the graphics tiles
   83                        	; - places zeroes in graphics tiles at start_vram_addr
   84                        	
   85                        	_gfx_clear.1	.proc
  105                        			.endp
  106                        	
  107                        	
  108                        	
  109                        	; ***************************************************************************
  110                        	; ***************************************************************************
  111                        	;
  112                        	; void __fastcall gfx_line( unsigned int x1<_gfx_x1>, unsigned int y1<_gfx_y1>, unsigned int x2<_gfx_x2>, unsigned int y2<_gfx_y2>, unsigned char color<_gfx_color> );
  113                        	
  114                        	huc_gfx_line	.procgroup
  459                        			.endprocgroup	; huc_gfx_line
                             #[2]   "..\..\..\include\hucc\hucc-final.asm"
   92                        		.endif
   93                        	
   94               0000     		.ifdef	HUCC_USES_ZX0			; Set in hucc_zx0.h
   96                        		.endif
   97                        	
   98                        	
   99                        	
  100                        	; ***************************************************************************
  101                        	; ***************************************************************************
  102                        	;
  103                        	; Check that C "__zp" declarations aren't overwriting System Card variables.
  104                        	;
  105                        	
  106               20A0     			.zp
  107               0000     		.if	(* > zpg_sys_top) || (USING_PSGDRIVER && (* > zpg_psg_top))
  109                        		.endif
  110                        	
  111                        	
  112                        	
  113                        	; ***************************************************************************
  114                        	; ***************************************************************************
  115                        	;
  116                        	; Check that there isn't too much C "const" data in the ".RODATA" section.
  117                        	;
  118                        	
  119               60F6     			.rodata
  120               0000     		.if	(bank(*) - _bank_base) >= (CONST_BANK + 2)
  122                        		.endif
  123               E937     			.code
                             #[1]   "main.s"

PROCEDURE LIST (in order of size):

Size: $151C, Addr: $0E:C820,      .proc _update_PLAYER
Size: $086A, Addr: $01:C0F6, .procgroup blkmap_group
Size: $0417, Addr: $09:D880,      .proc _joypad_DIR
Size: $0390, Addr: $01:C960,      .proc huc_monofont_x
Size: $0379, Addr: $01:CCF0,      .proc _init_LEVEL
Size: $02AD, Addr: $0E:DD3C,      .proc _load_OBJECT_TILES
Size: $0292, Addr: $09:DC97, .procgroup chrmap_group
Size: $0184, Addr: $01:D069,      .proc _check_OBJECTS
Size: $0167, Addr: $01:D1ED,      .proc _scroll_object
Size: $0167, Addr: $01:D354,      .proc _scroll_chest
Size: $0167, Addr: $01:D4BB,      .proc _scroll_npc
Size: $0134, Addr: $01:D622,      .proc _init_OBJECT_LV1
Size: $0108, Addr: $01:D756,      .proc read_joypads
Size: $0107, Addr: $01:D85E,      .proc _recenter_CAMERA
Size: $00DF, Addr: $01:D965, .procgroup vdc_set_mode
Size: $00D4, Addr: $09:DF29,      .proc _joypad_BUTTONS
Size: $00BF, Addr: $01:DA44, .procgroup vdc_tty_out
Size: $00BE, Addr: $01:DB03,      .proc _init_CHEST_LV1
Size: $00BE, Addr: $01:DBC1,      .proc _init_NPC_LV1
Size: $00B5, Addr: $01:DC7F,      .proc _main
Size: $009D, Addr: $01:DD34,      .proc _display_TIME
Size: $0086, Addr: $01:DDD1,      .proc _sgx_scroll_split.5
Size: $0081, Addr: $01:DE57,      .proc vbl_init_scroll
Size: $007A, Addr: $01:DED8,      .proc _check_TILE_DEPTH
Size: $0077, Addr: $01:DF52,      .proc core_main
Size: $006A, Addr: $02:C000, .procgroup load_vram_group
Size: $0064, Addr: $02:C06A,      .proc _check_BG
Size: $0062, Addr: $02:C0CE,      .proc _init_256x224
Size: $004B, Addr: $02:C130, .procgroup hucc_memcmp
Size: $004B, Addr: $02:C17B, .procgroup old_satb_group
Size: $0043, Addr: $02:C1C6, .procgroup vdc_clear_vram
Size: $0043, Addr: $02:C209,      .proc sgx_detect
Size: $003F, Addr: $02:C24C, .procgroup load_bat_group
Size: $003E, Addr: $02:C28B,      .proc _vram2vram.3
Size: $003B, Addr: $02:C2C9,      .proc init_random
Size: $002E, Addr: $01:DFC9,      .proc _scroll_BG
Size: $002B, Addr: $02:C304,      .proc _load_palette.3
Size: $0028, Addr: $02:C32F,      .proc _init_VARIABLES
Size: $0025, Addr: $02:C357,      .proc _load_CHEST_TILES
Size: $0025, Addr: $02:C37C,      .proc _load_NPC_TILES
Size: $001E, Addr: $02:C3A1,      .proc _init_PLAYER
Size: $001C, Addr: $02:C3BF,      .proc clear_vce
Size: $001A, Addr: $02:C3DB,      .proc _display_KEY
Size: $001A, Addr: $02:C3F5,      .proc _display_POTION
Size: $001A, Addr: $02:C40F,      .proc _display_ZENNY
