                             #[1]   "main.s"
   27                        	
   28               0010     	CORE_VERSION	=	$10			; Version 1.0
   29                        	
   30                        			; Get the user program's configuration settings, this will
   31                        			; be read from the current directory, if it exists, or the
   32                        			; "../include/" directory if not.
   33                        	
                             #[4]   "..\..\..\include\hucc\core-config.inc"
   34                        			include	"core-config.inc"
    1                        	; ***************************************************************************
    2                        	; ***************************************************************************
    3                        	;
    4                        	; core-config.inc
    5                        	;
    6                        	; Configuration settings for the "CORE(not TM)" PC Engine library code.
    7                        	;
    8                        	; Copyright John Brandwood 2021-2024.
    9                        	;
   10                        	; Distributed under the Boost Software License, Version 1.0.
   11                        	; (See accompanying file LICENSE_1_0.txt or copy at
   12                        	;  http://www.boost.org/LICENSE_1_0.txt)
   13                        	;
   14                        	; ***************************************************************************
   15                        	; ***************************************************************************
   16                        	;
   17                        	; The idea is that you, a PCE developer, copy this file from the ../include/
   18                        	; directory and into your project's directory, and then customize the values
   19                        	; to suit your particular project.
   20                        	;
   21                        	; Because PCEAS searches the current (i.e. project) directory for an include
   22                        	; file first, then it will find your customized copy of the file rather than
   23                        	; the original copy in the ../include/ directory.
   24                        	;
   25                        	; That means that all of the different overlay programs in your project will
   26                        	; share the same overall library configuration for your game.
   27                        	;
   28                        	; ***************************************************************************
   29                        	; ***************************************************************************
   30                        	
   31                        	;
   32                        	; Are we going to take over MPR7?
   33                        	;
   34                        	; While this is the default for the "CORE(not TM)" library, it is definitely
   35                        	; possible to use the library to build CD-ROM code that runs with the System
   36                        	; Card in MPR7, and with the 1st bank remaining in MPR2.
   37                        	;
   38                        	; N.B. The CD-ROM Stage1 loader runs the library with USING_MPR7=0 while it
   39                        	;      installs the kernel into PCE RAM in MPR1.
   40                        	;
   41                        	
   42               0000     		.ifndef	USING_MPR7
   44                        		.endif
   45                        	
   46                        	;
   47                        	; Are we building a CD-ROM overlay that uses an already-built CD-ROM Stage1
   48                        	; loader to install the library's kernel code into PCE RAM in MPR1?
   49                        	;
   50                        	; If this is set, the library's kernel code will be excluded from the build,
   51                        	; which will save about 1KB-3KB of code space in every overlay program!
   52                        	;
   53                        	; N.B. The CD-ROM Stage1 loader sets USING_STAGE1=0 so it builds correctly.
   54                        	;
   55                        	
   56               0000     		.ifndef	USING_STAGE1
   58                        		.endif
   59                        	
   60                        	;
   61                        	; Are we currently building the CD-ROM Stage1 loader?
   62                        	;
   63                        	; If this is set, the library's startup code does not call the __sound_init
   64                        	; macro because the sound driver code is not usually a part of the kernel.
   65                        	;
   66                        	; N.B. The CD-ROM Stage1 loader sets BUILDING_STAGE1=1 so it builds correctly.
   67                        	;
   68                        	
   69               0000     		.ifndef	BUILDING_STAGE1
   71                        		.endif
   72                        	
   73                        	;
   74                        	; Is the last track of the CD a duplicate of the main ISO data track?
   75                        	;
   76                        	; Most CD games put two copies of the same ISO track on the CD, so that data
   77                        	; can be read from the secondary track if the drive has a problem reading it
   78                        	; it from the primary location.
   79                        	;
   80                        	; If set, the secondary track will be enabled when the library first starts.
   81                        	;
   82                        	
   83               0000     		.ifndef	SUPPORT_2ISO
   85                        		.endif
   86                        	
   87                        	;
   88                        	; Maximum number of directory entries to use from the ISO.
   89                        	;
   90                        	; The fewer that we choose, the less RAM memory we need. A setting of 64 is
   91                        	; a good compromise to use until you are putting lots of files on the ISO.
   92                        	;
   93                        	
   94               0000     		.ifndef	MAX_DIRSIZE
   96                        		.endif
   97                        	
   98                        	;
   99                        	; Use the System Card's PSG driver code instead of a modern alternative
  100                        	; sound driver like a DefleMask or Furnace player?
  101                        	;
  102                        	
  103               0000     		.ifndef	USING_PSGDRIVER
  105                        		.endif
  106                        	
  107                        	;
  108                        	; Support development for the Turbo EverDrive v2?
  109                        	;
  110                        	; This only applies to HuCard programs, but when chosen, the "CORE(not TM)"
  111                        	; kernel is moved from bank 0 to bank 2, and a minimal set of startup code
  112                        	; is put in bank 0.
  113                        	;
  114                        	; This is because the TED2 hardware occupies the whole of bank 0 when it is
  115                        	; activated, and so we need to run with a different bank in MPR7.
  116                        	;
  117                        	
  118               0000     		.ifndef	SUPPORT_TED2
  120                        		.endif
  121                        	
  122                        	;
  123                        	; Support development for the SuperGRAFX?
  124                        	;
  125                        	; This enables SuperGRAFX support in certain library functions.
  126                        	;
  127                        	
  128               0000     		.ifndef	SUPPORT_SGX
  130                        		.endif
  131                        	
  132                        	;
  133                        	; Choose SuperGRAFX VPC initialization mode.
  134                        	;
  135                        	; SGX_PARALLAX=0 (useful when VDC #1 is a fullscreen HUD)
  136                        	;
  137                        	;  FRONT
  138                        	;   SP1 = VDC #1 (pce) sprite pixels
  139                        	;   BG1 = VDC #1 (pce) background pixels
  140                        	;   SP2 = VDC #2 (sgx) sprite pixels
  141                        	;   BG2 = VDC #2 (sgx) background pixels
  142                        	;  BACK
  143                        	;
  144                        	; SGX_PARALLAX=1
  145                        	;
  146                        	;  FRONT
  147                        	;   SP1 = VDC #1 (pce) sprite pixels
  148                        	;   SP2 = VDC #2 (sgx) sprite pixels
  149                        	;   BG1 = VDC #1 (pce) background pixels
  150                        	;   BG2 = VDC #2 (sgx) background pixels
  151                        	;  BACK
  152                        	;
  153                        	
  154               0000     		.ifndef	SGX_PARALLAX
  156                        		.endif
  157                        	
  158                        	;
  159                        	; Support development for the ArcadeCard?
  160                        	;
  161                        	; This enables ArcadeCard support in certain library functions.
  162                        	;
  163                        	
  164               0000     		.ifndef	SUPPORT_ACD
  166                        		.endif
  167                        	
  168                        	;
  169                        	; Support development for the IFU's ADPCM hardware?
  170                        	;
  171                        	; Developers would normally just use the System Card functions for ADPCM, but
  172                        	; enabling this adds alternative functions, and allows ADPCM use on a HuCARD.
  173                        	;
  174                        	
  175               0000     		.ifndef	SUPPORT_ADPCM
  177                        		.endif
  178                        	
  179                        	;
  180                        	; Select which version of the joystick library code to include, only one of
  181                        	; these can be set to '1' ...
  182                        	;
  183                        	; SUPPORT_2BUTTON : Only returns buttons I and II.
  184                        	; SUPPORT_6BUTTON : Read buttons III-VI, but ignore a mouse.
  185                        	; SUPPORT_MOUSE	  : Read mouse, but ignore buttons III-VI.
  186                        	;
  187                        	; It doesn't make sense to design a game the relies on both the 6-button and
  188                        	; the mouse, so the joystick library is optimized for one or the other.
  189                        	;
  190                        	; Note that both those devices are always detected and no conflicts occur,
  191                        	; this just controls reading either buttons III-VI or the Mouse Y-movement.
  192                        	;
  193                        	
  194               0000     		.ifndef	SUPPORT_6BUTTON
  200                        		.endif
  201                        	
  202                        	;
  203                        	; How many joypad/mouse devices should be supported?
  204                        	;
  205                        	; This is normally 5, but can be set to 3 (or lower) in order to speed up
  206                        	; the processing and free up CPU time for other code, which is especially
  207                        	; useful for mouse games.
  208                        	;
  209                        	
  210               0000     		.ifndef	MAX_PADS
  212                        		.endif
  213                        	
  214                        	;
  215                        	; Implement a HuC-compatible seperate array for accumulating joypad presses?
  216                        	;
  217                        	; This is only really needed if your game is not expected to run at 60Hz and
  218                        	; so you will sometimes miss joypad presses.
  219                        	;
  220                        	; Alternatively you can set ACCUMULATE_JOY so that joypad presses are always
  221                        	; accumulated in the normal joytrg array, which is how asm programmers would
  222                        	; normally deal with this situation.
  223                        	;
  224                        	
  225               0000     		.ifndef HUC_JOY_EVENTS
  227                        		.endif
  228                        	
  229                        	;
  230                        	; Should "joytrg" accumulate presses, and so need to be explicitely cleared
  231                        	; after reading, or should it just be the result of the last read?
  232                        	;
  233                        	; This option has no effect if HUC_JOY_EVENTS is non-zero since that option
  234                        	; takes precedence over this one!
  235                        	;
  236                        	
  237               0000     		.ifndef ACCUMULATE_JOY
  239                        		.endif
  240                        	
  241                        	;
  242                        	; The DATA_BANK location needs to be set as early as possible so that library
  243                        	; code is able to put data in there before the total overall size of the code
  244                        	; is known.
  245                        	;
  246                        	; By default, DATA_BANK is the next bank after the CORE_BANK.
  247                        	;
  248                        	; RESERVE_BANKS allows developers to reserve some banks between the CORE_BANK
  249                        	; and the DATA_BANK that they can use however they wish.
  250                        	;
  251                        	; One use for RESERVE_BANKS is to create empty space that PCEAS can use when
  252                        	; it relocates procedures. This provides a way for a developer to group code
  253                        	; together at the start of memory, and leave the maximum number of banks for
  254                        	; loading dynamic data from CD-ROM.
  255                        	;
  256                        	; The KickC environment sets RESERVE_BANKS=1 (or higher) so that there is a
  257                        	; a bank for the permanent C code and static constants.
  258                        	;
  259                        	
  260               0000     		.ifndef	RESERVE_BANKS
  266                        		.endif	RESERVE_BANKS
                             #[3]   "..\..\..\include\hucc\core.inc"
   35                        	
   36                        	;
   37                        	; This is a simple macro to call System Card functions when using MPR7 for
   38                        	; running the "CORE(not TM)" PC Engine library code.
   39                        	;
   40                        	
   41                        	system		.macro
   42                        			ldy     #<\1
   43                        			jsr	call_bios
   44                        			.endm
   45                        	
   46                        	;
   47                        	; This replaces the System Card's ex_setvec, because "call_bios" uses the
   48                        	; Y register.
   49                        	;
   50                        	
   51                        	setvec		.macro
   52                        			php
   53                        			sei
   54                        			lda.l	#\2
   55                        			sta.l	\1
   56                        			lda.h	#\2
   57                        			sta.h	\1
   58                        			plp
   59                        			.endm
   60                        	
   61                        	;
   62                        	; Repurpose this System Card variable, since nmi_hook is never used.
   63                        	;
   64                        	; We'll use it as a vector to a user-supplied sound driver instead.
   65                        	;
   66                        	
   67               2206     	sound_hook	=	nmi_hook		; Sound Driver to run in VBL.
   68                        	
   69                        	;
   70                        	; CORE Zero-Page variables, relative to the System Card's ZP variables.
   71                        	;
   72                        	
   73               0000     		.if	USING_PSGDRIVER
   75                        		.else
   76               20EC     	core_zpend	=	$F8:20EC
   77                        		.endif	USING_PSGDRIVER
   78                        	
   79               0001     		.if	SUPPORT_SGX
   80                        	
   81                        			; Put some "CORE(not TM)" variables at the start of Zero Page.
   82                        			;
   83                        			; These are at the *start* of ZP so that the SuperGrafx shadow
   84                        			; "sgx_" registers are at a specific offset from their System
   85                        			; Card "vdc_" counterparts, and they MUST NOT be moved!
   86                        			;
   87                        			; This allows us to put SGX_VDC_OFFSET or PCE_VDC_OFFSET into
   88                        			; the X register, and then index into either set of hardware
   89                        			; registers and the "sgx_reg" or "vdc_reg" shadow-variables.
   90                        	
   91               0000     	PCE_VDC_OFFSET	=	$00		; Offset to PCE VDC chip & shadow vars.
   92               0010     	SGX_VDC_OFFSET	=	$10		; Offset to SGX VDC chip & shadow vars.
   93                        	
   94               2000     			.zp
   95               2000     			.org	$2000
   96    F8:2000             	__temp		ds	2		; $F8:2000 Use within any ASM routine.
   97    F8:2002             	_bp_bank	ds	1		; $F8:2002 Use within any ASM/HuCC routine.
   98    F8:2003             	sgx_crl		ds	1		; $F8:2003 SGX shadow (vdc_crl = $20F3).
   99    F8:2004             	sgx_crh		ds	1		; $F8:2004 SGX shadow (vdc_crh = $20F4).
  100    F8:2005             	core_1stbank	ds	1		; $F8:2005 1st bank of library code.
  101    F8:2006             	sgx_sr		ds	1		; $F8:2006 SGX shadow (vdc_sr  = $20F6).
  102    F8:2007             	sgx_reg		ds	1		; $F8:2007 SGX shadow (vdc_reg = $20F7).
  103                        	
  104               2008     	core_zp1st	=	*		; $F8:2008 1st free user address.
  105                        	
  106                        		.else	SUPPORT_SGX
  116                        		.endif	SUPPORT_SGX
  117                        	
  118                        	;
  119                        	; The kernel code in RAM follows the System Card's RAM variables.
  120                        	;
  121                        	
  122               0000     		.if	USING_PSGDRIVER
  124                        		.else
  125               22D0     	core_ram1st     =	$F8:22D0
  126                        		.endif	USING_PSGDRIVER
  127                        	
  128                        	;
  129                        	; Include the "CORE(not TM)" startup code to begin the HuCARD / Overlay.
  130                        	;
  131                        	
                             #[4]   "..\..\..\include\hucc\core-startup.asm"
  132                        			include	"core-startup.asm"
    1                        	; ***************************************************************************
    2                        	; ***************************************************************************
    3                        	;
    4                        	; core-startup.asm
    5                        	;
    6                        	; The "CORE(not TM)" PC Engine library startup code that runs at boot/reset.
    7                        	;
    8                        	; Copyright John Brandwood 2021-2024.
    9                        	;
   10                        	; Distributed under the Boost Software License, Version 1.0.
   11                        	; (See accompanying file LICENSE_1_0.txt or copy at
   12                        	;  http://www.boost.org/LICENSE_1_0.txt)
   13                        	;
   14                        	; ***************************************************************************
   15                        	; ***************************************************************************
   16                        	;
   17                        	; This is the initialization code in the 1st bank, and it is responsible for
   18                        	; setting up a consistant runtime environment for the developer's program,
   19                        	; so that the developer can concentrate on writing the program itself.
   20                        	;
   21                        	; The idea is that when a program is loaded, the first 40KB of it is mapped
   22                        	; as $4000..$DFFF, and initialization starts at $4000, with the developer's
   23                        	; program getting control after initialization, with a jump to "core_main".
   24                        	;
   25                        	; The initializtion sets up a small kernel of code that provides interrupt
   26                        	; handling that mimics a subset of the System Card's behavior, designed to
   27                        	; act in the same way on HuCARD and CD-ROM, with either the System Card in
   28                        	; MPR7, or with an overlay in MPR7.
   29                        	;
   30                        	; The kernel handles reading the joypad/mouse, and it offers handler hooks
   31                        	; for running the developer's interrupt code.  On CD-ROM systems, it also
   32                        	; handles the loading and running of subsequent overlay programs.
   33                        	;
   34                        	; On HuCARD, the kernel itself runs in MPR7; while on CD-ROM systems it is
   35                        	; run from RAM in MPR1, so that overlay programs are independant from each
   36                        	; other, and can be written in different programming languages.
   37                        	;
   38                        	;
   39                        	; 1) If we're running on a HuCARD, the initialization is simple!
   40                        	;
   41                        	;    The PC Engine's memory map is set to ...
   42                        	;
   43                        	;      MPR0 = bank $FF : PCE hardware
   44                        	;      MPR1 = bank $F8 : PCE RAM with Stack & ZP
   45                        	;      MPR2 = bank $00 : HuCARD ROM
   46                        	;      MPR3 = bank $01 : HuCARD ROM
   47                        	;      MPR4 = bank $02 : HuCARD ROM
   48                        	;      MPR5 = bank $03 : HuCARD ROM
   49                        	;      MPR6 = bank $04 : HuCARD ROM
   50                        	;      MPR7 = bank $00 : HuCARD ROM
   51                        	;
   52                        	;
   53                        	; 2) If we're running on a HuCARD that supports the Turbo Everdrive, then the
   54                        	;    first 2 banks are reserved for mapping the TED2 hardware and a RAM bank.
   55                        	;
   56                        	;    The PC Engine's memory map is set to ...
   57                        	;
   58                        	;      MPR0 = bank $FF : PCE hardware
   59                        	;      MPR1 = bank $F8 : PCE RAM with Stack & ZP
   60                        	;      MPR2 = bank $02 : HuCARD ROM
   61                        	;      MPR3 = bank $03 : HuCARD ROM
   62                        	;      MPR4 = bank $04 : HuCARD ROM
   63                        	;      MPR5 = bank $05 : HuCARD ROM
   64                        	;      MPR6 = bank $06 : HuCARD ROM
   65                        	;      MPR7 = bank $02 : HuCARD ROM
   66                        	;
   67                        	;
   68                        	; 3) If we're running on an old CD System, the overlay is loaded from the ISO
   69                        	;    into banks $80-$87 (64KB max).
   70                        	;
   71                        	;    The PC Engine's memory map is set to ...
   72                        	;
   73                        	;      MPR0 = bank $FF : PCE hardware
   74                        	;      MPR1 = bank $F8 : PCE RAM with Stack & ZP
   75                        	;      MPR2 = bank $80 : CD RAM
   76                        	;      MPR3 = bank $81 : CD RAM
   77                        	;      MPR4 = bank $82 : CD RAM
   78                        	;      MPR5 = bank $83 : CD RAM
   79                        	;      MPR6 = bank $84 : CD RAM
   80                        	;      MPR7 = bank $80 : CD RAM or System Card's bank $00
   81                        	;
   82                        	;
   83                        	; 4) If we're running on a SuperCD System, the overlay is loaded from the ISO
   84                        	;    into banks $68-$87 (256KB max).
   85                        	;
   86                        	;    The PC Engine's memory map is set to ...
   87                        	;
   88                        	;      MPR0 = bank $FF : PCE hardware
   89                        	;      MPR1 = bank $F8 : PCE RAM with Stack & ZP
   90                        	;      MPR2 = bank $68 : SCD RAM
   91                        	;      MPR3 = bank $69 : SCD RAM
   92                        	;      MPR4 = bank $6A : SCD RAM
   93                        	;      MPR5 = bank $6B : SCD RAM
   94                        	;      MPR6 = bank $6C : SCD RAM
   95                        	;      MPR7 = bank $68 : SCD RAM or System Card's bank $00
   96                        	;
   97                        	; ***************************************************************************
   98                        	; ***************************************************************************
   99                        	
  100                        	
  101                        	
  102               E000     			.code
  103               0000     			.bank	0
  104                        	
  105               0000     		.if	SUPPORT_TED2			; Do we want to use a TED2?
  177                        		.endif	SUPPORT_TED2
  178                        	
  179                        	
  180                        	
  181               0001     		.if	USING_MPR7
  182                        	
  183                        	; ***************************************************************************
  184                        	; ***************************************************************************
  185                        	;
  186                        	; RESET VECTORS (when running in MPR7, either as a HuCARD, or a CD overlay)
  187                        	;
  188                        	
  189                        			; Hardware reset and interrupt vectors.
  190                        	
  191               FFF4     			.org	$FFF4
  192                        	
  193    00:FFF4  10         	core_version:	db	CORE_VERSION		; CORE(not TM) Version.
  194    00:FFF5  80         			db	$80			; System Card compatibility.
  195                        	
  196    00:FFF6  5D E0      			dw	core_irq2		; IRQ2	(from CD/ADPCM)
  197    00:FFF8  64 E0      			dw	core_irq1		; IRQ1	(from VDC)
  198    00:FFFA  58 E1      			dw	core_timer		; TIMER (from CPU)
  199    00:FFFC  5E E1      			dw	core_rti		; NMI	(unused)
  200               0000     		.if	CDROM
  202                        		.else
  203    00:FFFE  21 E0      			dw	core_hw_reset		; RESET (HuCARD)
  204                        		.endif	CDROM
  205                        	
  206               0001     		.if	USING_NEWPROC			; If the ".proc" trampolines
  207               FFF3     	__trampolineptr =	$FFF3			; are in MPR7, tell PCEAS to
  208                        		.endif					; put them below the vectors.
  209                        	
  210                        		.else	USING_MPR7
  222                        		.endif	USING_MPR7
  223                        	
  224                        	
  225                        	
  226                        	; ***************************************************************************
  227                        	; ***************************************************************************
  228                        	;
  229                        	; !!! THE HuCARD/OVERLAY PROGRAM'S FIRST BANK STARTS HERE !!!
  230                        	;
  231                        	
  232                        			; Switch to MPR2 for the "CORE(not TM)" library init.
  233                        			;
  234                        			; This is also executed by a HuCARD once it has run
  235                        			; its initial hardware-reset code.
  236                        			;
  237                        			; When run, MPR2-MPR6 are always mapped to the 1st 5 banks of
  238                        			; the overlay program, and MPR7 contains the System Card.
  239                        	
  240               4000     			.org	$4000
  241                        	
  242               0000     	CORE_BANK	=	bank(*) - _bank_base	; It isn't always zero! ;-)
  243                        	
  244               0000     			.bank	CORE_BANK, "CORE_BANK"	; Give it a label.
  245                        	
  246               0001     		.if	USING_MPR7
  247               0007     	CORE_PAGE	=	7			; User code runs in MPR7.
  248                        		.else
  250                        		.endif	USING_MPR7
  251                        	
  252    00:4000  4C 06 40   	core_boot:	jmp	* + 6			; Allow someone to patch this.
  253                        	
  254                        			; Add an ident string so isoLINK can autodetect configuration.
  255                        			;
  256                        			; This allows isoLINK to decide whether to use the IPL-SCD boot
  257                        			; sector hack, and whether to include a SuperGRAFX signature in
  258                        			; the boot sector, without the user having to manually use some
  259                        			; command line parameters, although they are free to do that if
  260                        			; they wish.
  261                        	
  262               0001     		.if	SUPPORT_SGX
  263               0000     		.if	BUILDING_STAGE1
  265                        		.else
  266    00:4003  53 47 58   			db	"SGX"			; SGX SuperCD or SGX HuCARD.
  267                        		.endif	BUILDING_STAGE1
  268                        		.else
  282                        		.endif	SUPPORT_SGX
  283                        	
  284               0000     		.if	CDROM
  331                        		.else	CDROM
  332                        	
  333                        			; Set up HuCARD RAM in a compatible way to the System Card.
  334                        			;
  335                        			; Note that the entire RAM is cleared by "core_hw_reset".
  336                        	
  337    00:4006  A9 1F      			lda	#%11111			; Enable joypad soft-reset.
  338    00:4008  8D 27 22   			sta	joyena
  339                        	
  340                        		.endif	CDROM
  341                        	
  342                        			; Now that RAM is initialized ...
  343                        	
  344    00:400B  43 04      			tma2				; Remember overlay's 1st bank
  345    00:400D  85 05      			sta	<core_1stbank		; $00, $02, $68 or $80!
  346               0001     		.if	USING_MPR7
  347    00:400F  53 80      			tam7				; "CORE(not TM)" takes MPR7!
  348                        		.endif
  349                        	
  350    00:4011  A2 FF      			ldx	#$FF			; Initialize stack pointer.
  351    00:4013  9A         			txs
  352                        	
  353    00:4014  20 5F E1   			jsr	core_clr_hooks		; Reset default hooks.
  354                        	
  355                        	;		stz	TIMER_CR		; Stop HuC6280 timer.
  356                        	;		stz	IRQ_ACK			; Clr HuC6280 timer interrupt.
  357                        	;		stz	IRQ_MSK			; Clr HuC6280 interrupt mask.
  358                        	
  359    00:4017  AD 00 02   			lda	VDC_SR			; Purge any overdue VBL.
  360    00:401A  9C 41 22   			stz	irq_cnt			; Make it easy to check.
  361    00:401D  58         			cli				; Restore interrupts.
  362                        	
  363    00:401E  4C E5 FF   			jmp	core_main		; Start the game's code.
  364                        	
  365                        	
  366                        	
  367               0001     		.if	!CDROM
  368                        	
  369                        	; ***************************************************************************
  370                        	; ***************************************************************************
  371                        	;
  372                        	; HuCARD Kernel Code
  373                        	;
  374                        	; core_ram1st - Start of code to relocate to MPR1.
  375                        	; core_ramend - End of code to relocate to MPR1.
  376                        	;
  377                        	
  378                        			; In a HuCARD, BSS variables start as low as possible.
  379                        	
  380               2200     			.bss
  381               22D0     			.org	core_ram1st
  382               22D0     	core_ramend	=	*
  383               4021     			.code
  384                        	
  385                        			; Normal HuCARD hardware-reset code, executed in MPR7.
  386                        			;
  387                        			; This does the basic PCE startup that every HuCARD (including
  388                        			; a System Card) needs to do, and then it remaps memory to be
  389                        			; compatible with the "CORE(not TM)" CD overlay program start.
  390                        	
  391               E021     			.page	7			; This will run in MPR7.
  392                        	
  393    00:E021  78         	core_hw_reset:	sei				; Disable interrupts.
  394    00:E022  D4         			csh				; Set high-speed mode.
  395    00:E023  D8         			cld
  396                        	
  397    00:E024  A2 FF      			ldx	#$FF			; Initialize stack pointer.
  398    00:E026  9A         			txs
  399    00:E027  8A         			txa				; MPR0 = $FF : PCE hardware
  400    00:E028  53 01      			tam0				; MPR1 = $F8 : PCE RAM
  401    00:E02A  A9 F8      			lda	#$F8
  402    00:E02C  53 02      			tam1
  403                        	
  404    00:E02E  9C 01 0C   			stz	TIMER_CR		; HW reset already does these,
  405    00:E031  9C 03 14   			stz	IRQ_ACK			; but this may be a reset from
  406    00:E034  9C 02 14   			stz	IRQ_MSK			; software (i.e. joypad).
  407                        	
  408    00:E037  F3 53 E0 00			tai	const_0000, $2000, 8192 ; Clear RAM.
         00:E03B  20 00 20    
  409                        	
  410    00:E03E  43 80      			tma7				; Not always bank 0!
  411                        	
  412    00:E040  53 04      			tam2				; Set CD-ROM overlay memory map,
  413    00:E042  1A         			inc	a			; 1st 5 banks in MPR2-MPR6.
  414    00:E043  53 08      			tam3
  415    00:E045  1A         			inc	a
  416    00:E046  53 10      			tam4
  417    00:E048  1A         			inc	a
  418    00:E049  53 20      			tam5
  419    00:E04B  1A         			inc	a
  420    00:E04C  53 40      			tam6
  421                        	
  422    00:E04E  4C 00 40   			jmp	core_boot		; Continue execution in MPR2.
  423                        	
  424                        			; In a HuCARD, the kernel code is permanently in MPR7.
  425                        	
                             #[5]   "..\..\..\include\hucc\core-kernel.asm"
  426                        			include "core-kernel.asm"
    1                        	; ***************************************************************************
    2                        	; ***************************************************************************
    3                        	;
    4                        	; core-kernel.asm
    5                        	;
    6                        	; The "CORE(not TM)" PC Engine library kernel code that runs after startup.
    7                        	;
    8                        	; Copyright John Brandwood 2021-2024.
    9                        	;
   10                        	; Distributed under the Boost Software License, Version 1.0.
   11                        	; (See accompanying file LICENSE_1_0.txt or copy at
   12                        	;  http://www.boost.org/LICENSE_1_0.txt)
   13                        	;
   14                        	; ***************************************************************************
   15                        	; ***************************************************************************
   16                        	;
   17                        	; This code is permanently located in either MPR7 (HuCARD), or MPR1 (CD-ROM),
   18                        	; and it provides a consistant method of interrupt-handling on both systems
   19                        	; that is designed to be compatible with the System Card.
   20                        	;
   21                        	; The library uses the "irq1_hook" for its own VDC interrupt handler, and PCE
   22                        	; developers are expected to use "vsync_hook" and "hsync_hook" for their VDC
   23                        	; interrupt functions.  Plenty of memory is available in the 1st bank for the
   24                        	; developer to put those functions.
   25                        	;
   26                        	; The reason for using "irq1_hook", is so that the library can work properly
   27                        	; if either the current overlay program, or the System Card, are mapped into
   28                        	; MPR7 whenever an interrupt occurs.
   29                        	;
   30                        	; The VDC interupt handler itself is changed from the System Card's handler,
   31                        	; and it is designed to provide faster response to vsync_hook, and to enable
   32                        	; interrupts during the slow(ish) joypad and sound driver code, so that both
   33                        	; raster and timer interrupts are not delayed.
   34                        	;
   35                        	; Developers are free to enable interrupts during their own vsync_hook code,
   36                        	; if they wish to do so.
   37                        	;
   38                        	; On CD-ROM systems, this library kernel also provides a function to load and
   39                        	; run a new overlay program, without relying upon any of the code/data within
   40                        	; the current overlay program's memory (unlike HuC v3).
   41                        	;
   42                        	; ***************************************************************************
   43                        	; ***************************************************************************
   44                        	
   45                        	
   46                        	
   47                        	; ***************************************************************************
   48                        	; ***************************************************************************
   49                        	;
   50                        	; core_kernel - Start of kernel code.
   51                        	;
   52                        	
   53               E051     	core_kernel	=	*
   54                        	
   55                        	
   56                        	
   57                        	; ***************************************************************************
   58                        	; ***************************************************************************
   59                        	;
   60                        	; Useful constants, needed by joypad library code, and used by many others.
   61                        	;
   62                        	; The kernel starts with a non-zero byte so that core-startup.asm can check
   63                        	; whether it has already been loaded into RAM.
   64                        	;
   65                        	
   66    00:E051  FF FF      	const_FFFF:	dw	$FFFF			; Useful constant for TAI.
   67    00:E053  00 00      	const_0000:	dw	$0000			; Useful constant for TAI.
   68                        	
   69    00:E055  01 02 04 08	bit_mask:	db	$01,$02,$04,$08,$10,$20,$40,$80
         00:E059  10 20 40 80 
   70                        	
   71                        	
   72                        	
   73                        	; ***************************************************************************
   74                        	; ***************************************************************************
   75                        	;
   76                        	; core_irq2  - Minimal interrupt handler compatible with System Card.
   77                        	; core_irq1  - Minimal interrupt handler compatible with System Card.
   78                        	; core_timer - Minimal interrupt handler compatible with System Card.
   79                        	; core_rti   - Minimal interrupt handler compatible with System Card.
   80                        	;
   81                        	; Note that it takes 8 cycles to respond to an IRQ.
   82                        	;
   83                        	; These routines are copied to a location in RAM that does not vary when
   84                        	; a different overlay program is loaded.
   85                        	;
   86                        	; All overlay programs are set up to vector interrupts to these routines,
   87                        	; which is designed to avoid interrupt-related crashes when loading a new
   88                        	; overlay on top of an old overlay in memory.
   89                        	;
   90                        	; All of the game's actual interrupt handling itself is done in the "hook"
   91                        	; functions so that everything works the same if the System Card is banked
   92                        	; into MPR7 when an interrupt occurs.
   93                        	;
   94                        	; ***************************************************************************
   95                        	; ***************************************************************************
   96                        	;
   97                        	; Bit settings for irq_vec  ...
   98                        	;
   99                        	;   7 : 1 to skip BIOS hsync processsing
  100                        	;   6 : 1 to call [hsync_hook]
  101                        	;   5 : 1 to skip BIOS vsync processsing
  102                        	;   4 : 1 to call [vsync_hook]
  103                        	;
  104                        	;   3 : 1 to jump [nmi_hook]
  105                        	;   2 : 1 to jump [timer_hook]
  106                        	;   1 : 1 to jump [irq1_hook]
  107                        	;   0 : 1 to jump [irq2_hook]
  108                        	;
  109                        	; ***************************************************************************
  110                        	; ***************************************************************************
  111                        	
  112    00:E05D  8F F5 01   	core_irq2:	bbs0	<irq_vec, .hook		; 8 cycles if using hook.
  113                        	
  114               0000     		.if	CDROM
  138                        		.else
  139                        			; Does this HuCARD support the IFU's ADPCM hardware?
  140                        	
  141               0000     		.if	SUPPORT_ADPCM
  153                        		.endif	SUPPORT_ADPCM
  154                        	
  155    00:E060  40         			rti				; No IRQ2 hardware on HuCARD.
  156                        	
  157    00:E061  6C 00 22   	.hook:		jmp	[irq2_hook]		; 7 cycles.
  158                        		.endif	CDROM
  159                        	
  160                        	
  161                        	
  162                        	; ***************************************************************************
  163                        	; ***************************************************************************
  164                        	;
  165                        	; core_irq1 - Minimal interrupt handler compatible with System Card.
  166                        	;
  167                        	; irq1_handler - Basic "CORE(not TM)" IRQ1 handler to use as the "irq1_hook".
  168                        	;
  169                        	; Doing the IRQ1 handler processing in this hook means that things operate
  170                        	; the same whether the System Card or an Overlay is paged into MPR7.
  171                        	
  172               0000     		.ifndef	HUCC
  181                        		.else
  182                        			; Faster IRQ servicing for HuCC and code that would like to
  183                        			; avoid the 8 cycles used by the "bbs1" instruction that is
  184                        			; taken when the System Card is mapped into MPR7.
  185                        	
  186    00:E064             	core_irq1:	;;;				; 8 (cycles for the INT)
  187               0001     		.if	CDROM || !defined(NO_CORE_IRQ1_HOOK)
  188    00:E064  6C 02 22   			jmp	[irq1_hook]		; 7 cycles.
  189                        	
  190                        		.endif
  191                        		.endif
  192                        	
  193    00:E067  48         	irq1_handler:	pha				; 3 Save all registers.
  194    00:E068  DA         			phx				; 3
  195    00:E069  5A         			phy				; 3
  196                        	
  197               0000     		.ifndef	USING_RCR_MACROS		;   This slows things down
  206                        		.endif	USING_RCR_MACROS
  207                        	
  208    00:E06A  AD 00 02   			lda	VDC_SR			; 6 Acknowledge the VDC's IRQ.
  209    00:E06D  85 F6      			sta	<vdc_sr			; 4 Remember what caused it.
  210                        	
  211               0001     		.if	SUPPORT_SGX
  212    00:E06F  AE 10 02   			ldx	SGX_SR			; 6 Read SGX_SR after VDC_SR in
  213    00:E072  86 06      			stx	<sgx_sr			; 4 case this is not an SGX!
  214                        		.endif
  215                        	
  216                        			; Handle the VDC's RCR interrupt.
  217                        	
  218    00:E074  29 04      	!:		and	#$04			; 2 Is this an HSYNC interrupt?
  219    00:E076  F0 44      			beq	!+			; 2
  220                        	
  221               0001     		.ifdef	USING_RCR_MACROS
  222                        			VDC_RCR_MACRO
                             	
         00:E078  03 06      			st0	#VDC_RCR		; 5
                             	
         00:E07A  AE 13 27   			ldx	vdc_next_region		; 5 X and Y can be greater than
         00:E07D  BC 14 27   			ldy	vdc_regionA_nxt, x	; 5 HUCC_PCE_SPLITS if regionB!
         00:E080  18         			clc				; 2
         00:E081  D0 05      			bne	!set_next_rcr+		; 4 Stop RCR if next line is 0.
                             	
         00:E083  2D 53 E0   			and	const_0000		; 5 A=$00 with the same #cycles
         00:E086  80 05      			bra	!clr_next_rcr+		; 4 as if the branch were taken.
                             	
         00:E088  B9 C3 26   	!set_next_rcr:	lda	vdc_regionA_rcr, y	; 5 Set next RCR 1 line before
         00:E08B  69 3F      			adc	#64-1			; 2 the region begins, or 0 to
         00:E08D  8D 02 02   	!clr_next_rcr:	sta	VDC_DL			; 6 disable.
         00:E090  62         			cla				; 2
         00:E091  2A         			rol	a			; 2
         00:E092  8D 03 02   			sta	VDC_DH			; 6
                             	
         00:E095  03 08      			st0	#VDC_BYR		; 5 Do BYR first to mitigate the
         00:E097  BD F3 26   			lda	vdc_regionA_yl, x	; 5 glitch if the IRQ is delayed.
         00:E09A  8D 02 02   			sta	VDC_DL			; 6 = 105 cycles from RCR on SGX
         00:E09D  BD 03 27   			lda	vdc_regionA_yh, x	; 5
         00:E0A0  8D 03 02   			sta	VDC_DH			; 6
                             	
         00:E0A3  03 05      			st0	#VDC_CR			; 5
         00:E0A5  BD B3 26   			lda	vdc_regionA_crl, x	; 5
                             	;		asl	a
         00:E0A8  8D 02 02   			sta	VDC_DL			; 6
                             	
         00:E0AB  03 07      			st0	#VDC_BXR		; 2
         00:E0AD  BD D3 26   			lda	vdc_regionA_xl, x	; 5
         00:E0B0  8D 02 02   			sta	VDC_DL			; 6
         00:E0B3  BD E3 26   			lda	vdc_regionA_xh, x	; 5
         00:E0B6  8D 03 02   			sta	VDC_DH			; 6 = 156 cycles from RCR if DUO
                             	
                             	;		bcc	!+
                             	;		lda	vdc_regionA_yh, x	; 5
                             	;		sta.l	VCE_CTW			; 6
                             	
         00:E0B9  8C 13 27   			sty	vdc_next_region		; 5
                             	
  223                        		.else
  225                        		.endif
  226                        	
  227               0001     		.if	SUPPORT_SGX
  228                        	
  229                        			; Handle the SGX's RCR interrupt.
  230                        	
  231    00:E0BC  2F 06 50   	!:		bbr2	<sgx_sr, !+		; 6 Is this an HSYNC interrupt?
  232                        	
  233               0001     		.ifdef	USING_RCR_MACROS
  234                        			SGX_RCR_MACRO
                             	
         00:E0BF  A9 06      			lda	#VDC_RCR		; 2
         00:E0C1  8D 10 02   			sta	SGX_AR			; 6
                             	
         00:E0C4  AE 94 27   			ldx	sgx_next_region		; 5 X and Y can be greater than
         00:E0C7  BC 95 27   			ldy	sgx_regionA_nxt, x	; 5 HUCC_SGX_SPLITS if regionB!
         00:E0CA  18         			clc				; 2
         00:E0CB  D0 05      			bne	!set_next_rcr+		; 4 Stop RCR if next line is 0.
                             	
         00:E0CD  2D 53 E0   			and	const_0000		; 5 A=$00 with the same #cycles
         00:E0D0  80 05      			bra	!clr_next_rcr+		; 4 as if the branch were taken.
                             	
         00:E0D2  B9 44 27   	!set_next_rcr:	lda	sgx_regionA_rcr, y	; 5 Set next RCR 1 line before
         00:E0D5  69 3F      			adc	#64-1			; 2 the region begins, or 0 to
         00:E0D7  8D 12 02   	!clr_next_rcr:	sta	SGX_DL			; 6 disable.
         00:E0DA  62         			cla				; 2
         00:E0DB  2A         			rol	a			; 2
         00:E0DC  8D 13 02   			sta	SGX_DH			; 6
                             	
         00:E0DF  A9 08      			lda	#VDC_BYR		; 2 Do BYR first to mitigate the
         00:E0E1  8D 10 02   			sta	SGX_AR			; 6 glitch if the IRQ is delayed.
         00:E0E4  BD 74 27   			lda	sgx_regionA_yl, x	; 5
         00:E0E7  8D 12 02   			sta	SGX_DL			; 6
         00:E0EA  BD 84 27   			lda	sgx_regionA_yh, x	; 5
         00:E0ED  8D 13 02   			sta	SGX_DH			; 6
                             	
         00:E0F0  A9 05      			lda	#VDC_CR			; 2
         00:E0F2  8D 10 02   			sta	SGX_AR			; 6
         00:E0F5  BD 34 27   			lda	sgx_regionA_crl, x	; 5
         00:E0F8  8D 12 02   			sta	SGX_DL			; 6
                             	
         00:E0FB  A9 07      			lda	#VDC_BXR		; 2
         00:E0FD  8D 10 02   			sta	SGX_AR			; 6
         00:E100  BD 54 27   			lda	sgx_regionA_xl, x	; 5
         00:E103  8D 12 02   			sta	SGX_DL			; 6
         00:E106  BD 64 27   			lda	sgx_regionA_xh, x	; 5
         00:E109  8D 13 02   			sta	SGX_DH			; 6 = 293 cycles (282 if no YH)
                             	
         00:E10C  8C 94 27   			sty	sgx_next_region		; 5
                             	
  235                        		.else
  237                        		.endif
  238                        	
  239                        		.endif	SUPPORT_SGX
  240                        	
  241                        			; Handle the VDC's VBL interrupt.
  242                        	
  243    00:E10F  5F F6 32   	!:		bbr5	<vdc_sr, .exit_irq1	; 6 Is this a VBLANK interrupt?
  244                        	
  245               0001     		.ifdef	USING_RCR_MACROS		;   If we didn't do it earlier
  246               0000     		.if	CDROM				;   then we need to do it now.
  253                        		.endif	CDROM
  254                        		.endif	USING_RCR_MACROS
  255                        	
  256               0001     		.if	SUPPORT_SGX
  257    00:E112  A9 05      			lda	#VDC_CR			; Update the SGX's Control
  258    00:E114  8D 10 02   			sta	SGX_AR			; Register first, just in
  259    00:E117  8D 00 02   			sta	VDC_AR			; case this is not an SGX!
  260    00:E11A  A5 03      			lda	<sgx_crl		
  261    00:E11C  8D 12 02   			sta	SGX_DL
  262    00:E11F  A5 F3      			lda	<vdc_crl
  263    00:E121  8D 02 02   			sta	VDC_DL
  264                        	
  265                        	;		lda	<sgx_crh		; Do not mess with the SGX's
  266                        	;		sta	SGX_DH			; auto-increment!!!
  267                        	;		lda	<vdc_crh		; Do not mess with the VDC's
  268                        	;		sta	VDC_DH			; auto-increment!!!
  269                        		.else
  277                        		.endif	SUPPORT_SGX
  278                        	
  279    00:E124  EE 41 22   			inc	irq_cnt			; Mark that a VBLANK occurred.
  280                        	
  281    00:E127  4F F5 02   			bbr4	<irq_vec, .skip_hookv	; Is a driver registered?
  282                        	
  283    00:E12A  44 26      			bsr	.user_vsync		; Call game's VBLANK code.
  284                        	
  285    00:E12C  DF F5 15   	.skip_hookv:	bbs5	<irq_vec, .exit_vbl	; Should we skip "BIOS" stuff?
  286                        	
  287    00:E12F  58         			cli				; Allow HSYNC and TIMER IRQ.
  288                        	
  289    00:E130  20 DB FF   			call	read_joypads		; Update joypad state.
  290                        	
  291               0000     		.if	USING_PSGDRIVER
  305                        		.else
  306    00:E133  AD 07 22   			lda	sound_hook + 1		; Is a driver registered?
  307    00:E136  F0 0C      			beq	.exit_vbl
  308                        	
  309    00:E138  A9 80      			lda	#$80			; Acquire sound mutex to avoid
  310    00:E13A  0C E7 22   			tsb	sound_mutex		; conflict with a delayed VBL.
  311    00:E13D  30 05      			bmi	.exit_vbl
  312                        	
  313    00:E13F  44 14      			bsr	.user_sound		; Call the driver hook.
  314                        	
  315    00:E141  9C E7 22   			stz	sound_mutex		; Release sound mutex.
  316                        		.endif	USING_PSGDRIVER
  317                        	
  318    00:E144             	.exit_vbl:
  319                        	
  320               0001     		.ifdef	USING_RCR_MACROS		; If USING_RCR_MACROS then 
  321               0000     		.if	CDROM				; restore after the VBLANK.
  326                        		.endif	CDROM
  327                        		.endif	USING_RCR_MACROS
  328                        	
  329    00:E144             	.exit_irq1:
  330                        	
  331               0000     		.ifndef	USING_RCR_MACROS		; If !USING_RCR_MACROS then
  338                        		.endif	USING_RCR_MACROS
  339                        	
  340               0001     		.if	SUPPORT_SGX
  341    00:E144  A5 07      			lda	<sgx_reg		; Restore SGX_AR first, just
  342    00:E146  8D 10 02   			sta	SGX_AR			; in case this is not an SGX!
  343                        		.endif
  344                        	
  345    00:E149  A5 F7      			lda	<vdc_reg		; Restore VDC_AR in case we
  346    00:E14B  8D 00 02   			sta	VDC_AR			; changed it.
  347                        	
  348    00:E14E  7A         			ply				; Restore all registers.
  349    00:E14F  FA         			plx
  350    00:E150  68         			pla
  351                        	
  352    00:E151  40         			rti				; Return from interrupt.
  353                        	
  354    00:E152  6C 08 22   	.user_vsync:	jmp	[vsync_hook]		; 7
  355    00:E155  6C 06 22   	.user_sound:	jmp	[sound_hook]		; 7
  356                        	
  357               0000     		.ifndef	USING_RCR_MACROS
  362                        		.endif	USING_RCR_MACROS
  363                        	
  364                        	
  365                        	
  366                        	; ***************************************************************************
  367                        	; ***************************************************************************
  368                        	;
  369                        	; core_timer - Minimal interrupt handler compatible with System Card.
  370                        	;
  371                        	; tirq_handler - Basic "CORE(not TM)" TIRQ handler to use as the "timer_hook".
  372                        	;
  373                        	; Doing the TIRQ handler processing in this hook means that things operate
  374                        	; the same whether the System Card or an Overlay is paged into MPR7.
  375                        	
  376               0000     		.ifndef	HUCC
  385                        		.else
  386                        			; Faster IRQ servicing for HuCC and code that would like to
  387                        			; avoid the 8 cycles used by the "bbs2" instruction that is
  388                        			; taken when the System Card is mapped into MPR7.
  389                        	
  390    00:E158             	core_timer:	;;;				; 8 (cycles for the INT)
  391               0001     		.if	CDROM || !defined(NO_CORE_TIRQ_HOOK)
  392    00:E158  6C 04 22   			jmp	[timer_hook]		; 7 cycles.
  393                        		.endif
  394                        		.endif
  395                        	
  396    00:E15B             	tirq_handler:
  397               0000     		.ifdef	USING_TIRQ_MACRO
  399                        		.else
  400    00:E15B  9C 03 14   			stz	IRQ_ACK			; 5 Clear timer interrupt.
  401                        		.endif
  402                        	
  403    00:E15E  40         	core_rti:	rti
  404                        	
  405                        	
  406                        	
  407                        	; ***************************************************************************
  408                        	; ***************************************************************************
  409                        	;
  410                        	; core_clr_hooks - Reset default "CORE(not TM)" interrupt-handling hooks.
  411                        	;
  412                        	
  413    00:E15F  08         	core_clr_hooks:	php				; Preserve interrupt state.
  414    00:E160  78         			sei				; Disable interrupts.
  415                        	
  416               0000     		.if	USING_PSGDRIVER
  419                        		.else
  420    00:E161  9C 07 22   			stz.h	sound_hook		; Disable sound driver calls.
  421                        		.endif
  422                        	
  423    00:E164  A9 88      			lda	#<core_sw_reset		; Set up the soft-reset hook.
  424    00:E166  8D 84 22   			sta.l	reset_hook
  425    00:E169  A9 E1      			lda	#>core_sw_reset
  426    00:E16B  8D 85 22   			sta.h	reset_hook
  427                        	
  428    00:E16E  A9 67      			lda	#<irq1_handler		; Set up the IRQ1 hook.
  429    00:E170  8D 02 22   			sta.l	irq1_hook
  430    00:E173  A9 E0      			lda	#>irq1_handler
  431    00:E175  8D 03 22   			sta.h	irq1_hook
  432                        	
  433    00:E178  A9 5B      			lda	#<tirq_handler		; Set up the TIRQ hook.
  434    00:E17A  8D 04 22   			sta.l	timer_hook
  435    00:E17D  A9 E1      			lda	#>tirq_handler
  436    00:E17F  8D 05 22   			sta.h	timer_hook
  437                        	
  438    00:E182  A9 06      			lda	#%00000110		; Replace the System Card's
  439    00:E184  85 F5      			sta	<irq_vec		; IRQ1 and TIRQ processing.
  440                        	
  441    00:E186  28         			plp				; Restore interrupt state.
  442    00:E187  60         			rts
  443                        	
  444                        	
  445                        	
  446                        	; ***************************************************************************
  447                        	; ***************************************************************************
  448                        	;
  449                        	; Include the joypad library, with configuration from "core-config.inc".
  450                        	;
  451                        	
                             #[6]   "..\..\..\include\hucc\joypad.asm"
  452                        			include "joypad.asm"
    1                        	; ***************************************************************************
    2                        	; ***************************************************************************
    3                        	;
    4                        	; joypad.asm
    5                        	;
    6                        	; Read 2-button & 6-button joypads & PCE mouse, with or without a MultiTap.
    7                        	;
    8                        	; Copyright John Brandwood 2019-2025.
    9                        	;
   10                        	; Distributed under the Boost Software License, Version 1.0.
   11                        	; (See accompanying file LICENSE_1_0.txt or copy at
   12                        	;  http://www.boost.org/LICENSE_1_0.txt)
   13                        	;
   14                        	; ***************************************************************************
   15                        	; ***************************************************************************
   16                        	;
   17                        	; Unlike Lemmings, this code does not interfere with a Memory Base 128! ;-)
   18                        	;
   19                        	; ***************************************************************************
   20                        	; ***************************************************************************
   21                        	;
   22                        	; With SUPPORT_MOUSE ..... 2602 cycles to read 5 ports with 5 mice
   23                        	;
   24                        	; With HuC library code .. 2442 cycles to read 5 ports with 5 pads (2-button)
   25                        	; With HuC library code .. 2442 cycles to read 5 ports with 5 pads (6-button)
   26                        	;
   27                        	; With SUPPORT_MOUSE ....  2016 cycles to read 5 ports with 5 pads (2-button)
   28                        	; With SUPPORT_MOUSE ..... 1976 cycles to read 5 ports with 5 pads (6-button)
   29                        	;
   30                        	; With SUPPORT_MOUSE ....  1618 cycles to read 3 ports with 3 mice
   31                        	; With SUPPORT_MOUSE ..... 1462 cycles to read 3 ports with 2 mice
   32                        	; With SUPPORT_MOUSE ..... 1306 cycles to read 3 ports with 1 mouse
   33                        	;
   34                        	; With SUPPORT_6BUTTON ... 1235 cycles to read 5 ports with 5 pads (2-button)
   35                        	; With SUPPORT_6BUTTON ... 1215 cycles to read 5 ports with 5 pads (6-button)
   36                        	;
   37                        	; With SUPPORT_MOUSE ..... 1126 cycles to read 2 ports with 2 mice
   38                        	; With SUPPORT_MOUSE ...... 970 cycles to read 2 ports with 1 mouse
   39                        	;
   40                        	; Only SUPPORT_2BUTTON .... 971 cycles to read 5 ports with 5 pads (2-button)
   41                        	; Only SUPPORT_2BUTTON .... 861 cycles to read 5 ports with 5 pads (6-button)
   42                        	;
   43                        	; With SUPPORT_MOUSE ...... 634 cycles to read 1 port  with 1 mouse
   44                        	;
   45                        	; ***************************************************************************
   46                        	; ***************************************************************************
   47                        	
  142                        	
  143                        	;
  144                        	; Now choose which version of the code to include.
  145                        	;
  146                        	
  147               0000     		.if	SUPPORT_2BUTTON
  278                        		.endif	SUPPORT_2BUTTON
  279                        	
  280                        	
  281                        	
  282               0000     		.if	SUPPORT_MOUSE
  845                        		.else	SUPPORT_MOUSE
  846                        	
  847                        	
  848                        	
  849               0001     		.if	SUPPORT_6BUTTON			; Without mouse!
  850                        	
  851                        	; ***************************************************************************
  852                        	; ***************************************************************************
  853                        	;
  854                        	; read_joypads - full 6-button pad support, but mouse movement is ignored.
  855                        	;
  856                        	; This code distinguishes between a mouse and a 2-button or 6-button joypad,
  857                        	; so that unsupported devices do not have to be unplugged from the MultiTap.
  858                        	;
  859                        	; The code loops two times to get both sets of buttons on a 6-button joypad.
  860                        	;
  861                        	; N.B. Takes approx 1/3 frame to detect mice the first time it is run.
  862                        	;
  863                        	; bit values for joypad 2-button bytes: (MSB = #7; LSB = #0)
  864                        	; ----------------------------------------------------------
  865                        	; bit 0 (ie $01) = I
  866                        	; bit 1 (ie $02) = II
  867                        	; bit 2 (ie $04) = SELECT
  868                        	; bit 3 (ie $08) = RUN
  869                        	; bit 4 (ie $10) = UP
  870                        	; bit 5 (ie $20) = RIGHT
  871                        	; bit 6 (ie $40) = DOWN
  872                        	; bit 7 (ie $80) = LEFT
  873                        	;
  874                        	; bit values for joypad 6-button bytes: (MSB = #7; LSB = #0)
  875                        	; ----------------------------------------------------------
  876                        	; bit 0 (ie $01) = III
  877                        	; bit 1 (ie $02) = IV
  878                        	; bit 2 (ie $04) = V
  879                        	; bit 3 (ie $08) = VI
  880                        	; bit 4 (ie $10) = zero
  881                        	; bit 5 (ie $20) = zero
  882                        	; bit 6 (ie $40) = zero
  883                        	; bit 7 (ie $80) = zero, but set to one if 6-button pad detected.
  884                        	;
  885                        	
  886               E188     			.code
  887                        	
  888               0001     		.if	(* >= $4000)			; Make this a ".proc" if it
  889    10:DEEF             	read_joypads	.proc                           ; not running in RAM.
  890                        		.else
  892                        		.endif
  893                        	
  894    10:DEEF  A9 80      			lda	#$80			; Acquire port mutex to avoid
  895    10:DEF1  0C D0 22   			tsb	port_mutex		; conflict with a delayed VBL
  896    10:DEF4  30 75      			bmi	.exit			; or access to an MB128.
  897                        	
  898    10:DEF6  73 28 22 32			tii	joynow,joyold,MAX_PADS	; Save the previous values.
         10:DEFA  22 05 00    
  899    10:DEFD  73 D3 22 D8			tii	joy6now,joy6old,MAX_PADS
         10:DF01  22 05 00    
  900                        	
  901                        			; Reset the 6-btn bits, the user might change the joypad mode!
  902                        	
  903    10:DF04  F3 53 E0 D3			tai	const_0000, joy6now, MAX_PADS
         10:DF08  22 05 00    
  904                        	
  905                        			; Detect attached mice the first time this routine is called.
  906                        	
  907    10:DF0B  AD D2 22   			lda	mouse_flg		; Has mouse detection happened?
  908    10:DF0E  30 28      			bmi	.calc_pressed
  909                        	
  910    10:DF10  A9 05      			lda	#MAX_PADS		; Reset number of pads to read.
  911    10:DF12  8D D1 22   			sta	num_ports
  912                        	
  913    10:DF15  A9 1F      			lda	#%00011111		; Try reading everything as a
  914    10:DF17  8D D2 22   			sta	mouse_flg		; mouse.
  915                        	
  916    10:DF1A  A0 17      			ldy	#23			; Initialize repeat count.
  917    10:DF1C  A9 80      			lda	#$80			; Initialize mouse detection.
  918    10:DF1E  5A         	.detect_loop:	phy
  919    10:DF1F  48         			pha
  920    10:DF20  44 53      			bsr	.read_devices		; Read all devices as if mice.
  921    10:DF22  68         			pla
  922    10:DF23  82         			clx
  923    10:DF24  BC E2 22   	.detect_port:	ldy	mouse_x, x		; A movement of zero means
  924    10:DF27  D0 03      			bne	.detect_next		; this port is a mouse.
  925    10:DF29  1D 55 E0   			ora	bit_mask, x
  926    10:DF2C  E8         	.detect_next:	inx				; Get the next pad from the
  927    10:DF2D  E0 05      			cpx	#MAX_PADS		; multitap.
  928    10:DF2F  D0 F3      			bne	.detect_port
  929    10:DF31  7A         			ply				; Repeat the detection test.
  930    10:DF32  88         			dey
  931    10:DF33  D0 E9      			bne	.detect_loop
  932                        	
  933                        	;	.if	DETECT_PHANTOMS
  934                        	;		cmp	#(1 << MAX_PADS) + 127	; If we find a mouse in every
  935                        	;		bne	.detect_done		; port, then assume mirrored!
  936                        	;		lda	#1			; Report a single mouse in a
  937                        	;		sta	num_ports		; single port.
  938                        	;		lda	#$81
  939                        	;	.endif
  940                        	
  941    10:DF35  8D D2 22   	.detect_done:	sta	mouse_flg		; Report mouse detection.
  942                        	
  943                        			; See what has just been pressed, and check for soft-reset.
  944                        	
  945    10:DF38  44 3B      	.calc_pressed:	bsr	.read_devices		; Read all devices normally.
  946                        	
  947    10:DF3A  A2 04      			ldx	#MAX_PADS - 1
  948                        	
  949    10:DF3C  BD D3 22   	.pressed_loop:	lda	joy6now, x		; Calc which buttons have just
  950    10:DF3F  5D D8 22   			eor	joy6old, x		; been pressed (6-button).
  951    10:DF42  3D D3 22   			and	joy6now, x
  952               0000     		.if	HUC_JOY_EVENTS
  956                        		.else
  957               0000     		.if	ACCUMULATE_JOY
  959                        		.endif
  960    10:DF45  9D DD 22   			sta	joy6trg, x
  961                        		.endif
  962                        	
  963    10:DF48  BD 28 22   			lda	joynow, x		; Calc which buttons have just
  964    10:DF4B  A8         			tay                             ; been pressed (2-button).
  965    10:DF4C  5D 32 22   			eor	joyold, x
  966    10:DF4F  3D 28 22   			and	joynow, x
  967               0000     		.if	HUC_JOY_EVENTS
  971                        		.else
  972               0000     		.if	ACCUMULATE_JOY
  974                        		.endif
  975    10:DF52  9D 2D 22   			sta	joytrg, x
  976                        		.endif
  977                        	
  978    10:DF55  C9 04      			cmp	#$04			; Detect the soft-reset combo,
  979    10:DF57  D0 0C      			bne	.not_reset		; hold RUN then press SELECT.
  980    10:DF59  C0 0C      			cpy	#$0C
  981    10:DF5B  D0 08      			bne	.not_reset
  982    10:DF5D  BD 55 E0   			lda	bit_mask, x
  983    10:DF60  2C 27 22   			bit	joyena
  984    10:DF63  D0 09      			bne	.soft_reset
  985                        	
  986    10:DF65  CA         	.not_reset:	dex				; Check the next pad from the
  987    10:DF66  10 D4      			bpl	.pressed_loop		; multitap.
  988                        	
  989    10:DF68  9C D0 22   			stz	port_mutex		; Release port mutex.
  990                        	
  991               0001     		.if	(* >= $4000)			; This is a ".proc" if it is
  992                        	.exit:		leave                           ; not running in RAM.
         10:DF6B  4C EF FF   			jmp	leave_proc
  993                        		.else
  995                        		.endif
  996                        	
  997    10:DF6E  78         	.soft_reset:	sei				; Disable interrupts.
  998    10:DF6F  9C D0 22   			stz	port_mutex		; Release port mutex.
  999    10:DF72  6C 84 22   			jmp	[reset_hook]		; Jump to the soft-reset hook.
 1000                        	
 1001                        			; Read all of the devices attached to the MultiTap.
 1002                        	
 1003    10:DF75  A2 02      	.read_devices:	ldx	#2			; Repeat this loop 2 times.
 1004                        	
 1005    10:DF77  A9 01      	.read_multitap:	lda	#$01			; CLR lo, SEL hi for d-pad.
 1006    10:DF79  8D 00 10   			sta	IO_PORT
 1007    10:DF7C  A9 03      			lda	#$03			; CLR hi, SEL hi, reset tap.
 1008    10:DF7E  8D 00 10   			sta	IO_PORT
 1009    10:DF81  C2         			cly				; Start at port 1.
 1010                        	
 1011    10:DF82  A9 01      	.read_port:	lda	#$01			; CLR lo, SEL hi for d-pad.
 1012    10:DF84  8D 00 10   			sta	IO_PORT			; Wait 1.25us (9 cycles).
 1013                        	
 1014    10:DF87  B9 55 E0   			lda	bit_mask, y		; Is there a mouse attached?
 1015    10:DF8A  2D D2 22   			and	mouse_flg
 1016    10:DF8D  D0 33      			bne	.read_mouse
 1017                        	
 1018    10:DF8F  AD 00 10   	.read_pad:	lda	IO_PORT			; Read direction-pad bits.
 1019    10:DF92  9C 00 10   			stz	IO_PORT			; CLR lo, SEL lo for buttons.
 1020    10:DF95  0A         			asl	a			; Wait 1.25us (9 cycles).
 1021    10:DF96  0A         			asl	a
 1022    10:DF97  0A         			asl	a
 1023    10:DF98  0A         			asl	a
 1024    10:DF99  F0 1B      			beq	.read_6button		; 6-btn pad if UDLR all held.
 1025                        	
 1026    10:DF9B  99 28 22   	.read_2button:	sta	joynow, y		; Get buttons of 2-btn pad.
 1027    10:DF9E  AD 00 10   			lda	IO_PORT
 1028    10:DFA1  29 0F      			and	#$0F
 1029    10:DFA3  19 28 22   			ora	joynow, y
 1030    10:DFA6  49 FF      			eor	#$FF
 1031    10:DFA8  99 28 22   			sta	joynow, y
 1032                        	
 1033    10:DFAB  C8         	.next_port:	iny				; Get the next pad from the
 1034    10:DFAC  CC D1 22   			cpy	num_ports		; multitap.
 1035    10:DFAF  90 D1      			bcc	.read_port
 1036                        	
 1037    10:DFB1  CA         			dex				; Do the next complete pass.
 1038    10:DFB2  CA         			dex
 1039    10:DFB3  10 C2      			bpl	.read_multitap		; Have we finished 2 passes?
 1040    10:DFB5  60         			rts				; Now that everything is read.
 1041                        	
 1042    10:DFB6  AD 00 10   	.read_6button:	lda	IO_PORT			; Get buttons of 6-btn pad.
 1043    10:DFB9  29 0F      			and	#$0F
 1044    10:DFBB  49 8F      			eor	#$8F			; Set bit-7 to show that a
 1045    10:DFBD  99 D3 22   			sta	joy6now, y		; 6-button pad is present.
 1046    10:DFC0  80 E9      			bra	.next_port
 1047                        	
 1048    10:DFC2  7C F3 DF   	.read_mouse:	jmp	[.mouse_vectors, x]	; Which mouse info is next?
 1049                        	
 1050                        			; Mouse processing, normally four passes, here just two.
 1051                        	
 1052    10:DFC5  A9 1C      	.mouse_x_hi:	lda	#28			; 189 cycle delay after CLR lo
 1053    10:DFC7  3A         	.wait_loop:	dec	a			; on port to allow the mouse
 1054    10:DFC8  D0 FD      			bne	.wait_loop		; to buffer and reset counters.
 1055                        	
 1056    10:DFCA  AD 00 10   			lda	IO_PORT			; Read direction-pad bits.
 1057    10:DFCD  9C 00 10   			stz	IO_PORT			; CLR lo, SEL lo for buttons.
 1058    10:DFD0  0A         			asl	a			; Wait 1.25us (9 cycles).
 1059    10:DFD1  0A         			asl	a
 1060    10:DFD2  0A         			asl	a
 1061    10:DFD3  0A         			asl	a
 1062    10:DFD4  99 E2 22   			sta	mouse_x, y		; Save port's X-hi nibble.
 1063                        	
 1064    10:DFD7  AD 00 10   			lda	IO_PORT			; Get mouse buttons.
 1065    10:DFDA  29 0F      			and	#$0F
 1066    10:DFDC  49 0F      			eor	#$0F
 1067    10:DFDE  99 28 22   			sta	joynow, y
 1068    10:DFE1  80 C8      			bra	.next_port
 1069                        	
 1070    10:DFE3  AD 00 10   	.mouse_x_lo:	lda	IO_PORT			; Read direction-pad bits.
 1071    10:DFE6  9C 00 10   			stz	IO_PORT			; CLR lo, SEL lo for buttons.
 1072    10:DFE9  29 0F      			and	#$0F			; Wait 1.25us (9 cycles).
 1073    10:DFEB  19 E2 22   			ora	mouse_x, y		; Add port's X-hi nibble.
 1074                        	;		eor	#$FF			; Negate so LEFT is -ve.
 1075                        	;		inc	a
 1076    10:DFEE  99 E2 22   			sta	mouse_x, y
 1077    10:DFF1  80 B8      			bra	.next_port
 1078                        	
 1079    10:DFF3  E3 DF      	.mouse_vectors: dw	.mouse_x_lo		; Pass 2
 1080    10:DFF5  C5 DF      			dw	.mouse_x_hi		; Pass 1
 1081                        	
 1082               0001     		.if	(* >= $4000)			; This is a ".proc" if it is
 1083                        			.endp                           ; not running in RAM.
 1084               22D0     			.bss				; Put the variables in RAM.
 1085                        		.endif
 1086                        	
 1087    F8:22D0             	port_mutex:	ds	1			; NZ when controller port busy.
 1088    F8:22D1             	num_ports:	ds	1			; Set to 1 if no multitap.
 1089    F8:22D2             	mouse_flg:	ds	1			; Which ports are mice?
 1090               0000     		.if	HUC_JOY_EVENTS
 1093                        		.endif
 1094    F8:22D3             	joy6now:	ds	MAX_PADS
 1095    F8:22D8             	joy6old:	ds	MAX_PADS
 1096    F8:22DD             	joy6trg:	ds	MAX_PADS
 1097    F8:22E2             	mouse_x:	ds	MAX_PADS
 1098                        	
 1099               E188     			.code
 1100                        	
 1101                        		.endif	SUPPORT_6BUTTON			; Without mouse!
 1102                        	
 1103                        		.endif	SUPPORT_MOUSE
                             #[5]   "..\..\..\include\hucc\core-kernel.asm"
  453                        	
  454                        	
  455                        	
  456               0001     		.if	!CDROM
  457                        	
  458                        	; ***************************************************************************
  459                        	; ***************************************************************************
  460                        	;
  461                        	; core_sw_reset - Default HuCARD handler for a joypad "soft-reset".
  462                        	;
  463                        	
  464    00:E188  78         	core_sw_reset:	sei				; Disable interrupts.
  465                        	
  466    00:E189  6C FE FF   			jmp	[$FFFE]			; Jump to the HuCARD reset.
  467                        	
  468                        	
  469                        	
  470                        		.else	!CDROM
  616                        		.endif	!CDROM
  617                        	
  618                        	
  619                        	
  620                        	; ***************************************************************************
  621                        	; ***************************************************************************
  622                        	
  623               0001     		.if	(core_kernel >= $4000)		; If not running in RAM, then
  624               22E7     			.bss				; put these variables in RAM.
  625                        		.endif
  626                        	
  627    F8:22E7             	sound_mutex:	ds	1			; NZ when controller port busy.
  628                        	
  629               0001     		.if	SUPPORT_SGX
  630    F8:22E8             	sgx_detected:	ds	1			; NZ if SuperGrafx detected.
  631    F8:22E9             	hsync_hook_sgx:	ds	2			; SGX version of hsync_hook.
  632                        		.endif
  633                        	
  634               0000     		.if	SUPPORT_ACD
  636                        		.endif
  637                        	
  638               0001     		.if	(core_kernel >= $4000)
  639               E18C     			.code
  640                        		.endif
                             #[4]   "..\..\..\include\hucc\core-startup.asm"
  427                        	
  428                        	
  429                        	
  430                        		.else	!CDROM
  524                        		.endif	!CDROM
  525                        	
  526                        	
  527                        	
  528                        	; ***************************************************************************
  529                        	; ***************************************************************************
  530                        	;
  531                        	; With the availability of so many different configuration options, we've now
  532                        	; built somewhere between a few hundred bytes, and a couple of KB, of code in
  533                        	; the CORE_BANK of the HuCARD / overlay program.
  534                        	;
  535                        	; This is the end of the "CORE(not TM)" library code!
  536                        	;
  537                        	; Remember that the ".proc" trampolines are located at the end of this bank,
  538                        	; so the amount of free space left depends upon the number of ".proc" calls.
  539                        	;
  540                        	
  541                        			; Switch to CORE_PAGE to run the developer's game code.
  542               E18C     			.page	CORE_PAGE
  543                        	
  544                        	
  545                        	
  546                        	; ***************************************************************************
  547                        	; ***************************************************************************
  548                        	;
  549                        	; The DATA_BANK location needs to be set as early as possible so that library
  550                        	; code is able to put data in there before the total overall size of the code
  551                        	; is known.
  552                        	;
  553                        	; By default, DATA_BANK is the next bank after the CORE_BANK.
  554                        	;
  555                        	; RESERVE_BANKS allows developers to reserve some banks between the CORE_BANK
  556                        	; and the DATA_BANK that they can use however they wish.
  557                        	;
  558                        	; One use for RESERVE_BANKS is to create empty space that PCEAS can use when
  559                        	; it relocates procedures. This provides a way for a developer to group code
  560                        	; together at the start of memory, and leave the maximum number of banks for
  561                        	; loading dynamic data from CD-ROM.
  562                        	;
  563                        	; The KickC environment sets RESERVE_BANKS=1 (or higher) so that there is a
  564                        	; a bank for the permanent C code and static constants.
  565                        	;
  566                        	; RESERVE_BANKS is normally defined in each project's "core-config.inc".
  567                        	;
  568                        	
  569                        			.opt	d+			; DATA labels use fixed MPR.
  570                        	
  571               0001     			.rsset	CORE_BANK + 1
  572                        	
  573               0000     		.ifdef	NEED_HOME_BANK
  580                        		.endif
  581                        	
  582               0001     		.ifdef	NEED_SOUND_BANK			; Defined in hucc-sound.inc
  583               0000     		.if	NEED_SOUND_BANK			; if the driver wants a bank.
  585                        		.endif
  586                        		.endif
  587                        	
  588               0001     		.ifdef	RESERVE_BANKS			; For CORE projects.
  589               0001     	RESERVED_BANK	.rs	RESERVE_BANKS
  590                        		.endif
  591                        	
  592               0001     		.ifdef	HUCC
  593               0001     		.ifdef	HUC_RESERVE_BANKS		; For HuCC projects.
  594               0001     	HUC_USER_BANK	.rs	HUC_RESERVE_BANKS
  595                        		.endif
  596                        	
  597               0001     	CONST_BANK	.rs	2
  598               6000     			.rodata
  599               0001     			.bank	CONST_BANK, ".rodata"
  600                        		.endif	HUCC
  601                        	
  602               0003     	DATA_BANK	.rs	0
  603               6000     			.data
  604               0000     		.if	BUILDING_STAGE1
  606                        		.else
  607               0003     			.bank	DATA_BANK, ".data"
  608                        		.endif
  609               6000     			.org	$6000
  610                        	
  611               E18C     			.code
                             #[3]   "..\..\..\include\hucc\core.inc"
                             #[2]   "..\..\..\include\hucc\hucc.asm"
  120                        		.else
  126                        		.endif
  127                        	
  128                        			; Allocate this as early as possible to ensure bank-aligned
  129                        			; so that there is no wasted space for aligning the table.
  130                        	
  131               0000     		.if	FAST_MULTIPLY
  138                        		.endif
  139                        	
  140                        			;
  141                        	
  144                        	
  145                        			; The hardware stack is used for expressions.
  146                        	
  147               00FF     	__tos		=	$F8:2101, 255
  148                        	
  149               2008     			.zp
  150               2008     			.align	2
  151    F8:2008             	__stack:	ds	HUCC_STACK_SZ
  152                        	
  153    F8:2088             	__ptr:		ds	2
  154    F8:208A             	__fptr:		ds	2
  155    F8:208C             	__fbank:	ds	1
  156    F8:208D             	__sp:		ds	1
  157                        	
  158                        			; REGTEMP 6-byte stack for temporaries used by SDCC.
  159                        			; Keep the size in sync with NUM_TEMP_REGS in sdcc/src/mos6502/gen.h!
  160                        	
  161    F8:208E             	REGTEMP:	ds	6
  162                        	
  163                        			; HuCC's non-recursive consecutive varargs for printf().
  164                        	
  165               2008     	__vararg1	=	__stack + 0
  166               200A     	__vararg2	=	__stack + 2
  167               200C     	__vararg3	=	__stack + 4
  168               200E     	__vararg4	=	__stack + 6
  169                        	
  170                        			; Pointer used by poke() because __ptr could be overwritten.
  171                        	
  172               20EE     	__poke		=	__si
  173                        	
  174                        			; Used for indirect calls because __ptr could be overwritten.
  175                        	
  176               20EE     	__func		=	__si
  177                        	
  178                        			; Data pointer used by SDCC for indirect indexed memory access.
  179                        	
  180               2088     	DPTR		=	__ptr
  181                        	
  182                        			; Values returned from SDCC functions that don't fit into XA.
  183                        			; These are also used as workspace for SDCC library functions,
  184                        			; including HuCC's multiplication and division functions.
  185                        	
  186    F8:2094             	___SDCC_m6502_ret0:	ds	1
  187    F8:2095             	___SDCC_m6502_ret1:	ds	1
  188    F8:2096             	___SDCC_m6502_ret2:	ds	1
  189    F8:2097             	___SDCC_m6502_ret3:	ds	1
  190                        	
  191               0000     		.if	0
  196                        		.endif
  197                        	
  198                        			; Permanent pointers for fast table-of-squares multiplication.
  199                        	
  200               0000     		.if	FAST_MULTIPLY
  205                        		.endif
  206                        	
  207                        			; HuCC keeps a realtime clock, updated in hucc_vbl.
  208                        			;
  209                        			; Defining this here means that it will go before any HuCC
  210                        			; variables in "globals.h", and so it won't get cleared in
  211                        			; a CDROM game when loading different overlays.
  212                        	
  213               22EB     			.bss
  214    F8:22EB             	old_cnt:	ds	1			; irq_cnt of previous vsync().
  215    F8:22EC             	clock_hh:	ds	1			; System Clock, hours	(0-11)
  216    F8:22ED             	clock_mm:	ds	1			; System Clock, minutes (0-59)
  217    F8:22EE             	clock_ss:	ds	1			; System Clock, seconds (0-59)
  218    F8:22EF             	clock_tt:	ds	1			; System Clock, ticks	(0-59)
  219               E18C     			.code
  220                        	
  221                        			; Critical HuCC libraries that the compiler depends upon.
  222                        			;
  223                        			; These include various macros that must be defined before
  224                        			; they are encountered in any compiler-generated code.
  225                        	
                             #[3]   "..\..\..\include\hucc\hucc-codegen.asm"
  226                        			include "hucc-codegen.asm"	; HuCC i-code macros and funcs.
    1                        	; ***************************************************************************
    2                        	; ***************************************************************************
    3                        	;
    4                        	; hucc-codegen.asm
    5                        	;
    6                        	; The HuCC compiler translates C code into these macros, it does not directly
    7                        	; generate HuC6280 instructions.
    8                        	;
    9                        	; Based on the original HuC macros created by David Michel and the other HuC
   10                        	; developers, later modified and improved by Ulrich Hecht.
   11                        	;
   12                        	; Modifications copyright John Brandwood 2024.
   13                        	;
   14                        	; Distributed under the Boost Software License, Version 1.0.
   15                        	; (See accompanying file LICENSE_1_0.txt or copy at
   16                        	;  http://www.boost.org/LICENSE_1_0.txt)
   17                        	;
   18                        	; ***************************************************************************
   19                        	; ***************************************************************************
   20                        	;
   21                        	; NAMING SCHEME FOR HuCC MACROS ...
   22                        	;
   23                        	;   __function.parameters
   24                        	;
   25                        	; {parameters} is a list of alphanumeric specifiers, starting with {size} and
   26                        	; followed by {where}, followed by {index} if an array, then optional {value}
   27                        	; and finally ending with optional {suffix}
   28                        	;
   29                        	; {size}
   30                        	;   w : 16-bit signed int (default "int" in HuCC)
   31                        	;   c : 16-bit unsigned int (a "cardinal" in Pascal terms)
   32                        	;   b :  8-bit signed char
   33                        	;   u :  8-bit unsigned char (default "char" in HuCC)
   34                        	;
   35                        	; {where} or {index}
   36                        	;   r : HuCC primary register, made up of the Y:A cpu registers
   37                        	;   t : top of expression stack
   38                        	;   p : indirect pointer, usually [__ptr]
   39                        	;   f : structure field (member) offset value
   40                        	;   i : immediate value, i.e. a decimal number
   41                        	;   m : memory, i.e. C global, static, and "-fno-recursive" variables
   42                        	;   s : stack, i.e. C function parameters and locals (not "-fno-recursive")
   43                        	;   a : array, i.e. C global, static, "-fno-recursive" arrays <= 256 bytes
   44                        	;   x : array index already in the X register
   45                        	;   y : array index already in the Y register
   46                        	;
   47                        	; {value} OPTIONAL
   48                        	;   i : immediate value, i.e. a decimal number
   49                        	;   z : zero value
   50                        	;
   51                        	; {suffix} OPTIONAL
   52                        	;   q : quick, used for optimized math on only 8-bit values, because all math
   53                        	;       is normally promoted to "int" size in C; and when optimized stores do
   54                        	;       not need to preserve the primary register contents
   55                        	;
   56                        	; ***************************************************************************
   57                        	; ***************************************************************************
   58                        	
   59                        	
   60                        	
 8399                        	
 8400                        	; ***************************************************************************
 8401                        	; ***************************************************************************
 8402                        	; subroutines for logical and arithmetic shifts by a constant amount
 8403                        	; ***************************************************************************
 8404                        	; ***************************************************************************
 8405                        	
 8406                        	; **************
 8407                        	; Y:A = Y:A << const
 8408                        	
 8409    00:E1BE  0A         	aslw15:		asl	a
 8410    00:E1BF  0A         	aslw14:		asl	a
 8411    00:E1C0  0A         	aslw13:		asl	a
 8412    00:E1C1  0A         	aslw12:		asl	a
 8413    00:E1C2  0A         	aslw11:		asl	a
 8414    00:E1C3  0A         	aslw10:		asl	a
 8415    00:E1C4  0A         	aslw9:		asl	a
 8416    00:E1C5  A8         	aslw8:		tay
 8417    00:E1C6  62         			cla
 8418    00:E1C7  60         			rts
 8419                        	
 8420               0001     		.if	1
 8421    00:E1C8  66 00      	aslw5:		ror	<__temp
 8422    00:E1CA  6A         			ror	a
 8423    00:E1CB  66 00      	aslw6:		ror	<__temp
 8424    00:E1CD  6A         			ror	a
 8425    00:E1CE  66 00      	aslw7:		ror	<__temp
 8426    00:E1D0  6A         			ror	a
 8427    00:E1D1  A4 00      			ldy	<__temp
 8428    00:E1D3  60         			rts
 8429                        		.else
 8436                        		.endif
 8437    00:E1D4  0A         	aslw4:		asl	a
 8438    00:E1D5  26 00      			rol	<__temp
 8439    00:E1D7  0A         	aslw3:		asl	a
 8440    00:E1D8  26 00      			rol	<__temp
 8441    00:E1DA  0A         	aslw2:		asl	a
 8442    00:E1DB  26 00      			rol	<__temp
 8443    00:E1DD  0A         	aslw1:		asl	a
 8444    00:E1DE  26 00      			rol	<__temp
 8445    00:E1E0  A4 00      	aslw0:		ldy	<__temp
 8446    00:E1E2  60         			rts
 8447                        	
 8448                        	; **************
 8449                        	; Y:A = Y:A >> const
 8450                        	
 8451    00:E1E3  C9 80      	asrw15:		cmp	#$80
 8452    00:E1E5  6A         			ror	a
 8453    00:E1E6  C9 80      	asrw14:		cmp	#$80
 8454    00:E1E8  6A         			ror	a
 8455    00:E1E9  C9 80      	asrw13:		cmp	#$80
 8456    00:E1EB  6A         			ror	a
 8457    00:E1EC  C9 80      	asrw12:		cmp	#$80
 8458    00:E1EE  6A         			ror	a
 8459    00:E1EF  C9 80      	asrw11:		cmp	#$80
 8460    00:E1F1  6A         			ror	a
 8461    00:E1F2  C9 80      	asrw10:		cmp	#$80
 8462    00:E1F4  6A         			ror	a
 8463    00:E1F5  C9 80      	asrw9:		cmp	#$80
 8464    00:E1F7  6A         			ror	a
 8465    00:E1F8  C9 80      	asrw8:		cmp	#$80
 8466    00:E1FA  C2         			cly
 8467    00:E1FB  90 01      			bcc	!+
 8468    00:E1FD  88         			dey
 8469    00:E1FE  60         	!:		rts
 8470                        	
 8471    00:E1FF  C0 80      	asrw7:		cpy	#$80
 8472    00:E201  66 00      			ror	<__temp
 8473    00:E203  6A         			ror	a
 8474    00:E204  C0 80      	asrw6:		cpy	#$80
 8475    00:E206  66 00      			ror	<__temp
 8476    00:E208  6A         			ror	a
 8477    00:E209  C0 80      	asrw5:		cpy	#$80
 8478    00:E20B  66 00      			ror	<__temp
 8479    00:E20D  6A         			ror	a
 8480    00:E20E  C0 80      	asrw4:		cpy	#$80
 8481    00:E210  66 00      			ror	<__temp
 8482    00:E212  6A         			ror	a
 8483    00:E213  C0 80      	asrw3:		cpy	#$80
 8484    00:E215  66 00      			ror	<__temp
 8485    00:E217  6A         			ror	a
 8486    00:E218  C0 80      	asrw2:		cpy	#$80
 8487    00:E21A  66 00      			ror	<__temp
 8488    00:E21C  6A         			ror	a
 8489    00:E21D  C0 80      	asrw1:		cpy	#$80
 8490    00:E21F  66 00      			ror	<__temp
 8491    00:E221  6A         			ror	a
 8492    00:E222  A4 00      	asrw0:		ldy	<__temp
 8493    00:E224  60         			rts
 8494                        	
 8495                        	; **************
 8496                        	; Y:A = Y:A >> const
 8497                        	
 8498    00:E225  4A         	lsrw15:		lsr	a
 8499    00:E226  4A         	lsrw14:		lsr	a
 8500    00:E227  4A         	lsrw13:		lsr	a
 8501    00:E228  4A         	lsrw12:		lsr	a
 8502    00:E229  4A         	lsrw11:		lsr	a
 8503    00:E22A  4A         	lsrw10:		lsr	a
 8504    00:E22B  4A         	lsrw9:		lsr	a
 8505    00:E22C  C2         	lsrw8:		cly
 8506    00:E22D  60         			rts
 8507                        	
 8508    00:E22E  46 00      	lsrw7:		lsr	<__temp
 8509    00:E230  6A         			ror	a
 8510    00:E231  46 00      	lsrw6:		lsr	<__temp
 8511    00:E233  6A         			ror	a
 8512    00:E234  46 00      	lsrw5:		lsr	<__temp
 8513    00:E236  6A         			ror	a
 8514    00:E237  46 00      	lsrw4:		lsr	<__temp
 8515    00:E239  6A         			ror	a
 8516    00:E23A  46 00      	lsrw3:		lsr	<__temp
 8517    00:E23C  6A         			ror	a
 8518    00:E23D  46 00      	lsrw2:		lsr	<__temp
 8519    00:E23F  6A         			ror	a
 8520    00:E240  46 00      	lsrw1:		lsr	<__temp
 8521    00:E242  6A         			ror	a
 8522    00:E243  A4 00      	lsrw0:		ldy	<__temp
 8523    00:E245  60         			rts
 8524                        	
 8525                        	
 8526                        	
 8527                        	; ***************************************************************************
 8528                        	; ***************************************************************************
 8529                        	; subroutines for logical and arithmetic shifts by a variable amount
 8530                        	; ***************************************************************************
 8531                        	; ***************************************************************************
 8532                        	
 8533                        	; **************
 8534                        	; Y:A = Y:A << X
 8535                        	
 8536    00:E246  84 00      	asl.wx:		sty	<__temp
 8537    00:E248  E0 10      			cpx	#16
 8538    00:E24A  B0 37      			bcs	!zero+
 8539    00:E24C  CA         			dex
 8540    00:E24D  30 06      			bmi	.done
 8541    00:E24F  0A         	.loop:		asl	a
 8542    00:E250  26 00      			rol	<__temp
 8543    00:E252  CA         			dex
 8544    00:E253  10 FA      			bpl	.loop
 8545    00:E255  A4 00      	.done:		ldy	<__temp
 8546    00:E257  60         			rts
 8547                        	
 8548                        	; **************
 8549                        	; Y:A = Y:A >> X
 8550                        	
 8551    00:E258  84 00      	asr.wx:		sty	<__temp
 8552    00:E25A  10 17      			bpl	!positive+
 8553    00:E25C  E0 10      	!negative:	cpx	#16
 8554    00:E25E  B0 0D      			bcs	.sign
 8555    00:E260  CA         			dex
 8556    00:E261  30 07      			bmi	.done
 8557    00:E263  38         	.loop:		sec
 8558    00:E264  66 00      			ror	<__temp
 8559    00:E266  6A         			ror	a
 8560    00:E267  CA         			dex
 8561    00:E268  10 F9      			bpl	.loop
 8562    00:E26A  A4 00      	.done:		ldy	<__temp
 8563    00:E26C  60         			rts
 8564                        	
 8565    00:E26D  A9 FF      	.sign:		lda	#$FF
 8566    00:E26F  A8         			tay
 8567    00:E270  60         			rts
 8568                        	
 8569                        	; **************
 8570                        	; Y:A = Y:A >> X
 8571                        	
 8572    00:E271  84 00      	lsr.wx:		sty	<__temp
 8573    00:E273  E0 10      	!positive:	cpx	#16
 8574    00:E275  B0 0C      			bcs	!zero+
 8575    00:E277  CA         			dex
 8576    00:E278  30 06      			bmi	.done
 8577    00:E27A  46 00      	.loop:		lsr	<__temp
 8578    00:E27C  6A         			ror	a
 8579    00:E27D  CA         			dex
 8580    00:E27E  10 FA      			bpl	.loop
 8581    00:E280  A4 00      	.done:		ldy	<__temp
 8582    00:E282  60         			rts
 8583                        	
 8584    00:E283  62         	!zero:		cla
 8585    00:E284  C2         			cly
 8586    00:E285  60         			rts
 8587                        	
 8588                        	
 8589                        	
 8590                        	; ***************************************************************************
 8591                        	; ***************************************************************************
 8592                        	; POTENTIAL OPTIMIZATIONS, NOT YET ADDED
 8593                        	; ***************************************************************************
 8594                        	; ***************************************************************************
                             #[2]   "..\..\..\include\hucc\hucc.asm"
                             #[3]   "..\..\..\include\hucc\hucc-baselib.asm"
  227                        			include	"hucc-baselib.asm"	; HuCC base library macros.
    1                        	; ***************************************************************************
    2                        	; ***************************************************************************
    3                        	;
    4                        	; hucc-baselib.asm
    5                        	;
    6                        	; Basic library functions provided (mostly) as macros.
    7                        	;
    8                        	; Copyright John Brandwood 2024-2025.
    9                        	;
   10                        	; Distributed under the Boost Software License, Version 1.0.
   11                        	; (See accompanying file LICENSE_1_0.txt or copy at
   12                        	;  http://www.boost.org/LICENSE_1_0.txt)
   13                        	;
   14                        	; ***************************************************************************
   15                        	; ***************************************************************************
   16                        	
   17                        	
   18                        	
   19                        	; ***************************************************************************
   20                        	; ***************************************************************************
   21                        	;
   22                        	; Make certain System Card variables accessible to HuCC.
   23                        	
   24    00:E286             	_irq_cnt	.alias	irq_cnt
   25    00:E286             	_joynow		.alias	joynow
   26    00:E286             	_joytrg		.alias	joytrg
   27    00:E286             	_joy6now	.alias	joy6now
   28    00:E286             	_joy6trg	.alias	joy6trg
   29    00:E286             	_bg_x1		.alias	bg_x1
   30    00:E286             	_bg_y1		.alias	bg_y1
   31    00:E286             	_bg_x2		.alias	bg_x2
   32    00:E286             	_bg_y2		.alias	bg_y2
   33                        	
   34                        	
   35                        	
   36                        	; ***************************************************************************
   37                        	; ***************************************************************************
   38                        	;
   39                        	; void __fastcall dump_screen( void );
   40                        	;
   41                        	; THIS IS AN ILLEGAL INSTRUCTION ONLY IMPLEMENTED BY THE TGEMU EMULATOR!
   42                        	
   43    00:E286  33         	_dump_screen:	db	0x33
   44                        	
   45                        	
   46                        	
   47                        	; ***************************************************************************
   48                        	; ***************************************************************************
   49                        	;
   50                        	; void __fastcall abort( void );
   51                        	;
   52                        	; THIS IS AN ILLEGAL INSTRUCTION ONLY IMPLEMENTED BY THE TGEMU EMULATOR!
   53                        	
   54    00:E287  E2         	_abort:		db	0xE2
   55                        	
   56                        	
   57                        	
   58                        	; ***************************************************************************
   59                        	; ***************************************************************************
   60                        	;
   61                        	; void __fastcall exit( int value<acc> );
   62                        	;
   63                        	; THIS IS AN ILLEGAL INSTRUCTION ONLY IMPLEMENTED BY THE TGEMU EMULATOR!
   64                        	
   65    00:E288  AA         	_exit.1:	tax				; Put the return code into X.
   66    00:E289  63         			db	0x63
   67                        	
   68    00:E28A  80 FE      	.hang:		bra	.hang			; Hang if used in normal code.
   69                        	
   70                        	
   71                        	
   72                        	; ***************************************************************************
   73                        	; ***************************************************************************
   74                        	;
   75                        	; unsigned char __fastcall __macro cd_execoverlay( unsigned char ovl_index<acc> );
   76                        	;
   77                        	; Execute program overlay from disc
   78                        	;
   79                        	; N.B. This does not return, even if there's an error.
   80                        	
   81                        			.macro	_cd_execoverlay.1
   82                        			tax
   83                        			jmp	exec_overlay
   84                        			.endm
   85                        	
   86                        	
   87                        	
   88                        	; ***************************************************************************
   89                        	; ***************************************************************************
   90                        	;
   91                        	; void __fastcall __nop set_far_base( unsigned char data_bank<_bp_bank>, unsigned char *data_addr<_bp> );
   92                        	; void __fastcall set_far_offset( unsigned int offset<_bp>, unsigned char data_bank<_bp_bank>, unsigned char *data_addr<acc> );
   93                        	
   94    00:E28C             	_set_far_offset.3:
   95    00:E28C  18         			clc
   96    00:E28D  65 EC      			adc.l	<_bp
   97    00:E28F  85 EC      			sta.l	<_bp
   98    00:E291  98         			tya
   99    00:E292  29 1F      			and	#$1F
  100    00:E294  65 ED      			adc.h	<_bp
  101    00:E296  A8         			tay
  102    00:E297  29 1F      			and	#$1F
  103    00:E299  09 60      			ora	#$60
  104    00:E29B  85 ED      			sta.h	<_bp
  105    00:E29D  98         			tya
  106    00:E29E  6A         			ror	a
  107    00:E29F  4A         			lsr	a
  108    00:E2A0  4A         			lsr	a
  109    00:E2A1  4A         			lsr	a
  110    00:E2A2  4A         			lsr	a
  111    00:E2A3  18         			clc
  112    00:E2A4  65 02      			adc	<_bp_bank
  113    00:E2A6  85 02      			sta	<_bp_bank
  114    00:E2A8  60         			rts
  115                        	
  116                        	
  117                        	; ***************************************************************************
  118                        	; ***************************************************************************
  119                        	;
  120                        	; void __fastcall __macro reset_mpr2( void );
  121                        	; void __fastcall __macro reset_mpr34( void );
  122                        	;
  123                        	; void * __fastcall __macro set_mpr2( void __far *addr<_bp_bank:_bp> );
  124                        	; void * __fastcall __macro set_mpr34( void __far *addr<_bp_bank:_bp> );
  125                        	;
  126                        	; void * __fastcall __macro far_set_mpr2( void );
  127                        	; void * __fastcall __macro far_set_mpr34( void );
  128                        	
  129                        	_reset_mpr2	.macro
  130                        		.if	SUPPORT_SGX
  131                        			lda	#$F9
  132                        		.else
  133                        			lda	#$87
  134                        		.endif
  135                        			tam2
  136                        			.endm
  137                        	
  138                        	_reset_mpr34	.macro
  139                        			lda	#CONST_BANK + _bank_base
  140                        			tam3
  141                        			inc	a
  142                        			tam4
  143                        			.endm
  144                        	
  145                        	_farset_mpr2.1	.macro
  146                        			lda	<_bp_bank
  147                        			tam2
  148                        			lda.l	<_bp
  149                        			ldy.h	<_bp
  150                        			.endm
  151                        	
  152                        	_farset_mpr34.1	.macro
  153                        			lda	<_bp_bank
  154                        			tam3
  155                        			inc	a
  156                        			tam4
  157                        			lda.l	<_bp
  158                        			ldy.h	<_bp
  159                        			.endm
  160                        	
  161                        	_far_set_mpr2	.macro
  162                        			lda	<_bp_bank
  163                        			tam2
  164                        			lda.l	<_bp
  165                        			ldy.h	<_bp
  166                        			.endm
  167                        	
  168                        	_far_set_mpr34	.macro
  169                        			lda	<_bp_bank
  170                        			tam3
  171                        			inc	a
  172                        			tam4
  173                        			lda.l	<_bp
  174                        			ldy.h	<_bp
  175                        			.endm
  176                        	
  177                        	
  178                        	
  179                        	; ***************************************************************************
  180                        	; ***************************************************************************
  181                        	;
  182                        	; unsigned char __fastcall __macro ac_exists( void );
  183                        	
  184                        	_ac_exists	.macro
  185                        			cla
  186                        			ldy	ACD_FLAG
  187                        			cpy	#ACD_ID
  188                        			bne	!+
  189                        			inc	a
  190                        	!:		cly
  191                        			.endm
  192                        	
  193                        	
  194                        	
  195                        	; ***************************************************************************
  196                        	; ***************************************************************************
  197                        	;
  198                        	; unsigned char __fastcall __macro _sgx_detect( void );
  199                        	
  200                        	_sgx_detect	.macro
  201                        			lda	sgx_detected
  202                        			cly
  203                        			.endm
  204                        	
  205                        	
  206                        	
  207                        	; ***************************************************************************
  208                        	; ***************************************************************************
  209                        	;
  210                        	; unsigned int __fastcall __macro peek( unsigned int addr<__ptr> );
  211                        	
  212                        	_peek.1		.macro
  213                        			lda	[__ptr]
  214                        			cly
  215                        			.endm
  216                        	
  217                        	
  218                        	
  219                        	; ***************************************************************************
  220                        	; ***************************************************************************
  221                        	;
  222                        	; unsigned int __fastcall __macro peekw( unsigned int addr<__ptr> );
  223                        	
  224                        	_peekw.1	.macro
  225                        			lda	[__ptr]
  226                        			pha
  227                        			ldy	#1
  228                        			lda	[__ptr], y
  229                        			tay
  230                        			pla
  231                        			.endm
  232                        	
  233                        	
  234                        	
  235                        	; ***************************************************************************
  236                        	; ***************************************************************************
  237                        	;
  238                        	; void __fastcall __macro poke( unsigned int addr<__poke>, unsigned char with<acc> );
  239                        	;
  240                        	; N.B. Because the <acc> value can be a complex C calculation, it isn't safe
  241                        	; to use __ptr as the destination, which can be overwritten in C macros.
  242                        	
  243                        	_poke.2		.macro
  244                        			sta	[__poke]
  245                        			.endm
  246                        	
  247                        	
  248                        	
  249                        	; ***************************************************************************
  250                        	; ***************************************************************************
  251                        	;
  252                        	; void __fastcall __macro pokew( unsigned int addr<__poke>, unsigned int with<acc> );
  253                        	;
  254                        	; N.B. Because the <acc> value can be a complex C calculation, it isn't safe
  255                        	; to use __ptr as the destination, which can be overwritten in C macros.
  256                        	
  257                        	_pokew.2	.macro
  258                        			sta	[__poke]
  259                        			tya
  260                        			ldy	#1
  261                        			sta	[__poke], y
  262                        			.endm
  263                        	
  264                        	
  265                        	
  266                        	; ***************************************************************************
  267                        	; ***************************************************************************
  268                        	;
  269                        	; unsigned char __fastcall __macro clock_hh( void );
  270                        	
  271                        	_clock_hh	.macro
  272                        			lda	clock_hh
  273                        			cly
  274                        			.endm
  275                        	
  276                        	
  277                        	
  278                        	; ***************************************************************************
  279                        	; ***************************************************************************
  280                        	;
  281                        	; unsigned char __fastcall __macro clock_mm( void );
  282                        	
  283                        	_clock_mm	.macro
  284                        			lda	clock_mm
  285                        			cly
  286                        			.endm
  287                        	
  288                        	
  289                        	
  290                        	; ***************************************************************************
  291                        	; ***************************************************************************
  292                        	;
  293                        	; unsigned char __fastcall __macro clock_ss( void );
  294                        	
  295                        	_clock_ss	.macro
  296                        			lda	clock_ss
  297                        			cly
  298                        			.endm
  299                        	
  300                        	
  301                        	
  302                        	; ***************************************************************************
  303                        	; ***************************************************************************
  304                        	;
  305                        	; unsigned char __fastcall __macro clock_tt( void );
  306                        	
  307                        	_clock_tt	.macro
  308                        			lda	clock_tt
  309                        			cly
  310                        			.endm
  311                        	
  312                        	
  313                        	
  314                        	; ***************************************************************************
  315                        	; ***************************************************************************
  316                        	;
  317                        	; void __fastcall __macro clock_reset( void );
  318                        	
  319                        	_clock_reset	.macro
  320                        			stz	clock_hh
  321                        			stz	clock_mm
  322                        			stz	clock_ss
  323                        			stz	clock_tt
  324                        			.endm
  325                        	
  326                        	
  327                        	
  328                        	; ***************************************************************************
  329                        	; ***************************************************************************
  330                        	;
  331                        	; unsigned int __fastcall __macro joy( unsigned char which<acc> );
  332                        	
  333                        	_joy.1		.macro
  334                        			tax
  335                        			lda	joynow, x
  336                        		.if	SUPPORT_6BUTTON
  337                        			ldy	joy6now, x
  338                        		.else
  339                        			cly
  340                        		.endif
  341                        			.endm
  342                        	
  343                        	
  344                        	
  345                        	; ***************************************************************************
  346                        	; ***************************************************************************
  347                        	;
  348                        	; unsigned int __fastcall __macro joytrg( unsigned char which<acc> );
  349                        	
  350                        	_joytrg.1	.macro
  351                        			tax
  352                        			lda	joytrg, x
  353                        		.if	SUPPORT_6BUTTON
  354                        			ldy	joy6trg, x
  355                        		.else
  356                        			cly
  357                        		.endif
  358                        			.endm
  359                        	
  360                        	
  361                        	
  362                        	; ***************************************************************************
  363                        	; ***************************************************************************
  364                        	;
  365                        	; unsigned int __fastcall __macro joybuf( unsigned char which<acc> );
  366                        	
  367                        	_joybuf.1	.macro
  368                        		.if	HUC_JOY_EVENTS
  369                        			tax
  370                        			lda	joybuf, x
  371                        		.if	SUPPORT_6BUTTON
  372                        			ldy	joy6buf, x
  373                        		.else
  374                        			cly
  375                        		.endif
  376                        		.else
  377                        			.fail	You must enable HUC_JOY_EVENTS in your hucc-config.inc!
  378                        		.endif
  379                        			.endm
  380                        	
  381                        	
  382                        	
  383                        	; ***************************************************************************
  384                        	; ***************************************************************************
  385                        	;
  386                        	; unsigned int __fastcall __macro get_joy_events( unsigned char which<acc> );
  387                        	;
  388                        	; N.B. This is just a version of joybuf() that clears the accumulated events.
  389                        	
  390                        			.macro	_get_joy_events.1
  391                        		.if	HUC_JOY_EVENTS
  392                        			tax
  393                        			lda	joybuf, x
  394                        			stz	joybuf, x
  395                        		.if	SUPPORT_6BUTTON
  396                        			ldy	joy6buf, x
  397                        			stz	joy6buf, x
  398                        		.else
  399                        			cly
  400                        		.endif
  401                        		.else
  402                        		.if	ACCUMULATE_JOY
  403                        			tax
  404                        			lda	joytrg, x
  405                        			stz	joytrg, x
  406                        		.if	SUPPORT_6BUTTON
  407                        			ldy	joy6trg, x
  408                        			stz	joy6trg, x
  409                        		.else
  410                        			cly
  411                        		.endif
  412                        		.else
  413                        			.fail	You must enable HUC_JOY_EVENTS or ACCUMULATE_JOY in your hucc-config.inc!
  414                        		.endif
  415                        		.endif
  416                        			.endm
  417                        	
  418                        	
  419                        	
  420                        	; ***************************************************************************
  421                        	; ***************************************************************************
  422                        	;
  423                        	; void __fastcall __macro clear_joy_events( unsigned char mask<acc> );
  424                        	
  425                        			.macro	_clear_joy_events.1
  426                        			php
  427                        			sei
  428                        			and	#(1 << MAX_PADS) - 1
  429                        			ldx	#$FF
  430                        	.loop:		inx
  431                        			lsr	a
  432                        			bcc	.next
  433                        		.if	HUC_JOY_EVENTS
  434                        			stz	joybuf, x
  435                        		.if	SUPPORT_6BUTTON
  436                        			stz	joy6buf, x
  437                        		.endif
  438                        		.else
  439                        		.if	ACCUMULATE_JOY
  440                        			stz	joytrg, x
  441                        		.if	SUPPORT_6BUTTON
  442                        			stz	joy6trg, x
  443                        		.endif
  444                        		.else
  445                        			.fail	You must enable HUC_JOY_EVENTS or ACCUMULATE_JOY in your hucc-config.inc!
  446                        		.endif
  447                        		.endif
  448                        	.next:		bne	.loop
  449                        			plp
  450                        			.endm
  451                        	
  452                        	
  453                        	
  454                        	; ***************************************************************************
  455                        	; ***************************************************************************
  456                        	;
  457                        	; void __fastcall srand( unsigned char seed<acc> );
  458                        	
  459               0001     		.ifndef	HUCC_NO_DEFAULT_RANDOM
  460                        	_srand.1	.macro
  461                        			tay
  462                        			jsr	init_random
  463                        			.endm
  464                        		.endif
  465                        	
  466                        	
  467                        	
  468                        	; ***************************************************************************
  469                        	; ***************************************************************************
  470                        	;
  471                        	; unsigned int __fastcall rand( void );
  472                        	; unsigned char __fastcall rand8( void );
  473                        	
  474               0001     		.ifndef	HUCC_NO_DEFAULT_RANDOM
  475    00:E2A9  20 C3 E5   	_rand:		jsr	get_random		; Random in A, preserve Y.
  476    00:E2AC  A8         			tay
  477    00:E2AD  4C C3 E5   			jmp	get_random		; Random in A, preserve Y.
  478                        		.endif
  479                        	
  480                        	
  481                        	
  482                        	; ***************************************************************************
  483                        	; ***************************************************************************
  484                        	;
  485                        	; unsigned char __fastcall random8( unsigned char limit<acc> );
  486                        	;
  487                        	; IN :	A = range (0..255)
  488                        	; OUT : A = random number interval 0 <= x < A
  489                        	
  490               0001     		.ifndef	HUCC_NO_DEFAULT_RANDOM
  491                        	
  492    00:E2B0  A8         	_random8.1:	tay				; Preserve the limit.
  493    00:E2B1  20 C3 E5   			jsr	get_random		; Random in A, preserve Y.
  494                        	
  495    00:E2B4  20 F0 E4   			jsr	__muluchar
  496    00:E2B7  98         			tya				; Do a 8.0 x 0.8 fixed point
  497    00:E2B8  C2         			cly				; fractional multiply.
  498    00:E2B9  60         			rts
  499                        		.endif
  500                        	
  501                        	
  502                        	
  503                        	; ***************************************************************************
  504                        	; ***************************************************************************
  505                        	;
  506                        	; unsigned char __fastcall random( unsigned char limit<acc> );
  507                        	;
  508                        	; IN :	A = range (0..128), 129..255 is treated as 128
  509                        	; OUT : A = random number interval 0 <= x < A
  510                        	
  511               0001     		.ifndef	HUCC_NO_DEFAULT_RANDOM
  512                        	
  513    00:E2BA  A8         	_random.1:	tay				; Preserve the limit.
  514    00:E2BB  20 C3 E5   			jsr	get_random		; Random in A, preserve Y.
  515                        	
  516    00:E2BE  C0 80      			cpy	#128			; Check the limit.
  517    00:E2C0  90 04      			bcc	!+
  518                        	
  519    00:E2C2  29 7F      			and	#$7F			; Just mask the random if
  520    00:E2C4  C2         			cly				; the limit is >= 128.
  521    00:E2C5  60         			rts
  522                        	
  523    00:E2C6  20 F0 E4   	!:		jsr	__muluchar
  524    00:E2C9  98         			tya				; If the limit is < 128 then
  525    00:E2CA  C2         			cly				; do a 8.0 x 0.8 fixed point
  526    00:E2CB  60         			rts				; fractional multiply.
  527                        		.endif
  528                        	
  529                        	
  530                        	
  531                        	; ***************************************************************************
  532                        	; ***************************************************************************
  533                        	;
  534                        	; unsigned char __fastcall __builtin_ffs( unsigned int value<__temp> );
  535                        	
  536                        			.proc	___builtin_ffs.1
  556                        			.endp
  557                        	
  558                        	
  559                        	
  560                        	; ***************************************************************************
  561                        	; ***************************************************************************
  562                        	;
  563                        	; N.B. Declared in hucc-string.h, but defined here because they're macros!
  564                        	;
  565                        	; int __fastcall __macro memcmp( unsigned char *destination<_di>, unsigned char *source<_bp>, unsigned int count<acc> );
  566                        	
  567                        	_memcmp.3	.macro
  568                        			stz	<_bp_bank		; Map the source string.
  569                        			call	_farmemcmp.3
  570                        			.endm
  571                        	
  572                        	
  573                        	
  574                        	; ***************************************************************************
  575                        	; ***************************************************************************
  576                        	;
  577                        	; N.B. Declared in hucc-gfx.h, but defined here because they're macros!
  578                        	;
  579                        	; void __fastcall __macro get_color( unsigned int index<VCE_CTA> );
  580                        	
  581                        	_get_color.1	.macro
  582                        			lda.l	VCE_CTR
  583                        			ldy.h	VCE_CTR
  584                        			.endm
  585                        	
  586                        	
  587                        	
  588                        	; ***************************************************************************
  589                        	; ***************************************************************************
  590                        	;
  591                        	; N.B. Declared in hucc-gfx.h, but defined here because they're macros!
  592                        	;
  593                        	; void __fastcall __macro fade_to_black( unsigned int __far *from<_bp_bank:_bp>, unsigned int *destination<_di>, unsigned char num_colors<_al>, unsigned char value_to_sub<_ah> );
  594                        	; void __fastcall __macro fade_to_white( unsigned int __far *from<_bp_bank:_bp>, unsigned int *destination<_di>, unsigned char num_colors<_al>, unsigned char value_to_add<_ah> );
  595                        	; void __fastcall __macro cross_fade_to( unsigned int __far *from<_bp_bank:_bp>, unsigned int *destination<_di>, unsigned char num_colors<_al>, unsigned char which_component<_ah );
  596                        	;
  597                        	; void __fastcall __macro far_fade_to_black( unsigned int *destination<_di>, unsigned char num_colors<_al>, unsigned char value_to_sub<_ah> );
  598                        	; void __fastcall __macro far_fade_to_white( unsigned int *destination<_di>, unsigned char num_colors<_al>, unsigned char value_to_add<_ah> );
  599                        	; void __fastcall __macro far_cross_fade_to( unsigned int *destination<_di>, unsigned char num_colors<_al>, unsigned char which_component<_ah );
  600                        	
  601                        			.macro	_fade_to_black.4
  602                        			ldy	<_bp_bank
  603                        			call	fade_to_black
  604                        			.endm
  605                        	
  606                        			.macro	_fade_to_white.4
  607                        			ldy	<_bp_bank
  608                        			call	fade_to_white
  609                        			.endm
  610                        	
  611                        			.macro	_cross_fade_to.4
  612                        			ldy	<_bp_bank
  613                        			call	cross_fade_to
  614                        			.endm
  615                        	
  616                        			.macro	_far_fade_to_black.3
  617                        			ldy	<_bp_bank
  618                        			call	fade_to_black
  619                        			.endm
  620                        	
  621                        			.macro	_far_fade_to_white.3
  622                        			ldy	<_bp_bank
  623                        			call	fade_to_white
  624                        			.endm
  625                        	
  626                        			.macro	_far_cross_fade_to.3
  627                        			ldy	<_bp_bank
  628                        			call	cross_fade_to
  629                        			.endm
  630                        	
  631                        	
  632                        	
  633                        	; ***************************************************************************
  634                        	; ***************************************************************************
  635                        	;
  636                        	; N.B. Declared in hucc-gfx.h, but defined here because they're macros!
  637                        	;
  638                        	; void __fastcall __macro set_xres( unsigned int x_pixels<_ax> );
  639                        	; void __fastcall __macro sgx_set_xres( unsigned int x_pixels<_ax> );
  640                        	;
  641                        	; void __fastcall set_xres( unsigned int x_pixels<_ax>, unsigned char blur_flag<_bl> );
  642                        	; void __fastcall sgx_set_xres( unsigned int x_pixels<_ax>, unsigned char blur_flag<_bl> );
  643                        	
  644                        	_set_xres.1	.macro
  645                        			lda	#XRES_SOFT
  646                        			sta	<_bl
  647                        			call	_set_xres.2
  648                        			.endm
  649                        	
  650               0001     		.if	SUPPORT_SGX
  651                        			.macro	_sgx_set_xres.1
  652                        			lda	#XRES_SOFT
  653                        			sta	<_bl
  654                        			call	_sgx_set_xres.2
  655                        			.endm
  656                        		.endif
  657                        	
  658                        	
  659                        	
  660                        	; ***************************************************************************
  661                        	; ***************************************************************************
  662                        	;
  663                        	; N.B. Declared in hucc-gfx.h, but defined here because they're macros!
  664                        	;
  665                        	; unsigned int __fastcall __macro vram_addr( unsigned char bat_x<_al>, unsigned char bat_y<_ah> );
  666                        	; unsigned int __fastcall __macro sgx_vram_addr( unsigned char bat_x<_al>, unsigned char bat_y<_ah> );
  667                        	
  668                        			.macro	_vram_addr.2
  669                        			cla
  670                        			bit	vdc_bat_width
  671                        			bmi	!w128+
  672                        			bvs	!w64+
  673                        	!w32:		lsr	<_ah
  674                        			ror	a
  675                        	!w64:		lsr	<_ah
  676                        			ror	a
  677                        	!w128:		lsr	<_ah
  678                        			ror	a
  679                        			ora	<_al
  680                        			ldy	<_ah
  681                        			.endm
  682                        	
  683               0001     		.if	SUPPORT_SGX
  684                        			.macro	_sgx_vram_addr.2
  685                        			cla
  686                        			bit	sgx_bat_width
  687                        			bmi	!w128+
  688                        			bvs	!w64+
  689                        	!w32:		lsr	<_ah
  690                        			ror	a
  691                        	!w64:		lsr	<_ah
  692                        			ror	a
  693                        	!w128:		lsr	<_ah
  694                        			ror	a
  695                        			ora	<_al
  696                        			ldy	<_ah
  697                        			.endm
  698                        		.endif
  699                        	
  700                        	
  701                        	
  702                        	; ***************************************************************************
  703                        	; ***************************************************************************
  704                        	;
  705                        	; N.B. Declared in hucc-gfx.h, but defined here because they're macros!
  706                        	;
  707                        	; unsigned int __fastcall __macro get_vram( unsigned int address<_di> );
  708                        	; void __fastcall __macro put_vram( unsigned int address<_di>, unsigned int data<acc> );
  709                        	;
  710                        	; unsigned int __fastcall __macro sgx_get_vram( unsigned int address<_di> );
  711                        	; void __fastcall __macro sgx_put_vram( unsigned int address<_di>, unsigned int data<acc> );
  712                        	
  713                        			.macro	_get_vram.1
  714                        			jsr	vdc_di_to_marr
  715                        			lda	VDC_DL
  716                        			ldy	VDC_DH
  717                        			.endm
  718                        	
  719                        			.macro	_put_vram.2
  720                        			pha
  721                        			jsr	vdc_di_to_mawr
  722                        			pla
  723                        			sta	VDC_DL
  724                        			sty	VDC_DH
  725                        			.endm
  726                        	
  727               0001     		.if	SUPPORT_SGX
  728                        			.macro	_sgx_get_vram.1
  729                        			jsr	sgx_di_to_marr
  730                        			lda	SGX_DL
  731                        			ldy	SGX_DH
  732                        			.endm
  733                        	
  734                        			.macro	_sgx_put_vram.2
  735                        			pha
  736                        			jsr	sgx_di_to_mawr
  737                        			pla
  738                        			sta	SGX_DL
  739                        			sty	SGX_DH
  740                        			.endm
  741                        		.endif
  742                        	
  743                        	
  744                        	
  745                        	; ***************************************************************************
  746                        	; ***************************************************************************
  747                        	;
  748                        	; N.B. Declared in hucc-gfx.h, but defined here because they're macros!
  749                        	;
  750                        	; void __fastcall __macro set_bgpal( unsigned char palette<_al>, unsigned char __far *data<_bp_bank:_bp> );
  751                        	; void __fastcall __macro set_bgpal( unsigned char palette<_al>, unsigned char __far *data<_bp_bank:_bp>, unsigned int num_palettes<_ah> );
  752                        	; void __fastcall __macro set_sprpal( unsigned char palette<_al>, unsigned char __far *data<_bp_bank:_bp> );
  753                        	; void __fastcall __macro set_sprpal( unsigned char palette<_al>, unsigned char __far *data<_bp_bank:_bp>, unsigned int num_palettes<_ah> );
  754                        	
  755                        	_set_bgpal.2	.macro
  756                        			lda	#1
  757                        			sta	<_ah
  758                        			call	_load_palette.3
  759                        			.endm
  760                        	
  761                        	_set_bgpal.3	.macro
  762                        			call	_load_palette.3
  763                        			.endm
  764                        	
  765                        	_set_sprpal.2	.macro
  766                        			lda	#1
  767                        			sta	<_ah
  768                        			smb4	<_al
  769                        			call	_load_palette.3
  770                        			.endm
  771                        	
  772                        	_set_sprpal.3	.macro
  773                        			smb4	<_al
  774                        			call	_load_palette.3
  775                        			.endm
  776                        	
  777                        	
  778                        	
  779                        	; ***************************************************************************
  780                        	; ***************************************************************************
  781                        	;
  782                        	; N.B. Declared in hucc-gfx.h, but defined here because they're macros!
  783                        	;
  784                        	; void __fastcall __macro load_vram( unsigned int vram<_di>, unsigned char __far *data<_bp_bank:_bp>, unsigned int num_words<_ax> );
  785                        	; void __fastcall __macro sgx_load_vram( unsigned int vram<_di>, unsigned char __far *data<_bp_bank:_bp>, unsigned int num_words<_ax> );
  786                        	;
  787                        	; void __fastcall __macro far_load_vram( unsigned int vram<_di>, unsigned int num_words<_ax> );
  788                        	; void __fastcall __macro sgx_far_load_vram( unsigned int vram<_di>, unsigned int num_words<_ax> );
  789                        	;
  790                        	
  791               0001     		.if	SUPPORT_SGX
  792                        			.macro	_sgx_load_vram.3
  793                        			ldx	#SGX_VDC_OFFSET		; Offset to SGX VDC.
  794                        			call	load_vram_x
  795                        			.endm
  796                        	
  797                        			.macro	_sgx_far_load_vram.2
  798                        			ldx	#SGX_VDC_OFFSET		; Offset to SGX VDC.
  799                        			call	load_vram_x
  800                        			.endm
  801                        		.endif
  802                        	
  803                        			.macro	_load_vram.3
  804                        			clx				; Offset to PCE VDC.
  805                        			call	load_vram_x
  806                        			.endm
  807                        	
  808                        			.macro	_far_load_vram.2
  809                        			clx				; Offset to PCE VDC.
  810                        			call	load_vram_x
  811                        			.endm
  812                        	
  813                        	
  814                        	
  815                        	; ***************************************************************************
  816                        	; ***************************************************************************
  817                        	;
  818                        	; N.B. Declared in hucc-gfx.h, but defined here because they're macros!
  819                        	;
  820                        	; void __fastcall __macro load_sprites( unsigned int vram<_di>, unsigned char __far *data<_bp_bank:_bp>, unsigned int num_groups<acc> );
  821                        	; void __fastcall __macro sgx_load_sprites( unsigned int vram<_di>, unsigned char __far *data<_bp_bank:_bp>, unsigned int num_groups<acc> );
  822                        	; void __fastcall __macro far_load_sprites( unsigned int vram<_di>, unsigned int num_groups<acc> );
  823                        	; void __fastcall __macro sgx_far_load_sprites( unsigned int vram<_di>, unsigned int num_groups<acc> );
  824                        	
  825               0001     		.if	SUPPORT_SGX
  826                        			.macro	_sgx_load_sprites.3
  827                        			stz.l	<_ax
  828                        			asl	a
  829                        			sta.h	<_ax
  830                        			ldx	#SGX_VDC_OFFSET		; Offset to SGX VDC.
  831                        			call	load_vram_x
  832                        			.endm
  833                        	
  834                        			.macro	_sgx_far_load_sprites.2
  835                        			stz.l	<_ax
  836                        			asl	a
  837                        			sta.h	<_ax
  838                        			ldx	#SGX_VDC_OFFSET		; Offset to SGX VDC.
  839                        			call	load_vram_x
  840                        			.endm
  841                        		.endif
  842                        	
  843                        			.macro	_load_sprites.3
  844                        			stz.l	<_ax
  845                        			asl	a
  846                        			sta.h	<_ax
  847                        			clx				; Offset to PCE VDC.
  848                        			call	load_vram_x
  849                        			.endm
  850                        	
  851                        			.macro	_far_load_sprites.2
  852                        			stz.l	<_ax
  853                        			asl	a
  854                        			sta.h	<_ax
  855                        			clx				; Offset to PCE VDC.
  856                        			call	load_vram_x
  857                        			.endm
  858                        	
  859                        	
  860                        	
  861                        	; ***************************************************************************
  862                        	; ***************************************************************************
  863                        	;
  864                        	; N.B. Declared in hucc-gfx.h, but defined here because they're macros!
  865                        	;
  866                        	; void __fastcall load_default_font( void );
  867                        	; void __fastcall sgx_load_default_font( void );
  868                        	;
  869                        	
  870               0001     		.if	SUPPORT_SGX
  871                        			.macro	_sgx_load_default_font
  872                        			ldx	#SGX_VDC_OFFSET		; Offset to SGX VDC.
  873                        			call	huc_monofont_x
  874                        			.endm
  875                        		.endif
  876                        	
  877                        			.macro	_load_default_font
  878                        			clx				; Offset to PCE VDC.
  879                        			call	huc_monofont_x
  880                        			.endm
  881                        	
  882                        	
  883                        	
  884                        	; ***************************************************************************
  885                        	; ***************************************************************************
  886                        	
  887               0000     		.if	0
  905                        		.endif
                             #[2]   "..\..\..\include\hucc\hucc.asm"
  228                        	
  229               0000     		.if	CDROM
  231                        		.endif
  232                        	
  233                        			; Definitions for compatibility with old HuC/MagicKit projects.
  234                        	
  235               0001     		.ifndef	HUCC_NO_DEPRECATED
                             #[3]   "..\..\..\include\hucc\hucc-deprecated.inc"
  236                        			include	"hucc-deprecated.inc"
    1                        	; ***************************************************************************
    2                        	; ***************************************************************************
    3                        	;
    4                        	; hucc-deprecated.inc
    5                        	;
    6                        	; Macros and definitions for compatibility with old HuC/MagicKit projects.
    7                        	;
    8                        	; Based on the original HuC and MagicKit definitions by David Michel and the
    9                        	; other original HuC developers.
   10                        	;
   11                        	; ***************************************************************************
   12                        	; ***************************************************************************
   13                        	
   14                        			; For compatibility with HuC projects that use the old name.
   15                        	
   16               0001     	HUC_USER_RESERVED = HUC_USER_BANK
   17                        	
   18                        			; For compatibility with code that expects the HuC naming that
   19                        			; is used in the newer HuC, rather than the original HuC v3.21.
   20                        			;
   21                        			; Code generated by HuCC uses the original single-underscore.
   22                        	
   23               0001     		.if	1				
   24               0002     	__bp		=	$F8:20EC, 2		; base pointer
   25               0002     	__si		=	$F8:20EE, 2		; source address
   26               0002     	__di		=	$F8:20F0, 2		; destination address
   27                        	
   28               0002     	__ax		=	$F8:20F8, 2
   29               0001     	__al		=	$F8:20F8, 1
   30               0001     	__ah		=	$F8:20F9, 1
   31                        	
   32               0002     	__bx		=	$F8:20FA, 2
   33               0001     	__bl		=	$F8:20FA, 1
   34               0001     	__bh		=	$F8:20FB, 1
   35                        	
   36               0002     	__cx		=	$F8:20FC, 2
   37               0001     	__cl		=	$F8:20FC, 1
   38               0001     	__ch		=	$F8:20FD, 1
   39                        	
   40               0002     	__dx		=	$F8:20FE, 2
   41               0001     	__dl		=	$F8:20FE, 1
   42               0001     	__dh		=	$F8:20FF, 1
   43                        		.endif
   44                        	
   45                        			; For compatibility with code that expects the HuC naming that
   46                        			; is used rather than the shorter upper-case #define naming.
   47                        	
   48               0001     		.if	1				
   49               0001     	video_reg	=	$FF:0200, 1		; Address/Status Register
   50               0001     	video_reg_l	=	$FF:0200, 1		; Address/Status Register
   51               0001     	video_reg_h	=	$FF:0201, 1		; Address/Status Register
   52               0002     	video_data	=	$FF:0202, 2		; Data (Read/Write) Low
   53               0001     	video_data_l	=	$FF:0202, 1		; Data (Read/Write) Low
   54               0001     	video_data_h	=	$FF:0203, 1		; Data (Read/Write) High
   55                        	
   56               0002     	color_ctrl	=	$FF:0400, 2		; Control Register
   57               0002     	color_reg	=	$FF:0402, 2		; Color Table Address
   58               0001     	color_reg_l	=	$FF:0402, 1		; Color Table Address
   59               0001     	color_reg_h	=	$FF:0402, 1		; Color Table Address
   60               0002     	color_data	=	$FF:0404, 2		; Color Table Data Read/Write
   61               0001     	color_data_l	=	$FF:0404, 1		; Color Table Data Read/Write
   62               0001     	color_data_h	=	$FF:0405, 1		; Color Table Data Read/Write
   63                        	
   64               0001     	psg_ch		=	$FF:0800, 1		; Channel Select
   65               0001     	psg_mainvol	=	$FF:0801, 1		; Main Amplitude Level
   66               0001     	psg_freqlo	=	$FF:0802, 1		; Frequency Low
   67               0001     	psg_freqhi	=	$FF:0803, 1		; Frequency High
   68               0001     	psg_ctrl	=	$FF:0804, 1		; Control & Channel Amplitude
   69               0001     	psg_pan		=	$FF:0805, 1		; L/R Amplitude Level
   70               0001     	psg_wavebuf	=	$FF:0806, 1		; Waveform
   71               0001     	psg_noise	=	$FF:0807, 1		; Noise
   72               0001     	psg_lfofreq	=	$FF:0808, 1		; LFO Frequency
   73               0001     	psg_lfoctrl	=	$FF:0809, 1		; LFO Control
   74                        	
   75               0001     	irq_m		=	irq_vec, 1		; Old System Card name.
   76               0002     	irq2_jmp	=	irq2_hook, 2		; Old System Card name.
   77               0002     	irq1_jmp	=	irq1_hook, 2		; Old System Card name.
   78               0002     	timer_jmp	=	timer_hook, 2		; Old System Card name.
   79               0002     	nmi_jmp		=	nmi_hook, 2		; Old System Card name.
   80               0002     	sat_adr		=	satb_addr, 2		; Old System Card name.
   81               0005     	joy		=	joynow, 5		; Old System Card name.
   82               0001     	mwr_m		=	vdc_mwr, 1		; Old System Card name.
   83               0001     	dcr_m		=	vdc_dcr, 1		; Old System Card name.
   84                        		.endif
   85                        	
   86                        			; Macros for compatibility with #asm usage in old HuC projects.
   87                        	
   88                        	stw		.macro
   89                        			lda.l	\1
   90                        			sta.l	\2
   91                        			lda.h	\1
   92                        			sta.h	\2
   93                        			.endm
   94                        	
   95                        	stb		.macro
   96                        			lda	\1
   97                        			sta	\2
   98                        			.endm
   99                        	
  100                        	addw		.macro
  101                        		.if	(\# = 3)
  102                        			clc
  103                        			lda.l	\2
  104                        			adc.l	\1
  105                        			sta.l	\3
  106                        			lda.h	\2
  107                        			adc.h	\1
  108                        			sta.h	\3
  109                        		.else
  110                        			clc
  111                        			lda.l	\2
  112                        			adc.l	\1
  113                        			sta.l	\2
  114                        			lda.h	\2
  115                        			adc.h	\1
  116                        			sta.h	\2
  117                        		.endif
  118                        			.endm
  119                        	
  120                        	add		.macro			; add byte-sized value to
  121                        		.if (\# = 2)			; register A (handle carry
  122                        			lda	\2		; flag)
  123                        			clc
  124                        			adc	\1
  125                        			sta	\2
  126                        		.else
  127                        			clc
  128                        			adc	\1
  129                        		.endif
  130                        			.endm
  131                        	
  132                        	subw		.macro
  133                        			sec
  134                        			lda.l	\2
  135                        			sbc.l	\1
  136                        			sta.l	\2
  137                        			lda.h	\2
  138                        			sbc.h	\1
  139                        			sta.h	\2
  140                        			.endm
  141                        	
  142                        	sub		.macro			; subtract byte-sized value
  143                        		.if (\# = 2)			; from register A (handle
  144                        			lda	\2		; carry flag)
  145                        			sec
  146                        			sbc	\1
  147                        			sta	\2
  148                        		.else
  149                        			sec
  150                        			sbc	\1
  151                        		.endif
  152                        			.endm
  153                        	
  154                        	incw		.macro			; increment a word-sized
  155                        			inc.l	\1		; value at stated memory
  156                        			bne	!+		; location
  157                        			inc.h	\1
  158                        	!:
  159                        			.endm
  160                        	
  161                        	decw		.macro			; decrement a word-sized
  162                        			lda	\1		; value at stated memory
  163                        			bne	!+		; location
  164                        			dec.h	\1
  165                        	!:		dec.l	\1
  166                        			.endm
  167                        	
  168                        	lbne		.macro
  169                        			bne	\1
  170                        			.endm
  171                        	
  172                        	lbeq		.macro
  173                        			beq	\1
  174                        			.endm
  175                        	
  176                        	lbpl		.macro
  177                        			bpl	\1
  178                        			.endm
  179                        	
  180                        	lbmi		.macro
  181                        			bmi	\1
  182                        			.endm
  183                        	
  184                        	lbcc		.macro
  185                        			bcc	\1
  186                        			.endm
  187                        	
  188                        	lbcs		.macro
  189                        			bcs	\1
  190                        			.endm
  191                        	
  192                        	lblo		.macro
  193                        			bcc	\1
  194                        			.endm
  195                        	
  196                        	lbhs		.macro
  197                        			bcs	\1
  198                        			.endm
  199                        	
  200                        	__ldwi		.macro
  201                        		__ld.wi		\1
  202                        			.endm
                             #[2]   "..\..\..\include\hucc\hucc.asm"
  237                        		.endif
  238                        	
  239                        			;
  240                        			;
  241                        			;
  242                        	
  243                        	
  244                        	
  245                        	; ***************************************************************************
  246                        	; ***************************************************************************
  247                        	;
  248                        	; core_main - This is executed after "CORE(not TM)" library initialization.
  249                        	;
  250                        	; This is the first code assembled after the library includes, so we're still
  251                        	; in the CORE_BANK, usually ".bank 0"; and because this is assembled with the
  252                        	; default configuration from "include/core-config.inc", which sets the option
  253                        	; "USING_MPR7", then we're running in MPR7 ($E000-$FFFF).
  254                        	
  255    11:C54C             	core_main	.proc
  256                        	
  257               0001     		.if	SUPPORT_SGX
  258    11:C54C  A9 F9      			lda	#$F9			; Map the 2nd SGX RAM bank.
  259                        		.else
  261                        		.endif
  262    11:C54E  53 04      			tam2
  263                        	
  264    11:C550  A9 01      			lda	#CONST_BANK + _bank_base; Map HuCC's .RODATA bank.
  265    11:C552  53 08      			tam3
  266    11:C554  1A         			inc	a
  267    11:C555  53 10      			tam4
  268                        	
  269               0000     		.ifdef	HOME_BANK
  271                        		.else
  272    11:C557  1A         			inc	a
  273                        		.endif
  274    11:C558  53 20      			tam5
  275                        	
  276    11:C55A  08         			php				; Disable interrupts while
  277    11:C55B  78         			sei				; clearing overlay's BSS.
  278                        	
  279               0000     		.ifndef	USING_RCR_MACROS
  294                        		.endif	USING_RCR_MACROS
  295                        	
  296    11:C55C  A9 CC      			lda	#<hucc_vbl		; Setup HuCC's VBL IRQ handler.
  297    11:C55E  8D 08 22   			sta.l	vsync_hook
  298    11:C561  A9 E2      			lda	#>hucc_vbl
  299    11:C563  8D 09 22   			sta.h	vsync_hook
  300                        	
  301               0000     		.if	CDROM				; Overlays should clear BSS.
  303                        		.else
  304    11:C566  73 B3 C5 F0			tii	.rom_tia, ram_tia, 16	; Only needed on HuCARD.
         11:C56A  22 10 00    
  305                        		.endif	CDROM
  306                        	
  307               0000     		.if	(__heap_start - __bss_init)	; Copy initialized BSS data.
  309                        		.endif
  310                        	
  311    11:C56D  F3 B1 C5 08			tai	.stack_fill, __stack, HUCC_STACK_SZ
         11:C571  20 80 00    
  312                        	
  313               0000     		.if	FAST_MULTIPLY
  322                        		.endif
  323                        	
  324    11:C574  A9 10      			lda	#$10			; Enable HuCC's vblank IRQ
  325    11:C576  04 F5      			tsb	<irq_vec		; handler.
  326                        	
  327                        			__sound_init			; Initialize a sound driver.
  328                        	
  329    11:C578  AD 00 02   			lda	VDC_SR			; Purge any overdue VBL.
  330    11:C57B  9C 41 22   			stz	irq_cnt			; Make it easy to check.
  331                        	
  332    11:C57E  28         			plp				; Restore interrupts.
  333                        	
  334               0001     		.ifndef	HUCC_NO_DEFAULT_SCREEN
  335    11:C57F  20 D1 FF   			call	_init_256x224		; HuCC initializes the VDC and
  336    11:C582  20 16 E4   			jsr	set_dspon		; turns the display on.
  337                        		.endif
  338                        	
  339               0001     		.ifndef	HUCC_NO_DEFAULT_FONT
  340    11:C585  A9 01      			lda	#1			; HuCC loads a default font.
  341    11:C587  8D A1 26   			sta	monofont_fg
  342    11:C58A  9C A2 26   			stz	monofont_bg
  343                        			_load_default_font
         11:C58D  82         			clx				; Offset to PCE VDC.
         11:C58E  20 C7 FF   			call	huc_monofont_x
  344    11:C591  A9 01      			lda	#$01			; Set the font palette entry to
  345    11:C593  8D 02 04   			sta.l	VCE_CTA			; cyan which is a) visible, but
  346    11:C596  9C 03 04   			stz.h	VCE_CTA			; b) a clear indicator that the
  347    11:C599  A0 96      			ldy	#$96			; user hasn't set a palette yet.
  348    11:C59B  8C 04 04   			sty.l	VCE_CTW
  349    11:C59E  8D 05 04   			sta.h	VCE_CTW
  350                        		.endif
  351                        	
  352               0001     		.ifndef	HUCC_NO_DEFAULT_RANDOM
  353    11:C5A1  AC 41 22   			ldy	irq_cnt			; Initialize random seed.
  354    11:C5A4  20 BD FF   			call	init_random
  355                        		.endif
  356                        	
  357    11:C5A7  A2 80      			ldx	#HUCC_STACK_SZ		; Initialize the HuCC stack.
  358    11:C5A9  86 8D      			stx	<__sp
  359                        	
  360    11:C5AB  20 B3 FF   			call	_main			; Execute the HuCC program.
  361                        	
  362    11:C5AE  4C 88 E2   			jmp	_exit.1			; Pass the exit code on.
  363                        	
  364    11:C5B1  EA EA      	.stack_fill:	db	$EA,$EA			; To make it easier to see.
  365                        	
  366               0001     		.if	!CDROM
  367                        	
  368    11:C5B3  E3 34 12 02	.rom_tia:	tia	$1234, VDC_DL, 32
         11:C5B7  02 20 00    
  369    11:C5BA  60         			rts
  370                        	
  371    11:C5BB  73 34 12 78	.rom_tii:	tii	$1234, $5678, $9ABC
         11:C5BF  56 BC 9A    
  372    11:C5C2  60         			rts
  373                        	
  374               22F0     			.bss
  375    F8:22F0             	ram_tia:	ds	8
  376    F8:22F8             	ram_tii:	ds	8
  377               C5C3     			.code
  378                        	
  379                        		.endif	!CDROM
  380                        	
  381                        			.endp
  382                        	
  383                        			;
  384                        			; Self-Modifying TIA and TII instruction subroutines.
  385                        			;
  386                        			; These need to be in permanently-accessible memory so that
  387                        			; HuCC code can modify the values as __fastcall parameters.
  388                        			;
  389                        	
  390               0000     		.if	CDROM
  398                        		.endif	CDROM
  399                        	
  400               22F0     			rsset	ram_tia
  401               22F0     	ram_tia_opc	rs	1
  402               22F1     	ram_tia_src	rs	2
  403               22F3     	ram_tia_dst	rs	2
  404               22F5     	ram_tia_len	rs	2
  405               22F7     	ram_tia_rts	rs	1
  406                        	
  407               22F8     			rsset	ram_tii
  408               22F8     	ram_tii_opc	rs	1
  409               22F9     	ram_tii_src	rs	2
  410               22FB     	ram_tii_dst	rs	2
  411               22FD     	ram_tii_len	rs	2
  412               22FF     	ram_tii_rts	rs	1
  413                        	
  414                        	
  415                        	
  416                        	; ***************************************************************************
  417                        	; ***************************************************************************
  418                        	;
  419                        	; hucc_vbl - vblank IRQ handler, called by the "CORE(not TM)" kernel.
  420                        	;
  421                        	; This uses the kernel's hook to process things during vblank. It returns
  422                        	; with a simple RTS, and it can corrupt any register.
  423                        	;
  424                        	; Any slow routines in here should enable interrupts and protect itself from
  425                        	; re-entrancy problems.
  426                        	;
  427                        	
  428    00:E2CC  20 A9 FF   	hucc_vbl:	call	vbl_init_scroll		; Prepare for the next frame.
  429                        	
  430    00:E2CF  F8         			sed				; Update the HuC system clock
  431    00:E2D0  38         			sec				; which is in BCD here rather
  432    00:E2D1  AD EF 22   			lda	clock_tt		; than the binary one in HuC.
  433    00:E2D4  69 00      			adc	#0			; BCD add ...
  434    00:E2D6  C9 60      			cmp	#$60			; ... but binary comparison.
  435    00:E2D8  90 28      			bcc	.ticks
  436    00:E2DA  AD EE 22   			lda	clock_ss
  437    00:E2DD  69 00      			adc	#0			; BCD add ...
  438    00:E2DF  C9 60      			cmp	#$60			; ... but binary comparison.
  439    00:E2E1  90 1B      			bcc	.seconds
  440    00:E2E3  AD ED 22   			lda	clock_mm
  441    00:E2E6  69 00      			adc	#0			; BCD add ...
  442    00:E2E8  C9 60      			cmp	#$60			; ... but binary comparison.
  443    00:E2EA  90 0E      			bcc	.minutes
  444    00:E2EC  AD EC 22   			lda	clock_hh
  445    00:E2EF  69 00      			adc	#0			; BCD add ...
  446    00:E2F1  C9 12      			cmp	#$12			; ... but binary comparison.
  447    00:E2F3  90 01      			bcc	.hours
  448    00:E2F5  62         			cla
  449    00:E2F6  8D EC 22   	.hours:		sta	clock_hh
  450    00:E2F9  62         			cla
  451    00:E2FA  8D ED 22   	.minutes:	sta	clock_mm
  452    00:E2FD  62         			cla
  453    00:E2FE  8D EE 22   	.seconds:	sta	clock_ss
  454    00:E301  62         			cla
  455    00:E302  8D EF 22   	.ticks:		sta	clock_tt
  456    00:E305  D8         			cld
  457                        	
  458    00:E306  4C 96 E3   			jmp	xfer_palettes		; Upload any palette changes.
                             #[1]   "main.s"
   15               6000     			.data
   16               0003     			.bank	DATA_BANK
   17                        	
   18               E309     		.code
   19                        	
   20                        		.dbg	line,	"..\..\..\include\hucc\globals.h", 1; // **************************************************************************
   21                        		.dbg	line,	"..\..\..\include\hucc\globals.h", 2; // **************************************************************************
   22                        		.dbg	line,	"..\..\..\include\hucc\globals.h", 3; //
   23                        		.dbg	line,	"..\..\..\include\hucc\globals.h", 4; // globals.h
   24                        		.dbg	line,	"..\..\..\include\hucc\globals.h", 5; //
   25                        		.dbg	line,	"..\..\..\include\hucc\globals.h", 6; // **************************************************************************
   26                        		.dbg	line,	"..\..\..\include\hucc\globals.h", 7; // **************************************************************************
   27                        		.dbg	line,	"..\..\..\include\hucc\globals.h", 8; //
   28                        		.dbg	line,	"..\..\..\include\hucc\globals.h", 9; // The idea is that you, a PCE developer, copy this file from the ../include/
   29                        		.dbg	line,	"..\..\..\include\hucc\globals.h", 10; // directory and into your project's directory, and then define the variables
   30                        		.dbg	line,	"..\..\..\include\hucc\globals.h", 11; // that you want to have shared access to in all overlay programs on your CD.
   31                        		.dbg	line,	"..\..\..\include\hucc\globals.h", 12; //
   32                        		.dbg	line,	"..\..\..\include\hucc\globals.h", 13; // Because PCEAS searches the current (i.e. project) directory for an include
   33                        		.dbg	line,	"..\..\..\include\hucc\globals.h", 14; // file first, then it will find your customized copy of the file rather than
   34                        		.dbg	line,	"..\..\..\include\hucc\globals.h", 15; // the original copy in the ../include/ directory.
   35                        		.dbg	line,	"..\..\..\include\hucc\globals.h", 16; //
   36                        		.dbg	line,	"..\..\..\include\hucc\globals.h", 17; // **************************************************************************
   37                        		.dbg	line,	"..\..\..\include\hucc\globals.h", 18; // **************************************************************************
   38                        		.dbg	clear
   39               2300     		.bss
   40    F8:2300             	huc_globals:
   41                        	
   42    F8:2300             	huc_globals_end:
   43               E309     		.code
   44                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 1; #ifndef _hucc_legacy_h
   45                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 2; #define _hucc_legacy_h
   46                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 4; /****************************************************************************
   47                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 5; ; ***************************************************************************
   48                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 6; ;
   49                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 7; ; huc.h
   50                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 8; ;
   51                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 9; ; HuCC wrapper file to include a default set of HuC-compatible functions.
   52                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 10; ;
   53                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 11; ; Copyright John Brandwood 2024.
   54                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 12; ;
   55                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 13; ; Distributed under the Boost Software License, Version 1.0.
   56                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 14; ; (See accompanying file LICENSE_1_0.txt or copy at
   57                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 15; ;  http://www.boost.org/LICENSE_1_0.txt)
   58                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 16; ;
   59                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 17; ; ***************************************************************************
   60                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 18; ; ***************************************************************************
   61                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 19; ;
   62                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 20; ; When the HuCC compiler is invoked with the "--legacy" option to compile old
   63                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 21; ; projects, then this "huc.h" file is automatically included.
   64                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 22; ;
   65                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 23; ; This file includes a set of the individual HuCC headers which correspond to
   66                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 24; ; HuC's built-in functions and MagicKit library.
   67                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 25; ;
   68                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 26; ; New HuCC projects should, preferably, include the specific headers that are
   69                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 27; ; needed, which will then allow them to replace parts of the standard library
   70                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 28; ; with newer functions, or they can just manually include this "huc.h" file.
   71                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 29; ;
   72                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 30; ; ***************************************************************************
   73                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 31; ; **************************************************************************/
   74                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 33; #include "hucc-systemcard.h"
   75                        		.dbg	line,	"..\..\..\include\hucc\hucc-systemcard.h", 1; #ifndef _hucc_systemcard_h
   76                        		.dbg	line,	"..\..\..\include\hucc\hucc-systemcard.h", 2; #define _hucc_systemcard_h
   77                        		.dbg	line,	"..\..\..\include\hucc\hucc-systemcard.h", 4; /****************************************************************************
   78                        		.dbg	line,	"..\..\..\include\hucc\hucc-systemcard.h", 5; ; ***************************************************************************
   79                        		.dbg	line,	"..\..\..\include\hucc\hucc-systemcard.h", 6; ;
   80                        		.dbg	line,	"..\..\..\include\hucc\hucc-systemcard.h", 7; ; hucc-systemcard.h
   81                        		.dbg	line,	"..\..\..\include\hucc\hucc-systemcard.h", 8; ;
   82                        		.dbg	line,	"..\..\..\include\hucc\hucc-systemcard.h", 9; ; Macros and library functions for using the System Card.
   83                        		.dbg	line,	"..\..\..\include\hucc\hucc-systemcard.h", 10; ;
   84                        		.dbg	line,	"..\..\..\include\hucc\hucc-systemcard.h", 11; ; Copyright John Brandwood 2024.
   85                        		.dbg	line,	"..\..\..\include\hucc\hucc-systemcard.h", 12; ;
   86                        		.dbg	line,	"..\..\..\include\hucc\hucc-systemcard.h", 13; ; Distributed under the Boost Software License, Version 1.0.
   87                        		.dbg	line,	"..\..\..\include\hucc\hucc-systemcard.h", 14; ; (See accompanying file LICENSE_1_0.txt or copy at
   88                        		.dbg	line,	"..\..\..\include\hucc\hucc-systemcard.h", 15; ;  http://www.boost.org/LICENSE_1_0.txt)
   89                        		.dbg	line,	"..\..\..\include\hucc\hucc-systemcard.h", 16; ;
   90                        		.dbg	line,	"..\..\..\include\hucc\hucc-systemcard.h", 17; ; ***************************************************************************
   91                        		.dbg	line,	"..\..\..\include\hucc\hucc-systemcard.h", 18; ; ***************************************************************************
   92                        		.dbg	line,	"..\..\..\include\hucc\hucc-systemcard.h", 19; ;
   93                        		.dbg	line,	"..\..\..\include\hucc\hucc-systemcard.h", 20; ; Because these are mainly macros, and so must be included before being used
   94                        		.dbg	line,	"..\..\..\include\hucc\hucc-systemcard.h", 21; ; in compiled code, the actual functions here are written to avoid using any
   95                        		.dbg	line,	"..\..\..\include\hucc\hucc-systemcard.h", 22; ; BSS memory so that HuCC's overlay global-shared-variables are not effected.
   96                        		.dbg	line,	"..\..\..\include\hucc\hucc-systemcard.h", 23; ;
   97                        		.dbg	line,	"..\..\..\include\hucc\hucc-systemcard.h", 24; ; ***************************************************************************
   98                        		.dbg	line,	"..\..\..\include\hucc\hucc-systemcard.h", 25; ; **************************************************************************/
   99                        		.dbg	line,	"..\..\..\include\hucc\hucc-systemcard.h", 27; // *************
  100                        		.dbg	line,	"..\..\..\include\hucc\hucc-systemcard.h", 28; // Backup RAM defines ...
  101                        		.dbg	line,	"..\..\..\include\hucc\hucc-systemcard.h", 29; // *************
  102                        		.dbg	line,	"..\..\..\include\hucc\hucc-systemcard.h", 31; #define  BM_OK             0
  103                        		.dbg	line,	"..\..\..\include\hucc\hucc-systemcard.h", 32; #define  BM_NOT_FOUND      1
  104                        		.dbg	line,	"..\..\..\include\hucc\hucc-systemcard.h", 33; #define  BM_BAD_CHECKSUM   2
  105                        		.dbg	line,	"..\..\..\include\hucc\hucc-systemcard.h", 34; #define  BM_DIR_CORRUPTED  3
  106                        		.dbg	line,	"..\..\..\include\hucc\hucc-systemcard.h", 35; #define  BM_FILE_EMPTY     4
  107                        		.dbg	line,	"..\..\..\include\hucc\hucc-systemcard.h", 36; #define  BM_FULL           5
  108                        		.dbg	line,	"..\..\..\include\hucc\hucc-systemcard.h", 37; #define  BM_NOT_FORMATED   0xFF			// HuC incorrect spelling.
  109                        		.dbg	line,	"..\..\..\include\hucc\hucc-systemcard.h", 38; #define  BM_NOT_FORMATTED  0xFF			// HuCC can use a dictionary!
  110                        		.dbg	line,	"..\..\..\include\hucc\hucc-systemcard.h", 40; #define  BRAM_STARTPTR     0x8010
  111                        		.dbg	line,	"..\..\..\include\hucc\hucc-systemcard.h", 42; // *************
  112                        		.dbg	line,	"..\..\..\include\hucc\hucc-systemcard.h", 43; // CD defines ...
  113                        		.dbg	line,	"..\..\..\include\hucc\hucc-systemcard.h", 44; // *************
  114                        		.dbg	line,	"..\..\..\include\hucc\hucc-systemcard.h", 46; #define	CDPLAY_MUTE		0
  115                        		.dbg	line,	"..\..\..\include\hucc\hucc-systemcard.h", 47; #define	CDPLAY_REPEAT		1
  116                        		.dbg	line,	"..\..\..\include\hucc\hucc-systemcard.h", 48; #define	CDPLAY_NORMAL		2
  117                        		.dbg	line,	"..\..\..\include\hucc\hucc-systemcard.h", 49; #define	CDPLAY_ENDOFDISC	0
  118                        		.dbg	line,	"..\..\..\include\hucc\hucc-systemcard.h", 51; #define	CDFADE_CANCEL	0
  119                        		.dbg	line,	"..\..\..\include\hucc\hucc-systemcard.h", 52; #define	CDFADE_PCM6	8
  120                        		.dbg	line,	"..\..\..\include\hucc\hucc-systemcard.h", 53; #define	CDFADE_ADPCM6	10
  121                        		.dbg	line,	"..\..\..\include\hucc\hucc-systemcard.h", 54; #define	CDFADE_PCM2	12
  122                        		.dbg	line,	"..\..\..\include\hucc\hucc-systemcard.h", 55; #define	CDFADE_ADPCM2	14
  123                        		.dbg	line,	"..\..\..\include\hucc\hucc-systemcard.h", 57; #define CDTRK_AUDIO	0
  124                        		.dbg	line,	"..\..\..\include\hucc\hucc-systemcard.h", 58; #define CDTRK_DATA	4
  125                        		.dbg	line,	"..\..\..\include\hucc\hucc-systemcard.h", 60; // *************
  126                        		.dbg	line,	"..\..\..\include\hucc\hucc-systemcard.h", 61; // ADPCM defines ...
  127                        		.dbg	line,	"..\..\..\include\hucc\hucc-systemcard.h", 62; // *************
  128                        		.dbg	line,	"..\..\..\include\hucc\hucc-systemcard.h", 64; #define	ADPLAY_AUTOSTOP		0
  129                        		.dbg	line,	"..\..\..\include\hucc\hucc-systemcard.h", 65; #define	ADPLAY_REPEAT		0x80
  130                        		.dbg	line,	"..\..\..\include\hucc\hucc-systemcard.h", 67; #define ADPLAY_FREQ_16KHZ	0xE
  131                        		.dbg	line,	"..\..\..\include\hucc\hucc-systemcard.h", 68; #define ADPLAY_FREQ_10KHZ	0xD
  132                        		.dbg	line,	"..\..\..\include\hucc\hucc-systemcard.h", 69; #define ADPLAY_FREQ_8KHZ	0xC
  133                        		.dbg	line,	"..\..\..\include\hucc\hucc-systemcard.h", 70; #define ADPLAY_FREQ_6KHZ	0xB
  134                        		.dbg	line,	"..\..\..\include\hucc\hucc-systemcard.h", 71; #define ADPLAY_FREQ_5KHZ	0xA
  135                        		.dbg	line,	"..\..\..\include\hucc\hucc-systemcard.h", 73; #define ADREAD_RAM	0
  136                        		.dbg	line,	"..\..\..\include\hucc\hucc-systemcard.h", 74; #define ADREAD_VRAM	0xFF
  137                        		.dbg	line,	"..\..\..\include\hucc\hucc-systemcard.h", 76; #define ADWRITE_RAM	0
  138                        		.dbg	line,	"..\..\..\include\hucc\hucc-systemcard.h", 77; #define ADWRITE_VRAM	0xFF
  139                        		.dbg	line,	"..\..\..\include\hucc\hucc-systemcard.h", 79; // *************
  140                        		.dbg	line,	"..\..\..\include\hucc\hucc-systemcard.h", 80; // Functions in hucc-systemcard.asm ...
  141                        		.dbg	line,	"..\..\..\include\hucc\hucc-systemcard.h", 81; // *************
  142                        		.dbg	line,	"..\..\..\include\hucc\hucc-systemcard.h", 83; #ifdef __HUCC__
  143                        		.dbg	line,	"..\..\..\include\hucc\hucc-systemcard.h", 85; #asmdef	HUCC_USES_SYSTEMCARD 1
  144               0001     	HUCC_USES_SYSTEMCARD = 1
  145                        		.dbg	line,	"..\..\..\include\hucc\hucc-systemcard.h", 87; extern void __fastcall __macro cd_boot( void );
  146                        		.dbg	line,	"..\..\..\include\hucc\hucc-systemcard.h", 88; extern unsigned int __fastcall __macro cd_getver( void );
  147                        		.dbg	line,	"..\..\..\include\hucc\hucc-systemcard.h", 89; extern void __fastcall __macro cd_reset( void );
  148                        		.dbg	line,	"..\..\..\include\hucc\hucc-systemcard.h", 90; extern unsigned char __fastcall __macro cd_pause( void );
  149                        		.dbg	line,	"..\..\..\include\hucc\hucc-systemcard.h", 91; extern unsigned char __fastcall cd_unpause( void );
  150                        		.dbg	line,	"..\..\..\include\hucc\hucc-systemcard.h", 92; extern void __fastcall __macro cd_fade( unsigned char type<acc> );
  151                        		.dbg	line,	"..\..\..\include\hucc\hucc-systemcard.h", 93; extern unsigned char __fastcall cd_playtrk( unsigned char start_track<_bx>, unsigned char end_track<_cx>, unsigned char mode<_dh> );
  152                        		.dbg	line,	"..\..\..\include\hucc\hucc-systemcard.h", 94; extern unsigned char __fastcall cd_playmsf( unsigned char start_minute<_al>,  unsigned char start_second<_ah>,  unsigned char start_frame<_bl>, unsigned char end_minute<_cl>,  unsigned char end_second<_ch>,  unsigned char end_frame<_dl>,  unsigned char mode<_dh> );
  153                        		.dbg	line,	"..\..\..\include\hucc\hucc-systemcard.h", 95; extern unsigned char __fastcall cd_fastvram( unsigned char ovl_index<_cl>, unsigned int sect_offset<_si>, unsigned int vramaddr<_bx>, unsigned int sectors<_al> );
  154                        		.dbg	line,	"..\..\..\include\hucc\hucc-systemcard.h", 96; extern unsigned char __fastcall cd_loadvram( unsigned char ovl_index<_cl>, unsigned int sect_offset<_si>, unsigned int vramaddr<_bx>, unsigned int bytes<_ax> );
  155                        		.dbg	line,	"..\..\..\include\hucc\hucc-systemcard.h", 97; extern unsigned char __fastcall cd_loaddata( unsigned char ovl_index<_cl>, unsigned int sect_offset<_si>, unsigned char __far *buffer<_bp_bank:_bp>, unsigned int bytes<__ptr> );
  156                        		.dbg	line,	"..\..\..\include\hucc\hucc-systemcard.h", 98; extern unsigned char __fastcall cd_loadbank( unsigned char ovl_index<_cl>, unsigned int sect_offset<_si>, unsigned char bank<_bl>, unsigned int sectors<_al> );
  157                        		.dbg	line,	"..\..\..\include\hucc\hucc-systemcard.h", 99; extern unsigned char __fastcall __macro cd_status( unsigned char mode<acc> );
  158                        		.dbg	line,	"..\..\..\include\hucc\hucc-systemcard.h", 101; extern void __fastcall __macro ad_reset( void );
  159                        		.dbg	line,	"..\..\..\include\hucc\hucc-systemcard.h", 102; extern unsigned char __fastcall __macro ad_trans( unsigned char ovl_index<_cl>, unsigned int sect_offset<_si>, unsigned char nb_sectors<_dh>, unsigned int ad_addr<_bx> );
  160                        		.dbg	line,	"..\..\..\include\hucc\hucc-systemcard.h", 103; extern void __fastcall __macro ad_read( unsigned int ad_addr<_cx>, unsigned char mode<_dh>, unsigned int buf<_bx>, unsigned int bytes<_ax> );
  161                        		.dbg	line,	"..\..\..\include\hucc\hucc-systemcard.h", 104; extern void __fastcall __macro ad_write( unsigned int ad_addr<_cx>, unsigned char mode<_dh>, unsigned int buf<_bx>, unsigned int bytes<_ax> );
  162                        		.dbg	line,	"..\..\..\include\hucc\hucc-systemcard.h", 105; extern unsigned char __fastcall __macro ad_play( unsigned int ad_addr<_bx>, unsigned int bytes<_ax>, unsigned char freq<_dh>, unsigned char mode<_dl> );
  163                        		.dbg	line,	"..\..\..\include\hucc\hucc-systemcard.h", 106; extern unsigned char __fastcall __macro ad_cplay( unsigned char ovl_index<_cl>, unsigned int sect_offset<_si>, unsigned int nb_sectors<_bx>, unsigned char freq<_dh> );
  164                        		.dbg	line,	"..\..\..\include\hucc\hucc-systemcard.h", 107; extern void __fastcall __macro ad_stop( void );
  165                        		.dbg	line,	"..\..\..\include\hucc\hucc-systemcard.h", 108; extern unsigned char __fastcall __macro ad_stat( void );
  166                        		.dbg	line,	"..\..\..\include\hucc\hucc-systemcard.h", 110; extern unsigned char __fastcall bm_check( void );
  167                        		.dbg	line,	"..\..\..\include\hucc\hucc-systemcard.h", 111; extern unsigned char __fastcall bm_format( void );
  168                        		.dbg	line,	"..\..\..\include\hucc\hucc-systemcard.h", 112; extern unsigned int __fastcall __macro bm_free( void );
  169                        		.dbg	line,	"..\..\..\include\hucc\hucc-systemcard.h", 113; extern unsigned char __fastcall __macro bm_read( unsigned char *buffer<_bx>, unsigned char *name<_ax>, unsigned int offset<_dx>, unsigned int length<_cx> );
  170                        		.dbg	line,	"..\..\..\include\hucc\hucc-systemcard.h", 114; extern unsigned char __fastcall __macro bm_write( unsigned char *buffer<_bx>, unsigned char *name<_ax>, unsigned int offset<_dx>, unsigned int length<_cx> );
  171                        		.dbg	line,	"..\..\..\include\hucc\hucc-systemcard.h", 115; extern unsigned char __fastcall __macro bm_delete( unsigned char *name<_ax> );
  172                        		.dbg	line,	"..\..\..\include\hucc\hucc-systemcard.h", 117; // Deprecated functions ...
  173                        		.dbg	line,	"..\..\..\include\hucc\hucc-systemcard.h", 119; extern unsigned char __fastcall __macro bm_exist( unsigned char *name<_ax> );
  174                        		.dbg	line,	"..\..\..\include\hucc\hucc-systemcard.h", 120; extern unsigned char __fastcall __macro bm_create( unsigned char *name<_ax>, unsigned int length<_cx> );
  175                        		.dbg	line,	"..\..\..\include\hucc\hucc-systemcard.h", 122; // void __fastcall _xsafe add_sectors( unsigned int sector_offset<acc> );
  176                        		.dbg	line,	"..\..\..\include\hucc\hucc-systemcard.h", 124; #endif // __HUCC__
  177                        		.dbg	line,	"..\..\..\include\hucc\hucc-systemcard.h", 126; #endif // _hucc_systemcard_h
  178                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 34; #include "hucc-baselib.h"
  179                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 1; #ifndef _hucc_baselib_h
  180                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 2; #define _hucc_baselib_h
  181                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 4; /****************************************************************************
  182                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 5; ; ***************************************************************************
  183                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 6; ;
  184                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 7; ; hucc-baselib.h
  185                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 8; ;
  186                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 9; ; Basic library functions provided as macros.
  187                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 10; ;
  188                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 11; ; Copyright John Brandwood 2024.
  189                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 12; ;
  190                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 13; ; Distributed under the Boost Software License, Version 1.0.
  191                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 14; ; (See accompanying file LICENSE_1_0.txt or copy at
  192                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 15; ;  http://www.boost.org/LICENSE_1_0.txt)
  193                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 16; ;
  194                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 17; ; ***************************************************************************
  195                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 18; ; **************************************************************************/
  196                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 20; // *************
  197                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 21; // Joypad defines ...
  198                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 22; // *************
  199                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 24; #define	JOY_A		0x01
  200                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 25; #define	JOY_I		0x01
  201                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 26; #define	JOY_B		0x02
  202                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 27; #define	JOY_II		0x02
  203                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 28; #define	JOY_SLCT	0x04
  204                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 29; #define	JOY_SEL		0x04
  205                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 30; #define	JOY_STRT	0x08
  206                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 31; #define	JOY_RUN		0x08
  207                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 32; #define	JOY_UP		0x10
  208                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 33; #define	JOY_RGHT	0x20
  209                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 34; #define	JOY_RIGHT	0x20
  210                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 35; #define	JOY_DOWN	0x40
  211                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 36; #define	JOY_LEFT	0x80
  212                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 38; #define	JOY_C		0x0100
  213                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 39; #define	JOY_III		0x0100
  214                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 40; #define	JOY_D		0x0200
  215                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 41; #define	JOY_IV		0x0200
  216                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 42; #define	JOY_E		0x0400
  217                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 43; #define	JOY_V		0x0400
  218                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 44; #define	JOY_F		0x0800
  219                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 45; #define	JOY_VI		0x0800
  220                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 47; #define JOY_SIXBUT	0x8000
  221                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 48; #define JOY_TYPE6	0x8000
  222                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 50; // *************
  223                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 51; // SuperGRAFX VPC settings for set_vpc_ctl() ...
  224                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 52; // *************
  225                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 54; #define VPC_SPR1_BKG1_SPR2_BKG2	0x3000 // same as SGX_PARALLAX=0
  226                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 55; #define VPC_SPR1_SPR2_BKG1_BKG2	0x7000 // same as SGX_PARALLAX=1
  227                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 56; #define VPC_BKG1_BKG2_SPR1_SPR2	0xB000
  228                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 58; // *************
  229                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 59; // System Card variables ...
  230                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 60; // *************
  231                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 62; extern unsigned int si;
  232                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 63; extern unsigned int di;
  233                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 64; extern unsigned int bp;
  234                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 66; extern unsigned int ax;
  235                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 67; extern unsigned int bx;
  236                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 68; extern unsigned int cx;
  237                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 69; extern unsigned int dx;
  238                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 71; extern unsigned char al;
  239                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 72; extern unsigned char ah;
  240                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 73; extern unsigned char bl;
  241                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 74; extern unsigned char bh;
  242                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 75; extern unsigned char cl;
  243                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 76; extern unsigned char ch;
  244                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 77; extern unsigned char dl;
  245                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 78; extern unsigned char dh;
  246                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 80; extern unsigned char irq_cnt;
  247                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 81; extern unsigned char joynow[5];
  248                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 82; extern unsigned char joytrg[5];
  249                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 83; extern unsigned char joy6now[5];
  250                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 84; extern unsigned char joy6trg[5];
  251                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 85; extern unsigned int  bg_x1;
  252                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 86; extern unsigned int  bg_y1;
  253                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 87; extern unsigned int  bg_x2;
  254                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 88; extern unsigned int  bg_y2;
  255                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 90; // *************
  256                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 91; // Special macros to get information from PCEAS ...
  257                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 92; // *************
  258                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 94; #define BANK( datasym ) ((unsigned) (&__bank__ ## datasym))
  259                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 95; #define SIZEOF( datasym ) ((unsigned) (&__sizeof__ ## datasym))
  260                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 96; #define COUNTOF( datasym ) ((unsigned) (&__countof__ ## datasym))
  261                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 97; #define OVERLAY( datasym ) ((unsigned) (&__overlay__ ## datasym))
  262                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 100; // *************
  263                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 101; // Functions in hucc-baselib.asm ...
  264                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 102; // *************
  265                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 104; #ifdef __HUCC__
  266                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 106; #asmdef	HUCC_USES_BASELIB 1
  267               0001     	HUCC_USES_BASELIB = 1
  268                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 108; #define	_OPTIMIZE 1
  269                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 111; // *************
  270                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 112; // Hardware Detection
  271                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 113; // *************
  272                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 115; extern unsigned char __fastcall __macro sgx_detect( void );
  273                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 116; extern unsigned char __fastcall __macro ac_exists( void );
  274                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 119; // *************
  275                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 120; // Memory Access
  276                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 121; // *************
  277                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 123; extern unsigned char __fastcall __macro peek( unsigned int addr<__ptr> );
  278                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 124; extern unsigned int  __fastcall __macro peekw( unsigned int addr<__ptr> );
  279                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 126; extern void __fastcall __macro poke( unsigned int addr<__poke>, unsigned char with<acc> );
  280                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 127; extern void __fastcall __macro pokew( unsigned int addr<__poke>, unsigned int with<acc> );
  281                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 129; extern unsigned char __fastcall farpeek( void __far *addr<_bp_bank:_bp> );
  282                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 130; extern unsigned int  __fastcall farpeekw( void __far *addr<_bp_bank:_bp> );
  283                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 132; extern void __fastcall __nop set_far_base( unsigned char data_bank<_bp_bank>, unsigned char *data_addr<_bp> );
  284                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 133; extern void __fastcall set_far_offset( unsigned int offset<_bp>, unsigned char data_bank<_bp_bank>, unsigned char *data_addr<acc> );
  285                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 135; extern unsigned char __fastcall far_peek( void );
  286                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 136; extern unsigned int  __fastcall far_peekw( void );
  287                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 138; extern void __fastcall __macro reset_mpr2( void );
  288                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 139; extern void __fastcall __macro reset_mpr34( void );
  289                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 141; extern void * __fastcall __macro farset_mpr2( void __far *addr<_bp_bank:_bp> );
  290                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 142; extern void * __fastcall __macro farset_mpr34( void __far *addr<_bp_bank:_bp> );
  291                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 144; extern void * __fastcall __macro far_set_mpr2( void );
  292                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 145; extern void * __fastcall __macro far_set_mpr34( void );
  293                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 148; // *************
  294                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 149; // Clock Functions
  295                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 150; // *************
  296                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 152; extern unsigned char __fastcall __macro clock_hh( void );
  297                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 153; extern unsigned char __fastcall __macro clock_mm( void );
  298                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 154; extern unsigned char __fastcall __macro clock_ss( void );
  299                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 155; extern unsigned char __fastcall __macro clock_tt( void );
  300                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 156; extern void __fastcall __macro clock_reset( void );
  301                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 159; // *************
  302                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 160; // Joypad Functions
  303                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 161; // *************
  304                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 163; extern unsigned int __fastcall __macro joy( unsigned char which<acc> );
  305                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 164; extern unsigned int __fastcall __macro joytrg( unsigned char which<acc> );
  306                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 167; // *************
  307                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 168; // Number Functions
  308                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 169; // *************
  309                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 171; extern int __fastcall abs( int value<acc> );
  310                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 173; extern void __fastcall __macro srand( unsigned char seed<acc> );
  311                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 174; extern unsigned int __fastcall rand( void );
  312                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 175; extern unsigned char __fastcall rand8( void );
  313                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 177; // Note: "limit" is 0..255.
  314                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 178; extern unsigned char __fastcall random8( unsigned char limit<acc> );
  315                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 180; // Note: "limit" is 0..128, 129..255 are treated as 128!
  316                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 181; extern unsigned char __fastcall random( unsigned char limit<acc> );
  317                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 184; // *************
  318                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 185; // Overlay Execution
  319                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 186; // *************
  320                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 188; extern unsigned char __fastcall __macro cd_execoverlay( unsigned char ovl_index<acc> );
  321                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 191; // *************
  322                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 192; // Functions that are only optionally available if configured in your hucc-config.inc
  323                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 193; // *************
  324                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 195; extern unsigned int __fastcall __macro joybuf( unsigned char which<acc> );
  325                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 196; extern unsigned int __fastcall __macro get_joy_events( unsigned char which<acc> );
  326                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 197; extern void __fastcall __macro clear_joy_events( unsigned char mask<acc> );
  327                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 200; // *************
  328                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 201; // Functions that are only implemented in the TGEMU emulator for unit-testing
  329                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 202; // the compiler, and which should never be used in normal HuCC projects ...
  330                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 203; // *************
  331                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 205; extern void __fastcall dump_screen( void );
  332                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 206; extern void __fastcall abort( void );
  333                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 207; extern void __fastcall exit( int value<acc> );
  334                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 209; extern unsigned char __fastcall __builtin_ffs( unsigned int value<__temp> );
  335                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 211; #endif // __HUCC__
  336                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 213; #endif // _hucc_baselib_h
  337                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 35; #include "hucc-gfx.h"
  338                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 1; #ifndef _hucc_gfx_h
  339                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 2; #define _hucc_gfx_h
  340                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 4; /****************************************************************************
  341                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 5; ; ***************************************************************************
  342                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 6; ;
  343                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 7; ; huc-gfx.h
  344                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 8; ;
  345                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 9; ; Based on the original HuC and MagicKit functions by David Michel and the
  346                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 10; ; other original HuC developers.
  347                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 11; ;
  348                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 12; ; Modifications copyright John Brandwood 2024.
  349                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 13; ;
  350                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 14; ; Distributed under the Boost Software License, Version 1.0.
  351                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 15; ; (See accompanying file LICENSE_1_0.txt or copy at
  352                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 16; ;  http://www.boost.org/LICENSE_1_0.txt)
  353                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 17; ;
  354                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 18; ; ***************************************************************************
  355                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 19; ; **************************************************************************/
  356                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 21; // *************
  357                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 22; // Screen defines ...
  358                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 23; // *************
  359                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 25; #define	SCR_SIZE_32x32	0
  360                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 26; #define	SCR_SIZE_64x32	1
  361                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 27; #define	SCR_SIZE_128x32	2
  362                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 28; #define	SCR_SIZE_32x64	4
  363                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 29; #define	SCR_SIZE_64x64	5
  364                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 30; #define	SCR_SIZE_128x64	6
  365                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 32; #define	XRES_SHARP	0
  366                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 33; #define	XRES_SOFT	4
  367                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 34; #define	XRES_KEEP	128
  368                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 36; #define VPC_WIN_A	0x00
  369                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 37; #define VPC_WIN_B	0x01
  370                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 38; #define	VPC_WIN_AB	0x02
  371                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 39; #define	VPC_WIN_NONE	0x03
  372                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 40; #define	VPC_NORM	0x00
  373                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 41; #define	VPC_SPR		0x04
  374                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 42; #define	VPC_INV_SPR	0x08
  375                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 43; #define VDC1_ON		0x01
  376                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 44; #define	VDC1_OFF	0x00
  377                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 45; #define VDC2_ON		0x02
  378                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 46; #define	VDC2_OFF	0x00
  379                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 47; #define VDC_ON		0x03
  380                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 48; #define	VDC_OFF		0x00
  381                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 50; // *************
  382                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 51; // Functions in hucc-gfx.asm ...
  383                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 52; // *************
  384                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 54; #ifdef __HUCC__
  385                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 56; #asmdef	HUCC_USES_GFX 1
  386               0001     	HUCC_USES_GFX = 1
  387                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 58; // *************
  388                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 59; // Color and Palette Functions
  389                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 60; // *************
  390                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 62; extern void __fastcall clear_palette( void );
  391                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 64; extern void __fastcall __nop set_color( unsigned int index<VCE_CTA>, unsigned int value<VCE_CTW> );
  392                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 65; extern void __fastcall set_color_rgb( unsigned int index<VCE_CTA>, unsigned char r<_al>, unsigned char g<_ah>, unsigned char b<acc> );
  393                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 66; extern unsigned int __fastcall __macro get_color( unsigned int index<VCE_CTA> );
  394                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 68; extern void __fastcall load_palette( unsigned char palette<_al>, unsigned char __far *data<_bp_bank:_bp>, unsigned char num_palettes<_ah> );
  395                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 69; extern void __fastcall far_load_palette( unsigned char palette<_al>, unsigned char num_palettes<_ah> );
  396                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 71; extern void __fastcall read_palette( unsigned char palette<_al>, unsigned char num_palettes<_ah>, unsigned int *destination<_di> );
  397                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 73; extern void __fastcall __macro fade_to_black( unsigned int __far *from<_bp_bank:_bp>, unsigned int *destination<_di>, unsigned char num_colors<_al>, unsigned char value_to_sub<_ah> );
  398                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 74; extern void __fastcall __macro fade_to_white( unsigned int __far *from<_bp_bank:_bp>, unsigned int *destination<_di>, unsigned char num_colors<_al>, unsigned char value_to_add<_ah> );
  399                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 75; extern void __fastcall __macro cross_fade_to( unsigned int __far *from<_bp_bank:_bp>, unsigned int *destination<_di>, unsigned char num_colors<_al>, unsigned char which_component<_ah> );
  400                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 77; extern void __fastcall __macro far_fade_to_black( unsigned int *destination<_di>, unsigned char num_colors<_al>, unsigned char value_to_sub<_ah> );
  401                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 78; extern void __fastcall __macro far_fade_to_white( unsigned int *destination<_di>, unsigned char num_colors<_al>, unsigned char value_to_add<_ah> );
  402                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 79; extern void __fastcall __macro far_cross_fade_to( unsigned int *destination<_di>, unsigned char num_colors<_al>, unsigned char which_component<_ah> );
  403                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 83; // *************
  404                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 84; // Video Functions
  405                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 85; // *************
  406                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 87; extern void __fastcall init_240x208( void );
  407                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 88; extern void __fastcall init_256x224( void );
  408                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 90; extern void __fastcall vsync( void );
  409                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 91; extern void __fastcall vsync( unsigned char count<_al> );
  410                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 93; extern void __fastcall disp_on( void );
  411                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 94; extern void __fastcall disp_off( void );
  412                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 96; extern void __fastcall set_screen_size( unsigned char value<_al> );
  413                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 98; extern void __fastcall set_xres( unsigned int x_pixels<_ax>, unsigned char blur_flag<_bl> );
  414                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 100; extern void __fastcall cls( void );
  415                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 101; extern void __fastcall cls( unsigned int tile<acc> );
  416                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 103; extern unsigned int __fastcall __macro vram_addr( unsigned char bat_x<_al>, unsigned char bat_y<_ah> );
  417                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 104; extern unsigned int __fastcall __macro get_vram( unsigned int address<_di> );
  418                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 105; extern void __fastcall __macro put_vram( unsigned int address<_di>, unsigned int data<acc> );
  419                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 107; extern void __fastcall __macro load_vram( unsigned int vram<_di>, unsigned char __far *data<_bp_bank:_bp>, unsigned int num_words<_ax> );
  420                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 108; extern void __fastcall __macro far_load_vram( unsigned int vram<_di>,  unsigned int num_words<_ax> );
  421                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 110; extern void __fastcall load_bat( unsigned int vram<_di>, unsigned char __far *data<_bp_bank:_bp>, unsigned char tiles_w<_al>, unsigned char tiles_h<_ah> );
  422                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 111; extern void __fastcall far_load_bat( unsigned int vram<_di>, unsigned char tiles_w<_al>, unsigned char tiles_h<_ah> );
  423                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 113; extern void __fastcall __macro load_sprites( unsigned int vram<_di>, unsigned char __far *data<_bp_bank:_bp>, unsigned int num_groups<acc> );
  424                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 114; extern void __fastcall __macro far_load_sprites( unsigned int vram<_di>, unsigned int num_groups<acc> );
  425                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 116; extern void __fastcall vram2vram( unsigned int vram_dst<_ax>, unsigned int vram_src<_bx>, unsigned int word_len<_cx> );
  426                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 119; // *************
  427                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 120; // SuperGRAFX Video Functions
  428                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 121; // *************
  429                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 123; extern void __fastcall __nop vpc_set_ctl( unsigned int bits<VPC_CR> );
  430                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 124; extern void __fastcall __nop vpc_set_win1( unsigned int width<VPC_WINDOW1> );
  431                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 125; extern void __fastcall __nop vpc_set_win2( unsigned int width<VPC_WINDOW2> );
  432                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 127; extern void __fastcall sgx_set_screen_size( unsigned char value<_al> );
  433                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 129; extern void __fastcall sgx_set_xres( unsigned int x_pixels<_ax>, unsigned char blur_flag<_bl> );
  434                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 131; extern void __fastcall sgx_cls( void );
  435                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 132; extern void __fastcall sgx_cls( unsigned int tile<acc> );
  436                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 134; extern unsigned int __fastcall __macro sgx_vram_addr( unsigned char bat_x<_al>, unsigned char bat_y<_ah> );
  437                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 135; extern unsigned int __fastcall __macro sgx_get_vram( unsigned int address<_di> );
  438                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 136; extern void __fastcall __macro sgx_put_vram( unsigned int address<_di>, unsigned int data<acc> );
  439                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 138; extern void __fastcall __macro sgx_load_vram( unsigned int vram<_di>, unsigned char __far *data<_bp_bank:_bp>, unsigned int num_words<_ax> );
  440                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 139; extern void __fastcall __macro sgx_far_load_vram( unsigned int vram<_di>, unsigned int num_words<_ax> );
  441                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 141; extern void __fastcall sgx_load_bat( unsigned int vram<_di>, unsigned char __far *data<_bp_bank:_bp>, unsigned char tiles_w<_al>, unsigned char tiles_h<_ah> );
  442                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 142; extern void __fastcall sgx_far_load_bat( unsigned int vram<_di>, unsigned char tiles_w<_al>, unsigned char tiles_h<_ah> );
  443                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 144; extern void __fastcall __macro sgx_load_sprites( unsigned int vram<_di>, unsigned char __far *data<_bp_bank:_bp>, unsigned int num_groups<acc> );
  444                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 145; extern void __fastcall __macro sgx_far_load_sprites( unsigned int vram<_di>, unsigned int num_groups<acc> );
  445                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 147; extern void __fastcall sgx_vram2vram( unsigned int vram_dst<_ax>, unsigned int vram_src<_bx>, unsigned int word_len<_cx> );
  446                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 150; // *************
  447                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 151; // Font Functions
  448                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 152; // *************
  449                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 154; extern void __fastcall set_font_addr( unsigned int vram<acc> );
  450                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 155; extern void __fastcall set_font_pal( unsigned char palette<acc> );
  451                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 157; extern void __fastcall load_font( unsigned char __far *font<_bp_bank:_bp>, unsigned char count<_al>, unsigned int vram<acc> );
  452                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 158; extern void __fastcall far_load_font( unsigned char count<_al>, unsigned int vram<acc> );
  453                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 160; extern void __fastcall __nop set_font_color( unsigned char foreground<monofont_fg>, unsigned char background<monofont_bg> );
  454                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 161; extern void __fastcall __macro load_default_font( void );
  455                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 164; // *************
  456                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 165; // SuperGRAFX Font Functions
  457                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 166; // *************
  458                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 168; extern void __fastcall sgx_set_font_addr( unsigned int vram<acc> );
  459                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 169; extern void __fastcall sgx_set_font_pal( unsigned char palette<acc> );
  460                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 171; extern void __fastcall sgx_load_font( char __far *font<_bp_bank:_bp>, unsigned char count<_al>, unsigned int vram<acc> );
  461                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 172; extern void __fastcall sgx_far_load_font( unsigned char count<_al>, unsigned int vram<acc> );
  462                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 174; extern void __fastcall __macro sgx_load_default_font( void );
  463                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 177; // *************
  464                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 178; // Deprecated functions ...
  465                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 179; // *************
  466                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 181; extern void __fastcall __macro set_xres( unsigned int x_pixels<_ax> );
  467                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 182; extern void __fastcall __macro sgx_set_xres( unsigned int x_pixels<_ax> );
  468                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 184; extern void __fastcall load_background( unsigned char __far *tiles<_bp_bank:_bp>, unsigned char __far *palettes<__fbank:__fptr>, unsigned char __far *bat<_cl:_bx>, unsigned char w<_dl>, unsigned char h<_dh> );
  469                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 186; extern void __fastcall __macro set_bgpal( unsigned char palette<_al>, unsigned char __far *data<_bp_bank:_bp> );
  470                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 187; extern void __fastcall __macro set_bgpal( unsigned char palette<_al>, unsigned char __far *data<_bp_bank:_bp>, unsigned int num_palettes<_ah> );
  471                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 188; extern void __fastcall __macro set_sprpal( unsigned char palette<_al>, unsigned char __far *data<_bp_bank:_bp> );
  472                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 189; extern void __fastcall __macro set_sprpal( unsigned char palette<_al>, unsigned char __far *data<_bp_bank:_bp>, unsigned int num_palettes<_ah> );
  473                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 191; extern void __fastcall load_font( char __far *font<_bp_bank:_bp>, unsigned char count<_al> );
  474                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 193; extern void __fastcall put_string( unsigned char *string<_bp>, unsigned char bat_x<_dil>, unsigned char bat_y<_dih> );
  475                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 195; extern void __fastcall put_char( unsigned char digit<_bl>, unsigned char bat_x<_dil>, unsigned char bat_y<_dih> );
  476                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 196; extern void __fastcall put_digit( unsigned char digit<_bl>, unsigned char bat_x<_dil>, unsigned char bat_y<_dih> );
  477                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 197; extern void __fastcall put_hex( unsigned int number<_bx>, unsigned char length<_cl>, unsigned char bat_x<_dil>, unsigned char bat_y<_dih> );
  478                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 198; extern void __fastcall put_number( unsigned int number<_bx>, unsigned char length<_cl>, unsigned char bat_x<_dil>, unsigned char bat_y<_dih> );
  479                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 199; extern void __fastcall put_raw( unsigned int data<_bx>, unsigned char bat_x<_dil>, unsigned char bat_y<_dih> );
  480                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 201; #endif // __HUCC__
  481                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 203; #endif // _hucc_gfx_h
  482                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 36; #include "hucc-string.h"
  483                        		.dbg	line,	"..\..\..\include\hucc\hucc-string.h", 1; #ifndef _hucc_string_h
  484                        		.dbg	line,	"..\..\..\include\hucc\hucc-string.h", 2; #define _hucc_string_h
  485                        		.dbg	line,	"..\..\..\include\hucc\hucc-string.h", 4; /****************************************************************************
  486                        		.dbg	line,	"..\..\..\include\hucc\hucc-string.h", 5; ; ***************************************************************************
  487                        		.dbg	line,	"..\..\..\include\hucc\hucc-string.h", 6; ;
  488                        		.dbg	line,	"..\..\..\include\hucc\hucc-string.h", 7; ; hucc-string.h
  489                        		.dbg	line,	"..\..\..\include\hucc\hucc-string.h", 8; ;
  490                        		.dbg	line,	"..\..\..\include\hucc\hucc-string.h", 9; ; Not-quite-standard, but fast, replacements for <string.h>.
  491                        		.dbg	line,	"..\..\..\include\hucc\hucc-string.h", 10; ;
  492                        		.dbg	line,	"..\..\..\include\hucc\hucc-string.h", 11; ; Copyright John Brandwood 2024.
  493                        		.dbg	line,	"..\..\..\include\hucc\hucc-string.h", 12; ;
  494                        		.dbg	line,	"..\..\..\include\hucc\hucc-string.h", 13; ; Distributed under the Boost Software License, Version 1.0.
  495                        		.dbg	line,	"..\..\..\include\hucc\hucc-string.h", 14; ; (See accompanying file LICENSE_1_0.txt or copy at
  496                        		.dbg	line,	"..\..\..\include\hucc\hucc-string.h", 15; ;  http://www.boost.org/LICENSE_1_0.txt)
  497                        		.dbg	line,	"..\..\..\include\hucc\hucc-string.h", 16; ;
  498                        		.dbg	line,	"..\..\..\include\hucc\hucc-string.h", 17; ; ***************************************************************************
  499                        		.dbg	line,	"..\..\..\include\hucc\hucc-string.h", 18; ; ***************************************************************************
  500                        		.dbg	line,	"..\..\..\include\hucc\hucc-string.h", 19; ;
  501                        		.dbg	line,	"..\..\..\include\hucc\hucc-string.h", 20; ; !!! WARNING : non-standard return values !!!
  502                        		.dbg	line,	"..\..\..\include\hucc\hucc-string.h", 21; ;
  503                        		.dbg	line,	"..\..\..\include\hucc\hucc-string.h", 22; ; Strings are limited to a maximum of 255 characters (+ the terminator)!
  504                        		.dbg	line,	"..\..\..\include\hucc\hucc-string.h", 23; ;
  505                        		.dbg	line,	"..\..\..\include\hucc\hucc-string.h", 24; ; The memcpy(), strcpy() and strcat() functions do NOT return the destination
  506                        		.dbg	line,	"..\..\..\include\hucc\hucc-string.h", 25; ; address, and they are declared "void" to check that the value is not used.
  507                        		.dbg	line,	"..\..\..\include\hucc\hucc-string.h", 26; ;
  508                        		.dbg	line,	"..\..\..\include\hucc\hucc-string.h", 27; ; mempcpy() is provided which returns the end address instead of the starting
  509                        		.dbg	line,	"..\..\..\include\hucc\hucc-string.h", 28; ; address, because this is typically more useful.
  510                        		.dbg	line,	"..\..\..\include\hucc\hucc-string.h", 29; ;
  511                        		.dbg	line,	"..\..\..\include\hucc\hucc-string.h", 30; ; Please note that both memcpy() and memset() are implemented using a TII for
  512                        		.dbg	line,	"..\..\..\include\hucc\hucc-string.h", 31; ; speed, and so the length should be < 16 bytes if used in time-critical bits
  513                        		.dbg	line,	"..\..\..\include\hucc\hucc-string.h", 32; ; of code (such as when using a split screen) because they delay interrupts.
  514                        		.dbg	line,	"..\..\..\include\hucc\hucc-string.h", 33; ;
  515                        		.dbg	line,	"..\..\..\include\hucc\hucc-string.h", 34; ; strncpy() and strncat() are not provided, because strncpy() was not created
  516                        		.dbg	line,	"..\..\..\include\hucc\hucc-string.h", 35; ; for the purpose of avoiding string overruns, and strncat() is just a poorly
  517                        		.dbg	line,	"..\..\..\include\hucc\hucc-string.h", 36; ; designed function IMHO.
  518                        		.dbg	line,	"..\..\..\include\hucc\hucc-string.h", 37; ;
  519                        		.dbg	line,	"..\..\..\include\hucc\hucc-string.h", 38; ; POSIX strlcpy() and strlcat() are provided instead, but once again they are
  520                        		.dbg	line,	"..\..\..\include\hucc\hucc-string.h", 39; ; slightly non-standard in that the return value when there is an overflow is
  521                        		.dbg	line,	"..\..\..\include\hucc\hucc-string.h", 40; ; the buffer size (so that the overflow can be detected), instead of the full
  522                        		.dbg	line,	"..\..\..\include\hucc\hucc-string.h", 41; ; size of the destination string that was too big to fit in the buffer.
  523                        		.dbg	line,	"..\..\..\include\hucc\hucc-string.h", 42; ;
  524                        		.dbg	line,	"..\..\..\include\hucc\hucc-string.h", 43; ; ***************************************************************************
  525                        		.dbg	line,	"..\..\..\include\hucc\hucc-string.h", 44; ; **************************************************************************/
  526                        		.dbg	line,	"..\..\..\include\hucc\hucc-string.h", 46; // *************
  527                        		.dbg	line,	"..\..\..\include\hucc\hucc-string.h", 47; // Functions in hucc-string.asm ...
  528                        		.dbg	line,	"..\..\..\include\hucc\hucc-string.h", 48; // *************
  529                        		.dbg	line,	"..\..\..\include\hucc\hucc-string.h", 50; #ifdef __HUCC__
  530                        		.dbg	line,	"..\..\..\include\hucc\hucc-string.h", 52; #asmdef	HUCC_USES_STRING 1
  531               0001     	HUCC_USES_STRING = 1
  532                        		.dbg	line,	"..\..\..\include\hucc\hucc-string.h", 54; extern void __fastcall strcpy( char *destination<_di>, char *source<_bp> );
  533                        		.dbg	line,	"..\..\..\include\hucc\hucc-string.h", 55; extern void __fastcall strcat( char *destination<_di>, char *source<_bp> );
  534                        		.dbg	line,	"..\..\..\include\hucc\hucc-string.h", 57; extern unsigned int __fastcall strlen( char *source<_bp> );
  535                        		.dbg	line,	"..\..\..\include\hucc\hucc-string.h", 59; extern unsigned int __fastcall strlcpy( char *destination<_di>, char *source<_bp>, unsigned char size<acc> );
  536                        		.dbg	line,	"..\..\..\include\hucc\hucc-string.h", 60; extern unsigned int __fastcall strlcat( char *destination<_di>, char *source<_bp>, unsigned char size<acc> );
  537                        		.dbg	line,	"..\..\..\include\hucc\hucc-string.h", 62; extern void __fastcall memcpy( unsigned char *destination<ram_tii_dst>, unsigned char *source<ram_tii_src>, unsigned int count<acc> );
  538                        		.dbg	line,	"..\..\..\include\hucc\hucc-string.h", 63; extern void __fastcall farmemcpy( unsigned char *destination<ram_tii_dst>, unsigned char __far *source<_bp_bank:ram_tii_src>, unsigned int count<acc> );
  539                        		.dbg	line,	"..\..\..\include\hucc\hucc-string.h", 64; extern void __fastcall far_memcpy( unsigned char *destination<ram_tii_dst>, unsigned int count<acc> );
  540                        		.dbg	line,	"..\..\..\include\hucc\hucc-string.h", 66; extern unsigned char * __fastcall mempcpy( unsigned char *destination<ram_tii_dst>, unsigned char *source<ram_tii_src>, unsigned int count<acc> );
  541                        		.dbg	line,	"..\..\..\include\hucc\hucc-string.h", 67; extern unsigned char * __fastcall farmempcpy( unsigned char *destination<ram_tii_dst>, unsigned char __far *source<_bp_bank:ram_tii_src>, unsigned int count<acc> );
  542                        		.dbg	line,	"..\..\..\include\hucc\hucc-string.h", 68; extern unsigned char * __fastcall far_mempcpy( unsigned char *destination<ram_tii_dst>, unsigned int count<acc> );
  543                        		.dbg	line,	"..\..\..\include\hucc\hucc-string.h", 70; extern void __fastcall memset( unsigned char *destination<ram_tii_src>, unsigned char value<_al>, unsigned int count<acc> );
  544                        		.dbg	line,	"..\..\..\include\hucc\hucc-string.h", 72; //  0 	if strings are equal
  545                        		.dbg	line,	"..\..\..\include\hucc\hucc-string.h", 73; //  1 	if the first non-matching character in string1 > string2 (in ASCII).
  546                        		.dbg	line,	"..\..\..\include\hucc\hucc-string.h", 74; // -1 	if the first non-matching character in string1 < string2 (in ASCII).
  547                        		.dbg	line,	"..\..\..\include\hucc\hucc-string.h", 76; extern int __fastcall strcmp( char *string1<_di>, char *string2<_bp> );
  548                        		.dbg	line,	"..\..\..\include\hucc\hucc-string.h", 77; extern int __fastcall strncmp( char *string1<_di>, char *string2<_bp>, unsigned int count<_ax> );
  549                        		.dbg	line,	"..\..\..\include\hucc\hucc-string.h", 79; extern int __fastcall __macro memcmp( unsigned char *string1<_di>, unsigned char *string2<_bp>, unsigned int count<acc> );
  550                        		.dbg	line,	"..\..\..\include\hucc\hucc-string.h", 80; extern int __fastcall farmemcmp( unsigned char *string1<_di>, unsigned char __far *string2<_bp_bank:_bp>, unsigned int count<acc> );
  551                        		.dbg	line,	"..\..\..\include\hucc\hucc-string.h", 81; extern int __fastcall far_memcmp( unsigned char *string1<_di>, unsigned int count<acc> );
  552                        		.dbg	line,	"..\..\..\include\hucc\hucc-string.h", 83; #endif // __HUCC__
  553                        		.dbg	line,	"..\..\..\include\hucc\hucc-string.h", 85; #endif // _hucc_string_h
  554                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 37; #include "hucc-old-scroll.h"
  555                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-scroll.h", 1; #ifndef _hucc_old_scroll_h
  556                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-scroll.h", 2; #define _hucc_old_scroll_h
  557                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-scroll.h", 4; /****************************************************************************
  558                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-scroll.h", 5; ; ***************************************************************************
  559                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-scroll.h", 6; ;
  560                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-scroll.h", 7; ; hucc-old-scroll.h
  561                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-scroll.h", 8; ;
  562                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-scroll.h", 9; ; Based on the original HuC and MagicKit functions by David Michel and the
  563                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-scroll.h", 10; ; other original HuC developers.
  564                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-scroll.h", 11; ;
  565                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-scroll.h", 12; ; Modifications copyright John Brandwood 2024.
  566                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-scroll.h", 13; ;
  567                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-scroll.h", 14; ; Distributed under the Boost Software License, Version 1.0.
  568                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-scroll.h", 15; ; (See accompanying file LICENSE_1_0.txt or copy at
  569                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-scroll.h", 16; ;  http://www.boost.org/LICENSE_1_0.txt)
  570                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-scroll.h", 17; ;
  571                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-scroll.h", 18; ; ***************************************************************************
  572                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-scroll.h", 19; ; ***************************************************************************
  573                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-scroll.h", 20; ;
  574                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-scroll.h", 21; ; HuC's old scrolling library is provided for use with existing HuC projects,
  575                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-scroll.h", 22; ; but it should preferably be avoided in new projects because it is slow and
  576                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-scroll.h", 23; ; forever limited by its choice to handle gaps between areas, and sorting.
  577                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-scroll.h", 24; ;
  578                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-scroll.h", 25; ; HuCC's new scrolling library puts the responibility for defining both gaps
  579                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-scroll.h", 26; ; and the display order into the project's hands, but in return it runs much
  580                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-scroll.h", 27; ; faster, using less than 1/6 of the processing time in VBLANK, and far less
  581                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-scroll.h", 28; ; time in the RCR interrputs themselves. It also supports the 2nd SuperGRAFX
  582                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-scroll.h", 29; ; screen layer, which HuC's old scrolling library ignores.
  583                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-scroll.h", 30; ;
  584                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-scroll.h", 31; ; ***************************************************************************
  585                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-scroll.h", 32; ; **************************************************************************/
  586                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-scroll.h", 34; // *************
  587                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-scroll.h", 35; // Functions in hucc-old-scroll.asm ...
  588                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-scroll.h", 36; // *************
  589                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-scroll.h", 38; #ifdef __HUCC__
  590                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-scroll.h", 40; #asmdef	HUCC_USES_OLD_SCROLL 1
  591               0001     	HUCC_USES_OLD_SCROLL = 1
  592                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-scroll.h", 42; extern void __fastcall scroll( unsigned char num<_al>, unsigned int x<_cx>, unsigned int y<_dx>, unsigned char top<_ah>, unsigned char bottom<_bl>, unsigned char disp<acc> );
  593                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-scroll.h", 43; extern void __fastcall scroll_disable( unsigned char num<acc> );
  594                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-scroll.h", 45; #endif // __HUCC__
  595                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-scroll.h", 47; #endif // _hucc_old_scroll_h
  596                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 38; #include "hucc-old-spr.h"
  597                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-spr.h", 1; #ifndef _hucc_old_spr_h
  598                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-spr.h", 2; #define _hucc_old_spr_h
  599                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-spr.h", 4; /****************************************************************************
  600                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-spr.h", 5; ; ***************************************************************************
  601                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-spr.h", 6; ;
  602                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-spr.h", 7; ; hucc-old-spr.h
  603                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-spr.h", 8; ;
  604                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-spr.h", 9; ; Based on the original HuC and MagicKit functions by David Michel and the
  605                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-spr.h", 10; ; other original HuC developers.
  606                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-spr.h", 11; ;
  607                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-spr.h", 12; ; Modifications copyright John Brandwood 2024.
  608                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-spr.h", 13; ;
  609                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-spr.h", 14; ; Distributed under the Boost Software License, Version 1.0.
  610                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-spr.h", 15; ; (See accompanying file LICENSE_1_0.txt or copy at
  611                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-spr.h", 16; ;  http://www.boost.org/LICENSE_1_0.txt)
  612                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-spr.h", 17; ;
  613                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-spr.h", 18; ; ***************************************************************************
  614                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-spr.h", 19; ; **************************************************************************/
  615                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-spr.h", 21; // *************
  616                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-spr.h", 22; // Sprite defines ...
  617                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-spr.h", 23; // *************
  618                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-spr.h", 25; #define FLIP_X_MASK 0x08
  619                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-spr.h", 26; #define FLIP_Y_MASK 0x80
  620                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-spr.h", 27; #define FLIP_MAS    0x88
  621                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-spr.h", 28; #define SIZE_MAS    0x31
  622                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-spr.h", 30; #define NO_FLIP     0x00
  623                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-spr.h", 31; #define NO_FLIP_X   0x00
  624                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-spr.h", 32; #define NO_FLIP_Y   0x00
  625                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-spr.h", 33; #define FLIP_X      0x08
  626                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-spr.h", 34; #define FLIP_Y      0x80
  627                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-spr.h", 35; #define SZ_16x16    0x00
  628                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-spr.h", 36; #define SZ_16x32    0x10
  629                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-spr.h", 37; #define SZ_16x64    0x30
  630                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-spr.h", 38; #define SZ_32x16    0x01
  631                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-spr.h", 39; #define SZ_32x32    0x11
  632                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-spr.h", 40; #define	SZ_32x64    0x31
  633                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-spr.h", 42; // *************
  634                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-spr.h", 43; // Functions in hucc-old-spr.asm ...
  635                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-spr.h", 44; // *************
  636                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-spr.h", 46; #ifdef __HUCC__
  637                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-spr.h", 48; #asmdef	HUCC_USES_OLD_SPR 1
  638               0001     	HUCC_USES_OLD_SPR = 1
  639                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-spr.h", 50; extern void __fastcall init_satb( void );
  640                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-spr.h", 51; extern void __fastcall reset_satb( void );
  641                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-spr.h", 52; extern void __fastcall satb_update( void );
  642                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-spr.h", 53; extern void __fastcall spr_set( unsigned char num<acc> );
  643                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-spr.h", 54; extern void __fastcall spr_hide( void );
  644                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-spr.h", 55; extern void __fastcall spr_show( void );
  645                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-spr.h", 56; extern void __fastcall spr_x( unsigned int value<acc> );
  646                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-spr.h", 57; extern void __fastcall spr_y( unsigned int value<acc> );
  647                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-spr.h", 58; extern void __fastcall spr_pattern( unsigned int vaddr<acc> );
  648                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-spr.h", 59; extern void __fastcall spr_ctrl( unsigned char mask<_al>, unsigned char value<acc> );
  649                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-spr.h", 60; extern void __fastcall spr_pal( unsigned char palette<acc> );
  650                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-spr.h", 61; extern void __fastcall spr_pri( unsigned char priority<acc> );
  651                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-spr.h", 63; extern unsigned int __fastcall spr_get_x( void );
  652                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-spr.h", 64; extern unsigned int __fastcall spr_get_y( void );
  653                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-spr.h", 66; extern void __fastcall sgx_init_satb( void );
  654                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-spr.h", 67; extern void __fastcall sgx_reset_satb( void );
  655                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-spr.h", 68; extern void __fastcall sgx_satb_update( void );
  656                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-spr.h", 69; extern void __fastcall sgx_spr_set( unsigned char num<acc> );
  657                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-spr.h", 70; extern void __fastcall sgx_spr_hide( void );
  658                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-spr.h", 71; extern void __fastcall sgx_spr_show( void );
  659                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-spr.h", 72; extern void __fastcall sgx_spr_x( unsigned int value<acc> );
  660                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-spr.h", 73; extern void __fastcall sgx_spr_y( unsigned int value<acc> );
  661                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-spr.h", 74; extern void __fastcall sgx_spr_pattern( unsigned int vaddr<acc> );
  662                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-spr.h", 75; extern void __fastcall sgx_spr_ctrl( unsigned char mask<_al>, unsigned char value<acc> );
  663                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-spr.h", 76; extern void __fastcall sgx_spr_pal( unsigned char palette<acc> );
  664                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-spr.h", 77; extern void __fastcall sgx_spr_pri( unsigned char priority<acc> );
  665                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-spr.h", 79; extern unsigned int __fastcall sgx_spr_get_x( void );
  666                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-spr.h", 80; extern unsigned int __fastcall sgx_spr_get_y( void );
  667                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-spr.h", 82; #endif // __HUCC__
  668                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-spr.h", 84; #endif // _hucc_old_spr_h
  669                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 39; #include "hucc-old-map.h"
  670                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-map.h", 1; #ifndef _hucc_old_map_h
  671                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-map.h", 2; #define _hucc_old_map_h
  672                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-map.h", 4; /****************************************************************************
  673                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-map.h", 5; ; ***************************************************************************
  674                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-map.h", 6; ;
  675                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-map.h", 7; ; hucc-old-map.h
  676                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-map.h", 8; ;
  677                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-map.h", 9; ; Based on the original HuC and MagicKit functions by David Michel and the
  678                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-map.h", 10; ; other original HuC developers.
  679                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-map.h", 11; ;
  680                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-map.h", 12; ; Modifications copyright John Brandwood 2024.
  681                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-map.h", 13; ;
  682                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-map.h", 14; ; Distributed under the Boost Software License, Version 1.0.
  683                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-map.h", 15; ; (See accompanying file LICENSE_1_0.txt or copy at
  684                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-map.h", 16; ;  http://www.boost.org/LICENSE_1_0.txt)
  685                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-map.h", 17; ;
  686                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-map.h", 18; ; ***************************************************************************
  687                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-map.h", 19; ; **************************************************************************/
  688                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-map.h", 21; // *************
  689                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-map.h", 22; // Functions in hucc-old-map.asm ...
  690                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-map.h", 23; // *************
  691                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-map.h", 25; #ifdef __HUCC__
  692                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-map.h", 27; #asmdef	HUCC_USES_OLD_MAP 1
  693               0001     	HUCC_USES_OLD_MAP = 1
  694                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-map.h", 29; extern void __fastcall set_tile_address( unsigned int vram<_di> );
  695                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-map.h", 30; extern void __fastcall sgx_set_tile_address( unsigned int vram<_di> );
  696                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-map.h", 32; extern void __fastcall __nop set_tile_data( unsigned char __far *tiles<vdc_tile_bank:vdc_tile_addr>, unsigned char num_tiles<vdc_num_tiles>, unsigned char __far *palette_table<vdc_attr_bank:vdc_attr_addr>, unsigned char tile_type<vdc_tile_type> );
  697                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-map.h", 33; extern void __fastcall __nop sgx_set_tile_data( unsigned char __far *tiles<sgx_tile_bank:sgx_tile_addr>, unsigned char num_tiles<sgx_num_tiles>, unsigned char __far *palette_table<sgx_attr_bank:sgx_attr_addr>, unsigned char tile_type<sgx_tile_type> );
  698                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-map.h", 35; extern void __fastcall __nop set_far_tile_data( unsigned char tile_bank<vdc_tile_bank>, unsigned char *tile_addr<vdc_tile_addr>, unsigned char num_tiles<vdc_num_tiles>, unsigned char palette_table_bank<vdc_attr_bank>, unsigned char *palette_table_addr<vdc_attr_addr>, unsigned char tile_type<vdc_tile_type> );
  699                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-map.h", 36; extern void __fastcall __nop sgx_set_far_tile_data( unsigned char tile_bank<sgx_tile_bank>, unsigned char *tile_addr<sgx_tile_addr>, unsigned char num_tiles<sgx_num_tiles>, unsigned char palette_table_bank<sgx_attr_bank>, unsigned char *palette_table_addr<sgx_attr_addr>, unsigned char tile_type<sgx_tile_type> );
  700                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-map.h", 38; extern void __fastcall __nop set_map_data( unsigned char __far *map<vdc_map_bank:vdc_map_addr>, unsigned char w<vdc_map_width>, unsigned char h<vdc_map_height> );
  701                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-map.h", 39; extern void __fastcall __nop sgx_set_map_data( unsigned char __far *map<sgx_map_bank:sgx_map_addr>, unsigned char w<sgx_map_width>, unsigned char h<sgx_map_height> );
  702                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-map.h", 41; extern void __fastcall __nop set_far_map_data( unsigned char map_bank<vdc_map_bank>, unsigned char *map_addr<vdc_map_addr>, unsigned char w<vdc_map_width>, unsigned char h<vdc_map_height> );
  703                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-map.h", 42; extern void __fastcall __nop sgx_set_far_map_data( unsigned char map_bank<vdc_map_bank>, unsigned char *map_addr<vdc_map_addr>, unsigned char w<sgx_map_width>, unsigned char h<sgx_map_height> );
  704                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-map.h", 44; extern void __fastcall load_tile( unsigned int vram<_di> );
  705                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-map.h", 45; extern void __fastcall sgx_load_tile( unsigned int vram<_di> );
  706                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-map.h", 47; extern void __fastcall load_map( unsigned char bat_x<_al>, unsigned char bat_y<_ah>, int map_x<_bx>, int map_y<_dx>, unsigned char tiles_w<_cl>, unsigned char tiles_h<_ch> );
  707                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-map.h", 48; extern void __fastcall sgx_load_map( unsigned char bat_x<_al>, unsigned char bat_y<_ah>, int map_x<_bx>, int map_y<_dx>, unsigned char tiles_w<_cl>, unsigned char tiles_h<_ch> );
  708                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-map.h", 50; extern unsigned char __fastcall map_get_tile( unsigned char map_x<_bl>, unsigned char map_y<_bh> );
  709                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-map.h", 51; extern unsigned char __fastcall sgx_map_get_tile( unsigned char map_x<_bl>, unsigned char map_y<_bh> );
  710                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-map.h", 53; extern void __fastcall map_put_tile( unsigned char map_x<_bl>, unsigned char map_y<_bh>, unsigned char tile<_al> );
  711                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-map.h", 54; extern void __fastcall sgx_map_put_tile( unsigned char map_x<_bl>, unsigned char map_y<_bh>, unsigned char tile<_al> );
  712                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-map.h", 56; extern void __fastcall put_tile( unsigned char tile<_bl>, unsigned char bat_x<_al>, unsigned char bat_y<_ah> );
  713                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-map.h", 57; extern void __fastcall sgx_put_tile( unsigned char tile<_bl>, unsigned char bat_x<_al>, unsigned char bat_y<_ah> );
  714                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-map.h", 59; // Deprecated functions ...
  715                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-map.h", 61; extern void __fastcall set_tile_data( unsigned char *tile_ex<_di> );
  716                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-map.h", 63; extern void __fastcall __nop set_map_pals( unsigned char __far *palette_table<vdc_attr_bank:vdc_attr_addr> );
  717                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-map.h", 64; extern void __fastcall __nop set_map_tile_type( unsigned char tile_type<vdc_tile_type> );
  718                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-map.h", 66; extern void __fastcall __nop sgx_set_map_pals( unsigned char __far *palette_table<sgx_attr_bank:sgx_attr_addr> );
  719                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-map.h", 67; extern void __fastcall __nop sgx_set_map_tile_type( unsigned char tile_type<sgx_tile_type> );
  720                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-map.h", 69; extern void __fastcall set_map_tile_base( unsigned int vram<_di> );
  721                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-map.h", 70; extern void __fastcall sgx_set_map_tile_base( unsigned int vram<_di> );
  722                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-map.h", 72; #endif // __HUCC__
  723                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-map.h", 74; #endif // _hucc_old_map_h
  724                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 40; #include "hucc-old-line.h"
  725                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-line.h", 1; #ifndef _hucc_old_line_h
  726                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-line.h", 2; #define _hucc_old_line_h
  727                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-line.h", 4; /****************************************************************************
  728                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-line.h", 5; ; ***************************************************************************
  729                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-line.h", 6; ;
  730                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-line.h", 7; ; hucc-old-line.h
  731                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-line.h", 8; ;
  732                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-line.h", 9; ; Based on the original HuC and MagicKit functions by David Michel and the
  733                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-line.h", 10; ; other original HuC developers.
  734                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-line.h", 11; ;
  735                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-line.h", 12; ; Modifications copyright John Brandwood 2024.
  736                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-line.h", 13; ;
  737                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-line.h", 14; ; Distributed under the Boost Software License, Version 1.0.
  738                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-line.h", 15; ; (See accompanying file LICENSE_1_0.txt or copy at
  739                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-line.h", 16; ;  http://www.boost.org/LICENSE_1_0.txt)
  740                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-line.h", 17; ;
  741                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-line.h", 18; ; ***************************************************************************
  742                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-line.h", 19; ; **************************************************************************/
  743                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-line.h", 21; // *************
  744                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-line.h", 22; // Functions in hucc-old-line.asm ...
  745                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-line.h", 23; // *************
  746                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-line.h", 25; #ifdef __HUCC__
  747                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-line.h", 27; #asmdef	HUCC_USES_OLD_LINE 1
  748               0001     	HUCC_USES_OLD_LINE = 1
  749                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-line.h", 29; extern void __fastcall gfx_init( unsigned int start_vram_addr<_ax> );
  750                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-line.h", 30; extern void __fastcall gfx_clear( unsigned int start_vram_addr<_di> );
  751                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-line.h", 31; extern void __fastcall gfx_plot( unsigned int x<_gfx_x1>, unsigned int y<_gfx_y1>, char color<_gfx_color> );
  752                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-line.h", 32; extern void __fastcall gfx_line( unsigned int x1<_gfx_x1>, unsigned int y1<_gfx_y1>, unsigned int x2<_gfx_x2>, unsigned int y2<_gfx_y2>, unsigned char color<_gfx_color> );
  753                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-line.h", 34; #endif // __HUCC__
  754                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-line.h", 36; #endif // _hucc_old_line_h
  755                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 42; #endif // _hucc_legacy_h
  756                        		.dbg	line,	"main.c", 1; #include "huc.h"
  757                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 1; #ifndef _hucc_legacy_h
  758                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 2; #define _hucc_legacy_h
  759                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 4; /****************************************************************************
  760                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 5; ; ***************************************************************************
  761                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 6; ;
  762                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 7; ; huc.h
  763                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 8; ;
  764                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 9; ; HuCC wrapper file to include a default set of HuC-compatible functions.
  765                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 10; ;
  766                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 11; ; Copyright John Brandwood 2024.
  767                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 12; ;
  768                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 13; ; Distributed under the Boost Software License, Version 1.0.
  769                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 14; ; (See accompanying file LICENSE_1_0.txt or copy at
  770                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 15; ;  http://www.boost.org/LICENSE_1_0.txt)
  771                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 16; ;
  772                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 17; ; ***************************************************************************
  773                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 18; ; ***************************************************************************
  774                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 19; ;
  775                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 20; ; When the HuCC compiler is invoked with the "--legacy" option to compile old
  776                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 21; ; projects, then this "huc.h" file is automatically included.
  777                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 22; ;
  778                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 23; ; This file includes a set of the individual HuCC headers which correspond to
  779                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 24; ; HuC's built-in functions and MagicKit library.
  780                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 25; ;
  781                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 26; ; New HuCC projects should, preferably, include the specific headers that are
  782                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 27; ; needed, which will then allow them to replace parts of the standard library
  783                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 28; ; with newer functions, or they can just manually include this "huc.h" file.
  784                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 29; ;
  785                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 30; ; ***************************************************************************
  786                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 31; ; **************************************************************************/
  787                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 33; #include "hucc-systemcard.h"
  788                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 34; #include "hucc-baselib.h"
  789                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 35; #include "hucc-gfx.h"
  790                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 36; #include "hucc-string.h"
  791                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 37; #include "hucc-old-scroll.h"
  792                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 38; #include "hucc-old-spr.h"
  793                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 39; #include "hucc-old-map.h"
  794                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 40; #include "hucc-old-line.h"
  795                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 42; #endif // _hucc_legacy_h
  796                        		.dbg	line,	"main.c", 2; #include "hucc-scroll.h"
  797                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 1; #ifndef _hucc_scroll_h
  798                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 2; #define _hucc_scroll_h
  799                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 4; /****************************************************************************
  800                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 5; ; ***************************************************************************
  801                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 6; ;
  802                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 7; ; hucc-scroll.h
  803                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 8; ;
  804                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 9; ; Routines for a fast split-screen scrolling system.
  805                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 10; ;
  806                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 11; ; Copyright John Brandwood 2024.
  807                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 12; ;
  808                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 13; ; Distributed under the Boost Software License, Version 1.0.
  809                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 14; ; (See accompanying file LICENSE_1_0.txt or copy at
  810                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 15; ;  http://www.boost.org/LICENSE_1_0.txt)
  811                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 16; ;
  812                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 17; ; ***************************************************************************
  813                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 18; ; ***************************************************************************
  814                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 19; ;
  815                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 20; ; The maximum number of splits for each screen layer is set in your project's
  816                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 21; ; "hucc-config.inc" file, with the library having a limit of 128-per-layer.
  817                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 22; ;
  818                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 23; ; Your first active split must be defined to start at screen line 0, and then
  819                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 24; ; the rest of the active splits must be in increasing line order to match the
  820                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 25; ; way that the PC Engine displays the output image.
  821                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 26; ;
  822                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 27; ; You can have disabled splits interleaved with your active splits.
  823                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 28; ;
  824                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 29; ; Splits that are normally disabled can be used to create full screen effects
  825                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 30; ; such as bouncing the screen up and down by adding blank areas at the top or
  826                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 31; ; bottom of the screen, and then rapidly changing the height of those areas.
  827                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 32; ;
  828                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 33; ; ***************************************************************************
  829                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 34; ; **************************************************************************/
  830                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 36; // *************
  831                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 37; // VDC bits for display_flags ...
  832                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 38; // *************
  833                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 40; #ifndef BKG_OFF
  834                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 41; #define BKG_OFF 0x00
  835                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 42; #endif
  836                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 44; #ifndef SPR_OFF
  837                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 45; #define SPR_OFF 0x00
  838                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 46; #endif
  839                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 48; #ifndef BKG_ON
  840                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 49; #define BKG_ON 0x80
  841                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 50; #endif
  842                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 52; #ifndef SPR_ON
  843                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 53; #define SPR_ON 0x40
  844                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 54; #endif
  845                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 56; // *************
  846                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 57; // Functions in hucc-scroll.asm ...
  847                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 58; // *************
  848                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 60; #ifdef __HUCC__
  849                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 62; #asmdef	HUCC_USES_NEW_SCROLL 1
  850               0001     	HUCC_USES_NEW_SCROLL = 1
  851                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 64; extern void __fastcall scroll_split( unsigned char index<_al>, unsigned char screen_line<_ah>, unsigned int bat_x<_bx>, unsigned int bat_y<_cx>, unsigned char display_flags<_dl> );
  852                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 65; extern void __fastcall sgx_scroll_split( unsigned char index<_al>, unsigned char screen_line<_ah>, unsigned int bat_x<_bx>, unsigned int bat_y<_cx>, unsigned char display_flags<_dl> );
  853                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 67; extern void __fastcall disable_split( unsigned char index<acc> );
  854                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 68; extern void __fastcall sgx_disable_split( unsigned char index<acc> );
  855                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 70; extern void __fastcall __macro disable_all_splits( void );
  856                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 71; extern void __fastcall __macro sgx_disable_all_splits( void );
  857                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 73; #asm
  858                        		.dbg	clear
  859                        			.macro	_disable_all_splits
  860                        			ldy	#HUCC_PCE_SPLITS - 1
  861                        	!loop:		tya
  862                        			call	_disable_split.1
  863                        			dey
  864                        			bpl	!loop-
  865                        			.endm
  866                        			.macro	_sgx_disable_all_splits
  867                        			ldy	#HUCC_SGX_SPLITS - 1
  868                        	!loop:		tya
  869                        			call	_sgx_disable_split.1
  870                        			dey
  871                        			bpl	!loop-
  872                        			.endm
  873                        	
  874                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 89; #endasm
  875                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 91; #endif // __HUCC__
  876                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 93; #endif // _hucc_scroll_h
  877                        		.dbg	line,	"main.c", 3; #include "hucc-chrmap.h"
  878                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 1; #ifndef _hucc_chrmap_h
  879                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 2; #define _hucc_chrmap_h
  880                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 4; /****************************************************************************
  881                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 5; ; ***************************************************************************
  882                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 6; ;
  883                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 7; ; hucc-chrmap.h
  884                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 8; ;
  885                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 9; ; A simple map system based on 8x8 characters (aka "tiles") in BAT format.
  886                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 10; ;
  887                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 11; ; Copyright John Brandwood 2025.
  888                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 12; ;
  889                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 13; ; Distributed under the Boost Software License, Version 1.0.
  890                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 14; ; (See accompanying file LICENSE_1_0.txt or copy at
  891                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 15; ;  http://www.boost.org/LICENSE_1_0.txt)
  892                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 16; ;
  893                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 17; ; ***************************************************************************
  894                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 18; ; ***************************************************************************
  895                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 19; ;
  896                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 20; ; The maximum X and Y size for chrmaps is 256 characters (2048 pixels).
  897                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 21; ;
  898                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 22; ; The maximum total size for a chrmap is 16KBytes, which allows for maps up
  899                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 23; ; to 256x32 tiles (2048x256 pixels).
  900                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 24; ;
  901                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 25; ; ***************************************************************************
  902                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 26; ; **************************************************************************/
  903                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 28; // *************
  904                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 29; // This code extends the blkmap library ...
  905                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 30; // *************
  906                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 32; #include "hucc-blkmap.h"
  907                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 1; #ifndef _hucc_blkmap_h
  908                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 2; #define _hucc_blkmap_h
  909                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 4; /****************************************************************************
  910                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 5; ; ***************************************************************************
  911                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 6; ;
  912                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 7; ; hucc-blkmap.h
  913                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 8; ;
  914                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 9; ; A map system based on 16x16 meta-tiles (aka "blocks", aka CHR/BLK/MAP).
  915                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 10; ;
  916                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 11; ; Copyright John Brandwood 2025.
  917                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 12; ;
  918                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 13; ; Distributed under the Boost Software License, Version 1.0.
  919                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 14; ; (See accompanying file LICENSE_1_0.txt or copy at
  920                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 15; ;  http://www.boost.org/LICENSE_1_0.txt)
  921                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 16; ;
  922                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 17; ; ***************************************************************************
  923                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 18; ; ***************************************************************************
  924                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 19; ;
  925                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 20; ; The maximum X and Y size for blkmaps is 128 blocks (2048 pixels).
  926                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 21; ;
  927                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 22; ; The maximum total size for a blkmap is 16KBytes, which allows for maps up
  928                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 23; ; to 128x128 blocks (2048x2048 pixels).
  929                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 24; ;
  930                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 25; ; Huge multi-screen blkmaps are also supported (optionally).
  931                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 26; ;
  932                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 27; ; The maximum X and Y for multi-screen maps is 128 screens (32768 pixels).
  933                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 28; ;
  934                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 29; ; The maximum total size for a multi-screen map is 8KBytes, which allows for
  935                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 30; ; a total of 1024 screens.
  936                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 31; ;
  937                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 32; ; ***************************************************************************
  938                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 33; ; **************************************************************************/
  939                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 35; // *************
  940                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 36; // Functions in blkmap.asm ...
  941                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 37; // *************
  942                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 39; #ifdef __HUCC__
  943                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 41; #asmdef	HUCC_USES_BLKMAP 1
  944               0001     	HUCC_USES_BLKMAP = 1
  945                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 43; // Current top-left of drawn map in pixels.
  946                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 44; extern unsigned int   vdc_map_pxl_x;
  947                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 45; extern unsigned int   vdc_map_pxl_y;
  948                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 47; // Width and height to draw/scroll in characters (not tiles).
  949                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 48; extern unsigned char  vdc_map_draw_w;
  950                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 49; extern unsigned char  vdc_map_draw_h;
  951                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 51; // Width of map (or multi-screen BAT) in tiles.
  952                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 52; extern unsigned char  vdc_map_line_w;
  953                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 54; // Width of map in screens (if multi-screen map).
  954                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 55; extern unsigned char  vdc_map_scrn_w;
  955                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 57; // Extra information returned by get_map_block() and sgx_get_map_block(),
  956                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 58; // which are the collision flags and the mask/overlay sprite for the BLK.
  957                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 59; extern unsigned char  map_blk_flag;
  958                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 60; extern unsigned char  map_blk_mask;
  959                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 62; extern unsigned char  vdc_scr_bank;
  960                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 63; extern unsigned char *vdc_scr_addr;
  961                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 65; extern unsigned char  vdc_map_bank;
  962                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 66; extern unsigned char *vdc_map_addr;
  963                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 68; extern unsigned char  vdc_blk_bank;
  964                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 69; extern unsigned char *vdc_blk_addr;
  965                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 71; extern unsigned char  vdc_tbl_bank;
  966                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 72; extern unsigned char *vdc_tbl_addr;
  967                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 74; extern void __fastcall set_blocks( unsigned char __far *blk_def<vdc_blk_bank:vdc_blk_addr>, unsigned char __far *flg_def<vdc_tbl_bank:vdc_tbl_addr>, unsigned char number_of_blocks<_al> );
  968                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 75; extern void __fastcall __macro set_blkmap( unsigned char __far *blk_map<vdc_map_bank:vdc_map_addr>, unsigned char blocks_w<vdc_map_line_w> );
  969                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 76; extern void __fastcall __macro set_multimap( unsigned char __far *multi_map<vdc_scr_bank:vdc_scr_addr>, unsigned char screens_w<vdc_map_scrn_w> );
  970                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 78; extern void __fastcall draw_map( void );
  971                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 79; extern void __fastcall scroll_map( void );
  972                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 81; extern void __fastcall blit_map( unsigned char tile_x<map_bat_x>, unsigned char tile_y<map_bat_y>, unsigned char tile_w<map_draw_x>, unsigned char tile_h<map_draw_y> );
  973                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 83; extern unsigned char __fastcall get_map_block( unsigned int x<map_pxl_x>, unsigned int y<map_pxl_y> );
  974                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 85; #asm
  975                        		.dbg	clear
  976                        			.macro	_set_blkmap.2
  977                        			stz	vdc_scr_bank
  978                        			.endm
  979                        			.macro	_set_multimap.2
  980                        			lda	vdc_bat_width
  981                        			lsr	a
  982                        			sta	vdc_map_line_w
  983                        			.endm
  984                        			.macro	SCREEN
  985                        			db	(((\1) & $1FFF) | $6000) >> 8, bank(\1)
  986                        			db	(((\2) & $1FFF) | $4000) >> 8, bank(\2)
  987                        			db	(((\3) & $1FFF) | $6000) >> 8, bank(\3)
  988                        			dw	(\4)
  989                        			.endm
  990                        	
  991                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 102; #endasm
  992                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 104; #ifdef _SGX
  993                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 106; // Current top-left of drawn map in pixels.
  994                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 107; extern unsigned int   sgx_map_pxl_x;
  995                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 108; extern unsigned int   sgx_map_pxl_y;
  996                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 110; // Width and height to draw/scroll in characters (not tiles).
  997                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 111; extern unsigned char  sgx_map_draw_w;
  998                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 112; extern unsigned char  sgx_map_draw_h;
  999                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 114; // Width of map (or multi-screen BAT) in tiles.
 1000                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 115; extern unsigned char  sgx_map_line_w;
 1001                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 117; // Width of map in screens (if multi-screen map).
 1002                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 118; extern unsigned char  sgx_map_scrn_w;
 1003                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 120; extern unsigned char  sgx_scr_bank;
 1004                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 121; extern unsigned char *sgx_scr_addr;
 1005                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 123; extern unsigned char  sgx_map_bank;
 1006                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 124; extern unsigned char *sgx_map_addr;
 1007                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 126; extern unsigned char  sgx_blk_bank;
 1008                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 127; extern unsigned char *sgx_blk_addr;
 1009                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 129; extern unsigned char  sgx_tbl_bank;
 1010                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 130; extern unsigned char *sgx_tbl_addr;
 1011                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 132; extern void __fastcall sgx_set_blocks( unsigned char __far *blk_def<sgx_blk_bank:sgx_blk_addr>, unsigned char __far *flg_def<sgx_tbl_bank:sgx_tbl_addr>, unsigned char number_of_blocks<_al> );
 1012                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 133; extern void __fastcall __macro sgx_set_blkmap( unsigned char __far *blk_map<sgx_map_bank:sgx_map_addr>, unsigned char blocks_w<sgx_map_line_w> );
 1013                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 134; extern void __fastcall __macro sgx_set_multimap( unsigned char __far *multi_map<sgx_scr_bank:sgx_scr_addr>, unsigned char screens_w<sgx_map_scrn_w> );
 1014                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 136; extern void __fastcall sgx_draw_map( void );
 1015                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 137; extern void __fastcall sgx_scroll_map( void );
 1016                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 139; extern void __fastcall sgx_blit_map( unsigned char tile_x<map_bat_x>, unsigned char tile_y<map_bat_y>, unsigned char tile_w<map_draw_x>, unsigned char tile_h<map_draw_y> );
 1017                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 141; extern unsigned char __fastcall sgx_get_map_block( unsigned int x<map_pxl_x>, unsigned int y<map_pxl_y> );
 1018                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 143; #asm
 1019                        		.dbg	clear
 1020                        			.macro	_sgx_set_blkmap.2
 1021                        			stz	sgx_scr_bank
 1022                        			.endm
 1023                        			.macro	_sgx_set_multimap.2
 1024                        			lda	sgx_bat_width
 1025                        			lsr	a
 1026                        			sta	sgx_map_line_w
 1027                        			.endm
 1028                        	
 1029                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 153; #endasm
 1030                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 155; #endif
 1031                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 157; #endif // __HUCC__
 1032                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 159; #endif // _hucc_blkmap_h
 1033                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 34; // *************
 1034                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 35; // Functions in chrmap.asm ...
 1035                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 36; // *************
 1036                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 38; #ifdef __HUCC__
 1037                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 40; #asmdef	HUCC_USES_CHRMAP 1
 1038               0001     	HUCC_USES_CHRMAP = 1
 1039                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 42; extern void __fastcall __nop set_chrmap( unsigned char __far *chrmap<vdc_map_bank:vdc_map_addr>, unsigned char tiles_w<vdc_map_line_w> );
 1040                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 44; extern void __fastcall draw_bat( void );
 1041                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 45; extern void __fastcall scroll_bat( void );
 1042                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 47; extern void __fastcall blit_bat( unsigned char tile_x<map_bat_x>, unsigned char tile_y<map_bat_y>, unsigned char tile_w<map_draw_x>, unsigned char tile_h<map_draw_y> );
 1043                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 49; #ifdef _SGX
 1044                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 51; extern void __fastcall __nop sgx_set_chrmap( unsigned char __far *chrmap<sgx_map_bank:sgx_map_addr>, unsigned char tiles_w<sgx_map_line_w> );
 1045                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 53; extern void __fastcall sgx_draw_bat( void );
 1046                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 54; extern void __fastcall sgx_scroll_bat( void );
 1047                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 56; extern void __fastcall sgx_blit_bat( unsigned char tile_x<map_bat_x>, unsigned char tile_y<map_bat_y>, unsigned char tile_w<map_draw_x>, unsigned char tile_h<map_draw_y> );
 1048                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 58; #endif
 1049                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 60; #endif // __HUCC__
 1050                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 62; #endif // _hucc_chrmap_h
 1051                        		.dbg	line,	"main.c", 4; #include "hucc-blkmap.h"
 1052                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 1; #ifndef _hucc_blkmap_h
 1053                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 2; #define _hucc_blkmap_h
 1054                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 4; /****************************************************************************
 1055                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 5; ; ***************************************************************************
 1056                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 6; ;
 1057                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 7; ; hucc-blkmap.h
 1058                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 8; ;
 1059                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 9; ; A map system based on 16x16 meta-tiles (aka "blocks", aka CHR/BLK/MAP).
 1060                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 10; ;
 1061                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 11; ; Copyright John Brandwood 2025.
 1062                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 12; ;
 1063                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 13; ; Distributed under the Boost Software License, Version 1.0.
 1064                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 14; ; (See accompanying file LICENSE_1_0.txt or copy at
 1065                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 15; ;  http://www.boost.org/LICENSE_1_0.txt)
 1066                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 16; ;
 1067                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 17; ; ***************************************************************************
 1068                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 18; ; ***************************************************************************
 1069                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 19; ;
 1070                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 20; ; The maximum X and Y size for blkmaps is 128 blocks (2048 pixels).
 1071                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 21; ;
 1072                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 22; ; The maximum total size for a blkmap is 16KBytes, which allows for maps up
 1073                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 23; ; to 128x128 blocks (2048x2048 pixels).
 1074                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 24; ;
 1075                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 25; ; Huge multi-screen blkmaps are also supported (optionally).
 1076                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 26; ;
 1077                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 27; ; The maximum X and Y for multi-screen maps is 128 screens (32768 pixels).
 1078                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 28; ;
 1079                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 29; ; The maximum total size for a multi-screen map is 8KBytes, which allows for
 1080                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 30; ; a total of 1024 screens.
 1081                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 31; ;
 1082                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 32; ; ***************************************************************************
 1083                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 33; ; **************************************************************************/
 1084                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 35; // *************
 1085                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 36; // Functions in blkmap.asm ...
 1086                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 37; // *************
 1087                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 39; #ifdef __HUCC__
 1088                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 41; #asmdef	HUCC_USES_BLKMAP 1
 1089                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 43; // Current top-left of drawn map in pixels.
 1090                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 44; extern unsigned int   vdc_map_pxl_x;
 1091                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 45; extern unsigned int   vdc_map_pxl_y;
 1092                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 47; // Width and height to draw/scroll in characters (not tiles).
 1093                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 48; extern unsigned char  vdc_map_draw_w;
 1094                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 49; extern unsigned char  vdc_map_draw_h;
 1095                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 51; // Width of map (or multi-screen BAT) in tiles.
 1096                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 52; extern unsigned char  vdc_map_line_w;
 1097                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 54; // Width of map in screens (if multi-screen map).
 1098                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 55; extern unsigned char  vdc_map_scrn_w;
 1099                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 57; // Extra information returned by get_map_block() and sgx_get_map_block(),
 1100                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 58; // which are the collision flags and the mask/overlay sprite for the BLK.
 1101                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 59; extern unsigned char  map_blk_flag;
 1102                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 60; extern unsigned char  map_blk_mask;
 1103                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 62; extern unsigned char  vdc_scr_bank;
 1104                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 63; extern unsigned char *vdc_scr_addr;
 1105                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 65; extern unsigned char  vdc_map_bank;
 1106                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 66; extern unsigned char *vdc_map_addr;
 1107                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 68; extern unsigned char  vdc_blk_bank;
 1108                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 69; extern unsigned char *vdc_blk_addr;
 1109                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 71; extern unsigned char  vdc_tbl_bank;
 1110                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 72; extern unsigned char *vdc_tbl_addr;
 1111                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 74; extern void __fastcall set_blocks( unsigned char __far *blk_def<vdc_blk_bank:vdc_blk_addr>, unsigned char __far *flg_def<vdc_tbl_bank:vdc_tbl_addr>, unsigned char number_of_blocks<_al> );
 1112                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 75; extern void __fastcall __macro set_blkmap( unsigned char __far *blk_map<vdc_map_bank:vdc_map_addr>, unsigned char blocks_w<vdc_map_line_w> );
 1113                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 76; extern void __fastcall __macro set_multimap( unsigned char __far *multi_map<vdc_scr_bank:vdc_scr_addr>, unsigned char screens_w<vdc_map_scrn_w> );
 1114                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 78; extern void __fastcall draw_map( void );
 1115                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 79; extern void __fastcall scroll_map( void );
 1116                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 81; extern void __fastcall blit_map( unsigned char tile_x<map_bat_x>, unsigned char tile_y<map_bat_y>, unsigned char tile_w<map_draw_x>, unsigned char tile_h<map_draw_y> );
 1117                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 83; extern unsigned char __fastcall get_map_block( unsigned int x<map_pxl_x>, unsigned int y<map_pxl_y> );
 1118                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 85; #asm
 1119                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 86; .macro	_set_blkmap.2
 1120                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 87; stz	vdc_scr_bank
 1121                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 88; .endm
 1122                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 90; .macro	_set_multimap.2
 1123                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 91; lda	vdc_bat_width
 1124                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 92; lsr	a
 1125                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 93; sta	vdc_map_line_w
 1126                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 94; .endm
 1127                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 96; .macro	SCREEN
 1128                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 97; db	(((\1) & $1FFF) | $6000) >> 8, bank(\1)
 1129                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 98; db	(((\2) & $1FFF) | $4000) >> 8, bank(\2)
 1130                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 99; db	(((\3) & $1FFF) | $6000) >> 8, bank(\3)
 1131                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 100; dw	(\4)
 1132                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 101; .endm
 1133                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 102; #endasm
 1134                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 104; #ifdef _SGX
 1135                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 106; // Current top-left of drawn map in pixels.
 1136                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 107; extern unsigned int   sgx_map_pxl_x;
 1137                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 108; extern unsigned int   sgx_map_pxl_y;
 1138                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 110; // Width and height to draw/scroll in characters (not tiles).
 1139                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 111; extern unsigned char  sgx_map_draw_w;
 1140                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 112; extern unsigned char  sgx_map_draw_h;
 1141                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 114; // Width of map (or multi-screen BAT) in tiles.
 1142                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 115; extern unsigned char  sgx_map_line_w;
 1143                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 117; // Width of map in screens (if multi-screen map).
 1144                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 118; extern unsigned char  sgx_map_scrn_w;
 1145                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 120; extern unsigned char  sgx_scr_bank;
 1146                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 121; extern unsigned char *sgx_scr_addr;
 1147                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 123; extern unsigned char  sgx_map_bank;
 1148                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 124; extern unsigned char *sgx_map_addr;
 1149                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 126; extern unsigned char  sgx_blk_bank;
 1150                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 127; extern unsigned char *sgx_blk_addr;
 1151                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 129; extern unsigned char  sgx_tbl_bank;
 1152                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 130; extern unsigned char *sgx_tbl_addr;
 1153                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 132; extern void __fastcall sgx_set_blocks( unsigned char __far *blk_def<sgx_blk_bank:sgx_blk_addr>, unsigned char __far *flg_def<sgx_tbl_bank:sgx_tbl_addr>, unsigned char number_of_blocks<_al> );
 1154                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 133; extern void __fastcall __macro sgx_set_blkmap( unsigned char __far *blk_map<sgx_map_bank:sgx_map_addr>, unsigned char blocks_w<sgx_map_line_w> );
 1155                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 134; extern void __fastcall __macro sgx_set_multimap( unsigned char __far *multi_map<sgx_scr_bank:sgx_scr_addr>, unsigned char screens_w<sgx_map_scrn_w> );
 1156                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 136; extern void __fastcall sgx_draw_map( void );
 1157                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 137; extern void __fastcall sgx_scroll_map( void );
 1158                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 139; extern void __fastcall sgx_blit_map( unsigned char tile_x<map_bat_x>, unsigned char tile_y<map_bat_y>, unsigned char tile_w<map_draw_x>, unsigned char tile_h<map_draw_y> );
 1159                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 141; extern unsigned char __fastcall sgx_get_map_block( unsigned int x<map_pxl_x>, unsigned int y<map_pxl_y> );
 1160                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 143; #asm
 1161                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 144; .macro	_sgx_set_blkmap.2
 1162                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 145; stz	sgx_scr_bank
 1163                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 146; .endm
 1164                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 148; .macro	_sgx_set_multimap.2
 1165                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 149; lda	sgx_bat_width
 1166                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 150; lsr	a
 1167                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 151; sta	sgx_map_line_w
 1168                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 152; .endm
 1169                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 153; #endasm
 1170                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 155; #endif
 1171                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 157; #endif // __HUCC__
 1172                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 159; #endif // _hucc_blkmap_h
 1173                        		.dbg	line,	"main.c", 7; #include "include/constants.c"
 1174                        		.dbg	line,	"include\constants.c", 1; //*****************************************************************************//
 1175                        		.dbg	line,	"include\constants.c", 2; //                                                                             //
 1176                        		.dbg	line,	"include\constants.c", 3; //                                SYSTEM CONSTANTS                             //
 1177                        		.dbg	line,	"include\constants.c", 4; //                                                                             //
 1178                        		.dbg	line,	"include\constants.c", 5; //*****************************************************************************//
 1179                        		.dbg	line,	"include\constants.c", 7; #define FALSE 0
 1180                        		.dbg	line,	"include\constants.c", 8; #define TRUE  1
 1181                        		.dbg	line,	"include\constants.c", 10; #define YES   1
 1182                        		.dbg	line,	"include\constants.c", 11; #define NO    2
 1183                        		.dbg	line,	"include\constants.c", 13; #define JOYPAD_1 0
 1184                        		.dbg	line,	"include\constants.c", 14; #define JOYPAD_2 1
 1185                        		.dbg	line,	"include\constants.c", 16; #define BAT_SIZE_W 2048 // IN PIXELS
 1186                        		.dbg	line,	"include\constants.c", 17; #define BAT_SIZE_H 256  // IN PIXELS
 1187                        		.dbg	line,	"include\constants.c", 19; #define NUMBERS_FONT_VRAM_ADR   0x0900
 1188                        		.dbg	line,	"include\constants.c", 21; #define JOY_DIR_PRESSED (JOY_DOWN | JOY_UP | JOY_RIGHT | JOY_LEFT)
 1189                        		.dbg	line,	"include\constants.c", 24; #define TILES_1   16
 1190                        		.dbg	line,	"include\constants.c", 25; #define TILES_2   32
 1191                        		.dbg	line,	"include\constants.c", 26; #define TILES_3   48
 1192                        		.dbg	line,	"include\constants.c", 27; #define TILES_4   64
 1193                        		.dbg	line,	"include\constants.c", 28; #define TILES_8   128
 1194                        		.dbg	line,	"include\constants.c", 29; #define TILES_16  256
 1195                        		.dbg	line,	"include\constants.c", 30; #define TILES_32  512
 1196                        		.dbg	line,	"include\constants.c", 31; #define TILES_48  768
 1197                        		.dbg	line,	"include\constants.c", 32; #define TILES_64  1024
 1198                        		.dbg	line,	"include\constants.c", 33; #define TILES_80  1280
 1199                        		.dbg	line,	"include\constants.c", 34; #define TILES_96  1536
 1200                        		.dbg	line,	"include\constants.c", 35; #define TILES_112 1792
 1201                        		.dbg	line,	"include\constants.c", 36; #define TILES_128 2048
 1202                        		.dbg	line,	"include\constants.c", 37; #define TILES_144 2304
 1203                        		.dbg	line,	"include\constants.c", 38; #define TILES_160 2560
 1204                        		.dbg	line,	"include\constants.c", 39; #define TILES_176 2816
 1205                        		.dbg	line,	"include\constants.c", 40; #define TILES_192 3072
 1206                        		.dbg	line,	"include\constants.c", 41; #define TILES_208 3328
 1207                        		.dbg	line,	"include\constants.c", 42; #define TILES_224 3584+256
 1208                        		.dbg	line,	"include\constants.c", 45; #define OFFSET_PLAYER_WALK_1     256
 1209                        		.dbg	line,	"include\constants.c", 46; #define OFFSET_PLAYER_WALK_2     512
 1210                        		.dbg	line,	"include\constants.c", 47; #define OFFSET_PLAYER_WALK_3     768
 1211                        		.dbg	line,	"include\constants.c", 48; #define OFFSET_PLAYER_WALK_4     1024
 1212                        		.dbg	line,	"include\constants.c", 49; #define OFFSET_PLAYER_WALK_5     1280
 1213                        		.dbg	line,	"include\constants.c", 50; #define OFFSET_PLAYER_WALK_6     1536
 1214                        		.dbg	line,	"include\constants.c", 57; #define SEQUENCE_TITLE      0
 1215                        		.dbg	line,	"include\constants.c", 58; #define SEQUENCE_INTRO      1
 1216                        		.dbg	line,	"include\constants.c", 59; #define SEQUENCE_GAME       2
 1217                        		.dbg	line,	"include\constants.c", 60; #define SEQUENCE_NPC        3
 1218                        		.dbg	line,	"include\constants.c", 61; #define SEQUENCE_SHOP       4
 1219                        		.dbg	line,	"include\constants.c", 64; #define CAMERA_RECENTER_VELOCITY    4
 1220                        		.dbg	line,	"include\constants.c", 69; //-----------------------------------------------------------------------------//
 1221                        		.dbg	line,	"include\constants.c", 70; //                                                                             //
 1222                        		.dbg	line,	"include\constants.c", 71; //                                   PLAYER                                    //
 1223                        		.dbg	line,	"include\constants.c", 72; //                                                                             //
 1224                        		.dbg	line,	"include\constants.c", 73; //-----------------------------------------------------------------------------//
 1225                        		.dbg	line,	"include\constants.c", 75; #define AXIS_RIGHT          0
 1226                        		.dbg	line,	"include\constants.c", 76; #define AXIS_LEFT           1
 1227                        		.dbg	line,	"include\constants.c", 77; #define AXIS_UP             2
 1228                        		.dbg	line,	"include\constants.c", 78; #define AXIS_DOWN           3
 1229                        		.dbg	line,	"include\constants.c", 82; #define STATE_IDLE          0
 1230                        		.dbg	line,	"include\constants.c", 83; #define STATE_WALK          1
 1231                        		.dbg	line,	"include\constants.c", 84; #define STATE_PUNCH         2
 1232                        		.dbg	line,	"include\constants.c", 85; #define STATE_JUMP          4
 1233                        		.dbg	line,	"include\constants.c", 86; #define STATE_JUMP_RIGHT    5
 1234                        		.dbg	line,	"include\constants.c", 87; #define STATE_JUMP_LEFT     6
 1235                        		.dbg	line,	"include\constants.c", 88; #define STATE_CROUCH        7
 1236                        		.dbg	line,	"include\constants.c", 89; #define STATE_CROUCH_PUNCH  8
 1237                        		.dbg	line,	"include\constants.c", 90; #define STATE_FALL          9
 1238                        		.dbg	line,	"include\constants.c", 91; #define STATE_HANG          10
 1239                        		.dbg	line,	"include\constants.c", 92; #define STATE_CLIMB_UP      11
 1240                        		.dbg	line,	"include\constants.c", 93; #define STATE_CLIMB_DOWN    12
 1241                        		.dbg	line,	"include\constants.c", 94; #define STATE_JUMP_LADDER   13
 1242                        		.dbg	line,	"include\constants.c", 98; #define PLAYER_VRAM_ADR     0x1800
 1243                        		.dbg	line,	"include\constants.c", 100; #define PLAYER_BASE_Y_POS   128
 1244                        		.dbg	line,	"include\constants.c", 103; #define RESPAWN_DEAD        1
 1245                        		.dbg	line,	"include\constants.c", 104; #define RESPAWN_SHOP        2
 1246                        		.dbg	line,	"include\constants.c", 109; //-----------------------------------------------------------------------------//
 1247                        		.dbg	line,	"include\constants.c", 110; //                                                                             //
 1248                        		.dbg	line,	"include\constants.c", 111; //                                  COLLISIONS                                 //
 1249                        		.dbg	line,	"include\constants.c", 112; //                                                                             //
 1250                        		.dbg	line,	"include\constants.c", 113; //-----------------------------------------------------------------------------//
 1251                        		.dbg	line,	"include\constants.c", 115; #define TILE_EMPTY          0
 1252                        		.dbg	line,	"include\constants.c", 116; #define TILE_BG             1
 1253                        		.dbg	line,	"include\constants.c", 117; #define TILE_LADDER         2
 1254                        		.dbg	line,	"include\constants.c", 122; //-----------------------------------------------------------------------------//
 1255                        		.dbg	line,	"include\constants.c", 123; //                                                                             //
 1256                        		.dbg	line,	"include\constants.c", 124; //                                     HUD                                     //
 1257                        		.dbg	line,	"include\constants.c", 125; //                                                                             //
 1258                        		.dbg	line,	"include\constants.c", 126; //-----------------------------------------------------------------------------//
 1259                        		.dbg	line,	"include\constants.c", 128; #define LIFEBAR_1_VRAM_ADR      0x1000
 1260                        		.dbg	line,	"include\constants.c", 129; #define LIFEBAR_2_VRAM_ADR      LIFEBAR_1_VRAM_ADR+TILES_2
 1261                        		.dbg	line,	"include\constants.c", 130; #define LIFEBAR_3_VRAM_ADR      LIFEBAR_2_VRAM_ADR+TILES_2
 1262                        		.dbg	line,	"include\constants.c", 131; #define LIFEBAR_4_VRAM_ADR      LIFEBAR_3_VRAM_ADR+TILES_2
 1263                        		.dbg	line,	"include\constants.c", 132; #define LIFEBAR_5_VRAM_ADR      LIFEBAR_4_VRAM_ADR+TILES_2
 1264                        		.dbg	line,	"include\constants.c", 134; #define WEAPON_VRAM_ADR         LIFEBAR_5_VRAM_ADR+TILES_2
 1265                        		.dbg	line,	"include\constants.c", 135; #define ARMOR_VRAM_ADR          WEAPON_VRAM_ADR+TILES_4
 1266                        		.dbg	line,	"include\constants.c", 140; //-----------------------------------------------------------------------------//
 1267                        		.dbg	line,	"include\constants.c", 141; //                                                                             //
 1268                        		.dbg	line,	"include\constants.c", 142; //                                    LEVELS                                   //
 1269                        		.dbg	line,	"include\constants.c", 143; //                                                                             //
 1270                        		.dbg	line,	"include\constants.c", 144; //-----------------------------------------------------------------------------//
 1271                        		.dbg	line,	"include\constants.c", 146; #define LV1_WALL_VRAM_ADR       0x1000
 1272                        		.dbg	line,	"include\constants.c", 147; #define LV1_DOOR_VRAM_ADR       LV1_WALL_VRAM_ADR+256
 1273                        		.dbg	line,	"include\constants.c", 150; #define OBJECT_NUMBER_LV1       23
 1274                        		.dbg	line,	"include\constants.c", 151; #define CHEST_NUMBER_LV1        2
 1275                        		.dbg	line,	"include\constants.c", 152; #define NPC_NUMBER_LV1          2
 1276                        		.dbg	line,	"include\constants.c", 154; #define OBJECT_START_INDEX_LV1  3
 1277                        		.dbg	line,	"include\constants.c", 155; #define CHEST_START_INDEX_LV1   OBJECT_START_INDEX_LV1+OBJECT_NUMBER_LV1
 1278                        		.dbg	line,	"include\constants.c", 156; #define NPC_START_INDEX_LV1     CHEST_START_INDEX_LV1+CHEST_NUMBER_LV1
 1279                        		.dbg	line,	"include\constants.c", 161; //-----------------------------------------------------------------------------//
 1280                        		.dbg	line,	"include\constants.c", 162; //                                                                             //
 1281                        		.dbg	line,	"include\constants.c", 163; //                                   OBJECT                                    //
 1282                        		.dbg	line,	"include\constants.c", 164; //                                                                             //
 1283                        		.dbg	line,	"include\constants.c", 165; //-----------------------------------------------------------------------------//
 1284                        		.dbg	line,	"include\constants.c", 167; #define TYPE_HOURGLASS          0
 1285                        		.dbg	line,	"include\constants.c", 168; #define TYPE_POT                1
 1286                        		.dbg	line,	"include\constants.c", 169; #define TYPE_POW                2
 1287                        		.dbg	line,	"include\constants.c", 170; #define TYPE_CHEST              3
 1288                        		.dbg	line,	"include\constants.c", 171; #define TYPE_GRAY_KEY           4
 1289                        		.dbg	line,	"include\constants.c", 172; #define TYPE_GOLD_KEY           5
 1290                        		.dbg	line,	"include\constants.c", 173; #define TYPE_1UP                6
 1291                        		.dbg	line,	"include\constants.c", 174; #define TYPE_COIN_1             7
 1292                        		.dbg	line,	"include\constants.c", 175; #define TYPE_COIN_5             8
 1293                        		.dbg	line,	"include\constants.c", 176; #define TYPE_COIN_10            9
 1294                        		.dbg	line,	"include\constants.c", 177; #define TYPE_COIN_50            10
 1295                        		.dbg	line,	"include\constants.c", 178; #define TYPE_COIN_100           11
 1296                        		.dbg	line,	"include\constants.c", 179; #define TYPE_COIN_500           12
 1297                        		.dbg	line,	"include\constants.c", 180; #define TYPE_COIN_1000          13
 1298                        		.dbg	line,	"include\constants.c", 181; #define TYPE_YASHICHI           14
 1299                        		.dbg	line,	"include\constants.c", 184; #define STATE_ACTIVE            0
 1300                        		.dbg	line,	"include\constants.c", 185; #define STATE_INACTIVE          1
 1301                        		.dbg	line,	"include\constants.c", 187; #define OBJECT_MARGIN           10//9
 1302                        		.dbg	line,	"include\constants.c", 190; #define POT1_VRAM_ADR           0x1C00
 1303                        		.dbg	line,	"include\constants.c", 191; #define POT2_VRAM_ADR           POT1_VRAM_ADR+TILES_4
 1304                        		.dbg	line,	"include\constants.c", 192; #define POT3_VRAM_ADR           POT2_VRAM_ADR+TILES_4
 1305                        		.dbg	line,	"include\constants.c", 193; #define POT4_VRAM_ADR           POT3_VRAM_ADR+TILES_4
 1306                        		.dbg	line,	"include\constants.c", 194; #define POT5_VRAM_ADR           POT4_VRAM_ADR+TILES_4
 1307                        		.dbg	line,	"include\constants.c", 195; #define POT6_VRAM_ADR           POT5_VRAM_ADR+TILES_4
 1308                        		.dbg	line,	"include\constants.c", 196; #define POT7_VRAM_ADR           POT6_VRAM_ADR+TILES_4
 1309                        		.dbg	line,	"include\constants.c", 197; #define POT8_VRAM_ADR           POT7_VRAM_ADR+TILES_4
 1310                        		.dbg	line,	"include\constants.c", 199; #define POW_VRAM_ADR            POT8_VRAM_ADR+TILES_4
 1311                        		.dbg	line,	"include\constants.c", 200; #define GRAY_KEY_VRAM_ADR       POW_VRAM_ADR+TILES_4
 1312                        		.dbg	line,	"include\constants.c", 201; #define GOLD_KEY_VRAM_ADR       GRAY_KEY_VRAM_ADR+TILES_4
 1313                        		.dbg	line,	"include\constants.c", 202; #define LIFE_VRAM_ADR           GOLD_KEY_VRAM_ADR+TILES_4
 1314                        		.dbg	line,	"include\constants.c", 204; #define COIN_1_VRAM_ADR         LIFE_VRAM_ADR+TILES_4
 1315                        		.dbg	line,	"include\constants.c", 205; #define COIN_5_VRAM_ADR         COIN_1_VRAM_ADR+TILES_4
 1316                        		.dbg	line,	"include\constants.c", 206; #define COIN_10_VRAM_ADR        COIN_5_VRAM_ADR+TILES_4
 1317                        		.dbg	line,	"include\constants.c", 207; #define COIN_50_VRAM_ADR        COIN_10_VRAM_ADR+TILES_4
 1318                        		.dbg	line,	"include\constants.c", 208; #define COIN_100_VRAM_ADR       COIN_50_VRAM_ADR+TILES_4
 1319                        		.dbg	line,	"include\constants.c", 209; #define COIN_500_VRAM_ADR       COIN_100_VRAM_ADR+TILES_4
 1320                        		.dbg	line,	"include\constants.c", 210; #define COIN_1000_VRAM_ADR      COIN_500_VRAM_ADR+TILES_4
 1321                        		.dbg	line,	"include\constants.c", 212; #define STAR_VRAM_ADR           COIN_1000_VRAM_ADR+TILES_4
 1322                        		.dbg	line,	"include\constants.c", 213; #define OCTOPUS_VRAM_ADR        STAR_VRAM_ADR+TILES_4
 1323                        		.dbg	line,	"include\constants.c", 214; #define FRUIT_VRAM_ADR          OCTOPUS_VRAM_ADR+TILES_4
 1324                        		.dbg	line,	"include\constants.c", 215; #define BARREL_VRAM_ADR         FRUIT_VRAM_ADR+TILES_4
 1325                        		.dbg	line,	"include\constants.c", 216; #define HOURGLASS_VRAM_ADR      BARREL_VRAM_ADR+TILES_4
 1326                        		.dbg	line,	"include\constants.c", 217; #define BAMBOO_VRAM_ADR         HOURGLASS_VRAM_ADR+TILES_4
 1327                        		.dbg	line,	"include\constants.c", 218; #define YASHICHI_VRAM_ADR       BAMBOO_VRAM_ADR+TILES_4
 1328                        		.dbg	line,	"include\constants.c", 219; #define ELEPHANT_VRAM_ADR       YASHICHI_VRAM_ADR+TILES_4
 1329                        		.dbg	line,	"include\constants.c", 220; #define DRAGONFLY_VRAM_ADR      ELEPHANT_VRAM_ADR+TILES_4
 1330                        		.dbg	line,	"include\constants.c", 221; #define COW_VRAM_ADR            DRAGONFLY_VRAM_ADR+TILES_4
 1331                        		.dbg	line,	"include\constants.c", 222; #define MOBICHAN_VRAM_ADR       COW_VRAM_ADR+TILES_4
 1332                        		.dbg	line,	"include\constants.c", 224; #define CHEST_VRAM_ADR          0x2400
 1333                        		.dbg	line,	"include\constants.c", 225; #define NPC_VRAM_ADR            CHEST_VRAM_ADR+TILES_96
 1334                        		.dbg	line,	"include\constants.c", 230; //-----------------------------------------------------------------------------//
 1335                        		.dbg	line,	"include\constants.c", 231; //                                                                             //
 1336                        		.dbg	line,	"include\constants.c", 232; //                                    NPC                                      //
 1337                        		.dbg	line,	"include\constants.c", 233; //                                                                             //
 1338                        		.dbg	line,	"include\constants.c", 234; //-----------------------------------------------------------------------------//
 1339                        		.dbg	line,	"include\constants.c", 236; #define TYPE_NPC_REWARD         0
 1340                        		.dbg	line,	"include\constants.c", 237; #define TYPE_NPC_SHOP           1
 1341                        		.dbg	line,	"include\constants.c", 242; //-----------------------------------------------------------------------------//
 1342                        		.dbg	line,	"include\constants.c", 243; //                                                                             //
 1343                        		.dbg	line,	"include\constants.c", 244; //                                    SHOP                                     //
 1344                        		.dbg	line,	"include\constants.c", 245; //                                                                             //
 1345                        		.dbg	line,	"include\constants.c", 246; //-----------------------------------------------------------------------------//
 1346                        		.dbg	line,	"include\constants.c", 248; #define TYPE_ITEM_WEAPON_2      0
 1347                        		.dbg	line,	"include\constants.c", 249; #define TYPE_ITEM_WEAPON_3      1
 1348                        		.dbg	line,	"include\constants.c", 250; #define TYPE_ITEM_WEAPON_4      2
 1349                        		.dbg	line,	"include\constants.c", 251; #define TYPE_ITEM_WEAPON_5      3
 1350                        		.dbg	line,	"include\constants.c", 252; #define TYPE_ITEM_KEY           4
 1351                        		.dbg	line,	"include\constants.c", 254; #define TYPE_ITEM_ARMOR_2       5
 1352                        		.dbg	line,	"include\constants.c", 255; #define TYPE_ITEM_ARMOR_3       6
 1353                        		.dbg	line,	"include\constants.c", 256; #define TYPE_ITEM_ARMOR_4       7
 1354                        		.dbg	line,	"include\constants.c", 257; #define TYPE_ITEM_ARMOR_5       8
 1355                        		.dbg	line,	"include\constants.c", 258; #define TYPE_ITEM_POTION        9
 1356                        		.dbg	line,	"main.c", 8; #include "include/variables.c"
 1357                        		.dbg	line,	"include\variables.c", 1; #include "huc.h"
 1358                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 1; #ifndef _hucc_legacy_h
 1359                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 2; #define _hucc_legacy_h
 1360                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 4; /****************************************************************************
 1361                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 5; ; ***************************************************************************
 1362                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 6; ;
 1363                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 7; ; huc.h
 1364                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 8; ;
 1365                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 9; ; HuCC wrapper file to include a default set of HuC-compatible functions.
 1366                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 10; ;
 1367                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 11; ; Copyright John Brandwood 2024.
 1368                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 12; ;
 1369                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 13; ; Distributed under the Boost Software License, Version 1.0.
 1370                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 14; ; (See accompanying file LICENSE_1_0.txt or copy at
 1371                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 15; ;  http://www.boost.org/LICENSE_1_0.txt)
 1372                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 16; ;
 1373                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 17; ; ***************************************************************************
 1374                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 18; ; ***************************************************************************
 1375                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 19; ;
 1376                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 20; ; When the HuCC compiler is invoked with the "--legacy" option to compile old
 1377                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 21; ; projects, then this "huc.h" file is automatically included.
 1378                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 22; ;
 1379                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 23; ; This file includes a set of the individual HuCC headers which correspond to
 1380                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 24; ; HuC's built-in functions and MagicKit library.
 1381                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 25; ;
 1382                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 26; ; New HuCC projects should, preferably, include the specific headers that are
 1383                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 27; ; needed, which will then allow them to replace parts of the standard library
 1384                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 28; ; with newer functions, or they can just manually include this "huc.h" file.
 1385                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 29; ;
 1386                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 30; ; ***************************************************************************
 1387                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 31; ; **************************************************************************/
 1388                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 33; #include "hucc-systemcard.h"
 1389                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 34; #include "hucc-baselib.h"
 1390                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 35; #include "hucc-gfx.h"
 1391                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 36; #include "hucc-string.h"
 1392                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 37; #include "hucc-old-scroll.h"
 1393                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 38; #include "hucc-old-spr.h"
 1394                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 39; #include "hucc-old-map.h"
 1395                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 40; #include "hucc-old-line.h"
 1396                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 42; #endif // _hucc_legacy_h
 1397                        		.dbg	line,	"include\variables.c", 2; #include "hucc-scroll.h"
 1398                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 1; #ifndef _hucc_scroll_h
 1399                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 2; #define _hucc_scroll_h
 1400                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 4; /****************************************************************************
 1401                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 5; ; ***************************************************************************
 1402                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 6; ;
 1403                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 7; ; hucc-scroll.h
 1404                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 8; ;
 1405                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 9; ; Routines for a fast split-screen scrolling system.
 1406                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 10; ;
 1407                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 11; ; Copyright John Brandwood 2024.
 1408                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 12; ;
 1409                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 13; ; Distributed under the Boost Software License, Version 1.0.
 1410                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 14; ; (See accompanying file LICENSE_1_0.txt or copy at
 1411                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 15; ;  http://www.boost.org/LICENSE_1_0.txt)
 1412                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 16; ;
 1413                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 17; ; ***************************************************************************
 1414                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 18; ; ***************************************************************************
 1415                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 19; ;
 1416                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 20; ; The maximum number of splits for each screen layer is set in your project's
 1417                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 21; ; "hucc-config.inc" file, with the library having a limit of 128-per-layer.
 1418                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 22; ;
 1419                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 23; ; Your first active split must be defined to start at screen line 0, and then
 1420                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 24; ; the rest of the active splits must be in increasing line order to match the
 1421                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 25; ; way that the PC Engine displays the output image.
 1422                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 26; ;
 1423                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 27; ; You can have disabled splits interleaved with your active splits.
 1424                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 28; ;
 1425                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 29; ; Splits that are normally disabled can be used to create full screen effects
 1426                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 30; ; such as bouncing the screen up and down by adding blank areas at the top or
 1427                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 31; ; bottom of the screen, and then rapidly changing the height of those areas.
 1428                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 32; ;
 1429                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 33; ; ***************************************************************************
 1430                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 34; ; **************************************************************************/
 1431                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 36; // *************
 1432                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 37; // VDC bits for display_flags ...
 1433                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 38; // *************
 1434                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 40; #ifndef BKG_OFF
 1435                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 41; #define BKG_OFF 0x00
 1436                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 42; #endif
 1437                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 44; #ifndef SPR_OFF
 1438                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 45; #define SPR_OFF 0x00
 1439                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 46; #endif
 1440                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 48; #ifndef BKG_ON
 1441                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 49; #define BKG_ON 0x80
 1442                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 50; #endif
 1443                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 52; #ifndef SPR_ON
 1444                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 53; #define SPR_ON 0x40
 1445                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 54; #endif
 1446                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 56; // *************
 1447                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 57; // Functions in hucc-scroll.asm ...
 1448                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 58; // *************
 1449                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 60; #ifdef __HUCC__
 1450                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 62; #asmdef	HUCC_USES_NEW_SCROLL 1
 1451                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 64; extern void __fastcall scroll_split( unsigned char index<_al>, unsigned char screen_line<_ah>, unsigned int bat_x<_bx>, unsigned int bat_y<_cx>, unsigned char display_flags<_dl> );
 1452                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 65; extern void __fastcall sgx_scroll_split( unsigned char index<_al>, unsigned char screen_line<_ah>, unsigned int bat_x<_bx>, unsigned int bat_y<_cx>, unsigned char display_flags<_dl> );
 1453                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 67; extern void __fastcall disable_split( unsigned char index<acc> );
 1454                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 68; extern void __fastcall sgx_disable_split( unsigned char index<acc> );
 1455                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 70; extern void __fastcall __macro disable_all_splits( void );
 1456                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 71; extern void __fastcall __macro sgx_disable_all_splits( void );
 1457                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 73; #asm
 1458                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 74; .macro	_disable_all_splits
 1459                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 75; ldy	#HUCC_PCE_SPLITS - 1
 1460                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 76; !loop:		tya
 1461                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 77; call	_disable_split.1
 1462                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 78; dey
 1463                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 79; bpl	!loop-
 1464                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 80; .endm
 1465                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 82; .macro	_sgx_disable_all_splits
 1466                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 83; ldy	#HUCC_SGX_SPLITS - 1
 1467                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 84; !loop:		tya
 1468                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 85; call	_sgx_disable_split.1
 1469                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 86; dey
 1470                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 87; bpl	!loop-
 1471                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 88; .endm
 1472                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 89; #endasm
 1473                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 91; #endif // __HUCC__
 1474                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 93; #endif // _hucc_scroll_h
 1475                        		.dbg	line,	"include\variables.c", 3; #include "hucc-chrmap.h"
 1476                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 1; #ifndef _hucc_chrmap_h
 1477                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 2; #define _hucc_chrmap_h
 1478                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 4; /****************************************************************************
 1479                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 5; ; ***************************************************************************
 1480                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 6; ;
 1481                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 7; ; hucc-chrmap.h
 1482                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 8; ;
 1483                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 9; ; A simple map system based on 8x8 characters (aka "tiles") in BAT format.
 1484                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 10; ;
 1485                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 11; ; Copyright John Brandwood 2025.
 1486                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 12; ;
 1487                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 13; ; Distributed under the Boost Software License, Version 1.0.
 1488                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 14; ; (See accompanying file LICENSE_1_0.txt or copy at
 1489                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 15; ;  http://www.boost.org/LICENSE_1_0.txt)
 1490                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 16; ;
 1491                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 17; ; ***************************************************************************
 1492                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 18; ; ***************************************************************************
 1493                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 19; ;
 1494                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 20; ; The maximum X and Y size for chrmaps is 256 characters (2048 pixels).
 1495                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 21; ;
 1496                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 22; ; The maximum total size for a chrmap is 16KBytes, which allows for maps up
 1497                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 23; ; to 256x32 tiles (2048x256 pixels).
 1498                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 24; ;
 1499                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 25; ; ***************************************************************************
 1500                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 26; ; **************************************************************************/
 1501                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 28; // *************
 1502                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 29; // This code extends the blkmap library ...
 1503                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 30; // *************
 1504                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 32; #include "hucc-blkmap.h"
 1505                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 34; // *************
 1506                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 35; // Functions in chrmap.asm ...
 1507                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 36; // *************
 1508                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 38; #ifdef __HUCC__
 1509                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 40; #asmdef	HUCC_USES_CHRMAP 1
 1510                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 42; extern void __fastcall __nop set_chrmap( unsigned char __far *chrmap<vdc_map_bank:vdc_map_addr>, unsigned char tiles_w<vdc_map_line_w> );
 1511                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 44; extern void __fastcall draw_bat( void );
 1512                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 45; extern void __fastcall scroll_bat( void );
 1513                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 47; extern void __fastcall blit_bat( unsigned char tile_x<map_bat_x>, unsigned char tile_y<map_bat_y>, unsigned char tile_w<map_draw_x>, unsigned char tile_h<map_draw_y> );
 1514                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 49; #ifdef _SGX
 1515                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 51; extern void __fastcall __nop sgx_set_chrmap( unsigned char __far *chrmap<sgx_map_bank:sgx_map_addr>, unsigned char tiles_w<sgx_map_line_w> );
 1516                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 53; extern void __fastcall sgx_draw_bat( void );
 1517                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 54; extern void __fastcall sgx_scroll_bat( void );
 1518                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 56; extern void __fastcall sgx_blit_bat( unsigned char tile_x<map_bat_x>, unsigned char tile_y<map_bat_y>, unsigned char tile_w<map_draw_x>, unsigned char tile_h<map_draw_y> );
 1519                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 58; #endif
 1520                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 60; #endif // __HUCC__
 1521                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 62; #endif // _hucc_chrmap_h
 1522                        		.dbg	line,	"include\variables.c", 4; #include "hucc-blkmap.h"
 1523                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 1; #ifndef _hucc_blkmap_h
 1524                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 2; #define _hucc_blkmap_h
 1525                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 4; /****************************************************************************
 1526                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 5; ; ***************************************************************************
 1527                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 6; ;
 1528                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 7; ; hucc-blkmap.h
 1529                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 8; ;
 1530                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 9; ; A map system based on 16x16 meta-tiles (aka "blocks", aka CHR/BLK/MAP).
 1531                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 10; ;
 1532                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 11; ; Copyright John Brandwood 2025.
 1533                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 12; ;
 1534                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 13; ; Distributed under the Boost Software License, Version 1.0.
 1535                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 14; ; (See accompanying file LICENSE_1_0.txt or copy at
 1536                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 15; ;  http://www.boost.org/LICENSE_1_0.txt)
 1537                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 16; ;
 1538                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 17; ; ***************************************************************************
 1539                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 18; ; ***************************************************************************
 1540                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 19; ;
 1541                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 20; ; The maximum X and Y size for blkmaps is 128 blocks (2048 pixels).
 1542                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 21; ;
 1543                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 22; ; The maximum total size for a blkmap is 16KBytes, which allows for maps up
 1544                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 23; ; to 128x128 blocks (2048x2048 pixels).
 1545                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 24; ;
 1546                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 25; ; Huge multi-screen blkmaps are also supported (optionally).
 1547                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 26; ;
 1548                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 27; ; The maximum X and Y for multi-screen maps is 128 screens (32768 pixels).
 1549                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 28; ;
 1550                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 29; ; The maximum total size for a multi-screen map is 8KBytes, which allows for
 1551                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 30; ; a total of 1024 screens.
 1552                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 31; ;
 1553                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 32; ; ***************************************************************************
 1554                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 33; ; **************************************************************************/
 1555                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 35; // *************
 1556                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 36; // Functions in blkmap.asm ...
 1557                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 37; // *************
 1558                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 39; #ifdef __HUCC__
 1559                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 41; #asmdef	HUCC_USES_BLKMAP 1
 1560                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 43; // Current top-left of drawn map in pixels.
 1561                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 44; extern unsigned int   vdc_map_pxl_x;
 1562                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 45; extern unsigned int   vdc_map_pxl_y;
 1563                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 47; // Width and height to draw/scroll in characters (not tiles).
 1564                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 48; extern unsigned char  vdc_map_draw_w;
 1565                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 49; extern unsigned char  vdc_map_draw_h;
 1566                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 51; // Width of map (or multi-screen BAT) in tiles.
 1567                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 52; extern unsigned char  vdc_map_line_w;
 1568                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 54; // Width of map in screens (if multi-screen map).
 1569                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 55; extern unsigned char  vdc_map_scrn_w;
 1570                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 57; // Extra information returned by get_map_block() and sgx_get_map_block(),
 1571                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 58; // which are the collision flags and the mask/overlay sprite for the BLK.
 1572                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 59; extern unsigned char  map_blk_flag;
 1573                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 60; extern unsigned char  map_blk_mask;
 1574                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 62; extern unsigned char  vdc_scr_bank;
 1575                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 63; extern unsigned char *vdc_scr_addr;
 1576                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 65; extern unsigned char  vdc_map_bank;
 1577                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 66; extern unsigned char *vdc_map_addr;
 1578                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 68; extern unsigned char  vdc_blk_bank;
 1579                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 69; extern unsigned char *vdc_blk_addr;
 1580                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 71; extern unsigned char  vdc_tbl_bank;
 1581                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 72; extern unsigned char *vdc_tbl_addr;
 1582                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 74; extern void __fastcall set_blocks( unsigned char __far *blk_def<vdc_blk_bank:vdc_blk_addr>, unsigned char __far *flg_def<vdc_tbl_bank:vdc_tbl_addr>, unsigned char number_of_blocks<_al> );
 1583                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 75; extern void __fastcall __macro set_blkmap( unsigned char __far *blk_map<vdc_map_bank:vdc_map_addr>, unsigned char blocks_w<vdc_map_line_w> );
 1584                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 76; extern void __fastcall __macro set_multimap( unsigned char __far *multi_map<vdc_scr_bank:vdc_scr_addr>, unsigned char screens_w<vdc_map_scrn_w> );
 1585                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 78; extern void __fastcall draw_map( void );
 1586                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 79; extern void __fastcall scroll_map( void );
 1587                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 81; extern void __fastcall blit_map( unsigned char tile_x<map_bat_x>, unsigned char tile_y<map_bat_y>, unsigned char tile_w<map_draw_x>, unsigned char tile_h<map_draw_y> );
 1588                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 83; extern unsigned char __fastcall get_map_block( unsigned int x<map_pxl_x>, unsigned int y<map_pxl_y> );
 1589                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 85; #asm
 1590                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 86; .macro	_set_blkmap.2
 1591                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 87; stz	vdc_scr_bank
 1592                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 88; .endm
 1593                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 90; .macro	_set_multimap.2
 1594                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 91; lda	vdc_bat_width
 1595                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 92; lsr	a
 1596                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 93; sta	vdc_map_line_w
 1597                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 94; .endm
 1598                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 96; .macro	SCREEN
 1599                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 97; db	(((\1) & $1FFF) | $6000) >> 8, bank(\1)
 1600                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 98; db	(((\2) & $1FFF) | $4000) >> 8, bank(\2)
 1601                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 99; db	(((\3) & $1FFF) | $6000) >> 8, bank(\3)
 1602                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 100; dw	(\4)
 1603                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 101; .endm
 1604                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 102; #endasm
 1605                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 104; #ifdef _SGX
 1606                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 106; // Current top-left of drawn map in pixels.
 1607                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 107; extern unsigned int   sgx_map_pxl_x;
 1608                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 108; extern unsigned int   sgx_map_pxl_y;
 1609                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 110; // Width and height to draw/scroll in characters (not tiles).
 1610                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 111; extern unsigned char  sgx_map_draw_w;
 1611                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 112; extern unsigned char  sgx_map_draw_h;
 1612                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 114; // Width of map (or multi-screen BAT) in tiles.
 1613                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 115; extern unsigned char  sgx_map_line_w;
 1614                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 117; // Width of map in screens (if multi-screen map).
 1615                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 118; extern unsigned char  sgx_map_scrn_w;
 1616                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 120; extern unsigned char  sgx_scr_bank;
 1617                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 121; extern unsigned char *sgx_scr_addr;
 1618                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 123; extern unsigned char  sgx_map_bank;
 1619                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 124; extern unsigned char *sgx_map_addr;
 1620                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 126; extern unsigned char  sgx_blk_bank;
 1621                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 127; extern unsigned char *sgx_blk_addr;
 1622                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 129; extern unsigned char  sgx_tbl_bank;
 1623                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 130; extern unsigned char *sgx_tbl_addr;
 1624                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 132; extern void __fastcall sgx_set_blocks( unsigned char __far *blk_def<sgx_blk_bank:sgx_blk_addr>, unsigned char __far *flg_def<sgx_tbl_bank:sgx_tbl_addr>, unsigned char number_of_blocks<_al> );
 1625                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 133; extern void __fastcall __macro sgx_set_blkmap( unsigned char __far *blk_map<sgx_map_bank:sgx_map_addr>, unsigned char blocks_w<sgx_map_line_w> );
 1626                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 134; extern void __fastcall __macro sgx_set_multimap( unsigned char __far *multi_map<sgx_scr_bank:sgx_scr_addr>, unsigned char screens_w<sgx_map_scrn_w> );
 1627                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 136; extern void __fastcall sgx_draw_map( void );
 1628                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 137; extern void __fastcall sgx_scroll_map( void );
 1629                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 139; extern void __fastcall sgx_blit_map( unsigned char tile_x<map_bat_x>, unsigned char tile_y<map_bat_y>, unsigned char tile_w<map_draw_x>, unsigned char tile_h<map_draw_y> );
 1630                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 141; extern unsigned char __fastcall sgx_get_map_block( unsigned int x<map_pxl_x>, unsigned int y<map_pxl_y> );
 1631                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 143; #asm
 1632                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 144; .macro	_sgx_set_blkmap.2
 1633                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 145; stz	sgx_scr_bank
 1634                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 146; .endm
 1635                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 148; .macro	_sgx_set_multimap.2
 1636                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 149; lda	sgx_bat_width
 1637                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 150; lsr	a
 1638                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 151; sta	sgx_map_line_w
 1639                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 152; .endm
 1640                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 153; #endasm
 1641                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 155; #endif
 1642                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 157; #endif // __HUCC__
 1643                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 159; #endif // _hucc_blkmap_h
 1644                        		.dbg	line,	"include\variables.c", 13; unsigned char   sequence_id,
 1645                        		.dbg	line,	"include\variables.c", 14; sequence_loaded,
 1646                        		.dbg	line,	"include\variables.c", 16; level_id,
 1647                        		.dbg	line,	"include\variables.c", 18; // PLAYER //
 1648                        		.dbg	line,	"include\variables.c", 19; respawn,
 1649                        		.dbg	line,	"include\variables.c", 20; player_id,
 1650                        		.dbg	line,	"include\variables.c", 21; player_state,
 1651                        		.dbg	line,	"include\variables.c", 22; player_axis,
 1652                        		.dbg	line,	"include\variables.c", 23; player_previous_axis,
 1653                        		.dbg	line,	"include\variables.c", 24; player_counter_anim,
 1654                        		.dbg	line,	"include\variables.c", 25; player_index_jump,
 1655                        		.dbg	line,	"include\variables.c", 26; player_index_fall,
 1656                        		.dbg	line,	"include\variables.c", 28; jump_ladder,
 1657                        		.dbg	line,	"include\variables.c", 29; jump_max_index,
 1658                        		.dbg	line,	"include\variables.c", 31; // ARMOR + WEAPON //
 1659                        		.dbg	line,	"include\variables.c", 32; armor_level,
 1660                        		.dbg	line,	"include\variables.c", 33; weapon_level,
 1661                        		.dbg	line,	"include\variables.c", 35; // HUD //
 1662                        		.dbg	line,	"include\variables.c", 36; life_amount,
 1663                        		.dbg	line,	"include\variables.c", 37; key_amount,
 1664                        		.dbg	line,	"include\variables.c", 38; potion_amount,
 1665                        		.dbg	line,	"include\variables.c", 40; // TIME //
 1666                        		.dbg	line,	"include\variables.c", 41; minutes,
 1667                        		.dbg	line,	"include\variables.c", 42; seconds,
 1668                        		.dbg	line,	"include\variables.c", 43; time_counter,
 1669                        		.dbg	line,	"include\variables.c", 46; // OBJECTS //
 1670                        		.dbg	line,	"include\variables.c", 47; object_start_index,
 1671                        		.dbg	line,	"include\variables.c", 48; level_object_number,
 1672                        		.dbg	line,	"include\variables.c", 49; onscreen_object_number,
 1673                        		.dbg	line,	"include\variables.c", 50; 
 1674                        		.dbg	line,	"include\variables.c", 51; list_object_type[25],
 1675                        		.dbg	line,	"include\variables.c", 52; list_object_state[25],
 1676                        		.dbg	line,	"include\variables.c", 53; list_object_energy[25],
 1677                        		.dbg	line,	"include\variables.c", 54; list_reward_type[25],
 1678                        		.dbg	line,	"include\variables.c", 55; 
 1679                        		.dbg	line,	"include\variables.c", 56; list_onscreen_object[8],
 1680                        		.dbg	line,	"include\variables.c", 57; 
 1681                        		.dbg	line,	"include\variables.c", 58; // CHESTS //
 1682                        		.dbg	line,	"include\variables.c", 59; chest_start_index,
 1683                        		.dbg	line,	"include\variables.c", 60; level_chest_number,
 1684                        		.dbg	line,	"include\variables.c", 61; onscreen_chest_number,
 1685                        		.dbg	line,	"include\variables.c", 62; 
 1686                        		.dbg	line,	"include\variables.c", 63; list_chest_state[8],
 1687                        		.dbg	line,	"include\variables.c", 64; list_onscreen_chest[8],
 1688                        		.dbg	line,	"include\variables.c", 66; // NPC //
 1689                        		.dbg	line,	"include\variables.c", 67; npc_start_index,
 1690                        		.dbg	line,	"include\variables.c", 68; level_npc_number,
 1691                        		.dbg	line,	"include\variables.c", 69; onscreen_npc_number,
 1692                        		.dbg	line,	"include\variables.c", 71; list_npc_type[9],
 1693                        		.dbg	line,	"include\variables.c", 72; list_npc_state[9],
 1694                        		.dbg	line,	"include\variables.c", 73; list_onscreen_npc[9],
 1695                        		.dbg	line,	"include\variables.c", 75; // SHOPS //
 1696                        		.dbg	line,	"include\variables.c", 76; index_x,
 1697                        		.dbg	line,	"include\variables.c", 77; index_y,
 1698                        		.dbg	line,	"include\variables.c", 78; item_index,
 1699                        		.dbg	line,	"include\variables.c", 79; 
 1700                        		.dbg	line,	"include\variables.c", 80; tilemap_mask[256];
 1701                        		.dbg	line,	"include\variables.c", 85; signed int      player_pos_x,
 1702                        		.dbg	line,	"include\variables.c", 86; player_pos_y,
 1703                        		.dbg	line,	"include\variables.c", 87; camera_max_y_position,
 1704                        		.dbg	line,	"include\variables.c", 89; camera_pos_x_backup,
 1705                        		.dbg	line,	"include\variables.c", 90; camera_pos_y_backup,
 1706                        		.dbg	line,	"include\variables.c", 93; list_object_x_pos[25],
 1707                        		.dbg	line,	"include\variables.c", 94; list_object_y_pos[25],
 1708                        		.dbg	line,	"include\variables.c", 95; list_object_x_pos_ref[25],
 1709                        		.dbg	line,	"include\variables.c", 96; list_object_y_pos_ref[25],
 1710                        		.dbg	line,	"include\variables.c", 99; list_chest_x_pos[8],
 1711                        		.dbg	line,	"include\variables.c", 100; list_chest_y_pos[8],
 1712                        		.dbg	line,	"include\variables.c", 101; list_chest_x_pos_ref[8],
 1713                        		.dbg	line,	"include\variables.c", 102; list_chest_y_pos_ref[8],
 1714                        		.dbg	line,	"include\variables.c", 105; list_npc_x_pos[9],
 1715                        		.dbg	line,	"include\variables.c", 106; list_npc_y_pos[9],
 1716                        		.dbg	line,	"include\variables.c", 107; list_npc_x_pos_ref[9],
 1717                        		.dbg	line,	"include\variables.c", 108; list_npc_y_pos_ref[9];
 1718                        		.dbg	line,	"include\variables.c", 109; 
 1719                        		.dbg	line,	"include\variables.c", 113; int             zenny_amount,
 1720                        		.dbg	line,	"include\variables.c", 114; score,
 1721                        		.dbg	line,	"include\variables.c", 116; shop_prices[10];
 1722                        		.dbg	line,	"include\variables.c", 121; extern unsigned char tileset_LV1_BG_B[];
 1723                        		.dbg	line,	"include\variables.c", 122; extern unsigned char multimap_LV1_BG_B[];
 1724                        		.dbg	line,	"include\variables.c", 124; extern unsigned char tileset_HUD[];
 1725                        		.dbg	line,	"include\variables.c", 125; extern unsigned char multimap_LV1_BG_A[];
 1726                        		.dbg	line,	"include\variables.c", 127; extern unsigned char tileset_SHOP_BG_B[];
 1727                        		.dbg	line,	"include\variables.c", 131; int *ptr_SHOP_ITEM_PRICES;
 1728                        		.dbg	line,	"main.c", 11; #include "include/gfx_BG.c"
 1729                        		.dbg	line,	"include\gfx_BG.c", 1; #include "huc.h"
 1730                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 1; #ifndef _hucc_legacy_h
 1731                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 2; #define _hucc_legacy_h
 1732                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 4; /****************************************************************************
 1733                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 5; ; ***************************************************************************
 1734                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 6; ;
 1735                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 7; ; huc.h
 1736                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 8; ;
 1737                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 9; ; HuCC wrapper file to include a default set of HuC-compatible functions.
 1738                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 10; ;
 1739                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 11; ; Copyright John Brandwood 2024.
 1740                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 12; ;
 1741                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 13; ; Distributed under the Boost Software License, Version 1.0.
 1742                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 14; ; (See accompanying file LICENSE_1_0.txt or copy at
 1743                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 15; ;  http://www.boost.org/LICENSE_1_0.txt)
 1744                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 16; ;
 1745                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 17; ; ***************************************************************************
 1746                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 18; ; ***************************************************************************
 1747                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 19; ;
 1748                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 20; ; When the HuCC compiler is invoked with the "--legacy" option to compile old
 1749                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 21; ; projects, then this "huc.h" file is automatically included.
 1750                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 22; ;
 1751                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 23; ; This file includes a set of the individual HuCC headers which correspond to
 1752                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 24; ; HuC's built-in functions and MagicKit library.
 1753                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 25; ;
 1754                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 26; ; New HuCC projects should, preferably, include the specific headers that are
 1755                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 27; ; needed, which will then allow them to replace parts of the standard library
 1756                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 28; ; with newer functions, or they can just manually include this "huc.h" file.
 1757                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 29; ;
 1758                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 30; ; ***************************************************************************
 1759                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 31; ; **************************************************************************/
 1760                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 33; #include "hucc-systemcard.h"
 1761                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 34; #include "hucc-baselib.h"
 1762                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 35; #include "hucc-gfx.h"
 1763                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 36; #include "hucc-string.h"
 1764                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 37; #include "hucc-old-scroll.h"
 1765                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 38; #include "hucc-old-spr.h"
 1766                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 39; #include "hucc-old-map.h"
 1767                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 40; #include "hucc-old-line.h"
 1768                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 42; #endif // _hucc_legacy_h
 1769                        		.dbg	line,	"include\gfx_BG.c", 2; #include "hucc-scroll.h"
 1770                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 1; #ifndef _hucc_scroll_h
 1771                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 2; #define _hucc_scroll_h
 1772                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 4; /****************************************************************************
 1773                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 5; ; ***************************************************************************
 1774                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 6; ;
 1775                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 7; ; hucc-scroll.h
 1776                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 8; ;
 1777                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 9; ; Routines for a fast split-screen scrolling system.
 1778                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 10; ;
 1779                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 11; ; Copyright John Brandwood 2024.
 1780                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 12; ;
 1781                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 13; ; Distributed under the Boost Software License, Version 1.0.
 1782                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 14; ; (See accompanying file LICENSE_1_0.txt or copy at
 1783                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 15; ;  http://www.boost.org/LICENSE_1_0.txt)
 1784                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 16; ;
 1785                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 17; ; ***************************************************************************
 1786                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 18; ; ***************************************************************************
 1787                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 19; ;
 1788                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 20; ; The maximum number of splits for each screen layer is set in your project's
 1789                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 21; ; "hucc-config.inc" file, with the library having a limit of 128-per-layer.
 1790                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 22; ;
 1791                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 23; ; Your first active split must be defined to start at screen line 0, and then
 1792                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 24; ; the rest of the active splits must be in increasing line order to match the
 1793                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 25; ; way that the PC Engine displays the output image.
 1794                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 26; ;
 1795                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 27; ; You can have disabled splits interleaved with your active splits.
 1796                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 28; ;
 1797                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 29; ; Splits that are normally disabled can be used to create full screen effects
 1798                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 30; ; such as bouncing the screen up and down by adding blank areas at the top or
 1799                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 31; ; bottom of the screen, and then rapidly changing the height of those areas.
 1800                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 32; ;
 1801                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 33; ; ***************************************************************************
 1802                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 34; ; **************************************************************************/
 1803                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 36; // *************
 1804                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 37; // VDC bits for display_flags ...
 1805                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 38; // *************
 1806                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 40; #ifndef BKG_OFF
 1807                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 41; #define BKG_OFF 0x00
 1808                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 42; #endif
 1809                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 44; #ifndef SPR_OFF
 1810                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 45; #define SPR_OFF 0x00
 1811                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 46; #endif
 1812                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 48; #ifndef BKG_ON
 1813                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 49; #define BKG_ON 0x80
 1814                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 50; #endif
 1815                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 52; #ifndef SPR_ON
 1816                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 53; #define SPR_ON 0x40
 1817                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 54; #endif
 1818                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 56; // *************
 1819                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 57; // Functions in hucc-scroll.asm ...
 1820                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 58; // *************
 1821                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 60; #ifdef __HUCC__
 1822                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 62; #asmdef	HUCC_USES_NEW_SCROLL 1
 1823                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 64; extern void __fastcall scroll_split( unsigned char index<_al>, unsigned char screen_line<_ah>, unsigned int bat_x<_bx>, unsigned int bat_y<_cx>, unsigned char display_flags<_dl> );
 1824                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 65; extern void __fastcall sgx_scroll_split( unsigned char index<_al>, unsigned char screen_line<_ah>, unsigned int bat_x<_bx>, unsigned int bat_y<_cx>, unsigned char display_flags<_dl> );
 1825                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 67; extern void __fastcall disable_split( unsigned char index<acc> );
 1826                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 68; extern void __fastcall sgx_disable_split( unsigned char index<acc> );
 1827                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 70; extern void __fastcall __macro disable_all_splits( void );
 1828                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 71; extern void __fastcall __macro sgx_disable_all_splits( void );
 1829                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 73; #asm
 1830                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 74; .macro	_disable_all_splits
 1831                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 75; ldy	#HUCC_PCE_SPLITS - 1
 1832                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 76; !loop:		tya
 1833                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 77; call	_disable_split.1
 1834                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 78; dey
 1835                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 79; bpl	!loop-
 1836                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 80; .endm
 1837                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 82; .macro	_sgx_disable_all_splits
 1838                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 83; ldy	#HUCC_SGX_SPLITS - 1
 1839                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 84; !loop:		tya
 1840                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 85; call	_sgx_disable_split.1
 1841                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 86; dey
 1842                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 87; bpl	!loop-
 1843                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 88; .endm
 1844                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 89; #endasm
 1845                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 91; #endif // __HUCC__
 1846                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 93; #endif // _hucc_scroll_h
 1847                        		.dbg	line,	"include\gfx_BG.c", 3; #include "hucc-chrmap.h"
 1848                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 1; #ifndef _hucc_chrmap_h
 1849                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 2; #define _hucc_chrmap_h
 1850                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 4; /****************************************************************************
 1851                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 5; ; ***************************************************************************
 1852                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 6; ;
 1853                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 7; ; hucc-chrmap.h
 1854                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 8; ;
 1855                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 9; ; A simple map system based on 8x8 characters (aka "tiles") in BAT format.
 1856                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 10; ;
 1857                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 11; ; Copyright John Brandwood 2025.
 1858                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 12; ;
 1859                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 13; ; Distributed under the Boost Software License, Version 1.0.
 1860                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 14; ; (See accompanying file LICENSE_1_0.txt or copy at
 1861                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 15; ;  http://www.boost.org/LICENSE_1_0.txt)
 1862                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 16; ;
 1863                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 17; ; ***************************************************************************
 1864                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 18; ; ***************************************************************************
 1865                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 19; ;
 1866                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 20; ; The maximum X and Y size for chrmaps is 256 characters (2048 pixels).
 1867                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 21; ;
 1868                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 22; ; The maximum total size for a chrmap is 16KBytes, which allows for maps up
 1869                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 23; ; to 256x32 tiles (2048x256 pixels).
 1870                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 24; ;
 1871                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 25; ; ***************************************************************************
 1872                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 26; ; **************************************************************************/
 1873                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 28; // *************
 1874                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 29; // This code extends the blkmap library ...
 1875                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 30; // *************
 1876                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 32; #include "hucc-blkmap.h"
 1877                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 34; // *************
 1878                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 35; // Functions in chrmap.asm ...
 1879                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 36; // *************
 1880                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 38; #ifdef __HUCC__
 1881                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 40; #asmdef	HUCC_USES_CHRMAP 1
 1882                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 42; extern void __fastcall __nop set_chrmap( unsigned char __far *chrmap<vdc_map_bank:vdc_map_addr>, unsigned char tiles_w<vdc_map_line_w> );
 1883                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 44; extern void __fastcall draw_bat( void );
 1884                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 45; extern void __fastcall scroll_bat( void );
 1885                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 47; extern void __fastcall blit_bat( unsigned char tile_x<map_bat_x>, unsigned char tile_y<map_bat_y>, unsigned char tile_w<map_draw_x>, unsigned char tile_h<map_draw_y> );
 1886                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 49; #ifdef _SGX
 1887                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 51; extern void __fastcall __nop sgx_set_chrmap( unsigned char __far *chrmap<sgx_map_bank:sgx_map_addr>, unsigned char tiles_w<sgx_map_line_w> );
 1888                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 53; extern void __fastcall sgx_draw_bat( void );
 1889                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 54; extern void __fastcall sgx_scroll_bat( void );
 1890                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 56; extern void __fastcall sgx_blit_bat( unsigned char tile_x<map_bat_x>, unsigned char tile_y<map_bat_y>, unsigned char tile_w<map_draw_x>, unsigned char tile_h<map_draw_y> );
 1891                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 58; #endif
 1892                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 60; #endif // __HUCC__
 1893                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 62; #endif // _hucc_chrmap_h
 1894                        		.dbg	line,	"include\gfx_BG.c", 4; #include "hucc-blkmap.h"
 1895                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 1; #ifndef _hucc_blkmap_h
 1896                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 2; #define _hucc_blkmap_h
 1897                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 4; /****************************************************************************
 1898                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 5; ; ***************************************************************************
 1899                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 6; ;
 1900                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 7; ; hucc-blkmap.h
 1901                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 8; ;
 1902                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 9; ; A map system based on 16x16 meta-tiles (aka "blocks", aka CHR/BLK/MAP).
 1903                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 10; ;
 1904                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 11; ; Copyright John Brandwood 2025.
 1905                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 12; ;
 1906                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 13; ; Distributed under the Boost Software License, Version 1.0.
 1907                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 14; ; (See accompanying file LICENSE_1_0.txt or copy at
 1908                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 15; ;  http://www.boost.org/LICENSE_1_0.txt)
 1909                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 16; ;
 1910                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 17; ; ***************************************************************************
 1911                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 18; ; ***************************************************************************
 1912                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 19; ;
 1913                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 20; ; The maximum X and Y size for blkmaps is 128 blocks (2048 pixels).
 1914                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 21; ;
 1915                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 22; ; The maximum total size for a blkmap is 16KBytes, which allows for maps up
 1916                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 23; ; to 128x128 blocks (2048x2048 pixels).
 1917                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 24; ;
 1918                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 25; ; Huge multi-screen blkmaps are also supported (optionally).
 1919                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 26; ;
 1920                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 27; ; The maximum X and Y for multi-screen maps is 128 screens (32768 pixels).
 1921                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 28; ;
 1922                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 29; ; The maximum total size for a multi-screen map is 8KBytes, which allows for
 1923                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 30; ; a total of 1024 screens.
 1924                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 31; ;
 1925                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 32; ; ***************************************************************************
 1926                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 33; ; **************************************************************************/
 1927                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 35; // *************
 1928                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 36; // Functions in blkmap.asm ...
 1929                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 37; // *************
 1930                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 39; #ifdef __HUCC__
 1931                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 41; #asmdef	HUCC_USES_BLKMAP 1
 1932                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 43; // Current top-left of drawn map in pixels.
 1933                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 44; extern unsigned int   vdc_map_pxl_x;
 1934                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 45; extern unsigned int   vdc_map_pxl_y;
 1935                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 47; // Width and height to draw/scroll in characters (not tiles).
 1936                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 48; extern unsigned char  vdc_map_draw_w;
 1937                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 49; extern unsigned char  vdc_map_draw_h;
 1938                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 51; // Width of map (or multi-screen BAT) in tiles.
 1939                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 52; extern unsigned char  vdc_map_line_w;
 1940                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 54; // Width of map in screens (if multi-screen map).
 1941                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 55; extern unsigned char  vdc_map_scrn_w;
 1942                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 57; // Extra information returned by get_map_block() and sgx_get_map_block(),
 1943                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 58; // which are the collision flags and the mask/overlay sprite for the BLK.
 1944                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 59; extern unsigned char  map_blk_flag;
 1945                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 60; extern unsigned char  map_blk_mask;
 1946                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 62; extern unsigned char  vdc_scr_bank;
 1947                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 63; extern unsigned char *vdc_scr_addr;
 1948                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 65; extern unsigned char  vdc_map_bank;
 1949                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 66; extern unsigned char *vdc_map_addr;
 1950                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 68; extern unsigned char  vdc_blk_bank;
 1951                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 69; extern unsigned char *vdc_blk_addr;
 1952                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 71; extern unsigned char  vdc_tbl_bank;
 1953                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 72; extern unsigned char *vdc_tbl_addr;
 1954                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 74; extern void __fastcall set_blocks( unsigned char __far *blk_def<vdc_blk_bank:vdc_blk_addr>, unsigned char __far *flg_def<vdc_tbl_bank:vdc_tbl_addr>, unsigned char number_of_blocks<_al> );
 1955                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 75; extern void __fastcall __macro set_blkmap( unsigned char __far *blk_map<vdc_map_bank:vdc_map_addr>, unsigned char blocks_w<vdc_map_line_w> );
 1956                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 76; extern void __fastcall __macro set_multimap( unsigned char __far *multi_map<vdc_scr_bank:vdc_scr_addr>, unsigned char screens_w<vdc_map_scrn_w> );
 1957                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 78; extern void __fastcall draw_map( void );
 1958                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 79; extern void __fastcall scroll_map( void );
 1959                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 81; extern void __fastcall blit_map( unsigned char tile_x<map_bat_x>, unsigned char tile_y<map_bat_y>, unsigned char tile_w<map_draw_x>, unsigned char tile_h<map_draw_y> );
 1960                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 83; extern unsigned char __fastcall get_map_block( unsigned int x<map_pxl_x>, unsigned int y<map_pxl_y> );
 1961                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 85; #asm
 1962                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 86; .macro	_set_blkmap.2
 1963                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 87; stz	vdc_scr_bank
 1964                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 88; .endm
 1965                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 90; .macro	_set_multimap.2
 1966                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 91; lda	vdc_bat_width
 1967                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 92; lsr	a
 1968                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 93; sta	vdc_map_line_w
 1969                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 94; .endm
 1970                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 96; .macro	SCREEN
 1971                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 97; db	(((\1) & $1FFF) | $6000) >> 8, bank(\1)
 1972                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 98; db	(((\2) & $1FFF) | $4000) >> 8, bank(\2)
 1973                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 99; db	(((\3) & $1FFF) | $6000) >> 8, bank(\3)
 1974                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 100; dw	(\4)
 1975                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 101; .endm
 1976                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 102; #endasm
 1977                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 104; #ifdef _SGX
 1978                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 106; // Current top-left of drawn map in pixels.
 1979                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 107; extern unsigned int   sgx_map_pxl_x;
 1980                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 108; extern unsigned int   sgx_map_pxl_y;
 1981                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 110; // Width and height to draw/scroll in characters (not tiles).
 1982                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 111; extern unsigned char  sgx_map_draw_w;
 1983                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 112; extern unsigned char  sgx_map_draw_h;
 1984                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 114; // Width of map (or multi-screen BAT) in tiles.
 1985                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 115; extern unsigned char  sgx_map_line_w;
 1986                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 117; // Width of map in screens (if multi-screen map).
 1987                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 118; extern unsigned char  sgx_map_scrn_w;
 1988                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 120; extern unsigned char  sgx_scr_bank;
 1989                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 121; extern unsigned char *sgx_scr_addr;
 1990                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 123; extern unsigned char  sgx_map_bank;
 1991                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 124; extern unsigned char *sgx_map_addr;
 1992                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 126; extern unsigned char  sgx_blk_bank;
 1993                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 127; extern unsigned char *sgx_blk_addr;
 1994                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 129; extern unsigned char  sgx_tbl_bank;
 1995                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 130; extern unsigned char *sgx_tbl_addr;
 1996                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 132; extern void __fastcall sgx_set_blocks( unsigned char __far *blk_def<sgx_blk_bank:sgx_blk_addr>, unsigned char __far *flg_def<sgx_tbl_bank:sgx_tbl_addr>, unsigned char number_of_blocks<_al> );
 1997                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 133; extern void __fastcall __macro sgx_set_blkmap( unsigned char __far *blk_map<sgx_map_bank:sgx_map_addr>, unsigned char blocks_w<sgx_map_line_w> );
 1998                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 134; extern void __fastcall __macro sgx_set_multimap( unsigned char __far *multi_map<sgx_scr_bank:sgx_scr_addr>, unsigned char screens_w<sgx_map_scrn_w> );
 1999                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 136; extern void __fastcall sgx_draw_map( void );
 2000                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 137; extern void __fastcall sgx_scroll_map( void );
 2001                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 139; extern void __fastcall sgx_blit_map( unsigned char tile_x<map_bat_x>, unsigned char tile_y<map_bat_y>, unsigned char tile_w<map_draw_x>, unsigned char tile_h<map_draw_y> );
 2002                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 141; extern unsigned char __fastcall sgx_get_map_block( unsigned int x<map_pxl_x>, unsigned int y<map_pxl_y> );
 2003                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 143; #asm
 2004                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 144; .macro	_sgx_set_blkmap.2
 2005                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 145; stz	sgx_scr_bank
 2006                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 146; .endm
 2007                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 148; .macro	_sgx_set_multimap.2
 2008                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 149; lda	sgx_bat_width
 2009                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 150; lsr	a
 2010                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 151; sta	sgx_map_line_w
 2011                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 152; .endm
 2012                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 153; #endasm
 2013                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 155; #endif
 2014                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 157; #endif // __HUCC__
 2015                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 159; #endif // _hucc_blkmap_h
 2016                        		.dbg	line,	"include\gfx_BG.c", 13; #incchr(tileset_FONT,"res/maps/tiles_FONT.png");
 2017               6000     		.data
 2018    03:6000             	_tileset_FONT: 	.incchr		"res/maps/tiles_FONT.png"
 2019               E309     		.code
 2020                        		.dbg	line,	"include\gfx_BG.c", 14; //#incchr(tileset_NUMBERS_FONT,"res/maps/tiles_NUMBERS_FONT.png");
 2021                        		.dbg	line,	"include\gfx_BG.c", 17; //**************************************************************************************//
 2022                        		.dbg	line,	"include\gfx_BG.c", 18; //                                                                                      //
 2023                        		.dbg	line,	"include\gfx_BG.c", 19; //                                       LEVEL 1                                        //
 2024                        		.dbg	line,	"include\gfx_BG.c", 20; //                                                                                      //
 2025                        		.dbg	line,	"include\gfx_BG.c", 21; //**************************************************************************************//
 2026                        		.dbg	line,	"include\gfx_BG.c", 23; #incchr(tileset_LV1_WALL,"res/maps/tiles_LV1_WALL.png", 4 , 4);
 2027               6C00     		.data
 2028    03:6C00             	_tileset_LV1_WALL: 	.incchr		"res/maps/tiles_LV1_WALL.png", 4, 4
 2029               E309     		.code
 2030                        		.dbg	line,	"include\gfx_BG.c", 24; #incchr(tileset_LV1_DOOR_OPEN,"res/maps/tiles_LV1_DOOR_OPEN.png", 4 , 6);
 2031               6E00     		.data
 2032    03:6E00             	_tileset_LV1_DOOR_OPEN: 	.incchr		"res/maps/tiles_LV1_DOOR_OPEN.png", 4, 6
 2033               E309     		.code
 2034                        		.dbg	line,	"include\gfx_BG.c", 25; #incchr(tileset_LV1_DOOR_CLOSED,"res/maps/tiles_LV1_DOOR_CLOSED.png", 4 , 6);
 2035               7100     		.data
 2036    03:7100             	_tileset_LV1_DOOR_CLOSED: 	.incchr		"res/maps/tiles_LV1_DOOR_CLOSED.png", 4, 6
 2037               E309     		.code
 2038                        		.dbg	line,	"include\gfx_BG.c", 27; #incchr(tileset_LIFE_RED,"res/maps/tileset_LIFE_RED.png", 2 , 1);
 2039               7400     		.data
 2040    03:7400             	_tileset_LIFE_RED: 	.incchr		"res/maps/tileset_LIFE_RED.png", 2, 1
 2041               E309     		.code
 2042                        		.dbg	line,	"include\gfx_BG.c", 28; #incchr(tileset_LIFE_ORANGE,"res/maps/tileset_LIFE_ORANGE.png", 2 , 1);
 2043               7440     		.data
 2044    03:7440             	_tileset_LIFE_ORANGE: 	.incchr		"res/maps/tileset_LIFE_ORANGE.png", 2, 1
 2045               E309     		.code
 2046                        		.dbg	line,	"include\gfx_BG.c", 29; #incchr(tileset_LIFE_YELLOW,"res/maps/tileset_LIFE_YELLOW.png", 2 , 1);
 2047               7480     		.data
 2048    03:7480             	_tileset_LIFE_YELLOW: 	.incchr		"res/maps/tileset_LIFE_YELLOW.png", 2, 1
 2049               E309     		.code
 2050                        		.dbg	line,	"include\gfx_BG.c", 30; #incchr(tileset_LIFE_EMPTY,"res/maps/tileset_LIFE_EMPTY.png", 2 , 1);
 2051               74C0     		.data
 2052    03:74C0             	_tileset_LIFE_EMPTY: 	.incchr		"res/maps/tileset_LIFE_EMPTY.png", 2, 1
 2053               E309     		.code
 2054                        		.dbg	line,	"include\gfx_BG.c", 32; #incchr(tileset_ARMOR_1,"res/maps/tileset_ARMOR_1.png", 2 , 2);
 2055               7500     		.data
 2056    03:7500             	_tileset_ARMOR_1: 	.incchr		"res/maps/tileset_ARMOR_1.png", 2, 2
 2057               E309     		.code
 2058                        		.dbg	line,	"include\gfx_BG.c", 33; #incchr(tileset_ARMOR_2,"res/maps/tileset_ARMOR_2.png", 2 , 2);
 2059               7580     		.data
 2060    03:7580             	_tileset_ARMOR_2: 	.incchr		"res/maps/tileset_ARMOR_2.png", 2, 2
 2061               E309     		.code
 2062                        		.dbg	line,	"include\gfx_BG.c", 34; #incchr(tileset_ARMOR_4,"res/maps/tileset_ARMOR_4.png", 2 , 2);
 2063               7600     		.data
 2064    03:7600             	_tileset_ARMOR_4: 	.incchr		"res/maps/tileset_ARMOR_4.png", 2, 2
 2065               E309     		.code
 2066                        		.dbg	line,	"include\gfx_BG.c", 35; #incchr(tileset_ARMOR_8,"res/maps/tileset_ARMOR_8.png", 2 , 2);
 2067               7680     		.data
 2068    03:7680             	_tileset_ARMOR_8: 	.incchr		"res/maps/tileset_ARMOR_8.png", 2, 2
 2069               E309     		.code
 2070                        		.dbg	line,	"include\gfx_BG.c", 37; #incchr(tileset_WEAPON_1,"res/maps/tileset_WEAPON_1.png", 2 , 2);
 2071               7700     		.data
 2072    03:7700             	_tileset_WEAPON_1: 	.incchr		"res/maps/tileset_WEAPON_1.png", 2, 2
 2073               E309     		.code
 2074                        		.dbg	line,	"include\gfx_BG.c", 38; #incchr(tileset_WEAPON_2,"res/maps/tileset_WEAPON_2.png", 2 , 2);
 2075               7780     		.data
 2076    03:7780             	_tileset_WEAPON_2: 	.incchr		"res/maps/tileset_WEAPON_2.png", 2, 2
 2077               E309     		.code
 2078                        		.dbg	line,	"include\gfx_BG.c", 39; #incchr(tileset_WEAPON_4,"res/maps/tileset_WEAPON_4.png", 2 , 2);
 2079               7800     		.data
 2080    03:7800             	_tileset_WEAPON_4: 	.incchr		"res/maps/tileset_WEAPON_4.png", 2, 2
 2081               E309     		.code
 2082                        		.dbg	line,	"include\gfx_BG.c", 40; #incchr(tileset_WEAPON_5,"res/maps/tileset_WEAPON_5.png", 2 , 2);
 2083               7880     		.data
 2084    03:7880             	_tileset_WEAPON_5: 	.incchr		"res/maps/tileset_WEAPON_5.png", 2, 2
 2085               E309     		.code
 2086                        		.dbg	line,	"include\gfx_BG.c", 41; #incchr(tileset_WEAPON_8,"res/maps/tileset_WEAPON_8.png", 2 , 2);
 2087               7900     		.data
 2088    03:7900             	_tileset_WEAPON_8: 	.incchr		"res/maps/tileset_WEAPON_8.png", 2, 2
 2089               E309     		.code
 2090                        		.dbg	line,	"include\gfx_BG.c", 44; //--------------------------------------------------------------------------------------//
 2091                        		.dbg	line,	"include\gfx_BG.c", 45; //                                        VDC 2                                         //
 2092                        		.dbg	line,	"include\gfx_BG.c", 46; //--------------------------------------------------------------------------------------//
 2093                        		.dbg	line,	"include\gfx_BG.c", 48; #asm
 2094                        		.dbg	clear
 2095               0001     	OPTIMIZE	=	1
 2096               7980     			.data
 2097                        	; EXTRACT TILESET
 2098                        	;----------------
 2099    03:7980             	_tileset_LV1_BG_B:  incchr	"res/maps/template_LV1_WALL.png"
 2100    03:7B80             			incchr	"res/maps/template_LV1_DOOR.png"
 2101    03:7E80             			incchr	"res/maps/tilemap_LV1_BG_B.png", OPTIMIZE
 2102                        	; EXTRACT BLOCKS
 2103                        	;--------------
 2104    07:7000             	blocks_LV1_BG_B1:	incblk	"res/maps/tilemap_LV1_BG_B.png" , 0x1000 ,    0 ,   0 ,  64 , 32 , _tileset_LV1_BG_B ; // 96x16 = 1536 | 32x16 =  512
 2105    07:7800             	blocks_LV1_BG_B2:	incblk	"res/maps/tilemap_LV1_BG_B.png" , 0x1000 , 1024 ,   0 ,  96 , 32 , _tileset_LV1_BG_B ; // 64x16 = 1024 | 32x16 =  512
 2106    08:6000             	blocks_LV1_BG_B3:	incblk	"res/maps/tilemap_LV1_BG_B.png" , 0x1000 ,    0 , 512 ,  64 , 32 , _tileset_LV1_BG_B ; // 96x16 = 1536 | 16x16 =  256
 2107    08:6800             	blocks_LV1_BG_B4:	incblk	"res/maps/tilemap_LV1_BG_B.png" , 0x1000 , 1024 , 512 ,  96 , 32 , _tileset_LV1_BG_B ; // 64x16 = 1024 | 16x16 =  256
 2108                        	; EXTRACT MAPS
 2109                        	;------------
 2110               7000     			align	256
 2111    08:7000             	MAP_LV1_BG_B1:		incmap	"res/maps/tilemap_LV1_BG_B.png",    0 ,   0 ,  64 , 32 , blocks_LV1_BG_B1 ; // 96x16 = 1536 | 32x16 =  512
 2112               7800     			align	256
 2113    08:7800             	MAP_LV1_BG_B2:		incmap	"res/maps/tilemap_LV1_BG_B.png", 1024 ,   0 ,  96 , 32 , blocks_LV1_BG_B2 ; // 64x16 = 1024 | 32x16 =  512
 2114               6400     			align	256
 2115    09:6400             	MAP_LV1_BG_B3:		incmap	"res/maps/tilemap_LV1_BG_B.png",    0 , 512 ,  64 , 32 , blocks_LV1_BG_B3 ; // 96x16 = 1536 | 16x16 =  256
 2116               6C00     			align	256
 2117    09:6C00             	MAP_LV1_BG_B4:		incmap	"res/maps/tilemap_LV1_BG_B.png", 1024 , 512 ,  96 , 32 , blocks_LV1_BG_B4 ; // 64x16 = 1024 | 16x16 =  256
 2118                        	; MASK (EMPTY)
 2119                        	;----------------
 2120    09:7800  00 00 00 00	dummy_tbl:	ds	256
         09:7804  00 00 00 00 
         09:7808  00 00 00 00 
         09:780C  00 00 00 00 
         09:7810  00 00 00 00 
         09:7814  00 00 00 00 
         09:7818  00 00 00 00 
         09:781C  00 00 00 00 
         09:7820  00 00 00 00 
         09:7824  00 00 00 00 
         09:7828  00 00 00 00 
         09:782C  00 00 00 00 
         09:7830  00 00 00 00 
         09:7834  00 00 00 00 
         09:7838  00 00 00 00 
         09:783C  00 00 00 00 
         09:7840  00 00 00 00 
         09:7844  00 00 00 00 
         09:7848  00 00 00 00 
         09:784C  00 00 00 00 
         09:7850  00 00 00 00 
         09:7854  00 00 00 00 
         09:7858  00 00 00 00 
         09:785C  00 00 00 00 
         09:7860  00 00 00 00 
         09:7864  00 00 00 00 
         09:7868  00 00 00 00 
         09:786C  00 00 00 00 
         09:7870  00 00 00 00 
         09:7874  00 00 00 00 
         09:7878  00 00 00 00 
         09:787C  00 00 00 00 
         09:7880  00 00 00 00 
         09:7884  00 00 00 00 
         09:7888  00 00 00 00 
         09:788C  00 00 00 00 
         09:7890  00 00 00 00 
         09:7894  00 00 00 00 
         09:7898  00 00 00 00 
         09:789C  00 00 00 00 
         09:78A0  00 00 00 00 
         09:78A4  00 00 00 00 
         09:78A8  00 00 00 00 
         09:78AC  00 00 00 00 
         09:78B0  00 00 00 00 
         09:78B4  00 00 00 00 
         09:78B8  00 00 00 00 
         09:78BC  00 00 00 00 
         09:78C0  00 00 00 00 
         09:78C4  00 00 00 00 
         09:78C8  00 00 00 00 
         09:78CC  00 00 00 00 
         09:78D0  00 00 00 00 
         09:78D4  00 00 00 00 
         09:78D8  00 00 00 00 
         09:78DC  00 00 00 00 
         09:78E0  00 00 00 00 
         09:78E4  00 00 00 00 
         09:78E8  00 00 00 00 
         09:78EC  00 00 00 00 
         09:78F0  00 00 00 00 
         09:78F4  00 00 00 00 
         09:78F8  00 00 00 00 
         09:78FC  00 00 00 00 
 2121                        	; SWIZZLE MAPS
 2122                        	;-------------
 2123    09:7900             	swizzle	MAP_LV1_BG_B1,  32, 16 ;
 2124    09:7900             	swizzle	MAP_LV1_BG_B2,  32, 16 ;
 2125    09:7900             	swizzle	MAP_LV1_BG_B3,  32, 16 ;
 2126    09:7900             	swizzle	MAP_LV1_BG_B4,  32, 16 ;
 2127                        	; BUILD MULTIMAP
 2128                        	;---------------
 2129    09:7900             	_multimap_LV1_BG_B:
 2130                        			; 1st line of 5 screens (512x256)
 2131                        			SCREEN MAP_LV1_BG_B1 + 0x0000, blocks_LV1_BG_B1, dummy_tbl, 0
         09:7900  70 08      			db	(((MAP_LV1_BG_B1 + 0x0000) & $1FFF) | $6000) >> 8, bank(MAP_LV1_BG_B1 + 0x0000)
         09:7902  50 07      			db	(((blocks_LV1_BG_B1) & $1FFF) | $4000) >> 8, bank(blocks_LV1_BG_B1)
         09:7904  78 09      			db	(((dummy_tbl) & $1FFF) | $6000) >> 8, bank(dummy_tbl)
         09:7906  00 00      			dw	(0)
 2132                        			SCREEN MAP_LV1_BG_B1 + 0x0200, blocks_LV1_BG_B1, dummy_tbl, 0
         09:7908  72 08      			db	(((MAP_LV1_BG_B1 + 0x0200) & $1FFF) | $6000) >> 8, bank(MAP_LV1_BG_B1 + 0x0200)
         09:790A  50 07      			db	(((blocks_LV1_BG_B1) & $1FFF) | $4000) >> 8, bank(blocks_LV1_BG_B1)
         09:790C  78 09      			db	(((dummy_tbl) & $1FFF) | $6000) >> 8, bank(dummy_tbl)
         09:790E  00 00      			dw	(0)
 2133                        			SCREEN MAP_LV1_BG_B2 + 0x0000, blocks_LV1_BG_B2, dummy_tbl, 0
         09:7910  78 08      			db	(((MAP_LV1_BG_B2 + 0x0000) & $1FFF) | $6000) >> 8, bank(MAP_LV1_BG_B2 + 0x0000)
         09:7912  58 07      			db	(((blocks_LV1_BG_B2) & $1FFF) | $4000) >> 8, bank(blocks_LV1_BG_B2)
         09:7914  78 09      			db	(((dummy_tbl) & $1FFF) | $6000) >> 8, bank(dummy_tbl)
         09:7916  00 00      			dw	(0)
 2134                        			SCREEN MAP_LV1_BG_B2 + 0x0200, blocks_LV1_BG_B2, dummy_tbl, 0
         09:7918  7A 08      			db	(((MAP_LV1_BG_B2 + 0x0200) & $1FFF) | $6000) >> 8, bank(MAP_LV1_BG_B2 + 0x0200)
         09:791A  58 07      			db	(((blocks_LV1_BG_B2) & $1FFF) | $4000) >> 8, bank(blocks_LV1_BG_B2)
         09:791C  78 09      			db	(((dummy_tbl) & $1FFF) | $6000) >> 8, bank(dummy_tbl)
         09:791E  00 00      			dw	(0)
 2135                        			SCREEN MAP_LV1_BG_B2 + 0x0400, blocks_LV1_BG_B2, dummy_tbl, 0
         09:7920  7C 08      			db	(((MAP_LV1_BG_B2 + 0x0400) & $1FFF) | $6000) >> 8, bank(MAP_LV1_BG_B2 + 0x0400)
         09:7922  58 07      			db	(((blocks_LV1_BG_B2) & $1FFF) | $4000) >> 8, bank(blocks_LV1_BG_B2)
         09:7924  78 09      			db	(((dummy_tbl) & $1FFF) | $6000) >> 8, bank(dummy_tbl)
         09:7926  00 00      			dw	(0)
 2136                        			; 2nd line of 5 screens (512x256)
 2137                        			SCREEN MAP_LV1_BG_B1 + 0x0400, blocks_LV1_BG_B1, dummy_tbl, 0
         09:7928  74 08      			db	(((MAP_LV1_BG_B1 + 0x0400) & $1FFF) | $6000) >> 8, bank(MAP_LV1_BG_B1 + 0x0400)
         09:792A  50 07      			db	(((blocks_LV1_BG_B1) & $1FFF) | $4000) >> 8, bank(blocks_LV1_BG_B1)
         09:792C  78 09      			db	(((dummy_tbl) & $1FFF) | $6000) >> 8, bank(dummy_tbl)
         09:792E  00 00      			dw	(0)
 2138                        			SCREEN MAP_LV1_BG_B1 + 0x0600, blocks_LV1_BG_B1, dummy_tbl, 0
         09:7930  76 08      			db	(((MAP_LV1_BG_B1 + 0x0600) & $1FFF) | $6000) >> 8, bank(MAP_LV1_BG_B1 + 0x0600)
         09:7932  50 07      			db	(((blocks_LV1_BG_B1) & $1FFF) | $4000) >> 8, bank(blocks_LV1_BG_B1)
         09:7934  78 09      			db	(((dummy_tbl) & $1FFF) | $6000) >> 8, bank(dummy_tbl)
         09:7936  00 00      			dw	(0)
 2139                        			SCREEN MAP_LV1_BG_B2 + 0x0600, blocks_LV1_BG_B2, dummy_tbl, 0
         09:7938  7E 08      			db	(((MAP_LV1_BG_B2 + 0x0600) & $1FFF) | $6000) >> 8, bank(MAP_LV1_BG_B2 + 0x0600)
         09:793A  58 07      			db	(((blocks_LV1_BG_B2) & $1FFF) | $4000) >> 8, bank(blocks_LV1_BG_B2)
         09:793C  78 09      			db	(((dummy_tbl) & $1FFF) | $6000) >> 8, bank(dummy_tbl)
         09:793E  00 00      			dw	(0)
 2140                        			SCREEN MAP_LV1_BG_B2 + 0x0800, blocks_LV1_BG_B2, dummy_tbl, 0
         09:7940  60 09      			db	(((MAP_LV1_BG_B2 + 0x0800) & $1FFF) | $6000) >> 8, bank(MAP_LV1_BG_B2 + 0x0800)
         09:7942  58 07      			db	(((blocks_LV1_BG_B2) & $1FFF) | $4000) >> 8, bank(blocks_LV1_BG_B2)
         09:7944  78 09      			db	(((dummy_tbl) & $1FFF) | $6000) >> 8, bank(dummy_tbl)
         09:7946  00 00      			dw	(0)
 2141                        			SCREEN MAP_LV1_BG_B2 + 0x0A00, blocks_LV1_BG_B2, dummy_tbl, 0
         09:7948  62 09      			db	(((MAP_LV1_BG_B2 + 0x0A00) & $1FFF) | $6000) >> 8, bank(MAP_LV1_BG_B2 + 0x0A00)
         09:794A  58 07      			db	(((blocks_LV1_BG_B2) & $1FFF) | $4000) >> 8, bank(blocks_LV1_BG_B2)
         09:794C  78 09      			db	(((dummy_tbl) & $1FFF) | $6000) >> 8, bank(dummy_tbl)
         09:794E  00 00      			dw	(0)
 2142                        			; 3rd line of 5 screens (512x256)
 2143                        			SCREEN MAP_LV1_BG_B3 + 0x0000, blocks_LV1_BG_B3, dummy_tbl, 0
         09:7950  64 09      			db	(((MAP_LV1_BG_B3 + 0x0000) & $1FFF) | $6000) >> 8, bank(MAP_LV1_BG_B3 + 0x0000)
         09:7952  40 08      			db	(((blocks_LV1_BG_B3) & $1FFF) | $4000) >> 8, bank(blocks_LV1_BG_B3)
         09:7954  78 09      			db	(((dummy_tbl) & $1FFF) | $6000) >> 8, bank(dummy_tbl)
         09:7956  00 00      			dw	(0)
 2144                        			SCREEN MAP_LV1_BG_B3 + 0x0200, blocks_LV1_BG_B3, dummy_tbl, 0
         09:7958  66 09      			db	(((MAP_LV1_BG_B3 + 0x0200) & $1FFF) | $6000) >> 8, bank(MAP_LV1_BG_B3 + 0x0200)
         09:795A  40 08      			db	(((blocks_LV1_BG_B3) & $1FFF) | $4000) >> 8, bank(blocks_LV1_BG_B3)
         09:795C  78 09      			db	(((dummy_tbl) & $1FFF) | $6000) >> 8, bank(dummy_tbl)
         09:795E  00 00      			dw	(0)
 2145                        			SCREEN MAP_LV1_BG_B4 + 0x0000, blocks_LV1_BG_B4, dummy_tbl, 0
         09:7960  6C 09      			db	(((MAP_LV1_BG_B4 + 0x0000) & $1FFF) | $6000) >> 8, bank(MAP_LV1_BG_B4 + 0x0000)
         09:7962  48 08      			db	(((blocks_LV1_BG_B4) & $1FFF) | $4000) >> 8, bank(blocks_LV1_BG_B4)
         09:7964  78 09      			db	(((dummy_tbl) & $1FFF) | $6000) >> 8, bank(dummy_tbl)
         09:7966  00 00      			dw	(0)
 2146                        			SCREEN MAP_LV1_BG_B4 + 0x0200, blocks_LV1_BG_B4, dummy_tbl, 0
         09:7968  6E 09      			db	(((MAP_LV1_BG_B4 + 0x0200) & $1FFF) | $6000) >> 8, bank(MAP_LV1_BG_B4 + 0x0200)
         09:796A  48 08      			db	(((blocks_LV1_BG_B4) & $1FFF) | $4000) >> 8, bank(blocks_LV1_BG_B4)
         09:796C  78 09      			db	(((dummy_tbl) & $1FFF) | $6000) >> 8, bank(dummy_tbl)
         09:796E  00 00      			dw	(0)
 2147                        			SCREEN MAP_LV1_BG_B4 + 0x0400, blocks_LV1_BG_B4, dummy_tbl, 0
         09:7970  70 09      			db	(((MAP_LV1_BG_B4 + 0x0400) & $1FFF) | $6000) >> 8, bank(MAP_LV1_BG_B4 + 0x0400)
         09:7972  48 08      			db	(((blocks_LV1_BG_B4) & $1FFF) | $4000) >> 8, bank(blocks_LV1_BG_B4)
         09:7974  78 09      			db	(((dummy_tbl) & $1FFF) | $6000) >> 8, bank(dummy_tbl)
         09:7976  00 00      			dw	(0)
 2148                        			; 4th line of 5 screens (512x256)
 2149                        			SCREEN MAP_LV1_BG_B3 + 0x0400, blocks_LV1_BG_B3, dummy_tbl, 0
         09:7978  68 09      			db	(((MAP_LV1_BG_B3 + 0x0400) & $1FFF) | $6000) >> 8, bank(MAP_LV1_BG_B3 + 0x0400)
         09:797A  40 08      			db	(((blocks_LV1_BG_B3) & $1FFF) | $4000) >> 8, bank(blocks_LV1_BG_B3)
         09:797C  78 09      			db	(((dummy_tbl) & $1FFF) | $6000) >> 8, bank(dummy_tbl)
         09:797E  00 00      			dw	(0)
 2150                        			SCREEN MAP_LV1_BG_B3 + 0x0600, blocks_LV1_BG_B3, dummy_tbl, 0
         09:7980  6A 09      			db	(((MAP_LV1_BG_B3 + 0x0600) & $1FFF) | $6000) >> 8, bank(MAP_LV1_BG_B3 + 0x0600)
         09:7982  40 08      			db	(((blocks_LV1_BG_B3) & $1FFF) | $4000) >> 8, bank(blocks_LV1_BG_B3)
         09:7984  78 09      			db	(((dummy_tbl) & $1FFF) | $6000) >> 8, bank(dummy_tbl)
         09:7986  00 00      			dw	(0)
 2151                        			SCREEN MAP_LV1_BG_B4 + 0x0600, blocks_LV1_BG_B4, dummy_tbl, 0
         09:7988  72 09      			db	(((MAP_LV1_BG_B4 + 0x0600) & $1FFF) | $6000) >> 8, bank(MAP_LV1_BG_B4 + 0x0600)
         09:798A  48 08      			db	(((blocks_LV1_BG_B4) & $1FFF) | $4000) >> 8, bank(blocks_LV1_BG_B4)
         09:798C  78 09      			db	(((dummy_tbl) & $1FFF) | $6000) >> 8, bank(dummy_tbl)
         09:798E  00 00      			dw	(0)
 2152                        			SCREEN MAP_LV1_BG_B4 + 0x0800, blocks_LV1_BG_B4, dummy_tbl, 0
         09:7990  74 09      			db	(((MAP_LV1_BG_B4 + 0x0800) & $1FFF) | $6000) >> 8, bank(MAP_LV1_BG_B4 + 0x0800)
         09:7992  48 08      			db	(((blocks_LV1_BG_B4) & $1FFF) | $4000) >> 8, bank(blocks_LV1_BG_B4)
         09:7994  78 09      			db	(((dummy_tbl) & $1FFF) | $6000) >> 8, bank(dummy_tbl)
         09:7996  00 00      			dw	(0)
 2153                        			SCREEN MAP_LV1_BG_B4 + 0x0A00, blocks_LV1_BG_B4, dummy_tbl, 0
         09:7998  76 09      			db	(((MAP_LV1_BG_B4 + 0x0A00) & $1FFF) | $6000) >> 8, bank(MAP_LV1_BG_B4 + 0x0A00)
         09:799A  48 08      			db	(((blocks_LV1_BG_B4) & $1FFF) | $4000) >> 8, bank(blocks_LV1_BG_B4)
         09:799C  78 09      			db	(((dummy_tbl) & $1FFF) | $6000) >> 8, bank(dummy_tbl)
         09:799E  00 00      			dw	(0)
 2154                        	;//--------------------------------------------------------------------------------------//
 2155                        	;//                                        VDC 1                                         //
 2156                        	;//--------------------------------------------------------------------------------------//
 2157                        	; EXTRACT TILESET
 2158                        	;----------------
 2159    09:79A0             	_tileset_HUD:	incchr	"res/maps/template_LIFEBAR_1.png"
 2160    09:79E0             			incchr	"res/maps/template_LIFEBAR_2.png"
 2161    09:7A20             			incchr	"res/maps/template_LIFEBAR_3.png"
 2162    09:7A60             			incchr	"res/maps/template_LIFEBAR_4.png"
 2163    09:7AA0             			incchr	"res/maps/template_LIFEBAR_5.png"
 2164    09:7AE0             			incchr	"res/maps/tileset_WEAPON_1.png"
 2165    09:7B60             			incchr	"res/maps/tileset_ARMOR_2.png"
 2166    09:7BE0             			incchr	"res/maps/tilemap_HUD.png", OPTIMIZE
 2167                        	; EXTRACT BLOCKS
 2168                        	;--------------
 2169    0A:6000             	blocks_HUD1:	incblk	"res/maps/tilemap_HUD.png" , 0x1000 ,    0 ,   0 , 128 , 64 , _tileset_HUD ; // 128x16 = 2048 | 64x16 = 1024
 2170    0A:6800             	blocks_HUD2:	incblk	"res/maps/tilemap_HUD.png" , 0x1000 , 2048 ,   0 ,  32 , 64 , _tileset_HUD ; //  32x16 =  512 | 64x16 = 1024
 2171                        	; EXTRACT MAPS
 2172                        	;------------
 2173               7000     			align	256
 2174    0A:7000             	MAP_HUD1:		incmap	"res/maps/tilemap_HUD.png",    0 ,   0 , 128 , 64 , blocks_HUD1 ; // 128x16 = 2048 | 64x16 = 1024
 2175    0B:7000             			flagmap "res/maps/collision_LV1.png",       0 ,   0 , 128 , 64 , MAP_HUD1
 2176               7000     			align	256
 2177    0B:7000             	MAP_HUD2:		incmap	"res/maps/tilemap_HUD.png", 2048 ,   0 ,  32 , 64 , blocks_HUD2 ; //  32x16 =  512 | 64x16 = 1024
 2178    0B:7800             			flagmap "res/maps/collision_LV1.png",    2048 ,   0 ,  32 , 64 , MAP_HUD2
 2179                        	; SWIZZLE MAPS
 2180                        	;-------------
 2181    0B:7800             	swizzle	MAP_HUD1,  32, 16 ;
 2182    0B:7800             	swizzle	MAP_HUD2,  32, 16 ;
 2183                        	; BUILD MULTIMAP
 2184                        	;---------------
 2185    0B:7800             	_multimap_LV1_BG_A:
 2186                        			; 1st line of 5 screens (512x256)
 2187                        			SCREEN MAP_HUD1 + 0x0000, blocks_HUD1, dummy_tbl, 0
         0B:7800  70 0A      			db	(((MAP_HUD1 + 0x0000) & $1FFF) | $6000) >> 8, bank(MAP_HUD1 + 0x0000)
         0B:7802  40 0A      			db	(((blocks_HUD1) & $1FFF) | $4000) >> 8, bank(blocks_HUD1)
         0B:7804  78 09      			db	(((dummy_tbl) & $1FFF) | $6000) >> 8, bank(dummy_tbl)
         0B:7806  00 00      			dw	(0)
 2188                        			SCREEN MAP_HUD1 + 0x0200, blocks_HUD1, dummy_tbl, 0
         0B:7808  72 0A      			db	(((MAP_HUD1 + 0x0200) & $1FFF) | $6000) >> 8, bank(MAP_HUD1 + 0x0200)
         0B:780A  40 0A      			db	(((blocks_HUD1) & $1FFF) | $4000) >> 8, bank(blocks_HUD1)
         0B:780C  78 09      			db	(((dummy_tbl) & $1FFF) | $6000) >> 8, bank(dummy_tbl)
         0B:780E  00 00      			dw	(0)
 2189                        			SCREEN MAP_HUD1 + 0x0400, blocks_HUD1, dummy_tbl, 0
         0B:7810  74 0A      			db	(((MAP_HUD1 + 0x0400) & $1FFF) | $6000) >> 8, bank(MAP_HUD1 + 0x0400)
         0B:7812  40 0A      			db	(((blocks_HUD1) & $1FFF) | $4000) >> 8, bank(blocks_HUD1)
         0B:7814  78 09      			db	(((dummy_tbl) & $1FFF) | $6000) >> 8, bank(dummy_tbl)
         0B:7816  00 00      			dw	(0)
 2190                        			SCREEN MAP_HUD1 + 0x0600, blocks_HUD1, dummy_tbl, 0
         0B:7818  76 0A      			db	(((MAP_HUD1 + 0x0600) & $1FFF) | $6000) >> 8, bank(MAP_HUD1 + 0x0600)
         0B:781A  40 0A      			db	(((blocks_HUD1) & $1FFF) | $4000) >> 8, bank(blocks_HUD1)
         0B:781C  78 09      			db	(((dummy_tbl) & $1FFF) | $6000) >> 8, bank(dummy_tbl)
         0B:781E  00 00      			dw	(0)
 2191                        			SCREEN MAP_HUD2 + 0x0000, blocks_HUD2, dummy_tbl, 0
         0B:7820  70 0B      			db	(((MAP_HUD2 + 0x0000) & $1FFF) | $6000) >> 8, bank(MAP_HUD2 + 0x0000)
         0B:7822  48 0A      			db	(((blocks_HUD2) & $1FFF) | $4000) >> 8, bank(blocks_HUD2)
         0B:7824  78 09      			db	(((dummy_tbl) & $1FFF) | $6000) >> 8, bank(dummy_tbl)
         0B:7826  00 00      			dw	(0)
 2192                        			; 2nd line of 5 screens (512x256)
 2193                        			SCREEN MAP_HUD1 + 0x0800, blocks_HUD1, dummy_tbl, 0
         0B:7828  78 0A      			db	(((MAP_HUD1 + 0x0800) & $1FFF) | $6000) >> 8, bank(MAP_HUD1 + 0x0800)
         0B:782A  40 0A      			db	(((blocks_HUD1) & $1FFF) | $4000) >> 8, bank(blocks_HUD1)
         0B:782C  78 09      			db	(((dummy_tbl) & $1FFF) | $6000) >> 8, bank(dummy_tbl)
         0B:782E  00 00      			dw	(0)
 2194                        			SCREEN MAP_HUD1 + 0x0A00, blocks_HUD1, dummy_tbl, 0
         0B:7830  7A 0A      			db	(((MAP_HUD1 + 0x0A00) & $1FFF) | $6000) >> 8, bank(MAP_HUD1 + 0x0A00)
         0B:7832  40 0A      			db	(((blocks_HUD1) & $1FFF) | $4000) >> 8, bank(blocks_HUD1)
         0B:7834  78 09      			db	(((dummy_tbl) & $1FFF) | $6000) >> 8, bank(dummy_tbl)
         0B:7836  00 00      			dw	(0)
 2195                        			SCREEN MAP_HUD1 + 0x0C00, blocks_HUD1, dummy_tbl, 0
         0B:7838  7C 0A      			db	(((MAP_HUD1 + 0x0C00) & $1FFF) | $6000) >> 8, bank(MAP_HUD1 + 0x0C00)
         0B:783A  40 0A      			db	(((blocks_HUD1) & $1FFF) | $4000) >> 8, bank(blocks_HUD1)
         0B:783C  78 09      			db	(((dummy_tbl) & $1FFF) | $6000) >> 8, bank(dummy_tbl)
         0B:783E  00 00      			dw	(0)
 2196                        			SCREEN MAP_HUD1 + 0x0E00, blocks_HUD1, dummy_tbl, 0
         0B:7840  7E 0A      			db	(((MAP_HUD1 + 0x0E00) & $1FFF) | $6000) >> 8, bank(MAP_HUD1 + 0x0E00)
         0B:7842  40 0A      			db	(((blocks_HUD1) & $1FFF) | $4000) >> 8, bank(blocks_HUD1)
         0B:7844  78 09      			db	(((dummy_tbl) & $1FFF) | $6000) >> 8, bank(dummy_tbl)
         0B:7846  00 00      			dw	(0)
 2197                        			SCREEN MAP_HUD2 + 0x0200, blocks_HUD2, dummy_tbl, 0
         0B:7848  72 0B      			db	(((MAP_HUD2 + 0x0200) & $1FFF) | $6000) >> 8, bank(MAP_HUD2 + 0x0200)
         0B:784A  48 0A      			db	(((blocks_HUD2) & $1FFF) | $4000) >> 8, bank(blocks_HUD2)
         0B:784C  78 09      			db	(((dummy_tbl) & $1FFF) | $6000) >> 8, bank(dummy_tbl)
         0B:784E  00 00      			dw	(0)
 2198                        			; 3rd line of 5 screens (512x256)
 2199                        			SCREEN MAP_HUD1 + 0x1000, blocks_HUD1, dummy_tbl, 0
         0B:7850  60 0B      			db	(((MAP_HUD1 + 0x1000) & $1FFF) | $6000) >> 8, bank(MAP_HUD1 + 0x1000)
         0B:7852  40 0A      			db	(((blocks_HUD1) & $1FFF) | $4000) >> 8, bank(blocks_HUD1)
         0B:7854  78 09      			db	(((dummy_tbl) & $1FFF) | $6000) >> 8, bank(dummy_tbl)
         0B:7856  00 00      			dw	(0)
 2200                        			SCREEN MAP_HUD1 + 0x1200, blocks_HUD1, dummy_tbl, 0
         0B:7858  62 0B      			db	(((MAP_HUD1 + 0x1200) & $1FFF) | $6000) >> 8, bank(MAP_HUD1 + 0x1200)
         0B:785A  40 0A      			db	(((blocks_HUD1) & $1FFF) | $4000) >> 8, bank(blocks_HUD1)
         0B:785C  78 09      			db	(((dummy_tbl) & $1FFF) | $6000) >> 8, bank(dummy_tbl)
         0B:785E  00 00      			dw	(0)
 2201                        			SCREEN MAP_HUD1 + 0x1400, blocks_HUD1, dummy_tbl, 0
         0B:7860  64 0B      			db	(((MAP_HUD1 + 0x1400) & $1FFF) | $6000) >> 8, bank(MAP_HUD1 + 0x1400)
         0B:7862  40 0A      			db	(((blocks_HUD1) & $1FFF) | $4000) >> 8, bank(blocks_HUD1)
         0B:7864  78 09      			db	(((dummy_tbl) & $1FFF) | $6000) >> 8, bank(dummy_tbl)
         0B:7866  00 00      			dw	(0)
 2202                        			SCREEN MAP_HUD1 + 0x1600, blocks_HUD1, dummy_tbl, 0
         0B:7868  66 0B      			db	(((MAP_HUD1 + 0x1600) & $1FFF) | $6000) >> 8, bank(MAP_HUD1 + 0x1600)
         0B:786A  40 0A      			db	(((blocks_HUD1) & $1FFF) | $4000) >> 8, bank(blocks_HUD1)
         0B:786C  78 09      			db	(((dummy_tbl) & $1FFF) | $6000) >> 8, bank(dummy_tbl)
         0B:786E  00 00      			dw	(0)
 2203                        			SCREEN MAP_HUD2 + 0x0400, blocks_HUD2, dummy_tbl, 0
         0B:7870  74 0B      			db	(((MAP_HUD2 + 0x0400) & $1FFF) | $6000) >> 8, bank(MAP_HUD2 + 0x0400)
         0B:7872  48 0A      			db	(((blocks_HUD2) & $1FFF) | $4000) >> 8, bank(blocks_HUD2)
         0B:7874  78 09      			db	(((dummy_tbl) & $1FFF) | $6000) >> 8, bank(dummy_tbl)
         0B:7876  00 00      			dw	(0)
 2204                        			; 4th line of 5 screens (512x256)
 2205                        			SCREEN MAP_HUD1 + 0x1800, blocks_HUD1, dummy_tbl, 0
         0B:7878  68 0B      			db	(((MAP_HUD1 + 0x1800) & $1FFF) | $6000) >> 8, bank(MAP_HUD1 + 0x1800)
         0B:787A  40 0A      			db	(((blocks_HUD1) & $1FFF) | $4000) >> 8, bank(blocks_HUD1)
         0B:787C  78 09      			db	(((dummy_tbl) & $1FFF) | $6000) >> 8, bank(dummy_tbl)
         0B:787E  00 00      			dw	(0)
 2206                        			SCREEN MAP_HUD1 + 0x1A00, blocks_HUD1, dummy_tbl, 0
         0B:7880  6A 0B      			db	(((MAP_HUD1 + 0x1A00) & $1FFF) | $6000) >> 8, bank(MAP_HUD1 + 0x1A00)
         0B:7882  40 0A      			db	(((blocks_HUD1) & $1FFF) | $4000) >> 8, bank(blocks_HUD1)
         0B:7884  78 09      			db	(((dummy_tbl) & $1FFF) | $6000) >> 8, bank(dummy_tbl)
         0B:7886  00 00      			dw	(0)
 2207                        			SCREEN MAP_HUD1 + 0x1C00, blocks_HUD1, dummy_tbl, 0
         0B:7888  6C 0B      			db	(((MAP_HUD1 + 0x1C00) & $1FFF) | $6000) >> 8, bank(MAP_HUD1 + 0x1C00)
         0B:788A  40 0A      			db	(((blocks_HUD1) & $1FFF) | $4000) >> 8, bank(blocks_HUD1)
         0B:788C  78 09      			db	(((dummy_tbl) & $1FFF) | $6000) >> 8, bank(dummy_tbl)
         0B:788E  00 00      			dw	(0)
 2208                        			SCREEN MAP_HUD1 + 0x1E00, blocks_HUD1, dummy_tbl, 0
         0B:7890  6E 0B      			db	(((MAP_HUD1 + 0x1E00) & $1FFF) | $6000) >> 8, bank(MAP_HUD1 + 0x1E00)
         0B:7892  40 0A      			db	(((blocks_HUD1) & $1FFF) | $4000) >> 8, bank(blocks_HUD1)
         0B:7894  78 09      			db	(((dummy_tbl) & $1FFF) | $6000) >> 8, bank(dummy_tbl)
         0B:7896  00 00      			dw	(0)
 2209                        			SCREEN MAP_HUD2 + 0x0600, blocks_HUD2, dummy_tbl, 0
         0B:7898  76 0B      			db	(((MAP_HUD2 + 0x0600) & $1FFF) | $6000) >> 8, bank(MAP_HUD2 + 0x0600)
         0B:789A  48 0A      			db	(((blocks_HUD2) & $1FFF) | $4000) >> 8, bank(blocks_HUD2)
         0B:789C  78 09      			db	(((dummy_tbl) & $1FFF) | $6000) >> 8, bank(dummy_tbl)
         0B:789E  00 00      			dw	(0)
 2210               E309     			.code
 2211                        	
 2212                        		.dbg	line,	"include\gfx_BG.c", 208; #endasm
 2213                        		.dbg	line,	"include\gfx_BG.c", 212; //--------------------------------------------------------------------------------------//
 2214                        		.dbg	line,	"include\gfx_BG.c", 213; //                                   EXTRACT PALETTES                                   //
 2215                        		.dbg	line,	"include\gfx_BG.c", 214; //--------------------------------------------------------------------------------------//
 2216                        		.dbg	line,	"include\gfx_BG.c", 216; #incpal(palette_LV1,"res/maps/tilemap_LV1_BG_B.png");
 2217               78A0     		.data
 2218    0B:78A0             	_palette_LV1:	.incpal		"res/maps/tilemap_LV1_BG_B.png"
 2219               E309     		.code
 2220                        		.dbg	line,	"include\gfx_BG.c", 225; //**************************************************************************************//
 2221                        		.dbg	line,	"include\gfx_BG.c", 226; //                                                                                      //
 2222                        		.dbg	line,	"include\gfx_BG.c", 227; //                                         SHOP                                         //
 2223                        		.dbg	line,	"include\gfx_BG.c", 228; //                                                                                      //
 2224                        		.dbg	line,	"include\gfx_BG.c", 229; //**************************************************************************************//
 2225                        		.dbg	line,	"include\gfx_BG.c", 231; #asm
 2226                        		.dbg	clear
 2227               0001     	OPTIMIZE	=	1
 2228               7AA0     			.data
 2229                        	;//--------------------------------------------------------------------------------------//
 2230                        	;//                                        VDC 1                                         //
 2231                        	;//--------------------------------------------------------------------------------------//
 2232                        	; EXTRACT TILESET
 2233                        	;----------------
 2234    0B:7AA0             	_tileset_SHOP_BG_B:		incchr	"res/maps/template_ITEM_1.png"
 2235    0B:7B20             			incchr	"res/maps/template_ITEM_2.png"
 2236    0B:7BA0             			incchr	"res/maps/template_ITEM_3.png"
 2237    0B:7C20             			incchr	"res/maps/template_ITEM_4.png"
 2238    0B:7CA0             			incchr	"res/maps/template_ITEM_5.png"
 2239    0B:7D20             			incchr	"res/maps/template_ITEM_6.png"
 2240    0B:7DA0             			incchr	"res/maps/template_ITEM_7.png"
 2241    0B:7E20             			incchr	"res/maps/template_ITEM_8.png"
 2242    0B:7EA0             			incchr	"res/maps/template_ITEM_9.png"
 2243    0B:7F20             			incchr	"res/maps/template_ITEM_10.png"
 2244    0B:7FA0             			incchr	"res/maps/tilemap_SHOP_BG_B.png", OPTIMIZE
 2245               E309     			.code
 2246                        	
 2247                        		.dbg	line,	"include\gfx_BG.c", 255; #endasm
 2248                        		.dbg	line,	"include\gfx_BG.c", 258; // EXTRACT BLOCKS //
 2249                        		.dbg	line,	"include\gfx_BG.c", 259; #incblk(blocks_SHOP_BG_B, "res/maps/tilemap_SHOP_BG_B.png", 0x1000, tileset_SHOP_BG_B);
 2250               7400     		.data
 2251    0D:7800             	_blocks_SHOP_BG_B:	.incblk		"res/maps/tilemap_SHOP_BG_B.png", 4096, _tileset_SHOP_BG_B
 2252               E309     		.code
 2253                        		.dbg	line,	"include\gfx_BG.c", 261; // EXTRACT MAP //
 2254                        		.dbg	line,	"include\gfx_BG.c", 262; #incmap(map_SHOP_BG_B, "res/maps/tilemap_SHOP_BG_B.png", blocks_SHOP_BG_B);
 2255               8000     		.data
 2256    0E:6000             	_map_SHOP_BG_B:	.incmap		"res/maps/tilemap_SHOP_BG_B.png", _blocks_SHOP_BG_B
 2257               E309     		.code
 2258                        		.dbg	line,	"include\gfx_BG.c", 265; //--------------------------------------------------------------------------------------//
 2259                        		.dbg	line,	"include\gfx_BG.c", 266; //                                        ITEMS                                         //
 2260                        		.dbg	line,	"include\gfx_BG.c", 267; //--------------------------------------------------------------------------------------//
 2261                        		.dbg	line,	"include\gfx_BG.c", 269; #incchr(tiles_ITEM_WEAPON_2,"res/maps/tiles_ITEM_WEAPON_2.png", 2 , 2);
 2262               60E0     		.data
 2263    0E:60E0             	_tiles_ITEM_WEAPON_2: 	.incchr		"res/maps/tiles_ITEM_WEAPON_2.png", 2, 2
 2264               E309     		.code
 2265                        		.dbg	line,	"include\gfx_BG.c", 270; #incchr(tiles_ITEM_WEAPON_3,"res/maps/tiles_ITEM_WEAPON_3.png", 2 , 2);
 2266               6160     		.data
 2267    0E:6160             	_tiles_ITEM_WEAPON_3: 	.incchr		"res/maps/tiles_ITEM_WEAPON_3.png", 2, 2
 2268               E309     		.code
 2269                        		.dbg	line,	"include\gfx_BG.c", 271; #incchr(tiles_ITEM_WEAPON_4,"res/maps/tiles_ITEM_WEAPON_4.png", 2 , 2);
 2270               61E0     		.data
 2271    0E:61E0             	_tiles_ITEM_WEAPON_4: 	.incchr		"res/maps/tiles_ITEM_WEAPON_4.png", 2, 2
 2272               E309     		.code
 2273                        		.dbg	line,	"include\gfx_BG.c", 272; #incchr(tiles_ITEM_WEAPON_5,"res/maps/tiles_ITEM_WEAPON_5.png", 2 , 2);
 2274               6260     		.data
 2275    0E:6260             	_tiles_ITEM_WEAPON_5: 	.incchr		"res/maps/tiles_ITEM_WEAPON_5.png", 2, 2
 2276               E309     		.code
 2277                        		.dbg	line,	"include\gfx_BG.c", 273; #incchr(tiles_ITEM_KEY,"res/maps/tiles_ITEM_KEY.png", 2 , 2);
 2278               62E0     		.data
 2279    0E:62E0             	_tiles_ITEM_KEY: 	.incchr		"res/maps/tiles_ITEM_KEY.png", 2, 2
 2280               E309     		.code
 2281                        		.dbg	line,	"include\gfx_BG.c", 274; #incchr(tiles_ITEM_ARMOR_2,"res/maps/tiles_ITEM_ARMOR_2.png", 2 , 2);
 2282               6360     		.data
 2283    0E:6360             	_tiles_ITEM_ARMOR_2: 	.incchr		"res/maps/tiles_ITEM_ARMOR_2.png", 2, 2
 2284               E309     		.code
 2285                        		.dbg	line,	"include\gfx_BG.c", 275; #incchr(tiles_ITEM_ARMOR_3,"res/maps/tiles_ITEM_ARMOR_3.png", 2 , 2);
 2286               63E0     		.data
 2287    0E:63E0             	_tiles_ITEM_ARMOR_3: 	.incchr		"res/maps/tiles_ITEM_ARMOR_3.png", 2, 2
 2288               E309     		.code
 2289                        		.dbg	line,	"include\gfx_BG.c", 276; #incchr(tiles_ITEM_ARMOR_4,"res/maps/tiles_ITEM_ARMOR_4.png", 2 , 2);
 2290               6460     		.data
 2291    0E:6460             	_tiles_ITEM_ARMOR_4: 	.incchr		"res/maps/tiles_ITEM_ARMOR_4.png", 2, 2
 2292               E309     		.code
 2293                        		.dbg	line,	"include\gfx_BG.c", 277; #incchr(tiles_ITEM_ARMOR_5,"res/maps/tiles_ITEM_ARMOR_5.png", 2 , 2);
 2294               64E0     		.data
 2295    0E:64E0             	_tiles_ITEM_ARMOR_5: 	.incchr		"res/maps/tiles_ITEM_ARMOR_5.png", 2, 2
 2296               E309     		.code
 2297                        		.dbg	line,	"include\gfx_BG.c", 278; #incchr(tiles_ITEM_POTION,"res/maps/tiles_ITEM_POTION.png", 2 , 2);
 2298               6560     		.data
 2299    0E:6560             	_tiles_ITEM_POTION: 	.incchr		"res/maps/tiles_ITEM_POTION.png", 2, 2
 2300               E309     		.code
 2301                        		.dbg	line,	"include\gfx_BG.c", 280; //#incchr(tileset_NUMBERS_SHOP_FONT,"res/maps/tiles_NUMBERS_SHOP_FONT.png");
 2302                        		.dbg	line,	"include\gfx_BG.c", 283; //--------------------------------------------------------------------------------------//
 2303                        		.dbg	line,	"include\gfx_BG.c", 284; //                                   EXTRACT PALETTES                                   //
 2304                        		.dbg	line,	"include\gfx_BG.c", 285; //--------------------------------------------------------------------------------------//
 2305                        		.dbg	line,	"include\gfx_BG.c", 287; #incpal(palette_SHOP,"res/maps/tilemap_SHOP_BG_B.png");
 2306               65E0     		.data
 2307    0E:65E0             	_palette_SHOP:	.incpal		"res/maps/tilemap_SHOP_BG_B.png"
 2308               E309     		.code
 2309                        		.dbg	line,	"include\gfx_BG.c", 288; #incpal(palette_SHOP_ITEMS,"res/palettes/palette_SHOP_ITEMS.png");
 2310               67E0     		.data
 2311    0E:67E0             	_palette_SHOP_ITEMS:	.incpal		"res/palettes/palette_SHOP_ITEMS.png"
 2312               E309     		.code
 2313                        		.dbg	line,	"main.c", 12; #include "include/gfx_SPRITES.c"
 2314                        		.dbg	line,	"include\gfx_SPRITES.c", 1; #include "huc.h"
 2315                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 1; #ifndef _hucc_legacy_h
 2316                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 2; #define _hucc_legacy_h
 2317                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 4; /****************************************************************************
 2318                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 5; ; ***************************************************************************
 2319                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 6; ;
 2320                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 7; ; huc.h
 2321                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 8; ;
 2322                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 9; ; HuCC wrapper file to include a default set of HuC-compatible functions.
 2323                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 10; ;
 2324                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 11; ; Copyright John Brandwood 2024.
 2325                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 12; ;
 2326                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 13; ; Distributed under the Boost Software License, Version 1.0.
 2327                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 14; ; (See accompanying file LICENSE_1_0.txt or copy at
 2328                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 15; ;  http://www.boost.org/LICENSE_1_0.txt)
 2329                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 16; ;
 2330                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 17; ; ***************************************************************************
 2331                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 18; ; ***************************************************************************
 2332                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 19; ;
 2333                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 20; ; When the HuCC compiler is invoked with the "--legacy" option to compile old
 2334                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 21; ; projects, then this "huc.h" file is automatically included.
 2335                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 22; ;
 2336                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 23; ; This file includes a set of the individual HuCC headers which correspond to
 2337                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 24; ; HuC's built-in functions and MagicKit library.
 2338                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 25; ;
 2339                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 26; ; New HuCC projects should, preferably, include the specific headers that are
 2340                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 27; ; needed, which will then allow them to replace parts of the standard library
 2341                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 28; ; with newer functions, or they can just manually include this "huc.h" file.
 2342                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 29; ;
 2343                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 30; ; ***************************************************************************
 2344                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 31; ; **************************************************************************/
 2345                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 33; #include "hucc-systemcard.h"
 2346                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 34; #include "hucc-baselib.h"
 2347                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 35; #include "hucc-gfx.h"
 2348                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 36; #include "hucc-string.h"
 2349                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 37; #include "hucc-old-scroll.h"
 2350                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 38; #include "hucc-old-spr.h"
 2351                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 39; #include "hucc-old-map.h"
 2352                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 40; #include "hucc-old-line.h"
 2353                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 42; #endif // _hucc_legacy_h
 2354                        		.dbg	line,	"include\gfx_SPRITES.c", 10; // EXTRACT PLAYER TILES //
 2355                        		.dbg	line,	"include\gfx_SPRITES.c", 11; #incspr(tiles_SPR_PLAYER,"res/sprites/tiles_SPR_PLAYER.png")
 2356               69E0     		.data
 2357    0E:69E0             	_tiles_SPR_PLAYER:	.incspr		"res/sprites/tiles_SPR_PLAYER.png"
 2358               E309     		.code
 2359                        		.dbg	line,	"include\gfx_SPRITES.c", 13; // EXTRACT PLAYER PALETTE //
 2360                        		.dbg	line,	"include\gfx_SPRITES.c", 14; #incpal(palette_PLAYER,"res/palettes/palette_PLAYER.png");
 2361               69E0     		.data
 2362    0F:69E0             	_palette_PLAYER:	.incpal		"res/palettes/palette_PLAYER.png"
 2363               E309     		.code
 2364                        		.dbg	line,	"include\gfx_SPRITES.c", 17; #incspr(tiles_SPR_HIT,"res/sprites/tiles_SPR_HIT.png")
 2365               6BE0     		.data
 2366    0F:6BE0             	_tiles_SPR_HIT:	.incspr		"res/sprites/tiles_SPR_HIT.png"
 2367               E309     		.code
 2368                        		.dbg	line,	"include\gfx_SPRITES.c", 20; // EXTRACT OBJECTS TILES //
 2369                        		.dbg	line,	"include\gfx_SPRITES.c", 21; #incspr(tiles_SPR_BARREL,"res/sprites/tiles_SPR_BARREL.png")
 2370               6C60     		.data
 2371    0F:6C60             	_tiles_SPR_BARREL:	.incspr		"res/sprites/tiles_SPR_BARREL.png"
 2372               E309     		.code
 2373                        		.dbg	line,	"include\gfx_SPRITES.c", 22; #incspr(tiles_SPR_CHEST,"res/sprites/tiles_SPR_CHEST.png")
 2374               6CE0     		.data
 2375    0F:6CE0             	_tiles_SPR_CHEST:	.incspr		"res/sprites/tiles_SPR_CHEST.png"
 2376               E309     		.code
 2377                        		.dbg	line,	"include\gfx_SPRITES.c", 23; #incspr(tiles_SPR_COIN_1,"res/sprites/tiles_SPR_COIN_1.png")
 2378               78E0     		.data
 2379    0F:78E0             	_tiles_SPR_COIN_1:	.incspr		"res/sprites/tiles_SPR_COIN_1.png"
 2380               E309     		.code
 2381                        		.dbg	line,	"include\gfx_SPRITES.c", 24; #incspr(tiles_SPR_COIN_5,"res/sprites/tiles_SPR_COIN_5.png")
 2382               7960     		.data
 2383    0F:7960             	_tiles_SPR_COIN_5:	.incspr		"res/sprites/tiles_SPR_COIN_5.png"
 2384               E309     		.code
 2385                        		.dbg	line,	"include\gfx_SPRITES.c", 25; #incspr(tiles_SPR_COIN_10,"res/sprites/tiles_SPR_COIN_10.png")
 2386               79E0     		.data
 2387    0F:79E0             	_tiles_SPR_COIN_10:	.incspr		"res/sprites/tiles_SPR_COIN_10.png"
 2388               E309     		.code
 2389                        		.dbg	line,	"include\gfx_SPRITES.c", 26; #incspr(tiles_SPR_COIN_50,"res/sprites/tiles_SPR_COIN_50.png")
 2390               7A60     		.data
 2391    0F:7A60             	_tiles_SPR_COIN_50:	.incspr		"res/sprites/tiles_SPR_COIN_50.png"
 2392               E309     		.code
 2393                        		.dbg	line,	"include\gfx_SPRITES.c", 27; #incspr(tiles_SPR_COIN_100,"res/sprites/tiles_SPR_COIN_100.png")
 2394               7AE0     		.data
 2395    0F:7AE0             	_tiles_SPR_COIN_100:	.incspr		"res/sprites/tiles_SPR_COIN_100.png"
 2396               E309     		.code
 2397                        		.dbg	line,	"include\gfx_SPRITES.c", 28; #incspr(tiles_SPR_COIN_500,"res/sprites/tiles_SPR_COIN_500.png")
 2398               7B60     		.data
 2399    0F:7B60             	_tiles_SPR_COIN_500:	.incspr		"res/sprites/tiles_SPR_COIN_500.png"
 2400               E309     		.code
 2401                        		.dbg	line,	"include\gfx_SPRITES.c", 29; #incspr(tiles_SPR_COIN_1000,"res/sprites/tiles_SPR_COIN_1000.png")
 2402               7BE0     		.data
 2403    0F:7BE0             	_tiles_SPR_COIN_1000:	.incspr		"res/sprites/tiles_SPR_COIN_1000.png"
 2404               E309     		.code
 2405                        		.dbg	line,	"include\gfx_SPRITES.c", 30; #incspr(tiles_SPR_FRUIT,"res/sprites/tiles_SPR_FRUIT.png")
 2406               7C60     		.data
 2407    0F:7C60             	_tiles_SPR_FRUIT:	.incspr		"res/sprites/tiles_SPR_FRUIT.png"
 2408               E309     		.code
 2409                        		.dbg	line,	"include\gfx_SPRITES.c", 31; #incspr(tiles_SPR_GRAY_KEY,"res/sprites/tiles_SPR_GRAY_KEY.png")
 2410               7CE0     		.data
 2411    0F:7CE0             	_tiles_SPR_GRAY_KEY:	.incspr		"res/sprites/tiles_SPR_GRAY_KEY.png"
 2412               E309     		.code
 2413                        		.dbg	line,	"include\gfx_SPRITES.c", 32; #incspr(tiles_SPR_GOLD_KEY,"res/sprites/tiles_SPR_GOLD_KEY.png")
 2414               7D60     		.data
 2415    0F:7D60             	_tiles_SPR_GOLD_KEY:	.incspr		"res/sprites/tiles_SPR_GOLD_KEY.png"
 2416               E309     		.code
 2417                        		.dbg	line,	"include\gfx_SPRITES.c", 33; #incspr(tiles_SPR_HOURGLASS,"res/sprites/tiles_SPR_HOURGLASS.png")
 2418               7DE0     		.data
 2419    0F:7DE0             	_tiles_SPR_HOURGLASS:	.incspr		"res/sprites/tiles_SPR_HOURGLASS.png"
 2420               E309     		.code
 2421                        		.dbg	line,	"include\gfx_SPRITES.c", 34; #incspr(tiles_SPR_LIFE,"res/sprites/tiles_SPR_LIFE.png")
 2422               7E60     		.data
 2423    0F:7E60             	_tiles_SPR_LIFE:	.incspr		"res/sprites/tiles_SPR_LIFE.png"
 2424               E309     		.code
 2425                        		.dbg	line,	"include\gfx_SPRITES.c", 35; #incspr(tiles_SPR_OCTOPUS,"res/sprites/tiles_SPR_OCTOPUS.png")
 2426               7EE0     		.data
 2427    0F:7EE0             	_tiles_SPR_OCTOPUS:	.incspr		"res/sprites/tiles_SPR_OCTOPUS.png"
 2428               E309     		.code
 2429                        		.dbg	line,	"include\gfx_SPRITES.c", 36; #incspr(tiles_SPR_POT,"res/sprites/tiles_SPR_POT.png")
 2430               7F60     		.data
 2431    0F:7F60             	_tiles_SPR_POT:	.incspr		"res/sprites/tiles_SPR_POT.png"
 2432               E309     		.code
 2433                        		.dbg	line,	"include\gfx_SPRITES.c", 37; #incspr(tiles_SPR_POW,"res/sprites/tiles_SPR_POW.png")
 2434               6360     		.data
 2435    10:6360             	_tiles_SPR_POW:	.incspr		"res/sprites/tiles_SPR_POW.png"
 2436               E309     		.code
 2437                        		.dbg	line,	"include\gfx_SPRITES.c", 38; #incspr(tiles_SPR_STAR,"res/sprites/tiles_SPR_STAR.png")
 2438               63E0     		.data
 2439    10:63E0             	_tiles_SPR_STAR:	.incspr		"res/sprites/tiles_SPR_STAR.png"
 2440               E309     		.code
 2441                        		.dbg	line,	"include\gfx_SPRITES.c", 39; #incspr(tiles_SPR_BAMBOO,"res/sprites/tiles_SPR_BAMBOO.png")
 2442               6460     		.data
 2443    10:6460             	_tiles_SPR_BAMBOO:	.incspr		"res/sprites/tiles_SPR_BAMBOO.png"
 2444               E309     		.code
 2445                        		.dbg	line,	"include\gfx_SPRITES.c", 40; #incspr(tiles_SPR_YASHICHI,"res/sprites/tiles_SPR_YASHICHI.png")
 2446               64E0     		.data
 2447    10:64E0             	_tiles_SPR_YASHICHI:	.incspr		"res/sprites/tiles_SPR_YASHICHI.png"
 2448               E309     		.code
 2449                        		.dbg	line,	"include\gfx_SPRITES.c", 41; #incspr(tiles_SPR_ELEPHANT,"res/sprites/tiles_SPR_ELEPHANT.png")
 2450               6560     		.data
 2451    10:6560             	_tiles_SPR_ELEPHANT:	.incspr		"res/sprites/tiles_SPR_ELEPHANT.png"
 2452               E309     		.code
 2453                        		.dbg	line,	"include\gfx_SPRITES.c", 42; #incspr(tiles_SPR_DRAGONFLY,"res/sprites/tiles_SPR_DRAGONFLY.png")
 2454               65E0     		.data
 2455    10:65E0             	_tiles_SPR_DRAGONFLY:	.incspr		"res/sprites/tiles_SPR_DRAGONFLY.png"
 2456               E309     		.code
 2457                        		.dbg	line,	"include\gfx_SPRITES.c", 43; #incspr(tiles_SPR_COW,"res/sprites/tiles_SPR_COW.png")
 2458               6660     		.data
 2459    10:6660             	_tiles_SPR_COW:	.incspr		"res/sprites/tiles_SPR_COW.png"
 2460               E309     		.code
 2461                        		.dbg	line,	"include\gfx_SPRITES.c", 44; #incspr(tiles_SPR_MOBICHAN,"res/sprites/tiles_SPR_MOBICHAN.png")
 2462               66E0     		.data
 2463    10:66E0             	_tiles_SPR_MOBICHAN:	.incspr		"res/sprites/tiles_SPR_MOBICHAN.png"
 2464               E309     		.code
 2465                        		.dbg	line,	"include\gfx_SPRITES.c", 46; // EXTRACT OBJECTS PALETTE //
 2466                        		.dbg	line,	"include\gfx_SPRITES.c", 47; #incpal(palette_objects_1,"res/palettes/palette_objects_1.png");
 2467               6760     		.data
 2468    10:6760             	_palette_objects_1:	.incpal		"res/palettes/palette_objects_1.png"
 2469               E309     		.code
 2470                        		.dbg	line,	"include\gfx_SPRITES.c", 48; #incpal(palette_objects_2,"res/palettes/palette_objects_2.png");
 2471               6960     		.data
 2472    10:6960             	_palette_objects_2:	.incpal		"res/palettes/palette_objects_2.png"
 2473               E309     		.code
 2474                        		.dbg	line,	"include\gfx_SPRITES.c", 51; // EXTRACT NPCS TILES //
 2475                        		.dbg	line,	"include\gfx_SPRITES.c", 52; #incspr(tiles_SPR_NPC,"res/sprites/tiles_SPR_NPC.png")
 2476               6B60     		.data
 2477    10:6B60             	_tiles_SPR_NPC:	.incspr		"res/sprites/tiles_SPR_NPC.png"
 2478               E309     		.code
 2479                        		.dbg	line,	"include\gfx_SPRITES.c", 56; // EXTRACT CURSOR TILES //
 2480                        		.dbg	line,	"include\gfx_SPRITES.c", 57; #incspr(tiles_SPR_CURSOR,"res/sprites/tiles_SPR_CURSOR.png")
 2481               7760     		.data
 2482    10:7760             	_tiles_SPR_CURSOR:	.incspr		"res/sprites/tiles_SPR_CURSOR.png"
 2483               E309     		.code
 2484                        		.dbg	line,	"main.c", 15; #include "include/tables_NPC.c"
 2485                        		.dbg	line,	"include\tables_NPC.c", 1; //-----------------------------------------------------------------------------//
 2486                        		.dbg	line,	"include\tables_NPC.c", 2; //                                                                             //
 2487                        		.dbg	line,	"include\tables_NPC.c", 3; //                                   LEVEL 1                                   //
 2488                        		.dbg	line,	"include\tables_NPC.c", 4; //                                                                             //
 2489                        		.dbg	line,	"include\tables_NPC.c", 5; //-----------------------------------------------------------------------------//
 2490                        		.dbg	line,	"include\tables_NPC.c", 7; const char              TABLE_NPC_TYPE_LV1[NPC_NUMBER_LV1]              =   {
 2491                        		.dbg	line,	"include\tables_NPC.c", 8; TYPE_NPC_SHOP,
 2492                        		.dbg	line,	"include\tables_NPC.c", 9; TYPE_NPC_REWARD
 2493                        		.dbg	line,	"include\tables_NPC.c", 10; };
 2494                        		.dbg	line,	"include\tables_NPC.c", 13; const signed int        TABLE_NPC_X_POS_REF_LV1[NPC_NUMBER_LV1]         =   {
 2495                        		.dbg	line,	"include\tables_NPC.c", 14; 912,
 2496                        		.dbg	line,	"include\tables_NPC.c", 15; 1232
 2497                        		.dbg	line,	"include\tables_NPC.c", 16; };
 2498                        		.dbg	line,	"include\tables_NPC.c", 19; const signed int        TABLE_NPC_Y_POS_REF_LV1[NPC_NUMBER_LV1]         =   {
 2499                        		.dbg	line,	"include\tables_NPC.c", 20; 576,
 2500                        		.dbg	line,	"include\tables_NPC.c", 21; 400
 2501                        		.dbg	line,	"include\tables_NPC.c", 22; };
 2502                        		.dbg	line,	"main.c", 16; #include "include/tables_OBJECT.c"
 2503                        		.dbg	line,	"include\tables_OBJECT.c", 1; //-----------------------------------------------------------------------------//
 2504                        		.dbg	line,	"include\tables_OBJECT.c", 2; //                                                                             //
 2505                        		.dbg	line,	"include\tables_OBJECT.c", 3; //                                   LEVEL 1                                   //
 2506                        		.dbg	line,	"include\tables_OBJECT.c", 4; //                                                                             //
 2507                        		.dbg	line,	"include\tables_OBJECT.c", 5; //-----------------------------------------------------------------------------//
 2508                        		.dbg	line,	"include\tables_OBJECT.c", 7; const char              TABLE_OBJECT_TYPE_LV1[OBJECT_NUMBER_LV1]      =   {
 2509                        		.dbg	line,	"include\tables_OBJECT.c", 8; TYPE_HOURGLASS,
 2510                        		.dbg	line,	"include\tables_OBJECT.c", 9; TYPE_POT,
 2511                        		.dbg	line,	"include\tables_OBJECT.c", 10; TYPE_POT,
 2512                        		.dbg	line,	"include\tables_OBJECT.c", 11; TYPE_POT,
 2513                        		.dbg	line,	"include\tables_OBJECT.c", 12; TYPE_POT,
 2514                        		.dbg	line,	"include\tables_OBJECT.c", 13; TYPE_POT,
 2515                        		.dbg	line,	"include\tables_OBJECT.c", 14; TYPE_POT,
 2516                        		.dbg	line,	"include\tables_OBJECT.c", 15; TYPE_POW,
 2517                        		.dbg	line,	"include\tables_OBJECT.c", 16; TYPE_POT,
 2518                        		.dbg	line,	"include\tables_OBJECT.c", 17; TYPE_POT,
 2519                        		.dbg	line,	"include\tables_OBJECT.c", 19; //
 2520                        		.dbg	line,	"include\tables_OBJECT.c", 20; TYPE_POT,
 2521                        		.dbg	line,	"include\tables_OBJECT.c", 21; TYPE_POT,
 2522                        		.dbg	line,	"include\tables_OBJECT.c", 22; TYPE_POT,
 2523                        		.dbg	line,	"include\tables_OBJECT.c", 23; TYPE_POT,
 2524                        		.dbg	line,	"include\tables_OBJECT.c", 24; TYPE_POT,
 2525                        		.dbg	line,	"include\tables_OBJECT.c", 25; TYPE_POT,
 2526                        		.dbg	line,	"include\tables_OBJECT.c", 26; TYPE_POT,
 2527                        		.dbg	line,	"include\tables_OBJECT.c", 27; TYPE_POT,
 2528                        		.dbg	line,	"include\tables_OBJECT.c", 28; TYPE_POT,
 2529                        		.dbg	line,	"include\tables_OBJECT.c", 29; TYPE_POT,
 2530                        		.dbg	line,	"include\tables_OBJECT.c", 31; //
 2531                        		.dbg	line,	"include\tables_OBJECT.c", 32; TYPE_POT,
 2532                        		.dbg	line,	"include\tables_OBJECT.c", 33; TYPE_POT,
 2533                        		.dbg	line,	"include\tables_OBJECT.c", 34; TYPE_POT
 2534                        		.dbg	line,	"include\tables_OBJECT.c", 35; };
 2535                        		.dbg	line,	"include\tables_OBJECT.c", 38; const signed int        TABLE_OBJECT_X_POS_REF_LV1[OBJECT_NUMBER_LV1] =   {
 2536                        		.dbg	line,	"include\tables_OBJECT.c", 39; 1680,
 2537                        		.dbg	line,	"include\tables_OBJECT.c", 40; 1280,
 2538                        		.dbg	line,	"include\tables_OBJECT.c", 41; 1472,
 2539                        		.dbg	line,	"include\tables_OBJECT.c", 42; 1440,
 2540                        		.dbg	line,	"include\tables_OBJECT.c", 43; 1168,
 2541                        		.dbg	line,	"include\tables_OBJECT.c", 44; 1200,
 2542                        		.dbg	line,	"include\tables_OBJECT.c", 45; 960,
 2543                        		.dbg	line,	"include\tables_OBJECT.c", 46; 984,
 2544                        		.dbg	line,	"include\tables_OBJECT.c", 47; 1360,
 2545                        		.dbg	line,	"include\tables_OBJECT.c", 48; 1392,
 2546                        		.dbg	line,	"include\tables_OBJECT.c", 50; //
 2547                        		.dbg	line,	"include\tables_OBJECT.c", 51; 1552,
 2548                        		.dbg	line,	"include\tables_OBJECT.c", 52; 1680,
 2549                        		.dbg	line,	"include\tables_OBJECT.c", 53; 1712,
 2550                        		.dbg	line,	"include\tables_OBJECT.c", 54; 1744,
 2551                        		.dbg	line,	"include\tables_OBJECT.c", 55; 1248,
 2552                        		.dbg	line,	"include\tables_OBJECT.c", 56; 1280,
 2553                        		.dbg	line,	"include\tables_OBJECT.c", 57; 1168,
 2554                        		.dbg	line,	"include\tables_OBJECT.c", 58; 1040,
 2555                        		.dbg	line,	"include\tables_OBJECT.c", 59; 640,
 2556                        		.dbg	line,	"include\tables_OBJECT.c", 60; 672,
 2557                        		.dbg	line,	"include\tables_OBJECT.c", 62; //
 2558                        		.dbg	line,	"include\tables_OBJECT.c", 63; 336,
 2559                        		.dbg	line,	"include\tables_OBJECT.c", 64; 368,
 2560                        		.dbg	line,	"include\tables_OBJECT.c", 65; 416
 2561                        		.dbg	line,	"include\tables_OBJECT.c", 66; };
 2562                        		.dbg	line,	"include\tables_OBJECT.c", 69; const signed int        TABLE_OBJECT_Y_POS_REF_LV1[OBJECT_NUMBER_LV1] =   {
 2563                        		.dbg	line,	"include\tables_OBJECT.c", 70; 384,
 2564                        		.dbg	line,	"include\tables_OBJECT.c", 71; 416,
 2565                        		.dbg	line,	"include\tables_OBJECT.c", 72; 480,
 2566                        		.dbg	line,	"include\tables_OBJECT.c", 73; 496,
 2567                        		.dbg	line,	"include\tables_OBJECT.c", 74; 560,
 2568                        		.dbg	line,	"include\tables_OBJECT.c", 75; 560,
 2569                        		.dbg	line,	"include\tables_OBJECT.c", 76; 592,
 2570                        		.dbg	line,	"include\tables_OBJECT.c", 77; 592,
 2571                        		.dbg	line,	"include\tables_OBJECT.c", 78; 592,
 2572                        		.dbg	line,	"include\tables_OBJECT.c", 79; 592,
 2573                        		.dbg	line,	"include\tables_OBJECT.c", 81; //
 2574                        		.dbg	line,	"include\tables_OBJECT.c", 82; 704,
 2575                        		.dbg	line,	"include\tables_OBJECT.c", 83; 720,
 2576                        		.dbg	line,	"include\tables_OBJECT.c", 84; 720,
 2577                        		.dbg	line,	"include\tables_OBJECT.c", 85; 720,
 2578                        		.dbg	line,	"include\tables_OBJECT.c", 86; 736,
 2579                        		.dbg	line,	"include\tables_OBJECT.c", 87; 736,
 2580                        		.dbg	line,	"include\tables_OBJECT.c", 88; 752,
 2581                        		.dbg	line,	"include\tables_OBJECT.c", 89; 848,
 2582                        		.dbg	line,	"include\tables_OBJECT.c", 90; 880,
 2583                        		.dbg	line,	"include\tables_OBJECT.c", 91; 880,
 2584                        		.dbg	line,	"include\tables_OBJECT.c", 93; //
 2585                        		.dbg	line,	"include\tables_OBJECT.c", 94; 896,
 2586                        		.dbg	line,	"include\tables_OBJECT.c", 95; 896,
 2587                        		.dbg	line,	"include\tables_OBJECT.c", 96; 896
 2588                        		.dbg	line,	"include\tables_OBJECT.c", 97; };
 2589                        		.dbg	line,	"include\tables_OBJECT.c", 100; /*const char              TABLE_REWARD_TYPE_LV1[OBJECT_NUMBER_LV1]       =   {
 2590                        		.dbg	line,	"include\tables_OBJECT.c", 101; TYPE_POT
 2591                        		.dbg	line,	"include\tables_OBJECT.c", 102; TYPE_POT,
 2592                        		.dbg	line,	"include\tables_OBJECT.c", 103; TYPE_POT,
 2593                        		.dbg	line,	"include\tables_OBJECT.c", 104; TYPE_POT,
 2594                        		.dbg	line,	"include\tables_OBJECT.c", 105; TYPE_POT,
 2595                        		.dbg	line,	"include\tables_OBJECT.c", 106; TYPE_POT,
 2596                        		.dbg	line,	"include\tables_OBJECT.c", 107; TYPE_POT,
 2597                        		.dbg	line,	"include\tables_OBJECT.c", 108; TYPE_POW,
 2598                        		.dbg	line,	"include\tables_OBJECT.c", 109; TYPE_POT,
 2599                        		.dbg	line,	"include\tables_OBJECT.c", 110; TYPE_POT,
 2600                        		.dbg	line,	"include\tables_OBJECT.c", 112; //
 2601                        		.dbg	line,	"include\tables_OBJECT.c", 113; TYPE_POT,
 2602                        		.dbg	line,	"include\tables_OBJECT.c", 114; TYPE_POT,
 2603                        		.dbg	line,	"include\tables_OBJECT.c", 115; TYPE_POT,
 2604                        		.dbg	line,	"include\tables_OBJECT.c", 116; TYPE_POT,
 2605                        		.dbg	line,	"include\tables_OBJECT.c", 117; TYPE_POT,
 2606                        		.dbg	line,	"include\tables_OBJECT.c", 118; TYPE_POT,
 2607                        		.dbg	line,	"include\tables_OBJECT.c", 119; TYPE_POT,
 2608                        		.dbg	line,	"include\tables_OBJECT.c", 120; TYPE_POT,
 2609                        		.dbg	line,	"include\tables_OBJECT.c", 122; //
 2610                        		.dbg	line,	"include\tables_OBJECT.c", 123; TYPE_GRAY_KEY,
 2611                        		.dbg	line,	"include\tables_OBJECT.c", 124; TYPE_GRAY_KEY,
 2612                        		.dbg	line,	"include\tables_OBJECT.c", 125; TYPE_GRAY_KEY,
 2613                        		.dbg	line,	"include\tables_OBJECT.c", 126; TYPE_COIN_5,
 2614                        		.dbg	line,	"include\tables_OBJECT.c", 127; TYPE_GRAY_KEY
 2615                        		.dbg	line,	"include\tables_OBJECT.c", 128; };*/
 2616                        		.dbg	line,	"include\tables_OBJECT.c", 133; const signed int        TABLE_CHEST_X_POS_REF_LV1[CHEST_NUMBER_LV1]   =   {
 2617                        		.dbg	line,	"include\tables_OBJECT.c", 134; 1072,
 2618                        		.dbg	line,	"include\tables_OBJECT.c", 135; 816
 2619                        		.dbg	line,	"include\tables_OBJECT.c", 136; };
 2620                        		.dbg	line,	"include\tables_OBJECT.c", 139; const signed int        TABLE_CHEST_Y_POS_REF_LV1[CHEST_NUMBER_LV1]   =   {
 2621                        		.dbg	line,	"include\tables_OBJECT.c", 140; 832,
 2622                        		.dbg	line,	"include\tables_OBJECT.c", 141; 848
 2623                        		.dbg	line,	"main.c", 16; };
 2624                        		.dbg	line,	"main.c", 17; #include "include/tables_PLAYER.c"
 2625                        		.dbg	line,	"include\tables_PLAYER.c", 3; const signed char       TABLE_PLAYER_JUMP_V[35]     =   {
 2626                        		.dbg	line,	"include\tables_PLAYER.c", 4; // UPWARD
 2627                        		.dbg	line,	"include\tables_PLAYER.c", 5; -4,
 2628                        		.dbg	line,	"include\tables_PLAYER.c", 6; -5,
 2629                        		.dbg	line,	"include\tables_PLAYER.c", 7; -10,
 2630                        		.dbg	line,	"include\tables_PLAYER.c", 8; -4,
 2631                        		.dbg	line,	"include\tables_PLAYER.c", 9; -4,
 2632                        		.dbg	line,	"include\tables_PLAYER.c", 10; -7,
 2633                        		.dbg	line,	"include\tables_PLAYER.c", 11; -6,
 2634                        		.dbg	line,	"include\tables_PLAYER.c", 12; -3,
 2635                        		.dbg	line,	"include\tables_PLAYER.c", 13; -5,
 2636                        		.dbg	line,	"include\tables_PLAYER.c", 14; -2,
 2637                        		.dbg	line,	"include\tables_PLAYER.c", 15; -4,
 2638                        		.dbg	line,	"include\tables_PLAYER.c", 16; -1,
 2639                        		.dbg	line,	"include\tables_PLAYER.c", 17; -1,
 2640                        		.dbg	line,	"include\tables_PLAYER.c", 18; -1,
 2641                        		.dbg	line,	"include\tables_PLAYER.c", 19; -1,
 2642                        		.dbg	line,	"include\tables_PLAYER.c", 20; 0,
 2643                        		.dbg	line,	"include\tables_PLAYER.c", 21; 0,
 2644                        		.dbg	line,	"include\tables_PLAYER.c", 22; 0,
 2645                        		.dbg	line,	"include\tables_PLAYER.c", 23; 0,
 2646                        		.dbg	line,	"include\tables_PLAYER.c", 24; // DOWNWARD
 2647                        		.dbg	line,	"include\tables_PLAYER.c", 25; 1,
 2648                        		.dbg	line,	"include\tables_PLAYER.c", 26; 1,
 2649                        		.dbg	line,	"include\tables_PLAYER.c", 27; 1,
 2650                        		.dbg	line,	"include\tables_PLAYER.c", 28; 1,
 2651                        		.dbg	line,	"include\tables_PLAYER.c", 29; 4,
 2652                        		.dbg	line,	"include\tables_PLAYER.c", 30; 2,
 2653                        		.dbg	line,	"include\tables_PLAYER.c", 31; 5,
 2654                        		.dbg	line,	"include\tables_PLAYER.c", 32; 3,
 2655                        		.dbg	line,	"include\tables_PLAYER.c", 33; 6,
 2656                        		.dbg	line,	"include\tables_PLAYER.c", 34; 7,
 2657                        		.dbg	line,	"include\tables_PLAYER.c", 35; 4,
 2658                        		.dbg	line,	"include\tables_PLAYER.c", 36; 4,
 2659                        		.dbg	line,	"include\tables_PLAYER.c", 37; 10,
 2660                        		.dbg	line,	"include\tables_PLAYER.c", 38; 4,
 2661                        		.dbg	line,	"include\tables_PLAYER.c", 39; 4,
 2662                        		.dbg	line,	"include\tables_PLAYER.c", 40; 5
 2663                        		.dbg	line,	"include\tables_PLAYER.c", 41; };
 2664                        		.dbg	line,	"include\tables_PLAYER.c", 44; const signed char       TABLE_PLAYER_FALL[21]       =   {
 2665                        		.dbg	line,	"include\tables_PLAYER.c", 45; 0,
 2666                        		.dbg	line,	"include\tables_PLAYER.c", 46; 0,
 2667                        		.dbg	line,	"include\tables_PLAYER.c", 47; 0,
 2668                        		.dbg	line,	"include\tables_PLAYER.c", 48; 0,
 2669                        		.dbg	line,	"include\tables_PLAYER.c", 49; 1,
 2670                        		.dbg	line,	"include\tables_PLAYER.c", 50; 1,
 2671                        		.dbg	line,	"include\tables_PLAYER.c", 51; 1,
 2672                        		.dbg	line,	"include\tables_PLAYER.c", 52; 1,
 2673                        		.dbg	line,	"include\tables_PLAYER.c", 53; 2,
 2674                        		.dbg	line,	"include\tables_PLAYER.c", 54; 2,
 2675                        		.dbg	line,	"include\tables_PLAYER.c", 55; 2,
 2676                        		.dbg	line,	"include\tables_PLAYER.c", 56; 2,
 2677                        		.dbg	line,	"include\tables_PLAYER.c", 57; 3,
 2678                        		.dbg	line,	"include\tables_PLAYER.c", 58; 3,
 2679                        		.dbg	line,	"include\tables_PLAYER.c", 59; 3,
 2680                        		.dbg	line,	"include\tables_PLAYER.c", 60; 4,
 2681                        		.dbg	line,	"include\tables_PLAYER.c", 61; 4,
 2682                        		.dbg	line,	"include\tables_PLAYER.c", 62; 4,
 2683                        		.dbg	line,	"include\tables_PLAYER.c", 63; 4,
 2684                        		.dbg	line,	"include\tables_PLAYER.c", 64; 4,
 2685                        		.dbg	line,	"include\tables_PLAYER.c", 65; 5
 2686                        		.dbg	line,	"include\tables_PLAYER.c", 66; };
 2687                        		.dbg	line,	"include\tables_PLAYER.c", 69; const signed char       TABLE_PLAYER_JUMP_LADDER[30]    =   {
 2688                        		.dbg	line,	"include\tables_PLAYER.c", 70; // UPWARD
 2689                        		.dbg	line,	"include\tables_PLAYER.c", 71; -4,
 2690                        		.dbg	line,	"include\tables_PLAYER.c", 72; -4,
 2691                        		.dbg	line,	"include\tables_PLAYER.c", 73; -3,
 2692                        		.dbg	line,	"include\tables_PLAYER.c", 74; -3,
 2693                        		.dbg	line,	"include\tables_PLAYER.c", 75; -3,
 2694                        		.dbg	line,	"include\tables_PLAYER.c", 76; -2,
 2695                        		.dbg	line,	"include\tables_PLAYER.c", 77; -2,
 2696                        		.dbg	line,	"include\tables_PLAYER.c", 78; -2,
 2697                        		.dbg	line,	"include\tables_PLAYER.c", 79; -1,
 2698                        		.dbg	line,	"include\tables_PLAYER.c", 80; -1,
 2699                        		.dbg	line,	"include\tables_PLAYER.c", 81; -1,
 2700                        		.dbg	line,	"include\tables_PLAYER.c", 82; -1,
 2701                        		.dbg	line,	"include\tables_PLAYER.c", 83; -1,
 2702                        		.dbg	line,	"include\tables_PLAYER.c", 84; 0,
 2703                        		.dbg	line,	"include\tables_PLAYER.c", 85; 0,
 2704                        		.dbg	line,	"include\tables_PLAYER.c", 86; 0,
 2705                        		.dbg	line,	"include\tables_PLAYER.c", 87; 0,
 2706                        		.dbg	line,	"include\tables_PLAYER.c", 88; // DOWNWARD
 2707                        		.dbg	line,	"include\tables_PLAYER.c", 89; 1,
 2708                        		.dbg	line,	"include\tables_PLAYER.c", 90; 1,
 2709                        		.dbg	line,	"include\tables_PLAYER.c", 91; 1,
 2710                        		.dbg	line,	"include\tables_PLAYER.c", 92; 1,
 2711                        		.dbg	line,	"include\tables_PLAYER.c", 93; 1,
 2712                        		.dbg	line,	"include\tables_PLAYER.c", 94; 2,
 2713                        		.dbg	line,	"include\tables_PLAYER.c", 95; 2,
 2714                        		.dbg	line,	"include\tables_PLAYER.c", 96; 2,
 2715                        		.dbg	line,	"include\tables_PLAYER.c", 97; 3,
 2716                        		.dbg	line,	"include\tables_PLAYER.c", 98; 3,
 2717                        		.dbg	line,	"include\tables_PLAYER.c", 99; 3,
 2718                        		.dbg	line,	"include\tables_PLAYER.c", 100; 4,
 2719                        		.dbg	line,	"include\tables_PLAYER.c", 101; 4
 2720                        		.dbg	line,	"main.c", 17; };
 2721                        		.dbg	line,	"main.c", 18; #include "include/tables_SHOP.c"
 2722                        		.dbg	line,	"include\tables_SHOP.c", 1; //-----------------------------------------------------------------------------//
 2723                        		.dbg	line,	"include\tables_SHOP.c", 2; //                                                                             //
 2724                        		.dbg	line,	"include\tables_SHOP.c", 3; //                                   LEVEL 1                                   //
 2725                        		.dbg	line,	"include\tables_SHOP.c", 4; //                                                                             //
 2726                        		.dbg	line,	"include\tables_SHOP.c", 5; //-----------------------------------------------------------------------------//
 2727                        		.dbg	line,	"include\tables_SHOP.c", 7; const char              TABLE_SHOP_ITEMS_LV1[10]        =   {
 2728                        		.dbg	line,	"include\tables_SHOP.c", 8; TYPE_ITEM_WEAPON_2,
 2729                        		.dbg	line,	"include\tables_SHOP.c", 9; TYPE_ITEM_WEAPON_3,
 2730                        		.dbg	line,	"include\tables_SHOP.c", 10; TYPE_ITEM_WEAPON_4,
 2731                        		.dbg	line,	"include\tables_SHOP.c", 11; TYPE_ITEM_WEAPON_5,
 2732                        		.dbg	line,	"include\tables_SHOP.c", 12; TYPE_ITEM_KEY,
 2733                        		.dbg	line,	"include\tables_SHOP.c", 14; TYPE_ITEM_ARMOR_2,
 2734                        		.dbg	line,	"include\tables_SHOP.c", 15; TYPE_ITEM_ARMOR_3,
 2735                        		.dbg	line,	"include\tables_SHOP.c", 16; TYPE_ITEM_ARMOR_4,
 2736                        		.dbg	line,	"include\tables_SHOP.c", 17; TYPE_ITEM_ARMOR_5,
 2737                        		.dbg	line,	"include\tables_SHOP.c", 18; TYPE_ITEM_POTION
 2738                        		.dbg	line,	"include\tables_SHOP.c", 19; };
 2739                        		.dbg	line,	"include\tables_SHOP.c", 22; const int               TABLE_SHOP_PRICES_LV1[10]       =   {
 2740                        		.dbg	line,	"include\tables_SHOP.c", 23; 100,
 2741                        		.dbg	line,	"include\tables_SHOP.c", 24; 1000,
 2742                        		.dbg	line,	"include\tables_SHOP.c", 25; 2400,
 2743                        		.dbg	line,	"include\tables_SHOP.c", 26; 9600,
 2744                        		.dbg	line,	"include\tables_SHOP.c", 27; 30,
 2745                        		.dbg	line,	"include\tables_SHOP.c", 28; 80,
 2746                        		.dbg	line,	"include\tables_SHOP.c", 29; 300,
 2747                        		.dbg	line,	"include\tables_SHOP.c", 30; 800,
 2748                        		.dbg	line,	"include\tables_SHOP.c", 31; 1600,
 2749                        		.dbg	line,	"include\tables_SHOP.c", 32; 150
 2750                        		.dbg	line,	"include\tables_SHOP.c", 33; };
 2751                        		.dbg	line,	"include\tables_SHOP.c", 36; const unsigned char     *TABLE_SHOP_ITEMS_TILES_ADR[10]     =   {
 2752                        		.dbg	line,	"include\tables_SHOP.c", 37; &tiles_ITEM_WEAPON_2,
 2753                        		.dbg	line,	"include\tables_SHOP.c", 38; &tiles_ITEM_WEAPON_3,
 2754                        		.dbg	line,	"include\tables_SHOP.c", 39; &tiles_ITEM_WEAPON_4,
 2755                        		.dbg	line,	"include\tables_SHOP.c", 40; &tiles_ITEM_WEAPON_5,
 2756                        		.dbg	line,	"include\tables_SHOP.c", 41; &tiles_ITEM_KEY,
 2757                        		.dbg	line,	"include\tables_SHOP.c", 42; &tiles_ITEM_ARMOR_2,
 2758                        		.dbg	line,	"include\tables_SHOP.c", 43; &tiles_ITEM_ARMOR_3,
 2759                        		.dbg	line,	"include\tables_SHOP.c", 44; &tiles_ITEM_ARMOR_4,
 2760                        		.dbg	line,	"include\tables_SHOP.c", 45; &tiles_ITEM_ARMOR_5,
 2761                        		.dbg	line,	"include\tables_SHOP.c", 46; &tiles_ITEM_POTION
 2762                        		.dbg	line,	"include\tables_SHOP.c", 47; };
 2763                        		.dbg	line,	"include\tables_SHOP.c", 50; const unsigned char     TABLE_SHOP_ITEMS_TILES_BANK[10]     =   {
 2764                        		.dbg	line,	"include\tables_SHOP.c", 51; ^tiles_ITEM_WEAPON_2,
 2765                        		.dbg	line,	"include\tables_SHOP.c", 52; ^tiles_ITEM_WEAPON_3,
 2766                        		.dbg	line,	"include\tables_SHOP.c", 53; ^tiles_ITEM_WEAPON_4,
 2767                        		.dbg	line,	"include\tables_SHOP.c", 54; ^tiles_ITEM_WEAPON_5,
 2768                        		.dbg	line,	"include\tables_SHOP.c", 55; ^tiles_ITEM_KEY,
 2769                        		.dbg	line,	"include\tables_SHOP.c", 56; ^tiles_ITEM_ARMOR_2,
 2770                        		.dbg	line,	"include\tables_SHOP.c", 57; ^tiles_ITEM_ARMOR_3,
 2771                        		.dbg	line,	"include\tables_SHOP.c", 58; ^tiles_ITEM_ARMOR_4,
 2772                        		.dbg	line,	"include\tables_SHOP.c", 59; ^tiles_ITEM_ARMOR_5,
 2773                        		.dbg	line,	"include\tables_SHOP.c", 60; ^tiles_ITEM_POTION
 2774                        		.dbg	line,	"include\tables_SHOP.c", 61; };
 2775                        		.dbg	line,	"include\tables_SHOP.c", 64; const char              TABLE_CURSOR_POS_X[11]              =   {
 2776                        		.dbg	line,	"include\tables_SHOP.c", 65; 24,
 2777                        		.dbg	line,	"include\tables_SHOP.c", 66; 56,
 2778                        		.dbg	line,	"include\tables_SHOP.c", 67; 96,
 2779                        		.dbg	line,	"include\tables_SHOP.c", 68; 136,
 2780                        		.dbg	line,	"include\tables_SHOP.c", 69; 176,
 2781                        		.dbg	line,	"include\tables_SHOP.c", 70; 24,
 2782                        		.dbg	line,	"include\tables_SHOP.c", 71; 56,
 2783                        		.dbg	line,	"include\tables_SHOP.c", 72; 96,
 2784                        		.dbg	line,	"include\tables_SHOP.c", 73; 136,
 2785                        		.dbg	line,	"include\tables_SHOP.c", 74; 176,
 2786                        		.dbg	line,	"include\tables_SHOP.c", 75; 212
 2787                        		.dbg	line,	"include\tables_SHOP.c", 76; };
 2788                        		.dbg	line,	"main.c", 22; #include "include/routines_LEVELS.c"
 2789                        		.dbg	line,	"include\routines_LEVELS.c", 1; #include "huc.h"
 2790                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 1; #ifndef _hucc_legacy_h
 2791                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 2; #define _hucc_legacy_h
 2792                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 4; /****************************************************************************
 2793                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 5; ; ***************************************************************************
 2794                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 6; ;
 2795                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 7; ; huc.h
 2796                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 8; ;
 2797                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 9; ; HuCC wrapper file to include a default set of HuC-compatible functions.
 2798                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 10; ;
 2799                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 11; ; Copyright John Brandwood 2024.
 2800                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 12; ;
 2801                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 13; ; Distributed under the Boost Software License, Version 1.0.
 2802                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 14; ; (See accompanying file LICENSE_1_0.txt or copy at
 2803                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 15; ;  http://www.boost.org/LICENSE_1_0.txt)
 2804                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 16; ;
 2805                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 17; ; ***************************************************************************
 2806                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 18; ; ***************************************************************************
 2807                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 19; ;
 2808                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 20; ; When the HuCC compiler is invoked with the "--legacy" option to compile old
 2809                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 21; ; projects, then this "huc.h" file is automatically included.
 2810                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 22; ;
 2811                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 23; ; This file includes a set of the individual HuCC headers which correspond to
 2812                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 24; ; HuC's built-in functions and MagicKit library.
 2813                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 25; ;
 2814                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 26; ; New HuCC projects should, preferably, include the specific headers that are
 2815                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 27; ; needed, which will then allow them to replace parts of the standard library
 2816                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 28; ; with newer functions, or they can just manually include this "huc.h" file.
 2817                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 29; ;
 2818                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 30; ; ***************************************************************************
 2819                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 31; ; **************************************************************************/
 2820                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 33; #include "hucc-systemcard.h"
 2821                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 34; #include "hucc-baselib.h"
 2822                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 35; #include "hucc-gfx.h"
 2823                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 36; #include "hucc-string.h"
 2824                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 37; #include "hucc-old-scroll.h"
 2825                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 38; #include "hucc-old-spr.h"
 2826                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 39; #include "hucc-old-map.h"
 2827                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 40; #include "hucc-old-line.h"
 2828                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 42; #endif // _hucc_legacy_h
 2829                        		.dbg	line,	"include\routines_LEVELS.c", 2; #include "hucc-scroll.h"
 2830                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 1; #ifndef _hucc_scroll_h
 2831                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 2; #define _hucc_scroll_h
 2832                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 4; /****************************************************************************
 2833                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 5; ; ***************************************************************************
 2834                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 6; ;
 2835                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 7; ; hucc-scroll.h
 2836                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 8; ;
 2837                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 9; ; Routines for a fast split-screen scrolling system.
 2838                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 10; ;
 2839                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 11; ; Copyright John Brandwood 2024.
 2840                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 12; ;
 2841                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 13; ; Distributed under the Boost Software License, Version 1.0.
 2842                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 14; ; (See accompanying file LICENSE_1_0.txt or copy at
 2843                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 15; ;  http://www.boost.org/LICENSE_1_0.txt)
 2844                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 16; ;
 2845                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 17; ; ***************************************************************************
 2846                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 18; ; ***************************************************************************
 2847                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 19; ;
 2848                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 20; ; The maximum number of splits for each screen layer is set in your project's
 2849                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 21; ; "hucc-config.inc" file, with the library having a limit of 128-per-layer.
 2850                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 22; ;
 2851                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 23; ; Your first active split must be defined to start at screen line 0, and then
 2852                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 24; ; the rest of the active splits must be in increasing line order to match the
 2853                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 25; ; way that the PC Engine displays the output image.
 2854                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 26; ;
 2855                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 27; ; You can have disabled splits interleaved with your active splits.
 2856                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 28; ;
 2857                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 29; ; Splits that are normally disabled can be used to create full screen effects
 2858                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 30; ; such as bouncing the screen up and down by adding blank areas at the top or
 2859                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 31; ; bottom of the screen, and then rapidly changing the height of those areas.
 2860                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 32; ;
 2861                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 33; ; ***************************************************************************
 2862                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 34; ; **************************************************************************/
 2863                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 36; // *************
 2864                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 37; // VDC bits for display_flags ...
 2865                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 38; // *************
 2866                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 40; #ifndef BKG_OFF
 2867                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 41; #define BKG_OFF 0x00
 2868                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 42; #endif
 2869                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 44; #ifndef SPR_OFF
 2870                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 45; #define SPR_OFF 0x00
 2871                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 46; #endif
 2872                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 48; #ifndef BKG_ON
 2873                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 49; #define BKG_ON 0x80
 2874                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 50; #endif
 2875                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 52; #ifndef SPR_ON
 2876                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 53; #define SPR_ON 0x40
 2877                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 54; #endif
 2878                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 56; // *************
 2879                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 57; // Functions in hucc-scroll.asm ...
 2880                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 58; // *************
 2881                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 60; #ifdef __HUCC__
 2882                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 62; #asmdef	HUCC_USES_NEW_SCROLL 1
 2883                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 64; extern void __fastcall scroll_split( unsigned char index<_al>, unsigned char screen_line<_ah>, unsigned int bat_x<_bx>, unsigned int bat_y<_cx>, unsigned char display_flags<_dl> );
 2884                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 65; extern void __fastcall sgx_scroll_split( unsigned char index<_al>, unsigned char screen_line<_ah>, unsigned int bat_x<_bx>, unsigned int bat_y<_cx>, unsigned char display_flags<_dl> );
 2885                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 67; extern void __fastcall disable_split( unsigned char index<acc> );
 2886                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 68; extern void __fastcall sgx_disable_split( unsigned char index<acc> );
 2887                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 70; extern void __fastcall __macro disable_all_splits( void );
 2888                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 71; extern void __fastcall __macro sgx_disable_all_splits( void );
 2889                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 73; #asm
 2890                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 74; .macro	_disable_all_splits
 2891                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 75; ldy	#HUCC_PCE_SPLITS - 1
 2892                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 76; !loop:		tya
 2893                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 77; call	_disable_split.1
 2894                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 78; dey
 2895                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 79; bpl	!loop-
 2896                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 80; .endm
 2897                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 82; .macro	_sgx_disable_all_splits
 2898                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 83; ldy	#HUCC_SGX_SPLITS - 1
 2899                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 84; !loop:		tya
 2900                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 85; call	_sgx_disable_split.1
 2901                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 86; dey
 2902                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 87; bpl	!loop-
 2903                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 88; .endm
 2904                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 89; #endasm
 2905                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 91; #endif // __HUCC__
 2906                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 93; #endif // _hucc_scroll_h
 2907                        		.dbg	line,	"include\routines_LEVELS.c", 3; #include "hucc-chrmap.h"
 2908                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 1; #ifndef _hucc_chrmap_h
 2909                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 2; #define _hucc_chrmap_h
 2910                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 4; /****************************************************************************
 2911                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 5; ; ***************************************************************************
 2912                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 6; ;
 2913                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 7; ; hucc-chrmap.h
 2914                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 8; ;
 2915                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 9; ; A simple map system based on 8x8 characters (aka "tiles") in BAT format.
 2916                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 10; ;
 2917                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 11; ; Copyright John Brandwood 2025.
 2918                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 12; ;
 2919                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 13; ; Distributed under the Boost Software License, Version 1.0.
 2920                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 14; ; (See accompanying file LICENSE_1_0.txt or copy at
 2921                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 15; ;  http://www.boost.org/LICENSE_1_0.txt)
 2922                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 16; ;
 2923                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 17; ; ***************************************************************************
 2924                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 18; ; ***************************************************************************
 2925                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 19; ;
 2926                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 20; ; The maximum X and Y size for chrmaps is 256 characters (2048 pixels).
 2927                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 21; ;
 2928                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 22; ; The maximum total size for a chrmap is 16KBytes, which allows for maps up
 2929                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 23; ; to 256x32 tiles (2048x256 pixels).
 2930                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 24; ;
 2931                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 25; ; ***************************************************************************
 2932                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 26; ; **************************************************************************/
 2933                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 28; // *************
 2934                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 29; // This code extends the blkmap library ...
 2935                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 30; // *************
 2936                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 32; #include "hucc-blkmap.h"
 2937                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 34; // *************
 2938                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 35; // Functions in chrmap.asm ...
 2939                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 36; // *************
 2940                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 38; #ifdef __HUCC__
 2941                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 40; #asmdef	HUCC_USES_CHRMAP 1
 2942                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 42; extern void __fastcall __nop set_chrmap( unsigned char __far *chrmap<vdc_map_bank:vdc_map_addr>, unsigned char tiles_w<vdc_map_line_w> );
 2943                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 44; extern void __fastcall draw_bat( void );
 2944                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 45; extern void __fastcall scroll_bat( void );
 2945                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 47; extern void __fastcall blit_bat( unsigned char tile_x<map_bat_x>, unsigned char tile_y<map_bat_y>, unsigned char tile_w<map_draw_x>, unsigned char tile_h<map_draw_y> );
 2946                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 49; #ifdef _SGX
 2947                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 51; extern void __fastcall __nop sgx_set_chrmap( unsigned char __far *chrmap<sgx_map_bank:sgx_map_addr>, unsigned char tiles_w<sgx_map_line_w> );
 2948                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 53; extern void __fastcall sgx_draw_bat( void );
 2949                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 54; extern void __fastcall sgx_scroll_bat( void );
 2950                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 56; extern void __fastcall sgx_blit_bat( unsigned char tile_x<map_bat_x>, unsigned char tile_y<map_bat_y>, unsigned char tile_w<map_draw_x>, unsigned char tile_h<map_draw_y> );
 2951                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 58; #endif
 2952                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 60; #endif // __HUCC__
 2953                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 62; #endif // _hucc_chrmap_h
 2954                        		.dbg	line,	"include\routines_LEVELS.c", 4; #include "hucc-blkmap.h"
 2955                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 1; #ifndef _hucc_blkmap_h
 2956                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 2; #define _hucc_blkmap_h
 2957                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 4; /****************************************************************************
 2958                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 5; ; ***************************************************************************
 2959                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 6; ;
 2960                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 7; ; hucc-blkmap.h
 2961                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 8; ;
 2962                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 9; ; A map system based on 16x16 meta-tiles (aka "blocks", aka CHR/BLK/MAP).
 2963                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 10; ;
 2964                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 11; ; Copyright John Brandwood 2025.
 2965                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 12; ;
 2966                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 13; ; Distributed under the Boost Software License, Version 1.0.
 2967                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 14; ; (See accompanying file LICENSE_1_0.txt or copy at
 2968                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 15; ;  http://www.boost.org/LICENSE_1_0.txt)
 2969                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 16; ;
 2970                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 17; ; ***************************************************************************
 2971                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 18; ; ***************************************************************************
 2972                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 19; ;
 2973                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 20; ; The maximum X and Y size for blkmaps is 128 blocks (2048 pixels).
 2974                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 21; ;
 2975                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 22; ; The maximum total size for a blkmap is 16KBytes, which allows for maps up
 2976                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 23; ; to 128x128 blocks (2048x2048 pixels).
 2977                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 24; ;
 2978                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 25; ; Huge multi-screen blkmaps are also supported (optionally).
 2979                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 26; ;
 2980                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 27; ; The maximum X and Y for multi-screen maps is 128 screens (32768 pixels).
 2981                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 28; ;
 2982                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 29; ; The maximum total size for a multi-screen map is 8KBytes, which allows for
 2983                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 30; ; a total of 1024 screens.
 2984                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 31; ;
 2985                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 32; ; ***************************************************************************
 2986                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 33; ; **************************************************************************/
 2987                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 35; // *************
 2988                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 36; // Functions in blkmap.asm ...
 2989                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 37; // *************
 2990                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 39; #ifdef __HUCC__
 2991                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 41; #asmdef	HUCC_USES_BLKMAP 1
 2992                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 43; // Current top-left of drawn map in pixels.
 2993                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 44; extern unsigned int   vdc_map_pxl_x;
 2994                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 45; extern unsigned int   vdc_map_pxl_y;
 2995                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 47; // Width and height to draw/scroll in characters (not tiles).
 2996                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 48; extern unsigned char  vdc_map_draw_w;
 2997                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 49; extern unsigned char  vdc_map_draw_h;
 2998                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 51; // Width of map (or multi-screen BAT) in tiles.
 2999                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 52; extern unsigned char  vdc_map_line_w;
 3000                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 54; // Width of map in screens (if multi-screen map).
 3001                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 55; extern unsigned char  vdc_map_scrn_w;
 3002                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 57; // Extra information returned by get_map_block() and sgx_get_map_block(),
 3003                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 58; // which are the collision flags and the mask/overlay sprite for the BLK.
 3004                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 59; extern unsigned char  map_blk_flag;
 3005                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 60; extern unsigned char  map_blk_mask;
 3006                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 62; extern unsigned char  vdc_scr_bank;
 3007                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 63; extern unsigned char *vdc_scr_addr;
 3008                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 65; extern unsigned char  vdc_map_bank;
 3009                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 66; extern unsigned char *vdc_map_addr;
 3010                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 68; extern unsigned char  vdc_blk_bank;
 3011                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 69; extern unsigned char *vdc_blk_addr;
 3012                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 71; extern unsigned char  vdc_tbl_bank;
 3013                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 72; extern unsigned char *vdc_tbl_addr;
 3014                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 74; extern void __fastcall set_blocks( unsigned char __far *blk_def<vdc_blk_bank:vdc_blk_addr>, unsigned char __far *flg_def<vdc_tbl_bank:vdc_tbl_addr>, unsigned char number_of_blocks<_al> );
 3015                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 75; extern void __fastcall __macro set_blkmap( unsigned char __far *blk_map<vdc_map_bank:vdc_map_addr>, unsigned char blocks_w<vdc_map_line_w> );
 3016                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 76; extern void __fastcall __macro set_multimap( unsigned char __far *multi_map<vdc_scr_bank:vdc_scr_addr>, unsigned char screens_w<vdc_map_scrn_w> );
 3017                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 78; extern void __fastcall draw_map( void );
 3018                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 79; extern void __fastcall scroll_map( void );
 3019                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 81; extern void __fastcall blit_map( unsigned char tile_x<map_bat_x>, unsigned char tile_y<map_bat_y>, unsigned char tile_w<map_draw_x>, unsigned char tile_h<map_draw_y> );
 3020                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 83; extern unsigned char __fastcall get_map_block( unsigned int x<map_pxl_x>, unsigned int y<map_pxl_y> );
 3021                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 85; #asm
 3022                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 86; .macro	_set_blkmap.2
 3023                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 87; stz	vdc_scr_bank
 3024                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 88; .endm
 3025                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 90; .macro	_set_multimap.2
 3026                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 91; lda	vdc_bat_width
 3027                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 92; lsr	a
 3028                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 93; sta	vdc_map_line_w
 3029                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 94; .endm
 3030                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 96; .macro	SCREEN
 3031                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 97; db	(((\1) & $1FFF) | $6000) >> 8, bank(\1)
 3032                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 98; db	(((\2) & $1FFF) | $4000) >> 8, bank(\2)
 3033                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 99; db	(((\3) & $1FFF) | $6000) >> 8, bank(\3)
 3034                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 100; dw	(\4)
 3035                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 101; .endm
 3036                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 102; #endasm
 3037                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 104; #ifdef _SGX
 3038                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 106; // Current top-left of drawn map in pixels.
 3039                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 107; extern unsigned int   sgx_map_pxl_x;
 3040                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 108; extern unsigned int   sgx_map_pxl_y;
 3041                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 110; // Width and height to draw/scroll in characters (not tiles).
 3042                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 111; extern unsigned char  sgx_map_draw_w;
 3043                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 112; extern unsigned char  sgx_map_draw_h;
 3044                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 114; // Width of map (or multi-screen BAT) in tiles.
 3045                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 115; extern unsigned char  sgx_map_line_w;
 3046                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 117; // Width of map in screens (if multi-screen map).
 3047                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 118; extern unsigned char  sgx_map_scrn_w;
 3048                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 120; extern unsigned char  sgx_scr_bank;
 3049                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 121; extern unsigned char *sgx_scr_addr;
 3050                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 123; extern unsigned char  sgx_map_bank;
 3051                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 124; extern unsigned char *sgx_map_addr;
 3052                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 126; extern unsigned char  sgx_blk_bank;
 3053                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 127; extern unsigned char *sgx_blk_addr;
 3054                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 129; extern unsigned char  sgx_tbl_bank;
 3055                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 130; extern unsigned char *sgx_tbl_addr;
 3056                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 132; extern void __fastcall sgx_set_blocks( unsigned char __far *blk_def<sgx_blk_bank:sgx_blk_addr>, unsigned char __far *flg_def<sgx_tbl_bank:sgx_tbl_addr>, unsigned char number_of_blocks<_al> );
 3057                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 133; extern void __fastcall __macro sgx_set_blkmap( unsigned char __far *blk_map<sgx_map_bank:sgx_map_addr>, unsigned char blocks_w<sgx_map_line_w> );
 3058                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 134; extern void __fastcall __macro sgx_set_multimap( unsigned char __far *multi_map<sgx_scr_bank:sgx_scr_addr>, unsigned char screens_w<sgx_map_scrn_w> );
 3059                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 136; extern void __fastcall sgx_draw_map( void );
 3060                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 137; extern void __fastcall sgx_scroll_map( void );
 3061                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 139; extern void __fastcall sgx_blit_map( unsigned char tile_x<map_bat_x>, unsigned char tile_y<map_bat_y>, unsigned char tile_w<map_draw_x>, unsigned char tile_h<map_draw_y> );
 3062                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 141; extern unsigned char __fastcall sgx_get_map_block( unsigned int x<map_pxl_x>, unsigned int y<map_pxl_y> );
 3063                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 143; #asm
 3064                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 144; .macro	_sgx_set_blkmap.2
 3065                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 145; stz	sgx_scr_bank
 3066                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 146; .endm
 3067                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 148; .macro	_sgx_set_multimap.2
 3068                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 149; lda	sgx_bat_width
 3069                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 150; lsr	a
 3070                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 151; sta	sgx_map_line_w
 3071                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 152; .endm
 3072                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 153; #endasm
 3073                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 155; #endif
 3074                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 157; #endif // __HUCC__
 3075                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 159; #endif // _hucc_blkmap_h
 3076                        		.dbg	line,	"include\routines_LEVELS.c", 13; void hide_LEVEL_SPRITES()
 3077                        		.dbg	line,	"include\routines_LEVELS.c", 14; {
 3078                        	;***********************
 3079                        	;***********************
 3080                        	
 3081                        		.hucc
 3082    11:C959             		.proc		_hide_LEVEL_SPRITES
 3083                        		__enter		_hide_LEVEL_SPRITES
 3084                        	
 3085                        		.dbg	line,	"include\routines_LEVELS.c", 15; char i;
 3086                        	
 3087                        		.dbg	line,	"include\routines_LEVELS.c", 17; for(i=0 ; i<64 ; i++)
 3088                        		__st.umiq	0, __hide_LEVEL_SPRITES_end - 1  /* i */
         11:C959  9C 3F 26   			stz	__hide_LEVEL_SPRITES_end - 1
 3089    11:C95C             	.LL3:
 3090                        		__ld.umq	__hide_LEVEL_SPRITES_end - 1  /* i */
         11:C95C  AD 3F 26   			lda	__hide_LEVEL_SPRITES_end - 1
 3091                        		__ult_b.uiq	64
         11:C95F  C9 40      			cmp	#64		; Subtract integer from A.
         11:C961  6A         			ror	a		; CC if A < integer.
         11:C962  49 80      			eor	#$80
         11:C964  2A         			rol	a
 3092                        		__btrue		.LL5
         11:C965  B0 07      			bcs	.LL5
 3093                        		__bra		.LL6
         11:C967  80 10      			bra	.LL6
 3094    11:C969             	.LL4:
 3095                        		__inc.umq	__hide_LEVEL_SPRITES_end - 1  /* i */
         11:C969  EE 3F 26   			inc	__hide_LEVEL_SPRITES_end - 1
 3096                        		__bra		.LL3
         11:C96C  80 EE      			bra	.LL3
 3097    11:C96E             	.LL5:
 3098                        	
 3099                        		.dbg	line,	"include\routines_LEVELS.c", 18; {
 3100                        	
 3101                        		.dbg	line,	"include\routines_LEVELS.c", 19; spr_set(i);
 3102                        		__ld.umq	__hide_LEVEL_SPRITES_end - 1  /* i */
         11:C96E  AD 3F 26   			lda	__hide_LEVEL_SPRITES_end - 1
 3103                        		__call		_spr_set.1
         11:C971  20 DD E7   			call	_spr_set.1
 3104                        	
 3105                        		.dbg	line,	"include\routines_LEVELS.c", 20; spr_hide();
 3106                        		__call		_spr_hide
         11:C974  20 F8 E7   			call	_spr_hide
 3107                        	
 3108                        		.dbg	line,	"include\routines_LEVELS.c", 21; }
 3109                        		__bra		.LL4
         11:C977  80 F0      			bra	.LL4
 3110    11:C979             	.LL6:
 3111                        	
 3112                        		.dbg	line,	"include\routines_LEVELS.c", 22; }
 3113    11:C979             	.LL2:
 3114                        		__return	0
         11:C979  4C EF FF   			jmp	leave_proc
 3115                        		.dbg	clear
 3116                        		.endp
 3117                        		.pceas
 3118                        	
 3119                        		.dbg	line,	"include\routines_LEVELS.c", 27; void display_LIFE()
 3120                        		.dbg	line,	"include\routines_LEVELS.c", 28; {
 3121                        	;***********************
 3122                        	;***********************
 3123                        	
 3124                        		.hucc
 3125                        		.proc		_display_LIFE
 3134                        		.endp
 3135                        		.pceas
 3136                        	
 3137                        		.dbg	line,	"include\routines_LEVELS.c", 33; void display_SCORE()
 3138                        		.dbg	line,	"include\routines_LEVELS.c", 34; {
 3139                        	;***********************
 3140                        	;***********************
 3141                        	
 3142                        		.hucc
 3143    11:C99A             		.proc		_display_SCORE
 3144                        		__enter		_display_SCORE
 3145                        	
 3146                        		.dbg	line,	"include\routines_LEVELS.c", 35; put_number(score,6,14,1);
 3147                        		__ld.wm		_score
         11:C99A  AD 24 26   			lda.l	_score
         11:C99D  AC 25 26   			ldy.h	_score
 3148                        		__st.wmq	_bx
         11:C9A0  85 FA      			sta.l	_bx
         11:C9A2  84 FB      			sty.h	_bx
 3149                        		__st.umiq	6, _cl
         11:C9A4  A9 06      			lda.l	#6
         11:C9A6  85 FC      			sta	_cl
 3150                        		__st.umiq	14, _dil
         11:C9A8  A9 0E      			lda.l	#14
         11:C9AA  85 F0      			sta	_dil
 3151                        		__st.umiq	1, _dih
         11:C9AC  A9 01      			lda.l	#1
         11:C9AE  85 F1      			sta	_dih
 3152                        		__call		_put_number.4
         11:C9B0  20 9F FF   			call	_put_number.4
 3153                        	
 3154                        		.dbg	line,	"include\routines_LEVELS.c", 36; }
 3155    11:C9B3             	.LL8:
 3156                        		__return	0
         11:C9B3  4C EF FF   			jmp	leave_proc
 3157                        		.dbg	clear
 3158                        		.endp
 3159                        		.pceas
 3160                        	
 3161                        		.dbg	line,	"include\routines_LEVELS.c", 39; void display_TIME()
 3162                        		.dbg	line,	"include\routines_LEVELS.c", 40; {
 3163                        	;***********************
 3164                        	;***********************
 3165                        	
 3166                        		.hucc
 3167    11:C32E             		.proc		_display_TIME
 3168                        		__enter		_display_TIME
 3169                        	
 3170                        		.dbg	line,	"include\routines_LEVELS.c", 41; put_number(minutes,1,1,3);
 3171                        		__ld.um		_minutes
         11:C32E  AD 22 23   			lda	_minutes
         11:C331  C2         			cly
 3172                        		__st.wmq	_bx
         11:C332  85 FA      			sta.l	_bx
         11:C334  84 FB      			sty.h	_bx
 3173                        		__st.umiq	1, _cl
         11:C336  A9 01      			lda.l	#1
         11:C338  85 FC      			sta	_cl
 3174                        		__st.umiq	1, _dil
         11:C33A  A9 01      			lda.l	#1
         11:C33C  85 F0      			sta	_dil
 3175                        		__st.umiq	3, _dih
         11:C33E  A9 03      			lda.l	#3
         11:C340  85 F1      			sta	_dih
 3176                        		__call		_put_number.4
         11:C342  20 9F FF   			call	_put_number.4
 3177                        	
 3178                        		.dbg	line,	"include\routines_LEVELS.c", 43; if(seconds < 10)
 3179                        		__ld.umq	_seconds
         11:C345  AD 23 23   			lda	_seconds
 3180                        		__ult_b.uiq	10
         11:C348  C9 0A      			cmp	#10		; Subtract integer from A.
         11:C34A  6A         			ror	a		; CC if A < integer.
         11:C34B  49 80      			eor	#$80
         11:C34D  2A         			rol	a
 3181                        		__bfalse	.LL10
         11:C34E  90 2C      			bcc	.LL10
 3182                        	
 3183                        		.dbg	line,	"include\routines_LEVELS.c", 44; {
 3184                        	
 3185                        		.dbg	line,	"include\routines_LEVELS.c", 45; put_number(0,1,3,3);
 3186                        		__st.wmiq	0, _bx
         11:C350  64 FA      			stz.l	_bx
         11:C352  64 FB      			stz.h	_bx
 3187                        		__st.umiq	1, _cl
         11:C354  A9 01      			lda.l	#1
         11:C356  85 FC      			sta	_cl
 3188                        		__st.umiq	3, _dil
         11:C358  A9 03      			lda.l	#3
         11:C35A  85 F0      			sta	_dil
 3189                        		__st.umiq	3, _dih
         11:C35C  A9 03      			lda.l	#3
         11:C35E  85 F1      			sta	_dih
 3190                        		__call		_put_number.4
         11:C360  20 9F FF   			call	_put_number.4
 3191                        	
 3192                        		.dbg	line,	"include\routines_LEVELS.c", 46; put_number(seconds,1,4,3);
 3193                        		__ld.um		_seconds
         11:C363  AD 23 23   			lda	_seconds
         11:C366  C2         			cly
 3194                        		__st.wmq	_bx
         11:C367  85 FA      			sta.l	_bx
         11:C369  84 FB      			sty.h	_bx
 3195                        		__st.umiq	1, _cl
         11:C36B  A9 01      			lda.l	#1
         11:C36D  85 FC      			sta	_cl
 3196                        		__st.umiq	4, _dil
         11:C36F  A9 04      			lda.l	#4
         11:C371  85 F0      			sta	_dil
 3197                        		__st.umiq	3, _dih
         11:C373  A9 03      			lda.l	#3
         11:C375  85 F1      			sta	_dih
 3198                        		__call		_put_number.4
         11:C377  20 9F FF   			call	_put_number.4
 3199                        	
 3200                        		.dbg	line,	"include\routines_LEVELS.c", 47; }
 3201                        	
 3202                        		.dbg	line,	"include\routines_LEVELS.c", 49; else
 3203                        		__bra		.LL11
         11:C37A  80 17      			bra	.LL11
 3204    11:C37C             	.LL10:
 3205                        	
 3206                        		.dbg	line,	"include\routines_LEVELS.c", 50; {
 3207                        	
 3208                        		.dbg	line,	"include\routines_LEVELS.c", 51; put_number(seconds,2,3,3);
 3209                        		__ld.um		_seconds
         11:C37C  AD 23 23   			lda	_seconds
         11:C37F  C2         			cly
 3210                        		__st.wmq	_bx
         11:C380  85 FA      			sta.l	_bx
         11:C382  84 FB      			sty.h	_bx
 3211                        		__st.umiq	2, _cl
         11:C384  A9 02      			lda.l	#2
         11:C386  85 FC      			sta	_cl
 3212                        		__st.umiq	3, _dil
         11:C388  A9 03      			lda.l	#3
         11:C38A  85 F0      			sta	_dil
 3213                        		__st.umiq	3, _dih
         11:C38C  A9 03      			lda.l	#3
         11:C38E  85 F1      			sta	_dih
 3214                        		__call		_put_number.4
         11:C390  20 9F FF   			call	_put_number.4
 3215                        	
 3216                        		.dbg	line,	"include\routines_LEVELS.c", 52; }
 3217    11:C393             	.LL11:
 3218                        	
 3219                        		.dbg	line,	"include\routines_LEVELS.c", 54; time_counter += 1;
 3220                        		__add_st.umiq	1, _time_counter
         11:C393  EE 24 23   			inc	_time_counter
 3221                        	
 3222                        		.dbg	line,	"include\routines_LEVELS.c", 56; if(time_counter == 60)
 3223                        		__ld.umq	_time_counter
         11:C396  AD 24 23   			lda	_time_counter
 3224                        		__equ_b.uiq	60
         11:C399  C9 3C      			cmp	#60
         11:C39B  F0 01      			beq	!+
         11:C39D  18         			clc
         11:C39E             	!:
 3225                        		__bfalse	.LL12
         11:C39E  90 28      			bcc	.LL12
 3226                        	
 3227                        		.dbg	line,	"include\routines_LEVELS.c", 57; {
 3228                        	
 3229                        		.dbg	line,	"include\routines_LEVELS.c", 58; time_counter = 0;
 3230                        		__st.umiq	0, _time_counter
         11:C3A0  9C 24 23   			stz	_time_counter
 3231                        	
 3232                        		.dbg	line,	"include\routines_LEVELS.c", 60; if(seconds > 0)
 3233                        		__ld.umq	_seconds
         11:C3A3  AD 23 23   			lda	_seconds
 3234                        		__ugt_b.uiq	0
         11:C3A6  18         			clc			; Subtract integer+1 from A.
         11:C3A7  E9 00      			sbc	#0		; CS if A > integer.
 3235                        		__bfalse	.LL13
         11:C3A9  90 05      			bcc	.LL13
 3236                        	
 3237                        		.dbg	line,	"include\routines_LEVELS.c", 61; {
 3238                        	
 3239                        		.dbg	line,	"include\routines_LEVELS.c", 62; seconds -= 1;
 3240                        		__sub_st.umiq	1, _seconds
         11:C3AB  CE 23 23   			dec	_seconds
 3241                        	
 3242                        		.dbg	line,	"include\routines_LEVELS.c", 63; }
 3243                        	
 3244                        		.dbg	line,	"include\routines_LEVELS.c", 65; else
 3245                        		__bra		.LL14
         11:C3AE  80 18      			bra	.LL14
 3246    11:C3B0             	.LL13:
 3247                        	
 3248                        		.dbg	line,	"include\routines_LEVELS.c", 66; {
 3249                        	
 3250                        		.dbg	line,	"include\routines_LEVELS.c", 67; if(minutes > 0)
 3251                        		__ld.umq	_minutes
         11:C3B0  AD 22 23   			lda	_minutes
 3252                        		__ugt_b.uiq	0
         11:C3B3  18         			clc			; Subtract integer+1 from A.
         11:C3B4  E9 00      			sbc	#0		; CS if A > integer.
 3253                        		__bfalse	.LL15
         11:C3B6  90 0A      			bcc	.LL15
 3254                        	
 3255                        		.dbg	line,	"include\routines_LEVELS.c", 68; {
 3256                        	
 3257                        		.dbg	line,	"include\routines_LEVELS.c", 69; seconds = 59;
 3258                        		__st.umiq	59, _seconds
         11:C3B8  A9 3B      			lda.l	#59
         11:C3BA  8D 23 23   			sta	_seconds
 3259                        	
 3260                        		.dbg	line,	"include\routines_LEVELS.c", 70; minutes -= 1;
 3261                        		__sub_st.umiq	1, _minutes
         11:C3BD  CE 22 23   			dec	_minutes
 3262                        	
 3263                        		.dbg	line,	"include\routines_LEVELS.c", 71; }
 3264                        	
 3265                        		.dbg	line,	"include\routines_LEVELS.c", 73; else
 3266                        		__bra		.LL16
         11:C3C0  80 06      			bra	.LL16
 3267    11:C3C2             	.LL15:
 3268                        	
 3269                        		.dbg	line,	"include\routines_LEVELS.c", 74; {
 3270                        	
 3271                        		.dbg	line,	"include\routines_LEVELS.c", 75; seconds = 0;
 3272                        		__st.umiq	0, _seconds
         11:C3C2  9C 23 23   			stz	_seconds
 3273                        	
 3274                        		.dbg	line,	"include\routines_LEVELS.c", 76; minutes = 0;
 3275                        		__st.umiq	0, _minutes
         11:C3C5  9C 22 23   			stz	_minutes
 3276                        	
 3277                        		.dbg	line,	"include\routines_LEVELS.c", 77; // TIME OUT //
 3278                        	
 3279                        		.dbg	line,	"include\routines_LEVELS.c", 78; }
 3280    11:C3C8             	.LL16:
 3281                        	
 3282                        		.dbg	line,	"include\routines_LEVELS.c", 79; }
 3283    11:C3C8             	.LL14:
 3284                        	
 3285                        		.dbg	line,	"include\routines_LEVELS.c", 80; }
 3286                        	
 3287                        		.dbg	line,	"include\routines_LEVELS.c", 81; 
 3288                        	
 3289                        		.dbg	line,	"include\routines_LEVELS.c", 82; }
 3290    11:C3C8             	.LL12:
 3291    11:C3C8             	.LL9:
 3292                        		__return	0
         11:C3C8  4C EF FF   			jmp	leave_proc
 3293                        		.dbg	clear
 3294                        		.endp
 3295                        		.pceas
 3296                        	
 3297                        		.dbg	line,	"include\routines_LEVELS.c", 85; void display_KEY()
 3298                        		.dbg	line,	"include\routines_LEVELS.c", 86; {
 3299                        	;***********************
 3300                        	;***********************
 3301                        	
 3302                        		.hucc
 3303    11:C9EE             		.proc		_display_KEY
 3304                        		__enter		_display_KEY
 3305                        	
 3306                        		.dbg	line,	"include\routines_LEVELS.c", 87; put_number(key_amount,2,7,27);
 3307                        		__ld.um		_key_amount
         11:C9EE  AD 20 23   			lda	_key_amount
         11:C9F1  C2         			cly
 3308                        		__st.wmq	_bx
         11:C9F2  85 FA      			sta.l	_bx
         11:C9F4  84 FB      			sty.h	_bx
 3309                        		__st.umiq	2, _cl
         11:C9F6  A9 02      			lda.l	#2
         11:C9F8  85 FC      			sta	_cl
 3310                        		__st.umiq	7, _dil
         11:C9FA  A9 07      			lda.l	#7
         11:C9FC  85 F0      			sta	_dil
 3311                        		__st.umiq	27, _dih
         11:C9FE  A9 1B      			lda.l	#27
         11:CA00  85 F1      			sta	_dih
 3312                        		__call		_put_number.4
         11:CA02  20 9F FF   			call	_put_number.4
 3313                        	
 3314                        		.dbg	line,	"include\routines_LEVELS.c", 88; }
 3315    11:CA05             	.LL17:
 3316                        		__return	0
         11:CA05  4C EF FF   			jmp	leave_proc
 3317                        		.dbg	clear
 3318                        		.endp
 3319                        		.pceas
 3320                        	
 3321                        		.dbg	line,	"include\routines_LEVELS.c", 91; void display_POTION()
 3322                        		.dbg	line,	"include\routines_LEVELS.c", 92; {
 3323                        	;***********************
 3324                        	;***********************
 3325                        	
 3326                        		.hucc
 3327    11:CA08             		.proc		_display_POTION
 3328                        		__enter		_display_POTION
 3329                        	
 3330                        		.dbg	line,	"include\routines_LEVELS.c", 93; put_number(potion_amount,2,19,27);
 3331                        		__ld.um		_potion_amount
         11:CA08  AD 21 23   			lda	_potion_amount
         11:CA0B  C2         			cly
 3332                        		__st.wmq	_bx
         11:CA0C  85 FA      			sta.l	_bx
         11:CA0E  84 FB      			sty.h	_bx
 3333                        		__st.umiq	2, _cl
         11:CA10  A9 02      			lda.l	#2
         11:CA12  85 FC      			sta	_cl
 3334                        		__st.umiq	19, _dil
         11:CA14  A9 13      			lda.l	#19
         11:CA16  85 F0      			sta	_dil
 3335                        		__st.umiq	27, _dih
         11:CA18  A9 1B      			lda.l	#27
         11:CA1A  85 F1      			sta	_dih
 3336                        		__call		_put_number.4
         11:CA1C  20 9F FF   			call	_put_number.4
 3337                        	
 3338                        		.dbg	line,	"include\routines_LEVELS.c", 94; }
 3339    11:CA1F             	.LL18:
 3340                        		__return	0
         11:CA1F  4C EF FF   			jmp	leave_proc
 3341                        		.dbg	clear
 3342                        		.endp
 3343                        		.pceas
 3344                        	
 3345                        		.dbg	line,	"include\routines_LEVELS.c", 97; void display_ZENNY()
 3346                        		.dbg	line,	"include\routines_LEVELS.c", 98; {
 3347                        	;***********************
 3348                        	;***********************
 3349                        	
 3350                        		.hucc
 3351    11:C9B6             		.proc		_display_ZENNY
 3352                        		__enter		_display_ZENNY
 3353                        	
 3354                        		.dbg	line,	"include\routines_LEVELS.c", 99; put_number(zenny_amount,5,26,4);
 3355                        		__ld.wm		_zenny_amount
         11:C9B6  AD 22 26   			lda.l	_zenny_amount
         11:C9B9  AC 23 26   			ldy.h	_zenny_amount
 3356                        		__st.wmq	_bx
         11:C9BC  85 FA      			sta.l	_bx
         11:C9BE  84 FB      			sty.h	_bx
 3357                        		__st.umiq	5, _cl
         11:C9C0  A9 05      			lda.l	#5
         11:C9C2  85 FC      			sta	_cl
 3358                        		__st.umiq	26, _dil
         11:C9C4  A9 1A      			lda.l	#26
         11:C9C6  85 F0      			sta	_dil
 3359                        		__st.umiq	4, _dih
         11:C9C8  A9 04      			lda.l	#4
         11:C9CA  85 F1      			sta	_dih
 3360                        		__call		_put_number.4
         11:C9CC  20 9F FF   			call	_put_number.4
 3361                        	
 3362                        		.dbg	line,	"include\routines_LEVELS.c", 100; }
 3363    11:C9CF             	.LL19:
 3364                        		__return	0
         11:C9CF  4C EF FF   			jmp	leave_proc
 3365                        		.dbg	clear
 3366                        		.endp
 3367                        		.pceas
 3368                        	
 3369                        		.dbg	line,	"include\routines_LEVELS.c", 105; void scroll_object()
 3370                        		.dbg	line,	"include\routines_LEVELS.c", 106; {
 3371                        	;***********************
 3372                        	;***********************
 3373                        	
 3374                        		.hucc
 3375    02:D770             		.proc		_scroll_object
 3376                        		__enter		_scroll_object
 3377                        	
 3378                        		.dbg	line,	"include\routines_LEVELS.c", 107; char i;
 3379                        	
 3380                        		.dbg	line,	"include\routines_LEVELS.c", 108; onscreen_object_number = 0;
 3381                        		__st.umiq	0, _onscreen_object_number
         02:D770  9C 27 23   			stz	_onscreen_object_number
 3382                        	
 3383                        		.dbg	line,	"include\routines_LEVELS.c", 110; for(i=0 ; i<level_object_number ; i++)
 3384                        		__st.umiq	0, __scroll_object_end - 1  /* i */
         02:D773  9C 3F 26   			stz	__scroll_object_end - 1
 3385    02:D776             	.LL21:
 3386                        		__ld.umq	__scroll_object_end - 1  /* i */
         02:D776  AD 3F 26   			lda	__scroll_object_end - 1
 3387                        		__ult_b.umq	_level_object_number
         02:D779  CD 26 23   			cmp	_level_object_number		; Subtract memory from A.
         02:D77C  6A         			ror	a		; CC if A < memory.
         02:D77D  49 80      			eor	#$80
         02:D77F  2A         			rol	a
 3388                        		__btrue		.LL23
         02:D780  B0 08      			bcs	.LL23
 3389                        		__bra		.LL24
         02:D782  4C D4 D8   			bra	.LL24
 3390    02:D785             	.LL22:
 3391                        		__inc.umq	__scroll_object_end - 1  /* i */
         02:D785  EE 3F 26   			inc	__scroll_object_end - 1
 3392                        		__bra		.LL21
         02:D788  80 EC      			bra	.LL21
 3393    02:D78A             	.LL23:
 3394                        	
 3395                        		.dbg	line,	"include\routines_LEVELS.c", 111; {
 3396                        	
 3397                        		.dbg	line,	"include\routines_LEVELS.c", 112; if(list_object_state[i] != STATE_INACTIVE)
 3398                        		__ldx.umq	__scroll_object_end - 1  /* i */
         02:D78A  AE 3F 26   			ldx	__scroll_object_end - 1
 3399                        		__ld.uaxq	_list_object_state
         02:D78D  BD 41 23   			lda	_list_object_state, x
 3400                        		__neq_b.uiq	1
         02:D790  38         			sec
         02:D791  49 01      			eor	#1
         02:D793  D0 01      			bne	!+
         02:D795  18         			clc
         02:D796             	!:
 3401                        		__bfalse	.LL25
         02:D796  90 ED      			bcc	.LL25
 3402                        	
 3403                        		.dbg	line,	"include\routines_LEVELS.c", 113; {
 3404                        	
 3405                        		.dbg	line,	"include\routines_LEVELS.c", 114; char scroll_allowed = FALSE;
 3406                        		__st.umiq	0, __scroll_object_end - 2  /* scroll_allowed */
         02:D798  9C 3E 26   			stz	__scroll_object_end - 2
 3407                        	
 3408                        		.dbg	line,	"include\routines_LEVELS.c", 115; 
 3409                        	
 3410                        		.dbg	line,	"include\routines_LEVELS.c", 116; // IF OBJECT X POSITION IS INFERIOR TO SCREEN RIGHT SIDE //
 3411                        	
 3412                        		.dbg	line,	"include\routines_LEVELS.c", 117; if(list_object_x_pos_ref[i] < sgx_map_pxl_x + 256)
 3413                        		__ld.wm		_sgx_map_pxl_x
         02:D79B  AD 84 26   			lda.l	_sgx_map_pxl_x
         02:D79E  AC 85 26   			ldy.h	_sgx_map_pxl_x
 3414                        		__add.wi	256
         02:D7A1  18         			clc
         02:D7A2  69 00      			adc.l	#256
         02:D7A4  42         			say
         02:D7A5  69 01      			adc.h	#256
         02:D7A7  42         			say
 3415                        		__ld2x.um	__scroll_object_end - 1  /* i */
         02:D7A8  AA         			tax
         02:D7A9  AD 3F 26   			lda	__scroll_object_end - 1
         02:D7AC  0A         			asl	a
         02:D7AD  22         			sax
 3416                        		__ugt_w.wax	_list_object_x_pos_ref
         02:D7AE  18         			clc			; Subtract memory+1 from Y:A.
         02:D7AF  FD 36 25   			sbc.l	_list_object_x_pos_ref, x
         02:D7B2  98         			tya
         02:D7B3  FD 37 25   			sbc.h	_list_object_x_pos_ref, x		; CS if Y:A > memory.
 3417                        		__bfalse	.LL26
         02:D7B6  B0 03 4C 3B			bcc	.LL26
         02:D7BA  D8          
 3418                        	
 3419                        		.dbg	line,	"include\routines_LEVELS.c", 118; {
 3420                        	
 3421                        		.dbg	line,	"include\routines_LEVELS.c", 119; // IF OBJECT X POSITION IS SUPERIOR TO SCREEN LEFT SIDE PLUS 16 PX //
 3422                        	
 3423                        		.dbg	line,	"include\routines_LEVELS.c", 120; if(list_object_x_pos_ref[i] - sgx_map_pxl_x + 16 > 0)
 3424                        		__ld2x.umq	__scroll_object_end - 1  /* i */
         02:D7BB  AD 3F 26   			lda	__scroll_object_end - 1
         02:D7BE  0A         			asl	a
         02:D7BF  AA         			tax
 3425                        		__ld.wax	_list_object_x_pos_ref
         02:D7C0  BD 36 25   			lda.l	_list_object_x_pos_ref, x
         02:D7C3  BC 37 25   			ldy.h	_list_object_x_pos_ref, x
 3426                        		__sub.wm	_sgx_map_pxl_x
         02:D7C6  38         			sec
         02:D7C7  ED 84 26   			sbc.l	_sgx_map_pxl_x
         02:D7CA  42         			say
         02:D7CB  ED 85 26   			sbc.h	_sgx_map_pxl_x
         02:D7CE  42         			say
 3427                        		__add.wi	16
         02:D7CF  18         			clc
         02:D7D0  69 10      			adc.l	#16
         02:D7D2  90 01      			bcc	!+
         02:D7D4  C8         			iny
         02:D7D5             	!:
 3428                        		__sgt_w.wi	0
         02:D7D5  18         			clc			; Subtract integer+1 from Y:A.
         02:D7D6  E9 00      			sbc.l	#0
         02:D7D8  98         			tya
         02:D7D9  E9 00      			sbc.h	#0
         02:D7DB  50 02      			bvc	!+
         02:D7DD  49 80      			eor	#$80		; +ve if Y:A > integer (signed).
         02:D7DF  49 80      	!:		eor	#$80
         02:D7E1  0A         			asl	a
 3429                        		__bfalse	.LL27
         02:D7E2  90 57      			bcc	.LL27
 3430                        	
 3431                        		.dbg	line,	"include\routines_LEVELS.c", 121; {
 3432                        	
 3433                        		.dbg	line,	"include\routines_LEVELS.c", 122; // IF OBJECT Y POSITION IS INFERIOR TO SCREEN BOTTOM //
 3434                        	
 3435                        		.dbg	line,	"include\routines_LEVELS.c", 123; if(list_object_y_pos_ref[i] < sgx_map_pxl_y + 224)
 3436                        		__ld.wm		_sgx_map_pxl_y
         02:D7E4  AD 86 26   			lda.l	_sgx_map_pxl_y
         02:D7E7  AC 87 26   			ldy.h	_sgx_map_pxl_y
 3437                        		__add.wi	224
         02:D7EA  18         			clc
         02:D7EB  69 E0      			adc.l	#224
         02:D7ED  90 01      			bcc	!+
         02:D7EF  C8         			iny
         02:D7F0             	!:
 3438                        		__ld2x.um	__scroll_object_end - 1  /* i */
         02:D7F0  AA         			tax
         02:D7F1  AD 3F 26   			lda	__scroll_object_end - 1
         02:D7F4  0A         			asl	a
         02:D7F5  22         			sax
 3439                        		__ugt_w.wax	_list_object_y_pos_ref
         02:D7F6  18         			clc			; Subtract memory+1 from Y:A.
         02:D7F7  FD 68 25   			sbc.l	_list_object_y_pos_ref, x
         02:D7FA  98         			tya
         02:D7FB  FD 69 25   			sbc.h	_list_object_y_pos_ref, x		; CS if Y:A > memory.
 3440                        		__bfalse	.LL28
         02:D7FE  90 3B      			bcc	.LL28
 3441                        	
 3442                        		.dbg	line,	"include\routines_LEVELS.c", 124; {
 3443                        	
 3444                        		.dbg	line,	"include\routines_LEVELS.c", 125; // IF OBJECT Y POSITION IS SUPERIOR TO SCREEN TOP PLUS 16 PX //
 3445                        	
 3446                        		.dbg	line,	"include\routines_LEVELS.c", 126; if(list_object_y_pos_ref[i] - sgx_map_pxl_y + 16 > 0)
 3447                        		__ld2x.umq	__scroll_object_end - 1  /* i */
         02:D800  AD 3F 26   			lda	__scroll_object_end - 1
         02:D803  0A         			asl	a
         02:D804  AA         			tax
 3448                        		__ld.wax	_list_object_y_pos_ref
         02:D805  BD 68 25   			lda.l	_list_object_y_pos_ref, x
         02:D808  BC 69 25   			ldy.h	_list_object_y_pos_ref, x
 3449                        		__sub.wm	_sgx_map_pxl_y
         02:D80B  38         			sec
         02:D80C  ED 86 26   			sbc.l	_sgx_map_pxl_y
         02:D80F  42         			say
         02:D810  ED 87 26   			sbc.h	_sgx_map_pxl_y
         02:D813  42         			say
 3450                        		__add.wi	16
         02:D814  18         			clc
         02:D815  69 10      			adc.l	#16
         02:D817  90 01      			bcc	!+
         02:D819  C8         			iny
         02:D81A             	!:
 3451                        		__sgt_w.wi	0
         02:D81A  18         			clc			; Subtract integer+1 from Y:A.
         02:D81B  E9 00      			sbc.l	#0
         02:D81D  98         			tya
         02:D81E  E9 00      			sbc.h	#0
         02:D820  50 02      			bvc	!+
         02:D822  49 80      			eor	#$80		; +ve if Y:A > integer (signed).
         02:D824  49 80      	!:		eor	#$80
         02:D826  0A         			asl	a
 3452                        		__bfalse	.LL29
         02:D827  90 12      			bcc	.LL29
 3453                        	
 3454                        		.dbg	line,	"include\routines_LEVELS.c", 127; {
 3455                        	
 3456                        		.dbg	line,	"include\routines_LEVELS.c", 128; // WE STORE THE OBJECT ID //
 3457                        	
 3458                        		.dbg	line,	"include\routines_LEVELS.c", 129; //put_number(i,2,0,2+onscreen_object_number);
 3459                        	
 3460                        		.dbg	line,	"include\routines_LEVELS.c", 130; list_onscreen_object[onscreen_object_number] = i;
 3461                        		__ldx.umq	_onscreen_object_number
         02:D829  AE 27 23   			ldx	_onscreen_object_number
 3462                        		__ld.um		__scroll_object_end - 1  /* i */
         02:D82C  AD 3F 26   			lda	__scroll_object_end - 1
         02:D82F  C2         			cly
 3463                        		__st.uaxq	_list_onscreen_object
         02:D830  9D 8C 23   			sta	_list_onscreen_object, x
 3464                        	
 3465                        		.dbg	line,	"include\routines_LEVELS.c", 131; onscreen_object_number += 1;
 3466                        		__add_st.umiq	1, _onscreen_object_number
         02:D833  EE 27 23   			inc	_onscreen_object_number
 3467                        	
 3468                        		.dbg	line,	"include\routines_LEVELS.c", 132; 
 3469                        	
 3470                        		.dbg	line,	"include\routines_LEVELS.c", 133; //list_object_visibility[i] = ON_SCREEN;
 3471                        	
 3472                        		.dbg	line,	"include\routines_LEVELS.c", 134; scroll_allowed = TRUE;
 3473                        		__st.umiq	1, __scroll_object_end - 2  /* scroll_allowed */
         02:D836  A9 01      			lda.l	#1
         02:D838  8D 3E 26   			sta	__scroll_object_end - 2
 3474                        	
 3475                        		.dbg	line,	"include\routines_LEVELS.c", 135; }
 3476                        	
 3477                        		.dbg	line,	"include\routines_LEVELS.c", 136; }
 3478    02:D83B             	.LL29:
 3479                        	
 3480                        		.dbg	line,	"include\routines_LEVELS.c", 137; }
 3481    02:D83B             	.LL28:
 3482                        	
 3483                        		.dbg	line,	"include\routines_LEVELS.c", 138; }
 3484    02:D83B             	.LL27:
 3485                        	
 3486                        		.dbg	line,	"include\routines_LEVELS.c", 140; // IF OBJECTS IS WITHIN THE SCREEN LIMITS //
 3487                        	
 3488                        		.dbg	line,	"include\routines_LEVELS.c", 141; if(scroll_allowed == TRUE)
 3489    02:D83B             	.LL26:
 3490                        		__ld.umq	__scroll_object_end - 2  /* scroll_allowed */
         02:D83B  AD 3E 26   			lda	__scroll_object_end - 2
 3491                        		__equ_b.uiq	1
         02:D83E  C9 01      			cmp	#1
         02:D840  F0 01      			beq	!+
         02:D842  18         			clc
         02:D843             	!:
 3492                        		__bfalse	.LL30
         02:D843  90 44      			bcc	.LL30
 3493                        	
 3494                        		.dbg	line,	"include\routines_LEVELS.c", 142; {
 3495                        	
 3496                        		.dbg	line,	"include\routines_LEVELS.c", 143; list_object_x_pos[i] = list_object_x_pos_ref[i] - sgx_map_pxl_x;
 3497                        		__ld2x.umq	__scroll_object_end - 1  /* i */
         02:D845  AD 3F 26   			lda	__scroll_object_end - 1
         02:D848  0A         			asl	a
         02:D849  AA         			tax
 3498                        		__ld.wax	_list_object_x_pos_ref
         02:D84A  BD 36 25   			lda.l	_list_object_x_pos_ref, x
         02:D84D  BC 37 25   			ldy.h	_list_object_x_pos_ref, x
 3499                        		__sub.wm	_sgx_map_pxl_x
         02:D850  38         			sec
         02:D851  ED 84 26   			sbc.l	_sgx_map_pxl_x
         02:D854  42         			say
         02:D855  ED 85 26   			sbc.h	_sgx_map_pxl_x
         02:D858  42         			say
 3500                        		__ld2x.um	__scroll_object_end - 1  /* i */
         02:D859  AA         			tax
         02:D85A  AD 3F 26   			lda	__scroll_object_end - 1
         02:D85D  0A         			asl	a
         02:D85E  22         			sax
 3501                        		__st.waxq	_list_object_x_pos
         02:D85F  9D D2 24   			sta.l	_list_object_x_pos, x
         02:D862  98         			tya
         02:D863  9D D3 24   			sta.h	_list_object_x_pos, x
 3502                        	
 3503                        		.dbg	line,	"include\routines_LEVELS.c", 144; list_object_y_pos[i] = list_object_y_pos_ref[i] - sgx_map_pxl_y;
 3504                        		__ld2x.umq	__scroll_object_end - 1  /* i */
         02:D866  AD 3F 26   			lda	__scroll_object_end - 1
         02:D869  0A         			asl	a
         02:D86A  AA         			tax
 3505                        		__ld.wax	_list_object_y_pos_ref
         02:D86B  BD 68 25   			lda.l	_list_object_y_pos_ref, x
         02:D86E  BC 69 25   			ldy.h	_list_object_y_pos_ref, x
 3506                        		__sub.wm	_sgx_map_pxl_y
         02:D871  38         			sec
         02:D872  ED 86 26   			sbc.l	_sgx_map_pxl_y
         02:D875  42         			say
         02:D876  ED 87 26   			sbc.h	_sgx_map_pxl_y
         02:D879  42         			say
 3507                        		__ld2x.um	__scroll_object_end - 1  /* i */
         02:D87A  AA         			tax
         02:D87B  AD 3F 26   			lda	__scroll_object_end - 1
         02:D87E  0A         			asl	a
         02:D87F  22         			sax
 3508                        		__st.waxq	_list_object_y_pos
         02:D880  9D 04 25   			sta.l	_list_object_y_pos, x
         02:D883  98         			tya
         02:D884  9D 05 25   			sta.h	_list_object_y_pos, x
 3509                        	
 3510                        		.dbg	line,	"include\routines_LEVELS.c", 145; }
 3511                        	
 3512                        		.dbg	line,	"include\routines_LEVELS.c", 147; else
 3513                        		__bra		.LL31
         02:D887  80 1E      			bra	.LL31
 3514    02:D889             	.LL30:
 3515                        	
 3516                        		.dbg	line,	"include\routines_LEVELS.c", 148; {
 3517                        	
 3518                        		.dbg	line,	"include\routines_LEVELS.c", 149; list_object_x_pos[i] = -16;
 3519                        		__ld2x.umq	__scroll_object_end - 1  /* i */
         02:D889  AD 3F 26   			lda	__scroll_object_end - 1
         02:D88C  0A         			asl	a
         02:D88D  AA         			tax
 3520                        		__st.waxiq	-16, _list_object_x_pos
         02:D88E  A9 F0      			lda.l	#-16
         02:D890  9D D2 24   			sta.l	_list_object_x_pos, x
         02:D893  A9 FF      			lda.h	#-16
         02:D895  9D D3 24   			sta.h	_list_object_x_pos, x
 3521                        	
 3522                        		.dbg	line,	"include\routines_LEVELS.c", 150; list_object_y_pos[i] = -16;
 3523                        		__ld2x.umq	__scroll_object_end - 1  /* i */
         02:D898  AD 3F 26   			lda	__scroll_object_end - 1
         02:D89B  0A         			asl	a
         02:D89C  AA         			tax
 3524                        		__st.waxiq	-16, _list_object_y_pos
         02:D89D  A9 F0      			lda.l	#-16
         02:D89F  9D 04 25   			sta.l	_list_object_y_pos, x
         02:D8A2  A9 FF      			lda.h	#-16
         02:D8A4  9D 05 25   			sta.h	_list_object_y_pos, x
 3525                        	
 3526                        		.dbg	line,	"include\routines_LEVELS.c", 151; //list_object_visibility[i] = OFF_SCREEN;
 3527                        	
 3528                        		.dbg	line,	"include\routines_LEVELS.c", 152; }
 3529    02:D8A7             	.LL31:
 3530                        	
 3531                        		.dbg	line,	"include\routines_LEVELS.c", 154; spr_set(i + object_start_index);
 3532                        		__ld.um		__scroll_object_end - 1  /* i */
         02:D8A7  AD 3F 26   			lda	__scroll_object_end - 1
         02:D8AA  C2         			cly
 3533                        		__add.um	_object_start_index
         02:D8AB  18         			clc
         02:D8AC  6D 25 23   			adc	_object_start_index
         02:D8AF  90 01      			bcc	!+
         02:D8B1  C8         			iny
         02:D8B2             	!:
 3534                        		__call		_spr_set.1
         02:D8B2  20 DD E7   			call	_spr_set.1
 3535                        	
 3536                        		.dbg	line,	"include\routines_LEVELS.c", 156; spr_x(list_object_x_pos[i]);
 3537                        		__ld2x.umq	__scroll_object_end - 1  /* i */
         02:D8B5  AD 3F 26   			lda	__scroll_object_end - 1
         02:D8B8  0A         			asl	a
         02:D8B9  AA         			tax
 3538                        		__ld.wax	_list_object_x_pos
         02:D8BA  BD D2 24   			lda.l	_list_object_x_pos, x
         02:D8BD  BC D3 24   			ldy.h	_list_object_x_pos, x
 3539                        		__call		_spr_x.1
         02:D8C0  20 0A E8   			call	_spr_x.1
 3540                        	
 3541                        		.dbg	line,	"include\routines_LEVELS.c", 157; spr_y(list_object_y_pos[i]);
 3542                        		__ld2x.umq	__scroll_object_end - 1  /* i */
         02:D8C3  AD 3F 26   			lda	__scroll_object_end - 1
         02:D8C6  0A         			asl	a
         02:D8C7  AA         			tax
 3543                        		__ld.wax	_list_object_y_pos
         02:D8C8  BD 04 25   			lda.l	_list_object_y_pos, x
         02:D8CB  BC 05 25   			ldy.h	_list_object_y_pos, x
 3544                        		__call		_spr_y.1
         02:D8CE  20 19 E8   			call	_spr_y.1
 3545                        	
 3546                        		.dbg	line,	"include\routines_LEVELS.c", 158; }
 3547                        	
 3548                        		.dbg	line,	"include\routines_LEVELS.c", 159; }
 3549    02:D8D1             	.LL25	.alias		.LL22
 3550                        		__bra		.LL22
         02:D8D1  4C 85 D7   			bra	.LL22
 3551    02:D8D4             	.LL24:
 3552                        	
 3553                        		.dbg	line,	"include\routines_LEVELS.c", 160; }
 3554    02:D8D4             	.LL20:
 3555                        		__return	0
         02:D8D4  4C EF FF   			jmp	leave_proc
 3556                        		.dbg	clear
 3557                        		.endp
 3558                        		.pceas
 3559                        	
 3560                        		.dbg	line,	"include\routines_LEVELS.c", 163; void scroll_chest()
 3561                        		.dbg	line,	"include\routines_LEVELS.c", 164; {
 3562                        	;***********************
 3563                        	;***********************
 3564                        	
 3565                        		.hucc
 3566    02:D8D7             		.proc		_scroll_chest
 3567                        		__enter		_scroll_chest
 3568                        	
 3569                        		.dbg	line,	"include\routines_LEVELS.c", 165; char i;
 3570                        	
 3571                        		.dbg	line,	"include\routines_LEVELS.c", 166; onscreen_chest_number = 0;
 3572                        		__st.umiq	0, _onscreen_chest_number
         02:D8D7  9C 96 23   			stz	_onscreen_chest_number
 3573                        	
 3574                        		.dbg	line,	"include\routines_LEVELS.c", 168; for(i=0 ; i<level_chest_number ; i++)
 3575                        		__st.umiq	0, __scroll_chest_end - 1  /* i */
         02:D8DA  9C 3F 26   			stz	__scroll_chest_end - 1
 3576    02:D8DD             	.LL33:
 3577                        		__ld.umq	__scroll_chest_end - 1  /* i */
         02:D8DD  AD 3F 26   			lda	__scroll_chest_end - 1
 3578                        		__ult_b.umq	_level_chest_number
         02:D8E0  CD 95 23   			cmp	_level_chest_number		; Subtract memory from A.
         02:D8E3  6A         			ror	a		; CC if A < memory.
         02:D8E4  49 80      			eor	#$80
         02:D8E6  2A         			rol	a
 3579                        		__btrue		.LL35
         02:D8E7  B0 08      			bcs	.LL35
 3580                        		__bra		.LL36
         02:D8E9  4C 3B DA   			bra	.LL36
 3581    02:D8EC             	.LL34:
 3582                        		__inc.umq	__scroll_chest_end - 1  /* i */
         02:D8EC  EE 3F 26   			inc	__scroll_chest_end - 1
 3583                        		__bra		.LL33
         02:D8EF  80 EC      			bra	.LL33
 3584    02:D8F1             	.LL35:
 3585                        	
 3586                        		.dbg	line,	"include\routines_LEVELS.c", 169; {
 3587                        	
 3588                        		.dbg	line,	"include\routines_LEVELS.c", 170; if(list_chest_state[i] != STATE_INACTIVE)
 3589                        		__ldx.umq	__scroll_chest_end - 1  /* i */
         02:D8F1  AE 3F 26   			ldx	__scroll_chest_end - 1
 3590                        		__ld.uaxq	_list_chest_state
         02:D8F4  BD 97 23   			lda	_list_chest_state, x
 3591                        		__neq_b.uiq	1
         02:D8F7  38         			sec
         02:D8F8  49 01      			eor	#1
         02:D8FA  D0 01      			bne	!+
         02:D8FC  18         			clc
         02:D8FD             	!:
 3592                        		__bfalse	.LL37
         02:D8FD  90 ED      			bcc	.LL37
 3593                        	
 3594                        		.dbg	line,	"include\routines_LEVELS.c", 171; {
 3595                        	
 3596                        		.dbg	line,	"include\routines_LEVELS.c", 172; char scroll_allowed = FALSE;
 3597                        		__st.umiq	0, __scroll_chest_end - 2  /* scroll_allowed */
         02:D8FF  9C 3E 26   			stz	__scroll_chest_end - 2
 3598                        	
 3599                        		.dbg	line,	"include\routines_LEVELS.c", 173; 
 3600                        	
 3601                        		.dbg	line,	"include\routines_LEVELS.c", 174; // IF CHEST X POSITION IS INFERIOR TO SCREEN RIGHT SIDE //
 3602                        	
 3603                        		.dbg	line,	"include\routines_LEVELS.c", 175; if(list_chest_x_pos_ref[i] < sgx_map_pxl_x + 256)
 3604                        		__ld.wm		_sgx_map_pxl_x
         02:D902  AD 84 26   			lda.l	_sgx_map_pxl_x
         02:D905  AC 85 26   			ldy.h	_sgx_map_pxl_x
 3605                        		__add.wi	256
         02:D908  18         			clc
         02:D909  69 00      			adc.l	#256
         02:D90B  42         			say
         02:D90C  69 01      			adc.h	#256
         02:D90E  42         			say
 3606                        		__ld2x.um	__scroll_chest_end - 1  /* i */
         02:D90F  AA         			tax
         02:D910  AD 3F 26   			lda	__scroll_chest_end - 1
         02:D913  0A         			asl	a
         02:D914  22         			sax
 3607                        		__ugt_w.wax	_list_chest_x_pos_ref
         02:D915  18         			clc			; Subtract memory+1 from Y:A.
         02:D916  FD BA 25   			sbc.l	_list_chest_x_pos_ref, x
         02:D919  98         			tya
         02:D91A  FD BB 25   			sbc.h	_list_chest_x_pos_ref, x		; CS if Y:A > memory.
 3608                        		__bfalse	.LL38
         02:D91D  B0 03 4C A2			bcc	.LL38
         02:D921  D9          
 3609                        	
 3610                        		.dbg	line,	"include\routines_LEVELS.c", 176; {
 3611                        	
 3612                        		.dbg	line,	"include\routines_LEVELS.c", 177; // IF CHEST X POSITION IS SUPERIOR TO SCREEN LEFT SIDE PLUS 32 PX //
 3613                        	
 3614                        		.dbg	line,	"include\routines_LEVELS.c", 178; if(list_chest_x_pos_ref[i] - sgx_map_pxl_x + 32 > 0)
 3615                        		__ld2x.umq	__scroll_chest_end - 1  /* i */
         02:D922  AD 3F 26   			lda	__scroll_chest_end - 1
         02:D925  0A         			asl	a
         02:D926  AA         			tax
 3616                        		__ld.wax	_list_chest_x_pos_ref
         02:D927  BD BA 25   			lda.l	_list_chest_x_pos_ref, x
         02:D92A  BC BB 25   			ldy.h	_list_chest_x_pos_ref, x
 3617                        		__sub.wm	_sgx_map_pxl_x
         02:D92D  38         			sec
         02:D92E  ED 84 26   			sbc.l	_sgx_map_pxl_x
         02:D931  42         			say
         02:D932  ED 85 26   			sbc.h	_sgx_map_pxl_x
         02:D935  42         			say
 3618                        		__add.wi	32
         02:D936  18         			clc
         02:D937  69 20      			adc.l	#32
         02:D939  90 01      			bcc	!+
         02:D93B  C8         			iny
         02:D93C             	!:
 3619                        		__sgt_w.wi	0
         02:D93C  18         			clc			; Subtract integer+1 from Y:A.
         02:D93D  E9 00      			sbc.l	#0
         02:D93F  98         			tya
         02:D940  E9 00      			sbc.h	#0
         02:D942  50 02      			bvc	!+
         02:D944  49 80      			eor	#$80		; +ve if Y:A > integer (signed).
         02:D946  49 80      	!:		eor	#$80
         02:D948  0A         			asl	a
 3620                        		__bfalse	.LL39
         02:D949  90 57      			bcc	.LL39
 3621                        	
 3622                        		.dbg	line,	"include\routines_LEVELS.c", 179; {
 3623                        	
 3624                        		.dbg	line,	"include\routines_LEVELS.c", 180; // IF CHEST Y POSITION IS INFERIOR TO SCREEN BOTTOM //
 3625                        	
 3626                        		.dbg	line,	"include\routines_LEVELS.c", 181; if(list_chest_y_pos_ref[i] < sgx_map_pxl_y + 224)
 3627                        		__ld.wm		_sgx_map_pxl_y
         02:D94B  AD 86 26   			lda.l	_sgx_map_pxl_y
         02:D94E  AC 87 26   			ldy.h	_sgx_map_pxl_y
 3628                        		__add.wi	224
         02:D951  18         			clc
         02:D952  69 E0      			adc.l	#224
         02:D954  90 01      			bcc	!+
         02:D956  C8         			iny
         02:D957             	!:
 3629                        		__ld2x.um	__scroll_chest_end - 1  /* i */
         02:D957  AA         			tax
         02:D958  AD 3F 26   			lda	__scroll_chest_end - 1
         02:D95B  0A         			asl	a
         02:D95C  22         			sax
 3630                        		__ugt_w.wax	_list_chest_y_pos_ref
         02:D95D  18         			clc			; Subtract memory+1 from Y:A.
         02:D95E  FD CA 25   			sbc.l	_list_chest_y_pos_ref, x
         02:D961  98         			tya
         02:D962  FD CB 25   			sbc.h	_list_chest_y_pos_ref, x		; CS if Y:A > memory.
 3631                        		__bfalse	.LL40
         02:D965  90 3B      			bcc	.LL40
 3632                        	
 3633                        		.dbg	line,	"include\routines_LEVELS.c", 182; {
 3634                        	
 3635                        		.dbg	line,	"include\routines_LEVELS.c", 183; // IF CHEST Y POSITION IS SUPERIOR TO SCREEN TOP PLUS 32 PX //
 3636                        	
 3637                        		.dbg	line,	"include\routines_LEVELS.c", 184; if(list_chest_y_pos_ref[i] - sgx_map_pxl_y + 32 > 0)
 3638                        		__ld2x.umq	__scroll_chest_end - 1  /* i */
         02:D967  AD 3F 26   			lda	__scroll_chest_end - 1
         02:D96A  0A         			asl	a
         02:D96B  AA         			tax
 3639                        		__ld.wax	_list_chest_y_pos_ref
         02:D96C  BD CA 25   			lda.l	_list_chest_y_pos_ref, x
         02:D96F  BC CB 25   			ldy.h	_list_chest_y_pos_ref, x
 3640                        		__sub.wm	_sgx_map_pxl_y
         02:D972  38         			sec
         02:D973  ED 86 26   			sbc.l	_sgx_map_pxl_y
         02:D976  42         			say
         02:D977  ED 87 26   			sbc.h	_sgx_map_pxl_y
         02:D97A  42         			say
 3641                        		__add.wi	32
         02:D97B  18         			clc
         02:D97C  69 20      			adc.l	#32
         02:D97E  90 01      			bcc	!+
         02:D980  C8         			iny
         02:D981             	!:
 3642                        		__sgt_w.wi	0
         02:D981  18         			clc			; Subtract integer+1 from Y:A.
         02:D982  E9 00      			sbc.l	#0
         02:D984  98         			tya
         02:D985  E9 00      			sbc.h	#0
         02:D987  50 02      			bvc	!+
         02:D989  49 80      			eor	#$80		; +ve if Y:A > integer (signed).
         02:D98B  49 80      	!:		eor	#$80
         02:D98D  0A         			asl	a
 3643                        		__bfalse	.LL41
         02:D98E  90 12      			bcc	.LL41
 3644                        	
 3645                        		.dbg	line,	"include\routines_LEVELS.c", 185; {
 3646                        	
 3647                        		.dbg	line,	"include\routines_LEVELS.c", 186; // WE STORE THE CHEST ID //
 3648                        	
 3649                        		.dbg	line,	"include\routines_LEVELS.c", 187; list_onscreen_chest[onscreen_chest_number] = i;
 3650                        		__ldx.umq	_onscreen_chest_number
         02:D990  AE 96 23   			ldx	_onscreen_chest_number
 3651                        		__ld.um		__scroll_chest_end - 1  /* i */
         02:D993  AD 3F 26   			lda	__scroll_chest_end - 1
         02:D996  C2         			cly
 3652                        		__st.uaxq	_list_onscreen_chest
         02:D997  9D 9F 23   			sta	_list_onscreen_chest, x
 3653                        	
 3654                        		.dbg	line,	"include\routines_LEVELS.c", 188; onscreen_chest_number += 1;
 3655                        		__add_st.umiq	1, _onscreen_chest_number
         02:D99A  EE 96 23   			inc	_onscreen_chest_number
 3656                        	
 3657                        		.dbg	line,	"include\routines_LEVELS.c", 189; 
 3658                        	
 3659                        		.dbg	line,	"include\routines_LEVELS.c", 190; scroll_allowed = TRUE;
 3660                        		__st.umiq	1, __scroll_chest_end - 2  /* scroll_allowed */
         02:D99D  A9 01      			lda.l	#1
         02:D99F  8D 3E 26   			sta	__scroll_chest_end - 2
 3661                        	
 3662                        		.dbg	line,	"include\routines_LEVELS.c", 191; }
 3663                        	
 3664                        		.dbg	line,	"include\routines_LEVELS.c", 192; }
 3665    02:D9A2             	.LL41:
 3666                        	
 3667                        		.dbg	line,	"include\routines_LEVELS.c", 193; }
 3668    02:D9A2             	.LL40:
 3669                        	
 3670                        		.dbg	line,	"include\routines_LEVELS.c", 194; }
 3671    02:D9A2             	.LL39:
 3672                        	
 3673                        		.dbg	line,	"include\routines_LEVELS.c", 196; // IF CHEST IS WITHIN THE SCREEN LIMITS //
 3674                        	
 3675                        		.dbg	line,	"include\routines_LEVELS.c", 197; if(scroll_allowed == TRUE)
 3676    02:D9A2             	.LL38:
 3677                        		__ld.umq	__scroll_chest_end - 2  /* scroll_allowed */
         02:D9A2  AD 3E 26   			lda	__scroll_chest_end - 2
 3678                        		__equ_b.uiq	1
         02:D9A5  C9 01      			cmp	#1
         02:D9A7  F0 01      			beq	!+
         02:D9A9  18         			clc
         02:D9AA             	!:
 3679                        		__bfalse	.LL42
         02:D9AA  90 44      			bcc	.LL42
 3680                        	
 3681                        		.dbg	line,	"include\routines_LEVELS.c", 198; {
 3682                        	
 3683                        		.dbg	line,	"include\routines_LEVELS.c", 199; list_chest_x_pos[i] = list_chest_x_pos_ref[i] - sgx_map_pxl_x;
 3684                        		__ld2x.umq	__scroll_chest_end - 1  /* i */
         02:D9AC  AD 3F 26   			lda	__scroll_chest_end - 1
         02:D9AF  0A         			asl	a
         02:D9B0  AA         			tax
 3685                        		__ld.wax	_list_chest_x_pos_ref
         02:D9B1  BD BA 25   			lda.l	_list_chest_x_pos_ref, x
         02:D9B4  BC BB 25   			ldy.h	_list_chest_x_pos_ref, x
 3686                        		__sub.wm	_sgx_map_pxl_x
         02:D9B7  38         			sec
         02:D9B8  ED 84 26   			sbc.l	_sgx_map_pxl_x
         02:D9BB  42         			say
         02:D9BC  ED 85 26   			sbc.h	_sgx_map_pxl_x
         02:D9BF  42         			say
 3687                        		__ld2x.um	__scroll_chest_end - 1  /* i */
         02:D9C0  AA         			tax
         02:D9C1  AD 3F 26   			lda	__scroll_chest_end - 1
         02:D9C4  0A         			asl	a
         02:D9C5  22         			sax
 3688                        		__st.waxq	_list_chest_x_pos
         02:D9C6  9D 9A 25   			sta.l	_list_chest_x_pos, x
         02:D9C9  98         			tya
         02:D9CA  9D 9B 25   			sta.h	_list_chest_x_pos, x
 3689                        	
 3690                        		.dbg	line,	"include\routines_LEVELS.c", 200; list_chest_y_pos[i] = list_chest_y_pos_ref[i] - sgx_map_pxl_y;
 3691                        		__ld2x.umq	__scroll_chest_end - 1  /* i */
         02:D9CD  AD 3F 26   			lda	__scroll_chest_end - 1
         02:D9D0  0A         			asl	a
         02:D9D1  AA         			tax
 3692                        		__ld.wax	_list_chest_y_pos_ref
         02:D9D2  BD CA 25   			lda.l	_list_chest_y_pos_ref, x
         02:D9D5  BC CB 25   			ldy.h	_list_chest_y_pos_ref, x
 3693                        		__sub.wm	_sgx_map_pxl_y
         02:D9D8  38         			sec
         02:D9D9  ED 86 26   			sbc.l	_sgx_map_pxl_y
         02:D9DC  42         			say
         02:D9DD  ED 87 26   			sbc.h	_sgx_map_pxl_y
         02:D9E0  42         			say
 3694                        		__ld2x.um	__scroll_chest_end - 1  /* i */
         02:D9E1  AA         			tax
         02:D9E2  AD 3F 26   			lda	__scroll_chest_end - 1
         02:D9E5  0A         			asl	a
         02:D9E6  22         			sax
 3695                        		__st.waxq	_list_chest_y_pos
         02:D9E7  9D AA 25   			sta.l	_list_chest_y_pos, x
         02:D9EA  98         			tya
         02:D9EB  9D AB 25   			sta.h	_list_chest_y_pos, x
 3696                        	
 3697                        		.dbg	line,	"include\routines_LEVELS.c", 201; }
 3698                        	
 3699                        		.dbg	line,	"include\routines_LEVELS.c", 203; else
 3700                        		__bra		.LL43
         02:D9EE  80 1E      			bra	.LL43
 3701    02:D9F0             	.LL42:
 3702                        	
 3703                        		.dbg	line,	"include\routines_LEVELS.c", 204; {
 3704                        	
 3705                        		.dbg	line,	"include\routines_LEVELS.c", 205; list_chest_x_pos[i] = -32;
 3706                        		__ld2x.umq	__scroll_chest_end - 1  /* i */
         02:D9F0  AD 3F 26   			lda	__scroll_chest_end - 1
         02:D9F3  0A         			asl	a
         02:D9F4  AA         			tax
 3707                        		__st.waxiq	-32, _list_chest_x_pos
         02:D9F5  A9 E0      			lda.l	#-32
         02:D9F7  9D 9A 25   			sta.l	_list_chest_x_pos, x
         02:D9FA  A9 FF      			lda.h	#-32
         02:D9FC  9D 9B 25   			sta.h	_list_chest_x_pos, x
 3708                        	
 3709                        		.dbg	line,	"include\routines_LEVELS.c", 206; list_chest_y_pos[i] = -32;
 3710                        		__ld2x.umq	__scroll_chest_end - 1  /* i */
         02:D9FF  AD 3F 26   			lda	__scroll_chest_end - 1
         02:DA02  0A         			asl	a
         02:DA03  AA         			tax
 3711                        		__st.waxiq	-32, _list_chest_y_pos
         02:DA04  A9 E0      			lda.l	#-32
         02:DA06  9D AA 25   			sta.l	_list_chest_y_pos, x
         02:DA09  A9 FF      			lda.h	#-32
         02:DA0B  9D AB 25   			sta.h	_list_chest_y_pos, x
 3712                        	
 3713                        		.dbg	line,	"include\routines_LEVELS.c", 207; }
 3714    02:DA0E             	.LL43:
 3715                        	
 3716                        		.dbg	line,	"include\routines_LEVELS.c", 209; spr_set(i + chest_start_index);
 3717                        		__ld.um		__scroll_chest_end - 1  /* i */
         02:DA0E  AD 3F 26   			lda	__scroll_chest_end - 1
         02:DA11  C2         			cly
 3718                        		__add.um	_chest_start_index
         02:DA12  18         			clc
         02:DA13  6D 94 23   			adc	_chest_start_index
         02:DA16  90 01      			bcc	!+
         02:DA18  C8         			iny
         02:DA19             	!:
 3719                        		__call		_spr_set.1
         02:DA19  20 DD E7   			call	_spr_set.1
 3720                        	
 3721                        		.dbg	line,	"include\routines_LEVELS.c", 211; spr_x(list_chest_x_pos[i]);
 3722                        		__ld2x.umq	__scroll_chest_end - 1  /* i */
         02:DA1C  AD 3F 26   			lda	__scroll_chest_end - 1
         02:DA1F  0A         			asl	a
         02:DA20  AA         			tax
 3723                        		__ld.wax	_list_chest_x_pos
         02:DA21  BD 9A 25   			lda.l	_list_chest_x_pos, x
         02:DA24  BC 9B 25   			ldy.h	_list_chest_x_pos, x
 3724                        		__call		_spr_x.1
         02:DA27  20 0A E8   			call	_spr_x.1
 3725                        	
 3726                        		.dbg	line,	"include\routines_LEVELS.c", 212; spr_y(list_chest_y_pos[i]);
 3727                        		__ld2x.umq	__scroll_chest_end - 1  /* i */
         02:DA2A  AD 3F 26   			lda	__scroll_chest_end - 1
         02:DA2D  0A         			asl	a
         02:DA2E  AA         			tax
 3728                        		__ld.wax	_list_chest_y_pos
         02:DA2F  BD AA 25   			lda.l	_list_chest_y_pos, x
         02:DA32  BC AB 25   			ldy.h	_list_chest_y_pos, x
 3729                        		__call		_spr_y.1
         02:DA35  20 19 E8   			call	_spr_y.1
 3730                        	
 3731                        		.dbg	line,	"include\routines_LEVELS.c", 213; }
 3732                        	
 3733                        		.dbg	line,	"include\routines_LEVELS.c", 214; }
 3734    02:DA38             	.LL37	.alias		.LL34
 3735                        		__bra		.LL34
         02:DA38  4C EC D8   			bra	.LL34
 3736    02:DA3B             	.LL36:
 3737                        	
 3738                        		.dbg	line,	"include\routines_LEVELS.c", 215; }
 3739    02:DA3B             	.LL32:
 3740                        		__return	0
         02:DA3B  4C EF FF   			jmp	leave_proc
 3741                        		.dbg	clear
 3742                        		.endp
 3743                        		.pceas
 3744                        	
 3745                        		.dbg	line,	"include\routines_LEVELS.c", 218; void scroll_npc()
 3746                        		.dbg	line,	"include\routines_LEVELS.c", 219; {
 3747                        	;***********************
 3748                        	;***********************
 3749                        	
 3750                        		.hucc
 3751    02:DA3E             		.proc		_scroll_npc
 3752                        		__enter		_scroll_npc
 3753                        	
 3754                        		.dbg	line,	"include\routines_LEVELS.c", 220; char i;
 3755                        	
 3756                        		.dbg	line,	"include\routines_LEVELS.c", 221; onscreen_npc_number = 0;
 3757                        		__st.umiq	0, _onscreen_npc_number
         02:DA3E  9C A9 23   			stz	_onscreen_npc_number
 3758                        	
 3759                        		.dbg	line,	"include\routines_LEVELS.c", 223; for(i=0 ; i<level_npc_number ; i++)
 3760                        		__st.umiq	0, __scroll_npc_end - 1  /* i */
         02:DA41  9C 3F 26   			stz	__scroll_npc_end - 1
 3761    02:DA44             	.LL45:
 3762                        		__ld.umq	__scroll_npc_end - 1  /* i */
         02:DA44  AD 3F 26   			lda	__scroll_npc_end - 1
 3763                        		__ult_b.umq	_level_npc_number
         02:DA47  CD A8 23   			cmp	_level_npc_number		; Subtract memory from A.
         02:DA4A  6A         			ror	a		; CC if A < memory.
         02:DA4B  49 80      			eor	#$80
         02:DA4D  2A         			rol	a
 3764                        		__btrue		.LL47
         02:DA4E  B0 08      			bcs	.LL47
 3765                        		__bra		.LL48
         02:DA50  4C A2 DB   			bra	.LL48
 3766    02:DA53             	.LL46:
 3767                        		__inc.umq	__scroll_npc_end - 1  /* i */
         02:DA53  EE 3F 26   			inc	__scroll_npc_end - 1
 3768                        		__bra		.LL45
         02:DA56  80 EC      			bra	.LL45
 3769    02:DA58             	.LL47:
 3770                        	
 3771                        		.dbg	line,	"include\routines_LEVELS.c", 224; {
 3772                        	
 3773                        		.dbg	line,	"include\routines_LEVELS.c", 225; if(list_npc_state[i] != STATE_INACTIVE)
 3774                        		__ldx.umq	__scroll_npc_end - 1  /* i */
         02:DA58  AE 3F 26   			ldx	__scroll_npc_end - 1
 3775                        		__ld.uaxq	_list_npc_state
         02:DA5B  BD B3 23   			lda	_list_npc_state, x
 3776                        		__neq_b.uiq	1
         02:DA5E  38         			sec
         02:DA5F  49 01      			eor	#1
         02:DA61  D0 01      			bne	!+
         02:DA63  18         			clc
         02:DA64             	!:
 3777                        		__bfalse	.LL49
         02:DA64  90 ED      			bcc	.LL49
 3778                        	
 3779                        		.dbg	line,	"include\routines_LEVELS.c", 226; {
 3780                        	
 3781                        		.dbg	line,	"include\routines_LEVELS.c", 227; char scroll_allowed = FALSE;
 3782                        		__st.umiq	0, __scroll_npc_end - 2  /* scroll_allowed */
         02:DA66  9C 3E 26   			stz	__scroll_npc_end - 2
 3783                        	
 3784                        		.dbg	line,	"include\routines_LEVELS.c", 228; 
 3785                        	
 3786                        		.dbg	line,	"include\routines_LEVELS.c", 229; // IF NPC X POSITION IS INFERIOR TO SCREEN RIGHT SIDE //
 3787                        	
 3788                        		.dbg	line,	"include\routines_LEVELS.c", 230; if(list_npc_x_pos_ref[i] < sgx_map_pxl_x + 256)
 3789                        		__ld.wm		_sgx_map_pxl_x
         02:DA69  AD 84 26   			lda.l	_sgx_map_pxl_x
         02:DA6C  AC 85 26   			ldy.h	_sgx_map_pxl_x
 3790                        		__add.wi	256
         02:DA6F  18         			clc
         02:DA70  69 00      			adc.l	#256
         02:DA72  42         			say
         02:DA73  69 01      			adc.h	#256
         02:DA75  42         			say
 3791                        		__ld2x.um	__scroll_npc_end - 1  /* i */
         02:DA76  AA         			tax
         02:DA77  AD 3F 26   			lda	__scroll_npc_end - 1
         02:DA7A  0A         			asl	a
         02:DA7B  22         			sax
 3792                        		__ugt_w.wax	_list_npc_x_pos_ref
         02:DA7C  18         			clc			; Subtract memory+1 from Y:A.
         02:DA7D  FD FE 25   			sbc.l	_list_npc_x_pos_ref, x
         02:DA80  98         			tya
         02:DA81  FD FF 25   			sbc.h	_list_npc_x_pos_ref, x		; CS if Y:A > memory.
 3793                        		__bfalse	.LL50
         02:DA84  B0 03 4C 09			bcc	.LL50
         02:DA88  DB          
 3794                        	
 3795                        		.dbg	line,	"include\routines_LEVELS.c", 231; {
 3796                        	
 3797                        		.dbg	line,	"include\routines_LEVELS.c", 232; // IF NPC X POSITION IS SUPERIOR TO SCREEN LEFT SIDE PLUS 32 PX //
 3798                        	
 3799                        		.dbg	line,	"include\routines_LEVELS.c", 233; if(list_npc_x_pos_ref[i] - sgx_map_pxl_x + 32 > 0)
 3800                        		__ld2x.umq	__scroll_npc_end - 1  /* i */
         02:DA89  AD 3F 26   			lda	__scroll_npc_end - 1
         02:DA8C  0A         			asl	a
         02:DA8D  AA         			tax
 3801                        		__ld.wax	_list_npc_x_pos_ref
         02:DA8E  BD FE 25   			lda.l	_list_npc_x_pos_ref, x
         02:DA91  BC FF 25   			ldy.h	_list_npc_x_pos_ref, x
 3802                        		__sub.wm	_sgx_map_pxl_x
         02:DA94  38         			sec
         02:DA95  ED 84 26   			sbc.l	_sgx_map_pxl_x
         02:DA98  42         			say
         02:DA99  ED 85 26   			sbc.h	_sgx_map_pxl_x
         02:DA9C  42         			say
 3803                        		__add.wi	32
         02:DA9D  18         			clc
         02:DA9E  69 20      			adc.l	#32
         02:DAA0  90 01      			bcc	!+
         02:DAA2  C8         			iny
         02:DAA3             	!:
 3804                        		__sgt_w.wi	0
         02:DAA3  18         			clc			; Subtract integer+1 from Y:A.
         02:DAA4  E9 00      			sbc.l	#0
         02:DAA6  98         			tya
         02:DAA7  E9 00      			sbc.h	#0
         02:DAA9  50 02      			bvc	!+
         02:DAAB  49 80      			eor	#$80		; +ve if Y:A > integer (signed).
         02:DAAD  49 80      	!:		eor	#$80
         02:DAAF  0A         			asl	a
 3805                        		__bfalse	.LL51
         02:DAB0  90 57      			bcc	.LL51
 3806                        	
 3807                        		.dbg	line,	"include\routines_LEVELS.c", 234; {
 3808                        	
 3809                        		.dbg	line,	"include\routines_LEVELS.c", 235; // IF NPC Y POSITION IS INFERIOR TO SCREEN BOTTOM //
 3810                        	
 3811                        		.dbg	line,	"include\routines_LEVELS.c", 236; if(list_npc_y_pos_ref[i] < sgx_map_pxl_y + 224)
 3812                        		__ld.wm		_sgx_map_pxl_y
         02:DAB2  AD 86 26   			lda.l	_sgx_map_pxl_y
         02:DAB5  AC 87 26   			ldy.h	_sgx_map_pxl_y
 3813                        		__add.wi	224
         02:DAB8  18         			clc
         02:DAB9  69 E0      			adc.l	#224
         02:DABB  90 01      			bcc	!+
         02:DABD  C8         			iny
         02:DABE             	!:
 3814                        		__ld2x.um	__scroll_npc_end - 1  /* i */
         02:DABE  AA         			tax
         02:DABF  AD 3F 26   			lda	__scroll_npc_end - 1
         02:DAC2  0A         			asl	a
         02:DAC3  22         			sax
 3815                        		__ugt_w.wax	_list_npc_y_pos_ref
         02:DAC4  18         			clc			; Subtract memory+1 from Y:A.
         02:DAC5  FD 10 26   			sbc.l	_list_npc_y_pos_ref, x
         02:DAC8  98         			tya
         02:DAC9  FD 11 26   			sbc.h	_list_npc_y_pos_ref, x		; CS if Y:A > memory.
 3816                        		__bfalse	.LL52
         02:DACC  90 3B      			bcc	.LL52
 3817                        	
 3818                        		.dbg	line,	"include\routines_LEVELS.c", 237; {
 3819                        	
 3820                        		.dbg	line,	"include\routines_LEVELS.c", 238; // IF NPC Y POSITION IS SUPERIOR TO SCREEN TOP PLUS 32 PX //
 3821                        	
 3822                        		.dbg	line,	"include\routines_LEVELS.c", 239; if(list_npc_y_pos_ref[i] - sgx_map_pxl_y + 32 > 0)
 3823                        		__ld2x.umq	__scroll_npc_end - 1  /* i */
         02:DACE  AD 3F 26   			lda	__scroll_npc_end - 1
         02:DAD1  0A         			asl	a
         02:DAD2  AA         			tax
 3824                        		__ld.wax	_list_npc_y_pos_ref
         02:DAD3  BD 10 26   			lda.l	_list_npc_y_pos_ref, x
         02:DAD6  BC 11 26   			ldy.h	_list_npc_y_pos_ref, x
 3825                        		__sub.wm	_sgx_map_pxl_y
         02:DAD9  38         			sec
         02:DADA  ED 86 26   			sbc.l	_sgx_map_pxl_y
         02:DADD  42         			say
         02:DADE  ED 87 26   			sbc.h	_sgx_map_pxl_y
         02:DAE1  42         			say
 3826                        		__add.wi	32
         02:DAE2  18         			clc
         02:DAE3  69 20      			adc.l	#32
         02:DAE5  90 01      			bcc	!+
         02:DAE7  C8         			iny
         02:DAE8             	!:
 3827                        		__sgt_w.wi	0
         02:DAE8  18         			clc			; Subtract integer+1 from Y:A.
         02:DAE9  E9 00      			sbc.l	#0
         02:DAEB  98         			tya
         02:DAEC  E9 00      			sbc.h	#0
         02:DAEE  50 02      			bvc	!+
         02:DAF0  49 80      			eor	#$80		; +ve if Y:A > integer (signed).
         02:DAF2  49 80      	!:		eor	#$80
         02:DAF4  0A         			asl	a
 3828                        		__bfalse	.LL53
         02:DAF5  90 12      			bcc	.LL53
 3829                        	
 3830                        		.dbg	line,	"include\routines_LEVELS.c", 240; {
 3831                        	
 3832                        		.dbg	line,	"include\routines_LEVELS.c", 241; // WE STORE THE NPC ID //
 3833                        	
 3834                        		.dbg	line,	"include\routines_LEVELS.c", 242; list_onscreen_npc[onscreen_npc_number] = i;
 3835                        		__ldx.umq	_onscreen_npc_number
         02:DAF7  AE A9 23   			ldx	_onscreen_npc_number
 3836                        		__ld.um		__scroll_npc_end - 1  /* i */
         02:DAFA  AD 3F 26   			lda	__scroll_npc_end - 1
         02:DAFD  C2         			cly
 3837                        		__st.uaxq	_list_onscreen_npc
         02:DAFE  9D BC 23   			sta	_list_onscreen_npc, x
 3838                        	
 3839                        		.dbg	line,	"include\routines_LEVELS.c", 243; onscreen_npc_number += 1;
 3840                        		__add_st.umiq	1, _onscreen_npc_number
         02:DB01  EE A9 23   			inc	_onscreen_npc_number
 3841                        	
 3842                        		.dbg	line,	"include\routines_LEVELS.c", 244; 
 3843                        	
 3844                        		.dbg	line,	"include\routines_LEVELS.c", 245; scroll_allowed = TRUE;
 3845                        		__st.umiq	1, __scroll_npc_end - 2  /* scroll_allowed */
         02:DB04  A9 01      			lda.l	#1
         02:DB06  8D 3E 26   			sta	__scroll_npc_end - 2
 3846                        	
 3847                        		.dbg	line,	"include\routines_LEVELS.c", 246; }
 3848                        	
 3849                        		.dbg	line,	"include\routines_LEVELS.c", 247; }
 3850    02:DB09             	.LL53:
 3851                        	
 3852                        		.dbg	line,	"include\routines_LEVELS.c", 248; }
 3853    02:DB09             	.LL52:
 3854                        	
 3855                        		.dbg	line,	"include\routines_LEVELS.c", 249; }
 3856    02:DB09             	.LL51:
 3857                        	
 3858                        		.dbg	line,	"include\routines_LEVELS.c", 251; // IF NPC IS WITHIN THE SCREEN LIMITS //
 3859                        	
 3860                        		.dbg	line,	"include\routines_LEVELS.c", 252; if(scroll_allowed == TRUE)
 3861    02:DB09             	.LL50:
 3862                        		__ld.umq	__scroll_npc_end - 2  /* scroll_allowed */
         02:DB09  AD 3E 26   			lda	__scroll_npc_end - 2
 3863                        		__equ_b.uiq	1
         02:DB0C  C9 01      			cmp	#1
         02:DB0E  F0 01      			beq	!+
         02:DB10  18         			clc
         02:DB11             	!:
 3864                        		__bfalse	.LL54
         02:DB11  90 44      			bcc	.LL54
 3865                        	
 3866                        		.dbg	line,	"include\routines_LEVELS.c", 253; {
 3867                        	
 3868                        		.dbg	line,	"include\routines_LEVELS.c", 254; list_npc_x_pos[i] = list_npc_x_pos_ref[i] - sgx_map_pxl_x;
 3869                        		__ld2x.umq	__scroll_npc_end - 1  /* i */
         02:DB13  AD 3F 26   			lda	__scroll_npc_end - 1
         02:DB16  0A         			asl	a
         02:DB17  AA         			tax
 3870                        		__ld.wax	_list_npc_x_pos_ref
         02:DB18  BD FE 25   			lda.l	_list_npc_x_pos_ref, x
         02:DB1B  BC FF 25   			ldy.h	_list_npc_x_pos_ref, x
 3871                        		__sub.wm	_sgx_map_pxl_x
         02:DB1E  38         			sec
         02:DB1F  ED 84 26   			sbc.l	_sgx_map_pxl_x
         02:DB22  42         			say
         02:DB23  ED 85 26   			sbc.h	_sgx_map_pxl_x
         02:DB26  42         			say
 3872                        		__ld2x.um	__scroll_npc_end - 1  /* i */
         02:DB27  AA         			tax
         02:DB28  AD 3F 26   			lda	__scroll_npc_end - 1
         02:DB2B  0A         			asl	a
         02:DB2C  22         			sax
 3873                        		__st.waxq	_list_npc_x_pos
         02:DB2D  9D DA 25   			sta.l	_list_npc_x_pos, x
         02:DB30  98         			tya
         02:DB31  9D DB 25   			sta.h	_list_npc_x_pos, x
 3874                        	
 3875                        		.dbg	line,	"include\routines_LEVELS.c", 255; list_npc_y_pos[i] = list_npc_y_pos_ref[i] - sgx_map_pxl_y;
 3876                        		__ld2x.umq	__scroll_npc_end - 1  /* i */
         02:DB34  AD 3F 26   			lda	__scroll_npc_end - 1
         02:DB37  0A         			asl	a
         02:DB38  AA         			tax
 3877                        		__ld.wax	_list_npc_y_pos_ref
         02:DB39  BD 10 26   			lda.l	_list_npc_y_pos_ref, x
         02:DB3C  BC 11 26   			ldy.h	_list_npc_y_pos_ref, x
 3878                        		__sub.wm	_sgx_map_pxl_y
         02:DB3F  38         			sec
         02:DB40  ED 86 26   			sbc.l	_sgx_map_pxl_y
         02:DB43  42         			say
         02:DB44  ED 87 26   			sbc.h	_sgx_map_pxl_y
         02:DB47  42         			say
 3879                        		__ld2x.um	__scroll_npc_end - 1  /* i */
         02:DB48  AA         			tax
         02:DB49  AD 3F 26   			lda	__scroll_npc_end - 1
         02:DB4C  0A         			asl	a
         02:DB4D  22         			sax
 3880                        		__st.waxq	_list_npc_y_pos
         02:DB4E  9D EC 25   			sta.l	_list_npc_y_pos, x
         02:DB51  98         			tya
         02:DB52  9D ED 25   			sta.h	_list_npc_y_pos, x
 3881                        	
 3882                        		.dbg	line,	"include\routines_LEVELS.c", 256; }
 3883                        	
 3884                        		.dbg	line,	"include\routines_LEVELS.c", 258; else
 3885                        		__bra		.LL55
         02:DB55  80 1E      			bra	.LL55
 3886    02:DB57             	.LL54:
 3887                        	
 3888                        		.dbg	line,	"include\routines_LEVELS.c", 259; {
 3889                        	
 3890                        		.dbg	line,	"include\routines_LEVELS.c", 260; list_npc_x_pos[i] = -32;
 3891                        		__ld2x.umq	__scroll_npc_end - 1  /* i */
         02:DB57  AD 3F 26   			lda	__scroll_npc_end - 1
         02:DB5A  0A         			asl	a
         02:DB5B  AA         			tax
 3892                        		__st.waxiq	-32, _list_npc_x_pos
         02:DB5C  A9 E0      			lda.l	#-32
         02:DB5E  9D DA 25   			sta.l	_list_npc_x_pos, x
         02:DB61  A9 FF      			lda.h	#-32
         02:DB63  9D DB 25   			sta.h	_list_npc_x_pos, x
 3893                        	
 3894                        		.dbg	line,	"include\routines_LEVELS.c", 261; list_npc_y_pos[i] = -32;
 3895                        		__ld2x.umq	__scroll_npc_end - 1  /* i */
         02:DB66  AD 3F 26   			lda	__scroll_npc_end - 1
         02:DB69  0A         			asl	a
         02:DB6A  AA         			tax
 3896                        		__st.waxiq	-32, _list_npc_y_pos
         02:DB6B  A9 E0      			lda.l	#-32
         02:DB6D  9D EC 25   			sta.l	_list_npc_y_pos, x
         02:DB70  A9 FF      			lda.h	#-32
         02:DB72  9D ED 25   			sta.h	_list_npc_y_pos, x
 3897                        	
 3898                        		.dbg	line,	"include\routines_LEVELS.c", 262; }
 3899    02:DB75             	.LL55:
 3900                        	
 3901                        		.dbg	line,	"include\routines_LEVELS.c", 264; spr_set(i + npc_start_index);
 3902                        		__ld.um		__scroll_npc_end - 1  /* i */
         02:DB75  AD 3F 26   			lda	__scroll_npc_end - 1
         02:DB78  C2         			cly
 3903                        		__add.um	_npc_start_index
         02:DB79  18         			clc
         02:DB7A  6D A7 23   			adc	_npc_start_index
         02:DB7D  90 01      			bcc	!+
         02:DB7F  C8         			iny
         02:DB80             	!:
 3904                        		__call		_spr_set.1
         02:DB80  20 DD E7   			call	_spr_set.1
 3905                        	
 3906                        		.dbg	line,	"include\routines_LEVELS.c", 266; spr_x(list_npc_x_pos[i]);
 3907                        		__ld2x.umq	__scroll_npc_end - 1  /* i */
         02:DB83  AD 3F 26   			lda	__scroll_npc_end - 1
         02:DB86  0A         			asl	a
         02:DB87  AA         			tax
 3908                        		__ld.wax	_list_npc_x_pos
         02:DB88  BD DA 25   			lda.l	_list_npc_x_pos, x
         02:DB8B  BC DB 25   			ldy.h	_list_npc_x_pos, x
 3909                        		__call		_spr_x.1
         02:DB8E  20 0A E8   			call	_spr_x.1
 3910                        	
 3911                        		.dbg	line,	"include\routines_LEVELS.c", 267; spr_y(list_npc_y_pos[i]);
 3912                        		__ld2x.umq	__scroll_npc_end - 1  /* i */
         02:DB91  AD 3F 26   			lda	__scroll_npc_end - 1
         02:DB94  0A         			asl	a
         02:DB95  AA         			tax
 3913                        		__ld.wax	_list_npc_y_pos
         02:DB96  BD EC 25   			lda.l	_list_npc_y_pos, x
         02:DB99  BC ED 25   			ldy.h	_list_npc_y_pos, x
 3914                        		__call		_spr_y.1
         02:DB9C  20 19 E8   			call	_spr_y.1
 3915                        	
 3916                        		.dbg	line,	"include\routines_LEVELS.c", 268; }
 3917                        	
 3918                        		.dbg	line,	"include\routines_LEVELS.c", 269; }
 3919    02:DB9F             	.LL49	.alias		.LL46
 3920                        		__bra		.LL46
         02:DB9F  4C 53 DA   			bra	.LL46
 3921    02:DBA2             	.LL48:
 3922                        	
 3923                        		.dbg	line,	"include\routines_LEVELS.c", 270; }
 3924    02:DBA2             	.LL44:
 3925                        		__return	0
         02:DBA2  4C EF FF   			jmp	leave_proc
 3926                        		.dbg	clear
 3927                        		.endp
 3928                        		.pceas
 3929                        	
 3930                        		.dbg	line,	"include\routines_LEVELS.c", 275; int check_TILE_DEPTH(signed char x_offset , signed char y_offset)
 3931                        		.dbg	line,	"include\routines_LEVELS.c", 276; {
 3932                        	;***********************
 3933                        	;***********************
 3934                        	
 3935                        		.hucc
 3936    11:C4D2             		.proc		_check_TILE_DEPTH
 3937                        		__enter		_check_TILE_DEPTH
 3938                        	
 3939                        		.dbg	line,	"include\routines_LEVELS.c", 277; int player_COLL_X;
 3940                        	
 3941                        		.dbg	line,	"include\routines_LEVELS.c", 278; int player_COLL_Y;
 3942                        	
 3943                        		.dbg	line,	"include\routines_LEVELS.c", 281; player_COLL_X = player_pos_x + x_offset;
 3944                        		__ld.bs		2  /* x_offset */
         11:C4D2  A6 8D      			ldx	<__sp
         11:C4D4  B5 0A      			lda	<__stack + 2, x
         11:C4D6  C2         			cly
         11:C4D7  10 01      			bpl	!+	; signed
         11:C4D9  88         			dey
         11:C4DA             	!:
 3945                        		__add.wm	_player_pos_x
         11:C4DA  18         			clc
         11:C4DB  6D C8 24   			adc.l	_player_pos_x
         11:C4DE  42         			say
         11:C4DF  6D C9 24   			adc.h	_player_pos_x
         11:C4E2  42         			say
 3946                        		__st.wmq	__check_TILE_DEPTH_end - 2  /* player_COLL_X */
         11:C4E3  8D 3E 26   			sta.l	__check_TILE_DEPTH_end - 2
         11:C4E6  8C 3F 26   			sty.h	__check_TILE_DEPTH_end - 2
 3947                        	
 3948                        		.dbg	line,	"include\routines_LEVELS.c", 282; player_COLL_Y = player_pos_y + 32 - y_offset;//32
 3949                        		__ld.wm		_player_pos_y
         11:C4E9  AD CA 24   			lda.l	_player_pos_y
         11:C4EC  AC CB 24   			ldy.h	_player_pos_y
 3950                        		__add.wi	32
         11:C4EF  18         			clc
         11:C4F0  69 20      			adc.l	#32
         11:C4F2  90 01      			bcc	!+
         11:C4F4  C8         			iny
         11:C4F5             	!:
 3951                        		__push.wr
         11:C4F5  5A         			phy
         11:C4F6  48         			pha
 3952                        		__ld.bs		0  /* y_offset */
         11:C4F7  A6 8D      			ldx	<__sp
         11:C4F9  B5 08      			lda	<__stack + 0, x
         11:C4FB  C2         			cly
         11:C4FC  10 01      			bpl	!+	; signed
         11:C4FE  88         			dey
         11:C4FF             	!:
 3953                        		__sub.wt
         11:C4FF  BA         			tsx
         11:C500  38         			sec
         11:C501  49 FF      			eor	#$FF
         11:C503  7D 01 21   			adc.l	__tos, x
         11:C506  42         			say
         11:C507  49 FF      			eor	#$FF
         11:C509  7D 02 21   			adc.h	__tos, x
         11:C50C  42         			say
         11:C50D  E8         			inx
         11:C50E  E8         			inx
         11:C50F  9A         			txs
 3954                        		__st.wmq	__check_TILE_DEPTH_end - 4  /* player_COLL_Y */
         11:C510  8D 3C 26   			sta.l	__check_TILE_DEPTH_end - 4
         11:C513  8C 3D 26   			sty.h	__check_TILE_DEPTH_end - 4
 3955                        	
 3956                        		.dbg	line,	"include\routines_LEVELS.c", 284; get_map_block(player_COLL_X + sgx_map_pxl_x, player_COLL_Y + sgx_map_pxl_y);
 3957                        		__ld.wm		__check_TILE_DEPTH_end - 2  /* player_COLL_X */
         11:C516  AD 3E 26   			lda.l	__check_TILE_DEPTH_end - 2
         11:C519  AC 3F 26   			ldy.h	__check_TILE_DEPTH_end - 2
 3958                        		__add.wm	_sgx_map_pxl_x
         11:C51C  18         			clc
         11:C51D  6D 84 26   			adc.l	_sgx_map_pxl_x
         11:C520  42         			say
         11:C521  6D 85 26   			adc.h	_sgx_map_pxl_x
         11:C524  42         			say
 3959                        		__st.wmq	map_pxl_x
         11:C525  85 FC      			sta.l	map_pxl_x
         11:C527  84 FD      			sty.h	map_pxl_x
 3960                        		__ld.wm		__check_TILE_DEPTH_end - 4  /* player_COLL_Y */
         11:C529  AD 3C 26   			lda.l	__check_TILE_DEPTH_end - 4
         11:C52C  AC 3D 26   			ldy.h	__check_TILE_DEPTH_end - 4
 3961                        		__add.wm	_sgx_map_pxl_y
         11:C52F  18         			clc
         11:C530  6D 86 26   			adc.l	_sgx_map_pxl_y
         11:C533  42         			say
         11:C534  6D 87 26   			adc.h	_sgx_map_pxl_y
         11:C537  42         			say
 3962                        		__st.wmq	map_pxl_y
         11:C538  85 FE      			sta.l	map_pxl_y
         11:C53A  84 FF      			sty.h	map_pxl_y
 3963                        		__call		_get_map_block.2
         11:C53C  20 95 FF   			call	_get_map_block.2
 3964                        	
 3965                        		.dbg	line,	"include\routines_LEVELS.c", 285; }
 3966    11:C53F             	.LL56:
 3967                        		__modsp		4
         11:C53F  AA         			tax
         11:C540  A5 8D      			lda	<__sp
         11:C542  18         			clc
         11:C543  69 04      			adc	#4
         11:C545  85 8D      			sta	<__sp
         11:C547  8A         			txa
 3968                        		__return	1
         11:C548  AA         			tax
         11:C549  4C EF FF   			jmp	leave_proc
 3969                        		.dbg	clear
 3970                        		.endp
 3971                        		.pceas
 3972                        	
 3973                        		.dbg	line,	"include\routines_LEVELS.c", 287; // CHECK COLLISION WITH BG //
 3974                        		.dbg	line,	"include\routines_LEVELS.c", 288; int check_BG(signed char x_offset , signed char y_offset)
 3975                        		.dbg	line,	"include\routines_LEVELS.c", 289; {
 3976                        	;***********************
 3977                        	;***********************
 3978                        	
 3979                        		.hucc
 3980    11:C62D             		.proc		_check_BG
 3981                        		__enter		_check_BG
 3982                        	
 3983                        		.dbg	line,	"include\routines_LEVELS.c", 290; int player_COLL_X;
 3984                        	
 3985                        		.dbg	line,	"include\routines_LEVELS.c", 291; int player_COLL_Y;
 3986                        	
 3987                        		.dbg	line,	"include\routines_LEVELS.c", 294; player_COLL_X = player_pos_x + x_offset;
 3988                        		__ld.bs		2  /* x_offset */
         11:C62D  A6 8D      			ldx	<__sp
         11:C62F  B5 0A      			lda	<__stack + 2, x
         11:C631  C2         			cly
         11:C632  10 01      			bpl	!+	; signed
         11:C634  88         			dey
         11:C635             	!:
 3989                        		__add.wm	_player_pos_x
         11:C635  18         			clc
         11:C636  6D C8 24   			adc.l	_player_pos_x
         11:C639  42         			say
         11:C63A  6D C9 24   			adc.h	_player_pos_x
         11:C63D  42         			say
 3990                        		__st.wmq	__check_BG_end - 2  /* player_COLL_X */
         11:C63E  8D 3E 26   			sta.l	__check_BG_end - 2
         11:C641  8C 3F 26   			sty.h	__check_BG_end - 2
 3991                        	
 3992                        		.dbg	line,	"include\routines_LEVELS.c", 295; player_COLL_Y = player_pos_y + y_offset;
 3993                        		__ld.bs		0  /* y_offset */
         11:C644  A6 8D      			ldx	<__sp
         11:C646  B5 08      			lda	<__stack + 0, x
         11:C648  C2         			cly
         11:C649  10 01      			bpl	!+	; signed
         11:C64B  88         			dey
         11:C64C             	!:
 3994                        		__add.wm	_player_pos_y
         11:C64C  18         			clc
         11:C64D  6D CA 24   			adc.l	_player_pos_y
         11:C650  42         			say
         11:C651  6D CB 24   			adc.h	_player_pos_y
         11:C654  42         			say
 3995                        		__st.wmq	__check_BG_end - 4  /* player_COLL_Y */
         11:C655  8D 3C 26   			sta.l	__check_BG_end - 4
         11:C658  8C 3D 26   			sty.h	__check_BG_end - 4
 3996                        	
 3997                        		.dbg	line,	"include\routines_LEVELS.c", 297; get_map_block(player_COLL_X + sgx_map_pxl_x, player_COLL_Y + sgx_map_pxl_y);
 3998                        		__ld.wm		__check_BG_end - 2  /* player_COLL_X */
         11:C65B  AD 3E 26   			lda.l	__check_BG_end - 2
         11:C65E  AC 3F 26   			ldy.h	__check_BG_end - 2
 3999                        		__add.wm	_sgx_map_pxl_x
         11:C661  18         			clc
         11:C662  6D 84 26   			adc.l	_sgx_map_pxl_x
         11:C665  42         			say
         11:C666  6D 85 26   			adc.h	_sgx_map_pxl_x
         11:C669  42         			say
 4000                        		__st.wmq	map_pxl_x
         11:C66A  85 FC      			sta.l	map_pxl_x
         11:C66C  84 FD      			sty.h	map_pxl_x
 4001                        		__ld.wm		__check_BG_end - 4  /* player_COLL_Y */
         11:C66E  AD 3C 26   			lda.l	__check_BG_end - 4
         11:C671  AC 3D 26   			ldy.h	__check_BG_end - 4
 4002                        		__add.wm	_sgx_map_pxl_y
         11:C674  18         			clc
         11:C675  6D 86 26   			adc.l	_sgx_map_pxl_y
         11:C678  42         			say
         11:C679  6D 87 26   			adc.h	_sgx_map_pxl_y
         11:C67C  42         			say
 4003                        		__st.wmq	map_pxl_y
         11:C67D  85 FE      			sta.l	map_pxl_y
         11:C67F  84 FF      			sty.h	map_pxl_y
 4004                        		__call		_get_map_block.2
         11:C681  20 95 FF   			call	_get_map_block.2
 4005                        	
 4006                        		.dbg	line,	"include\routines_LEVELS.c", 298; }
 4007    11:C684             	.LL57:
 4008                        		__modsp		4
         11:C684  AA         			tax
         11:C685  A5 8D      			lda	<__sp
         11:C687  18         			clc
         11:C688  69 04      			adc	#4
         11:C68A  85 8D      			sta	<__sp
         11:C68C  8A         			txa
 4009                        		__return	1
         11:C68D  AA         			tax
         11:C68E  4C EF FF   			jmp	leave_proc
 4010                        		.dbg	clear
 4011                        		.endp
 4012                        		.pceas
 4013                        	
 4014                        		.dbg	line,	"include\routines_LEVELS.c", 300; // CHECK COLLISION WITH OBJECTS //
 4015                        		.dbg	line,	"include\routines_LEVELS.c", 301; void check_OBJECT()
 4016                        		.dbg	line,	"include\routines_LEVELS.c", 302; {
 4017                        	;***********************
 4018                        	;***********************
 4019                        	
 4020                        		.hucc
 4021    02:D5EC             		.proc		_check_OBJECT
 4022                        		__enter		_check_OBJECT
 4023                        	
 4024                        		.dbg	line,	"include\routines_LEVELS.c", 303; if(onscreen_object_number != 0)
 4025                        		__tst.um	_onscreen_object_number
         02:D5EC  AD 27 23   			lda	_onscreen_object_number
         02:D5EF  C9 01      			cmp	#1
 4026                        		__bfalse	.LL59
         02:D5F1  B0 03 4C 6D			bcc	.LL59
         02:D5F5  D7          
 4027                        	
 4028                        		.dbg	line,	"include\routines_LEVELS.c", 304; {
 4029                        	
 4030                        		.dbg	line,	"include\routines_LEVELS.c", 305; char i;
 4031                        	
 4032                        		.dbg	line,	"include\routines_LEVELS.c", 306; char current_object_id;
 4033                        	
 4034                        		.dbg	line,	"include\routines_LEVELS.c", 307; char current_object_type;
 4035                        	
 4036                        		.dbg	line,	"include\routines_LEVELS.c", 309; for(i=0 ; i<onscreen_object_number ; i++)
 4037                        		__st.umiq	0, __check_OBJECT_end - 1  /* i */
         02:D5F6  9C 02 23   			stz	__check_OBJECT_end - 1
 4038    02:D5F9             	.LL60:
 4039                        		__ld.umq	__check_OBJECT_end - 1  /* i */
         02:D5F9  AD 02 23   			lda	__check_OBJECT_end - 1
 4040                        		__ult_b.umq	_onscreen_object_number
         02:D5FC  CD 27 23   			cmp	_onscreen_object_number		; Subtract memory from A.
         02:D5FF  6A         			ror	a		; CC if A < memory.
         02:D600  49 80      			eor	#$80
         02:D602  2A         			rol	a
 4041                        		__btrue		.LL62
         02:D603  B0 08      			bcs	.LL62
 4042                        		__bra		.LL63
         02:D605  4C 6D D7   			bra	.LL63
 4043    02:D608             	.LL61:
 4044                        		__inc.umq	__check_OBJECT_end - 1  /* i */
         02:D608  EE 02 23   			inc	__check_OBJECT_end - 1
 4045                        		__bra		.LL60
         02:D60B  80 EC      			bra	.LL60
 4046    02:D60D             	.LL62:
 4047                        	
 4048                        		.dbg	line,	"include\routines_LEVELS.c", 310; {
 4049                        	
 4050                        		.dbg	line,	"include\routines_LEVELS.c", 311; // RETRIEVE OBJECT INDEX IN THE LIST //
 4051                        	
 4052                        		.dbg	line,	"include\routines_LEVELS.c", 312; current_object_id = list_onscreen_object[i];
 4053                        		__ldx.umq	__check_OBJECT_end - 1  /* i */
         02:D60D  AE 02 23   			ldx	__check_OBJECT_end - 1
 4054                        		__ld.uax	_list_onscreen_object
         02:D610  BD 8C 23   			lda	_list_onscreen_object, x
         02:D613  C2         			cly
 4055                        		__st.umq	__check_OBJECT_end - 2  /* current_object_id */
         02:D614  8D 01 23   			sta	__check_OBJECT_end - 2
 4056                        	
 4057                        		.dbg	line,	"include\routines_LEVELS.c", 313; // RETRIEVE OBJECT TYPE //
 4058                        	
 4059                        		.dbg	line,	"include\routines_LEVELS.c", 314; current_object_type = list_object_type[current_object_id];
 4060                        		__ldx.umq	__check_OBJECT_end - 2  /* current_object_id */
         02:D617  AE 01 23   			ldx	__check_OBJECT_end - 2
 4061                        		__ld.uax	_list_object_type
         02:D61A  BD 28 23   			lda	_list_object_type, x
         02:D61D  C2         			cly
 4062                        		__st.umq	__check_OBJECT_end - 3  /* current_object_type */
         02:D61E  8D 00 23   			sta	__check_OBJECT_end - 3
 4063                        	
 4064                        		.dbg	line,	"include\routines_LEVELS.c", 316; if(current_object_type != TYPE_POT)
 4065                        		__ld.umq	__check_OBJECT_end - 3  /* current_object_type */
         02:D621  AD 00 23   			lda	__check_OBJECT_end - 3
 4066                        		__neq_b.uiq	1
         02:D624  38         			sec
         02:D625  49 01      			eor	#1
         02:D627  D0 01      			bne	!+
         02:D629  18         			clc
         02:D62A             	!:
 4067                        		__bfalse	.LL64
         02:D62A  90 DC      			bcc	.LL64
 4068                        	
 4069                        		.dbg	line,	"include\routines_LEVELS.c", 317; {
 4070                        	
 4071                        		.dbg	line,	"include\routines_LEVELS.c", 318; if(abs( (player_pos_x + 16) - (list_object_x_pos[current_object_id] + 8) ) < OBJECT_MARGIN)
 4072                        		__ld.wm		_player_pos_x
         02:D62C  AD C8 24   			lda.l	_player_pos_x
         02:D62F  AC C9 24   			ldy.h	_player_pos_x
 4073                        		__add.wi	16
         02:D632  18         			clc
         02:D633  69 10      			adc.l	#16
         02:D635  90 01      			bcc	!+
         02:D637  C8         			iny
         02:D638             	!:
 4074                        		__push.wr
         02:D638  5A         			phy
         02:D639  48         			pha
 4075                        		__ld2x.umq	__check_OBJECT_end - 2  /* current_object_id */
         02:D63A  AD 01 23   			lda	__check_OBJECT_end - 2
         02:D63D  0A         			asl	a
         02:D63E  AA         			tax
 4076                        		__ld.wax	_list_object_x_pos
         02:D63F  BD D2 24   			lda.l	_list_object_x_pos, x
         02:D642  BC D3 24   			ldy.h	_list_object_x_pos, x
 4077                        		__add.wi	8
         02:D645  18         			clc
         02:D646  69 08      			adc.l	#8
         02:D648  90 01      			bcc	!+
         02:D64A  C8         			iny
         02:D64B             	!:
 4078                        		__sub.wt
         02:D64B  BA         			tsx
         02:D64C  38         			sec
         02:D64D  49 FF      			eor	#$FF
         02:D64F  7D 01 21   			adc.l	__tos, x
         02:D652  42         			say
         02:D653  49 FF      			eor	#$FF
         02:D655  7D 02 21   			adc.h	__tos, x
         02:D658  42         			say
         02:D659  E8         			inx
         02:D65A  E8         			inx
         02:D65B  9A         			txs
 4079                        		__call		_abs.1
         02:D65C  20 09 E5   			call	_abs.1
 4080                        		__slt_w.wi	10
         02:D65F  C9 0A      			cmp.l	#10		; Subtract integer from Y:A.
         02:D661  98         			tya
         02:D662  E9 00      			sbc.h	#10
         02:D664  50 02      			bvc	!+
         02:D666  49 80      			eor	#$80		; -ve if Y:A < integer (signed).
         02:D668  0A         	!:		asl	a
 4081                        		__bfalse	.LL65
         02:D669  90 9D      			bcc	.LL65
 4082                        	
 4083                        		.dbg	line,	"include\routines_LEVELS.c", 319; {
 4084                        	
 4085                        		.dbg	line,	"include\routines_LEVELS.c", 320; if(abs( (player_pos_y + 16) - (list_object_y_pos[current_object_id] + 8) ) < OBJECT_MARGIN)
 4086                        		__ld.wm		_player_pos_y
         02:D66B  AD CA 24   			lda.l	_player_pos_y
         02:D66E  AC CB 24   			ldy.h	_player_pos_y
 4087                        		__add.wi	16
         02:D671  18         			clc
         02:D672  69 10      			adc.l	#16
         02:D674  90 01      			bcc	!+
         02:D676  C8         			iny
         02:D677             	!:
 4088                        		__push.wr
         02:D677  5A         			phy
         02:D678  48         			pha
 4089                        		__ld2x.umq	__check_OBJECT_end - 2  /* current_object_id */
         02:D679  AD 01 23   			lda	__check_OBJECT_end - 2
         02:D67C  0A         			asl	a
         02:D67D  AA         			tax
 4090                        		__ld.wax	_list_object_y_pos
         02:D67E  BD 04 25   			lda.l	_list_object_y_pos, x
         02:D681  BC 05 25   			ldy.h	_list_object_y_pos, x
 4091                        		__add.wi	8
         02:D684  18         			clc
         02:D685  69 08      			adc.l	#8
         02:D687  90 01      			bcc	!+
         02:D689  C8         			iny
         02:D68A             	!:
 4092                        		__sub.wt
         02:D68A  BA         			tsx
         02:D68B  38         			sec
         02:D68C  49 FF      			eor	#$FF
         02:D68E  7D 01 21   			adc.l	__tos, x
         02:D691  42         			say
         02:D692  49 FF      			eor	#$FF
         02:D694  7D 02 21   			adc.h	__tos, x
         02:D697  42         			say
         02:D698  E8         			inx
         02:D699  E8         			inx
         02:D69A  9A         			txs
 4093                        		__call		_abs.1
         02:D69B  20 09 E5   			call	_abs.1
 4094                        		__slt_w.wi	10
         02:D69E  C9 0A      			cmp.l	#10		; Subtract integer from Y:A.
         02:D6A0  98         			tya
         02:D6A1  E9 00      			sbc.h	#10
         02:D6A3  50 02      			bvc	!+
         02:D6A5  49 80      			eor	#$80		; -ve if Y:A < integer (signed).
         02:D6A7  0A         	!:		asl	a
 4095                        		__bfalse	.LL66
         02:D6A8  B0 03 4C 08			bcc	.LL66
         02:D6AC  D6          
 4096                        	
 4097                        		.dbg	line,	"include\routines_LEVELS.c", 321; {
 4098                        	
 4099                        		.dbg	line,	"include\routines_LEVELS.c", 322; // THE OBJECT DISAPPEARS //
 4100                        	
 4101                        		.dbg	line,	"include\routines_LEVELS.c", 323; list_object_x_pos[current_object_id] = -16;
 4102                        		__ld2x.umq	__check_OBJECT_end - 2  /* current_object_id */
         02:D6AD  AD 01 23   			lda	__check_OBJECT_end - 2
         02:D6B0  0A         			asl	a
         02:D6B1  AA         			tax
 4103                        		__st.waxiq	-16, _list_object_x_pos
         02:D6B2  A9 F0      			lda.l	#-16
         02:D6B4  9D D2 24   			sta.l	_list_object_x_pos, x
         02:D6B7  A9 FF      			lda.h	#-16
         02:D6B9  9D D3 24   			sta.h	_list_object_x_pos, x
 4104                        	
 4105                        		.dbg	line,	"include\routines_LEVELS.c", 324; list_object_y_pos[current_object_id] = -16;
 4106                        		__ld2x.umq	__check_OBJECT_end - 2  /* current_object_id */
         02:D6BC  AD 01 23   			lda	__check_OBJECT_end - 2
         02:D6BF  0A         			asl	a
         02:D6C0  AA         			tax
 4107                        		__st.waxiq	-16, _list_object_y_pos
         02:D6C1  A9 F0      			lda.l	#-16
         02:D6C3  9D 04 25   			sta.l	_list_object_y_pos, x
         02:D6C6  A9 FF      			lda.h	#-16
         02:D6C8  9D 05 25   			sta.h	_list_object_y_pos, x
 4108                        	
 4109                        		.dbg	line,	"include\routines_LEVELS.c", 325; list_object_state[current_object_id] = STATE_INACTIVE;
 4110                        		__ldx.umq	__check_OBJECT_end - 2  /* current_object_id */
         02:D6CB  AE 01 23   			ldx	__check_OBJECT_end - 2
 4111                        		__st.uaxiq	1, _list_object_state
         02:D6CE  A9 01      			lda.l	#1
         02:D6D0  9D 41 23   			sta	_list_object_state, x
 4112                        	
 4113                        		.dbg	line,	"include\routines_LEVELS.c", 327; spr_set(current_object_id + object_start_index);
 4114                        		__ld.um		__check_OBJECT_end - 2  /* current_object_id */
         02:D6D3  AD 01 23   			lda	__check_OBJECT_end - 2
         02:D6D6  C2         			cly
 4115                        		__add.um	_object_start_index
         02:D6D7  18         			clc
         02:D6D8  6D 25 23   			adc	_object_start_index
         02:D6DB  90 01      			bcc	!+
         02:D6DD  C8         			iny
         02:D6DE             	!:
 4116                        		__call		_spr_set.1
         02:D6DE  20 DD E7   			call	_spr_set.1
 4117                        	
 4118                        		.dbg	line,	"include\routines_LEVELS.c", 328; spr_x(list_object_x_pos[current_object_id]);
 4119                        		__ld2x.umq	__check_OBJECT_end - 2  /* current_object_id */
         02:D6E1  AD 01 23   			lda	__check_OBJECT_end - 2
         02:D6E4  0A         			asl	a
         02:D6E5  AA         			tax
 4120                        		__ld.wax	_list_object_x_pos
         02:D6E6  BD D2 24   			lda.l	_list_object_x_pos, x
         02:D6E9  BC D3 24   			ldy.h	_list_object_x_pos, x
 4121                        		__call		_spr_x.1
         02:D6EC  20 0A E8   			call	_spr_x.1
 4122                        	
 4123                        		.dbg	line,	"include\routines_LEVELS.c", 329; spr_y(list_object_y_pos[current_object_id]);
 4124                        		__ld2x.umq	__check_OBJECT_end - 2  /* current_object_id */
         02:D6EF  AD 01 23   			lda	__check_OBJECT_end - 2
         02:D6F2  0A         			asl	a
         02:D6F3  AA         			tax
 4125                        		__ld.wax	_list_object_y_pos
         02:D6F4  BD 04 25   			lda.l	_list_object_y_pos, x
         02:D6F7  BC 05 25   			ldy.h	_list_object_y_pos, x
 4126                        		__call		_spr_y.1
         02:D6FA  20 19 E8   			call	_spr_y.1
 4127                        	
 4128                        		.dbg	line,	"include\routines_LEVELS.c", 330; 
 4129                        	
 4130                        		.dbg	line,	"include\routines_LEVELS.c", 332; switch(current_object_type)
 4131                        		__ld.umq	__check_OBJECT_end - 3  /* current_object_type */
         02:D6FD  AD 00 23   			lda	__check_OBJECT_end - 3
 4132                        		__bra		.LL67
         02:D700  80 4A      			bra	.LL67
 4133                        	
 4134                        		.dbg	line,	"include\routines_LEVELS.c", 333; {
 4135                        	
 4136                        		.dbg	line,	"include\routines_LEVELS.c", 334; case TYPE_HOURGLASS:
 4137    02:D702             	.LL69:
 4138                        		__case		0
 4139                        	
 4140                        		.dbg	line,	"include\routines_LEVELS.c", 335; if(seconds + 30 > 59)
 4141                        		__ld.um		_seconds
         02:D702  AD 23 23   			lda	_seconds
         02:D705  C2         			cly
 4142                        		__add.wi	30
         02:D706  18         			clc
         02:D707  69 1E      			adc.l	#30
         02:D709  90 01      			bcc	!+
         02:D70B  C8         			iny
         02:D70C             	!:
 4143                        		__sgt_w.wi	59
         02:D70C  18         			clc			; Subtract integer+1 from Y:A.
         02:D70D  E9 3B      			sbc.l	#59
         02:D70F  98         			tya
         02:D710  E9 00      			sbc.h	#59
         02:D712  50 02      			bvc	!+
         02:D714  49 80      			eor	#$80		; +ve if Y:A > integer (signed).
         02:D716  49 80      	!:		eor	#$80
         02:D718  0A         			asl	a
 4144                        		__bfalse	.LL70
         02:D719  90 13      			bcc	.LL70
 4145                        	
 4146                        		.dbg	line,	"include\routines_LEVELS.c", 336; {
 4147                        	
 4148                        		.dbg	line,	"include\routines_LEVELS.c", 337; seconds = seconds + 30 - 60;
 4149                        		__ld.um		_seconds
         02:D71B  AD 23 23   			lda	_seconds
         02:D71E  C2         			cly
 4150                        		__sub.wi	30
         02:D71F  38         			sec
         02:D720  E9 1E      			sbc.l	#30
         02:D722  B0 01      			bcs	!+
         02:D724  88         			dey
         02:D725             	!:
 4151                        		__st.umq	_seconds
         02:D725  8D 23 23   			sta	_seconds
 4152                        	
 4153                        		.dbg	line,	"include\routines_LEVELS.c", 338; minutes += 1;
 4154                        		__add_st.umiq	1, _minutes
         02:D728  EE 22 23   			inc	_minutes
 4155                        	
 4156                        		.dbg	line,	"include\routines_LEVELS.c", 339; }
 4157                        	
 4158                        		.dbg	line,	"include\routines_LEVELS.c", 341; else
 4159                        		__bra		.LL71
         02:D72B  4C 08 D6   			bra	.LL71
 4160    02:D72E             	.LL70:
 4161                        	
 4162                        		.dbg	line,	"include\routines_LEVELS.c", 342; {
 4163                        	
 4164                        		.dbg	line,	"include\routines_LEVELS.c", 343; seconds += 30;
 4165                        		__add_st.umiq	30, _seconds
         02:D72E  18         			clc
         02:D72F  AD 23 23   			lda	_seconds
         02:D732  69 1E      			adc	#30
         02:D734  8D 23 23   			sta	_seconds
 4166                        	
 4167                        		.dbg	line,	"include\routines_LEVELS.c", 344; }
 4168    02:D737             	.LL71	.alias		.LL68
 4169                        	
 4170                        		.dbg	line,	"include\routines_LEVELS.c", 346; break;
 4171                        		__bra		.LL68
         02:D737  4C 08 D6   			bra	.LL68
 4172                        	
 4173                        		.dbg	line,	"include\routines_LEVELS.c", 348; case TYPE_POW:
 4174    02:D73A             	.LL72:
 4175                        		__case		2
 4176                        	
 4177                        		.dbg	line,	"include\routines_LEVELS.c", 349; //
 4178                        	
 4179                        		.dbg	line,	"include\routines_LEVELS.c", 350; break;
 4180                        		__bra		.LL68
         02:D73A  4C 08 D6   			bra	.LL68
 4181                        	
 4182                        		.dbg	line,	"include\routines_LEVELS.c", 352; case TYPE_GRAY_KEY:
 4183    02:D73D             	.LL73:
 4184                        		__case		4
 4185                        	
 4186                        		.dbg	line,	"include\routines_LEVELS.c", 353; key_amount += 1;
 4187                        		__add_st.umiq	1, _key_amount
         02:D73D  EE 20 23   			inc	_key_amount
 4188                        	
 4189                        		.dbg	line,	"include\routines_LEVELS.c", 354; display_KEY();
 4190                        		__call		_display_KEY
         02:D740  20 8B FF   			call	_display_KEY
 4191                        	
 4192                        		.dbg	line,	"include\routines_LEVELS.c", 355; break;
 4193                        		__bra		.LL68
         02:D743  4C 08 D6   			bra	.LL68
 4194                        	
 4195                        		.dbg	line,	"include\routines_LEVELS.c", 357; case TYPE_YASHICHI:
 4196    02:D746             	.LL74:
 4197                        		__case		14
 4198                        	
 4199                        		.dbg	line,	"include\routines_LEVELS.c", 358; life_amount += 1;
 4200                        		__add_st.umiq	1, _life_amount
         02:D746  EE 1F 23   			inc	_life_amount
 4201                        	
 4202                        		.dbg	line,	"include\routines_LEVELS.c", 359; break;
 4203                        		__bra		.LL68
         02:D749  4C 08 D6   			bra	.LL68
 4204                        	
 4205                        		.dbg	line,	"include\routines_LEVELS.c", 360; }
 4206    02:D74C             	.LL67:
 4207                        		__switch_c.ur	4
         02:D74C  A2 05      			ldx	#4 + 1
         02:D74E  CA         	!loop:		dex
         02:D74F  F0 05      			beq	!found+
         02:D751  DD 5B D7   			cmp	!table+ - 1, x
         02:D754  D0 F8      			bne	!loop-
         02:D756  8A         	!found:		txa
         02:D757  0A         			asl	a
         02:D758  AA         			tax
         02:D759  7C 60 D7   			jmp	[!table+ + 4, x]
 4208                        	
 4209    02:D75C  0E 04 02 00	!table:		db	14, 4, 2, 0
 4210    02:D760  08 D6      			dw	.LL68
 4211    02:D762  46 D7      			dw	.LL74, .LL73, .LL72, .LL69
         02:D764  3D D7       
         02:D766  3A D7       
         02:D768  02 D7       
 4212                        	
 4213    02:D76A             	.LL68	.alias		.LL61
 4214                        	
 4215                        		.dbg	line,	"include\routines_LEVELS.c", 361; }
 4216                        	
 4217                        		.dbg	line,	"include\routines_LEVELS.c", 362; }
 4218    02:D76A             	.LL66	.alias		.LL61
 4219                        	
 4220                        		.dbg	line,	"include\routines_LEVELS.c", 363; }
 4221    02:D76A             	.LL65	.alias		.LL61
 4222                        	
 4223                        		.dbg	line,	"include\routines_LEVELS.c", 364; }
 4224    02:D76A             	.LL64	.alias		.LL61
 4225                        		__bra		.LL61
         02:D76A  4C 08 D6   			bra	.LL61
 4226    02:D76D             	.LL63:
 4227                        	
 4228                        		.dbg	line,	"include\routines_LEVELS.c", 365; }
 4229                        	
 4230                        		.dbg	line,	"include\routines_LEVELS.c", 366; }
 4231    02:D76D             	.LL59:
 4232    02:D76D             	.LL58:
 4233                        		__return	0
         02:D76D  4C EF FF   			jmp	leave_proc
 4234                        		.dbg	clear
 4235                        		.endp
 4236               7960     		.data
 4237               2300     		.bss
 4238    F8:2300             	__check_OBJECT_loc:
 4239    F8:2300             			ds	3
 4240    F8:2303             	__check_OBJECT_end:
 4241               E309     		.code
 4242                        		.pceas
 4243                        	
 4244                        		.dbg	line,	"include\routines_LEVELS.c", 368; // CHECK COLLISION WITH NPCS //
 4245                        		.dbg	line,	"include\routines_LEVELS.c", 369; void check_NPC()
 4246                        		.dbg	line,	"include\routines_LEVELS.c", 370; {
 4247                        	;***********************
 4248                        	;***********************
 4249                        	
 4250                        		.hucc
 4251    01:DEC8             		.proc		_check_NPC
 4252                        		__enter		_check_NPC
 4253                        	
 4254                        		.dbg	line,	"include\routines_LEVELS.c", 371; if(onscreen_npc_number != 0)
 4255                        		__tst.um	_onscreen_npc_number
         01:DEC8  AD A9 23   			lda	_onscreen_npc_number
         01:DECB  C9 01      			cmp	#1
 4256                        		__bfalse	.LL76
         01:DECD  B0 03 4C F2			bcc	.LL76
         01:DED1  DF          
 4257                        	
 4258                        		.dbg	line,	"include\routines_LEVELS.c", 372; {
 4259                        	
 4260                        		.dbg	line,	"include\routines_LEVELS.c", 373; if(player_state == STATE_IDLE || player_state == STATE_WALK)
 4261                        		__not.um	_player_state
         01:DED2  AD 15 23   			lda	_player_state
         01:DED5  18         			clc
         01:DED6  D0 01      			bne	!+
         01:DED8  38         			sec
         01:DED9             	!:
 4262                        		__btrue		.LL78
         01:DED9  B0 08      			bcs	.LL78
 4263                        		__ld.umq	_player_state
         01:DEDB  AD 15 23   			lda	_player_state
 4264                        		__equ_b.uiq	1
         01:DEDE  C9 01      			cmp	#1
         01:DEE0  F0 01      			beq	!+
         01:DEE2  18         			clc
         01:DEE3             	!:
 4265    01:DEE3             	.LL78:
 4266                        		__bfalse	.LL77
         01:DEE3  B0 03 4C F2			bcc	.LL77
         01:DEE7  DF          
 4267                        	
 4268                        		.dbg	line,	"include\routines_LEVELS.c", 374; {
 4269                        	
 4270                        		.dbg	line,	"include\routines_LEVELS.c", 375; char i;
 4271                        	
 4272                        		.dbg	line,	"include\routines_LEVELS.c", 376; char current_npc_id;
 4273                        	
 4274                        		.dbg	line,	"include\routines_LEVELS.c", 377; char current_npc_type;
 4275                        	
 4276                        		.dbg	line,	"include\routines_LEVELS.c", 379; for(i=0 ; i<onscreen_npc_number ; i++)
 4277                        		__st.umiq	0, __check_NPC_end - 1  /* i */
         01:DEE8  9C 3F 26   			stz	__check_NPC_end - 1
 4278    01:DEEB             	.LL79:
 4279                        		__ld.umq	__check_NPC_end - 1  /* i */
         01:DEEB  AD 3F 26   			lda	__check_NPC_end - 1
 4280                        		__ult_b.umq	_onscreen_npc_number
         01:DEEE  CD A9 23   			cmp	_onscreen_npc_number		; Subtract memory from A.
         01:DEF1  6A         			ror	a		; CC if A < memory.
         01:DEF2  49 80      			eor	#$80
         01:DEF4  2A         			rol	a
 4281                        		__btrue		.LL81
         01:DEF5  B0 08      			bcs	.LL81
 4282                        		__bra		.LL82
         01:DEF7  4C F2 DF   			bra	.LL82
 4283    01:DEFA             	.LL80:
 4284                        		__inc.umq	__check_NPC_end - 1  /* i */
         01:DEFA  EE 3F 26   			inc	__check_NPC_end - 1
 4285                        		__bra		.LL79
         01:DEFD  80 EC      			bra	.LL79
 4286    01:DEFF             	.LL81:
 4287                        	
 4288                        		.dbg	line,	"include\routines_LEVELS.c", 380; {
 4289                        	
 4290                        		.dbg	line,	"include\routines_LEVELS.c", 381; // RETRIEVE NPC INDEX IN THE LIST //
 4291                        	
 4292                        		.dbg	line,	"include\routines_LEVELS.c", 382; current_npc_id = list_onscreen_npc[i];
 4293                        		__ldx.umq	__check_NPC_end - 1  /* i */
         01:DEFF  AE 3F 26   			ldx	__check_NPC_end - 1
 4294                        		__ld.uax	_list_onscreen_npc
         01:DF02  BD BC 23   			lda	_list_onscreen_npc, x
         01:DF05  C2         			cly
 4295                        		__st.umq	__check_NPC_end - 2  /* current_npc_id */
         01:DF06  8D 3E 26   			sta	__check_NPC_end - 2
 4296                        	
 4297                        		.dbg	line,	"include\routines_LEVELS.c", 384; if(list_npc_state[current_npc_id] == STATE_ACTIVE)
 4298                        		__ldx.umq	__check_NPC_end - 2  /* current_npc_id */
         01:DF09  AE 3E 26   			ldx	__check_NPC_end - 2
 4299                        		__not.uax	_list_npc_state
         01:DF0C  BD B3 23   			lda	_list_npc_state, x
         01:DF0F  18         			clc
         01:DF10  D0 01      			bne	!+
         01:DF12  38         			sec
         01:DF13             	!:
 4300                        		__bfalse	.LL83
         01:DF13  90 E5      			bcc	.LL83
 4301                        	
 4302                        		.dbg	line,	"include\routines_LEVELS.c", 385; {
 4303                        	
 4304                        		.dbg	line,	"include\routines_LEVELS.c", 386; // RETRIEVE NPC TYPE //
 4305                        	
 4306                        		.dbg	line,	"include\routines_LEVELS.c", 387; current_npc_type = list_npc_type[current_npc_id];
 4307                        		__ldx.umq	__check_NPC_end - 2  /* current_npc_id */
         01:DF15  AE 3E 26   			ldx	__check_NPC_end - 2
 4308                        		__ld.uax	_list_npc_type
         01:DF18  BD AA 23   			lda	_list_npc_type, x
         01:DF1B  C2         			cly
 4309                        		__st.umq	__check_NPC_end - 3  /* current_npc_type */
         01:DF1C  8D 3D 26   			sta	__check_NPC_end - 3
 4310                        	
 4311                        		.dbg	line,	"include\routines_LEVELS.c", 389; if(abs( (player_pos_x + 16) - (list_npc_x_pos[current_npc_id] + 16) ) < OBJECT_MARGIN)
 4312                        		__ld.wm		_player_pos_x
         01:DF1F  AD C8 24   			lda.l	_player_pos_x
         01:DF22  AC C9 24   			ldy.h	_player_pos_x
 4313                        		__add.wi	16
         01:DF25  18         			clc
         01:DF26  69 10      			adc.l	#16
         01:DF28  90 01      			bcc	!+
         01:DF2A  C8         			iny
         01:DF2B             	!:
 4314                        		__push.wr
         01:DF2B  5A         			phy
         01:DF2C  48         			pha
 4315                        		__ld2x.umq	__check_NPC_end - 2  /* current_npc_id */
         01:DF2D  AD 3E 26   			lda	__check_NPC_end - 2
         01:DF30  0A         			asl	a
         01:DF31  AA         			tax
 4316                        		__ld.wax	_list_npc_x_pos
         01:DF32  BD DA 25   			lda.l	_list_npc_x_pos, x
         01:DF35  BC DB 25   			ldy.h	_list_npc_x_pos, x
 4317                        		__add.wi	16
         01:DF38  18         			clc
         01:DF39  69 10      			adc.l	#16
         01:DF3B  90 01      			bcc	!+
         01:DF3D  C8         			iny
         01:DF3E             	!:
 4318                        		__sub.wt
         01:DF3E  BA         			tsx
         01:DF3F  38         			sec
         01:DF40  49 FF      			eor	#$FF
         01:DF42  7D 01 21   			adc.l	__tos, x
         01:DF45  42         			say
         01:DF46  49 FF      			eor	#$FF
         01:DF48  7D 02 21   			adc.h	__tos, x
         01:DF4B  42         			say
         01:DF4C  E8         			inx
         01:DF4D  E8         			inx
         01:DF4E  9A         			txs
 4319                        		__call		_abs.1
         01:DF4F  20 09 E5   			call	_abs.1
 4320                        		__slt_w.wi	10
         01:DF52  C9 0A      			cmp.l	#10		; Subtract integer from Y:A.
         01:DF54  98         			tya
         01:DF55  E9 00      			sbc.h	#10
         01:DF57  50 02      			bvc	!+
         01:DF59  49 80      			eor	#$80		; -ve if Y:A < integer (signed).
         01:DF5B  0A         	!:		asl	a
 4321                        		__bfalse	.LL84
         01:DF5C  90 9C      			bcc	.LL84
 4322                        	
 4323                        		.dbg	line,	"include\routines_LEVELS.c", 390; {
 4324                        	
 4325                        		.dbg	line,	"include\routines_LEVELS.c", 391; if(abs( (player_pos_y + 16) - (list_npc_y_pos[current_npc_id] + 16) ) < OBJECT_MARGIN)
 4326                        		__ld.wm		_player_pos_y
         01:DF5E  AD CA 24   			lda.l	_player_pos_y
         01:DF61  AC CB 24   			ldy.h	_player_pos_y
 4327                        		__add.wi	16
         01:DF64  18         			clc
         01:DF65  69 10      			adc.l	#16
         01:DF67  90 01      			bcc	!+
         01:DF69  C8         			iny
         01:DF6A             	!:
 4328                        		__push.wr
         01:DF6A  5A         			phy
         01:DF6B  48         			pha
 4329                        		__ld2x.umq	__check_NPC_end - 2  /* current_npc_id */
         01:DF6C  AD 3E 26   			lda	__check_NPC_end - 2
         01:DF6F  0A         			asl	a
         01:DF70  AA         			tax
 4330                        		__ld.wax	_list_npc_y_pos
         01:DF71  BD EC 25   			lda.l	_list_npc_y_pos, x
         01:DF74  BC ED 25   			ldy.h	_list_npc_y_pos, x
 4331                        		__add.wi	16
         01:DF77  18         			clc
         01:DF78  69 10      			adc.l	#16
         01:DF7A  90 01      			bcc	!+
         01:DF7C  C8         			iny
         01:DF7D             	!:
 4332                        		__sub.wt
         01:DF7D  BA         			tsx
         01:DF7E  38         			sec
         01:DF7F  49 FF      			eor	#$FF
         01:DF81  7D 01 21   			adc.l	__tos, x
         01:DF84  42         			say
         01:DF85  49 FF      			eor	#$FF
         01:DF87  7D 02 21   			adc.h	__tos, x
         01:DF8A  42         			say
         01:DF8B  E8         			inx
         01:DF8C  E8         			inx
         01:DF8D  9A         			txs
 4333                        		__call		_abs.1
         01:DF8E  20 09 E5   			call	_abs.1
 4334                        		__slt_w.wi	10
         01:DF91  C9 0A      			cmp.l	#10		; Subtract integer from Y:A.
         01:DF93  98         			tya
         01:DF94  E9 00      			sbc.h	#10
         01:DF96  50 02      			bvc	!+
         01:DF98  49 80      			eor	#$80		; -ve if Y:A < integer (signed).
         01:DF9A  0A         	!:		asl	a
 4335                        		__bfalse	.LL85
         01:DF9B  B0 03 4C FA			bcc	.LL85
         01:DF9F  DE          
 4336                        	
 4337                        		.dbg	line,	"include\routines_LEVELS.c", 392; {               
 4338                        	
 4339                        		.dbg	line,	"include\routines_LEVELS.c", 393; switch(current_npc_type)
 4340                        		__ld.umq	__check_NPC_end - 3  /* current_npc_type */
         01:DFA0  AD 3D 26   			lda	__check_NPC_end - 3
 4341                        		__bra		.LL86
         01:DFA3  80 39      			bra	.LL86
 4342                        	
 4343                        		.dbg	line,	"include\routines_LEVELS.c", 394; {
 4344                        	
 4345                        		.dbg	line,	"include\routines_LEVELS.c", 395; case TYPE_NPC_REWARD:
 4346    01:DFA5             	.LL88:
 4347                        		__case		0
 4348                        	
 4349                        		.dbg	line,	"include\routines_LEVELS.c", 396; //
 4350                        	
 4351                        		.dbg	line,	"include\routines_LEVELS.c", 397; break;
 4352                        		__bra		.LL87
         01:DFA5  4C FA DE   			bra	.LL87
 4353                        	
 4354                        		.dbg	line,	"include\routines_LEVELS.c", 399; case TYPE_NPC_SHOP:
 4355    01:DFA8             	.LL89:
 4356                        		__case		1
 4357                        	
 4358                        		.dbg	line,	"include\routines_LEVELS.c", 400; list_npc_state[current_npc_id] = STATE_INACTIVE;
 4359                        		__ldx.umq	__check_NPC_end - 2  /* current_npc_id */
         01:DFA8  AE 3E 26   			ldx	__check_NPC_end - 2
 4360                        		__st.uaxiq	1, _list_npc_state
         01:DFAB  A9 01      			lda.l	#1
         01:DFAD  9D B3 23   			sta	_list_npc_state, x
 4361                        	
 4362                        		.dbg	line,	"include\routines_LEVELS.c", 401; camera_pos_x_backup = sgx_map_pxl_x;
 4363                        		__ld.wm		_sgx_map_pxl_x
         01:DFB0  AD 84 26   			lda.l	_sgx_map_pxl_x
         01:DFB3  AC 85 26   			ldy.h	_sgx_map_pxl_x
 4364                        		__st.wmq	_camera_pos_x_backup
         01:DFB6  8D CE 24   			sta.l	_camera_pos_x_backup
         01:DFB9  8C CF 24   			sty.h	_camera_pos_x_backup
 4365                        	
 4366                        		.dbg	line,	"include\routines_LEVELS.c", 402; camera_pos_y_backup = list_npc_y_pos_ref[current_npc_id] - 128;
 4367                        		__ld2x.umq	__check_NPC_end - 2  /* current_npc_id */
         01:DFBC  AD 3E 26   			lda	__check_NPC_end - 2
         01:DFBF  0A         			asl	a
         01:DFC0  AA         			tax
 4368                        		__ld.wax	_list_npc_y_pos_ref
         01:DFC1  BD 10 26   			lda.l	_list_npc_y_pos_ref, x
         01:DFC4  BC 11 26   			ldy.h	_list_npc_y_pos_ref, x
 4369                        		__sub.wi	128
         01:DFC7  38         			sec
         01:DFC8  E9 80      			sbc.l	#128
         01:DFCA  B0 01      			bcs	!+
         01:DFCC  88         			dey
         01:DFCD             	!:
 4370                        		__st.wmq	_camera_pos_y_backup
         01:DFCD  8D D0 24   			sta.l	_camera_pos_y_backup
         01:DFD0  8C D1 24   			sty.h	_camera_pos_y_backup
 4371                        	
 4372                        		.dbg	line,	"include\routines_LEVELS.c", 403; sequence_loaded = FALSE;
 4373                        		__st.umiq	0, _sequence_loaded
         01:DFD3  9C 11 23   			stz	_sequence_loaded
 4374                        	
 4375                        		.dbg	line,	"include\routines_LEVELS.c", 404; sequence_id = SEQUENCE_SHOP;
 4376                        		__st.umiq	4, _sequence_id
         01:DFD6  A9 04      			lda.l	#4
         01:DFD8  8D 10 23   			sta	_sequence_id
 4377                        	
 4378                        		.dbg	line,	"include\routines_LEVELS.c", 405; break;
 4379                        		__bra		.LL87
         01:DFDB  4C FA DE   			bra	.LL87
 4380                        	
 4381                        		.dbg	line,	"include\routines_LEVELS.c", 406; }
 4382    01:DFDE             	.LL86:
 4383                        		__switch_r.ur	0, 1
         01:DFDE  C9 02      			cmp	#(1 - 0) + 1
         01:DFE0  90 02      			bcc	!found+
         01:DFE2  A9 02      	!default:	lda	#(1 - 0) + 1
         01:DFE4  0A         	!found:		asl	a
         01:DFE5  AA         			tax
         01:DFE6  7C E9 DF   			jmp	[!table+, x]
 4384                        	
 4385    01:DFE9  A5 DF      	!table:		dw	.LL88, .LL89
         01:DFEB  A8 DF       
 4386    01:DFED  FA DE      			dw	.LL87
 4387    01:DFEF             	.LL87	.alias		.LL80
 4388                        	
 4389                        		.dbg	line,	"include\routines_LEVELS.c", 407; }
 4390                        	
 4391                        		.dbg	line,	"include\routines_LEVELS.c", 408; }
 4392    01:DFEF             	.LL85	.alias		.LL80
 4393                        	
 4394                        		.dbg	line,	"include\routines_LEVELS.c", 409; }
 4395    01:DFEF             	.LL84	.alias		.LL80
 4396                        	
 4397                        		.dbg	line,	"include\routines_LEVELS.c", 410; }
 4398    01:DFEF             	.LL83	.alias		.LL80
 4399                        		__bra		.LL80
         01:DFEF  4C FA DE   			bra	.LL80
 4400    01:DFF2             	.LL82:
 4401                        	
 4402                        		.dbg	line,	"include\routines_LEVELS.c", 411; }
 4403                        	
 4404                        		.dbg	line,	"include\routines_LEVELS.c", 412; }
 4405    01:DFF2             	.LL77:
 4406                        	
 4407                        		.dbg	line,	"include\routines_LEVELS.c", 413; }
 4408    01:DFF2             	.LL76:
 4409    01:DFF2             	.LL75:
 4410                        		__return	0
         01:DFF2  4C EF FF   			jmp	leave_proc
 4411                        		.dbg	clear
 4412                        		.endp
 4413                        		.pceas
 4414                        	
 4415                        		.dbg	line,	"include\routines_LEVELS.c", 419; void scroll_BG()
 4416                        		.dbg	line,	"include\routines_LEVELS.c", 420; {
 4417                        	;***********************
 4418                        	;***********************
 4419                        	
 4420                        		.hucc
 4421    11:C8B6             		.proc		_scroll_BG
 4422                        		__enter		_scroll_BG
 4423                        	
 4424                        		.dbg	line,	"include\routines_LEVELS.c", 421; // UPDATE VDC2 BG //
 4425                        	
 4426                        		.dbg	line,	"include\routines_LEVELS.c", 422; sgx_scroll_map();
 4427                        		__call		_sgx_scroll_map
         11:C8B6  20 81 FF   			call	_sgx_scroll_map
 4428                        	
 4429                        		.dbg	line,	"include\routines_LEVELS.c", 424; //--------------------------------------------------------------------------------------//
 4430                        	
 4431                        		.dbg	line,	"include\routines_LEVELS.c", 425; //                                        VDC 2                                         //
 4432                        	
 4433                        		.dbg	line,	"include\routines_LEVELS.c", 426; //--------------------------------------------------------------------------------------//
 4434                        	
 4435                        		.dbg	line,	"include\routines_LEVELS.c", 428; sgx_scroll_split(0,   0, sgx_map_pxl_x & (BAT_SIZE_W - 1), sgx_map_pxl_y & (BAT_SIZE_H - 1), BKG_ON | SPR_ON);
 4436                        		__st.umiq	0, _al
         11:C8B9  64 F8      			stz	_al
 4437                        		__st.umiq	0, _ah
         11:C8BB  64 F9      			stz	_ah
 4438                        		__ld.wm		_sgx_map_pxl_x
         11:C8BD  AD 84 26   			lda.l	_sgx_map_pxl_x
         11:C8C0  AC 85 26   			ldy.h	_sgx_map_pxl_x
 4439                        		__and.wi	2047
         11:C8C3  29 FF      			and.l	#2047
         11:C8C5  42         			say
         11:C8C6  29 07      			and.h	#2047
         11:C8C8  42         			say
 4440                        		__st.wmq	_bx
         11:C8C9  85 FA      			sta.l	_bx
         11:C8CB  84 FB      			sty.h	_bx
 4441                        		__ld.wm		_sgx_map_pxl_y
         11:C8CD  AD 86 26   			lda.l	_sgx_map_pxl_y
         11:C8D0  AC 87 26   			ldy.h	_sgx_map_pxl_y
 4442                        		__and.wi	255
         11:C8D3  29 FF      			and	#255
         11:C8D5  C2         			cly
 4443                        		__st.wmq	_cx
         11:C8D6  85 FC      			sta.l	_cx
         11:C8D8  84 FD      			sty.h	_cx
 4444                        		__st.umiq	192, _dl
         11:C8DA  A9 C0      			lda.l	#192
         11:C8DC  85 FE      			sta	_dl
 4445                        		__call		_sgx_scroll_split.5
         11:C8DE  20 77 FF   			call	_sgx_scroll_split.5
 4446                        	
 4447                        		.dbg	line,	"include\routines_LEVELS.c", 429; }
 4448    11:C8E1             	.LL90:
 4449                        		__return	0
         11:C8E1  4C EF FF   			jmp	leave_proc
 4450                        		.dbg	clear
 4451                        		.endp
 4452                        		.pceas
 4453                        	
 4454                        		.dbg	line,	"include\routines_LEVELS.c", 432; void recenter_CAMERA()
 4455                        		.dbg	line,	"include\routines_LEVELS.c", 433; {
 4456                        	;***********************
 4457                        	;***********************
 4458                        	
 4459                        		.hucc
 4460    02:DCE2             		.proc		_recenter_CAMERA
 4461                        		__enter		_recenter_CAMERA
 4462                        	
 4463                        		.dbg	line,	"include\routines_LEVELS.c", 434; signed char camera_y_move;
 4464                        	
 4465                        		.dbg	line,	"include\routines_LEVELS.c", 436; spr_set(player_id);
 4466                        		__ld.umq	_player_id
         02:DCE2  AD 14 23   			lda	_player_id
 4467                        		__call		_spr_set.1
         02:DCE5  20 DD E7   			call	_spr_set.1
 4468                        	
 4469                        		.dbg	line,	"include\routines_LEVELS.c", 439; if(player_pos_y < 128)
 4470                        		__ld.wm		_player_pos_y
         02:DCE8  AD CA 24   			lda.l	_player_pos_y
         02:DCEB  AC CB 24   			ldy.h	_player_pos_y
 4471                        		__slt_w.wi	128
         02:DCEE  C9 80      			cmp.l	#128		; Subtract integer from Y:A.
         02:DCF0  98         			tya
         02:DCF1  E9 00      			sbc.h	#128
         02:DCF3  50 02      			bvc	!+
         02:DCF5  49 80      			eor	#$80		; -ve if Y:A < integer (signed).
         02:DCF7  0A         	!:		asl	a
 4472                        		__bfalse	.LL92
         02:DCF8  90 70      			bcc	.LL92
 4473                        	
 4474                        		.dbg	line,	"include\routines_LEVELS.c", 440; {
 4475                        	
 4476                        		.dbg	line,	"include\routines_LEVELS.c", 441; player_pos_y += CAMERA_RECENTER_VELOCITY;
 4477                        		__add_st.wmiq	4, _player_pos_y
         02:DCFA  18         			clc
         02:DCFB  AD CA 24   			lda.l	_player_pos_y
         02:DCFE  69 04      			adc.l	#4
         02:DD00  8D CA 24   			sta.l	_player_pos_y
         02:DD03  90 03      			bcc	!+
         02:DD05  EE CB 24   			inc.h	_player_pos_y
         02:DD08             	!:
 4478                        	
 4479                        		.dbg	line,	"include\routines_LEVELS.c", 443; if(player_pos_y > 128)
 4480                        		__ld.wm		_player_pos_y
         02:DD08  AD CA 24   			lda.l	_player_pos_y
         02:DD0B  AC CB 24   			ldy.h	_player_pos_y
 4481                        		__sgt_w.wi	128
         02:DD0E  18         			clc			; Subtract integer+1 from Y:A.
         02:DD0F  E9 80      			sbc.l	#128
         02:DD11  98         			tya
         02:DD12  E9 00      			sbc.h	#128
         02:DD14  50 02      			bvc	!+
         02:DD16  49 80      			eor	#$80		; +ve if Y:A > integer (signed).
         02:DD18  49 80      	!:		eor	#$80
         02:DD1A  0A         			asl	a
 4482                        		__bfalse	.LL93
         02:DD1B  90 24      			bcc	.LL93
 4483                        	
 4484                        		.dbg	line,	"include\routines_LEVELS.c", 444; {
 4485                        	
 4486                        		.dbg	line,	"include\routines_LEVELS.c", 445; camera_y_move = CAMERA_RECENTER_VELOCITY - (player_pos_y - 128);
 4487                        		__ld.wm		_player_pos_y
         02:DD1D  AD CA 24   			lda.l	_player_pos_y
         02:DD20  AC CB 24   			ldy.h	_player_pos_y
 4488                        		__sub.wi	128
         02:DD23  38         			sec
         02:DD24  E9 80      			sbc.l	#128
         02:DD26  B0 01      			bcs	!+
         02:DD28  88         			dey
         02:DD29             	!:
 4489                        		__isub.wi	4
         02:DD29  38         			sec
         02:DD2A  49 FF      			eor	#$FF
         02:DD2C  69 04      			adc.l	#4
         02:DD2E  42         			say
         02:DD2F  49 FF      			eor	#$FF
         02:DD31  69 00      			adc.h	#4
         02:DD33  42         			say
 4490                        		__st.umq	__recenter_CAMERA_end - 1  /* camera_y_move */
         02:DD34  8D 3F 26   			sta	__recenter_CAMERA_end - 1
 4491                        	
 4492                        		.dbg	line,	"include\routines_LEVELS.c", 447; player_pos_y = 128;
 4493                        		__st.wmiq	128, _player_pos_y
         02:DD37  A9 80      			lda.l	#128
         02:DD39  8D CA 24   			sta.l	_player_pos_y
         02:DD3C  9C CB 24   			stz.h	_player_pos_y
 4494                        	
 4495                        		.dbg	line,	"include\routines_LEVELS.c", 448; }
 4496                        	
 4497                        		.dbg	line,	"include\routines_LEVELS.c", 450; else
 4498                        		__bra		.LL94
         02:DD3F  80 05      			bra	.LL94
 4499    02:DD41             	.LL93:
 4500                        	
 4501                        		.dbg	line,	"include\routines_LEVELS.c", 451; {
 4502                        	
 4503                        		.dbg	line,	"include\routines_LEVELS.c", 452; camera_y_move = CAMERA_RECENTER_VELOCITY;
 4504                        		__st.umiq	4, __recenter_CAMERA_end - 1  /* camera_y_move */
         02:DD41  A9 04      			lda.l	#4
         02:DD43  8D 3F 26   			sta	__recenter_CAMERA_end - 1
 4505                        	
 4506                        		.dbg	line,	"include\routines_LEVELS.c", 453; }
 4507    02:DD46             	.LL94:
 4508                        	
 4509                        		.dbg	line,	"include\routines_LEVELS.c", 455; spr_y(player_pos_y);
 4510                        		__ld.wm		_player_pos_y
         02:DD46  AD CA 24   			lda.l	_player_pos_y
         02:DD49  AC CB 24   			ldy.h	_player_pos_y
 4511                        		__call		_spr_y.1
         02:DD4C  20 19 E8   			call	_spr_y.1
 4512                        	
 4513                        		.dbg	line,	"include\routines_LEVELS.c", 457; sgx_map_pxl_y -= camera_y_move;
 4514                        		__ld.bm		__recenter_CAMERA_end - 1  /* camera_y_move */
         02:DD4F  AD 3F 26   			lda	__recenter_CAMERA_end - 1
         02:DD52  C2         			cly
         02:DD53  10 01      			bpl	!+
         02:DD55  88         			dey
         02:DD56             	!:
 4515                        		__isub_st.wmq	_sgx_map_pxl_y
         02:DD56  38         			sec
         02:DD57  49 FF      			eor	#$FF
         02:DD59  6D 86 26   			adc.l	_sgx_map_pxl_y
         02:DD5C  8D 86 26   			sta.l	_sgx_map_pxl_y
         02:DD5F  98         			tya
         02:DD60  49 FF      			eor	#$FF
         02:DD62  6D 87 26   			adc.h	_sgx_map_pxl_y
         02:DD65  8D 87 26   			sta.h	_sgx_map_pxl_y
 4516                        	
 4517                        		.dbg	line,	"include\routines_LEVELS.c", 458; }
 4518                        	
 4519                        		.dbg	line,	"include\routines_LEVELS.c", 461; else if(player_pos_y > 128)
 4520                        		__bra		.LL95
         02:DD68  80 7C      			bra	.LL95
 4521    02:DD6A             	.LL92:
 4522                        		__ld.wm		_player_pos_y
         02:DD6A  AD CA 24   			lda.l	_player_pos_y
         02:DD6D  AC CB 24   			ldy.h	_player_pos_y
 4523                        		__sgt_w.wi	128
         02:DD70  18         			clc			; Subtract integer+1 from Y:A.
         02:DD71  E9 80      			sbc.l	#128
         02:DD73  98         			tya
         02:DD74  E9 00      			sbc.h	#128
         02:DD76  50 02      			bvc	!+
         02:DD78  49 80      			eor	#$80		; +ve if Y:A > integer (signed).
         02:DD7A  49 80      	!:		eor	#$80
         02:DD7C  0A         			asl	a
 4524                        		__bfalse	.LL96
         02:DD7D  90 67      			bcc	.LL96
 4525                        	
 4526                        		.dbg	line,	"include\routines_LEVELS.c", 462; {
 4527                        	
 4528                        		.dbg	line,	"include\routines_LEVELS.c", 463; player_pos_y -= CAMERA_RECENTER_VELOCITY;
 4529                        		__sub_st.wmiq	4, _player_pos_y
         02:DD7F  38         			sec
         02:DD80  AD CA 24   			lda.l	_player_pos_y
         02:DD83  E9 04      			sbc.l	#4
         02:DD85  8D CA 24   			sta.l	_player_pos_y
         02:DD88  B0 03      			bcs	!+
         02:DD8A  CE CB 24   			dec.h	_player_pos_y
         02:DD8D             	!:
 4530                        	
 4531                        		.dbg	line,	"include\routines_LEVELS.c", 465; if(player_pos_y < 128)
 4532                        		__ld.wm		_player_pos_y
         02:DD8D  AD CA 24   			lda.l	_player_pos_y
         02:DD90  AC CB 24   			ldy.h	_player_pos_y
 4533                        		__slt_w.wi	128
         02:DD93  C9 80      			cmp.l	#128		; Subtract integer from Y:A.
         02:DD95  98         			tya
         02:DD96  E9 00      			sbc.h	#128
         02:DD98  50 02      			bvc	!+
         02:DD9A  49 80      			eor	#$80		; -ve if Y:A < integer (signed).
         02:DD9C  0A         	!:		asl	a
 4534                        		__bfalse	.LL97
         02:DD9D  90 24      			bcc	.LL97
 4535                        	
 4536                        		.dbg	line,	"include\routines_LEVELS.c", 466; {
 4537                        	
 4538                        		.dbg	line,	"include\routines_LEVELS.c", 467; camera_y_move = CAMERA_RECENTER_VELOCITY - (128 - player_pos_y);
 4539                        		__ld.wi		128
         02:DD9F  A9 80      			lda.l	#128
         02:DDA1  C2         			cly
 4540                        		__sub.wm	_player_pos_y
         02:DDA2  38         			sec
         02:DDA3  ED CA 24   			sbc.l	_player_pos_y
         02:DDA6  42         			say
         02:DDA7  ED CB 24   			sbc.h	_player_pos_y
         02:DDAA  42         			say
 4541                        		__isub.wi	4
         02:DDAB  38         			sec
         02:DDAC  49 FF      			eor	#$FF
         02:DDAE  69 04      			adc.l	#4
         02:DDB0  42         			say
         02:DDB1  49 FF      			eor	#$FF
         02:DDB3  69 00      			adc.h	#4
         02:DDB5  42         			say
 4542                        		__st.umq	__recenter_CAMERA_end - 1  /* camera_y_move */
         02:DDB6  8D 3F 26   			sta	__recenter_CAMERA_end - 1
 4543                        	
 4544                        		.dbg	line,	"include\routines_LEVELS.c", 469; player_pos_y = 128;
 4545                        		__st.wmiq	128, _player_pos_y
         02:DDB9  A9 80      			lda.l	#128
         02:DDBB  8D CA 24   			sta.l	_player_pos_y
         02:DDBE  9C CB 24   			stz.h	_player_pos_y
 4546                        	
 4547                        		.dbg	line,	"include\routines_LEVELS.c", 470; }
 4548                        	
 4549                        		.dbg	line,	"include\routines_LEVELS.c", 472; else
 4550                        		__bra		.LL98
         02:DDC1  80 05      			bra	.LL98
 4551    02:DDC3             	.LL97:
 4552                        	
 4553                        		.dbg	line,	"include\routines_LEVELS.c", 473; {
 4554                        	
 4555                        		.dbg	line,	"include\routines_LEVELS.c", 474; camera_y_move = CAMERA_RECENTER_VELOCITY;
 4556                        		__st.umiq	4, __recenter_CAMERA_end - 1  /* camera_y_move */
         02:DDC3  A9 04      			lda.l	#4
         02:DDC5  8D 3F 26   			sta	__recenter_CAMERA_end - 1
 4557                        	
 4558                        		.dbg	line,	"include\routines_LEVELS.c", 475; }
 4559    02:DDC8             	.LL98:
 4560                        	
 4561                        		.dbg	line,	"include\routines_LEVELS.c", 477; spr_y(player_pos_y);
 4562                        		__ld.wm		_player_pos_y
         02:DDC8  AD CA 24   			lda.l	_player_pos_y
         02:DDCB  AC CB 24   			ldy.h	_player_pos_y
 4563                        		__call		_spr_y.1
         02:DDCE  20 19 E8   			call	_spr_y.1
 4564                        	
 4565                        		.dbg	line,	"include\routines_LEVELS.c", 479; sgx_map_pxl_y += camera_y_move;
 4566                        		__ld.bm		__recenter_CAMERA_end - 1  /* camera_y_move */
         02:DDD1  AD 3F 26   			lda	__recenter_CAMERA_end - 1
         02:DDD4  C2         			cly
         02:DDD5  10 01      			bpl	!+
         02:DDD7  88         			dey
         02:DDD8             	!:
 4567                        		__add_st.wmq	_sgx_map_pxl_y
         02:DDD8  18         			clc
         02:DDD9  6D 86 26   			adc.l	_sgx_map_pxl_y
         02:DDDC  8D 86 26   			sta.l	_sgx_map_pxl_y
         02:DDDF  98         			tya
         02:DDE0  6D 87 26   			adc.h	_sgx_map_pxl_y
         02:DDE3  8D 87 26   			sta.h	_sgx_map_pxl_y
 4568                        	
 4569                        		.dbg	line,	"include\routines_LEVELS.c", 480; }
 4570                        	
 4571                        		.dbg	line,	"include\routines_LEVELS.c", 481; }
 4572    02:DDE6             	.LL96:
 4573    02:DDE6             	.LL95:
 4574    02:DDE6             	.LL91:
 4575                        		__return	0
         02:DDE6  4C EF FF   			jmp	leave_proc
 4576                        		.dbg	clear
 4577                        		.endp
 4578                        		.pceas
 4579                        	
 4580                        		.dbg	line,	"include\routines_LEVELS.c", 490; void joypad_BUTTONS()
 4581                        		.dbg	line,	"include\routines_LEVELS.c", 491; {
 4582                        	;***********************
 4583                        	;***********************
 4584                        	
 4585                        		.hucc
 4586    11:C000             		.proc		_joypad_BUTTONS
 4587                        		__enter		_joypad_BUTTONS
 4588                        	
 4589                        		.dbg	line,	"include\routines_LEVELS.c", 492; if(joytrg(JOYPAD_1) == JOY_I)
 4590                        		__ld.uiq	0
         11:C000  62         			cla
 4591                        		 _joytrg.1
         11:C001  AA         			tax
         11:C002  BD 2D 22   			lda	joytrg, x
         11:C005  BC DD 22   			ldy	joy6trg, x
 4592                        		__equ_w.wi	1
         11:C008  C9 01      			cmp.l	#1
         11:C00A  D0 04      			bne	!false+
         11:C00C  C0 00      			cpy.h	#1
         11:C00E  F0 01      			beq	!+
         11:C010  18         	!false:		clc
         11:C011             	!:
 4593                        		__bfalse	.LL100
         11:C011  B0 03 4C D1			bcc	.LL100
         11:C015  C0          
 4594                        	
 4595                        		.dbg	line,	"include\routines_LEVELS.c", 493; {
 4596                        	
 4597                        		.dbg	line,	"include\routines_LEVELS.c", 494; if(player_state == STATE_IDLE)
 4598                        		__not.um	_player_state
         11:C016  AD 15 23   			lda	_player_state
         11:C019  18         			clc
         11:C01A  D0 01      			bne	!+
         11:C01C  38         			sec
         11:C01D             	!:
 4599                        		__bfalse	.LL101
         11:C01D  90 0B      			bcc	.LL101
 4600                        	
 4601                        		.dbg	line,	"include\routines_LEVELS.c", 495; {
 4602                        	
 4603                        		.dbg	line,	"include\routines_LEVELS.c", 496; player_counter_anim = 0;
 4604                        		__st.umiq	0, _player_counter_anim
         11:C01F  9C 18 23   			stz	_player_counter_anim
 4605                        	
 4606                        		.dbg	line,	"include\routines_LEVELS.c", 498; player_state = STATE_JUMP;
 4607                        		__st.umiq	4, _player_state
         11:C022  A9 04      			lda.l	#4
         11:C024  8D 15 23   			sta	_player_state
 4608                        	
 4609                        		.dbg	line,	"include\routines_LEVELS.c", 499; }
 4610                        	
 4611                        		.dbg	line,	"include\routines_LEVELS.c", 502; else if(player_state == STATE_WALK)
 4612                        		__bra		.LL102
         11:C027  4C D1 C0   			bra	.LL102
 4613    11:C02A             	.LL101:
 4614                        		__ld.umq	_player_state
         11:C02A  AD 15 23   			lda	_player_state
 4615                        		__equ_b.uiq	1
         11:C02D  C9 01      			cmp	#1
         11:C02F  F0 01      			beq	!+
         11:C031  18         			clc
         11:C032             	!:
 4616                        		__bfalse	.LL103
         11:C032  90 13      			bcc	.LL103
 4617                        	
 4618                        		.dbg	line,	"include\routines_LEVELS.c", 503; {
 4619                        	
 4620                        		.dbg	line,	"include\routines_LEVELS.c", 504; player_counter_anim = 0;
 4621                        		__st.umiq	0, _player_counter_anim
         11:C034  9C 18 23   			stz	_player_counter_anim
 4622                        	
 4623                        		.dbg	line,	"include\routines_LEVELS.c", 506; player_state = STATE_JUMP_RIGHT + player_axis;
 4624                        		__ld.wi		5
         11:C037  A9 05      			lda.l	#5
         11:C039  C2         			cly
 4625                        		__add.um	_player_axis
         11:C03A  18         			clc
         11:C03B  6D 16 23   			adc	_player_axis
         11:C03E  90 01      			bcc	!+
         11:C040  C8         			iny
         11:C041             	!:
 4626                        		__st.umq	_player_state
         11:C041  8D 15 23   			sta	_player_state
 4627                        	
 4628                        		.dbg	line,	"include\routines_LEVELS.c", 507; }
 4629                        	
 4630                        		.dbg	line,	"include\routines_LEVELS.c", 510; else if(player_state == STATE_HANG || player_state == STATE_CLIMB_UP || player_state == STATE_CLIMB_DOWN)
 4631                        		__bra		.LL104
         11:C044  4C D1 C0   			bra	.LL104
 4632    11:C047             	.LL103:
 4633                        		__ld.umq	_player_state
         11:C047  AD 15 23   			lda	_player_state
 4634                        		__equ_b.uiq	10
         11:C04A  C9 0A      			cmp	#10
         11:C04C  F0 01      			beq	!+
         11:C04E  18         			clc
         11:C04F             	!:
 4635                        		__btrue		.LL106
         11:C04F  B0 08      			bcs	.LL106
 4636                        		__ld.umq	_player_state
         11:C051  AD 15 23   			lda	_player_state
 4637                        		__equ_b.uiq	11
         11:C054  C9 0B      			cmp	#11
         11:C056  F0 01      			beq	!+
         11:C058  18         			clc
         11:C059             	!:
 4638    11:C059             	.LL106:
 4639                        		__btrue		.LL107
         11:C059  B0 08      			bcs	.LL107
 4640                        		__ld.umq	_player_state
         11:C05B  AD 15 23   			lda	_player_state
 4641                        		__equ_b.uiq	12
         11:C05E  C9 0C      			cmp	#12
         11:C060  F0 01      			beq	!+
         11:C062  18         			clc
         11:C063             	!:
 4642    11:C063             	.LL107:
 4643                        		__bfalse	.LL105
         11:C063  90 6C      			bcc	.LL105
 4644                        	
 4645                        		.dbg	line,	"include\routines_LEVELS.c", 511; {
 4646                        	
 4647                        		.dbg	line,	"include\routines_LEVELS.c", 512; if(joy(JOYPAD_1) & JOY_RIGHT)
 4648                        		__ld.uiq	0
         11:C065  62         			cla
 4649                        		 _joy.1
         11:C066  AA         			tax
         11:C067  BD 28 22   			lda	joynow, x
         11:C06A  BC D3 22   			ldy	joy6now, x
 4650                        		__tand.wi	32
         11:C06D  29 20      			and	#32
         11:C06F  C9 01      	!:		cmp	#1
 4651                        		__bfalse	.LL108
         11:C071  90 0A      			bcc	.LL108
 4652                        	
 4653                        		.dbg	line,	"include\routines_LEVELS.c", 513; {
 4654                        	
 4655                        		.dbg	line,	"include\routines_LEVELS.c", 514; player_counter_anim = 0;
 4656                        		__st.umiq	0, _player_counter_anim
         11:C073  9C 18 23   			stz	_player_counter_anim
 4657                        	
 4658                        		.dbg	line,	"include\routines_LEVELS.c", 516; player_state = STATE_JUMP_RIGHT;
 4659                        		__st.umiq	5, _player_state
         11:C076  A9 05      			lda.l	#5
         11:C078  8D 15 23   			sta	_player_state
 4660                        	
 4661                        		.dbg	line,	"include\routines_LEVELS.c", 517; }
 4662                        	
 4663                        		.dbg	line,	"include\routines_LEVELS.c", 519; else if(joy(JOYPAD_1) & JOY_LEFT)
 4664                        		__bra		.LL109
         11:C07B  80 54      			bra	.LL109
 4665    11:C07D             	.LL108:
 4666                        		__ld.uiq	0
         11:C07D  62         			cla
 4667                        		 _joy.1
         11:C07E  AA         			tax
         11:C07F  BD 28 22   			lda	joynow, x
         11:C082  BC D3 22   			ldy	joy6now, x
 4668                        		__tand.wi	128
         11:C085  29 80      			and	#128
         11:C087  C9 01      	!:		cmp	#1
 4669                        		__bfalse	.LL110
         11:C089  90 0A      			bcc	.LL110
 4670                        	
 4671                        		.dbg	line,	"include\routines_LEVELS.c", 520; {
 4672                        	
 4673                        		.dbg	line,	"include\routines_LEVELS.c", 521; player_counter_anim = 0;
 4674                        		__st.umiq	0, _player_counter_anim
         11:C08B  9C 18 23   			stz	_player_counter_anim
 4675                        	
 4676                        		.dbg	line,	"include\routines_LEVELS.c", 523; player_state = STATE_JUMP_LEFT;
 4677                        		__st.umiq	6, _player_state
         11:C08E  A9 06      			lda.l	#6
         11:C090  8D 15 23   			sta	_player_state
 4678                        	
 4679                        		.dbg	line,	"include\routines_LEVELS.c", 524; }
 4680                        	
 4681                        		.dbg	line,	"include\routines_LEVELS.c", 526; else if(joy(JOYPAD_1) & JOY_UP)
 4682                        		__bra		.LL111
         11:C093  80 3C      			bra	.LL111
 4683    11:C095             	.LL110:
 4684                        		__ld.uiq	0
         11:C095  62         			cla
 4685                        		 _joy.1
         11:C096  AA         			tax
         11:C097  BD 28 22   			lda	joynow, x
         11:C09A  BC D3 22   			ldy	joy6now, x
 4686                        		__tand.wi	16
         11:C09D  29 10      			and	#16
         11:C09F  C9 01      	!:		cmp	#1
 4687                        		__bfalse	.LL112
         11:C0A1  90 2E      			bcc	.LL112
 4688                        	
 4689                        		.dbg	line,	"include\routines_LEVELS.c", 527; {
 4690                        	
 4691                        		.dbg	line,	"include\routines_LEVELS.c", 528; player_counter_anim = 0;
 4692                        		__st.umiq	0, _player_counter_anim
         11:C0A3  9C 18 23   			stz	_player_counter_anim
 4693                        	
 4694                        		.dbg	line,	"include\routines_LEVELS.c", 530; check_BG( 15 , 8 );
 4695                        		__ld.wi		15
         11:C0A6  A9 0F      			lda.l	#15
         11:C0A8  C2         			cly
 4696                        		__pusharg.wr
         11:C0A9  A6 8D      			ldx	<__sp
         11:C0AB  CA         			dex
         11:C0AC  CA         			dex
         11:C0AD  95 08      			sta.l	<__stack, x
         11:C0AF  94 09      			sty.h	<__stack, x
         11:C0B1  86 8D      			stx	<__sp
 4697                        		__ld.wi		8
         11:C0B3  A9 08      			lda.l	#8
         11:C0B5  C2         			cly
 4698                        		__pusharg.wr
         11:C0B6  A6 8D      			ldx	<__sp
         11:C0B8  CA         			dex
         11:C0B9  CA         			dex
         11:C0BA  95 08      			sta.l	<__stack, x
         11:C0BC  94 09      			sty.h	<__stack, x
         11:C0BE  86 8D      			stx	<__sp
 4699                        		__call		_check_BG
         11:C0C0  20 6D FF   			call	_check_BG
 4700                        	
 4701                        		.dbg	line,	"include\routines_LEVELS.c", 532; if(map_blk_flag == TILE_EMPTY)
 4702                        		__not.um	_map_blk_flag
         11:C0C3  AD A5 2B   			lda	_map_blk_flag
         11:C0C6  18         			clc
         11:C0C7  D0 01      			bne	!+
         11:C0C9  38         			sec
         11:C0CA             	!:
 4703                        		__bfalse	.LL113
         11:C0CA  90 05      			bcc	.LL113
 4704                        	
 4705                        		.dbg	line,	"include\routines_LEVELS.c", 533; {
 4706                        	
 4707                        		.dbg	line,	"include\routines_LEVELS.c", 534; player_state = STATE_JUMP_LADDER;
 4708                        		__st.umiq	13, _player_state
         11:C0CC  A9 0D      			lda.l	#13
         11:C0CE  8D 15 23   			sta	_player_state
 4709                        	
 4710                        		.dbg	line,	"include\routines_LEVELS.c", 535; }
 4711                        	
 4712                        		.dbg	line,	"include\routines_LEVELS.c", 536; }
 4713    11:C0D1             	.LL113:
 4714                        	
 4715                        		.dbg	line,	"include\routines_LEVELS.c", 537; }
 4716    11:C0D1             	.LL112:
 4717    11:C0D1             	.LL111:
 4718    11:C0D1             	.LL109:
 4719                        	
 4720                        		.dbg	line,	"include\routines_LEVELS.c", 538; }
 4721    11:C0D1             	.LL105:
 4722    11:C0D1             	.LL104:
 4723    11:C0D1             	.LL102:
 4724                        	
 4725                        		.dbg	line,	"include\routines_LEVELS.c", 539; }
 4726    11:C0D1             	.LL100:
 4727    11:C0D1             	.LL99:
 4728                        		__return	0
         11:C0D1  4C EF FF   			jmp	leave_proc
 4729                        		.dbg	clear
 4730                        		.endp
 4731                        		.pceas
 4732                        	
 4733                        		.dbg	line,	"include\routines_LEVELS.c", 542; void joypad_DIR()
 4734                        		.dbg	line,	"include\routines_LEVELS.c", 543; {
 4735                        	;***********************
 4736                        	;***********************
 4737                        	
 4738                        		.hucc
 4739    02:C000             		.proc		_joypad_DIR
 4740                        		__enter		_joypad_DIR
 4741                        	
 4742                        		.dbg	line,	"include\routines_LEVELS.c", 544; //--------------------------------------------------------------------------------------//
 4743                        	
 4744                        		.dbg	line,	"include\routines_LEVELS.c", 545; //                                        NO DIR                                        //
 4745                        	
 4746                        		.dbg	line,	"include\routines_LEVELS.c", 546; //--------------------------------------------------------------------------------------//
 4747                        	
 4748                        		.dbg	line,	"include\routines_LEVELS.c", 548; if(! (joy(JOYPAD_1) & JOY_DIR_PRESSED) )
 4749                        		__ld.uiq	0
         02:C000  62         			cla
 4750                        		 _joy.1
         02:C001  AA         			tax
         02:C002  BD 28 22   			lda	joynow, x
         02:C005  BC D3 22   			ldy	joy6now, x
 4751                        		__nand.wi	240
         02:C008  18         			clc
         02:C009  29 F0      			and	#240
         02:C00B  D0 01      			bne	!+
         02:C00D  38         			sec
         02:C00E             	!:
 4752                        		__bfalse	.LL115
         02:C00E  90 3C      			bcc	.LL115
 4753                        	
 4754                        		.dbg	line,	"include\routines_LEVELS.c", 549; {
 4755                        	
 4756                        		.dbg	line,	"include\routines_LEVELS.c", 550; if(player_state == STATE_WALK || player_state == STATE_CROUCH)
 4757                        		__ld.umq	_player_state
         02:C010  AD 15 23   			lda	_player_state
 4758                        		__equ_b.uiq	1
         02:C013  C9 01      			cmp	#1
         02:C015  F0 01      			beq	!+
         02:C017  18         			clc
         02:C018             	!:
 4759                        		__btrue		.LL117
         02:C018  B0 08      			bcs	.LL117
 4760                        		__ld.umq	_player_state
         02:C01A  AD 15 23   			lda	_player_state
 4761                        		__equ_b.uiq	7
         02:C01D  C9 07      			cmp	#7
         02:C01F  F0 01      			beq	!+
         02:C021  18         			clc
         02:C022             	!:
 4762    02:C022             	.LL117:
 4763                        		__bfalse	.LL116
         02:C022  90 0A      			bcc	.LL116
 4764                        	
 4765                        		.dbg	line,	"include\routines_LEVELS.c", 551; {
 4766                        	
 4767                        		.dbg	line,	"include\routines_LEVELS.c", 552; player_counter_anim = 1;
 4768                        		__st.umiq	1, _player_counter_anim
         02:C024  A9 01      			lda.l	#1
         02:C026  8D 18 23   			sta	_player_counter_anim
 4769                        	
 4770                        		.dbg	line,	"include\routines_LEVELS.c", 553; player_state = STATE_IDLE;
 4771                        		__st.umiq	0, _player_state
         02:C029  9C 15 23   			stz	_player_state
 4772                        	
 4773                        		.dbg	line,	"include\routines_LEVELS.c", 554; }
 4774                        	
 4775                        		.dbg	line,	"include\routines_LEVELS.c", 557; else if(player_state == STATE_CLIMB_UP || player_state == STATE_CLIMB_DOWN)
 4776                        		__bra		.LL118
         02:C02C  80 1E      			bra	.LL118
 4777    02:C02E             	.LL116:
 4778                        		__ld.umq	_player_state
         02:C02E  AD 15 23   			lda	_player_state
 4779                        		__equ_b.uiq	11
         02:C031  C9 0B      			cmp	#11
         02:C033  F0 01      			beq	!+
         02:C035  18         			clc
         02:C036             	!:
 4780                        		__btrue		.LL120
         02:C036  B0 08      			bcs	.LL120
 4781                        		__ld.umq	_player_state
         02:C038  AD 15 23   			lda	_player_state
 4782                        		__equ_b.uiq	12
         02:C03B  C9 0C      			cmp	#12
         02:C03D  F0 01      			beq	!+
         02:C03F  18         			clc
         02:C040             	!:
 4783    02:C040             	.LL120:
 4784                        		__bfalse	.LL119
         02:C040  90 0A      			bcc	.LL119
 4785                        	
 4786                        		.dbg	line,	"include\routines_LEVELS.c", 558; {
 4787                        	
 4788                        		.dbg	line,	"include\routines_LEVELS.c", 559; player_counter_anim = 1;
 4789                        		__st.umiq	1, _player_counter_anim
         02:C042  A9 01      			lda.l	#1
         02:C044  8D 18 23   			sta	_player_counter_anim
 4790                        	
 4791                        		.dbg	line,	"include\routines_LEVELS.c", 560; player_state = STATE_HANG;
 4792                        		__st.umiq	10, _player_state
         02:C047  A9 0A      			lda.l	#10
         02:C049  8D 15 23   			sta	_player_state
 4793                        	
 4794                        		.dbg	line,	"include\routines_LEVELS.c", 561; }
 4795                        	
 4796                        		.dbg	line,	"include\routines_LEVELS.c", 562; }
 4797    02:C04C             	.LL119:
 4798    02:C04C             	.LL118:
 4799                        	
 4800                        		.dbg	line,	"include\routines_LEVELS.c", 565; //--------------------------------------------------------------------------------------//
 4801                        	
 4802                        		.dbg	line,	"include\routines_LEVELS.c", 566; //                                     RIGHT BUTTON                                     //
 4803                        	
 4804                        		.dbg	line,	"include\routines_LEVELS.c", 567; //--------------------------------------------------------------------------------------//
 4805                        	
 4806                        		.dbg	line,	"include\routines_LEVELS.c", 569; if(joy(JOYPAD_1) & JOY_RIGHT)
 4807    02:C04C             	.LL115:
 4808                        		__ld.uiq	0
         02:C04C  62         			cla
 4809                        		 _joy.1
         02:C04D  AA         			tax
         02:C04E  BD 28 22   			lda	joynow, x
         02:C051  BC D3 22   			ldy	joy6now, x
 4810                        		__tand.wi	32
         02:C054  29 20      			and	#32
         02:C056  C9 01      	!:		cmp	#1
 4811                        		__bfalse	.LL121
         02:C058  B0 03 4C 35			bcc	.LL121
         02:C05C  C1          
 4812                        	
 4813                        		.dbg	line,	"include\routines_LEVELS.c", 570; {
 4814                        	
 4815                        		.dbg	line,	"include\routines_LEVELS.c", 571; if(player_state == STATE_IDLE || player_state == STATE_WALK)
 4816                        		__not.um	_player_state
         02:C05D  AD 15 23   			lda	_player_state
         02:C060  18         			clc
         02:C061  D0 01      			bne	!+
         02:C063  38         			sec
         02:C064             	!:
 4817                        		__btrue		.LL123
         02:C064  B0 08      			bcs	.LL123
 4818                        		__ld.umq	_player_state
         02:C066  AD 15 23   			lda	_player_state
 4819                        		__equ_b.uiq	1
         02:C069  C9 01      			cmp	#1
         02:C06B  F0 01      			beq	!+
         02:C06D  18         			clc
         02:C06E             	!:
 4820    02:C06E             	.LL123:
 4821                        		__bfalse	.LL122
         02:C06E  90 47      			bcc	.LL122
 4822                        	
 4823                        		.dbg	line,	"include\routines_LEVELS.c", 572; {
 4824                        	
 4825                        		.dbg	line,	"include\routines_LEVELS.c", 573; player_axis = AXIS_RIGHT;
 4826                        		__st.umiq	0, _player_axis
         02:C070  9C 16 23   			stz	_player_axis
 4827                        	
 4828                        		.dbg	line,	"include\routines_LEVELS.c", 575; if(player_previous_axis != player_axis)
 4829                        		__ld.umq	_player_previous_axis
         02:C073  AD 17 23   			lda	_player_previous_axis
 4830                        		__neq_b.umq	_player_axis
         02:C076  38         			sec
         02:C077  4D 16 23   			eor	_player_axis
         02:C07A  D0 01      			bne	!+
         02:C07C  18         			clc
         02:C07D             	!:
 4831                        		__bfalse	.LL124
         02:C07D  90 15      			bcc	.LL124
 4832                        	
 4833                        		.dbg	line,	"include\routines_LEVELS.c", 576; {
 4834                        	
 4835                        		.dbg	line,	"include\routines_LEVELS.c", 577; player_previous_axis = player_axis;
 4836                        		__ld.um		_player_axis
         02:C07F  AD 16 23   			lda	_player_axis
         02:C082  C2         			cly
 4837                        		__st.umq	_player_previous_axis
         02:C083  8D 17 23   			sta	_player_previous_axis
 4838                        	
 4839                        		.dbg	line,	"include\routines_LEVELS.c", 579; spr_set(player_id);
 4840                        		__ld.umq	_player_id
         02:C086  AD 14 23   			lda	_player_id
 4841                        		__call		_spr_set.1
         02:C089  20 DD E7   			call	_spr_set.1
 4842                        	
 4843                        		.dbg	line,	"include\routines_LEVELS.c", 580; spr_ctrl(FLIP_MAS, NO_FLIP_X);
 4844                        		__st.umiq	136, _al
         02:C08C  A9 88      			lda.l	#136
         02:C08E  85 F8      			sta	_al
 4845                        		__ld.uiq	0
         02:C090  62         			cla
 4846                        		__call		_spr_ctrl.2
         02:C091  20 3C E8   			call	_spr_ctrl.2
 4847                        	
 4848                        		.dbg	line,	"include\routines_LEVELS.c", 581; }
 4849                        	
 4850                        		.dbg	line,	"include\routines_LEVELS.c", 583; if(joy(JOYPAD_1) & JOY_DOWN)
 4851    02:C094             	.LL124:
 4852                        		__ld.uiq	0
         02:C094  62         			cla
 4853                        		 _joy.1
         02:C095  AA         			tax
         02:C096  BD 28 22   			lda	joynow, x
         02:C099  BC D3 22   			ldy	joy6now, x
 4854                        		__tand.wi	64
         02:C09C  29 40      			and	#64
         02:C09E  C9 01      	!:		cmp	#1
 4855                        		__bfalse	.LL125
         02:C0A0  90 0D      			bcc	.LL125
 4856                        	
 4857                        		.dbg	line,	"include\routines_LEVELS.c", 584; {
 4858                        	
 4859                        		.dbg	line,	"include\routines_LEVELS.c", 585; player_counter_anim = 1;
 4860                        		__st.umiq	1, _player_counter_anim
         02:C0A2  A9 01      			lda.l	#1
         02:C0A4  8D 18 23   			sta	_player_counter_anim
 4861                        	
 4862                        		.dbg	line,	"include\routines_LEVELS.c", 586; player_state = STATE_CROUCH;
 4863                        		__st.umiq	7, _player_state
         02:C0A7  A9 07      			lda.l	#7
         02:C0A9  8D 15 23   			sta	_player_state
 4864                        	
 4865                        		.dbg	line,	"include\routines_LEVELS.c", 587; return;
 4866                        		__bra		.LL114
         02:C0AC  4C 14 C4   			bra	.LL114
 4867                        	
 4868                        		.dbg	line,	"include\routines_LEVELS.c", 588; }
 4869                        	
 4870                        		.dbg	line,	"include\routines_LEVELS.c", 590; player_state = STATE_WALK;
 4871    02:C0AF             	.LL125:
 4872                        		__st.umiq	1, _player_state
         02:C0AF  A9 01      			lda.l	#1
         02:C0B1  8D 15 23   			sta	_player_state
 4873                        	
 4874                        		.dbg	line,	"include\routines_LEVELS.c", 591; }
 4875                        	
 4876                        		.dbg	line,	"include\routines_LEVELS.c", 594; else if(player_state == STATE_JUMP || player_state == STATE_JUMP_LEFT || player_state == STATE_CROUCH || player_state == STATE_FALL || player_state == STATE_HANG)
 4877                        		__bra		.LL126
         02:C0B4  4C 14 C4   			bra	.LL126
 4878    02:C0B7             	.LL122:
 4879                        		__ld.umq	_player_state
         02:C0B7  AD 15 23   			lda	_player_state
 4880                        		__equ_b.uiq	4
         02:C0BA  C9 04      			cmp	#4
         02:C0BC  F0 01      			beq	!+
         02:C0BE  18         			clc
         02:C0BF             	!:
 4881                        		__btrue		.LL128
         02:C0BF  B0 08      			bcs	.LL128
 4882                        		__ld.umq	_player_state
         02:C0C1  AD 15 23   			lda	_player_state
 4883                        		__equ_b.uiq	6
         02:C0C4  C9 06      			cmp	#6
         02:C0C6  F0 01      			beq	!+
         02:C0C8  18         			clc
         02:C0C9             	!:
 4884    02:C0C9             	.LL128:
 4885                        		__btrue		.LL129
         02:C0C9  B0 08      			bcs	.LL129
 4886                        		__ld.umq	_player_state
         02:C0CB  AD 15 23   			lda	_player_state
 4887                        		__equ_b.uiq	7
         02:C0CE  C9 07      			cmp	#7
         02:C0D0  F0 01      			beq	!+
         02:C0D2  18         			clc
         02:C0D3             	!:
 4888    02:C0D3             	.LL129:
 4889                        		__btrue		.LL130
         02:C0D3  B0 08      			bcs	.LL130
 4890                        		__ld.umq	_player_state
         02:C0D5  AD 15 23   			lda	_player_state
 4891                        		__equ_b.uiq	9
         02:C0D8  C9 09      			cmp	#9
         02:C0DA  F0 01      			beq	!+
         02:C0DC  18         			clc
         02:C0DD             	!:
 4892    02:C0DD             	.LL130:
 4893                        		__btrue		.LL131
         02:C0DD  B0 08      			bcs	.LL131
 4894                        		__ld.umq	_player_state
         02:C0DF  AD 15 23   			lda	_player_state
 4895                        		__equ_b.uiq	10
         02:C0E2  C9 0A      			cmp	#10
         02:C0E4  F0 01      			beq	!+
         02:C0E6  18         			clc
         02:C0E7             	!:
 4896    02:C0E7             	.LL131:
 4897                        		__bfalse	.LL127
         02:C0E7  90 28      			bcc	.LL127
 4898                        	
 4899                        		.dbg	line,	"include\routines_LEVELS.c", 595; {
 4900                        	
 4901                        		.dbg	line,	"include\routines_LEVELS.c", 596; if(player_axis == AXIS_LEFT)
 4902                        		__ld.umq	_player_axis
         02:C0E9  AD 16 23   			lda	_player_axis
 4903                        		__equ_b.uiq	1
         02:C0EC  C9 01      			cmp	#1
         02:C0EE  F0 01      			beq	!+
         02:C0F0  18         			clc
         02:C0F1             	!:
 4904                        		__bfalse	.LL132
         02:C0F1  B0 03 4C 14			bcc	.LL132
         02:C0F5  C4          
 4905                        	
 4906                        		.dbg	line,	"include\routines_LEVELS.c", 597; {
 4907                        	
 4908                        		.dbg	line,	"include\routines_LEVELS.c", 598; player_axis = AXIS_RIGHT;
 4909                        		__st.umiq	0, _player_axis
         02:C0F6  9C 16 23   			stz	_player_axis
 4910                        	
 4911                        		.dbg	line,	"include\routines_LEVELS.c", 599; player_previous_axis = player_axis;
 4912                        		__ld.um		_player_axis
         02:C0F9  AD 16 23   			lda	_player_axis
         02:C0FC  C2         			cly
 4913                        		__st.umq	_player_previous_axis
         02:C0FD  8D 17 23   			sta	_player_previous_axis
 4914                        	
 4915                        		.dbg	line,	"include\routines_LEVELS.c", 601; spr_set(player_id);
 4916                        		__ld.umq	_player_id
         02:C100  AD 14 23   			lda	_player_id
 4917                        		__call		_spr_set.1
         02:C103  20 DD E7   			call	_spr_set.1
 4918                        	
 4919                        		.dbg	line,	"include\routines_LEVELS.c", 602; spr_ctrl(FLIP_MAS, NO_FLIP_X);
 4920                        		__st.umiq	136, _al
         02:C106  A9 88      			lda.l	#136
         02:C108  85 F8      			sta	_al
 4921                        		__ld.uiq	0
         02:C10A  62         			cla
 4922                        		__call		_spr_ctrl.2
         02:C10B  20 3C E8   			call	_spr_ctrl.2
 4923                        	
 4924                        		.dbg	line,	"include\routines_LEVELS.c", 603; }
 4925                        	
 4926                        		.dbg	line,	"include\routines_LEVELS.c", 604; }
 4927    02:C10E             	.LL132	.alias		.LL133
 4928                        	
 4929                        		.dbg	line,	"include\routines_LEVELS.c", 607; else if(player_state == STATE_CLIMB_UP || player_state == STATE_CLIMB_DOWN)
 4930                        		__bra		.LL133
         02:C10E  4C 14 C4   			bra	.LL133
 4931    02:C111             	.LL127:
 4932                        		__ld.umq	_player_state
         02:C111  AD 15 23   			lda	_player_state
 4933                        		__equ_b.uiq	11
         02:C114  C9 0B      			cmp	#11
         02:C116  F0 01      			beq	!+
         02:C118  18         			clc
         02:C119             	!:
 4934                        		__btrue		.LL135
         02:C119  B0 08      			bcs	.LL135
 4935                        		__ld.umq	_player_state
         02:C11B  AD 15 23   			lda	_player_state
 4936                        		__equ_b.uiq	12
         02:C11E  C9 0C      			cmp	#12
         02:C120  F0 01      			beq	!+
         02:C122  18         			clc
         02:C123             	!:
 4937    02:C123             	.LL135:
 4938                        		__bfalse	.LL134
         02:C123  B0 03 4C 14			bcc	.LL134
         02:C127  C4          
 4939                        	
 4940                        		.dbg	line,	"include\routines_LEVELS.c", 608; {
 4941                        	
 4942                        		.dbg	line,	"include\routines_LEVELS.c", 609; player_counter_anim = 1;
 4943                        		__st.umiq	1, _player_counter_anim
         02:C128  A9 01      			lda.l	#1
         02:C12A  8D 18 23   			sta	_player_counter_anim
 4944                        	
 4945                        		.dbg	line,	"include\routines_LEVELS.c", 610; player_state = STATE_HANG;
 4946                        		__st.umiq	10, _player_state
         02:C12D  A9 0A      			lda.l	#10
         02:C12F  8D 15 23   			sta	_player_state
 4947                        	
 4948                        		.dbg	line,	"include\routines_LEVELS.c", 611; }
 4949                        	
 4950                        		.dbg	line,	"include\routines_LEVELS.c", 612; }
 4951    02:C132             	.LL134	.alias		.LL136
 4952    02:C132             	.LL133	.alias		.LL136
 4953    02:C132             	.LL126	.alias		.LL136
 4954                        	
 4955                        		.dbg	line,	"include\routines_LEVELS.c", 615; //--------------------------------------------------------------------------------------//
 4956                        	
 4957                        		.dbg	line,	"include\routines_LEVELS.c", 616; //                                     LEFT BUTTON                                      //
 4958                        	
 4959                        		.dbg	line,	"include\routines_LEVELS.c", 617; //--------------------------------------------------------------------------------------//
 4960                        	
 4961                        		.dbg	line,	"include\routines_LEVELS.c", 619; else if(joy(JOYPAD_1) & JOY_LEFT)
 4962                        		__bra		.LL136
         02:C132  4C 14 C4   			bra	.LL136
 4963    02:C135             	.LL121:
 4964                        		__ld.uiq	0
         02:C135  62         			cla
 4965                        		 _joy.1
         02:C136  AA         			tax
         02:C137  BD 28 22   			lda	joynow, x
         02:C13A  BC D3 22   			ldy	joy6now, x
 4966                        		__tand.wi	128
         02:C13D  29 80      			and	#128
         02:C13F  C9 01      	!:		cmp	#1
 4967                        		__bfalse	.LL137
         02:C141  B0 03 4C 23			bcc	.LL137
         02:C145  C2          
 4968                        	
 4969                        		.dbg	line,	"include\routines_LEVELS.c", 620; {
 4970                        	
 4971                        		.dbg	line,	"include\routines_LEVELS.c", 621; if(player_state == STATE_IDLE || player_state == STATE_WALK)
 4972                        		__not.um	_player_state
         02:C146  AD 15 23   			lda	_player_state
         02:C149  18         			clc
         02:C14A  D0 01      			bne	!+
         02:C14C  38         			sec
         02:C14D             	!:
 4973                        		__btrue		.LL139
         02:C14D  B0 08      			bcs	.LL139
 4974                        		__ld.umq	_player_state
         02:C14F  AD 15 23   			lda	_player_state
 4975                        		__equ_b.uiq	1
         02:C152  C9 01      			cmp	#1
         02:C154  F0 01      			beq	!+
         02:C156  18         			clc
         02:C157             	!:
 4976    02:C157             	.LL139:
 4977                        		__bfalse	.LL138
         02:C157  90 4A      			bcc	.LL138
 4978                        	
 4979                        		.dbg	line,	"include\routines_LEVELS.c", 622; {
 4980                        	
 4981                        		.dbg	line,	"include\routines_LEVELS.c", 623; player_axis = AXIS_LEFT;
 4982                        		__st.umiq	1, _player_axis
         02:C159  A9 01      			lda.l	#1
         02:C15B  8D 16 23   			sta	_player_axis
 4983                        	
 4984                        		.dbg	line,	"include\routines_LEVELS.c", 625; if(player_previous_axis != player_axis)
 4985                        		__ld.umq	_player_previous_axis
         02:C15E  AD 17 23   			lda	_player_previous_axis
 4986                        		__neq_b.umq	_player_axis
         02:C161  38         			sec
         02:C162  4D 16 23   			eor	_player_axis
         02:C165  D0 01      			bne	!+
         02:C167  18         			clc
         02:C168             	!:
 4987                        		__bfalse	.LL140
         02:C168  90 16      			bcc	.LL140
 4988                        	
 4989                        		.dbg	line,	"include\routines_LEVELS.c", 626; {
 4990                        	
 4991                        		.dbg	line,	"include\routines_LEVELS.c", 627; player_previous_axis = player_axis;
 4992                        		__ld.um		_player_axis
         02:C16A  AD 16 23   			lda	_player_axis
         02:C16D  C2         			cly
 4993                        		__st.umq	_player_previous_axis
         02:C16E  8D 17 23   			sta	_player_previous_axis
 4994                        	
 4995                        		.dbg	line,	"include\routines_LEVELS.c", 629; spr_set(player_id);
 4996                        		__ld.umq	_player_id
         02:C171  AD 14 23   			lda	_player_id
 4997                        		__call		_spr_set.1
         02:C174  20 DD E7   			call	_spr_set.1
 4998                        	
 4999                        		.dbg	line,	"include\routines_LEVELS.c", 630; spr_ctrl(FLIP_MAS, FLIP_X);
 5000                        		__st.umiq	136, _al
         02:C177  A9 88      			lda.l	#136
         02:C179  85 F8      			sta	_al
 5001                        		__ld.uiq	8
         02:C17B  A9 08      			lda	#8
 5002                        		__call		_spr_ctrl.2
         02:C17D  20 3C E8   			call	_spr_ctrl.2
 5003                        	
 5004                        		.dbg	line,	"include\routines_LEVELS.c", 631; }
 5005                        	
 5006                        		.dbg	line,	"include\routines_LEVELS.c", 633; if(joy(JOYPAD_1) & JOY_DOWN)
 5007    02:C180             	.LL140:
 5008                        		__ld.uiq	0
         02:C180  62         			cla
 5009                        		 _joy.1
         02:C181  AA         			tax
         02:C182  BD 28 22   			lda	joynow, x
         02:C185  BC D3 22   			ldy	joy6now, x
 5010                        		__tand.wi	64
         02:C188  29 40      			and	#64
         02:C18A  C9 01      	!:		cmp	#1
 5011                        		__bfalse	.LL141
         02:C18C  90 0D      			bcc	.LL141
 5012                        	
 5013                        		.dbg	line,	"include\routines_LEVELS.c", 634; {
 5014                        	
 5015                        		.dbg	line,	"include\routines_LEVELS.c", 635; player_counter_anim = 1;
 5016                        		__st.umiq	1, _player_counter_anim
         02:C18E  A9 01      			lda.l	#1
         02:C190  8D 18 23   			sta	_player_counter_anim
 5017                        	
 5018                        		.dbg	line,	"include\routines_LEVELS.c", 636; player_state = STATE_CROUCH;
 5019                        		__st.umiq	7, _player_state
         02:C193  A9 07      			lda.l	#7
         02:C195  8D 15 23   			sta	_player_state
 5020                        	
 5021                        		.dbg	line,	"include\routines_LEVELS.c", 637; return;
 5022                        		__bra		.LL114
         02:C198  4C 14 C4   			bra	.LL114
 5023                        	
 5024                        		.dbg	line,	"include\routines_LEVELS.c", 638; }
 5025                        	
 5026                        		.dbg	line,	"include\routines_LEVELS.c", 640; player_state = STATE_WALK;
 5027    02:C19B             	.LL141:
 5028                        		__st.umiq	1, _player_state
         02:C19B  A9 01      			lda.l	#1
         02:C19D  8D 15 23   			sta	_player_state
 5029                        	
 5030                        		.dbg	line,	"include\routines_LEVELS.c", 641; }
 5031                        	
 5032                        		.dbg	line,	"include\routines_LEVELS.c", 644; else if(player_state == STATE_JUMP || player_state == STATE_JUMP_RIGHT || player_state == STATE_CROUCH || player_state == STATE_FALL || player_state == STATE_HANG)
 5033                        		__bra		.LL142
         02:C1A0  4C 14 C4   			bra	.LL142
 5034    02:C1A3             	.LL138:
 5035                        		__ld.umq	_player_state
         02:C1A3  AD 15 23   			lda	_player_state
 5036                        		__equ_b.uiq	4
         02:C1A6  C9 04      			cmp	#4
         02:C1A8  F0 01      			beq	!+
         02:C1AA  18         			clc
         02:C1AB             	!:
 5037                        		__btrue		.LL144
         02:C1AB  B0 08      			bcs	.LL144
 5038                        		__ld.umq	_player_state
         02:C1AD  AD 15 23   			lda	_player_state
 5039                        		__equ_b.uiq	5
         02:C1B0  C9 05      			cmp	#5
         02:C1B2  F0 01      			beq	!+
         02:C1B4  18         			clc
         02:C1B5             	!:
 5040    02:C1B5             	.LL144:
 5041                        		__btrue		.LL145
         02:C1B5  B0 08      			bcs	.LL145
 5042                        		__ld.umq	_player_state
         02:C1B7  AD 15 23   			lda	_player_state
 5043                        		__equ_b.uiq	7
         02:C1BA  C9 07      			cmp	#7
         02:C1BC  F0 01      			beq	!+
         02:C1BE  18         			clc
         02:C1BF             	!:
 5044    02:C1BF             	.LL145:
 5045                        		__btrue		.LL146
         02:C1BF  B0 08      			bcs	.LL146
 5046                        		__ld.umq	_player_state
         02:C1C1  AD 15 23   			lda	_player_state
 5047                        		__equ_b.uiq	9
         02:C1C4  C9 09      			cmp	#9
         02:C1C6  F0 01      			beq	!+
         02:C1C8  18         			clc
         02:C1C9             	!:
 5048    02:C1C9             	.LL146:
 5049                        		__btrue		.LL147
         02:C1C9  B0 08      			bcs	.LL147
 5050                        		__ld.umq	_player_state
         02:C1CB  AD 15 23   			lda	_player_state
 5051                        		__equ_b.uiq	10
         02:C1CE  C9 0A      			cmp	#10
         02:C1D0  F0 01      			beq	!+
         02:C1D2  18         			clc
         02:C1D3             	!:
 5052    02:C1D3             	.LL147:
 5053                        		__bfalse	.LL143
         02:C1D3  90 2A      			bcc	.LL143
 5054                        	
 5055                        		.dbg	line,	"include\routines_LEVELS.c", 645; {
 5056                        	
 5057                        		.dbg	line,	"include\routines_LEVELS.c", 646; if(player_axis == AXIS_RIGHT)
 5058                        		__not.um	_player_axis
         02:C1D5  AD 16 23   			lda	_player_axis
         02:C1D8  18         			clc
         02:C1D9  D0 01      			bne	!+
         02:C1DB  38         			sec
         02:C1DC             	!:
 5059                        		__bfalse	.LL148
         02:C1DC  B0 03 4C 14			bcc	.LL148
         02:C1E0  C4          
 5060                        	
 5061                        		.dbg	line,	"include\routines_LEVELS.c", 647; {
 5062                        	
 5063                        		.dbg	line,	"include\routines_LEVELS.c", 648; player_axis = AXIS_LEFT;
 5064                        		__st.umiq	1, _player_axis
         02:C1E1  A9 01      			lda.l	#1
         02:C1E3  8D 16 23   			sta	_player_axis
 5065                        	
 5066                        		.dbg	line,	"include\routines_LEVELS.c", 649; player_previous_axis = player_axis;
 5067                        		__ld.um		_player_axis
         02:C1E6  AD 16 23   			lda	_player_axis
         02:C1E9  C2         			cly
 5068                        		__st.umq	_player_previous_axis
         02:C1EA  8D 17 23   			sta	_player_previous_axis
 5069                        	
 5070                        		.dbg	line,	"include\routines_LEVELS.c", 651; spr_set(player_id);
 5071                        		__ld.umq	_player_id
         02:C1ED  AD 14 23   			lda	_player_id
 5072                        		__call		_spr_set.1
         02:C1F0  20 DD E7   			call	_spr_set.1
 5073                        	
 5074                        		.dbg	line,	"include\routines_LEVELS.c", 652; spr_ctrl(FLIP_MAS, FLIP_X);
 5075                        		__st.umiq	136, _al
         02:C1F3  A9 88      			lda.l	#136
         02:C1F5  85 F8      			sta	_al
 5076                        		__ld.uiq	8
         02:C1F7  A9 08      			lda	#8
 5077                        		__call		_spr_ctrl.2
         02:C1F9  20 3C E8   			call	_spr_ctrl.2
 5078                        	
 5079                        		.dbg	line,	"include\routines_LEVELS.c", 653; }
 5080                        	
 5081                        		.dbg	line,	"include\routines_LEVELS.c", 654; }
 5082    02:C1FC             	.LL148	.alias		.LL149
 5083                        	
 5084                        		.dbg	line,	"include\routines_LEVELS.c", 657; else if(player_state == STATE_CLIMB_UP || player_state == STATE_CLIMB_DOWN)
 5085                        		__bra		.LL149
         02:C1FC  4C 14 C4   			bra	.LL149
 5086    02:C1FF             	.LL143:
 5087                        		__ld.umq	_player_state
         02:C1FF  AD 15 23   			lda	_player_state
 5088                        		__equ_b.uiq	11
         02:C202  C9 0B      			cmp	#11
         02:C204  F0 01      			beq	!+
         02:C206  18         			clc
         02:C207             	!:
 5089                        		__btrue		.LL151
         02:C207  B0 08      			bcs	.LL151
 5090                        		__ld.umq	_player_state
         02:C209  AD 15 23   			lda	_player_state
 5091                        		__equ_b.uiq	12
         02:C20C  C9 0C      			cmp	#12
         02:C20E  F0 01      			beq	!+
         02:C210  18         			clc
         02:C211             	!:
 5092    02:C211             	.LL151:
 5093                        		__bfalse	.LL150
         02:C211  B0 03 4C 14			bcc	.LL150
         02:C215  C4          
 5094                        	
 5095                        		.dbg	line,	"include\routines_LEVELS.c", 658; {
 5096                        	
 5097                        		.dbg	line,	"include\routines_LEVELS.c", 659; player_counter_anim = 1;
 5098                        		__st.umiq	1, _player_counter_anim
         02:C216  A9 01      			lda.l	#1
         02:C218  8D 18 23   			sta	_player_counter_anim
 5099                        	
 5100                        		.dbg	line,	"include\routines_LEVELS.c", 660; player_state = STATE_HANG;
 5101                        		__st.umiq	10, _player_state
         02:C21B  A9 0A      			lda.l	#10
         02:C21D  8D 15 23   			sta	_player_state
 5102                        	
 5103                        		.dbg	line,	"include\routines_LEVELS.c", 661; }
 5104                        	
 5105                        		.dbg	line,	"include\routines_LEVELS.c", 662; }
 5106    02:C220             	.LL150	.alias		.LL152
 5107    02:C220             	.LL149	.alias		.LL152
 5108    02:C220             	.LL142	.alias		.LL152
 5109                        	
 5110                        		.dbg	line,	"include\routines_LEVELS.c", 665; //--------------------------------------------------------------------------------------//
 5111                        	
 5112                        		.dbg	line,	"include\routines_LEVELS.c", 666; //                                      UP BUTTON                                       //
 5113                        	
 5114                        		.dbg	line,	"include\routines_LEVELS.c", 667; //--------------------------------------------------------------------------------------//
 5115                        	
 5116                        		.dbg	line,	"include\routines_LEVELS.c", 669; else if(joy(JOYPAD_1) & JOY_UP)
 5117                        		__bra		.LL152
         02:C220  4C 14 C4   			bra	.LL152
 5118    02:C223             	.LL137:
 5119                        		__ld.uiq	0
         02:C223  62         			cla
 5120                        		 _joy.1
         02:C224  AA         			tax
         02:C225  BD 28 22   			lda	joynow, x
         02:C228  BC D3 22   			ldy	joy6now, x
 5121                        		__tand.wi	16
         02:C22B  29 10      			and	#16
         02:C22D  C9 01      	!:		cmp	#1
 5122                        		__bfalse	.LL153
         02:C22F  B0 03 4C F8			bcc	.LL153
         02:C233  C2          
 5123                        	
 5124                        		.dbg	line,	"include\routines_LEVELS.c", 670; {
 5125                        	
 5126                        		.dbg	line,	"include\routines_LEVELS.c", 671; if(player_state == STATE_HANG || player_state == STATE_CLIMB_UP || player_state == STATE_CLIMB_DOWN)
 5127                        		__ld.umq	_player_state
         02:C234  AD 15 23   			lda	_player_state
 5128                        		__equ_b.uiq	10
         02:C237  C9 0A      			cmp	#10
         02:C239  F0 01      			beq	!+
         02:C23B  18         			clc
         02:C23C             	!:
 5129                        		__btrue		.LL155
         02:C23C  B0 08      			bcs	.LL155
 5130                        		__ld.umq	_player_state
         02:C23E  AD 15 23   			lda	_player_state
 5131                        		__equ_b.uiq	11
         02:C241  C9 0B      			cmp	#11
         02:C243  F0 01      			beq	!+
         02:C245  18         			clc
         02:C246             	!:
 5132    02:C246             	.LL155:
 5133                        		__btrue		.LL156
         02:C246  B0 08      			bcs	.LL156
 5134                        		__ld.umq	_player_state
         02:C248  AD 15 23   			lda	_player_state
 5135                        		__equ_b.uiq	12
         02:C24B  C9 0C      			cmp	#12
         02:C24D  F0 01      			beq	!+
         02:C24F  18         			clc
         02:C250             	!:
 5136    02:C250             	.LL156:
 5137                        		__bfalse	.LL154
         02:C250  B0 03 4C 14			bcc	.LL154
         02:C254  C4          
 5138                        	
 5139                        		.dbg	line,	"include\routines_LEVELS.c", 672; {
 5140                        	
 5141                        		.dbg	line,	"include\routines_LEVELS.c", 673; unsigned char i;
 5142                        	
 5143                        		.dbg	line,	"include\routines_LEVELS.c", 675; check_BG( 15 , 8 );
 5144                        		__ld.wi		15
         02:C255  A9 0F      			lda.l	#15
         02:C257  C2         			cly
 5145                        		__pusharg.wr
         02:C258  A6 8D      			ldx	<__sp
         02:C25A  CA         			dex
         02:C25B  CA         			dex
         02:C25C  95 08      			sta.l	<__stack, x
         02:C25E  94 09      			sty.h	<__stack, x
         02:C260  86 8D      			stx	<__sp
 5146                        		__ld.wi		8
         02:C262  A9 08      			lda.l	#8
         02:C264  C2         			cly
 5147                        		__pusharg.wr
         02:C265  A6 8D      			ldx	<__sp
         02:C267  CA         			dex
         02:C268  CA         			dex
         02:C269  95 08      			sta.l	<__stack, x
         02:C26B  94 09      			sty.h	<__stack, x
         02:C26D  86 8D      			stx	<__sp
 5148                        		__call		_check_BG
         02:C26F  20 6D FF   			call	_check_BG
 5149                        	
 5150                        		.dbg	line,	"include\routines_LEVELS.c", 677; if(map_blk_flag == TILE_EMPTY)
 5151                        		__not.um	_map_blk_flag
         02:C272  AD A5 2B   			lda	_map_blk_flag
         02:C275  18         			clc
         02:C276  D0 01      			bne	!+
         02:C278  38         			sec
         02:C279             	!:
 5152                        		__bfalse	.LL157
         02:C279  90 67      			bcc	.LL157
 5153                        	
 5154                        		.dbg	line,	"include\routines_LEVELS.c", 678; {
 5155                        	
 5156                        		.dbg	line,	"include\routines_LEVELS.c", 679; for(i=1 ; i<3 ; i++)
 5157                        		__st.umiq	1, __joypad_DIR_end - 1  /* i */
         02:C27B  A9 01      			lda.l	#1
         02:C27D  8D 04 23   			sta	__joypad_DIR_end - 1
 5158    02:C280             	.LL158:
 5159                        		__ld.umq	__joypad_DIR_end - 1  /* i */
         02:C280  AD 04 23   			lda	__joypad_DIR_end - 1
 5160                        		__ult_b.uiq	3
         02:C283  C9 03      			cmp	#3		; Subtract integer from A.
         02:C285  6A         			ror	a		; CC if A < integer.
         02:C286  49 80      			eor	#$80
         02:C288  2A         			rol	a
 5161                        		__btrue		.LL160
         02:C289  B0 07      			bcs	.LL160
 5162                        		__bra		.LL161
         02:C28B  80 63      			bra	.LL161
 5163    02:C28D             	.LL159:
 5164                        		__inc.umq	__joypad_DIR_end - 1  /* i */
         02:C28D  EE 04 23   			inc	__joypad_DIR_end - 1
 5165                        		__bra		.LL158
         02:C290  80 EE      			bra	.LL158
 5166    02:C292             	.LL160:
 5167                        	
 5168                        		.dbg	line,	"include\routines_LEVELS.c", 680; {
 5169                        	
 5170                        		.dbg	line,	"include\routines_LEVELS.c", 681; check_BG( 15 , 8 + i );
 5171                        		__ld.wi		15
         02:C292  A9 0F      			lda.l	#15
         02:C294  C2         			cly
 5172                        		__pusharg.wr
         02:C295  A6 8D      			ldx	<__sp
         02:C297  CA         			dex
         02:C298  CA         			dex
         02:C299  95 08      			sta.l	<__stack, x
         02:C29B  94 09      			sty.h	<__stack, x
         02:C29D  86 8D      			stx	<__sp
 5173                        		__ld.wi		8
         02:C29F  A9 08      			lda.l	#8
         02:C2A1  C2         			cly
 5174                        		__add.um	__joypad_DIR_end - 1  /* i */
         02:C2A2  18         			clc
         02:C2A3  6D 04 23   			adc	__joypad_DIR_end - 1
         02:C2A6  90 01      			bcc	!+
         02:C2A8  C8         			iny
         02:C2A9             	!:
 5175                        		__pusharg.wr
         02:C2A9  A6 8D      			ldx	<__sp
         02:C2AB  CA         			dex
         02:C2AC  CA         			dex
         02:C2AD  95 08      			sta.l	<__stack, x
         02:C2AF  94 09      			sty.h	<__stack, x
         02:C2B1  86 8D      			stx	<__sp
 5176                        		__call		_check_BG
         02:C2B3  20 6D FF   			call	_check_BG
 5177                        	
 5178                        		.dbg	line,	"include\routines_LEVELS.c", 683; if(map_blk_flag == TILE_LADDER)
 5179                        		__ld.umq	_map_blk_flag
         02:C2B6  AD A5 2B   			lda	_map_blk_flag
 5180                        		__equ_b.uiq	2
         02:C2B9  C9 02      			cmp	#2
         02:C2BB  F0 01      			beq	!+
         02:C2BD  18         			clc
         02:C2BE             	!:
 5181                        		__bfalse	.LL162
         02:C2BE  90 CD      			bcc	.LL162
 5182                        	
 5183                        		.dbg	line,	"include\routines_LEVELS.c", 684; {
 5184                        	
 5185                        		.dbg	line,	"include\routines_LEVELS.c", 685; sgx_map_pxl_y -= (2 - i);
 5186                        		__ld.wi		2
         02:C2C0  A9 02      			lda.l	#2
         02:C2C2  C2         			cly
 5187                        		__sub.um	__joypad_DIR_end - 1  /* i */
         02:C2C3  38         			sec
         02:C2C4  ED 04 23   			sbc	__joypad_DIR_end - 1
         02:C2C7  B0 01      			bcs	!+
         02:C2C9  88         			dey
         02:C2CA             	!:
 5188                        		__isub_st.wmq	_sgx_map_pxl_y
         02:C2CA  38         			sec
         02:C2CB  49 FF      			eor	#$FF
         02:C2CD  6D 86 26   			adc.l	_sgx_map_pxl_y
         02:C2D0  8D 86 26   			sta.l	_sgx_map_pxl_y
         02:C2D3  98         			tya
         02:C2D4  49 FF      			eor	#$FF
         02:C2D6  6D 87 26   			adc.h	_sgx_map_pxl_y
         02:C2D9  8D 87 26   			sta.h	_sgx_map_pxl_y
 5189                        	
 5190                        		.dbg	line,	"include\routines_LEVELS.c", 686; break;
 5191                        		__bra		.LL161
         02:C2DC  80 12      			bra	.LL161
 5192                        	
 5193                        		.dbg	line,	"include\routines_LEVELS.c", 687; }
 5194                        	
 5195                        		.dbg	line,	"include\routines_LEVELS.c", 688; }
 5196    02:C2DE             	.LL162	.alias		.LL159
 5197                        		__bra		.LL159
         02:C2DE  80 AD      			bra	.LL159
 5198    02:C2E0             	.LL161	.alias		.LL163
 5199                        	
 5200                        		.dbg	line,	"include\routines_LEVELS.c", 689; }
 5201                        	
 5202                        		.dbg	line,	"include\routines_LEVELS.c", 691; else
 5203                        		__bra		.LL163
         02:C2E0  80 0E      			bra	.LL163
 5204    02:C2E2             	.LL157:
 5205                        	
 5206                        		.dbg	line,	"include\routines_LEVELS.c", 692; {
 5207                        	
 5208                        		.dbg	line,	"include\routines_LEVELS.c", 693; sgx_map_pxl_y -= 2;
 5209                        		__sub_st.wmiq	2, _sgx_map_pxl_y
         02:C2E2  38         			sec
         02:C2E3  AD 86 26   			lda.l	_sgx_map_pxl_y
         02:C2E6  E9 02      			sbc.l	#2
         02:C2E8  8D 86 26   			sta.l	_sgx_map_pxl_y
         02:C2EB  B0 03      			bcs	!+
         02:C2ED  CE 87 26   			dec.h	_sgx_map_pxl_y
         02:C2F0             	!:
 5210                        	
 5211                        		.dbg	line,	"include\routines_LEVELS.c", 694; }
 5212    02:C2F0             	.LL163:
 5213                        	
 5214                        		.dbg	line,	"include\routines_LEVELS.c", 696; player_state = STATE_CLIMB_UP;
 5215                        		__st.umiq	11, _player_state
         02:C2F0  A9 0B      			lda.l	#11
         02:C2F2  8D 15 23   			sta	_player_state
 5216                        	
 5217                        		.dbg	line,	"include\routines_LEVELS.c", 697; }
 5218                        	
 5219                        		.dbg	line,	"include\routines_LEVELS.c", 698; }
 5220    02:C2F5             	.LL154	.alias		.LL164
 5221                        	
 5222                        		.dbg	line,	"include\routines_LEVELS.c", 701; //--------------------------------------------------------------------------------------//
 5223                        	
 5224                        		.dbg	line,	"include\routines_LEVELS.c", 702; //                                     DOWN BUTTON                                      //
 5225                        	
 5226                        		.dbg	line,	"include\routines_LEVELS.c", 703; //--------------------------------------------------------------------------------------//
 5227                        	
 5228                        		.dbg	line,	"include\routines_LEVELS.c", 705; else if(joy(JOYPAD_1) & JOY_DOWN)
 5229                        		__bra		.LL164
         02:C2F5  4C 14 C4   			bra	.LL164
 5230    02:C2F8             	.LL153:
 5231                        		__ld.uiq	0
         02:C2F8  62         			cla
 5232                        		 _joy.1
         02:C2F9  AA         			tax
         02:C2FA  BD 28 22   			lda	joynow, x
         02:C2FD  BC D3 22   			ldy	joy6now, x
 5233                        		__tand.wi	64
         02:C300  29 40      			and	#64
         02:C302  C9 01      	!:		cmp	#1
 5234                        		__bfalse	.LL165
         02:C304  B0 03 4C 14			bcc	.LL165
         02:C308  C4          
 5235                        	
 5236                        		.dbg	line,	"include\routines_LEVELS.c", 706; {
 5237                        	
 5238                        		.dbg	line,	"include\routines_LEVELS.c", 707; if(player_state == STATE_IDLE || player_state == STATE_WALK)
 5239                        		__not.um	_player_state
         02:C309  AD 15 23   			lda	_player_state
         02:C30C  18         			clc
         02:C30D  D0 01      			bne	!+
         02:C30F  38         			sec
         02:C310             	!:
 5240                        		__btrue		.LL167
         02:C310  B0 08      			bcs	.LL167
 5241                        		__ld.umq	_player_state
         02:C312  AD 15 23   			lda	_player_state
 5242                        		__equ_b.uiq	1
         02:C315  C9 01      			cmp	#1
         02:C317  F0 01      			beq	!+
         02:C319  18         			clc
         02:C31A             	!:
 5243    02:C31A             	.LL167:
 5244                        		__bfalse	.LL166
         02:C31A  90 0D      			bcc	.LL166
 5245                        	
 5246                        		.dbg	line,	"include\routines_LEVELS.c", 708; {
 5247                        	
 5248                        		.dbg	line,	"include\routines_LEVELS.c", 709; player_counter_anim = 1;
 5249                        		__st.umiq	1, _player_counter_anim
         02:C31C  A9 01      			lda.l	#1
         02:C31E  8D 18 23   			sta	_player_counter_anim
 5250                        	
 5251                        		.dbg	line,	"include\routines_LEVELS.c", 710; player_state = STATE_CROUCH;
 5252                        		__st.umiq	7, _player_state
         02:C321  A9 07      			lda.l	#7
         02:C323  8D 15 23   			sta	_player_state
 5253                        	
 5254                        		.dbg	line,	"include\routines_LEVELS.c", 711; }
 5255                        	
 5256                        		.dbg	line,	"include\routines_LEVELS.c", 714; else if(player_state == STATE_HANG || player_state == STATE_CLIMB_UP || player_state == STATE_CLIMB_DOWN)
 5257                        		__bra		.LL168
         02:C326  4C 14 C4   			bra	.LL168
 5258    02:C329             	.LL166:
 5259                        		__ld.umq	_player_state
         02:C329  AD 15 23   			lda	_player_state
 5260                        		__equ_b.uiq	10
         02:C32C  C9 0A      			cmp	#10
         02:C32E  F0 01      			beq	!+
         02:C330  18         			clc
         02:C331             	!:
 5261                        		__btrue		.LL170
         02:C331  B0 08      			bcs	.LL170
 5262                        		__ld.umq	_player_state
         02:C333  AD 15 23   			lda	_player_state
 5263                        		__equ_b.uiq	11
         02:C336  C9 0B      			cmp	#11
         02:C338  F0 01      			beq	!+
         02:C33A  18         			clc
         02:C33B             	!:
 5264    02:C33B             	.LL170:
 5265                        		__btrue		.LL171
         02:C33B  B0 08      			bcs	.LL171
 5266                        		__ld.umq	_player_state
         02:C33D  AD 15 23   			lda	_player_state
 5267                        		__equ_b.uiq	12
         02:C340  C9 0C      			cmp	#12
         02:C342  F0 01      			beq	!+
         02:C344  18         			clc
         02:C345             	!:
 5268    02:C345             	.LL171:
 5269                        		__bfalse	.LL169
         02:C345  B0 03 4C 14			bcc	.LL169
         02:C349  C4          
 5270                        	
 5271                        		.dbg	line,	"include\routines_LEVELS.c", 715; {
 5272                        	
 5273                        		.dbg	line,	"include\routines_LEVELS.c", 716; unsigned char i;
 5274                        	
 5275                        		.dbg	line,	"include\routines_LEVELS.c", 718; check_BG( 15 , 10 );
 5276                        		__ld.wi		15
         02:C34A  A9 0F      			lda.l	#15
         02:C34C  C2         			cly
 5277                        		__pusharg.wr
         02:C34D  A6 8D      			ldx	<__sp
         02:C34F  CA         			dex
         02:C350  CA         			dex
         02:C351  95 08      			sta.l	<__stack, x
         02:C353  94 09      			sty.h	<__stack, x
         02:C355  86 8D      			stx	<__sp
 5278                        		__ld.wi		10
         02:C357  A9 0A      			lda.l	#10
         02:C359  C2         			cly
 5279                        		__pusharg.wr
         02:C35A  A6 8D      			ldx	<__sp
         02:C35C  CA         			dex
         02:C35D  CA         			dex
         02:C35E  95 08      			sta.l	<__stack, x
         02:C360  94 09      			sty.h	<__stack, x
         02:C362  86 8D      			stx	<__sp
 5280                        		__call		_check_BG
         02:C364  20 6D FF   			call	_check_BG
 5281                        	
 5282                        		.dbg	line,	"include\routines_LEVELS.c", 720; if(map_blk_flag == TILE_EMPTY)
 5283                        		__not.um	_map_blk_flag
         02:C367  AD A5 2B   			lda	_map_blk_flag
         02:C36A  18         			clc
         02:C36B  D0 01      			bne	!+
         02:C36D  38         			sec
         02:C36E             	!:
 5284                        		__bfalse	.LL172
         02:C36E  B0 03 4C 01			bcc	.LL172
         02:C372  C4          
 5285                        	
 5286                        		.dbg	line,	"include\routines_LEVELS.c", 721; {
 5287                        	
 5288                        		.dbg	line,	"include\routines_LEVELS.c", 722; for(i=1 ; i<3 ; i++)
 5289                        		__st.umiq	1, __joypad_DIR_end - 2  /* i */
         02:C373  A9 01      			lda.l	#1
         02:C375  8D 03 23   			sta	__joypad_DIR_end - 2
 5290    02:C378             	.LL173:
 5291                        		__ld.umq	__joypad_DIR_end - 2  /* i */
         02:C378  AD 03 23   			lda	__joypad_DIR_end - 2
 5292                        		__ult_b.uiq	3
         02:C37B  C9 03      			cmp	#3		; Subtract integer from A.
         02:C37D  6A         			ror	a		; CC if A < integer.
         02:C37E  49 80      			eor	#$80
         02:C380  2A         			rol	a
 5293                        		__btrue		.LL175
         02:C381  B0 08      			bcs	.LL175
 5294                        		__bra		.LL176
         02:C383  4C 14 C4   			bra	.LL176
 5295    02:C386             	.LL174:
 5296                        		__inc.umq	__joypad_DIR_end - 2  /* i */
         02:C386  EE 03 23   			inc	__joypad_DIR_end - 2
 5297                        		__bra		.LL173
         02:C389  80 ED      			bra	.LL173
 5298    02:C38B             	.LL175:
 5299                        	
 5300                        		.dbg	line,	"include\routines_LEVELS.c", 723; {
 5301                        	
 5302                        		.dbg	line,	"include\routines_LEVELS.c", 724; check_BG( 15 , 22 + i );
 5303                        		__ld.wi		15
         02:C38B  A9 0F      			lda.l	#15
         02:C38D  C2         			cly
 5304                        		__pusharg.wr
         02:C38E  A6 8D      			ldx	<__sp
         02:C390  CA         			dex
         02:C391  CA         			dex
         02:C392  95 08      			sta.l	<__stack, x
         02:C394  94 09      			sty.h	<__stack, x
         02:C396  86 8D      			stx	<__sp
 5305                        		__ld.wi		22
         02:C398  A9 16      			lda.l	#22
         02:C39A  C2         			cly
 5306                        		__add.um	__joypad_DIR_end - 2  /* i */
         02:C39B  18         			clc
         02:C39C  6D 03 23   			adc	__joypad_DIR_end - 2
         02:C39F  90 01      			bcc	!+
         02:C3A1  C8         			iny
         02:C3A2             	!:
 5307                        		__pusharg.wr
         02:C3A2  A6 8D      			ldx	<__sp
         02:C3A4  CA         			dex
         02:C3A5  CA         			dex
         02:C3A6  95 08      			sta.l	<__stack, x
         02:C3A8  94 09      			sty.h	<__stack, x
         02:C3AA  86 8D      			stx	<__sp
 5308                        		__call		_check_BG
         02:C3AC  20 6D FF   			call	_check_BG
 5309                        	
 5310                        		.dbg	line,	"include\routines_LEVELS.c", 726; if(map_blk_flag == TILE_LADDER)
 5311                        		__ld.umq	_map_blk_flag
         02:C3AF  AD A5 2B   			lda	_map_blk_flag
 5312                        		__equ_b.uiq	2
         02:C3B2  C9 02      			cmp	#2
         02:C3B4  F0 01      			beq	!+
         02:C3B6  18         			clc
         02:C3B7             	!:
 5313                        		__bfalse	.LL177
         02:C3B7  90 1A      			bcc	.LL177
 5314                        	
 5315                        		.dbg	line,	"include\routines_LEVELS.c", 727; {
 5316                        	
 5317                        		.dbg	line,	"include\routines_LEVELS.c", 728; sgx_map_pxl_y += (2 - i);
 5318                        		__ld.wi		2
         02:C3B9  A9 02      			lda.l	#2
         02:C3BB  C2         			cly
 5319                        		__sub.um	__joypad_DIR_end - 2  /* i */
         02:C3BC  38         			sec
         02:C3BD  ED 03 23   			sbc	__joypad_DIR_end - 2
         02:C3C0  B0 01      			bcs	!+
         02:C3C2  88         			dey
         02:C3C3             	!:
 5320                        		__add_st.wmq	_sgx_map_pxl_y
         02:C3C3  18         			clc
         02:C3C4  6D 86 26   			adc.l	_sgx_map_pxl_y
         02:C3C7  8D 86 26   			sta.l	_sgx_map_pxl_y
         02:C3CA  98         			tya
         02:C3CB  6D 87 26   			adc.h	_sgx_map_pxl_y
         02:C3CE  8D 87 26   			sta.h	_sgx_map_pxl_y
 5321                        	
 5322                        		.dbg	line,	"include\routines_LEVELS.c", 729; break;
 5323                        		__bra		.LL176
         02:C3D1  80 41      			bra	.LL176
 5324                        	
 5325                        		.dbg	line,	"include\routines_LEVELS.c", 730; }
 5326                        	
 5327                        		.dbg	line,	"include\routines_LEVELS.c", 732; else
 5328    02:C3D3             	.LL177:
 5329                        	
 5330                        		.dbg	line,	"include\routines_LEVELS.c", 733; {
 5331                        	
 5332                        		.dbg	line,	"include\routines_LEVELS.c", 734; load_vram(PLAYER_VRAM_ADR, tiles_SPR_PLAYER + TILES_224 , TILES_16);
 5333                        		__st.wmiq	6144, _di
         02:C3D3  64 F0      			stz.l	_di
         02:C3D5  A9 18      			lda.h	#6144
         02:C3D7  85 F1      			sta.h	_di
 5334                        		__farptr	_tiles_SPR_PLAYER + 7168 + 512, _bp_bank, _bp
         02:C3D9  A9 E0      			lda.l	#$6000 + ($1FFF & (_tiles_SPR_PLAYER + 7168 + 512))
         02:C3DB  85 EC      			sta.l	_bp
         02:C3DD  A9 67      			lda.h	#$6000 + ($1FFF & (_tiles_SPR_PLAYER + 7168 + 512))
         02:C3DF  85 ED      			sta.h	_bp
         02:C3E1  A9 0F      			lda	#bank(_tiles_SPR_PLAYER + 7168 + 512)
         02:C3E3  85 02      			sta	_bp_bank
 5335                        		__st.wmiq	256, _ax
         02:C3E5  64 F8      			stz.l	_ax
         02:C3E7  A9 01      			lda.h	#256
         02:C3E9  85 F9      			sta.h	_ax
 5336                        		 _load_vram.3
         02:C3EB  82         			clx				; Offset to PCE VDC.
         02:C3EC  20 63 FF   			call	load_vram_x
 5337                        	
 5338                        		.dbg	line,	"include\routines_LEVELS.c", 736; jump_ladder = FALSE;
 5339                        		__st.umiq	0, _jump_ladder
         02:C3EF  9C 1B 23   			stz	_jump_ladder
 5340                        	
 5341                        		.dbg	line,	"include\routines_LEVELS.c", 737; player_index_jump = 0;
 5342                        		__st.umiq	0, _player_index_jump
         02:C3F2  9C 19 23   			stz	_player_index_jump
 5343                        	
 5344                        		.dbg	line,	"include\routines_LEVELS.c", 738; player_index_fall = 0;
 5345                        		__st.umiq	0, _player_index_fall
         02:C3F5  9C 1A 23   			stz	_player_index_fall
 5346                        	
 5347                        		.dbg	line,	"include\routines_LEVELS.c", 739; player_state = STATE_FALL;
 5348                        		__st.umiq	9, _player_state
         02:C3F8  A9 09      			lda.l	#9
         02:C3FA  8D 15 23   			sta	_player_state
 5349                        	
 5350                        		.dbg	line,	"include\routines_LEVELS.c", 740; }
 5351    02:C3FD             	.LL178	.alias		.LL174
 5352                        	
 5353                        		.dbg	line,	"include\routines_LEVELS.c", 741; }
 5354                        		__bra		.LL174
         02:C3FD  80 87      			bra	.LL174
 5355    02:C3FF             	.LL176	.alias		.LL179
 5356                        	
 5357                        		.dbg	line,	"include\routines_LEVELS.c", 742; }
 5358                        	
 5359                        		.dbg	line,	"include\routines_LEVELS.c", 744; else
 5360                        		__bra		.LL179
         02:C3FF  80 13      			bra	.LL179
 5361    02:C401             	.LL172:
 5362                        	
 5363                        		.dbg	line,	"include\routines_LEVELS.c", 745; {
 5364                        	
 5365                        		.dbg	line,	"include\routines_LEVELS.c", 746; sgx_map_pxl_y += 2;
 5366                        		__add_st.wmiq	2, _sgx_map_pxl_y
         02:C401  18         			clc
         02:C402  AD 86 26   			lda.l	_sgx_map_pxl_y
         02:C405  69 02      			adc.l	#2
         02:C407  8D 86 26   			sta.l	_sgx_map_pxl_y
         02:C40A  90 03      			bcc	!+
         02:C40C  EE 87 26   			inc.h	_sgx_map_pxl_y
         02:C40F             	!:
 5367                        	
 5368                        		.dbg	line,	"include\routines_LEVELS.c", 747; player_state = STATE_CLIMB_DOWN;
 5369                        		__st.umiq	12, _player_state
         02:C40F  A9 0C      			lda.l	#12
         02:C411  8D 15 23   			sta	_player_state
 5370                        	
 5371                        		.dbg	line,	"include\routines_LEVELS.c", 748; }
 5372    02:C414             	.LL179:
 5373                        	
 5374                        		.dbg	line,	"include\routines_LEVELS.c", 749; }
 5375                        	
 5376                        		.dbg	line,	"include\routines_LEVELS.c", 750; }
 5377    02:C414             	.LL169:
 5378    02:C414             	.LL168:
 5379                        	
 5380                        		.dbg	line,	"include\routines_LEVELS.c", 751; }
 5381    02:C414             	.LL165:
 5382    02:C414             	.LL164:
 5383    02:C414             	.LL152:
 5384    02:C414             	.LL136:
 5385    02:C414             	.LL114:
 5386                        		__return	0
         02:C414  4C EF FF   			jmp	leave_proc
 5387                        		.dbg	clear
 5388                        		.endp
 5389               7960     		.data
 5390               2303     		.bss
 5391    F8:2303             	__joypad_DIR_loc:
 5392    F8:2303             			ds	2
 5393    F8:2305             	__joypad_DIR_end:
 5394               E309     		.code
 5395                        		.pceas
 5396                        	
 5397                        		.dbg	line,	"include\routines_LEVELS.c", 760; void update_PLAYER()
 5398                        		.dbg	line,	"include\routines_LEVELS.c", 761; {
 5399                        	;***********************
 5400                        	;***********************
 5401                        	
 5402                        		.hucc
 5403    01:C13F             		.proc		_update_PLAYER
 5404                        		__enter		_update_PLAYER
 5405                        	
 5406                        		.dbg	line,	"include\routines_LEVELS.c", 762; if(player_state == STATE_IDLE)
 5407                        		__not.um	_player_state
         01:C13F  AD 15 23   			lda	_player_state
         01:C142  18         			clc
         01:C143  D0 01      			bne	!+
         01:C145  38         			sec
         01:C146             	!:
 5408                        		__bfalse	.LL181
         01:C146  B0 03 4C F6			bcc	.LL181
         01:C14A  C1          
 5409                        	
 5410                        		.dbg	line,	"include\routines_LEVELS.c", 763; {
 5411                        	
 5412                        		.dbg	line,	"include\routines_LEVELS.c", 764; if(player_counter_anim == 1)
 5413                        		__ld.umq	_player_counter_anim
         01:C14B  AD 18 23   			lda	_player_counter_anim
 5414                        		__equ_b.uiq	1
         01:C14E  C9 01      			cmp	#1
         01:C150  F0 01      			beq	!+
         01:C152  18         			clc
         01:C153             	!:
 5415                        		__bfalse	.LL182
         01:C153  90 1F      			bcc	.LL182
 5416                        	
 5417                        		.dbg	line,	"include\routines_LEVELS.c", 765; {
 5418                        	
 5419                        		.dbg	line,	"include\routines_LEVELS.c", 766; load_vram(PLAYER_VRAM_ADR, tiles_SPR_PLAYER , TILES_16);
 5420                        		__st.wmiq	6144, _di
         01:C155  64 F0      			stz.l	_di
         01:C157  A9 18      			lda.h	#6144
         01:C159  85 F1      			sta.h	_di
 5421                        		__farptr	_tiles_SPR_PLAYER, _bp_bank, _bp
         01:C15B  A9 E0      			lda.l	#$6000 + ($1FFF & (_tiles_SPR_PLAYER))
         01:C15D  85 EC      			sta.l	_bp
         01:C15F  A9 69      			lda.h	#$6000 + ($1FFF & (_tiles_SPR_PLAYER))
         01:C161  85 ED      			sta.h	_bp
         01:C163  A9 0E      			lda	#bank(_tiles_SPR_PLAYER)
         01:C165  85 02      			sta	_bp_bank
 5422                        		__st.wmiq	256, _ax
         01:C167  64 F8      			stz.l	_ax
         01:C169  A9 01      			lda.h	#256
         01:C16B  85 F9      			sta.h	_ax
 5423                        		 _load_vram.3
         01:C16D  82         			clx				; Offset to PCE VDC.
         01:C16E  20 63 FF   			call	load_vram_x
 5424                        	
 5425                        		.dbg	line,	"include\routines_LEVELS.c", 768; player_counter_anim = 0;
 5426                        		__st.umiq	0, _player_counter_anim
         01:C171  9C 18 23   			stz	_player_counter_anim
 5427                        	
 5428                        		.dbg	line,	"include\routines_LEVELS.c", 769; }
 5429                        	
 5430                        		.dbg	line,	"include\routines_LEVELS.c", 771; recenter_CAMERA();
 5431    01:C174             	.LL182:
 5432                        		__call		_recenter_CAMERA
         01:C174  20 59 FF   			call	_recenter_CAMERA
 5433                        	
 5434                        		.dbg	line,	"include\routines_LEVELS.c", 774; // CHECK COLLISION WITH LEFT FLOOR //
 5435                        	
 5436                        		.dbg	line,	"include\routines_LEVELS.c", 775; check_BG( 10 , 32 );//8
 5437                        		__ld.wi		10
         01:C177  A9 0A      			lda.l	#10
         01:C179  C2         			cly
 5438                        		__pusharg.wr
         01:C17A  A6 8D      			ldx	<__sp
         01:C17C  CA         			dex
         01:C17D  CA         			dex
         01:C17E  95 08      			sta.l	<__stack, x
         01:C180  94 09      			sty.h	<__stack, x
         01:C182  86 8D      			stx	<__sp
 5439                        		__ld.wi		32
         01:C184  A9 20      			lda.l	#32
         01:C186  C2         			cly
 5440                        		__pusharg.wr
         01:C187  A6 8D      			ldx	<__sp
         01:C189  CA         			dex
         01:C18A  CA         			dex
         01:C18B  95 08      			sta.l	<__stack, x
         01:C18D  94 09      			sty.h	<__stack, x
         01:C18F  86 8D      			stx	<__sp
 5441                        		__call		_check_BG
         01:C191  20 6D FF   			call	_check_BG
 5442                        	
 5443                        		.dbg	line,	"include\routines_LEVELS.c", 777; if(map_blk_flag == TILE_EMPTY)
 5444                        		__not.um	_map_blk_flag
         01:C194  AD A5 2B   			lda	_map_blk_flag
         01:C197  18         			clc
         01:C198  D0 01      			bne	!+
         01:C19A  38         			sec
         01:C19B             	!:
 5445                        		__bfalse	.LL183
         01:C19B  B0 03 4C 58			bcc	.LL183
         01:C19F  D6          
 5446                        	
 5447                        		.dbg	line,	"include\routines_LEVELS.c", 778; {
 5448                        	
 5449                        		.dbg	line,	"include\routines_LEVELS.c", 779; // CHECK COLLISION WITH RIGHT FLOOR //
 5450                        	
 5451                        		.dbg	line,	"include\routines_LEVELS.c", 780; check_BG( 22 , 32 );//24
 5452                        		__ld.wi		22
         01:C1A0  A9 16      			lda.l	#22
         01:C1A2  C2         			cly
 5453                        		__pusharg.wr
         01:C1A3  A6 8D      			ldx	<__sp
         01:C1A5  CA         			dex
         01:C1A6  CA         			dex
         01:C1A7  95 08      			sta.l	<__stack, x
         01:C1A9  94 09      			sty.h	<__stack, x
         01:C1AB  86 8D      			stx	<__sp
 5454                        		__ld.wi		32
         01:C1AD  A9 20      			lda.l	#32
         01:C1AF  C2         			cly
 5455                        		__pusharg.wr
         01:C1B0  A6 8D      			ldx	<__sp
         01:C1B2  CA         			dex
         01:C1B3  CA         			dex
         01:C1B4  95 08      			sta.l	<__stack, x
         01:C1B6  94 09      			sty.h	<__stack, x
         01:C1B8  86 8D      			stx	<__sp
 5456                        		__call		_check_BG
         01:C1BA  20 6D FF   			call	_check_BG
 5457                        	
 5458                        		.dbg	line,	"include\routines_LEVELS.c", 782; if(map_blk_flag == TILE_EMPTY)
 5459                        		__not.um	_map_blk_flag
         01:C1BD  AD A5 2B   			lda	_map_blk_flag
         01:C1C0  18         			clc
         01:C1C1  D0 01      			bne	!+
         01:C1C3  38         			sec
         01:C1C4             	!:
 5460                        		__bfalse	.LL184
         01:C1C4  B0 03 4C 58			bcc	.LL184
         01:C1C8  D6          
 5461                        	
 5462                        		.dbg	line,	"include\routines_LEVELS.c", 783; {
 5463                        	
 5464                        		.dbg	line,	"include\routines_LEVELS.c", 784; load_vram(PLAYER_VRAM_ADR, tiles_SPR_PLAYER , TILES_16);
 5465                        		__st.wmiq	6144, _di
         01:C1C9  64 F0      			stz.l	_di
         01:C1CB  A9 18      			lda.h	#6144
         01:C1CD  85 F1      			sta.h	_di
 5466                        		__farptr	_tiles_SPR_PLAYER, _bp_bank, _bp
         01:C1CF  A9 E0      			lda.l	#$6000 + ($1FFF & (_tiles_SPR_PLAYER))
         01:C1D1  85 EC      			sta.l	_bp
         01:C1D3  A9 69      			lda.h	#$6000 + ($1FFF & (_tiles_SPR_PLAYER))
         01:C1D5  85 ED      			sta.h	_bp
         01:C1D7  A9 0E      			lda	#bank(_tiles_SPR_PLAYER)
         01:C1D9  85 02      			sta	_bp_bank
 5467                        		__st.wmiq	256, _ax
         01:C1DB  64 F8      			stz.l	_ax
         01:C1DD  A9 01      			lda.h	#256
         01:C1DF  85 F9      			sta.h	_ax
 5468                        		 _load_vram.3
         01:C1E1  82         			clx				; Offset to PCE VDC.
         01:C1E2  20 63 FF   			call	load_vram_x
 5469                        	
 5470                        		.dbg	line,	"include\routines_LEVELS.c", 786; jump_ladder = FALSE;
 5471                        		__st.umiq	0, _jump_ladder
         01:C1E5  9C 1B 23   			stz	_jump_ladder
 5472                        	
 5473                        		.dbg	line,	"include\routines_LEVELS.c", 787; player_index_jump = 0;
 5474                        		__st.umiq	0, _player_index_jump
         01:C1E8  9C 19 23   			stz	_player_index_jump
 5475                        	
 5476                        		.dbg	line,	"include\routines_LEVELS.c", 788; player_index_fall = 0;
 5477                        		__st.umiq	0, _player_index_fall
         01:C1EB  9C 1A 23   			stz	_player_index_fall
 5478                        	
 5479                        		.dbg	line,	"include\routines_LEVELS.c", 789; player_state = STATE_FALL;
 5480                        		__st.umiq	9, _player_state
         01:C1EE  A9 09      			lda.l	#9
         01:C1F0  8D 15 23   			sta	_player_state
 5481                        	
 5482                        		.dbg	line,	"include\routines_LEVELS.c", 790; }
 5483                        	
 5484                        		.dbg	line,	"include\routines_LEVELS.c", 791; }
 5485    01:C1F3             	.LL184	.alias		.LL185
 5486                        	
 5487                        		.dbg	line,	"include\routines_LEVELS.c", 792; }
 5488    01:C1F3             	.LL183	.alias		.LL185
 5489                        	
 5490                        		.dbg	line,	"include\routines_LEVELS.c", 795; else if(player_state == STATE_WALK)
 5491                        		__bra		.LL185
         01:C1F3  4C 58 D6   			bra	.LL185
 5492    01:C1F6             	.LL181:
 5493                        		__ld.umq	_player_state
         01:C1F6  AD 15 23   			lda	_player_state
 5494                        		__equ_b.uiq	1
         01:C1F9  C9 01      			cmp	#1
         01:C1FB  F0 01      			beq	!+
         01:C1FD  18         			clc
         01:C1FE             	!:
 5495                        		__bfalse	.LL186
         01:C1FE  B0 03 4C D1			bcc	.LL186
         01:C202  C4          
 5496                        	
 5497                        		.dbg	line,	"include\routines_LEVELS.c", 796; {
 5498                        	
 5499                        		.dbg	line,	"include\routines_LEVELS.c", 797; recenter_CAMERA();
 5500                        		__call		_recenter_CAMERA
         01:C203  20 59 FF   			call	_recenter_CAMERA
 5501                        	
 5502                        		.dbg	line,	"include\routines_LEVELS.c", 800; //--------------------------------------------------------------------------------------//
 5503                        	
 5504                        		.dbg	line,	"include\routines_LEVELS.c", 801; //                                   FLOOR COLLISION                                    //
 5505                        	
 5506                        		.dbg	line,	"include\routines_LEVELS.c", 802; //--------------------------------------------------------------------------------------//
 5507                        	
 5508                        		.dbg	line,	"include\routines_LEVELS.c", 804; // CHECK COLLISION WITH LEFT FLOOR //
 5509                        	
 5510                        		.dbg	line,	"include\routines_LEVELS.c", 805; check_BG( 10 , 32 );//8
 5511                        		__ld.wi		10
         01:C206  A9 0A      			lda.l	#10
         01:C208  C2         			cly
 5512                        		__pusharg.wr
         01:C209  A6 8D      			ldx	<__sp
         01:C20B  CA         			dex
         01:C20C  CA         			dex
         01:C20D  95 08      			sta.l	<__stack, x
         01:C20F  94 09      			sty.h	<__stack, x
         01:C211  86 8D      			stx	<__sp
 5513                        		__ld.wi		32
         01:C213  A9 20      			lda.l	#32
         01:C215  C2         			cly
 5514                        		__pusharg.wr
         01:C216  A6 8D      			ldx	<__sp
         01:C218  CA         			dex
         01:C219  CA         			dex
         01:C21A  95 08      			sta.l	<__stack, x
         01:C21C  94 09      			sty.h	<__stack, x
         01:C21E  86 8D      			stx	<__sp
 5515                        		__call		_check_BG
         01:C220  20 6D FF   			call	_check_BG
 5516                        	
 5517                        		.dbg	line,	"include\routines_LEVELS.c", 807; if(map_blk_flag == TILE_EMPTY)
 5518                        		__not.um	_map_blk_flag
         01:C223  AD A5 2B   			lda	_map_blk_flag
         01:C226  18         			clc
         01:C227  D0 01      			bne	!+
         01:C229  38         			sec
         01:C22A             	!:
 5519                        		__bfalse	.LL187
         01:C22A  B0 03 4C FE			bcc	.LL187
         01:C22E  C2          
 5520                        	
 5521                        		.dbg	line,	"include\routines_LEVELS.c", 808; {
 5522                        	
 5523                        		.dbg	line,	"include\routines_LEVELS.c", 809; // CHECK COLLISION WITH RIGHT FLOOR //
 5524                        	
 5525                        		.dbg	line,	"include\routines_LEVELS.c", 810; check_BG( 22 , 32 );//24
 5526                        		__ld.wi		22
         01:C22F  A9 16      			lda.l	#22
         01:C231  C2         			cly
 5527                        		__pusharg.wr
         01:C232  A6 8D      			ldx	<__sp
         01:C234  CA         			dex
         01:C235  CA         			dex
         01:C236  95 08      			sta.l	<__stack, x
         01:C238  94 09      			sty.h	<__stack, x
         01:C23A  86 8D      			stx	<__sp
 5528                        		__ld.wi		32
         01:C23C  A9 20      			lda.l	#32
         01:C23E  C2         			cly
 5529                        		__pusharg.wr
         01:C23F  A6 8D      			ldx	<__sp
         01:C241  CA         			dex
         01:C242  CA         			dex
         01:C243  95 08      			sta.l	<__stack, x
         01:C245  94 09      			sty.h	<__stack, x
         01:C247  86 8D      			stx	<__sp
 5530                        		__call		_check_BG
         01:C249  20 6D FF   			call	_check_BG
 5531                        	
 5532                        		.dbg	line,	"include\routines_LEVELS.c", 812; if(map_blk_flag == TILE_EMPTY)
 5533                        		__not.um	_map_blk_flag
         01:C24C  AD A5 2B   			lda	_map_blk_flag
         01:C24F  18         			clc
         01:C250  D0 01      			bne	!+
         01:C252  38         			sec
         01:C253             	!:
 5534                        		__bfalse	.LL188
         01:C253  90 2D      			bcc	.LL188
 5535                        	
 5536                        		.dbg	line,	"include\routines_LEVELS.c", 813; {
 5537                        	
 5538                        		.dbg	line,	"include\routines_LEVELS.c", 814; load_vram(PLAYER_VRAM_ADR, tiles_SPR_PLAYER , TILES_16);
 5539                        		__st.wmiq	6144, _di
         01:C255  64 F0      			stz.l	_di
         01:C257  A9 18      			lda.h	#6144
         01:C259  85 F1      			sta.h	_di
 5540                        		__farptr	_tiles_SPR_PLAYER, _bp_bank, _bp
         01:C25B  A9 E0      			lda.l	#$6000 + ($1FFF & (_tiles_SPR_PLAYER))
         01:C25D  85 EC      			sta.l	_bp
         01:C25F  A9 69      			lda.h	#$6000 + ($1FFF & (_tiles_SPR_PLAYER))
         01:C261  85 ED      			sta.h	_bp
         01:C263  A9 0E      			lda	#bank(_tiles_SPR_PLAYER)
         01:C265  85 02      			sta	_bp_bank
 5541                        		__st.wmiq	256, _ax
         01:C267  64 F8      			stz.l	_ax
         01:C269  A9 01      			lda.h	#256
         01:C26B  85 F9      			sta.h	_ax
 5542                        		 _load_vram.3
         01:C26D  82         			clx				; Offset to PCE VDC.
         01:C26E  20 63 FF   			call	load_vram_x
 5543                        	
 5544                        		.dbg	line,	"include\routines_LEVELS.c", 816; jump_ladder = FALSE;
 5545                        		__st.umiq	0, _jump_ladder
         01:C271  9C 1B 23   			stz	_jump_ladder
 5546                        	
 5547                        		.dbg	line,	"include\routines_LEVELS.c", 817; player_index_jump = 0;
 5548                        		__st.umiq	0, _player_index_jump
         01:C274  9C 19 23   			stz	_player_index_jump
 5549                        	
 5550                        		.dbg	line,	"include\routines_LEVELS.c", 818; player_index_fall = 0;
 5551                        		__st.umiq	0, _player_index_fall
         01:C277  9C 1A 23   			stz	_player_index_fall
 5552                        	
 5553                        		.dbg	line,	"include\routines_LEVELS.c", 819; player_state = STATE_FALL;
 5554                        		__st.umiq	9, _player_state
         01:C27A  A9 09      			lda.l	#9
         01:C27C  8D 15 23   			sta	_player_state
 5555                        	
 5556                        		.dbg	line,	"include\routines_LEVELS.c", 820; }
 5557                        	
 5558                        		.dbg	line,	"include\routines_LEVELS.c", 822; else
 5559                        		__bra		.LL189
         01:C27F  4C 71 C3   			bra	.LL189
 5560    01:C282             	.LL188:
 5561                        	
 5562                        		.dbg	line,	"include\routines_LEVELS.c", 823; {
 5563                        	
 5564                        		.dbg	line,	"include\routines_LEVELS.c", 824; if(player_axis == AXIS_RIGHT)
 5565                        		__not.um	_player_axis
         01:C282  AD 16 23   			lda	_player_axis
         01:C285  18         			clc
         01:C286  D0 01      			bne	!+
         01:C288  38         			sec
         01:C289             	!:
 5566                        		__bfalse	.LL190
         01:C289  90 3A      			bcc	.LL190
 5567                        	
 5568                        		.dbg	line,	"include\routines_LEVELS.c", 825; {
 5569                        	
 5570                        		.dbg	line,	"include\routines_LEVELS.c", 826; // CHECK COLLISION WITH RIGHT WALL //
 5571                        	
 5572                        		.dbg	line,	"include\routines_LEVELS.c", 827; check_BG( 24 , 31 ); // 24+2
 5573                        		__ld.wi		24
         01:C28B  A9 18      			lda.l	#24
         01:C28D  C2         			cly
 5574                        		__pusharg.wr
         01:C28E  A6 8D      			ldx	<__sp
         01:C290  CA         			dex
         01:C291  CA         			dex
         01:C292  95 08      			sta.l	<__stack, x
         01:C294  94 09      			sty.h	<__stack, x
         01:C296  86 8D      			stx	<__sp
 5575                        		__ld.wi		31
         01:C298  A9 1F      			lda.l	#31
         01:C29A  C2         			cly
 5576                        		__pusharg.wr
         01:C29B  A6 8D      			ldx	<__sp
         01:C29D  CA         			dex
         01:C29E  CA         			dex
         01:C29F  95 08      			sta.l	<__stack, x
         01:C2A1  94 09      			sty.h	<__stack, x
         01:C2A3  86 8D      			stx	<__sp
 5577                        		__call		_check_BG
         01:C2A5  20 6D FF   			call	_check_BG
 5578                        	
 5579                        		.dbg	line,	"include\routines_LEVELS.c", 829; if(map_blk_flag == TILE_EMPTY)
 5580                        		__not.um	_map_blk_flag
         01:C2A8  AD A5 2B   			lda	_map_blk_flag
         01:C2AB  18         			clc
         01:C2AC  D0 01      			bne	!+
         01:C2AE  38         			sec
         01:C2AF             	!:
 5581                        		__bfalse	.LL191
         01:C2AF  B0 03 4C 71			bcc	.LL191
         01:C2B3  C3          
 5582                        	
 5583                        		.dbg	line,	"include\routines_LEVELS.c", 830; {
 5584                        	
 5585                        		.dbg	line,	"include\routines_LEVELS.c", 831; sgx_map_pxl_x += 2;
 5586                        		__add_st.wmiq	2, _sgx_map_pxl_x
         01:C2B4  18         			clc
         01:C2B5  AD 84 26   			lda.l	_sgx_map_pxl_x
         01:C2B8  69 02      			adc.l	#2
         01:C2BA  8D 84 26   			sta.l	_sgx_map_pxl_x
         01:C2BD  90 03      			bcc	!+
         01:C2BF  EE 85 26   			inc.h	_sgx_map_pxl_x
         01:C2C2             	!:
 5587                        	
 5588                        		.dbg	line,	"include\routines_LEVELS.c", 832; }
 5589                        	
 5590                        		.dbg	line,	"include\routines_LEVELS.c", 833; }
 5591    01:C2C2             	.LL191	.alias		.LL192
 5592                        	
 5593                        		.dbg	line,	"include\routines_LEVELS.c", 835; else
 5594                        		__bra		.LL192
         01:C2C2  4C 71 C3   			bra	.LL192
 5595    01:C2C5             	.LL190:
 5596                        	
 5597                        		.dbg	line,	"include\routines_LEVELS.c", 836; {
 5598                        	
 5599                        		.dbg	line,	"include\routines_LEVELS.c", 837; // CHECK COLLISION WITH LEFT WALL //
 5600                        	
 5601                        		.dbg	line,	"include\routines_LEVELS.c", 838; check_BG( 8 , 31 ); // 8-2
 5602                        		__ld.wi		8
         01:C2C5  A9 08      			lda.l	#8
         01:C2C7  C2         			cly
 5603                        		__pusharg.wr
         01:C2C8  A6 8D      			ldx	<__sp
         01:C2CA  CA         			dex
         01:C2CB  CA         			dex
         01:C2CC  95 08      			sta.l	<__stack, x
         01:C2CE  94 09      			sty.h	<__stack, x
         01:C2D0  86 8D      			stx	<__sp
 5604                        		__ld.wi		31
         01:C2D2  A9 1F      			lda.l	#31
         01:C2D4  C2         			cly
 5605                        		__pusharg.wr
         01:C2D5  A6 8D      			ldx	<__sp
         01:C2D7  CA         			dex
         01:C2D8  CA         			dex
         01:C2D9  95 08      			sta.l	<__stack, x
         01:C2DB  94 09      			sty.h	<__stack, x
         01:C2DD  86 8D      			stx	<__sp
 5606                        		__call		_check_BG
         01:C2DF  20 6D FF   			call	_check_BG
 5607                        	
 5608                        		.dbg	line,	"include\routines_LEVELS.c", 840; if(map_blk_flag == TILE_EMPTY)
 5609                        		__not.um	_map_blk_flag
         01:C2E2  AD A5 2B   			lda	_map_blk_flag
         01:C2E5  18         			clc
         01:C2E6  D0 01      			bne	!+
         01:C2E8  38         			sec
         01:C2E9             	!:
 5610                        		__bfalse	.LL193
         01:C2E9  B0 03 4C 71			bcc	.LL193
         01:C2ED  C3          
 5611                        	
 5612                        		.dbg	line,	"include\routines_LEVELS.c", 841; {
 5613                        	
 5614                        		.dbg	line,	"include\routines_LEVELS.c", 842; sgx_map_pxl_x -= 2;
 5615                        		__sub_st.wmiq	2, _sgx_map_pxl_x
         01:C2EE  38         			sec
         01:C2EF  AD 84 26   			lda.l	_sgx_map_pxl_x
         01:C2F2  E9 02      			sbc.l	#2
         01:C2F4  8D 84 26   			sta.l	_sgx_map_pxl_x
         01:C2F7  B0 03      			bcs	!+
         01:C2F9  CE 85 26   			dec.h	_sgx_map_pxl_x
         01:C2FC             	!:
 5616                        	
 5617                        		.dbg	line,	"include\routines_LEVELS.c", 843; }
 5618                        	
 5619                        		.dbg	line,	"include\routines_LEVELS.c", 844; }
 5620    01:C2FC             	.LL193	.alias		.LL194
 5621    01:C2FC             	.LL192	.alias		.LL194
 5622                        	
 5623                        		.dbg	line,	"include\routines_LEVELS.c", 845; }
 5624    01:C2FC             	.LL189	.alias		.LL194
 5625                        	
 5626                        		.dbg	line,	"include\routines_LEVELS.c", 846; }
 5627                        	
 5628                        		.dbg	line,	"include\routines_LEVELS.c", 848; else
 5629                        		__bra		.LL194
         01:C2FC  80 73      			bra	.LL194
 5630    01:C2FE             	.LL187:
 5631                        	
 5632                        		.dbg	line,	"include\routines_LEVELS.c", 849; {
 5633                        	
 5634                        		.dbg	line,	"include\routines_LEVELS.c", 850; if(player_axis == AXIS_RIGHT)
 5635                        		__not.um	_player_axis
         01:C2FE  AD 16 23   			lda	_player_axis
         01:C301  18         			clc
         01:C302  D0 01      			bne	!+
         01:C304  38         			sec
         01:C305             	!:
 5636                        		__bfalse	.LL195
         01:C305  90 36      			bcc	.LL195
 5637                        	
 5638                        		.dbg	line,	"include\routines_LEVELS.c", 851; {
 5639                        	
 5640                        		.dbg	line,	"include\routines_LEVELS.c", 852; // CHECK COLLISION WITH RIGHT WALL //
 5641                        	
 5642                        		.dbg	line,	"include\routines_LEVELS.c", 853; check_BG( 24 , 31 ); // 24+2
 5643                        		__ld.wi		24
         01:C307  A9 18      			lda.l	#24
         01:C309  C2         			cly
 5644                        		__pusharg.wr
         01:C30A  A6 8D      			ldx	<__sp
         01:C30C  CA         			dex
         01:C30D  CA         			dex
         01:C30E  95 08      			sta.l	<__stack, x
         01:C310  94 09      			sty.h	<__stack, x
         01:C312  86 8D      			stx	<__sp
 5645                        		__ld.wi		31
         01:C314  A9 1F      			lda.l	#31
         01:C316  C2         			cly
 5646                        		__pusharg.wr
         01:C317  A6 8D      			ldx	<__sp
         01:C319  CA         			dex
         01:C31A  CA         			dex
         01:C31B  95 08      			sta.l	<__stack, x
         01:C31D  94 09      			sty.h	<__stack, x
         01:C31F  86 8D      			stx	<__sp
 5647                        		__call		_check_BG
         01:C321  20 6D FF   			call	_check_BG
 5648                        	
 5649                        		.dbg	line,	"include\routines_LEVELS.c", 855; if(map_blk_flag == TILE_EMPTY)
 5650                        		__not.um	_map_blk_flag
         01:C324  AD A5 2B   			lda	_map_blk_flag
         01:C327  18         			clc
         01:C328  D0 01      			bne	!+
         01:C32A  38         			sec
         01:C32B             	!:
 5651                        		__bfalse	.LL196
         01:C32B  90 44      			bcc	.LL196
 5652                        	
 5653                        		.dbg	line,	"include\routines_LEVELS.c", 856; {
 5654                        	
 5655                        		.dbg	line,	"include\routines_LEVELS.c", 857; sgx_map_pxl_x += 2;
 5656                        		__add_st.wmiq	2, _sgx_map_pxl_x
         01:C32D  18         			clc
         01:C32E  AD 84 26   			lda.l	_sgx_map_pxl_x
         01:C331  69 02      			adc.l	#2
         01:C333  8D 84 26   			sta.l	_sgx_map_pxl_x
         01:C336  90 03      			bcc	!+
         01:C338  EE 85 26   			inc.h	_sgx_map_pxl_x
         01:C33B             	!:
 5657                        	
 5658                        		.dbg	line,	"include\routines_LEVELS.c", 858; }
 5659                        	
 5660                        		.dbg	line,	"include\routines_LEVELS.c", 859; }
 5661    01:C33B             	.LL196	.alias		.LL197
 5662                        	
 5663                        		.dbg	line,	"include\routines_LEVELS.c", 861; else
 5664                        		__bra		.LL197
         01:C33B  80 34      			bra	.LL197
 5665    01:C33D             	.LL195:
 5666                        	
 5667                        		.dbg	line,	"include\routines_LEVELS.c", 862; {
 5668                        	
 5669                        		.dbg	line,	"include\routines_LEVELS.c", 863; // CHECK COLLISION WITH LEFT WALL //
 5670                        	
 5671                        		.dbg	line,	"include\routines_LEVELS.c", 864; check_BG( 8 , 31 ); // 8-2
 5672                        		__ld.wi		8
         01:C33D  A9 08      			lda.l	#8
         01:C33F  C2         			cly
 5673                        		__pusharg.wr
         01:C340  A6 8D      			ldx	<__sp
         01:C342  CA         			dex
         01:C343  CA         			dex
         01:C344  95 08      			sta.l	<__stack, x
         01:C346  94 09      			sty.h	<__stack, x
         01:C348  86 8D      			stx	<__sp
 5674                        		__ld.wi		31
         01:C34A  A9 1F      			lda.l	#31
         01:C34C  C2         			cly
 5675                        		__pusharg.wr
         01:C34D  A6 8D      			ldx	<__sp
         01:C34F  CA         			dex
         01:C350  CA         			dex
         01:C351  95 08      			sta.l	<__stack, x
         01:C353  94 09      			sty.h	<__stack, x
         01:C355  86 8D      			stx	<__sp
 5676                        		__call		_check_BG
         01:C357  20 6D FF   			call	_check_BG
 5677                        	
 5678                        		.dbg	line,	"include\routines_LEVELS.c", 866; if(map_blk_flag == TILE_EMPTY)
 5679                        		__not.um	_map_blk_flag
         01:C35A  AD A5 2B   			lda	_map_blk_flag
         01:C35D  18         			clc
         01:C35E  D0 01      			bne	!+
         01:C360  38         			sec
         01:C361             	!:
 5680                        		__bfalse	.LL198
         01:C361  90 0E      			bcc	.LL198
 5681                        	
 5682                        		.dbg	line,	"include\routines_LEVELS.c", 867; {
 5683                        	
 5684                        		.dbg	line,	"include\routines_LEVELS.c", 868; sgx_map_pxl_x -= 2;
 5685                        		__sub_st.wmiq	2, _sgx_map_pxl_x
         01:C363  38         			sec
         01:C364  AD 84 26   			lda.l	_sgx_map_pxl_x
         01:C367  E9 02      			sbc.l	#2
         01:C369  8D 84 26   			sta.l	_sgx_map_pxl_x
         01:C36C  B0 03      			bcs	!+
         01:C36E  CE 85 26   			dec.h	_sgx_map_pxl_x
         01:C371             	!:
 5686                        	
 5687                        		.dbg	line,	"include\routines_LEVELS.c", 869; }
 5688                        	
 5689                        		.dbg	line,	"include\routines_LEVELS.c", 870; }
 5690    01:C371             	.LL198:
 5691    01:C371             	.LL197:
 5692                        	
 5693                        		.dbg	line,	"include\routines_LEVELS.c", 871; }
 5694    01:C371             	.LL194:
 5695                        	
 5696                        		.dbg	line,	"include\routines_LEVELS.c", 876; spr_set(player_id);
 5697                        		__ld.umq	_player_id
         01:C371  AD 14 23   			lda	_player_id
 5698                        		__call		_spr_set.1
         01:C374  20 DD E7   			call	_spr_set.1
 5699                        	
 5700                        		.dbg	line,	"include\routines_LEVELS.c", 879; // UPDATE PLAYER TILES //
 5701                        	
 5702                        		.dbg	line,	"include\routines_LEVELS.c", 880; if(player_counter_anim == 0)
 5703                        		__not.um	_player_counter_anim
         01:C377  AD 18 23   			lda	_player_counter_anim
         01:C37A  18         			clc
         01:C37B  D0 01      			bne	!+
         01:C37D  38         			sec
         01:C37E             	!:
 5704                        		__bfalse	.LL199
         01:C37E  90 1F      			bcc	.LL199
 5705                        	
 5706                        		.dbg	line,	"include\routines_LEVELS.c", 881; {
 5707                        	
 5708                        		.dbg	line,	"include\routines_LEVELS.c", 882; load_vram(PLAYER_VRAM_ADR, tiles_SPR_PLAYER , TILES_16);
 5709                        		__st.wmiq	6144, _di
         01:C380  64 F0      			stz.l	_di
         01:C382  A9 18      			lda.h	#6144
         01:C384  85 F1      			sta.h	_di
 5710                        		__farptr	_tiles_SPR_PLAYER, _bp_bank, _bp
         01:C386  A9 E0      			lda.l	#$6000 + ($1FFF & (_tiles_SPR_PLAYER))
         01:C388  85 EC      			sta.l	_bp
         01:C38A  A9 69      			lda.h	#$6000 + ($1FFF & (_tiles_SPR_PLAYER))
         01:C38C  85 ED      			sta.h	_bp
         01:C38E  A9 0E      			lda	#bank(_tiles_SPR_PLAYER)
         01:C390  85 02      			sta	_bp_bank
 5711                        		__st.wmiq	256, _ax
         01:C392  64 F8      			stz.l	_ax
         01:C394  A9 01      			lda.h	#256
         01:C396  85 F9      			sta.h	_ax
 5712                        		 _load_vram.3
         01:C398  82         			clx				; Offset to PCE VDC.
         01:C399  20 63 FF   			call	load_vram_x
 5713                        	
 5714                        		.dbg	line,	"include\routines_LEVELS.c", 883; }
 5715                        	
 5716                        		.dbg	line,	"include\routines_LEVELS.c", 886; else if(player_counter_anim == 2)
 5717                        		__bra		.LL200
         01:C39C  4C CB C4   			bra	.LL200
 5718    01:C39F             	.LL199:
 5719                        		__ld.umq	_player_counter_anim
         01:C39F  AD 18 23   			lda	_player_counter_anim
 5720                        		__equ_b.uiq	2
         01:C3A2  C9 02      			cmp	#2
         01:C3A4  F0 01      			beq	!+
         01:C3A6  18         			clc
         01:C3A7             	!:
 5721                        		__bfalse	.LL201
         01:C3A7  90 1F      			bcc	.LL201
 5722                        	
 5723                        		.dbg	line,	"include\routines_LEVELS.c", 887; {
 5724                        	
 5725                        		.dbg	line,	"include\routines_LEVELS.c", 888; load_vram(PLAYER_VRAM_ADR, tiles_SPR_PLAYER + OFFSET_PLAYER_WALK_1 , TILES_16);
 5726                        		__st.wmiq	6144, _di
         01:C3A9  64 F0      			stz.l	_di
         01:C3AB  A9 18      			lda.h	#6144
         01:C3AD  85 F1      			sta.h	_di
 5727                        		__farptr	_tiles_SPR_PLAYER + 512, _bp_bank, _bp
         01:C3AF  A9 E0      			lda.l	#$6000 + ($1FFF & (_tiles_SPR_PLAYER + 512))
         01:C3B1  85 EC      			sta.l	_bp
         01:C3B3  A9 6B      			lda.h	#$6000 + ($1FFF & (_tiles_SPR_PLAYER + 512))
         01:C3B5  85 ED      			sta.h	_bp
         01:C3B7  A9 0E      			lda	#bank(_tiles_SPR_PLAYER + 512)
         01:C3B9  85 02      			sta	_bp_bank
 5728                        		__st.wmiq	256, _ax
         01:C3BB  64 F8      			stz.l	_ax
         01:C3BD  A9 01      			lda.h	#256
         01:C3BF  85 F9      			sta.h	_ax
 5729                        		 _load_vram.3
         01:C3C1  82         			clx				; Offset to PCE VDC.
         01:C3C2  20 63 FF   			call	load_vram_x
 5730                        	
 5731                        		.dbg	line,	"include\routines_LEVELS.c", 889; }
 5732                        	
 5733                        		.dbg	line,	"include\routines_LEVELS.c", 892; else if(player_counter_anim == 5)
 5734                        		__bra		.LL202
         01:C3C5  4C CB C4   			bra	.LL202
 5735    01:C3C8             	.LL201:
 5736                        		__ld.umq	_player_counter_anim
         01:C3C8  AD 18 23   			lda	_player_counter_anim
 5737                        		__equ_b.uiq	5
         01:C3CB  C9 05      			cmp	#5
         01:C3CD  F0 01      			beq	!+
         01:C3CF  18         			clc
         01:C3D0             	!:
 5738                        		__bfalse	.LL203
         01:C3D0  90 1F      			bcc	.LL203
 5739                        	
 5740                        		.dbg	line,	"include\routines_LEVELS.c", 893; {
 5741                        	
 5742                        		.dbg	line,	"include\routines_LEVELS.c", 894; load_vram(PLAYER_VRAM_ADR, tiles_SPR_PLAYER + OFFSET_PLAYER_WALK_2 , TILES_16);
 5743                        		__st.wmiq	6144, _di
         01:C3D2  64 F0      			stz.l	_di
         01:C3D4  A9 18      			lda.h	#6144
         01:C3D6  85 F1      			sta.h	_di
 5744                        		__farptr	_tiles_SPR_PLAYER + 1024, _bp_bank, _bp
         01:C3D8  A9 E0      			lda.l	#$6000 + ($1FFF & (_tiles_SPR_PLAYER + 1024))
         01:C3DA  85 EC      			sta.l	_bp
         01:C3DC  A9 6D      			lda.h	#$6000 + ($1FFF & (_tiles_SPR_PLAYER + 1024))
         01:C3DE  85 ED      			sta.h	_bp
         01:C3E0  A9 0E      			lda	#bank(_tiles_SPR_PLAYER + 1024)
         01:C3E2  85 02      			sta	_bp_bank
 5745                        		__st.wmiq	256, _ax
         01:C3E4  64 F8      			stz.l	_ax
         01:C3E6  A9 01      			lda.h	#256
         01:C3E8  85 F9      			sta.h	_ax
 5746                        		 _load_vram.3
         01:C3EA  82         			clx				; Offset to PCE VDC.
         01:C3EB  20 63 FF   			call	load_vram_x
 5747                        	
 5748                        		.dbg	line,	"include\routines_LEVELS.c", 895; }
 5749                        	
 5750                        		.dbg	line,	"include\routines_LEVELS.c", 898; else if(player_counter_anim == 8)
 5751                        		__bra		.LL204
         01:C3EE  4C CB C4   			bra	.LL204
 5752    01:C3F1             	.LL203:
 5753                        		__ld.umq	_player_counter_anim
         01:C3F1  AD 18 23   			lda	_player_counter_anim
 5754                        		__equ_b.uiq	8
         01:C3F4  C9 08      			cmp	#8
         01:C3F6  F0 01      			beq	!+
         01:C3F8  18         			clc
         01:C3F9             	!:
 5755                        		__bfalse	.LL205
         01:C3F9  90 1F      			bcc	.LL205
 5756                        	
 5757                        		.dbg	line,	"include\routines_LEVELS.c", 899; {
 5758                        	
 5759                        		.dbg	line,	"include\routines_LEVELS.c", 900; load_vram(PLAYER_VRAM_ADR, tiles_SPR_PLAYER + OFFSET_PLAYER_WALK_3 , TILES_16);
 5760                        		__st.wmiq	6144, _di
         01:C3FB  64 F0      			stz.l	_di
         01:C3FD  A9 18      			lda.h	#6144
         01:C3FF  85 F1      			sta.h	_di
 5761                        		__farptr	_tiles_SPR_PLAYER + 1536, _bp_bank, _bp
         01:C401  A9 E0      			lda.l	#$6000 + ($1FFF & (_tiles_SPR_PLAYER + 1536))
         01:C403  85 EC      			sta.l	_bp
         01:C405  A9 6F      			lda.h	#$6000 + ($1FFF & (_tiles_SPR_PLAYER + 1536))
         01:C407  85 ED      			sta.h	_bp
         01:C409  A9 0E      			lda	#bank(_tiles_SPR_PLAYER + 1536)
         01:C40B  85 02      			sta	_bp_bank
 5762                        		__st.wmiq	256, _ax
         01:C40D  64 F8      			stz.l	_ax
         01:C40F  A9 01      			lda.h	#256
         01:C411  85 F9      			sta.h	_ax
 5763                        		 _load_vram.3
         01:C413  82         			clx				; Offset to PCE VDC.
         01:C414  20 63 FF   			call	load_vram_x
 5764                        	
 5765                        		.dbg	line,	"include\routines_LEVELS.c", 901; }
 5766                        	
 5767                        		.dbg	line,	"include\routines_LEVELS.c", 904; else if(player_counter_anim == 11)
 5768                        		__bra		.LL206
         01:C417  4C CB C4   			bra	.LL206
 5769    01:C41A             	.LL205:
 5770                        		__ld.umq	_player_counter_anim
         01:C41A  AD 18 23   			lda	_player_counter_anim
 5771                        		__equ_b.uiq	11
         01:C41D  C9 0B      			cmp	#11
         01:C41F  F0 01      			beq	!+
         01:C421  18         			clc
         01:C422             	!:
 5772                        		__bfalse	.LL207
         01:C422  90 1F      			bcc	.LL207
 5773                        	
 5774                        		.dbg	line,	"include\routines_LEVELS.c", 905; {
 5775                        	
 5776                        		.dbg	line,	"include\routines_LEVELS.c", 906; load_vram(PLAYER_VRAM_ADR, tiles_SPR_PLAYER , TILES_16);
 5777                        		__st.wmiq	6144, _di
         01:C424  64 F0      			stz.l	_di
         01:C426  A9 18      			lda.h	#6144
         01:C428  85 F1      			sta.h	_di
 5778                        		__farptr	_tiles_SPR_PLAYER, _bp_bank, _bp
         01:C42A  A9 E0      			lda.l	#$6000 + ($1FFF & (_tiles_SPR_PLAYER))
         01:C42C  85 EC      			sta.l	_bp
         01:C42E  A9 69      			lda.h	#$6000 + ($1FFF & (_tiles_SPR_PLAYER))
         01:C430  85 ED      			sta.h	_bp
         01:C432  A9 0E      			lda	#bank(_tiles_SPR_PLAYER)
         01:C434  85 02      			sta	_bp_bank
 5779                        		__st.wmiq	256, _ax
         01:C436  64 F8      			stz.l	_ax
         01:C438  A9 01      			lda.h	#256
         01:C43A  85 F9      			sta.h	_ax
 5780                        		 _load_vram.3
         01:C43C  82         			clx				; Offset to PCE VDC.
         01:C43D  20 63 FF   			call	load_vram_x
 5781                        	
 5782                        		.dbg	line,	"include\routines_LEVELS.c", 907; }
 5783                        	
 5784                        		.dbg	line,	"include\routines_LEVELS.c", 910; else if(player_counter_anim == 14)
 5785                        		__bra		.LL208
         01:C440  4C CB C4   			bra	.LL208
 5786    01:C443             	.LL207:
 5787                        		__ld.umq	_player_counter_anim
         01:C443  AD 18 23   			lda	_player_counter_anim
 5788                        		__equ_b.uiq	14
         01:C446  C9 0E      			cmp	#14
         01:C448  F0 01      			beq	!+
         01:C44A  18         			clc
         01:C44B             	!:
 5789                        		__bfalse	.LL209
         01:C44B  90 1E      			bcc	.LL209
 5790                        	
 5791                        		.dbg	line,	"include\routines_LEVELS.c", 911; {
 5792                        	
 5793                        		.dbg	line,	"include\routines_LEVELS.c", 912; load_vram(PLAYER_VRAM_ADR, tiles_SPR_PLAYER + OFFSET_PLAYER_WALK_4 , TILES_16);
 5794                        		__st.wmiq	6144, _di
         01:C44D  64 F0      			stz.l	_di
         01:C44F  A9 18      			lda.h	#6144
         01:C451  85 F1      			sta.h	_di
 5795                        		__farptr	_tiles_SPR_PLAYER + 2048, _bp_bank, _bp
         01:C453  A9 E0      			lda.l	#$6000 + ($1FFF & (_tiles_SPR_PLAYER + 2048))
         01:C455  85 EC      			sta.l	_bp
         01:C457  A9 71      			lda.h	#$6000 + ($1FFF & (_tiles_SPR_PLAYER + 2048))
         01:C459  85 ED      			sta.h	_bp
         01:C45B  A9 0E      			lda	#bank(_tiles_SPR_PLAYER + 2048)
         01:C45D  85 02      			sta	_bp_bank
 5796                        		__st.wmiq	256, _ax
         01:C45F  64 F8      			stz.l	_ax
         01:C461  A9 01      			lda.h	#256
         01:C463  85 F9      			sta.h	_ax
 5797                        		 _load_vram.3
         01:C465  82         			clx				; Offset to PCE VDC.
         01:C466  20 63 FF   			call	load_vram_x
 5798                        	
 5799                        		.dbg	line,	"include\routines_LEVELS.c", 913; }
 5800                        	
 5801                        		.dbg	line,	"include\routines_LEVELS.c", 916; else if(player_counter_anim == 17)
 5802                        		__bra		.LL210
         01:C469  80 60      			bra	.LL210
 5803    01:C46B             	.LL209:
 5804                        		__ld.umq	_player_counter_anim
         01:C46B  AD 18 23   			lda	_player_counter_anim
 5805                        		__equ_b.uiq	17
         01:C46E  C9 11      			cmp	#17
         01:C470  F0 01      			beq	!+
         01:C472  18         			clc
         01:C473             	!:
 5806                        		__bfalse	.LL211
         01:C473  90 1E      			bcc	.LL211
 5807                        	
 5808                        		.dbg	line,	"include\routines_LEVELS.c", 917; {
 5809                        	
 5810                        		.dbg	line,	"include\routines_LEVELS.c", 918; load_vram(PLAYER_VRAM_ADR, tiles_SPR_PLAYER + OFFSET_PLAYER_WALK_5 , TILES_16);
 5811                        		__st.wmiq	6144, _di
         01:C475  64 F0      			stz.l	_di
         01:C477  A9 18      			lda.h	#6144
         01:C479  85 F1      			sta.h	_di
 5812                        		__farptr	_tiles_SPR_PLAYER + 2560, _bp_bank, _bp
         01:C47B  A9 E0      			lda.l	#$6000 + ($1FFF & (_tiles_SPR_PLAYER + 2560))
         01:C47D  85 EC      			sta.l	_bp
         01:C47F  A9 73      			lda.h	#$6000 + ($1FFF & (_tiles_SPR_PLAYER + 2560))
         01:C481  85 ED      			sta.h	_bp
         01:C483  A9 0E      			lda	#bank(_tiles_SPR_PLAYER + 2560)
         01:C485  85 02      			sta	_bp_bank
 5813                        		__st.wmiq	256, _ax
         01:C487  64 F8      			stz.l	_ax
         01:C489  A9 01      			lda.h	#256
         01:C48B  85 F9      			sta.h	_ax
 5814                        		 _load_vram.3
         01:C48D  82         			clx				; Offset to PCE VDC.
         01:C48E  20 63 FF   			call	load_vram_x
 5815                        	
 5816                        		.dbg	line,	"include\routines_LEVELS.c", 919; }
 5817                        	
 5818                        		.dbg	line,	"include\routines_LEVELS.c", 922; else if(player_counter_anim == 20)
 5819                        		__bra		.LL212
         01:C491  80 38      			bra	.LL212
 5820    01:C493             	.LL211:
 5821                        		__ld.umq	_player_counter_anim
         01:C493  AD 18 23   			lda	_player_counter_anim
 5822                        		__equ_b.uiq	20
         01:C496  C9 14      			cmp	#20
         01:C498  F0 01      			beq	!+
         01:C49A  18         			clc
         01:C49B             	!:
 5823                        		__bfalse	.LL213
         01:C49B  90 1E      			bcc	.LL213
 5824                        	
 5825                        		.dbg	line,	"include\routines_LEVELS.c", 923; {
 5826                        	
 5827                        		.dbg	line,	"include\routines_LEVELS.c", 924; load_vram(PLAYER_VRAM_ADR, tiles_SPR_PLAYER + OFFSET_PLAYER_WALK_6 , TILES_16);
 5828                        		__st.wmiq	6144, _di
         01:C49D  64 F0      			stz.l	_di
         01:C49F  A9 18      			lda.h	#6144
         01:C4A1  85 F1      			sta.h	_di
 5829                        		__farptr	_tiles_SPR_PLAYER + 3072, _bp_bank, _bp
         01:C4A3  A9 E0      			lda.l	#$6000 + ($1FFF & (_tiles_SPR_PLAYER + 3072))
         01:C4A5  85 EC      			sta.l	_bp
         01:C4A7  A9 75      			lda.h	#$6000 + ($1FFF & (_tiles_SPR_PLAYER + 3072))
         01:C4A9  85 ED      			sta.h	_bp
         01:C4AB  A9 0E      			lda	#bank(_tiles_SPR_PLAYER + 3072)
         01:C4AD  85 02      			sta	_bp_bank
 5830                        		__st.wmiq	256, _ax
         01:C4AF  64 F8      			stz.l	_ax
         01:C4B1  A9 01      			lda.h	#256
         01:C4B3  85 F9      			sta.h	_ax
 5831                        		 _load_vram.3
         01:C4B5  82         			clx				; Offset to PCE VDC.
         01:C4B6  20 63 FF   			call	load_vram_x
 5832                        	
 5833                        		.dbg	line,	"include\routines_LEVELS.c", 925; }
 5834                        	
 5835                        		.dbg	line,	"include\routines_LEVELS.c", 928; else if(player_counter_anim == 22)
 5836                        		__bra		.LL214
         01:C4B9  80 10      			bra	.LL214
 5837    01:C4BB             	.LL213:
 5838                        		__ld.umq	_player_counter_anim
         01:C4BB  AD 18 23   			lda	_player_counter_anim
 5839                        		__equ_b.uiq	22
         01:C4BE  C9 16      			cmp	#22
         01:C4C0  F0 01      			beq	!+
         01:C4C2  18         			clc
         01:C4C3             	!:
 5840                        		__bfalse	.LL215
         01:C4C3  90 06      			bcc	.LL215
 5841                        	
 5842                        		.dbg	line,	"include\routines_LEVELS.c", 929; {
 5843                        	
 5844                        		.dbg	line,	"include\routines_LEVELS.c", 930; player_counter_anim = 0;
 5845                        		__st.umiq	0, _player_counter_anim
         01:C4C5  9C 18 23   			stz	_player_counter_anim
 5846                        	
 5847                        		.dbg	line,	"include\routines_LEVELS.c", 932; return;
 5848                        		__bra		.LL180
         01:C4C8  4C 58 D6   			bra	.LL180
 5849                        	
 5850                        		.dbg	line,	"include\routines_LEVELS.c", 933; }
 5851                        	
 5852                        		.dbg	line,	"include\routines_LEVELS.c", 936; player_counter_anim += 1;
 5853    01:C4CB             	.LL215:
 5854    01:C4CB             	.LL214:
 5855    01:C4CB             	.LL212:
 5856    01:C4CB             	.LL210:
 5857    01:C4CB             	.LL208:
 5858    01:C4CB             	.LL206:
 5859    01:C4CB             	.LL204:
 5860    01:C4CB             	.LL202:
 5861    01:C4CB             	.LL200:
 5862                        		__add_st.umiq	1, _player_counter_anim
         01:C4CB  EE 18 23   			inc	_player_counter_anim
 5863                        	
 5864                        		.dbg	line,	"include\routines_LEVELS.c", 938; }
 5865                        	
 5866                        		.dbg	line,	"include\routines_LEVELS.c", 941; else if(player_state == STATE_JUMP)
 5867                        		__bra		.LL216
         01:C4CE  4C 58 D6   			bra	.LL216
 5868    01:C4D1             	.LL186:
 5869                        		__ld.umq	_player_state
         01:C4D1  AD 15 23   			lda	_player_state
 5870                        		__equ_b.uiq	4
         01:C4D4  C9 04      			cmp	#4
         01:C4D6  F0 01      			beq	!+
         01:C4D8  18         			clc
         01:C4D9             	!:
 5871                        		__bfalse	.LL217
         01:C4D9  B0 03 4C D1			bcc	.LL217
         01:C4DD  C7          
 5872                        	
 5873                        		.dbg	line,	"include\routines_LEVELS.c", 942; {
 5874                        	
 5875                        		.dbg	line,	"include\routines_LEVELS.c", 943; unsigned char i;
 5876                        	
 5877                        		.dbg	line,	"include\routines_LEVELS.c", 944; i = 1;
 5878                        		__st.umiq	1, __update_PLAYER_end - 1  /* i */
         01:C4DE  A9 01      			lda.l	#1
         01:C4E0  8D 0C 23   			sta	__update_PLAYER_end - 1
 5879                        	
 5880                        		.dbg	line,	"include\routines_LEVELS.c", 947; if(player_counter_anim == 0)
 5881                        		__not.um	_player_counter_anim
         01:C4E3  AD 18 23   			lda	_player_counter_anim
         01:C4E6  18         			clc
         01:C4E7  D0 01      			bne	!+
         01:C4E9  38         			sec
         01:C4EA             	!:
 5882                        		__bfalse	.LL218
         01:C4EA  90 21      			bcc	.LL218
 5883                        	
 5884                        		.dbg	line,	"include\routines_LEVELS.c", 948; {
 5885                        	
 5886                        		.dbg	line,	"include\routines_LEVELS.c", 949; load_vram(PLAYER_VRAM_ADR, tiles_SPR_PLAYER + TILES_112 , TILES_16);
 5887                        		__st.wmiq	6144, _di
         01:C4EC  64 F0      			stz.l	_di
         01:C4EE  A9 18      			lda.h	#6144
         01:C4F0  85 F1      			sta.h	_di
 5888                        		__farptr	_tiles_SPR_PLAYER + 3584, _bp_bank, _bp
         01:C4F2  A9 E0      			lda.l	#$6000 + ($1FFF & (_tiles_SPR_PLAYER + 3584))
         01:C4F4  85 EC      			sta.l	_bp
         01:C4F6  A9 77      			lda.h	#$6000 + ($1FFF & (_tiles_SPR_PLAYER + 3584))
         01:C4F8  85 ED      			sta.h	_bp
         01:C4FA  A9 0E      			lda	#bank(_tiles_SPR_PLAYER + 3584)
         01:C4FC  85 02      			sta	_bp_bank
 5889                        		__st.wmiq	256, _ax
         01:C4FE  64 F8      			stz.l	_ax
         01:C500  A9 01      			lda.h	#256
         01:C502  85 F9      			sta.h	_ax
 5890                        		 _load_vram.3
         01:C504  82         			clx				; Offset to PCE VDC.
         01:C505  20 63 FF   			call	load_vram_x
 5891                        	
 5892                        		.dbg	line,	"include\routines_LEVELS.c", 951; player_counter_anim = 1;
 5893                        		__st.umiq	1, _player_counter_anim
         01:C508  A9 01      			lda.l	#1
         01:C50A  8D 18 23   			sta	_player_counter_anim
 5894                        	
 5895                        		.dbg	line,	"include\routines_LEVELS.c", 952; }
 5896                        	
 5897                        		.dbg	line,	"include\routines_LEVELS.c", 955; player_pos_y += TABLE_PLAYER_JUMP_V[player_index_jump];
 5898    01:C50D             	.LL218:
 5899                        		__ldx.umq	_player_index_jump
         01:C50D  AE 19 23   			ldx	_player_index_jump
 5900                        		__ld.bax	_TABLE_PLAYER_JUMP_V
         01:C510  BD A2 60   			lda	_TABLE_PLAYER_JUMP_V, x
         01:C513  C2         			cly
         01:C514  10 01      			bpl	!+
         01:C516  88         			dey
         01:C517             	!:
 5901                        		__add_st.wmq	_player_pos_y
         01:C517  18         			clc
         01:C518  6D CA 24   			adc.l	_player_pos_y
         01:C51B  8D CA 24   			sta.l	_player_pos_y
         01:C51E  98         			tya
         01:C51F  6D CB 24   			adc.h	_player_pos_y
         01:C522  8D CB 24   			sta.h	_player_pos_y
 5902                        	
 5903                        		.dbg	line,	"include\routines_LEVELS.c", 957; // CHECK COLLISION WITH CEILING //
 5904                        	
 5905                        		.dbg	line,	"include\routines_LEVELS.c", 958; check_BG( 15 , 8 );
 5906                        		__ld.wi		15
         01:C525  A9 0F      			lda.l	#15
         01:C527  C2         			cly
 5907                        		__pusharg.wr
         01:C528  A6 8D      			ldx	<__sp
         01:C52A  CA         			dex
         01:C52B  CA         			dex
         01:C52C  95 08      			sta.l	<__stack, x
         01:C52E  94 09      			sty.h	<__stack, x
         01:C530  86 8D      			stx	<__sp
 5908                        		__ld.wi		8
         01:C532  A9 08      			lda.l	#8
         01:C534  C2         			cly
 5909                        		__pusharg.wr
         01:C535  A6 8D      			ldx	<__sp
         01:C537  CA         			dex
         01:C538  CA         			dex
         01:C539  95 08      			sta.l	<__stack, x
         01:C53B  94 09      			sty.h	<__stack, x
         01:C53D  86 8D      			stx	<__sp
 5910                        		__call		_check_BG
         01:C53F  20 6D FF   			call	_check_BG
 5911                        	
 5912                        		.dbg	line,	"include\routines_LEVELS.c", 960; if(map_blk_flag == TILE_BG)
 5913                        		__ld.umq	_map_blk_flag
         01:C542  AD A5 2B   			lda	_map_blk_flag
 5914                        		__equ_b.uiq	1
         01:C545  C9 01      			cmp	#1
         01:C547  F0 01      			beq	!+
         01:C549  18         			clc
         01:C54A             	!:
 5915                        		__bfalse	.LL219
         01:C54A  90 5A      			bcc	.LL219
 5916                        	
 5917                        		.dbg	line,	"include\routines_LEVELS.c", 961; {
 5918                        	
 5919                        		.dbg	line,	"include\routines_LEVELS.c", 962; for(i=1 ; i<8 ; i++)
 5920                        		__st.umiq	1, __update_PLAYER_end - 1  /* i */
         01:C54C  A9 01      			lda.l	#1
         01:C54E  8D 0C 23   			sta	__update_PLAYER_end - 1
 5921    01:C551             	.LL220:
 5922                        		__ld.umq	__update_PLAYER_end - 1  /* i */
         01:C551  AD 0C 23   			lda	__update_PLAYER_end - 1
 5923                        		__ult_b.uiq	8
         01:C554  C9 08      			cmp	#8		; Subtract integer from A.
         01:C556  6A         			ror	a		; CC if A < integer.
         01:C557  49 80      			eor	#$80
         01:C559  2A         			rol	a
 5924                        		__btrue		.LL222
         01:C55A  B0 07      			bcs	.LL222
 5925                        		__bra		.LL223
         01:C55C  80 48      			bra	.LL223
 5926    01:C55E             	.LL221:
 5927                        		__inc.umq	__update_PLAYER_end - 1  /* i */
         01:C55E  EE 0C 23   			inc	__update_PLAYER_end - 1
 5928                        		__bra		.LL220
         01:C561  80 EE      			bra	.LL220
 5929    01:C563             	.LL222:
 5930                        	
 5931                        		.dbg	line,	"include\routines_LEVELS.c", 963; {
 5932                        	
 5933                        		.dbg	line,	"include\routines_LEVELS.c", 964; check_BG( 15 , 8 + i );
 5934                        		__ld.wi		15
         01:C563  A9 0F      			lda.l	#15
         01:C565  C2         			cly
 5935                        		__pusharg.wr
         01:C566  A6 8D      			ldx	<__sp
         01:C568  CA         			dex
         01:C569  CA         			dex
         01:C56A  95 08      			sta.l	<__stack, x
         01:C56C  94 09      			sty.h	<__stack, x
         01:C56E  86 8D      			stx	<__sp
 5936                        		__ld.wi		8
         01:C570  A9 08      			lda.l	#8
         01:C572  C2         			cly
 5937                        		__add.um	__update_PLAYER_end - 1  /* i */
         01:C573  18         			clc
         01:C574  6D 0C 23   			adc	__update_PLAYER_end - 1
         01:C577  90 01      			bcc	!+
         01:C579  C8         			iny
         01:C57A             	!:
 5938                        		__pusharg.wr
         01:C57A  A6 8D      			ldx	<__sp
         01:C57C  CA         			dex
         01:C57D  CA         			dex
         01:C57E  95 08      			sta.l	<__stack, x
         01:C580  94 09      			sty.h	<__stack, x
         01:C582  86 8D      			stx	<__sp
 5939                        		__call		_check_BG
         01:C584  20 6D FF   			call	_check_BG
 5940                        	
 5941                        		.dbg	line,	"include\routines_LEVELS.c", 965; {
 5942                        	
 5943                        		.dbg	line,	"include\routines_LEVELS.c", 966; if(map_blk_flag == TILE_EMPTY)
 5944                        		__not.um	_map_blk_flag
         01:C587  AD A5 2B   			lda	_map_blk_flag
         01:C58A  18         			clc
         01:C58B  D0 01      			bne	!+
         01:C58D  38         			sec
         01:C58E             	!:
 5945                        		__bfalse	.LL224
         01:C58E  90 CE      			bcc	.LL224
 5946                        	
 5947                        		.dbg	line,	"include\routines_LEVELS.c", 967; {
 5948                        	
 5949                        		.dbg	line,	"include\routines_LEVELS.c", 968; player_pos_y += i;
 5950                        		__ld.um		__update_PLAYER_end - 1  /* i */
         01:C590  AD 0C 23   			lda	__update_PLAYER_end - 1
         01:C593  C2         			cly
 5951                        		__add_st.wmq	_player_pos_y
         01:C594  18         			clc
         01:C595  6D CA 24   			adc.l	_player_pos_y
         01:C598  8D CA 24   			sta.l	_player_pos_y
         01:C59B  98         			tya
         01:C59C  6D CB 24   			adc.h	_player_pos_y
         01:C59F  8D CB 24   			sta.h	_player_pos_y
 5952                        	
 5953                        		.dbg	line,	"include\routines_LEVELS.c", 969; break;
 5954                        		__bra		.LL223
         01:C5A2  80 02      			bra	.LL223
 5955                        	
 5956                        		.dbg	line,	"include\routines_LEVELS.c", 970; }
 5957                        	
 5958                        		.dbg	line,	"include\routines_LEVELS.c", 971; }
 5959    01:C5A4             	.LL224	.alias		.LL221
 5960                        	
 5961                        		.dbg	line,	"include\routines_LEVELS.c", 972; }
 5962                        		__bra		.LL221
         01:C5A4  80 B8      			bra	.LL221
 5963    01:C5A6             	.LL223:
 5964                        	
 5965                        		.dbg	line,	"include\routines_LEVELS.c", 973; }
 5966                        	
 5967                        		.dbg	line,	"include\routines_LEVELS.c", 975; spr_set(player_id);
 5968    01:C5A6             	.LL219:
 5969                        		__ld.umq	_player_id
         01:C5A6  AD 14 23   			lda	_player_id
 5970                        		__call		_spr_set.1
         01:C5A9  20 DD E7   			call	_spr_set.1
 5971                        	
 5972                        		.dbg	line,	"include\routines_LEVELS.c", 976; spr_y(player_pos_y);
 5973                        		__ld.wm		_player_pos_y
         01:C5AC  AD CA 24   			lda.l	_player_pos_y
         01:C5AF  AC CB 24   			ldy.h	_player_pos_y
 5974                        		__call		_spr_y.1
         01:C5B2  20 19 E8   			call	_spr_y.1
 5975                        	
 5976                        		.dbg	line,	"include\routines_LEVELS.c", 980; if(player_index_jump < 34)
 5977                        		__ld.umq	_player_index_jump
         01:C5B5  AD 19 23   			lda	_player_index_jump
 5978                        		__ult_b.uiq	34
         01:C5B8  C9 22      			cmp	#34		; Subtract integer from A.
         01:C5BA  6A         			ror	a		; CC if A < integer.
         01:C5BB  49 80      			eor	#$80
         01:C5BD  2A         			rol	a
 5979                        		__bfalse	.LL225
         01:C5BE  90 03      			bcc	.LL225
 5980                        	
 5981                        		.dbg	line,	"include\routines_LEVELS.c", 981; {
 5982                        	
 5983                        		.dbg	line,	"include\routines_LEVELS.c", 983; player_index_jump += 1;
 5984                        		__add_st.umiq	1, _player_index_jump
         01:C5C0  EE 19 23   			inc	_player_index_jump
 5985                        	
 5986                        		.dbg	line,	"include\routines_LEVELS.c", 984; }
 5987                        	
 5988                        		.dbg	line,	"include\routines_LEVELS.c", 989; //--------------------------------------------------------------------------------------//
 5989                        	
 5990                        		.dbg	line,	"include\routines_LEVELS.c", 990; //                                   FLOOR COLLISION                                    //
 5991                        	
 5992                        		.dbg	line,	"include\routines_LEVELS.c", 991; //--------------------------------------------------------------------------------------//
 5993                        	
 5994                        		.dbg	line,	"include\routines_LEVELS.c", 993; if(player_index_jump > 14)
 5995    01:C5C3             	.LL225:
 5996                        		__ld.umq	_player_index_jump
         01:C5C3  AD 19 23   			lda	_player_index_jump
 5997                        		__ugt_b.uiq	14
         01:C5C6  18         			clc			; Subtract integer+1 from A.
         01:C5C7  E9 0E      			sbc	#14		; CS if A > integer.
 5998                        		__bfalse	.LL226
         01:C5C9  B0 03 4C 44			bcc	.LL226
         01:C5CD  C7          
 5999                        	
 6000                        		.dbg	line,	"include\routines_LEVELS.c", 994; {
 6001                        	
 6002                        		.dbg	line,	"include\routines_LEVELS.c", 995; // CHECK COLLISION WITH LEFT FLOOR //
 6003                        	
 6004                        		.dbg	line,	"include\routines_LEVELS.c", 996; check_BG( 10 , 32 );
 6005                        		__ld.wi		10
         01:C5CE  A9 0A      			lda.l	#10
         01:C5D0  C2         			cly
 6006                        		__pusharg.wr
         01:C5D1  A6 8D      			ldx	<__sp
         01:C5D3  CA         			dex
         01:C5D4  CA         			dex
         01:C5D5  95 08      			sta.l	<__stack, x
         01:C5D7  94 09      			sty.h	<__stack, x
         01:C5D9  86 8D      			stx	<__sp
 6007                        		__ld.wi		32
         01:C5DB  A9 20      			lda.l	#32
         01:C5DD  C2         			cly
 6008                        		__pusharg.wr
         01:C5DE  A6 8D      			ldx	<__sp
         01:C5E0  CA         			dex
         01:C5E1  CA         			dex
         01:C5E2  95 08      			sta.l	<__stack, x
         01:C5E4  94 09      			sty.h	<__stack, x
         01:C5E6  86 8D      			stx	<__sp
 6009                        		__call		_check_BG
         01:C5E8  20 6D FF   			call	_check_BG
 6010                        	
 6011                        		.dbg	line,	"include\routines_LEVELS.c", 998; // IF PLAYER TOUCHES THE GROUND TO THE LEFT //
 6012                        	
 6013                        		.dbg	line,	"include\routines_LEVELS.c", 999; if(map_blk_flag == TILE_BG)
 6014                        		__ld.umq	_map_blk_flag
         01:C5EB  AD A5 2B   			lda	_map_blk_flag
 6015                        		__equ_b.uiq	1
         01:C5EE  C9 01      			cmp	#1
         01:C5F0  F0 01      			beq	!+
         01:C5F2  18         			clc
         01:C5F3             	!:
 6016                        		__bfalse	.LL227
         01:C5F3  B0 03 4C 89			bcc	.LL227
         01:C5F7  C6          
 6017                        	
 6018                        		.dbg	line,	"include\routines_LEVELS.c", 1000; {
 6019                        	
 6020                        		.dbg	line,	"include\routines_LEVELS.c", 1001; // CALCULATE HOW MANY PIXELS THE PLAYER MOVED INTO THE GROUND //
 6021                        	
 6022                        		.dbg	line,	"include\routines_LEVELS.c", 1002; for(i=1; i<11 ; i++ )
 6023                        		__st.umiq	1, __update_PLAYER_end - 1  /* i */
         01:C5F8  A9 01      			lda.l	#1
         01:C5FA  8D 0C 23   			sta	__update_PLAYER_end - 1
 6024    01:C5FD             	.LL228:
 6025                        		__ld.umq	__update_PLAYER_end - 1  /* i */
         01:C5FD  AD 0C 23   			lda	__update_PLAYER_end - 1
 6026                        		__ult_b.uiq	11
         01:C600  C9 0B      			cmp	#11		; Subtract integer from A.
         01:C602  6A         			ror	a		; CC if A < integer.
         01:C603  49 80      			eor	#$80
         01:C605  2A         			rol	a
 6027                        		__btrue		.LL230
         01:C606  B0 07      			bcs	.LL230
 6028                        		__bra		.LL231
         01:C608  80 71      			bra	.LL231
 6029    01:C60A             	.LL229:
 6030                        		__inc.umq	__update_PLAYER_end - 1  /* i */
         01:C60A  EE 0C 23   			inc	__update_PLAYER_end - 1
 6031                        		__bra		.LL228
         01:C60D  80 EE      			bra	.LL228
 6032    01:C60F             	.LL230:
 6033                        	
 6034                        		.dbg	line,	"include\routines_LEVELS.c", 1003; {
 6035                        	
 6036                        		.dbg	line,	"include\routines_LEVELS.c", 1004; check_TILE_DEPTH( 10 , i);
 6037                        		__ld.wi		10
         01:C60F  A9 0A      			lda.l	#10
         01:C611  C2         			cly
 6038                        		__pusharg.wr
         01:C612  A6 8D      			ldx	<__sp
         01:C614  CA         			dex
         01:C615  CA         			dex
         01:C616  95 08      			sta.l	<__stack, x
         01:C618  94 09      			sty.h	<__stack, x
         01:C61A  86 8D      			stx	<__sp
 6039                        		__ld.um		__update_PLAYER_end - 1  /* i */
         01:C61C  AD 0C 23   			lda	__update_PLAYER_end - 1
         01:C61F  C2         			cly
 6040                        		__pusharg.wr
         01:C620  A6 8D      			ldx	<__sp
         01:C622  CA         			dex
         01:C623  CA         			dex
         01:C624  95 08      			sta.l	<__stack, x
         01:C626  94 09      			sty.h	<__stack, x
         01:C628  86 8D      			stx	<__sp
 6041                        		__call		_check_TILE_DEPTH
         01:C62A  20 4F FF   			call	_check_TILE_DEPTH
 6042                        	
 6043                        		.dbg	line,	"include\routines_LEVELS.c", 1006; if(map_blk_flag == TILE_EMPTY)
 6044                        		__not.um	_map_blk_flag
         01:C62D  AD A5 2B   			lda	_map_blk_flag
         01:C630  18         			clc
         01:C631  D0 01      			bne	!+
         01:C633  38         			sec
         01:C634             	!:
 6045                        		__bfalse	.LL232
         01:C634  90 D4      			bcc	.LL232
 6046                        	
 6047                        		.dbg	line,	"include\routines_LEVELS.c", 1007; {
 6048                        	
 6049                        		.dbg	line,	"include\routines_LEVELS.c", 1008; load_vram(PLAYER_VRAM_ADR, tiles_SPR_PLAYER , TILES_16);
 6050                        		__st.wmiq	6144, _di
         01:C636  64 F0      			stz.l	_di
         01:C638  A9 18      			lda.h	#6144
         01:C63A  85 F1      			sta.h	_di
 6051                        		__farptr	_tiles_SPR_PLAYER, _bp_bank, _bp
         01:C63C  A9 E0      			lda.l	#$6000 + ($1FFF & (_tiles_SPR_PLAYER))
         01:C63E  85 EC      			sta.l	_bp
         01:C640  A9 69      			lda.h	#$6000 + ($1FFF & (_tiles_SPR_PLAYER))
         01:C642  85 ED      			sta.h	_bp
         01:C644  A9 0E      			lda	#bank(_tiles_SPR_PLAYER)
         01:C646  85 02      			sta	_bp_bank
 6052                        		__st.wmiq	256, _ax
         01:C648  64 F8      			stz.l	_ax
         01:C64A  A9 01      			lda.h	#256
         01:C64C  85 F9      			sta.h	_ax
 6053                        		 _load_vram.3
         01:C64E  82         			clx				; Offset to PCE VDC.
         01:C64F  20 63 FF   			call	load_vram_x
 6054                        	
 6055                        		.dbg	line,	"include\routines_LEVELS.c", 1010; player_pos_y -= (i - 1);
 6056                        		__ld.um		__update_PLAYER_end - 1  /* i */
         01:C652  AD 0C 23   			lda	__update_PLAYER_end - 1
         01:C655  C2         			cly
 6057                        		__sub.wi	1
         01:C656  38         			sec
         01:C657  E9 01      			sbc.l	#1
         01:C659  B0 01      			bcs	!+
         01:C65B  88         			dey
         01:C65C             	!:
 6058                        		__isub_st.wmq	_player_pos_y
         01:C65C  38         			sec
         01:C65D  49 FF      			eor	#$FF
         01:C65F  6D CA 24   			adc.l	_player_pos_y
         01:C662  8D CA 24   			sta.l	_player_pos_y
         01:C665  98         			tya
         01:C666  49 FF      			eor	#$FF
         01:C668  6D CB 24   			adc.h	_player_pos_y
         01:C66B  8D CB 24   			sta.h	_player_pos_y
 6059                        	
 6060                        		.dbg	line,	"include\routines_LEVELS.c", 1011; spr_y(player_pos_y);
 6061                        		__ld.wm		_player_pos_y
         01:C66E  AD CA 24   			lda.l	_player_pos_y
         01:C671  AC CB 24   			ldy.h	_player_pos_y
 6062                        		__call		_spr_y.1
         01:C674  20 19 E8   			call	_spr_y.1
 6063                        	
 6064                        		.dbg	line,	"include\routines_LEVELS.c", 1012; break;
 6065                        		__bra		.LL231
         01:C677  80 02      			bra	.LL231
 6066                        	
 6067                        		.dbg	line,	"include\routines_LEVELS.c", 1013; }
 6068                        	
 6069                        		.dbg	line,	"include\routines_LEVELS.c", 1015; }
 6070    01:C679             	.LL232	.alias		.LL229
 6071                        		__bra		.LL229
         01:C679  80 8F      			bra	.LL229
 6072    01:C67B             	.LL231:
 6073                        	
 6074                        		.dbg	line,	"include\routines_LEVELS.c", 1017; player_counter_anim = 1;
 6075                        		__st.umiq	1, _player_counter_anim
         01:C67B  A9 01      			lda.l	#1
         01:C67D  8D 18 23   			sta	_player_counter_anim
 6076                        	
 6077                        		.dbg	line,	"include\routines_LEVELS.c", 1018; player_index_jump = 0;
 6078                        		__st.umiq	0, _player_index_jump
         01:C680  9C 19 23   			stz	_player_index_jump
 6079                        	
 6080                        		.dbg	line,	"include\routines_LEVELS.c", 1019; player_state = STATE_IDLE;
 6081                        		__st.umiq	0, _player_state
         01:C683  9C 15 23   			stz	_player_state
 6082                        	
 6083                        		.dbg	line,	"include\routines_LEVELS.c", 1020; return;
 6084                        		__bra		.LL180
         01:C686  4C 58 D6   			bra	.LL180
 6085                        	
 6086                        		.dbg	line,	"include\routines_LEVELS.c", 1021; }
 6087                        	
 6088                        		.dbg	line,	"include\routines_LEVELS.c", 1023; // IF PLAYER TOUCHES THE GROUND TO THE RIGHT //
 6089                        	
 6090                        		.dbg	line,	"include\routines_LEVELS.c", 1024; else
 6091    01:C689             	.LL227:
 6092                        	
 6093                        		.dbg	line,	"include\routines_LEVELS.c", 1025; {
 6094                        	
 6095                        		.dbg	line,	"include\routines_LEVELS.c", 1026; // CHECK COLLISION WITH RIGHT FLOOR //
 6096                        	
 6097                        		.dbg	line,	"include\routines_LEVELS.c", 1027; check_BG( 22 , 32 );
 6098                        		__ld.wi		22
         01:C689  A9 16      			lda.l	#22
         01:C68B  C2         			cly
 6099                        		__pusharg.wr
         01:C68C  A6 8D      			ldx	<__sp
         01:C68E  CA         			dex
         01:C68F  CA         			dex
         01:C690  95 08      			sta.l	<__stack, x
         01:C692  94 09      			sty.h	<__stack, x
         01:C694  86 8D      			stx	<__sp
 6100                        		__ld.wi		32
         01:C696  A9 20      			lda.l	#32
         01:C698  C2         			cly
 6101                        		__pusharg.wr
         01:C699  A6 8D      			ldx	<__sp
         01:C69B  CA         			dex
         01:C69C  CA         			dex
         01:C69D  95 08      			sta.l	<__stack, x
         01:C69F  94 09      			sty.h	<__stack, x
         01:C6A1  86 8D      			stx	<__sp
 6102                        		__call		_check_BG
         01:C6A3  20 6D FF   			call	_check_BG
 6103                        	
 6104                        		.dbg	line,	"include\routines_LEVELS.c", 1029; if(map_blk_flag == TILE_BG)
 6105                        		__ld.umq	_map_blk_flag
         01:C6A6  AD A5 2B   			lda	_map_blk_flag
 6106                        		__equ_b.uiq	1
         01:C6A9  C9 01      			cmp	#1
         01:C6AB  F0 01      			beq	!+
         01:C6AD  18         			clc
         01:C6AE             	!:
 6107                        		__bfalse	.LL234
         01:C6AE  B0 03 4C 44			bcc	.LL234
         01:C6B2  C7          
 6108                        	
 6109                        		.dbg	line,	"include\routines_LEVELS.c", 1030; {
 6110                        	
 6111                        		.dbg	line,	"include\routines_LEVELS.c", 1031; // CALCULATE HOW MANY PIXELS THE PLAYER MOVED INTO THE GROUND //
 6112                        	
 6113                        		.dbg	line,	"include\routines_LEVELS.c", 1032; for(i=1; i<11 ; i++ )
 6114                        		__st.umiq	1, __update_PLAYER_end - 1  /* i */
         01:C6B3  A9 01      			lda.l	#1
         01:C6B5  8D 0C 23   			sta	__update_PLAYER_end - 1
 6115    01:C6B8             	.LL235:
 6116                        		__ld.umq	__update_PLAYER_end - 1  /* i */
         01:C6B8  AD 0C 23   			lda	__update_PLAYER_end - 1
 6117                        		__ult_b.uiq	11
         01:C6BB  C9 0B      			cmp	#11		; Subtract integer from A.
         01:C6BD  6A         			ror	a		; CC if A < integer.
         01:C6BE  49 80      			eor	#$80
         01:C6C0  2A         			rol	a
 6118                        		__btrue		.LL237
         01:C6C1  B0 07      			bcs	.LL237
 6119                        		__bra		.LL238
         01:C6C3  80 71      			bra	.LL238
 6120    01:C6C5             	.LL236:
 6121                        		__inc.umq	__update_PLAYER_end - 1  /* i */
         01:C6C5  EE 0C 23   			inc	__update_PLAYER_end - 1
 6122                        		__bra		.LL235
         01:C6C8  80 EE      			bra	.LL235
 6123    01:C6CA             	.LL237:
 6124                        	
 6125                        		.dbg	line,	"include\routines_LEVELS.c", 1033; {
 6126                        	
 6127                        		.dbg	line,	"include\routines_LEVELS.c", 1034; check_TILE_DEPTH( 22 , i);
 6128                        		__ld.wi		22
         01:C6CA  A9 16      			lda.l	#22
         01:C6CC  C2         			cly
 6129                        		__pusharg.wr
         01:C6CD  A6 8D      			ldx	<__sp
         01:C6CF  CA         			dex
         01:C6D0  CA         			dex
         01:C6D1  95 08      			sta.l	<__stack, x
         01:C6D3  94 09      			sty.h	<__stack, x
         01:C6D5  86 8D      			stx	<__sp
 6130                        		__ld.um		__update_PLAYER_end - 1  /* i */
         01:C6D7  AD 0C 23   			lda	__update_PLAYER_end - 1
         01:C6DA  C2         			cly
 6131                        		__pusharg.wr
         01:C6DB  A6 8D      			ldx	<__sp
         01:C6DD  CA         			dex
         01:C6DE  CA         			dex
         01:C6DF  95 08      			sta.l	<__stack, x
         01:C6E1  94 09      			sty.h	<__stack, x
         01:C6E3  86 8D      			stx	<__sp
 6132                        		__call		_check_TILE_DEPTH
         01:C6E5  20 4F FF   			call	_check_TILE_DEPTH
 6133                        	
 6134                        		.dbg	line,	"include\routines_LEVELS.c", 1036; if(map_blk_flag == TILE_EMPTY)
 6135                        		__not.um	_map_blk_flag
         01:C6E8  AD A5 2B   			lda	_map_blk_flag
         01:C6EB  18         			clc
         01:C6EC  D0 01      			bne	!+
         01:C6EE  38         			sec
         01:C6EF             	!:
 6136                        		__bfalse	.LL239
         01:C6EF  90 D4      			bcc	.LL239
 6137                        	
 6138                        		.dbg	line,	"include\routines_LEVELS.c", 1037; {
 6139                        	
 6140                        		.dbg	line,	"include\routines_LEVELS.c", 1038; load_vram(PLAYER_VRAM_ADR, tiles_SPR_PLAYER , TILES_16);
 6141                        		__st.wmiq	6144, _di
         01:C6F1  64 F0      			stz.l	_di
         01:C6F3  A9 18      			lda.h	#6144
         01:C6F5  85 F1      			sta.h	_di
 6142                        		__farptr	_tiles_SPR_PLAYER, _bp_bank, _bp
         01:C6F7  A9 E0      			lda.l	#$6000 + ($1FFF & (_tiles_SPR_PLAYER))
         01:C6F9  85 EC      			sta.l	_bp
         01:C6FB  A9 69      			lda.h	#$6000 + ($1FFF & (_tiles_SPR_PLAYER))
         01:C6FD  85 ED      			sta.h	_bp
         01:C6FF  A9 0E      			lda	#bank(_tiles_SPR_PLAYER)
         01:C701  85 02      			sta	_bp_bank
 6143                        		__st.wmiq	256, _ax
         01:C703  64 F8      			stz.l	_ax
         01:C705  A9 01      			lda.h	#256
         01:C707  85 F9      			sta.h	_ax
 6144                        		 _load_vram.3
         01:C709  82         			clx				; Offset to PCE VDC.
         01:C70A  20 63 FF   			call	load_vram_x
 6145                        	
 6146                        		.dbg	line,	"include\routines_LEVELS.c", 1040; player_pos_y -= (i - 1);
 6147                        		__ld.um		__update_PLAYER_end - 1  /* i */
         01:C70D  AD 0C 23   			lda	__update_PLAYER_end - 1
         01:C710  C2         			cly
 6148                        		__sub.wi	1
         01:C711  38         			sec
         01:C712  E9 01      			sbc.l	#1
         01:C714  B0 01      			bcs	!+
         01:C716  88         			dey
         01:C717             	!:
 6149                        		__isub_st.wmq	_player_pos_y
         01:C717  38         			sec
         01:C718  49 FF      			eor	#$FF
         01:C71A  6D CA 24   			adc.l	_player_pos_y
         01:C71D  8D CA 24   			sta.l	_player_pos_y
         01:C720  98         			tya
         01:C721  49 FF      			eor	#$FF
         01:C723  6D CB 24   			adc.h	_player_pos_y
         01:C726  8D CB 24   			sta.h	_player_pos_y
 6150                        	
 6151                        		.dbg	line,	"include\routines_LEVELS.c", 1041; spr_y(player_pos_y);
 6152                        		__ld.wm		_player_pos_y
         01:C729  AD CA 24   			lda.l	_player_pos_y
         01:C72C  AC CB 24   			ldy.h	_player_pos_y
 6153                        		__call		_spr_y.1
         01:C72F  20 19 E8   			call	_spr_y.1
 6154                        	
 6155                        		.dbg	line,	"include\routines_LEVELS.c", 1042; break;
 6156                        		__bra		.LL238
         01:C732  80 02      			bra	.LL238
 6157                        	
 6158                        		.dbg	line,	"include\routines_LEVELS.c", 1043; }
 6159                        	
 6160                        		.dbg	line,	"include\routines_LEVELS.c", 1045; }
 6161    01:C734             	.LL239	.alias		.LL236
 6162                        		__bra		.LL236
         01:C734  80 8F      			bra	.LL236
 6163    01:C736             	.LL238:
 6164                        	
 6165                        		.dbg	line,	"include\routines_LEVELS.c", 1047; player_counter_anim = 1;
 6166                        		__st.umiq	1, _player_counter_anim
         01:C736  A9 01      			lda.l	#1
         01:C738  8D 18 23   			sta	_player_counter_anim
 6167                        	
 6168                        		.dbg	line,	"include\routines_LEVELS.c", 1048; player_index_jump = 0;
 6169                        		__st.umiq	0, _player_index_jump
         01:C73B  9C 19 23   			stz	_player_index_jump
 6170                        	
 6171                        		.dbg	line,	"include\routines_LEVELS.c", 1049; player_state = STATE_IDLE;
 6172                        		__st.umiq	0, _player_state
         01:C73E  9C 15 23   			stz	_player_state
 6173                        	
 6174                        		.dbg	line,	"include\routines_LEVELS.c", 1050; return;
 6175                        		__bra		.LL180
         01:C741  4C 58 D6   			bra	.LL180
 6176                        	
 6177                        		.dbg	line,	"include\routines_LEVELS.c", 1051; }
 6178                        	
 6179                        		.dbg	line,	"include\routines_LEVELS.c", 1052; }
 6180    01:C744             	.LL234:
 6181    01:C744             	.LL233:
 6182                        	
 6183                        		.dbg	line,	"include\routines_LEVELS.c", 1053; }
 6184                        	
 6185                        		.dbg	line,	"include\routines_LEVELS.c", 1057; // CHECK COLLISION WITH LADDERS //
 6186                        	
 6187                        		.dbg	line,	"include\routines_LEVELS.c", 1058; check_BG( 16 , 16 );
 6188    01:C744             	.LL226:
 6189                        		__ld.wi		16
         01:C744  A9 10      			lda.l	#16
         01:C746  C2         			cly
 6190                        		__pusharg.wr
         01:C747  A6 8D      			ldx	<__sp
         01:C749  CA         			dex
         01:C74A  CA         			dex
         01:C74B  95 08      			sta.l	<__stack, x
         01:C74D  94 09      			sty.h	<__stack, x
         01:C74F  86 8D      			stx	<__sp
 6191                        		__ld.wi		16
         01:C751  A9 10      			lda.l	#16
         01:C753  C2         			cly
 6192                        		__pusharg.wr
         01:C754  A6 8D      			ldx	<__sp
         01:C756  CA         			dex
         01:C757  CA         			dex
         01:C758  95 08      			sta.l	<__stack, x
         01:C75A  94 09      			sty.h	<__stack, x
         01:C75C  86 8D      			stx	<__sp
 6193                        		__call		_check_BG
         01:C75E  20 6D FF   			call	_check_BG
 6194                        	
 6195                        		.dbg	line,	"include\routines_LEVELS.c", 1060; // IF PLAYER HITS THE LADDER //
 6196                        	
 6197                        		.dbg	line,	"include\routines_LEVELS.c", 1061; if(map_blk_flag == TILE_LADDER)
 6198                        		__ld.umq	_map_blk_flag
         01:C761  AD A5 2B   			lda	_map_blk_flag
 6199                        		__equ_b.uiq	2
         01:C764  C9 02      			cmp	#2
         01:C766  F0 01      			beq	!+
         01:C768  18         			clc
         01:C769             	!:
 6200                        		__bfalse	.LL240
         01:C769  B0 03 4C 58			bcc	.LL240
         01:C76D  D6          
 6201                        	
 6202                        		.dbg	line,	"include\routines_LEVELS.c", 1062; {
 6203                        	
 6204                        		.dbg	line,	"include\routines_LEVELS.c", 1063; // CAMERA GOES 8 PX BACKWARD //
 6205                        	
 6206                        		.dbg	line,	"include\routines_LEVELS.c", 1064; sgx_map_pxl_x = ( (sgx_map_pxl_x >> 3) << 3 );
 6207                        		__ld.wm		_sgx_map_pxl_x
         01:C76E  AD 84 26   			lda.l	_sgx_map_pxl_x
         01:C771  AC 85 26   			ldy.h	_sgx_map_pxl_x
 6208                        		__lsr.wi	3
         01:C774  84 00      			sty	__temp
         01:C776  20 3A E2   			jsr	lsrw3
 6209                        		__asl.wi	3
         01:C779  84 00      			sty	__temp
         01:C77B  20 D7 E1   			jsr	aslw3
 6210                        		__st.wmq	_sgx_map_pxl_x
         01:C77E  8D 84 26   			sta.l	_sgx_map_pxl_x
         01:C781  8C 85 26   			sty.h	_sgx_map_pxl_x
 6211                        	
 6212                        		.dbg	line,	"include\routines_LEVELS.c", 1066; // SO WE UPDATE THE MAP //
 6213                        	
 6214                        		.dbg	line,	"include\routines_LEVELS.c", 1067; sgx_scroll_map();
 6215                        		__call		_sgx_scroll_map
         01:C784  20 81 FF   			call	_sgx_scroll_map
 6216                        	
 6217                        		.dbg	line,	"include\routines_LEVELS.c", 1069; // CHECK IF THE PLAYER STANDS RIGHT TO THE LADDER //
 6218                        	
 6219                        		.dbg	line,	"include\routines_LEVELS.c", 1070; check_BG( 31 , 16 );
 6220                        		__ld.wi		31
         01:C787  A9 1F      			lda.l	#31
         01:C789  C2         			cly
 6221                        		__pusharg.wr
         01:C78A  A6 8D      			ldx	<__sp
         01:C78C  CA         			dex
         01:C78D  CA         			dex
         01:C78E  95 08      			sta.l	<__stack, x
         01:C790  94 09      			sty.h	<__stack, x
         01:C792  86 8D      			stx	<__sp
 6222                        		__ld.wi		16
         01:C794  A9 10      			lda.l	#16
         01:C796  C2         			cly
 6223                        		__pusharg.wr
         01:C797  A6 8D      			ldx	<__sp
         01:C799  CA         			dex
         01:C79A  CA         			dex
         01:C79B  95 08      			sta.l	<__stack, x
         01:C79D  94 09      			sty.h	<__stack, x
         01:C79F  86 8D      			stx	<__sp
 6224                        		__call		_check_BG
         01:C7A1  20 6D FF   			call	_check_BG
 6225                        	
 6226                        		.dbg	line,	"include\routines_LEVELS.c", 1072; if(map_blk_flag == TILE_LADDER)
 6227                        		__ld.umq	_map_blk_flag
         01:C7A4  AD A5 2B   			lda	_map_blk_flag
 6228                        		__equ_b.uiq	2
         01:C7A7  C9 02      			cmp	#2
         01:C7A9  F0 01      			beq	!+
         01:C7AB  18         			clc
         01:C7AC             	!:
 6229                        		__bfalse	.LL241
         01:C7AC  90 0E      			bcc	.LL241
 6230                        	
 6231                        		.dbg	line,	"include\routines_LEVELS.c", 1073; {
 6232                        	
 6233                        		.dbg	line,	"include\routines_LEVELS.c", 1074; sgx_map_pxl_x += 8;
 6234                        		__add_st.wmiq	8, _sgx_map_pxl_x
         01:C7AE  18         			clc
         01:C7AF  AD 84 26   			lda.l	_sgx_map_pxl_x
         01:C7B2  69 08      			adc.l	#8
         01:C7B4  8D 84 26   			sta.l	_sgx_map_pxl_x
         01:C7B7  90 03      			bcc	!+
         01:C7B9  EE 85 26   			inc.h	_sgx_map_pxl_x
         01:C7BC             	!:
 6235                        	
 6236                        		.dbg	line,	"include\routines_LEVELS.c", 1075; }
 6237                        	
 6238                        		.dbg	line,	"include\routines_LEVELS.c", 1077; player_counter_anim = 1;
 6239    01:C7BC             	.LL241:
 6240                        		__st.umiq	1, _player_counter_anim
         01:C7BC  A9 01      			lda.l	#1
         01:C7BE  8D 18 23   			sta	_player_counter_anim
 6241                        	
 6242                        		.dbg	line,	"include\routines_LEVELS.c", 1078; player_index_jump = 0;
 6243                        		__st.umiq	0, _player_index_jump
         01:C7C1  9C 19 23   			stz	_player_index_jump
 6244                        	
 6245                        		.dbg	line,	"include\routines_LEVELS.c", 1079; jump_ladder = TRUE;
 6246                        		__st.umiq	1, _jump_ladder
         01:C7C4  A9 01      			lda.l	#1
         01:C7C6  8D 1B 23   			sta	_jump_ladder
 6247                        	
 6248                        		.dbg	line,	"include\routines_LEVELS.c", 1080; player_state = STATE_HANG;
 6249                        		__st.umiq	10, _player_state
         01:C7C9  A9 0A      			lda.l	#10
         01:C7CB  8D 15 23   			sta	_player_state
 6250                        	
 6251                        		.dbg	line,	"include\routines_LEVELS.c", 1081; }
 6252                        	
 6253                        		.dbg	line,	"include\routines_LEVELS.c", 1082; }
 6254    01:C7CE             	.LL240	.alias		.LL242
 6255                        	
 6256                        		.dbg	line,	"include\routines_LEVELS.c", 1085; else if(player_state == STATE_JUMP_RIGHT)
 6257                        		__bra		.LL242
         01:C7CE  4C 58 D6   			bra	.LL242
 6258    01:C7D1             	.LL217:
 6259                        		__ld.umq	_player_state
         01:C7D1  AD 15 23   			lda	_player_state
 6260                        		__equ_b.uiq	5
         01:C7D4  C9 05      			cmp	#5
         01:C7D6  F0 01      			beq	!+
         01:C7D8  18         			clc
         01:C7D9             	!:
 6261                        		__bfalse	.LL243
         01:C7D9  B0 03 4C FC			bcc	.LL243
         01:C7DD  CB          
 6262                        	
 6263                        		.dbg	line,	"include\routines_LEVELS.c", 1086; {
 6264                        	
 6265                        		.dbg	line,	"include\routines_LEVELS.c", 1087; unsigned char i, camera_y_move;
 6266                        	
 6267                        		.dbg	line,	"include\routines_LEVELS.c", 1088; i = 1;
 6268                        		__st.umiq	1, __update_PLAYER_end - 2  /* i */
         01:C7DE  A9 01      			lda.l	#1
         01:C7E0  8D 0B 23   			sta	__update_PLAYER_end - 2
 6269                        	
 6270                        		.dbg	line,	"include\routines_LEVELS.c", 1091; // UPDATE PLAYER TILES //
 6271                        	
 6272                        		.dbg	line,	"include\routines_LEVELS.c", 1092; if(player_counter_anim == 0)
 6273                        		__not.um	_player_counter_anim
         01:C7E3  AD 18 23   			lda	_player_counter_anim
         01:C7E6  18         			clc
         01:C7E7  D0 01      			bne	!+
         01:C7E9  38         			sec
         01:C7EA             	!:
 6274                        		__bfalse	.LL244
         01:C7EA  90 21      			bcc	.LL244
 6275                        	
 6276                        		.dbg	line,	"include\routines_LEVELS.c", 1093; {
 6277                        	
 6278                        		.dbg	line,	"include\routines_LEVELS.c", 1094; load_vram(PLAYER_VRAM_ADR, tiles_SPR_PLAYER + TILES_112 , TILES_16);
 6279                        		__st.wmiq	6144, _di
         01:C7EC  64 F0      			stz.l	_di
         01:C7EE  A9 18      			lda.h	#6144
         01:C7F0  85 F1      			sta.h	_di
 6280                        		__farptr	_tiles_SPR_PLAYER + 3584, _bp_bank, _bp
         01:C7F2  A9 E0      			lda.l	#$6000 + ($1FFF & (_tiles_SPR_PLAYER + 3584))
         01:C7F4  85 EC      			sta.l	_bp
         01:C7F6  A9 77      			lda.h	#$6000 + ($1FFF & (_tiles_SPR_PLAYER + 3584))
         01:C7F8  85 ED      			sta.h	_bp
         01:C7FA  A9 0E      			lda	#bank(_tiles_SPR_PLAYER + 3584)
         01:C7FC  85 02      			sta	_bp_bank
 6281                        		__st.wmiq	256, _ax
         01:C7FE  64 F8      			stz.l	_ax
         01:C800  A9 01      			lda.h	#256
         01:C802  85 F9      			sta.h	_ax
 6282                        		 _load_vram.3
         01:C804  82         			clx				; Offset to PCE VDC.
         01:C805  20 63 FF   			call	load_vram_x
 6283                        	
 6284                        		.dbg	line,	"include\routines_LEVELS.c", 1096; player_counter_anim = 1;
 6285                        		__st.umiq	1, _player_counter_anim
         01:C808  A9 01      			lda.l	#1
         01:C80A  8D 18 23   			sta	_player_counter_anim
 6286                        	
 6287                        		.dbg	line,	"include\routines_LEVELS.c", 1097; }
 6288                        	
 6289                        		.dbg	line,	"include\routines_LEVELS.c", 1100; // SELECT PLAYER SPRITE //
 6290                        	
 6291                        		.dbg	line,	"include\routines_LEVELS.c", 1101; spr_set(player_id);
 6292    01:C80D             	.LL244:
 6293                        		__ld.umq	_player_id
         01:C80D  AD 14 23   			lda	_player_id
 6294                        		__call		_spr_set.1
         01:C810  20 DD E7   			call	_spr_set.1
 6295                        	
 6296                        		.dbg	line,	"include\routines_LEVELS.c", 1104; //**************************************************************************************//
 6297                        	
 6298                        		.dbg	line,	"include\routines_LEVELS.c", 1105; //                                        H MOVE                                        //
 6299                        	
 6300                        		.dbg	line,	"include\routines_LEVELS.c", 1106; //**************************************************************************************//
 6301                        	
 6302                        		.dbg	line,	"include\routines_LEVELS.c", 1108; //--------------------------------------------------------------------------------------//
 6303                        	
 6304                        		.dbg	line,	"include\routines_LEVELS.c", 1109; //                                    WALL COLLISION                                    //
 6305                        	
 6306                        		.dbg	line,	"include\routines_LEVELS.c", 1110; //--------------------------------------------------------------------------------------//
 6307                        	
 6308                        		.dbg	line,	"include\routines_LEVELS.c", 1112; // CHECK COLLISION WITH BOTTOM RIGHT WALL //
 6309                        	
 6310                        		.dbg	line,	"include\routines_LEVELS.c", 1113; check_BG( 24 , 31 );
 6311                        		__ld.wi		24
         01:C813  A9 18      			lda.l	#24
         01:C815  C2         			cly
 6312                        		__pusharg.wr
         01:C816  A6 8D      			ldx	<__sp
         01:C818  CA         			dex
         01:C819  CA         			dex
         01:C81A  95 08      			sta.l	<__stack, x
         01:C81C  94 09      			sty.h	<__stack, x
         01:C81E  86 8D      			stx	<__sp
 6313                        		__ld.wi		31
         01:C820  A9 1F      			lda.l	#31
         01:C822  C2         			cly
 6314                        		__pusharg.wr
         01:C823  A6 8D      			ldx	<__sp
         01:C825  CA         			dex
         01:C826  CA         			dex
         01:C827  95 08      			sta.l	<__stack, x
         01:C829  94 09      			sty.h	<__stack, x
         01:C82B  86 8D      			stx	<__sp
 6315                        		__call		_check_BG
         01:C82D  20 6D FF   			call	_check_BG
 6316                        	
 6317                        		.dbg	line,	"include\routines_LEVELS.c", 1115; if(map_blk_flag != TILE_BG)
 6318                        		__ld.umq	_map_blk_flag
         01:C830  AD A5 2B   			lda	_map_blk_flag
 6319                        		__neq_b.uiq	1
         01:C833  38         			sec
         01:C834  49 01      			eor	#1
         01:C836  D0 01      			bne	!+
         01:C838  18         			clc
         01:C839             	!:
 6320                        		__bfalse	.LL245
         01:C839  90 78      			bcc	.LL245
 6321                        	
 6322                        		.dbg	line,	"include\routines_LEVELS.c", 1116; {
 6323                        	
 6324                        		.dbg	line,	"include\routines_LEVELS.c", 1117; // CHECK COLLISION WITH TOP RIGHT WALL //
 6325                        	
 6326                        		.dbg	line,	"include\routines_LEVELS.c", 1118; check_BG( 24 , 15 );
 6327                        		__ld.wi		24
         01:C83B  A9 18      			lda.l	#24
         01:C83D  C2         			cly
 6328                        		__pusharg.wr
         01:C83E  A6 8D      			ldx	<__sp
         01:C840  CA         			dex
         01:C841  CA         			dex
         01:C842  95 08      			sta.l	<__stack, x
         01:C844  94 09      			sty.h	<__stack, x
         01:C846  86 8D      			stx	<__sp
 6329                        		__ld.wi		15
         01:C848  A9 0F      			lda.l	#15
         01:C84A  C2         			cly
 6330                        		__pusharg.wr
         01:C84B  A6 8D      			ldx	<__sp
         01:C84D  CA         			dex
         01:C84E  CA         			dex
         01:C84F  95 08      			sta.l	<__stack, x
         01:C851  94 09      			sty.h	<__stack, x
         01:C853  86 8D      			stx	<__sp
 6331                        		__call		_check_BG
         01:C855  20 6D FF   			call	_check_BG
 6332                        	
 6333                        		.dbg	line,	"include\routines_LEVELS.c", 1120; if(map_blk_flag == TILE_BG)
 6334                        		__ld.umq	_map_blk_flag
         01:C858  AD A5 2B   			lda	_map_blk_flag
 6335                        		__equ_b.uiq	1
         01:C85B  C9 01      			cmp	#1
         01:C85D  F0 01      			beq	!+
         01:C85F  18         			clc
         01:C860             	!:
 6336                        		__bfalse	.LL246
         01:C860  90 41      			bcc	.LL246
 6337                        	
 6338                        		.dbg	line,	"include\routines_LEVELS.c", 1121; {
 6339                        	
 6340                        		.dbg	line,	"include\routines_LEVELS.c", 1122; check_TILE_DEPTH( 15 , -16 );
 6341                        		__ld.wi		15
         01:C862  A9 0F      			lda.l	#15
         01:C864  C2         			cly
 6342                        		__pusharg.wr
         01:C865  A6 8D      			ldx	<__sp
         01:C867  CA         			dex
         01:C868  CA         			dex
         01:C869  95 08      			sta.l	<__stack, x
         01:C86B  94 09      			sty.h	<__stack, x
         01:C86D  86 8D      			stx	<__sp
 6343                        		__ld.wi		-16
         01:C86F  A9 F0      			lda.l	#-16
         01:C871  A0 FF      			ldy.h	#-16
 6344                        		__pusharg.wr
         01:C873  A6 8D      			ldx	<__sp
         01:C875  CA         			dex
         01:C876  CA         			dex
         01:C877  95 08      			sta.l	<__stack, x
         01:C879  94 09      			sty.h	<__stack, x
         01:C87B  86 8D      			stx	<__sp
 6345                        		__call		_check_TILE_DEPTH
         01:C87D  20 4F FF   			call	_check_TILE_DEPTH
 6346                        	
 6347                        		.dbg	line,	"include\routines_LEVELS.c", 1124; if(map_blk_flag == TILE_EMPTY && jump_ladder == TRUE)
 6348                        		__not.um	_map_blk_flag
         01:C880  AD A5 2B   			lda	_map_blk_flag
         01:C883  18         			clc
         01:C884  D0 01      			bne	!+
         01:C886  38         			sec
         01:C887             	!:
 6349                        		__bfalse	.LL248
         01:C887  90 08      			bcc	.LL248
 6350                        		__ld.umq	_jump_ladder
         01:C889  AD 1B 23   			lda	_jump_ladder
 6351                        		__equ_b.uiq	1
         01:C88C  C9 01      			cmp	#1
         01:C88E  F0 01      			beq	!+
         01:C890  18         			clc
         01:C891             	!:
 6352    01:C891             	.LL248:
 6353                        		__bfalse	.LL247
         01:C891  90 5F      			bcc	.LL247
 6354                        	
 6355                        		.dbg	line,	"include\routines_LEVELS.c", 1125; {
 6356                        	
 6357                        		.dbg	line,	"include\routines_LEVELS.c", 1126; jump_ladder = FALSE;
 6358                        		__st.umiq	0, _jump_ladder
         01:C893  9C 1B 23   			stz	_jump_ladder
 6359                        	
 6360                        		.dbg	line,	"include\routines_LEVELS.c", 1127; player_index_fall = 0;
 6361                        		__st.umiq	0, _player_index_fall
         01:C896  9C 1A 23   			stz	_player_index_fall
 6362                        	
 6363                        		.dbg	line,	"include\routines_LEVELS.c", 1128; player_state = STATE_FALL;
 6364                        		__st.umiq	9, _player_state
         01:C899  A9 09      			lda.l	#9
         01:C89B  8D 15 23   			sta	_player_state
 6365                        	
 6366                        		.dbg	line,	"include\routines_LEVELS.c", 1129; return;
 6367                        		__bra		.LL180
         01:C89E  4C 58 D6   			bra	.LL180
 6368                        	
 6369                        		.dbg	line,	"include\routines_LEVELS.c", 1130; }
 6370                        	
 6371                        		.dbg	line,	"include\routines_LEVELS.c", 1131; }
 6372    01:C8A1             	.LL247	.alias		.LL249
 6373                        	
 6374                        		.dbg	line,	"include\routines_LEVELS.c", 1133; else
 6375                        		__bra		.LL249
         01:C8A1  80 4F      			bra	.LL249
 6376    01:C8A3             	.LL246:
 6377                        	
 6378                        		.dbg	line,	"include\routines_LEVELS.c", 1134; {
 6379                        	
 6380                        		.dbg	line,	"include\routines_LEVELS.c", 1135; sgx_map_pxl_x += 2;
 6381                        		__add_st.wmiq	2, _sgx_map_pxl_x
         01:C8A3  18         			clc
         01:C8A4  AD 84 26   			lda.l	_sgx_map_pxl_x
         01:C8A7  69 02      			adc.l	#2
         01:C8A9  8D 84 26   			sta.l	_sgx_map_pxl_x
         01:C8AC  90 03      			bcc	!+
         01:C8AE  EE 85 26   			inc.h	_sgx_map_pxl_x
         01:C8B1             	!:
 6382                        	
 6383                        		.dbg	line,	"include\routines_LEVELS.c", 1136; }
 6384    01:C8B1             	.LL249	.alias		.LL250
 6385                        	
 6386                        		.dbg	line,	"include\routines_LEVELS.c", 1137; }
 6387                        	
 6388                        		.dbg	line,	"include\routines_LEVELS.c", 1139; else
 6389                        		__bra		.LL250
         01:C8B1  80 3F      			bra	.LL250
 6390    01:C8B3             	.LL245:
 6391                        	
 6392                        		.dbg	line,	"include\routines_LEVELS.c", 1140; {
 6393                        	
 6394                        		.dbg	line,	"include\routines_LEVELS.c", 1141; check_TILE_DEPTH( 15 , -16 );
 6395                        		__ld.wi		15
         01:C8B3  A9 0F      			lda.l	#15
         01:C8B5  C2         			cly
 6396                        		__pusharg.wr
         01:C8B6  A6 8D      			ldx	<__sp
         01:C8B8  CA         			dex
         01:C8B9  CA         			dex
         01:C8BA  95 08      			sta.l	<__stack, x
         01:C8BC  94 09      			sty.h	<__stack, x
         01:C8BE  86 8D      			stx	<__sp
 6397                        		__ld.wi		-16
         01:C8C0  A9 F0      			lda.l	#-16
         01:C8C2  A0 FF      			ldy.h	#-16
 6398                        		__pusharg.wr
         01:C8C4  A6 8D      			ldx	<__sp
         01:C8C6  CA         			dex
         01:C8C7  CA         			dex
         01:C8C8  95 08      			sta.l	<__stack, x
         01:C8CA  94 09      			sty.h	<__stack, x
         01:C8CC  86 8D      			stx	<__sp
 6399                        		__call		_check_TILE_DEPTH
         01:C8CE  20 4F FF   			call	_check_TILE_DEPTH
 6400                        	
 6401                        		.dbg	line,	"include\routines_LEVELS.c", 1143; if(map_blk_flag == TILE_EMPTY && jump_ladder == TRUE)
 6402                        		__not.um	_map_blk_flag
         01:C8D1  AD A5 2B   			lda	_map_blk_flag
         01:C8D4  18         			clc
         01:C8D5  D0 01      			bne	!+
         01:C8D7  38         			sec
         01:C8D8             	!:
 6403                        		__bfalse	.LL252
         01:C8D8  90 08      			bcc	.LL252
 6404                        		__ld.umq	_jump_ladder
         01:C8DA  AD 1B 23   			lda	_jump_ladder
 6405                        		__equ_b.uiq	1
         01:C8DD  C9 01      			cmp	#1
         01:C8DF  F0 01      			beq	!+
         01:C8E1  18         			clc
         01:C8E2             	!:
 6406    01:C8E2             	.LL252:
 6407                        		__bfalse	.LL251
         01:C8E2  90 0E      			bcc	.LL251
 6408                        	
 6409                        		.dbg	line,	"include\routines_LEVELS.c", 1144; {
 6410                        	
 6411                        		.dbg	line,	"include\routines_LEVELS.c", 1145; jump_ladder = FALSE;
 6412                        		__st.umiq	0, _jump_ladder
         01:C8E4  9C 1B 23   			stz	_jump_ladder
 6413                        	
 6414                        		.dbg	line,	"include\routines_LEVELS.c", 1146; player_index_fall = 0;
 6415                        		__st.umiq	0, _player_index_fall
         01:C8E7  9C 1A 23   			stz	_player_index_fall
 6416                        	
 6417                        		.dbg	line,	"include\routines_LEVELS.c", 1147; player_state = STATE_FALL;
 6418                        		__st.umiq	9, _player_state
         01:C8EA  A9 09      			lda.l	#9
         01:C8EC  8D 15 23   			sta	_player_state
 6419                        	
 6420                        		.dbg	line,	"include\routines_LEVELS.c", 1148; return;
 6421                        		__bra		.LL180
         01:C8EF  4C 58 D6   			bra	.LL180
 6422                        	
 6423                        		.dbg	line,	"include\routines_LEVELS.c", 1149; }
 6424                        	
 6425                        		.dbg	line,	"include\routines_LEVELS.c", 1150; }
 6426    01:C8F2             	.LL251:
 6427    01:C8F2             	.LL250:
 6428                        	
 6429                        		.dbg	line,	"include\routines_LEVELS.c", 1155; //**************************************************************************************//
 6430                        	
 6431                        		.dbg	line,	"include\routines_LEVELS.c", 1156; //                                        V MOVE                                        //
 6432                        	
 6433                        		.dbg	line,	"include\routines_LEVELS.c", 1157; //**************************************************************************************//
 6434                        	
 6435                        		.dbg	line,	"include\routines_LEVELS.c", 1159; // UPDATE PLAYER Y POSITION //
 6436                        	
 6437                        		.dbg	line,	"include\routines_LEVELS.c", 1160; if(jump_ladder == FALSE)
 6438                        		__not.um	_jump_ladder
         01:C8F2  AD 1B 23   			lda	_jump_ladder
         01:C8F5  18         			clc
         01:C8F6  D0 01      			bne	!+
         01:C8F8  38         			sec
         01:C8F9             	!:
 6439                        		__bfalse	.LL253
         01:C8F9  90 1A      			bcc	.LL253
 6440                        	
 6441                        		.dbg	line,	"include\routines_LEVELS.c", 1161; {
 6442                        	
 6443                        		.dbg	line,	"include\routines_LEVELS.c", 1162; player_pos_y += TABLE_PLAYER_JUMP_V[player_index_jump];
 6444                        		__ldx.umq	_player_index_jump
         01:C8FB  AE 19 23   			ldx	_player_index_jump
 6445                        		__ld.bax	_TABLE_PLAYER_JUMP_V
         01:C8FE  BD A2 60   			lda	_TABLE_PLAYER_JUMP_V, x
         01:C901  C2         			cly
         01:C902  10 01      			bpl	!+
         01:C904  88         			dey
         01:C905             	!:
 6446                        		__add_st.wmq	_player_pos_y
         01:C905  18         			clc
         01:C906  6D CA 24   			adc.l	_player_pos_y
         01:C909  8D CA 24   			sta.l	_player_pos_y
         01:C90C  98         			tya
         01:C90D  6D CB 24   			adc.h	_player_pos_y
         01:C910  8D CB 24   			sta.h	_player_pos_y
 6447                        	
 6448                        		.dbg	line,	"include\routines_LEVELS.c", 1163; }
 6449                        	
 6450                        		.dbg	line,	"include\routines_LEVELS.c", 1165; else
 6451                        		__bra		.LL254
         01:C913  80 18      			bra	.LL254
 6452    01:C915             	.LL253:
 6453                        	
 6454                        		.dbg	line,	"include\routines_LEVELS.c", 1166; {
 6455                        	
 6456                        		.dbg	line,	"include\routines_LEVELS.c", 1167; player_pos_y += TABLE_PLAYER_JUMP_LADDER[player_index_jump];
 6457                        		__ldx.umq	_player_index_jump
         01:C915  AE 19 23   			ldx	_player_index_jump
 6458                        		__ld.bax	_TABLE_PLAYER_JUMP_LADDER
         01:C918  BD DA 60   			lda	_TABLE_PLAYER_JUMP_LADDER, x
         01:C91B  C2         			cly
         01:C91C  10 01      			bpl	!+
         01:C91E  88         			dey
         01:C91F             	!:
 6459                        		__add_st.wmq	_player_pos_y
         01:C91F  18         			clc
         01:C920  6D CA 24   			adc.l	_player_pos_y
         01:C923  8D CA 24   			sta.l	_player_pos_y
         01:C926  98         			tya
         01:C927  6D CB 24   			adc.h	_player_pos_y
         01:C92A  8D CB 24   			sta.h	_player_pos_y
 6460                        	
 6461                        		.dbg	line,	"include\routines_LEVELS.c", 1168; }
 6462    01:C92D             	.LL254:
 6463                        	
 6464                        		.dbg	line,	"include\routines_LEVELS.c", 1172; // IF PLAYER GOES BELOW ITS BASE Y POSITION //
 6465                        	
 6466                        		.dbg	line,	"include\routines_LEVELS.c", 1173; if(player_pos_y >= PLAYER_BASE_Y_POS)
 6467                        		__ld.wm		_player_pos_y
         01:C92D  AD CA 24   			lda.l	_player_pos_y
         01:C930  AC CB 24   			ldy.h	_player_pos_y
 6468                        		__sge_w.wi	128
         01:C933  C9 80      			cmp.l	#128		; Subtract integer from Y:A.
         01:C935  98         			tya
         01:C936  E9 00      			sbc.h	#128
         01:C938  50 02      			bvc	!+
         01:C93A  49 80      			eor	#$80		; +ve if Y:A >= integer (signed).
         01:C93C  49 80      	!:		eor	#$80
         01:C93E  0A         			asl	a
 6469                        		__bfalse	.LL255
         01:C93F  90 4E      			bcc	.LL255
 6470                        	
 6471                        		.dbg	line,	"include\routines_LEVELS.c", 1174; {
 6472                        	
 6473                        		.dbg	line,	"include\routines_LEVELS.c", 1175; // THE CAMERA MOVES //
 6474                        	
 6475                        		.dbg	line,	"include\routines_LEVELS.c", 1176; // CALCULATE HOW MANY PIXELS THE CAMERA HAS TO MOVE DOWN //
 6476                        	
 6477                        		.dbg	line,	"include\routines_LEVELS.c", 1177; camera_y_move = player_pos_y - PLAYER_BASE_Y_POS;
 6478                        		__ld.wm		_player_pos_y
         01:C941  AD CA 24   			lda.l	_player_pos_y
         01:C944  AC CB 24   			ldy.h	_player_pos_y
 6479                        		__sub.wi	128
         01:C947  38         			sec
         01:C948  E9 80      			sbc.l	#128
         01:C94A  B0 01      			bcs	!+
         01:C94C  88         			dey
         01:C94D             	!:
 6480                        		__st.umq	__update_PLAYER_end - 3  /* camera_y_move */
         01:C94D  8D 0A 23   			sta	__update_PLAYER_end - 3
 6481                        	
 6482                        		.dbg	line,	"include\routines_LEVELS.c", 1178; sgx_map_pxl_y += camera_y_move;
 6483                        		__ld.um		__update_PLAYER_end - 3  /* camera_y_move */
         01:C950  AD 0A 23   			lda	__update_PLAYER_end - 3
         01:C953  C2         			cly
 6484                        		__add_st.wmq	_sgx_map_pxl_y
         01:C954  18         			clc
         01:C955  6D 86 26   			adc.l	_sgx_map_pxl_y
         01:C958  8D 86 26   			sta.l	_sgx_map_pxl_y
         01:C95B  98         			tya
         01:C95C  6D 87 26   			adc.h	_sgx_map_pxl_y
         01:C95F  8D 87 26   			sta.h	_sgx_map_pxl_y
 6485                        	
 6486                        		.dbg	line,	"include\routines_LEVELS.c", 1180; // IF THE CAMERA HAS REACHED ITS MAX (LOWEST) POSITION //
 6487                        	
 6488                        		.dbg	line,	"include\routines_LEVELS.c", 1181; if(sgx_map_pxl_y > camera_max_y_position)
 6489                        		__ld.wm		_sgx_map_pxl_y
         01:C962  AD 86 26   			lda.l	_sgx_map_pxl_y
         01:C965  AC 87 26   			ldy.h	_sgx_map_pxl_y
 6490                        		__ugt_w.wm	_camera_max_y_position
         01:C968  18         			clc			; Subtract memory+1 from Y:A.
         01:C969  ED CC 24   			sbc.l	_camera_max_y_position
         01:C96C  98         			tya
         01:C96D  ED CD 24   			sbc.h	_camera_max_y_position		; CS if Y:A > memory.
 6491                        		__bfalse	.LL256
         01:C970  90 0C      			bcc	.LL256
 6492                        	
 6493                        		.dbg	line,	"include\routines_LEVELS.c", 1182; {
 6494                        	
 6495                        		.dbg	line,	"include\routines_LEVELS.c", 1183; // THE CAMERA CAN NOT MOVE LOWER //
 6496                        	
 6497                        		.dbg	line,	"include\routines_LEVELS.c", 1184; sgx_map_pxl_y = camera_max_y_position;
 6498                        		__ld.wm		_camera_max_y_position
         01:C972  AD CC 24   			lda.l	_camera_max_y_position
         01:C975  AC CD 24   			ldy.h	_camera_max_y_position
 6499                        		__st.wmq	_sgx_map_pxl_y
         01:C978  8D 86 26   			sta.l	_sgx_map_pxl_y
         01:C97B  8C 87 26   			sty.h	_sgx_map_pxl_y
 6500                        	
 6501                        		.dbg	line,	"include\routines_LEVELS.c", 1185; }
 6502                        	
 6503                        		.dbg	line,	"include\routines_LEVELS.c", 1187; // THE PLAYER STAYS AT ITS BASE Y POSITION //
 6504                        	
 6505                        		.dbg	line,	"include\routines_LEVELS.c", 1188; player_pos_y = PLAYER_BASE_Y_POS;
 6506    01:C97E             	.LL256:
 6507                        		__st.wmiq	128, _player_pos_y
         01:C97E  A9 80      			lda.l	#128
         01:C980  8D CA 24   			sta.l	_player_pos_y
         01:C983  9C CB 24   			stz.h	_player_pos_y
 6508                        	
 6509                        		.dbg	line,	"include\routines_LEVELS.c", 1190; spr_y(player_pos_y);
 6510                        		__ld.wm		_player_pos_y
         01:C986  AD CA 24   			lda.l	_player_pos_y
         01:C989  AC CB 24   			ldy.h	_player_pos_y
 6511                        		__call		_spr_y.1
         01:C98C  20 19 E8   			call	_spr_y.1
 6512                        	
 6513                        		.dbg	line,	"include\routines_LEVELS.c", 1191; }
 6514                        	
 6515                        		.dbg	line,	"include\routines_LEVELS.c", 1194; // UPDATE JUMP INDEX IN THE ARRAY //
 6516                        	
 6517                        		.dbg	line,	"include\routines_LEVELS.c", 1195; if(player_index_jump < jump_max_index)
 6518    01:C98F             	.LL255:
 6519                        		__ld.umq	_player_index_jump
         01:C98F  AD 19 23   			lda	_player_index_jump
 6520                        		__ult_b.umq	_jump_max_index
         01:C992  CD 1C 23   			cmp	_jump_max_index		; Subtract memory from A.
         01:C995  6A         			ror	a		; CC if A < memory.
         01:C996  49 80      			eor	#$80
         01:C998  2A         			rol	a
 6521                        		__bfalse	.LL257
         01:C999  90 03      			bcc	.LL257
 6522                        	
 6523                        		.dbg	line,	"include\routines_LEVELS.c", 1196; {
 6524                        	
 6525                        		.dbg	line,	"include\routines_LEVELS.c", 1197; player_index_jump += 1;
 6526                        		__add_st.umiq	1, _player_index_jump
         01:C99B  EE 19 23   			inc	_player_index_jump
 6527                        	
 6528                        		.dbg	line,	"include\routines_LEVELS.c", 1198; }
 6529                        	
 6530                        		.dbg	line,	"include\routines_LEVELS.c", 1203; //--------------------------------------------------------------------------------------//
 6531                        	
 6532                        		.dbg	line,	"include\routines_LEVELS.c", 1204; //                                   FLOOR COLLISION                                    //
 6533                        	
 6534                        		.dbg	line,	"include\routines_LEVELS.c", 1205; //--------------------------------------------------------------------------------------//
 6535                        	
 6536                        		.dbg	line,	"include\routines_LEVELS.c", 1207; if(player_index_jump > 14)
 6537    01:C99E             	.LL257:
 6538                        		__ld.umq	_player_index_jump
         01:C99E  AD 19 23   			lda	_player_index_jump
 6539                        		__ugt_b.uiq	14
         01:C9A1  18         			clc			; Subtract integer+1 from A.
         01:C9A2  E9 0E      			sbc	#14		; CS if A > integer.
 6540                        		__bfalse	.LL258
         01:C9A4  B0 03 4C 59			bcc	.LL258
         01:C9A8  CB          
 6541                        	
 6542                        		.dbg	line,	"include\routines_LEVELS.c", 1208; {
 6543                        	
 6544                        		.dbg	line,	"include\routines_LEVELS.c", 1209; // CHECK COLLISION WITH LEFT FLOOR //
 6545                        	
 6546                        		.dbg	line,	"include\routines_LEVELS.c", 1210; check_BG( 10 , 32 );
 6547                        		__ld.wi		10
         01:C9A9  A9 0A      			lda.l	#10
         01:C9AB  C2         			cly
 6548                        		__pusharg.wr
         01:C9AC  A6 8D      			ldx	<__sp
         01:C9AE  CA         			dex
         01:C9AF  CA         			dex
         01:C9B0  95 08      			sta.l	<__stack, x
         01:C9B2  94 09      			sty.h	<__stack, x
         01:C9B4  86 8D      			stx	<__sp
 6549                        		__ld.wi		32
         01:C9B6  A9 20      			lda.l	#32
         01:C9B8  C2         			cly
 6550                        		__pusharg.wr
         01:C9B9  A6 8D      			ldx	<__sp
         01:C9BB  CA         			dex
         01:C9BC  CA         			dex
         01:C9BD  95 08      			sta.l	<__stack, x
         01:C9BF  94 09      			sty.h	<__stack, x
         01:C9C1  86 8D      			stx	<__sp
 6551                        		__call		_check_BG
         01:C9C3  20 6D FF   			call	_check_BG
 6552                        	
 6553                        		.dbg	line,	"include\routines_LEVELS.c", 1212; // IF PLAYER TOUCHES THE GROUND TO THE LEFT //
 6554                        	
 6555                        		.dbg	line,	"include\routines_LEVELS.c", 1213; if(map_blk_flag == TILE_BG)
 6556                        		__ld.umq	_map_blk_flag
         01:C9C6  AD A5 2B   			lda	_map_blk_flag
 6557                        		__equ_b.uiq	1
         01:C9C9  C9 01      			cmp	#1
         01:C9CB  F0 01      			beq	!+
         01:C9CD  18         			clc
         01:C9CE             	!:
 6558                        		__bfalse	.LL259
         01:C9CE  B0 03 4C 81			bcc	.LL259
         01:C9D2  CA          
 6559                        	
 6560                        		.dbg	line,	"include\routines_LEVELS.c", 1214; {
 6561                        	
 6562                        		.dbg	line,	"include\routines_LEVELS.c", 1215; // CALCULATE HOW MANY PIXELS THE PLAYER MOVED INTO THE GROUND //
 6563                        	
 6564                        		.dbg	line,	"include\routines_LEVELS.c", 1216; for(i=1; i<11 ; i++)
 6565                        		__st.umiq	1, __update_PLAYER_end - 2  /* i */
         01:C9D3  A9 01      			lda.l	#1
         01:C9D5  8D 0B 23   			sta	__update_PLAYER_end - 2
 6566    01:C9D8             	.LL260:
 6567                        		__ld.umq	__update_PLAYER_end - 2  /* i */
         01:C9D8  AD 0B 23   			lda	__update_PLAYER_end - 2
 6568                        		__ult_b.uiq	11
         01:C9DB  C9 0B      			cmp	#11		; Subtract integer from A.
         01:C9DD  6A         			ror	a		; CC if A < integer.
         01:C9DE  49 80      			eor	#$80
         01:C9E0  2A         			rol	a
 6569                        		__btrue		.LL262
         01:C9E1  B0 07      			bcs	.LL262
 6570                        		__bra		.LL263
         01:C9E3  80 7D      			bra	.LL263
 6571    01:C9E5             	.LL261:
 6572                        		__inc.umq	__update_PLAYER_end - 2  /* i */
         01:C9E5  EE 0B 23   			inc	__update_PLAYER_end - 2
 6573                        		__bra		.LL260
         01:C9E8  80 EE      			bra	.LL260
 6574    01:C9EA             	.LL262:
 6575                        	
 6576                        		.dbg	line,	"include\routines_LEVELS.c", 1217; {
 6577                        	
 6578                        		.dbg	line,	"include\routines_LEVELS.c", 1218; check_TILE_DEPTH( 10 , i);
 6579                        		__ld.wi		10
         01:C9EA  A9 0A      			lda.l	#10
         01:C9EC  C2         			cly
 6580                        		__pusharg.wr
         01:C9ED  A6 8D      			ldx	<__sp
         01:C9EF  CA         			dex
         01:C9F0  CA         			dex
         01:C9F1  95 08      			sta.l	<__stack, x
         01:C9F3  94 09      			sty.h	<__stack, x
         01:C9F5  86 8D      			stx	<__sp
 6581                        		__ld.um		__update_PLAYER_end - 2  /* i */
         01:C9F7  AD 0B 23   			lda	__update_PLAYER_end - 2
         01:C9FA  C2         			cly
 6582                        		__pusharg.wr
         01:C9FB  A6 8D      			ldx	<__sp
         01:C9FD  CA         			dex
         01:C9FE  CA         			dex
         01:C9FF  95 08      			sta.l	<__stack, x
         01:CA01  94 09      			sty.h	<__stack, x
         01:CA03  86 8D      			stx	<__sp
 6583                        		__call		_check_TILE_DEPTH
         01:CA05  20 4F FF   			call	_check_TILE_DEPTH
 6584                        	
 6585                        		.dbg	line,	"include\routines_LEVELS.c", 1220; if(map_blk_flag == TILE_EMPTY)
 6586                        		__not.um	_map_blk_flag
         01:CA08  AD A5 2B   			lda	_map_blk_flag
         01:CA0B  18         			clc
         01:CA0C  D0 01      			bne	!+
         01:CA0E  38         			sec
         01:CA0F             	!:
 6587                        		__bfalse	.LL264
         01:CA0F  90 D4      			bcc	.LL264
 6588                        	
 6589                        		.dbg	line,	"include\routines_LEVELS.c", 1221; {
 6590                        	
 6591                        		.dbg	line,	"include\routines_LEVELS.c", 1222; if(player_pos_y != PLAYER_BASE_Y_POS)
 6592                        		__ld.wm		_player_pos_y
         01:CA11  AD CA 24   			lda.l	_player_pos_y
         01:CA14  AC CB 24   			ldy.h	_player_pos_y
 6593                        		__neq_w.wi	128
         01:CA17  38         			sec
         01:CA18  49 80      			eor.l	#128
         01:CA1A  D0 06      			bne	!+
         01:CA1C  98         			tya
         01:CA1D  49 00      			eor.h	#128
         01:CA1F  D0 01      			bne	!+
         01:CA21  18         			clc
         01:CA22             	!:
 6594                        		__bfalse	.LL265
         01:CA22  90 1E      			bcc	.LL265
 6595                        	
 6596                        		.dbg	line,	"include\routines_LEVELS.c", 1223; {
 6597                        	
 6598                        		.dbg	line,	"include\routines_LEVELS.c", 1224; player_pos_y -= (i - 1);
 6599                        		__ld.um		__update_PLAYER_end - 2  /* i */
         01:CA24  AD 0B 23   			lda	__update_PLAYER_end - 2
         01:CA27  C2         			cly
 6600                        		__sub.wi	1
         01:CA28  38         			sec
         01:CA29  E9 01      			sbc.l	#1
         01:CA2B  B0 01      			bcs	!+
         01:CA2D  88         			dey
         01:CA2E             	!:
 6601                        		__isub_st.wmq	_player_pos_y
         01:CA2E  38         			sec
         01:CA2F  49 FF      			eor	#$FF
         01:CA31  6D CA 24   			adc.l	_player_pos_y
         01:CA34  8D CA 24   			sta.l	_player_pos_y
         01:CA37  98         			tya
         01:CA38  49 FF      			eor	#$FF
         01:CA3A  6D CB 24   			adc.h	_player_pos_y
         01:CA3D  8D CB 24   			sta.h	_player_pos_y
 6602                        	
 6603                        		.dbg	line,	"include\routines_LEVELS.c", 1225; }
 6604                        	
 6605                        		.dbg	line,	"include\routines_LEVELS.c", 1227; else
 6606                        		__bra		.LL266
         01:CA40  80 20      			bra	.LL266
 6607    01:CA42             	.LL265:
 6608                        	
 6609                        		.dbg	line,	"include\routines_LEVELS.c", 1228; {
 6610                        	
 6611                        		.dbg	line,	"include\routines_LEVELS.c", 1229; sgx_map_pxl_y -= (i - 1);
 6612                        		__ld.um		__update_PLAYER_end - 2  /* i */
         01:CA42  AD 0B 23   			lda	__update_PLAYER_end - 2
         01:CA45  C2         			cly
 6613                        		__sub.wi	1
         01:CA46  38         			sec
         01:CA47  E9 01      			sbc.l	#1
         01:CA49  B0 01      			bcs	!+
         01:CA4B  88         			dey
         01:CA4C             	!:
 6614                        		__isub_st.wmq	_sgx_map_pxl_y
         01:CA4C  38         			sec
         01:CA4D  49 FF      			eor	#$FF
         01:CA4F  6D 86 26   			adc.l	_sgx_map_pxl_y
         01:CA52  8D 86 26   			sta.l	_sgx_map_pxl_y
         01:CA55  98         			tya
         01:CA56  49 FF      			eor	#$FF
         01:CA58  6D 87 26   			adc.h	_sgx_map_pxl_y
         01:CA5B  8D 87 26   			sta.h	_sgx_map_pxl_y
 6615                        	
 6616                        		.dbg	line,	"include\routines_LEVELS.c", 1230; }
 6617    01:CA5E             	.LL266	.alias		.LL263
 6618                        	
 6619                        		.dbg	line,	"include\routines_LEVELS.c", 1232; break;
 6620                        		__bra		.LL263
         01:CA5E  80 02      			bra	.LL263
 6621                        	
 6622                        		.dbg	line,	"include\routines_LEVELS.c", 1233; }
 6623                        	
 6624                        		.dbg	line,	"include\routines_LEVELS.c", 1234; }
 6625    01:CA60             	.LL264	.alias		.LL261
 6626                        		__bra		.LL261
         01:CA60  80 83      			bra	.LL261
 6627    01:CA62             	.LL263:
 6628                        	
 6629                        		.dbg	line,	"include\routines_LEVELS.c", 1236; // SET PLAYER SPRITE NEW POSITION //
 6630                        	
 6631                        		.dbg	line,	"include\routines_LEVELS.c", 1237; spr_y(player_pos_y);
 6632                        		__ld.wm		_player_pos_y
         01:CA62  AD CA 24   			lda.l	_player_pos_y
         01:CA65  AC CB 24   			ldy.h	_player_pos_y
 6633                        		__call		_spr_y.1
         01:CA68  20 19 E8   			call	_spr_y.1
 6634                        	
 6635                        		.dbg	line,	"include\routines_LEVELS.c", 1239; player_counter_anim = 1;
 6636                        		__st.umiq	1, _player_counter_anim
         01:CA6B  A9 01      			lda.l	#1
         01:CA6D  8D 18 23   			sta	_player_counter_anim
 6637                        	
 6638                        		.dbg	line,	"include\routines_LEVELS.c", 1240; player_index_jump = 0;
 6639                        		__st.umiq	0, _player_index_jump
         01:CA70  9C 19 23   			stz	_player_index_jump
 6640                        	
 6641                        		.dbg	line,	"include\routines_LEVELS.c", 1241; jump_ladder = FALSE;
 6642                        		__st.umiq	0, _jump_ladder
         01:CA73  9C 1B 23   			stz	_jump_ladder
 6643                        	
 6644                        		.dbg	line,	"include\routines_LEVELS.c", 1242; jump_max_index = 34;
 6645                        		__st.umiq	34, _jump_max_index
         01:CA76  A9 22      			lda.l	#34
         01:CA78  8D 1C 23   			sta	_jump_max_index
 6646                        	
 6647                        		.dbg	line,	"include\routines_LEVELS.c", 1243; player_state = STATE_IDLE;
 6648                        		__st.umiq	0, _player_state
         01:CA7B  9C 15 23   			stz	_player_state
 6649                        	
 6650                        		.dbg	line,	"include\routines_LEVELS.c", 1244; return;
 6651                        		__bra		.LL180
         01:CA7E  4C 58 D6   			bra	.LL180
 6652                        	
 6653                        		.dbg	line,	"include\routines_LEVELS.c", 1245; }
 6654                        	
 6655                        		.dbg	line,	"include\routines_LEVELS.c", 1247; // IF PLAYER TOUCHES THE GROUND TO THE RIGHT //
 6656                        	
 6657                        		.dbg	line,	"include\routines_LEVELS.c", 1248; else
 6658    01:CA81             	.LL259:
 6659                        	
 6660                        		.dbg	line,	"include\routines_LEVELS.c", 1249; {
 6661                        	
 6662                        		.dbg	line,	"include\routines_LEVELS.c", 1250; // CHECK COLLISION WITH RIGHT FLOOR //
 6663                        	
 6664                        		.dbg	line,	"include\routines_LEVELS.c", 1251; check_BG( 22 , 32 );
 6665                        		__ld.wi		22
         01:CA81  A9 16      			lda.l	#22
         01:CA83  C2         			cly
 6666                        		__pusharg.wr
         01:CA84  A6 8D      			ldx	<__sp
         01:CA86  CA         			dex
         01:CA87  CA         			dex
         01:CA88  95 08      			sta.l	<__stack, x
         01:CA8A  94 09      			sty.h	<__stack, x
         01:CA8C  86 8D      			stx	<__sp
 6667                        		__ld.wi		32
         01:CA8E  A9 20      			lda.l	#32
         01:CA90  C2         			cly
 6668                        		__pusharg.wr
         01:CA91  A6 8D      			ldx	<__sp
         01:CA93  CA         			dex
         01:CA94  CA         			dex
         01:CA95  95 08      			sta.l	<__stack, x
         01:CA97  94 09      			sty.h	<__stack, x
         01:CA99  86 8D      			stx	<__sp
 6669                        		__call		_check_BG
         01:CA9B  20 6D FF   			call	_check_BG
 6670                        	
 6671                        		.dbg	line,	"include\routines_LEVELS.c", 1253; if(map_blk_flag == TILE_BG)
 6672                        		__ld.umq	_map_blk_flag
         01:CA9E  AD A5 2B   			lda	_map_blk_flag
 6673                        		__equ_b.uiq	1
         01:CAA1  C9 01      			cmp	#1
         01:CAA3  F0 01      			beq	!+
         01:CAA5  18         			clc
         01:CAA6             	!:
 6674                        		__bfalse	.LL268
         01:CAA6  B0 03 4C 59			bcc	.LL268
         01:CAAA  CB          
 6675                        	
 6676                        		.dbg	line,	"include\routines_LEVELS.c", 1254; {
 6677                        	
 6678                        		.dbg	line,	"include\routines_LEVELS.c", 1255; // CALCULATE HOW MANY PIXELS THE PLAYER MOVED INTO THE GROUND //
 6679                        	
 6680                        		.dbg	line,	"include\routines_LEVELS.c", 1256; for(i=1; i<11 ; i++)
 6681                        		__st.umiq	1, __update_PLAYER_end - 2  /* i */
         01:CAAB  A9 01      			lda.l	#1
         01:CAAD  8D 0B 23   			sta	__update_PLAYER_end - 2
 6682    01:CAB0             	.LL269:
 6683                        		__ld.umq	__update_PLAYER_end - 2  /* i */
         01:CAB0  AD 0B 23   			lda	__update_PLAYER_end - 2
 6684                        		__ult_b.uiq	11
         01:CAB3  C9 0B      			cmp	#11		; Subtract integer from A.
         01:CAB5  6A         			ror	a		; CC if A < integer.
         01:CAB6  49 80      			eor	#$80
         01:CAB8  2A         			rol	a
 6685                        		__btrue		.LL271
         01:CAB9  B0 07      			bcs	.LL271
 6686                        		__bra		.LL272
         01:CABB  80 7D      			bra	.LL272
 6687    01:CABD             	.LL270:
 6688                        		__inc.umq	__update_PLAYER_end - 2  /* i */
         01:CABD  EE 0B 23   			inc	__update_PLAYER_end - 2
 6689                        		__bra		.LL269
         01:CAC0  80 EE      			bra	.LL269
 6690    01:CAC2             	.LL271:
 6691                        	
 6692                        		.dbg	line,	"include\routines_LEVELS.c", 1257; {
 6693                        	
 6694                        		.dbg	line,	"include\routines_LEVELS.c", 1258; check_TILE_DEPTH( 22 , i);
 6695                        		__ld.wi		22
         01:CAC2  A9 16      			lda.l	#22
         01:CAC4  C2         			cly
 6696                        		__pusharg.wr
         01:CAC5  A6 8D      			ldx	<__sp
         01:CAC7  CA         			dex
         01:CAC8  CA         			dex
         01:CAC9  95 08      			sta.l	<__stack, x
         01:CACB  94 09      			sty.h	<__stack, x
         01:CACD  86 8D      			stx	<__sp
 6697                        		__ld.um		__update_PLAYER_end - 2  /* i */
         01:CACF  AD 0B 23   			lda	__update_PLAYER_end - 2
         01:CAD2  C2         			cly
 6698                        		__pusharg.wr
         01:CAD3  A6 8D      			ldx	<__sp
         01:CAD5  CA         			dex
         01:CAD6  CA         			dex
         01:CAD7  95 08      			sta.l	<__stack, x
         01:CAD9  94 09      			sty.h	<__stack, x
         01:CADB  86 8D      			stx	<__sp
 6699                        		__call		_check_TILE_DEPTH
         01:CADD  20 4F FF   			call	_check_TILE_DEPTH
 6700                        	
 6701                        		.dbg	line,	"include\routines_LEVELS.c", 1260; if(map_blk_flag == TILE_EMPTY)
 6702                        		__not.um	_map_blk_flag
         01:CAE0  AD A5 2B   			lda	_map_blk_flag
         01:CAE3  18         			clc
         01:CAE4  D0 01      			bne	!+
         01:CAE6  38         			sec
         01:CAE7             	!:
 6703                        		__bfalse	.LL273
         01:CAE7  90 D4      			bcc	.LL273
 6704                        	
 6705                        		.dbg	line,	"include\routines_LEVELS.c", 1261; {
 6706                        	
 6707                        		.dbg	line,	"include\routines_LEVELS.c", 1262; if(player_pos_y != PLAYER_BASE_Y_POS)
 6708                        		__ld.wm		_player_pos_y
         01:CAE9  AD CA 24   			lda.l	_player_pos_y
         01:CAEC  AC CB 24   			ldy.h	_player_pos_y
 6709                        		__neq_w.wi	128
         01:CAEF  38         			sec
         01:CAF0  49 80      			eor.l	#128
         01:CAF2  D0 06      			bne	!+
         01:CAF4  98         			tya
         01:CAF5  49 00      			eor.h	#128
         01:CAF7  D0 01      			bne	!+
         01:CAF9  18         			clc
         01:CAFA             	!:
 6710                        		__bfalse	.LL274
         01:CAFA  90 1E      			bcc	.LL274
 6711                        	
 6712                        		.dbg	line,	"include\routines_LEVELS.c", 1263; {
 6713                        	
 6714                        		.dbg	line,	"include\routines_LEVELS.c", 1264; player_pos_y -= (i - 1);
 6715                        		__ld.um		__update_PLAYER_end - 2  /* i */
         01:CAFC  AD 0B 23   			lda	__update_PLAYER_end - 2
         01:CAFF  C2         			cly
 6716                        		__sub.wi	1
         01:CB00  38         			sec
         01:CB01  E9 01      			sbc.l	#1
         01:CB03  B0 01      			bcs	!+
         01:CB05  88         			dey
         01:CB06             	!:
 6717                        		__isub_st.wmq	_player_pos_y
         01:CB06  38         			sec
         01:CB07  49 FF      			eor	#$FF
         01:CB09  6D CA 24   			adc.l	_player_pos_y
         01:CB0C  8D CA 24   			sta.l	_player_pos_y
         01:CB0F  98         			tya
         01:CB10  49 FF      			eor	#$FF
         01:CB12  6D CB 24   			adc.h	_player_pos_y
         01:CB15  8D CB 24   			sta.h	_player_pos_y
 6718                        	
 6719                        		.dbg	line,	"include\routines_LEVELS.c", 1265; }
 6720                        	
 6721                        		.dbg	line,	"include\routines_LEVELS.c", 1267; else
 6722                        		__bra		.LL275
         01:CB18  80 20      			bra	.LL275
 6723    01:CB1A             	.LL274:
 6724                        	
 6725                        		.dbg	line,	"include\routines_LEVELS.c", 1268; {
 6726                        	
 6727                        		.dbg	line,	"include\routines_LEVELS.c", 1269; sgx_map_pxl_y -= (i - 1);
 6728                        		__ld.um		__update_PLAYER_end - 2  /* i */
         01:CB1A  AD 0B 23   			lda	__update_PLAYER_end - 2
         01:CB1D  C2         			cly
 6729                        		__sub.wi	1
         01:CB1E  38         			sec
         01:CB1F  E9 01      			sbc.l	#1
         01:CB21  B0 01      			bcs	!+
         01:CB23  88         			dey
         01:CB24             	!:
 6730                        		__isub_st.wmq	_sgx_map_pxl_y
         01:CB24  38         			sec
         01:CB25  49 FF      			eor	#$FF
         01:CB27  6D 86 26   			adc.l	_sgx_map_pxl_y
         01:CB2A  8D 86 26   			sta.l	_sgx_map_pxl_y
         01:CB2D  98         			tya
         01:CB2E  49 FF      			eor	#$FF
         01:CB30  6D 87 26   			adc.h	_sgx_map_pxl_y
         01:CB33  8D 87 26   			sta.h	_sgx_map_pxl_y
 6731                        	
 6732                        		.dbg	line,	"include\routines_LEVELS.c", 1270; }
 6733    01:CB36             	.LL275	.alias		.LL272
 6734                        	
 6735                        		.dbg	line,	"include\routines_LEVELS.c", 1272; break;
 6736                        		__bra		.LL272
         01:CB36  80 02      			bra	.LL272
 6737                        	
 6738                        		.dbg	line,	"include\routines_LEVELS.c", 1273; }
 6739                        	
 6740                        		.dbg	line,	"include\routines_LEVELS.c", 1274; }
 6741    01:CB38             	.LL273	.alias		.LL270
 6742                        		__bra		.LL270
         01:CB38  80 83      			bra	.LL270
 6743    01:CB3A             	.LL272:
 6744                        	
 6745                        		.dbg	line,	"include\routines_LEVELS.c", 1276; // SET PLAYER SPRITE NEW POSITION //
 6746                        	
 6747                        		.dbg	line,	"include\routines_LEVELS.c", 1277; spr_y(player_pos_y);
 6748                        		__ld.wm		_player_pos_y
         01:CB3A  AD CA 24   			lda.l	_player_pos_y
         01:CB3D  AC CB 24   			ldy.h	_player_pos_y
 6749                        		__call		_spr_y.1
         01:CB40  20 19 E8   			call	_spr_y.1
 6750                        	
 6751                        		.dbg	line,	"include\routines_LEVELS.c", 1279; player_counter_anim = 1;
 6752                        		__st.umiq	1, _player_counter_anim
         01:CB43  A9 01      			lda.l	#1
         01:CB45  8D 18 23   			sta	_player_counter_anim
 6753                        	
 6754                        		.dbg	line,	"include\routines_LEVELS.c", 1280; player_index_jump = 0;
 6755                        		__st.umiq	0, _player_index_jump
         01:CB48  9C 19 23   			stz	_player_index_jump
 6756                        	
 6757                        		.dbg	line,	"include\routines_LEVELS.c", 1281; jump_ladder = FALSE;
 6758                        		__st.umiq	0, _jump_ladder
         01:CB4B  9C 1B 23   			stz	_jump_ladder
 6759                        	
 6760                        		.dbg	line,	"include\routines_LEVELS.c", 1282; jump_max_index = 34;
 6761                        		__st.umiq	34, _jump_max_index
         01:CB4E  A9 22      			lda.l	#34
         01:CB50  8D 1C 23   			sta	_jump_max_index
 6762                        	
 6763                        		.dbg	line,	"include\routines_LEVELS.c", 1283; player_state = STATE_IDLE;
 6764                        		__st.umiq	0, _player_state
         01:CB53  9C 15 23   			stz	_player_state
 6765                        	
 6766                        		.dbg	line,	"include\routines_LEVELS.c", 1284; return;
 6767                        		__bra		.LL180
         01:CB56  4C 58 D6   			bra	.LL180
 6768                        	
 6769                        		.dbg	line,	"include\routines_LEVELS.c", 1285; }
 6770                        	
 6771                        		.dbg	line,	"include\routines_LEVELS.c", 1286; }
 6772    01:CB59             	.LL268:
 6773    01:CB59             	.LL267:
 6774                        	
 6775                        		.dbg	line,	"include\routines_LEVELS.c", 1287; }
 6776                        	
 6777                        		.dbg	line,	"include\routines_LEVELS.c", 1292; //--------------------------------------------------------------------------------------//
 6778                        	
 6779                        		.dbg	line,	"include\routines_LEVELS.c", 1293; //                                   LADDER COLLISION                                   //
 6780                        	
 6781                        		.dbg	line,	"include\routines_LEVELS.c", 1294; //--------------------------------------------------------------------------------------//
 6782                        	
 6783                        		.dbg	line,	"include\routines_LEVELS.c", 1296; if(player_index_jump > 4)
 6784    01:CB59             	.LL258:
 6785                        		__ld.umq	_player_index_jump
         01:CB59  AD 19 23   			lda	_player_index_jump
 6786                        		__ugt_b.uiq	4
         01:CB5C  18         			clc			; Subtract integer+1 from A.
         01:CB5D  E9 04      			sbc	#4		; CS if A > integer.
 6787                        		__bfalse	.LL276
         01:CB5F  B0 03 4C F0			bcc	.LL276
         01:CB63  CB          
 6788                        	
 6789                        		.dbg	line,	"include\routines_LEVELS.c", 1297; {
 6790                        	
 6791                        		.dbg	line,	"include\routines_LEVELS.c", 1298; check_BG( 16 , 16 );
 6792                        		__ld.wi		16
         01:CB64  A9 10      			lda.l	#16
         01:CB66  C2         			cly
 6793                        		__pusharg.wr
         01:CB67  A6 8D      			ldx	<__sp
         01:CB69  CA         			dex
         01:CB6A  CA         			dex
         01:CB6B  95 08      			sta.l	<__stack, x
         01:CB6D  94 09      			sty.h	<__stack, x
         01:CB6F  86 8D      			stx	<__sp
 6794                        		__ld.wi		16
         01:CB71  A9 10      			lda.l	#16
         01:CB73  C2         			cly
 6795                        		__pusharg.wr
         01:CB74  A6 8D      			ldx	<__sp
         01:CB76  CA         			dex
         01:CB77  CA         			dex
         01:CB78  95 08      			sta.l	<__stack, x
         01:CB7A  94 09      			sty.h	<__stack, x
         01:CB7C  86 8D      			stx	<__sp
 6796                        		__call		_check_BG
         01:CB7E  20 6D FF   			call	_check_BG
 6797                        	
 6798                        		.dbg	line,	"include\routines_LEVELS.c", 1300; // IF PLAYER HITS THE LADDER //
 6799                        	
 6800                        		.dbg	line,	"include\routines_LEVELS.c", 1301; if(map_blk_flag == TILE_LADDER)
 6801                        		__ld.umq	_map_blk_flag
         01:CB81  AD A5 2B   			lda	_map_blk_flag
 6802                        		__equ_b.uiq	2
         01:CB84  C9 02      			cmp	#2
         01:CB86  F0 01      			beq	!+
         01:CB88  18         			clc
         01:CB89             	!:
 6803                        		__bfalse	.LL277
         01:CB89  90 65      			bcc	.LL277
 6804                        	
 6805                        		.dbg	line,	"include\routines_LEVELS.c", 1302; {
 6806                        	
 6807                        		.dbg	line,	"include\routines_LEVELS.c", 1303; // CAMERA GOES 8 PX BACKWARD //
 6808                        	
 6809                        		.dbg	line,	"include\routines_LEVELS.c", 1304; sgx_map_pxl_x = ( (sgx_map_pxl_x >> 3) << 3 );
 6810                        		__ld.wm		_sgx_map_pxl_x
         01:CB8B  AD 84 26   			lda.l	_sgx_map_pxl_x
         01:CB8E  AC 85 26   			ldy.h	_sgx_map_pxl_x
 6811                        		__lsr.wi	3
         01:CB91  84 00      			sty	__temp
         01:CB93  20 3A E2   			jsr	lsrw3
 6812                        		__asl.wi	3
         01:CB96  84 00      			sty	__temp
         01:CB98  20 D7 E1   			jsr	aslw3
 6813                        		__st.wmq	_sgx_map_pxl_x
         01:CB9B  8D 84 26   			sta.l	_sgx_map_pxl_x
         01:CB9E  8C 85 26   			sty.h	_sgx_map_pxl_x
 6814                        	
 6815                        		.dbg	line,	"include\routines_LEVELS.c", 1306; // SO WE UPDATE THE MAP //
 6816                        	
 6817                        		.dbg	line,	"include\routines_LEVELS.c", 1307; sgx_scroll_map();
 6818                        		__call		_sgx_scroll_map
         01:CBA1  20 81 FF   			call	_sgx_scroll_map
 6819                        	
 6820                        		.dbg	line,	"include\routines_LEVELS.c", 1309; // CHECK IF THE PLAYER STANDS RIGHT TO THE LADDER //
 6821                        	
 6822                        		.dbg	line,	"include\routines_LEVELS.c", 1310; check_BG( 31 , 16 );
 6823                        		__ld.wi		31
         01:CBA4  A9 1F      			lda.l	#31
         01:CBA6  C2         			cly
 6824                        		__pusharg.wr
         01:CBA7  A6 8D      			ldx	<__sp
         01:CBA9  CA         			dex
         01:CBAA  CA         			dex
         01:CBAB  95 08      			sta.l	<__stack, x
         01:CBAD  94 09      			sty.h	<__stack, x
         01:CBAF  86 8D      			stx	<__sp
 6825                        		__ld.wi		16
         01:CBB1  A9 10      			lda.l	#16
         01:CBB3  C2         			cly
 6826                        		__pusharg.wr
         01:CBB4  A6 8D      			ldx	<__sp
         01:CBB6  CA         			dex
         01:CBB7  CA         			dex
         01:CBB8  95 08      			sta.l	<__stack, x
         01:CBBA  94 09      			sty.h	<__stack, x
         01:CBBC  86 8D      			stx	<__sp
 6827                        		__call		_check_BG
         01:CBBE  20 6D FF   			call	_check_BG
 6828                        	
 6829                        		.dbg	line,	"include\routines_LEVELS.c", 1312; if(map_blk_flag == TILE_LADDER)
 6830                        		__ld.umq	_map_blk_flag
         01:CBC1  AD A5 2B   			lda	_map_blk_flag
 6831                        		__equ_b.uiq	2
         01:CBC4  C9 02      			cmp	#2
         01:CBC6  F0 01      			beq	!+
         01:CBC8  18         			clc
         01:CBC9             	!:
 6832                        		__bfalse	.LL278
         01:CBC9  90 0E      			bcc	.LL278
 6833                        	
 6834                        		.dbg	line,	"include\routines_LEVELS.c", 1313; {
 6835                        	
 6836                        		.dbg	line,	"include\routines_LEVELS.c", 1314; sgx_map_pxl_x += 8;
 6837                        		__add_st.wmiq	8, _sgx_map_pxl_x
         01:CBCB  18         			clc
         01:CBCC  AD 84 26   			lda.l	_sgx_map_pxl_x
         01:CBCF  69 08      			adc.l	#8
         01:CBD1  8D 84 26   			sta.l	_sgx_map_pxl_x
         01:CBD4  90 03      			bcc	!+
         01:CBD6  EE 85 26   			inc.h	_sgx_map_pxl_x
         01:CBD9             	!:
 6838                        	
 6839                        		.dbg	line,	"include\routines_LEVELS.c", 1315; }
 6840                        	
 6841                        		.dbg	line,	"include\routines_LEVELS.c", 1317; player_counter_anim = 1;
 6842    01:CBD9             	.LL278:
 6843                        		__st.umiq	1, _player_counter_anim
         01:CBD9  A9 01      			lda.l	#1
         01:CBDB  8D 18 23   			sta	_player_counter_anim
 6844                        	
 6845                        		.dbg	line,	"include\routines_LEVELS.c", 1318; player_index_jump = 0;
 6846                        		__st.umiq	0, _player_index_jump
         01:CBDE  9C 19 23   			stz	_player_index_jump
 6847                        	
 6848                        		.dbg	line,	"include\routines_LEVELS.c", 1319; jump_ladder = TRUE;
 6849                        		__st.umiq	1, _jump_ladder
         01:CBE1  A9 01      			lda.l	#1
         01:CBE3  8D 1B 23   			sta	_jump_ladder
 6850                        	
 6851                        		.dbg	line,	"include\routines_LEVELS.c", 1320; jump_max_index = 29;
 6852                        		__st.umiq	29, _jump_max_index
         01:CBE6  A9 1D      			lda.l	#29
         01:CBE8  8D 1C 23   			sta	_jump_max_index
 6853                        	
 6854                        		.dbg	line,	"include\routines_LEVELS.c", 1321; player_state = STATE_HANG;
 6855                        		__st.umiq	10, _player_state
         01:CBEB  A9 0A      			lda.l	#10
         01:CBED  8D 15 23   			sta	_player_state
 6856                        	
 6857                        		.dbg	line,	"include\routines_LEVELS.c", 1322; }
 6858                        	
 6859                        		.dbg	line,	"include\routines_LEVELS.c", 1323; }
 6860    01:CBF0             	.LL277:
 6861                        	
 6862                        		.dbg	line,	"include\routines_LEVELS.c", 1326; // SET PLAYER SPRITE NEW POSITION //
 6863                        	
 6864                        		.dbg	line,	"include\routines_LEVELS.c", 1327; spr_y(player_pos_y);
 6865    01:CBF0             	.LL276:
 6866                        		__ld.wm		_player_pos_y
         01:CBF0  AD CA 24   			lda.l	_player_pos_y
         01:CBF3  AC CB 24   			ldy.h	_player_pos_y
 6867                        		__call		_spr_y.1
         01:CBF6  20 19 E8   			call	_spr_y.1
 6868                        	
 6869                        		.dbg	line,	"include\routines_LEVELS.c", 1328; }
 6870                        	
 6871                        		.dbg	line,	"include\routines_LEVELS.c", 1331; else if(player_state == STATE_JUMP_LEFT)
 6872                        		__bra		.LL279
         01:CBF9  4C 58 D6   			bra	.LL279
 6873    01:CBFC             	.LL243:
 6874                        		__ld.umq	_player_state
         01:CBFC  AD 15 23   			lda	_player_state
 6875                        		__equ_b.uiq	6
         01:CBFF  C9 06      			cmp	#6
         01:CC01  F0 01      			beq	!+
         01:CC03  18         			clc
         01:CC04             	!:
 6876                        		__bfalse	.LL280
         01:CC04  B0 03 4C 27			bcc	.LL280
         01:CC08  D0          
 6877                        	
 6878                        		.dbg	line,	"include\routines_LEVELS.c", 1332; {
 6879                        	
 6880                        		.dbg	line,	"include\routines_LEVELS.c", 1333; unsigned char i, camera_y_move;
 6881                        	
 6882                        		.dbg	line,	"include\routines_LEVELS.c", 1334; i = 1;
 6883                        		__st.umiq	1, __update_PLAYER_end - 4  /* i */
         01:CC09  A9 01      			lda.l	#1
         01:CC0B  8D 09 23   			sta	__update_PLAYER_end - 4
 6884                        	
 6885                        		.dbg	line,	"include\routines_LEVELS.c", 1337; // UPDATE PLAYER TILES //
 6886                        	
 6887                        		.dbg	line,	"include\routines_LEVELS.c", 1338; if(player_counter_anim == 0)
 6888                        		__not.um	_player_counter_anim
         01:CC0E  AD 18 23   			lda	_player_counter_anim
         01:CC11  18         			clc
         01:CC12  D0 01      			bne	!+
         01:CC14  38         			sec
         01:CC15             	!:
 6889                        		__bfalse	.LL281
         01:CC15  90 21      			bcc	.LL281
 6890                        	
 6891                        		.dbg	line,	"include\routines_LEVELS.c", 1339; {
 6892                        	
 6893                        		.dbg	line,	"include\routines_LEVELS.c", 1340; load_vram(PLAYER_VRAM_ADR, tiles_SPR_PLAYER + TILES_112 , TILES_16);
 6894                        		__st.wmiq	6144, _di
         01:CC17  64 F0      			stz.l	_di
         01:CC19  A9 18      			lda.h	#6144
         01:CC1B  85 F1      			sta.h	_di
 6895                        		__farptr	_tiles_SPR_PLAYER + 3584, _bp_bank, _bp
         01:CC1D  A9 E0      			lda.l	#$6000 + ($1FFF & (_tiles_SPR_PLAYER + 3584))
         01:CC1F  85 EC      			sta.l	_bp
         01:CC21  A9 77      			lda.h	#$6000 + ($1FFF & (_tiles_SPR_PLAYER + 3584))
         01:CC23  85 ED      			sta.h	_bp
         01:CC25  A9 0E      			lda	#bank(_tiles_SPR_PLAYER + 3584)
         01:CC27  85 02      			sta	_bp_bank
 6896                        		__st.wmiq	256, _ax
         01:CC29  64 F8      			stz.l	_ax
         01:CC2B  A9 01      			lda.h	#256
         01:CC2D  85 F9      			sta.h	_ax
 6897                        		 _load_vram.3
         01:CC2F  82         			clx				; Offset to PCE VDC.
         01:CC30  20 63 FF   			call	load_vram_x
 6898                        	
 6899                        		.dbg	line,	"include\routines_LEVELS.c", 1342; player_counter_anim = 1;
 6900                        		__st.umiq	1, _player_counter_anim
         01:CC33  A9 01      			lda.l	#1
         01:CC35  8D 18 23   			sta	_player_counter_anim
 6901                        	
 6902                        		.dbg	line,	"include\routines_LEVELS.c", 1343; }
 6903                        	
 6904                        		.dbg	line,	"include\routines_LEVELS.c", 1346; // SELECT PLAYER SPRITE //
 6905                        	
 6906                        		.dbg	line,	"include\routines_LEVELS.c", 1347; spr_set(player_id);
 6907    01:CC38             	.LL281:
 6908                        		__ld.umq	_player_id
         01:CC38  AD 14 23   			lda	_player_id
 6909                        		__call		_spr_set.1
         01:CC3B  20 DD E7   			call	_spr_set.1
 6910                        	
 6911                        		.dbg	line,	"include\routines_LEVELS.c", 1350; //**************************************************************************************//
 6912                        	
 6913                        		.dbg	line,	"include\routines_LEVELS.c", 1351; //                                        H MOVE                                        //
 6914                        	
 6915                        		.dbg	line,	"include\routines_LEVELS.c", 1352; //**************************************************************************************//
 6916                        	
 6917                        		.dbg	line,	"include\routines_LEVELS.c", 1354; //--------------------------------------------------------------------------------------//
 6918                        	
 6919                        		.dbg	line,	"include\routines_LEVELS.c", 1355; //                                    WALL COLLISION                                    //
 6920                        	
 6921                        		.dbg	line,	"include\routines_LEVELS.c", 1356; //--------------------------------------------------------------------------------------//
 6922                        	
 6923                        		.dbg	line,	"include\routines_LEVELS.c", 1358; // CHECK COLLISION WITH BOTTOM LEFT WALL //
 6924                        	
 6925                        		.dbg	line,	"include\routines_LEVELS.c", 1359; check_BG( 8 , 31 );
 6926                        		__ld.wi		8
         01:CC3E  A9 08      			lda.l	#8
         01:CC40  C2         			cly
 6927                        		__pusharg.wr
         01:CC41  A6 8D      			ldx	<__sp
         01:CC43  CA         			dex
         01:CC44  CA         			dex
         01:CC45  95 08      			sta.l	<__stack, x
         01:CC47  94 09      			sty.h	<__stack, x
         01:CC49  86 8D      			stx	<__sp
 6928                        		__ld.wi		31
         01:CC4B  A9 1F      			lda.l	#31
         01:CC4D  C2         			cly
 6929                        		__pusharg.wr
         01:CC4E  A6 8D      			ldx	<__sp
         01:CC50  CA         			dex
         01:CC51  CA         			dex
         01:CC52  95 08      			sta.l	<__stack, x
         01:CC54  94 09      			sty.h	<__stack, x
         01:CC56  86 8D      			stx	<__sp
 6930                        		__call		_check_BG
         01:CC58  20 6D FF   			call	_check_BG
 6931                        	
 6932                        		.dbg	line,	"include\routines_LEVELS.c", 1361; if(map_blk_flag != TILE_BG)
 6933                        		__ld.umq	_map_blk_flag
         01:CC5B  AD A5 2B   			lda	_map_blk_flag
 6934                        		__neq_b.uiq	1
         01:CC5E  38         			sec
         01:CC5F  49 01      			eor	#1
         01:CC61  D0 01      			bne	!+
         01:CC63  18         			clc
         01:CC64             	!:
 6935                        		__bfalse	.LL282
         01:CC64  90 78      			bcc	.LL282
 6936                        	
 6937                        		.dbg	line,	"include\routines_LEVELS.c", 1362; {
 6938                        	
 6939                        		.dbg	line,	"include\routines_LEVELS.c", 1363; // CHECK COLLISION WITH TOP RIGHT WALL //
 6940                        	
 6941                        		.dbg	line,	"include\routines_LEVELS.c", 1364; check_BG( 8 , 15 );
 6942                        		__ld.wi		8
         01:CC66  A9 08      			lda.l	#8
         01:CC68  C2         			cly
 6943                        		__pusharg.wr
         01:CC69  A6 8D      			ldx	<__sp
         01:CC6B  CA         			dex
         01:CC6C  CA         			dex
         01:CC6D  95 08      			sta.l	<__stack, x
         01:CC6F  94 09      			sty.h	<__stack, x
         01:CC71  86 8D      			stx	<__sp
 6944                        		__ld.wi		15
         01:CC73  A9 0F      			lda.l	#15
         01:CC75  C2         			cly
 6945                        		__pusharg.wr
         01:CC76  A6 8D      			ldx	<__sp
         01:CC78  CA         			dex
         01:CC79  CA         			dex
         01:CC7A  95 08      			sta.l	<__stack, x
         01:CC7C  94 09      			sty.h	<__stack, x
         01:CC7E  86 8D      			stx	<__sp
 6946                        		__call		_check_BG
         01:CC80  20 6D FF   			call	_check_BG
 6947                        	
 6948                        		.dbg	line,	"include\routines_LEVELS.c", 1366; if(map_blk_flag == TILE_BG)
 6949                        		__ld.umq	_map_blk_flag
         01:CC83  AD A5 2B   			lda	_map_blk_flag
 6950                        		__equ_b.uiq	1
         01:CC86  C9 01      			cmp	#1
         01:CC88  F0 01      			beq	!+
         01:CC8A  18         			clc
         01:CC8B             	!:
 6951                        		__bfalse	.LL283
         01:CC8B  90 41      			bcc	.LL283
 6952                        	
 6953                        		.dbg	line,	"include\routines_LEVELS.c", 1367; {
 6954                        	
 6955                        		.dbg	line,	"include\routines_LEVELS.c", 1368; check_TILE_DEPTH( 15 , -16 );
 6956                        		__ld.wi		15
         01:CC8D  A9 0F      			lda.l	#15
         01:CC8F  C2         			cly
 6957                        		__pusharg.wr
         01:CC90  A6 8D      			ldx	<__sp
         01:CC92  CA         			dex
         01:CC93  CA         			dex
         01:CC94  95 08      			sta.l	<__stack, x
         01:CC96  94 09      			sty.h	<__stack, x
         01:CC98  86 8D      			stx	<__sp
 6958                        		__ld.wi		-16
         01:CC9A  A9 F0      			lda.l	#-16
         01:CC9C  A0 FF      			ldy.h	#-16
 6959                        		__pusharg.wr
         01:CC9E  A6 8D      			ldx	<__sp
         01:CCA0  CA         			dex
         01:CCA1  CA         			dex
         01:CCA2  95 08      			sta.l	<__stack, x
         01:CCA4  94 09      			sty.h	<__stack, x
         01:CCA6  86 8D      			stx	<__sp
 6960                        		__call		_check_TILE_DEPTH
         01:CCA8  20 4F FF   			call	_check_TILE_DEPTH
 6961                        	
 6962                        		.dbg	line,	"include\routines_LEVELS.c", 1370; if(map_blk_flag == TILE_EMPTY && jump_ladder == TRUE)
 6963                        		__not.um	_map_blk_flag
         01:CCAB  AD A5 2B   			lda	_map_blk_flag
         01:CCAE  18         			clc
         01:CCAF  D0 01      			bne	!+
         01:CCB1  38         			sec
         01:CCB2             	!:
 6964                        		__bfalse	.LL285
         01:CCB2  90 08      			bcc	.LL285
 6965                        		__ld.umq	_jump_ladder
         01:CCB4  AD 1B 23   			lda	_jump_ladder
 6966                        		__equ_b.uiq	1
         01:CCB7  C9 01      			cmp	#1
         01:CCB9  F0 01      			beq	!+
         01:CCBB  18         			clc
         01:CCBC             	!:
 6967    01:CCBC             	.LL285:
 6968                        		__bfalse	.LL284
         01:CCBC  90 5F      			bcc	.LL284
 6969                        	
 6970                        		.dbg	line,	"include\routines_LEVELS.c", 1371; {
 6971                        	
 6972                        		.dbg	line,	"include\routines_LEVELS.c", 1372; jump_ladder = FALSE;
 6973                        		__st.umiq	0, _jump_ladder
         01:CCBE  9C 1B 23   			stz	_jump_ladder
 6974                        	
 6975                        		.dbg	line,	"include\routines_LEVELS.c", 1373; player_index_fall = 0;
 6976                        		__st.umiq	0, _player_index_fall
         01:CCC1  9C 1A 23   			stz	_player_index_fall
 6977                        	
 6978                        		.dbg	line,	"include\routines_LEVELS.c", 1374; player_state = STATE_FALL;
 6979                        		__st.umiq	9, _player_state
         01:CCC4  A9 09      			lda.l	#9
         01:CCC6  8D 15 23   			sta	_player_state
 6980                        	
 6981                        		.dbg	line,	"include\routines_LEVELS.c", 1375; return;
 6982                        		__bra		.LL180
         01:CCC9  4C 58 D6   			bra	.LL180
 6983                        	
 6984                        		.dbg	line,	"include\routines_LEVELS.c", 1376; }
 6985                        	
 6986                        		.dbg	line,	"include\routines_LEVELS.c", 1377; }
 6987    01:CCCC             	.LL284	.alias		.LL286
 6988                        	
 6989                        		.dbg	line,	"include\routines_LEVELS.c", 1379; else
 6990                        		__bra		.LL286
         01:CCCC  80 4F      			bra	.LL286
 6991    01:CCCE             	.LL283:
 6992                        	
 6993                        		.dbg	line,	"include\routines_LEVELS.c", 1380; {
 6994                        	
 6995                        		.dbg	line,	"include\routines_LEVELS.c", 1381; sgx_map_pxl_x -= 2;
 6996                        		__sub_st.wmiq	2, _sgx_map_pxl_x
         01:CCCE  38         			sec
         01:CCCF  AD 84 26   			lda.l	_sgx_map_pxl_x
         01:CCD2  E9 02      			sbc.l	#2
         01:CCD4  8D 84 26   			sta.l	_sgx_map_pxl_x
         01:CCD7  B0 03      			bcs	!+
         01:CCD9  CE 85 26   			dec.h	_sgx_map_pxl_x
         01:CCDC             	!:
 6997                        	
 6998                        		.dbg	line,	"include\routines_LEVELS.c", 1382; }
 6999    01:CCDC             	.LL286	.alias		.LL287
 7000                        	
 7001                        		.dbg	line,	"include\routines_LEVELS.c", 1383; }
 7002                        	
 7003                        		.dbg	line,	"include\routines_LEVELS.c", 1385; else
 7004                        		__bra		.LL287
         01:CCDC  80 3F      			bra	.LL287
 7005    01:CCDE             	.LL282:
 7006                        	
 7007                        		.dbg	line,	"include\routines_LEVELS.c", 1386; {
 7008                        	
 7009                        		.dbg	line,	"include\routines_LEVELS.c", 1387; check_TILE_DEPTH( 15 , -16 );
 7010                        		__ld.wi		15
         01:CCDE  A9 0F      			lda.l	#15
         01:CCE0  C2         			cly
 7011                        		__pusharg.wr
         01:CCE1  A6 8D      			ldx	<__sp
         01:CCE3  CA         			dex
         01:CCE4  CA         			dex
         01:CCE5  95 08      			sta.l	<__stack, x
         01:CCE7  94 09      			sty.h	<__stack, x
         01:CCE9  86 8D      			stx	<__sp
 7012                        		__ld.wi		-16
         01:CCEB  A9 F0      			lda.l	#-16
         01:CCED  A0 FF      			ldy.h	#-16
 7013                        		__pusharg.wr
         01:CCEF  A6 8D      			ldx	<__sp
         01:CCF1  CA         			dex
         01:CCF2  CA         			dex
         01:CCF3  95 08      			sta.l	<__stack, x
         01:CCF5  94 09      			sty.h	<__stack, x
         01:CCF7  86 8D      			stx	<__sp
 7014                        		__call		_check_TILE_DEPTH
         01:CCF9  20 4F FF   			call	_check_TILE_DEPTH
 7015                        	
 7016                        		.dbg	line,	"include\routines_LEVELS.c", 1389; if(map_blk_flag == TILE_EMPTY && jump_ladder == TRUE)
 7017                        		__not.um	_map_blk_flag
         01:CCFC  AD A5 2B   			lda	_map_blk_flag
         01:CCFF  18         			clc
         01:CD00  D0 01      			bne	!+
         01:CD02  38         			sec
         01:CD03             	!:
 7018                        		__bfalse	.LL289
         01:CD03  90 08      			bcc	.LL289
 7019                        		__ld.umq	_jump_ladder
         01:CD05  AD 1B 23   			lda	_jump_ladder
 7020                        		__equ_b.uiq	1
         01:CD08  C9 01      			cmp	#1
         01:CD0A  F0 01      			beq	!+
         01:CD0C  18         			clc
         01:CD0D             	!:
 7021    01:CD0D             	.LL289:
 7022                        		__bfalse	.LL288
         01:CD0D  90 0E      			bcc	.LL288
 7023                        	
 7024                        		.dbg	line,	"include\routines_LEVELS.c", 1390; {
 7025                        	
 7026                        		.dbg	line,	"include\routines_LEVELS.c", 1391; jump_ladder = FALSE;
 7027                        		__st.umiq	0, _jump_ladder
         01:CD0F  9C 1B 23   			stz	_jump_ladder
 7028                        	
 7029                        		.dbg	line,	"include\routines_LEVELS.c", 1392; player_index_fall = 0;
 7030                        		__st.umiq	0, _player_index_fall
         01:CD12  9C 1A 23   			stz	_player_index_fall
 7031                        	
 7032                        		.dbg	line,	"include\routines_LEVELS.c", 1393; player_state = STATE_FALL;
 7033                        		__st.umiq	9, _player_state
         01:CD15  A9 09      			lda.l	#9
         01:CD17  8D 15 23   			sta	_player_state
 7034                        	
 7035                        		.dbg	line,	"include\routines_LEVELS.c", 1394; return;
 7036                        		__bra		.LL180
         01:CD1A  4C 58 D6   			bra	.LL180
 7037                        	
 7038                        		.dbg	line,	"include\routines_LEVELS.c", 1395; }
 7039                        	
 7040                        		.dbg	line,	"include\routines_LEVELS.c", 1396; }
 7041    01:CD1D             	.LL288:
 7042    01:CD1D             	.LL287:
 7043                        	
 7044                        		.dbg	line,	"include\routines_LEVELS.c", 1401; //**************************************************************************************//
 7045                        	
 7046                        		.dbg	line,	"include\routines_LEVELS.c", 1402; //                                        V MOVE                                        //
 7047                        	
 7048                        		.dbg	line,	"include\routines_LEVELS.c", 1403; //**************************************************************************************//
 7049                        	
 7050                        		.dbg	line,	"include\routines_LEVELS.c", 1405; // UPDATE PLAYER Y POSITION //
 7051                        	
 7052                        		.dbg	line,	"include\routines_LEVELS.c", 1406; if(jump_ladder == FALSE)
 7053                        		__not.um	_jump_ladder
         01:CD1D  AD 1B 23   			lda	_jump_ladder
         01:CD20  18         			clc
         01:CD21  D0 01      			bne	!+
         01:CD23  38         			sec
         01:CD24             	!:
 7054                        		__bfalse	.LL290
         01:CD24  90 1A      			bcc	.LL290
 7055                        	
 7056                        		.dbg	line,	"include\routines_LEVELS.c", 1407; {
 7057                        	
 7058                        		.dbg	line,	"include\routines_LEVELS.c", 1408; player_pos_y += TABLE_PLAYER_JUMP_V[player_index_jump];
 7059                        		__ldx.umq	_player_index_jump
         01:CD26  AE 19 23   			ldx	_player_index_jump
 7060                        		__ld.bax	_TABLE_PLAYER_JUMP_V
         01:CD29  BD A2 60   			lda	_TABLE_PLAYER_JUMP_V, x
         01:CD2C  C2         			cly
         01:CD2D  10 01      			bpl	!+
         01:CD2F  88         			dey
         01:CD30             	!:
 7061                        		__add_st.wmq	_player_pos_y
         01:CD30  18         			clc
         01:CD31  6D CA 24   			adc.l	_player_pos_y
         01:CD34  8D CA 24   			sta.l	_player_pos_y
         01:CD37  98         			tya
         01:CD38  6D CB 24   			adc.h	_player_pos_y
         01:CD3B  8D CB 24   			sta.h	_player_pos_y
 7062                        	
 7063                        		.dbg	line,	"include\routines_LEVELS.c", 1409; }
 7064                        	
 7065                        		.dbg	line,	"include\routines_LEVELS.c", 1411; else
 7066                        		__bra		.LL291
         01:CD3E  80 18      			bra	.LL291
 7067    01:CD40             	.LL290:
 7068                        	
 7069                        		.dbg	line,	"include\routines_LEVELS.c", 1412; {
 7070                        	
 7071                        		.dbg	line,	"include\routines_LEVELS.c", 1413; player_pos_y += TABLE_PLAYER_JUMP_LADDER[player_index_jump];
 7072                        		__ldx.umq	_player_index_jump
         01:CD40  AE 19 23   			ldx	_player_index_jump
 7073                        		__ld.bax	_TABLE_PLAYER_JUMP_LADDER
         01:CD43  BD DA 60   			lda	_TABLE_PLAYER_JUMP_LADDER, x
         01:CD46  C2         			cly
         01:CD47  10 01      			bpl	!+
         01:CD49  88         			dey
         01:CD4A             	!:
 7074                        		__add_st.wmq	_player_pos_y
         01:CD4A  18         			clc
         01:CD4B  6D CA 24   			adc.l	_player_pos_y
         01:CD4E  8D CA 24   			sta.l	_player_pos_y
         01:CD51  98         			tya
         01:CD52  6D CB 24   			adc.h	_player_pos_y
         01:CD55  8D CB 24   			sta.h	_player_pos_y
 7075                        	
 7076                        		.dbg	line,	"include\routines_LEVELS.c", 1414; }
 7077    01:CD58             	.LL291:
 7078                        	
 7079                        		.dbg	line,	"include\routines_LEVELS.c", 1417; // IF PLAYER GOES BELOW ITS BASE Y POSITION //
 7080                        	
 7081                        		.dbg	line,	"include\routines_LEVELS.c", 1418; if(player_pos_y >= PLAYER_BASE_Y_POS)
 7082                        		__ld.wm		_player_pos_y
         01:CD58  AD CA 24   			lda.l	_player_pos_y
         01:CD5B  AC CB 24   			ldy.h	_player_pos_y
 7083                        		__sge_w.wi	128
         01:CD5E  C9 80      			cmp.l	#128		; Subtract integer from Y:A.
         01:CD60  98         			tya
         01:CD61  E9 00      			sbc.h	#128
         01:CD63  50 02      			bvc	!+
         01:CD65  49 80      			eor	#$80		; +ve if Y:A >= integer (signed).
         01:CD67  49 80      	!:		eor	#$80
         01:CD69  0A         			asl	a
 7084                        		__bfalse	.LL292
         01:CD6A  90 4E      			bcc	.LL292
 7085                        	
 7086                        		.dbg	line,	"include\routines_LEVELS.c", 1419; {
 7087                        	
 7088                        		.dbg	line,	"include\routines_LEVELS.c", 1420; // THE CAMERA MOVES //
 7089                        	
 7090                        		.dbg	line,	"include\routines_LEVELS.c", 1421; // CALCULATE HOW MANY PIXELS THE CAMERA HAS TO MOVE DOWN //
 7091                        	
 7092                        		.dbg	line,	"include\routines_LEVELS.c", 1422; camera_y_move = player_pos_y - PLAYER_BASE_Y_POS;
 7093                        		__ld.wm		_player_pos_y
         01:CD6C  AD CA 24   			lda.l	_player_pos_y
         01:CD6F  AC CB 24   			ldy.h	_player_pos_y
 7094                        		__sub.wi	128
         01:CD72  38         			sec
         01:CD73  E9 80      			sbc.l	#128
         01:CD75  B0 01      			bcs	!+
         01:CD77  88         			dey
         01:CD78             	!:
 7095                        		__st.umq	__update_PLAYER_end - 5  /* camera_y_move */
         01:CD78  8D 08 23   			sta	__update_PLAYER_end - 5
 7096                        	
 7097                        		.dbg	line,	"include\routines_LEVELS.c", 1423; sgx_map_pxl_y += camera_y_move;
 7098                        		__ld.um		__update_PLAYER_end - 5  /* camera_y_move */
         01:CD7B  AD 08 23   			lda	__update_PLAYER_end - 5
         01:CD7E  C2         			cly
 7099                        		__add_st.wmq	_sgx_map_pxl_y
         01:CD7F  18         			clc
         01:CD80  6D 86 26   			adc.l	_sgx_map_pxl_y
         01:CD83  8D 86 26   			sta.l	_sgx_map_pxl_y
         01:CD86  98         			tya
         01:CD87  6D 87 26   			adc.h	_sgx_map_pxl_y
         01:CD8A  8D 87 26   			sta.h	_sgx_map_pxl_y
 7100                        	
 7101                        		.dbg	line,	"include\routines_LEVELS.c", 1425; // IF THE CAMERA HAS REACHED ITS MAX (LOWEST) POSITION //
 7102                        	
 7103                        		.dbg	line,	"include\routines_LEVELS.c", 1426; if(sgx_map_pxl_y > camera_max_y_position)
 7104                        		__ld.wm		_sgx_map_pxl_y
         01:CD8D  AD 86 26   			lda.l	_sgx_map_pxl_y
         01:CD90  AC 87 26   			ldy.h	_sgx_map_pxl_y
 7105                        		__ugt_w.wm	_camera_max_y_position
         01:CD93  18         			clc			; Subtract memory+1 from Y:A.
         01:CD94  ED CC 24   			sbc.l	_camera_max_y_position
         01:CD97  98         			tya
         01:CD98  ED CD 24   			sbc.h	_camera_max_y_position		; CS if Y:A > memory.
 7106                        		__bfalse	.LL293
         01:CD9B  90 0C      			bcc	.LL293
 7107                        	
 7108                        		.dbg	line,	"include\routines_LEVELS.c", 1427; {
 7109                        	
 7110                        		.dbg	line,	"include\routines_LEVELS.c", 1428; // THE CAMERA CAN NOT MOVE LOWER //
 7111                        	
 7112                        		.dbg	line,	"include\routines_LEVELS.c", 1429; sgx_map_pxl_y = camera_max_y_position;
 7113                        		__ld.wm		_camera_max_y_position
         01:CD9D  AD CC 24   			lda.l	_camera_max_y_position
         01:CDA0  AC CD 24   			ldy.h	_camera_max_y_position
 7114                        		__st.wmq	_sgx_map_pxl_y
         01:CDA3  8D 86 26   			sta.l	_sgx_map_pxl_y
         01:CDA6  8C 87 26   			sty.h	_sgx_map_pxl_y
 7115                        	
 7116                        		.dbg	line,	"include\routines_LEVELS.c", 1430; }
 7117                        	
 7118                        		.dbg	line,	"include\routines_LEVELS.c", 1432; // THE PLAYER STAYS AT ITS BASE Y POSITION //
 7119                        	
 7120                        		.dbg	line,	"include\routines_LEVELS.c", 1433; player_pos_y = PLAYER_BASE_Y_POS;
 7121    01:CDA9             	.LL293:
 7122                        		__st.wmiq	128, _player_pos_y
         01:CDA9  A9 80      			lda.l	#128
         01:CDAB  8D CA 24   			sta.l	_player_pos_y
         01:CDAE  9C CB 24   			stz.h	_player_pos_y
 7123                        	
 7124                        		.dbg	line,	"include\routines_LEVELS.c", 1435; spr_y(player_pos_y);
 7125                        		__ld.wm		_player_pos_y
         01:CDB1  AD CA 24   			lda.l	_player_pos_y
         01:CDB4  AC CB 24   			ldy.h	_player_pos_y
 7126                        		__call		_spr_y.1
         01:CDB7  20 19 E8   			call	_spr_y.1
 7127                        	
 7128                        		.dbg	line,	"include\routines_LEVELS.c", 1436; }
 7129                        	
 7130                        		.dbg	line,	"include\routines_LEVELS.c", 1439; // UPDATE JUMP INDEX IN THE ARRAY //
 7131                        	
 7132                        		.dbg	line,	"include\routines_LEVELS.c", 1440; if(player_index_jump < jump_max_index)
 7133    01:CDBA             	.LL292:
 7134                        		__ld.umq	_player_index_jump
         01:CDBA  AD 19 23   			lda	_player_index_jump
 7135                        		__ult_b.umq	_jump_max_index
         01:CDBD  CD 1C 23   			cmp	_jump_max_index		; Subtract memory from A.
         01:CDC0  6A         			ror	a		; CC if A < memory.
         01:CDC1  49 80      			eor	#$80
         01:CDC3  2A         			rol	a
 7136                        		__bfalse	.LL294
         01:CDC4  90 03      			bcc	.LL294
 7137                        	
 7138                        		.dbg	line,	"include\routines_LEVELS.c", 1441; {
 7139                        	
 7140                        		.dbg	line,	"include\routines_LEVELS.c", 1442; player_index_jump += 1;
 7141                        		__add_st.umiq	1, _player_index_jump
         01:CDC6  EE 19 23   			inc	_player_index_jump
 7142                        	
 7143                        		.dbg	line,	"include\routines_LEVELS.c", 1443; }
 7144                        	
 7145                        		.dbg	line,	"include\routines_LEVELS.c", 1448; //--------------------------------------------------------------------------------------//
 7146                        	
 7147                        		.dbg	line,	"include\routines_LEVELS.c", 1449; //                                   FLOOR COLLISION                                    //
 7148                        	
 7149                        		.dbg	line,	"include\routines_LEVELS.c", 1450; //--------------------------------------------------------------------------------------//
 7150                        	
 7151                        		.dbg	line,	"include\routines_LEVELS.c", 1452; if(player_index_jump > 14)
 7152    01:CDC9             	.LL294:
 7153                        		__ld.umq	_player_index_jump
         01:CDC9  AD 19 23   			lda	_player_index_jump
 7154                        		__ugt_b.uiq	14
         01:CDCC  18         			clc			; Subtract integer+1 from A.
         01:CDCD  E9 0E      			sbc	#14		; CS if A > integer.
 7155                        		__bfalse	.LL295
         01:CDCF  B0 03 4C 84			bcc	.LL295
         01:CDD3  CF          
 7156                        	
 7157                        		.dbg	line,	"include\routines_LEVELS.c", 1453; {
 7158                        	
 7159                        		.dbg	line,	"include\routines_LEVELS.c", 1454; // CHECK COLLISION WITH LEFT FLOOR //
 7160                        	
 7161                        		.dbg	line,	"include\routines_LEVELS.c", 1455; check_BG( 10 , 32 );
 7162                        		__ld.wi		10
         01:CDD4  A9 0A      			lda.l	#10
         01:CDD6  C2         			cly
 7163                        		__pusharg.wr
         01:CDD7  A6 8D      			ldx	<__sp
         01:CDD9  CA         			dex
         01:CDDA  CA         			dex
         01:CDDB  95 08      			sta.l	<__stack, x
         01:CDDD  94 09      			sty.h	<__stack, x
         01:CDDF  86 8D      			stx	<__sp
 7164                        		__ld.wi		32
         01:CDE1  A9 20      			lda.l	#32
         01:CDE3  C2         			cly
 7165                        		__pusharg.wr
         01:CDE4  A6 8D      			ldx	<__sp
         01:CDE6  CA         			dex
         01:CDE7  CA         			dex
         01:CDE8  95 08      			sta.l	<__stack, x
         01:CDEA  94 09      			sty.h	<__stack, x
         01:CDEC  86 8D      			stx	<__sp
 7166                        		__call		_check_BG
         01:CDEE  20 6D FF   			call	_check_BG
 7167                        	
 7168                        		.dbg	line,	"include\routines_LEVELS.c", 1457; if(map_blk_flag == TILE_BG)
 7169                        		__ld.umq	_map_blk_flag
         01:CDF1  AD A5 2B   			lda	_map_blk_flag
 7170                        		__equ_b.uiq	1
         01:CDF4  C9 01      			cmp	#1
         01:CDF6  F0 01      			beq	!+
         01:CDF8  18         			clc
         01:CDF9             	!:
 7171                        		__bfalse	.LL296
         01:CDF9  B0 03 4C AC			bcc	.LL296
         01:CDFD  CE          
 7172                        	
 7173                        		.dbg	line,	"include\routines_LEVELS.c", 1458; {
 7174                        	
 7175                        		.dbg	line,	"include\routines_LEVELS.c", 1459; // CALCULATE HOW MANY PIXELS THE PLAYER MOVED INTO THE GROUND //
 7176                        	
 7177                        		.dbg	line,	"include\routines_LEVELS.c", 1460; for(i=1; i<11 ; i++)
 7178                        		__st.umiq	1, __update_PLAYER_end - 4  /* i */
         01:CDFE  A9 01      			lda.l	#1
         01:CE00  8D 09 23   			sta	__update_PLAYER_end - 4
 7179    01:CE03             	.LL297:
 7180                        		__ld.umq	__update_PLAYER_end - 4  /* i */
         01:CE03  AD 09 23   			lda	__update_PLAYER_end - 4
 7181                        		__ult_b.uiq	11
         01:CE06  C9 0B      			cmp	#11		; Subtract integer from A.
         01:CE08  6A         			ror	a		; CC if A < integer.
         01:CE09  49 80      			eor	#$80
         01:CE0B  2A         			rol	a
 7182                        		__btrue		.LL299
         01:CE0C  B0 07      			bcs	.LL299
 7183                        		__bra		.LL300
         01:CE0E  80 7D      			bra	.LL300
 7184    01:CE10             	.LL298:
 7185                        		__inc.umq	__update_PLAYER_end - 4  /* i */
         01:CE10  EE 09 23   			inc	__update_PLAYER_end - 4
 7186                        		__bra		.LL297
         01:CE13  80 EE      			bra	.LL297
 7187    01:CE15             	.LL299:
 7188                        	
 7189                        		.dbg	line,	"include\routines_LEVELS.c", 1461; {
 7190                        	
 7191                        		.dbg	line,	"include\routines_LEVELS.c", 1462; check_TILE_DEPTH( 10 , i);
 7192                        		__ld.wi		10
         01:CE15  A9 0A      			lda.l	#10
         01:CE17  C2         			cly
 7193                        		__pusharg.wr
         01:CE18  A6 8D      			ldx	<__sp
         01:CE1A  CA         			dex
         01:CE1B  CA         			dex
         01:CE1C  95 08      			sta.l	<__stack, x
         01:CE1E  94 09      			sty.h	<__stack, x
         01:CE20  86 8D      			stx	<__sp
 7194                        		__ld.um		__update_PLAYER_end - 4  /* i */
         01:CE22  AD 09 23   			lda	__update_PLAYER_end - 4
         01:CE25  C2         			cly
 7195                        		__pusharg.wr
         01:CE26  A6 8D      			ldx	<__sp
         01:CE28  CA         			dex
         01:CE29  CA         			dex
         01:CE2A  95 08      			sta.l	<__stack, x
         01:CE2C  94 09      			sty.h	<__stack, x
         01:CE2E  86 8D      			stx	<__sp
 7196                        		__call		_check_TILE_DEPTH
         01:CE30  20 4F FF   			call	_check_TILE_DEPTH
 7197                        	
 7198                        		.dbg	line,	"include\routines_LEVELS.c", 1464; if(map_blk_flag == TILE_EMPTY)
 7199                        		__not.um	_map_blk_flag
         01:CE33  AD A5 2B   			lda	_map_blk_flag
         01:CE36  18         			clc
         01:CE37  D0 01      			bne	!+
         01:CE39  38         			sec
         01:CE3A             	!:
 7200                        		__bfalse	.LL301
         01:CE3A  90 D4      			bcc	.LL301
 7201                        	
 7202                        		.dbg	line,	"include\routines_LEVELS.c", 1465; {
 7203                        	
 7204                        		.dbg	line,	"include\routines_LEVELS.c", 1466; if(player_pos_y != PLAYER_BASE_Y_POS)
 7205                        		__ld.wm		_player_pos_y
         01:CE3C  AD CA 24   			lda.l	_player_pos_y
         01:CE3F  AC CB 24   			ldy.h	_player_pos_y
 7206                        		__neq_w.wi	128
         01:CE42  38         			sec
         01:CE43  49 80      			eor.l	#128
         01:CE45  D0 06      			bne	!+
         01:CE47  98         			tya
         01:CE48  49 00      			eor.h	#128
         01:CE4A  D0 01      			bne	!+
         01:CE4C  18         			clc
         01:CE4D             	!:
 7207                        		__bfalse	.LL302
         01:CE4D  90 1E      			bcc	.LL302
 7208                        	
 7209                        		.dbg	line,	"include\routines_LEVELS.c", 1467; {
 7210                        	
 7211                        		.dbg	line,	"include\routines_LEVELS.c", 1468; player_pos_y -= (i - 1);
 7212                        		__ld.um		__update_PLAYER_end - 4  /* i */
         01:CE4F  AD 09 23   			lda	__update_PLAYER_end - 4
         01:CE52  C2         			cly
 7213                        		__sub.wi	1
         01:CE53  38         			sec
         01:CE54  E9 01      			sbc.l	#1
         01:CE56  B0 01      			bcs	!+
         01:CE58  88         			dey
         01:CE59             	!:
 7214                        		__isub_st.wmq	_player_pos_y
         01:CE59  38         			sec
         01:CE5A  49 FF      			eor	#$FF
         01:CE5C  6D CA 24   			adc.l	_player_pos_y
         01:CE5F  8D CA 24   			sta.l	_player_pos_y
         01:CE62  98         			tya
         01:CE63  49 FF      			eor	#$FF
         01:CE65  6D CB 24   			adc.h	_player_pos_y
         01:CE68  8D CB 24   			sta.h	_player_pos_y
 7215                        	
 7216                        		.dbg	line,	"include\routines_LEVELS.c", 1469; }
 7217                        	
 7218                        		.dbg	line,	"include\routines_LEVELS.c", 1471; else
 7219                        		__bra		.LL303
         01:CE6B  80 20      			bra	.LL303
 7220    01:CE6D             	.LL302:
 7221                        	
 7222                        		.dbg	line,	"include\routines_LEVELS.c", 1472; {
 7223                        	
 7224                        		.dbg	line,	"include\routines_LEVELS.c", 1473; sgx_map_pxl_y -= (i - 1);
 7225                        		__ld.um		__update_PLAYER_end - 4  /* i */
         01:CE6D  AD 09 23   			lda	__update_PLAYER_end - 4
         01:CE70  C2         			cly
 7226                        		__sub.wi	1
         01:CE71  38         			sec
         01:CE72  E9 01      			sbc.l	#1
         01:CE74  B0 01      			bcs	!+
         01:CE76  88         			dey
         01:CE77             	!:
 7227                        		__isub_st.wmq	_sgx_map_pxl_y
         01:CE77  38         			sec
         01:CE78  49 FF      			eor	#$FF
         01:CE7A  6D 86 26   			adc.l	_sgx_map_pxl_y
         01:CE7D  8D 86 26   			sta.l	_sgx_map_pxl_y
         01:CE80  98         			tya
         01:CE81  49 FF      			eor	#$FF
         01:CE83  6D 87 26   			adc.h	_sgx_map_pxl_y
         01:CE86  8D 87 26   			sta.h	_sgx_map_pxl_y
 7228                        	
 7229                        		.dbg	line,	"include\routines_LEVELS.c", 1474; }
 7230    01:CE89             	.LL303	.alias		.LL300
 7231                        	
 7232                        		.dbg	line,	"include\routines_LEVELS.c", 1476; break;
 7233                        		__bra		.LL300
         01:CE89  80 02      			bra	.LL300
 7234                        	
 7235                        		.dbg	line,	"include\routines_LEVELS.c", 1477; }
 7236                        	
 7237                        		.dbg	line,	"include\routines_LEVELS.c", 1478; }
 7238    01:CE8B             	.LL301	.alias		.LL298
 7239                        		__bra		.LL298
         01:CE8B  80 83      			bra	.LL298
 7240    01:CE8D             	.LL300:
 7241                        	
 7242                        		.dbg	line,	"include\routines_LEVELS.c", 1480; // SET PLAYER SPRITE NEW POSITION //
 7243                        	
 7244                        		.dbg	line,	"include\routines_LEVELS.c", 1481; spr_y(player_pos_y);
 7245                        		__ld.wm		_player_pos_y
         01:CE8D  AD CA 24   			lda.l	_player_pos_y
         01:CE90  AC CB 24   			ldy.h	_player_pos_y
 7246                        		__call		_spr_y.1
         01:CE93  20 19 E8   			call	_spr_y.1
 7247                        	
 7248                        		.dbg	line,	"include\routines_LEVELS.c", 1483; player_counter_anim = 1;
 7249                        		__st.umiq	1, _player_counter_anim
         01:CE96  A9 01      			lda.l	#1
         01:CE98  8D 18 23   			sta	_player_counter_anim
 7250                        	
 7251                        		.dbg	line,	"include\routines_LEVELS.c", 1484; player_index_jump = 0;
 7252                        		__st.umiq	0, _player_index_jump
         01:CE9B  9C 19 23   			stz	_player_index_jump
 7253                        	
 7254                        		.dbg	line,	"include\routines_LEVELS.c", 1485; jump_ladder = FALSE;
 7255                        		__st.umiq	0, _jump_ladder
         01:CE9E  9C 1B 23   			stz	_jump_ladder
 7256                        	
 7257                        		.dbg	line,	"include\routines_LEVELS.c", 1486; jump_max_index = 34;
 7258                        		__st.umiq	34, _jump_max_index
         01:CEA1  A9 22      			lda.l	#34
         01:CEA3  8D 1C 23   			sta	_jump_max_index
 7259                        	
 7260                        		.dbg	line,	"include\routines_LEVELS.c", 1487; player_state = STATE_IDLE;
 7261                        		__st.umiq	0, _player_state
         01:CEA6  9C 15 23   			stz	_player_state
 7262                        	
 7263                        		.dbg	line,	"include\routines_LEVELS.c", 1488; return;
 7264                        		__bra		.LL180
         01:CEA9  4C 58 D6   			bra	.LL180
 7265                        	
 7266                        		.dbg	line,	"include\routines_LEVELS.c", 1489; }
 7267                        	
 7268                        		.dbg	line,	"include\routines_LEVELS.c", 1491; else
 7269    01:CEAC             	.LL296:
 7270                        	
 7271                        		.dbg	line,	"include\routines_LEVELS.c", 1492; {
 7272                        	
 7273                        		.dbg	line,	"include\routines_LEVELS.c", 1493; // CHECK COLLISION WITH RIGHT FLOOR //
 7274                        	
 7275                        		.dbg	line,	"include\routines_LEVELS.c", 1494; check_BG( 22 , 32 );
 7276                        		__ld.wi		22
         01:CEAC  A9 16      			lda.l	#22
         01:CEAE  C2         			cly
 7277                        		__pusharg.wr
         01:CEAF  A6 8D      			ldx	<__sp
         01:CEB1  CA         			dex
         01:CEB2  CA         			dex
         01:CEB3  95 08      			sta.l	<__stack, x
         01:CEB5  94 09      			sty.h	<__stack, x
         01:CEB7  86 8D      			stx	<__sp
 7278                        		__ld.wi		32
         01:CEB9  A9 20      			lda.l	#32
         01:CEBB  C2         			cly
 7279                        		__pusharg.wr
         01:CEBC  A6 8D      			ldx	<__sp
         01:CEBE  CA         			dex
         01:CEBF  CA         			dex
         01:CEC0  95 08      			sta.l	<__stack, x
         01:CEC2  94 09      			sty.h	<__stack, x
         01:CEC4  86 8D      			stx	<__sp
 7280                        		__call		_check_BG
         01:CEC6  20 6D FF   			call	_check_BG
 7281                        	
 7282                        		.dbg	line,	"include\routines_LEVELS.c", 1496; if(map_blk_flag == TILE_BG)
 7283                        		__ld.umq	_map_blk_flag
         01:CEC9  AD A5 2B   			lda	_map_blk_flag
 7284                        		__equ_b.uiq	1
         01:CECC  C9 01      			cmp	#1
         01:CECE  F0 01      			beq	!+
         01:CED0  18         			clc
         01:CED1             	!:
 7285                        		__bfalse	.LL305
         01:CED1  B0 03 4C 84			bcc	.LL305
         01:CED5  CF          
 7286                        	
 7287                        		.dbg	line,	"include\routines_LEVELS.c", 1497; {
 7288                        	
 7289                        		.dbg	line,	"include\routines_LEVELS.c", 1498; // CALCULATE HOW MANY PIXELS THE PLAYER MOVED INTO THE GROUND //
 7290                        	
 7291                        		.dbg	line,	"include\routines_LEVELS.c", 1499; for(i=1; i<11 ; i++)
 7292                        		__st.umiq	1, __update_PLAYER_end - 4  /* i */
         01:CED6  A9 01      			lda.l	#1
         01:CED8  8D 09 23   			sta	__update_PLAYER_end - 4
 7293    01:CEDB             	.LL306:
 7294                        		__ld.umq	__update_PLAYER_end - 4  /* i */
         01:CEDB  AD 09 23   			lda	__update_PLAYER_end - 4
 7295                        		__ult_b.uiq	11
         01:CEDE  C9 0B      			cmp	#11		; Subtract integer from A.
         01:CEE0  6A         			ror	a		; CC if A < integer.
         01:CEE1  49 80      			eor	#$80
         01:CEE3  2A         			rol	a
 7296                        		__btrue		.LL308
         01:CEE4  B0 07      			bcs	.LL308
 7297                        		__bra		.LL309
         01:CEE6  80 7D      			bra	.LL309
 7298    01:CEE8             	.LL307:
 7299                        		__inc.umq	__update_PLAYER_end - 4  /* i */
         01:CEE8  EE 09 23   			inc	__update_PLAYER_end - 4
 7300                        		__bra		.LL306
         01:CEEB  80 EE      			bra	.LL306
 7301    01:CEED             	.LL308:
 7302                        	
 7303                        		.dbg	line,	"include\routines_LEVELS.c", 1500; {
 7304                        	
 7305                        		.dbg	line,	"include\routines_LEVELS.c", 1501; check_TILE_DEPTH( 22 , i);
 7306                        		__ld.wi		22
         01:CEED  A9 16      			lda.l	#22
         01:CEEF  C2         			cly
 7307                        		__pusharg.wr
         01:CEF0  A6 8D      			ldx	<__sp
         01:CEF2  CA         			dex
         01:CEF3  CA         			dex
         01:CEF4  95 08      			sta.l	<__stack, x
         01:CEF6  94 09      			sty.h	<__stack, x
         01:CEF8  86 8D      			stx	<__sp
 7308                        		__ld.um		__update_PLAYER_end - 4  /* i */
         01:CEFA  AD 09 23   			lda	__update_PLAYER_end - 4
         01:CEFD  C2         			cly
 7309                        		__pusharg.wr
         01:CEFE  A6 8D      			ldx	<__sp
         01:CF00  CA         			dex
         01:CF01  CA         			dex
         01:CF02  95 08      			sta.l	<__stack, x
         01:CF04  94 09      			sty.h	<__stack, x
         01:CF06  86 8D      			stx	<__sp
 7310                        		__call		_check_TILE_DEPTH
         01:CF08  20 4F FF   			call	_check_TILE_DEPTH
 7311                        	
 7312                        		.dbg	line,	"include\routines_LEVELS.c", 1503; if(map_blk_flag == TILE_EMPTY)
 7313                        		__not.um	_map_blk_flag
         01:CF0B  AD A5 2B   			lda	_map_blk_flag
         01:CF0E  18         			clc
         01:CF0F  D0 01      			bne	!+
         01:CF11  38         			sec
         01:CF12             	!:
 7314                        		__bfalse	.LL310
         01:CF12  90 D4      			bcc	.LL310
 7315                        	
 7316                        		.dbg	line,	"include\routines_LEVELS.c", 1504; {
 7317                        	
 7318                        		.dbg	line,	"include\routines_LEVELS.c", 1505; if(player_pos_y != PLAYER_BASE_Y_POS)
 7319                        		__ld.wm		_player_pos_y
         01:CF14  AD CA 24   			lda.l	_player_pos_y
         01:CF17  AC CB 24   			ldy.h	_player_pos_y
 7320                        		__neq_w.wi	128
         01:CF1A  38         			sec
         01:CF1B  49 80      			eor.l	#128
         01:CF1D  D0 06      			bne	!+
         01:CF1F  98         			tya
         01:CF20  49 00      			eor.h	#128
         01:CF22  D0 01      			bne	!+
         01:CF24  18         			clc
         01:CF25             	!:
 7321                        		__bfalse	.LL311
         01:CF25  90 1E      			bcc	.LL311
 7322                        	
 7323                        		.dbg	line,	"include\routines_LEVELS.c", 1506; {
 7324                        	
 7325                        		.dbg	line,	"include\routines_LEVELS.c", 1507; player_pos_y -= (i - 1);
 7326                        		__ld.um		__update_PLAYER_end - 4  /* i */
         01:CF27  AD 09 23   			lda	__update_PLAYER_end - 4
         01:CF2A  C2         			cly
 7327                        		__sub.wi	1
         01:CF2B  38         			sec
         01:CF2C  E9 01      			sbc.l	#1
         01:CF2E  B0 01      			bcs	!+
         01:CF30  88         			dey
         01:CF31             	!:
 7328                        		__isub_st.wmq	_player_pos_y
         01:CF31  38         			sec
         01:CF32  49 FF      			eor	#$FF
         01:CF34  6D CA 24   			adc.l	_player_pos_y
         01:CF37  8D CA 24   			sta.l	_player_pos_y
         01:CF3A  98         			tya
         01:CF3B  49 FF      			eor	#$FF
         01:CF3D  6D CB 24   			adc.h	_player_pos_y
         01:CF40  8D CB 24   			sta.h	_player_pos_y
 7329                        	
 7330                        		.dbg	line,	"include\routines_LEVELS.c", 1508; }
 7331                        	
 7332                        		.dbg	line,	"include\routines_LEVELS.c", 1510; else
 7333                        		__bra		.LL312
         01:CF43  80 20      			bra	.LL312
 7334    01:CF45             	.LL311:
 7335                        	
 7336                        		.dbg	line,	"include\routines_LEVELS.c", 1511; {
 7337                        	
 7338                        		.dbg	line,	"include\routines_LEVELS.c", 1512; sgx_map_pxl_y -= (i - 1);
 7339                        		__ld.um		__update_PLAYER_end - 4  /* i */
         01:CF45  AD 09 23   			lda	__update_PLAYER_end - 4
         01:CF48  C2         			cly
 7340                        		__sub.wi	1
         01:CF49  38         			sec
         01:CF4A  E9 01      			sbc.l	#1
         01:CF4C  B0 01      			bcs	!+
         01:CF4E  88         			dey
         01:CF4F             	!:
 7341                        		__isub_st.wmq	_sgx_map_pxl_y
         01:CF4F  38         			sec
         01:CF50  49 FF      			eor	#$FF
         01:CF52  6D 86 26   			adc.l	_sgx_map_pxl_y
         01:CF55  8D 86 26   			sta.l	_sgx_map_pxl_y
         01:CF58  98         			tya
         01:CF59  49 FF      			eor	#$FF
         01:CF5B  6D 87 26   			adc.h	_sgx_map_pxl_y
         01:CF5E  8D 87 26   			sta.h	_sgx_map_pxl_y
 7342                        	
 7343                        		.dbg	line,	"include\routines_LEVELS.c", 1513; }
 7344    01:CF61             	.LL312	.alias		.LL309
 7345                        	
 7346                        		.dbg	line,	"include\routines_LEVELS.c", 1515; break;
 7347                        		__bra		.LL309
         01:CF61  80 02      			bra	.LL309
 7348                        	
 7349                        		.dbg	line,	"include\routines_LEVELS.c", 1516; }
 7350                        	
 7351                        		.dbg	line,	"include\routines_LEVELS.c", 1517; }
 7352    01:CF63             	.LL310	.alias		.LL307
 7353                        		__bra		.LL307
         01:CF63  80 83      			bra	.LL307
 7354    01:CF65             	.LL309:
 7355                        	
 7356                        		.dbg	line,	"include\routines_LEVELS.c", 1519; // SET PLAYER SPRITE NEW POSITION //
 7357                        	
 7358                        		.dbg	line,	"include\routines_LEVELS.c", 1520; spr_y(player_pos_y);
 7359                        		__ld.wm		_player_pos_y
         01:CF65  AD CA 24   			lda.l	_player_pos_y
         01:CF68  AC CB 24   			ldy.h	_player_pos_y
 7360                        		__call		_spr_y.1
         01:CF6B  20 19 E8   			call	_spr_y.1
 7361                        	
 7362                        		.dbg	line,	"include\routines_LEVELS.c", 1522; player_counter_anim = 1;
 7363                        		__st.umiq	1, _player_counter_anim
         01:CF6E  A9 01      			lda.l	#1
         01:CF70  8D 18 23   			sta	_player_counter_anim
 7364                        	
 7365                        		.dbg	line,	"include\routines_LEVELS.c", 1523; player_index_jump = 0;
 7366                        		__st.umiq	0, _player_index_jump
         01:CF73  9C 19 23   			stz	_player_index_jump
 7367                        	
 7368                        		.dbg	line,	"include\routines_LEVELS.c", 1524; jump_ladder = FALSE;
 7369                        		__st.umiq	0, _jump_ladder
         01:CF76  9C 1B 23   			stz	_jump_ladder
 7370                        	
 7371                        		.dbg	line,	"include\routines_LEVELS.c", 1525; jump_max_index = 34;
 7372                        		__st.umiq	34, _jump_max_index
         01:CF79  A9 22      			lda.l	#34
         01:CF7B  8D 1C 23   			sta	_jump_max_index
 7373                        	
 7374                        		.dbg	line,	"include\routines_LEVELS.c", 1526; player_state = STATE_IDLE;
 7375                        		__st.umiq	0, _player_state
         01:CF7E  9C 15 23   			stz	_player_state
 7376                        	
 7377                        		.dbg	line,	"include\routines_LEVELS.c", 1527; return;
 7378                        		__bra		.LL180
         01:CF81  4C 58 D6   			bra	.LL180
 7379                        	
 7380                        		.dbg	line,	"include\routines_LEVELS.c", 1528; }
 7381                        	
 7382                        		.dbg	line,	"include\routines_LEVELS.c", 1529; }
 7383    01:CF84             	.LL305:
 7384    01:CF84             	.LL304:
 7385                        	
 7386                        		.dbg	line,	"include\routines_LEVELS.c", 1530; }
 7387                        	
 7388                        		.dbg	line,	"include\routines_LEVELS.c", 1535; //--------------------------------------------------------------------------------------//
 7389                        	
 7390                        		.dbg	line,	"include\routines_LEVELS.c", 1536; //                                   LADDER COLLISION                                   //
 7391                        	
 7392                        		.dbg	line,	"include\routines_LEVELS.c", 1537; //--------------------------------------------------------------------------------------//
 7393                        	
 7394                        		.dbg	line,	"include\routines_LEVELS.c", 1539; if(player_index_jump > 4)
 7395    01:CF84             	.LL295:
 7396                        		__ld.umq	_player_index_jump
         01:CF84  AD 19 23   			lda	_player_index_jump
 7397                        		__ugt_b.uiq	4
         01:CF87  18         			clc			; Subtract integer+1 from A.
         01:CF88  E9 04      			sbc	#4		; CS if A > integer.
 7398                        		__bfalse	.LL313
         01:CF8A  B0 03 4C 1B			bcc	.LL313
         01:CF8E  D0          
 7399                        	
 7400                        		.dbg	line,	"include\routines_LEVELS.c", 1540; {
 7401                        	
 7402                        		.dbg	line,	"include\routines_LEVELS.c", 1541; check_BG( 16 , 16 );
 7403                        		__ld.wi		16
         01:CF8F  A9 10      			lda.l	#16
         01:CF91  C2         			cly
 7404                        		__pusharg.wr
         01:CF92  A6 8D      			ldx	<__sp
         01:CF94  CA         			dex
         01:CF95  CA         			dex
         01:CF96  95 08      			sta.l	<__stack, x
         01:CF98  94 09      			sty.h	<__stack, x
         01:CF9A  86 8D      			stx	<__sp
 7405                        		__ld.wi		16
         01:CF9C  A9 10      			lda.l	#16
         01:CF9E  C2         			cly
 7406                        		__pusharg.wr
         01:CF9F  A6 8D      			ldx	<__sp
         01:CFA1  CA         			dex
         01:CFA2  CA         			dex
         01:CFA3  95 08      			sta.l	<__stack, x
         01:CFA5  94 09      			sty.h	<__stack, x
         01:CFA7  86 8D      			stx	<__sp
 7407                        		__call		_check_BG
         01:CFA9  20 6D FF   			call	_check_BG
 7408                        	
 7409                        		.dbg	line,	"include\routines_LEVELS.c", 1543; if(map_blk_flag == TILE_LADDER)
 7410                        		__ld.umq	_map_blk_flag
         01:CFAC  AD A5 2B   			lda	_map_blk_flag
 7411                        		__equ_b.uiq	2
         01:CFAF  C9 02      			cmp	#2
         01:CFB1  F0 01      			beq	!+
         01:CFB3  18         			clc
         01:CFB4             	!:
 7412                        		__bfalse	.LL314
         01:CFB4  90 65      			bcc	.LL314
 7413                        	
 7414                        		.dbg	line,	"include\routines_LEVELS.c", 1544; {
 7415                        	
 7416                        		.dbg	line,	"include\routines_LEVELS.c", 1545; // CAMERA GOES 8 PX BACKWARD //
 7417                        	
 7418                        		.dbg	line,	"include\routines_LEVELS.c", 1546; sgx_map_pxl_x = ( (sgx_map_pxl_x >> 3) << 3 );
 7419                        		__ld.wm		_sgx_map_pxl_x
         01:CFB6  AD 84 26   			lda.l	_sgx_map_pxl_x
         01:CFB9  AC 85 26   			ldy.h	_sgx_map_pxl_x
 7420                        		__lsr.wi	3
         01:CFBC  84 00      			sty	__temp
         01:CFBE  20 3A E2   			jsr	lsrw3
 7421                        		__asl.wi	3
         01:CFC1  84 00      			sty	__temp
         01:CFC3  20 D7 E1   			jsr	aslw3
 7422                        		__st.wmq	_sgx_map_pxl_x
         01:CFC6  8D 84 26   			sta.l	_sgx_map_pxl_x
         01:CFC9  8C 85 26   			sty.h	_sgx_map_pxl_x
 7423                        	
 7424                        		.dbg	line,	"include\routines_LEVELS.c", 1548; // SO WE UPDATE THE MAP //
 7425                        	
 7426                        		.dbg	line,	"include\routines_LEVELS.c", 1549; sgx_scroll_map();
 7427                        		__call		_sgx_scroll_map
         01:CFCC  20 81 FF   			call	_sgx_scroll_map
 7428                        	
 7429                        		.dbg	line,	"include\routines_LEVELS.c", 1551; // CHECK IF THE PLAYER STANDS RIGHT TO THE LADDER //
 7430                        	
 7431                        		.dbg	line,	"include\routines_LEVELS.c", 1552; check_BG( 31 , 16 );
 7432                        		__ld.wi		31
         01:CFCF  A9 1F      			lda.l	#31
         01:CFD1  C2         			cly
 7433                        		__pusharg.wr
         01:CFD2  A6 8D      			ldx	<__sp
         01:CFD4  CA         			dex
         01:CFD5  CA         			dex
         01:CFD6  95 08      			sta.l	<__stack, x
         01:CFD8  94 09      			sty.h	<__stack, x
         01:CFDA  86 8D      			stx	<__sp
 7434                        		__ld.wi		16
         01:CFDC  A9 10      			lda.l	#16
         01:CFDE  C2         			cly
 7435                        		__pusharg.wr
         01:CFDF  A6 8D      			ldx	<__sp
         01:CFE1  CA         			dex
         01:CFE2  CA         			dex
         01:CFE3  95 08      			sta.l	<__stack, x
         01:CFE5  94 09      			sty.h	<__stack, x
         01:CFE7  86 8D      			stx	<__sp
 7436                        		__call		_check_BG
         01:CFE9  20 6D FF   			call	_check_BG
 7437                        	
 7438                        		.dbg	line,	"include\routines_LEVELS.c", 1554; if(map_blk_flag == TILE_LADDER)
 7439                        		__ld.umq	_map_blk_flag
         01:CFEC  AD A5 2B   			lda	_map_blk_flag
 7440                        		__equ_b.uiq	2
         01:CFEF  C9 02      			cmp	#2
         01:CFF1  F0 01      			beq	!+
         01:CFF3  18         			clc
         01:CFF4             	!:
 7441                        		__bfalse	.LL315
         01:CFF4  90 0E      			bcc	.LL315
 7442                        	
 7443                        		.dbg	line,	"include\routines_LEVELS.c", 1555; {
 7444                        	
 7445                        		.dbg	line,	"include\routines_LEVELS.c", 1556; sgx_map_pxl_x += 8;
 7446                        		__add_st.wmiq	8, _sgx_map_pxl_x
         01:CFF6  18         			clc
         01:CFF7  AD 84 26   			lda.l	_sgx_map_pxl_x
         01:CFFA  69 08      			adc.l	#8
         01:CFFC  8D 84 26   			sta.l	_sgx_map_pxl_x
         01:CFFF  90 03      			bcc	!+
         01:D001  EE 85 26   			inc.h	_sgx_map_pxl_x
         01:D004             	!:
 7447                        	
 7448                        		.dbg	line,	"include\routines_LEVELS.c", 1557; }
 7449                        	
 7450                        		.dbg	line,	"include\routines_LEVELS.c", 1559; player_counter_anim = 1;
 7451    01:D004             	.LL315:
 7452                        		__st.umiq	1, _player_counter_anim
         01:D004  A9 01      			lda.l	#1
         01:D006  8D 18 23   			sta	_player_counter_anim
 7453                        	
 7454                        		.dbg	line,	"include\routines_LEVELS.c", 1560; player_index_jump = 0;
 7455                        		__st.umiq	0, _player_index_jump
         01:D009  9C 19 23   			stz	_player_index_jump
 7456                        	
 7457                        		.dbg	line,	"include\routines_LEVELS.c", 1561; jump_ladder = TRUE;
 7458                        		__st.umiq	1, _jump_ladder
         01:D00C  A9 01      			lda.l	#1
         01:D00E  8D 1B 23   			sta	_jump_ladder
 7459                        	
 7460                        		.dbg	line,	"include\routines_LEVELS.c", 1562; jump_max_index = 29;
 7461                        		__st.umiq	29, _jump_max_index
         01:D011  A9 1D      			lda.l	#29
         01:D013  8D 1C 23   			sta	_jump_max_index
 7462                        	
 7463                        		.dbg	line,	"include\routines_LEVELS.c", 1563; player_state = STATE_HANG;
 7464                        		__st.umiq	10, _player_state
         01:D016  A9 0A      			lda.l	#10
         01:D018  8D 15 23   			sta	_player_state
 7465                        	
 7466                        		.dbg	line,	"include\routines_LEVELS.c", 1564; }
 7467                        	
 7468                        		.dbg	line,	"include\routines_LEVELS.c", 1565; }
 7469    01:D01B             	.LL314:
 7470                        	
 7471                        		.dbg	line,	"include\routines_LEVELS.c", 1568; // SET PLAYER SPRITE NEW POSITION //
 7472                        	
 7473                        		.dbg	line,	"include\routines_LEVELS.c", 1569; spr_y(player_pos_y);
 7474    01:D01B             	.LL313:
 7475                        		__ld.wm		_player_pos_y
         01:D01B  AD CA 24   			lda.l	_player_pos_y
         01:D01E  AC CB 24   			ldy.h	_player_pos_y
 7476                        		__call		_spr_y.1
         01:D021  20 19 E8   			call	_spr_y.1
 7477                        	
 7478                        		.dbg	line,	"include\routines_LEVELS.c", 1570; }
 7479                        	
 7480                        		.dbg	line,	"include\routines_LEVELS.c", 1573; else if(player_state == STATE_CROUCH)
 7481                        		__bra		.LL316
         01:D024  4C 58 D6   			bra	.LL316
 7482    01:D027             	.LL280:
 7483                        		__ld.umq	_player_state
         01:D027  AD 15 23   			lda	_player_state
 7484                        		__equ_b.uiq	7
         01:D02A  C9 07      			cmp	#7
         01:D02C  F0 01      			beq	!+
         01:D02E  18         			clc
         01:D02F             	!:
 7485                        		__bfalse	.LL317
         01:D02F  90 2F      			bcc	.LL317
 7486                        	
 7487                        		.dbg	line,	"include\routines_LEVELS.c", 1574; {
 7488                        	
 7489                        		.dbg	line,	"include\routines_LEVELS.c", 1575; if(player_counter_anim == 1)
 7490                        		__ld.umq	_player_counter_anim
         01:D031  AD 18 23   			lda	_player_counter_anim
 7491                        		__equ_b.uiq	1
         01:D034  C9 01      			cmp	#1
         01:D036  F0 01      			beq	!+
         01:D038  18         			clc
         01:D039             	!:
 7492                        		__bfalse	.LL318
         01:D039  90 1F      			bcc	.LL318
 7493                        	
 7494                        		.dbg	line,	"include\routines_LEVELS.c", 1576; {
 7495                        	
 7496                        		.dbg	line,	"include\routines_LEVELS.c", 1577; load_vram(PLAYER_VRAM_ADR, tiles_SPR_PLAYER + TILES_128 , TILES_16);
 7497                        		__st.wmiq	6144, _di
         01:D03B  64 F0      			stz.l	_di
         01:D03D  A9 18      			lda.h	#6144
         01:D03F  85 F1      			sta.h	_di
 7498                        		__farptr	_tiles_SPR_PLAYER + 4096, _bp_bank, _bp
         01:D041  A9 E0      			lda.l	#$6000 + ($1FFF & (_tiles_SPR_PLAYER + 4096))
         01:D043  85 EC      			sta.l	_bp
         01:D045  A9 79      			lda.h	#$6000 + ($1FFF & (_tiles_SPR_PLAYER + 4096))
         01:D047  85 ED      			sta.h	_bp
         01:D049  A9 0E      			lda	#bank(_tiles_SPR_PLAYER + 4096)
         01:D04B  85 02      			sta	_bp_bank
 7499                        		__st.wmiq	256, _ax
         01:D04D  64 F8      			stz.l	_ax
         01:D04F  A9 01      			lda.h	#256
         01:D051  85 F9      			sta.h	_ax
 7500                        		 _load_vram.3
         01:D053  82         			clx				; Offset to PCE VDC.
         01:D054  20 63 FF   			call	load_vram_x
 7501                        	
 7502                        		.dbg	line,	"include\routines_LEVELS.c", 1579; player_counter_anim = 0;
 7503                        		__st.umiq	0, _player_counter_anim
         01:D057  9C 18 23   			stz	_player_counter_anim
 7504                        	
 7505                        		.dbg	line,	"include\routines_LEVELS.c", 1580; }
 7506                        	
 7507                        		.dbg	line,	"include\routines_LEVELS.c", 1582; recenter_CAMERA();
 7508    01:D05A             	.LL318:
 7509                        		__call		_recenter_CAMERA
         01:D05A  20 59 FF   			call	_recenter_CAMERA
 7510                        	
 7511                        		.dbg	line,	"include\routines_LEVELS.c", 1583; }
 7512                        	
 7513                        		.dbg	line,	"include\routines_LEVELS.c", 1586; else if(player_state == STATE_FALL)
 7514                        		__bra		.LL319
         01:D05D  4C 58 D6   			bra	.LL319
 7515    01:D060             	.LL317:
 7516                        		__ld.umq	_player_state
         01:D060  AD 15 23   			lda	_player_state
 7517                        		__equ_b.uiq	9
         01:D063  C9 09      			cmp	#9
         01:D065  F0 01      			beq	!+
         01:D067  18         			clc
         01:D068             	!:
 7518                        		__bfalse	.LL320
         01:D068  B0 03 4C 6F			bcc	.LL320
         01:D06C  D2          
 7519                        	
 7520                        		.dbg	line,	"include\routines_LEVELS.c", 1587; {
 7521                        	
 7522                        		.dbg	line,	"include\routines_LEVELS.c", 1588; unsigned char i, camera_y_move;
 7523                        	
 7524                        		.dbg	line,	"include\routines_LEVELS.c", 1589; i = 1;
 7525                        		__st.umiq	1, __update_PLAYER_end - 6  /* i */
         01:D06D  A9 01      			lda.l	#1
         01:D06F  8D 07 23   			sta	__update_PLAYER_end - 6
 7526                        	
 7527                        		.dbg	line,	"include\routines_LEVELS.c", 1592; spr_set(player_id);
 7528                        		__ld.umq	_player_id
         01:D072  AD 14 23   			lda	_player_id
 7529                        		__call		_spr_set.1
         01:D075  20 DD E7   			call	_spr_set.1
 7530                        	
 7531                        		.dbg	line,	"include\routines_LEVELS.c", 1595; //--------------------------------------------------------------------------------------//
 7532                        	
 7533                        		.dbg	line,	"include\routines_LEVELS.c", 1596; //                                        V MOVE                                        //
 7534                        	
 7535                        		.dbg	line,	"include\routines_LEVELS.c", 1597; //--------------------------------------------------------------------------------------//
 7536                        	
 7537                        		.dbg	line,	"include\routines_LEVELS.c", 1599; // UPDATE PLAYER Y POSITION //
 7538                        	
 7539                        		.dbg	line,	"include\routines_LEVELS.c", 1600; player_pos_y += TABLE_PLAYER_FALL[player_index_fall];
 7540                        		__ldx.umq	_player_index_fall
         01:D078  AE 1A 23   			ldx	_player_index_fall
 7541                        		__ld.bax	_TABLE_PLAYER_FALL
         01:D07B  BD C5 60   			lda	_TABLE_PLAYER_FALL, x
         01:D07E  C2         			cly
         01:D07F  10 01      			bpl	!+
         01:D081  88         			dey
         01:D082             	!:
 7542                        		__add_st.wmq	_player_pos_y
         01:D082  18         			clc
         01:D083  6D CA 24   			adc.l	_player_pos_y
         01:D086  8D CA 24   			sta.l	_player_pos_y
         01:D089  98         			tya
         01:D08A  6D CB 24   			adc.h	_player_pos_y
         01:D08D  8D CB 24   			sta.h	_player_pos_y
 7543                        	
 7544                        		.dbg	line,	"include\routines_LEVELS.c", 1603; // IF PLAYER GOES BELOW ITS BASE Y POSITION //
 7545                        	
 7546                        		.dbg	line,	"include\routines_LEVELS.c", 1604; if(player_pos_y >= PLAYER_BASE_Y_POS)
 7547                        		__ld.wm		_player_pos_y
         01:D090  AD CA 24   			lda.l	_player_pos_y
         01:D093  AC CB 24   			ldy.h	_player_pos_y
 7548                        		__sge_w.wi	128
         01:D096  C9 80      			cmp.l	#128		; Subtract integer from Y:A.
         01:D098  98         			tya
         01:D099  E9 00      			sbc.h	#128
         01:D09B  50 02      			bvc	!+
         01:D09D  49 80      			eor	#$80		; +ve if Y:A >= integer (signed).
         01:D09F  49 80      	!:		eor	#$80
         01:D0A1  0A         			asl	a
 7549                        		__bfalse	.LL321
         01:D0A2  90 45      			bcc	.LL321
 7550                        	
 7551                        		.dbg	line,	"include\routines_LEVELS.c", 1605; {
 7552                        	
 7553                        		.dbg	line,	"include\routines_LEVELS.c", 1606; // THE CAMERA MOVES //
 7554                        	
 7555                        		.dbg	line,	"include\routines_LEVELS.c", 1607; // CALCULATE HOW MANY PIXELS THE CAMERA HAS TO MOVE DOWN //
 7556                        	
 7557                        		.dbg	line,	"include\routines_LEVELS.c", 1608; camera_y_move = player_pos_y - PLAYER_BASE_Y_POS;
 7558                        		__ld.wm		_player_pos_y
         01:D0A4  AD CA 24   			lda.l	_player_pos_y
         01:D0A7  AC CB 24   			ldy.h	_player_pos_y
 7559                        		__sub.wi	128
         01:D0AA  38         			sec
         01:D0AB  E9 80      			sbc.l	#128
         01:D0AD  B0 01      			bcs	!+
         01:D0AF  88         			dey
         01:D0B0             	!:
 7560                        		__st.umq	__update_PLAYER_end - 7  /* camera_y_move */
         01:D0B0  8D 06 23   			sta	__update_PLAYER_end - 7
 7561                        	
 7562                        		.dbg	line,	"include\routines_LEVELS.c", 1609; sgx_map_pxl_y += camera_y_move;
 7563                        		__ld.um		__update_PLAYER_end - 7  /* camera_y_move */
         01:D0B3  AD 06 23   			lda	__update_PLAYER_end - 7
         01:D0B6  C2         			cly
 7564                        		__add_st.wmq	_sgx_map_pxl_y
         01:D0B7  18         			clc
         01:D0B8  6D 86 26   			adc.l	_sgx_map_pxl_y
         01:D0BB  8D 86 26   			sta.l	_sgx_map_pxl_y
         01:D0BE  98         			tya
         01:D0BF  6D 87 26   			adc.h	_sgx_map_pxl_y
         01:D0C2  8D 87 26   			sta.h	_sgx_map_pxl_y
 7565                        	
 7566                        		.dbg	line,	"include\routines_LEVELS.c", 1611; // IF THE CAMERA HAS REACHED ITS MAX (LOWEST) POSITION //
 7567                        	
 7568                        		.dbg	line,	"include\routines_LEVELS.c", 1612; if(sgx_map_pxl_y > camera_max_y_position)
 7569                        		__ld.wm		_sgx_map_pxl_y
         01:D0C5  AD 86 26   			lda.l	_sgx_map_pxl_y
         01:D0C8  AC 87 26   			ldy.h	_sgx_map_pxl_y
 7570                        		__ugt_w.wm	_camera_max_y_position
         01:D0CB  18         			clc			; Subtract memory+1 from Y:A.
         01:D0CC  ED CC 24   			sbc.l	_camera_max_y_position
         01:D0CF  98         			tya
         01:D0D0  ED CD 24   			sbc.h	_camera_max_y_position		; CS if Y:A > memory.
 7571                        		__bfalse	.LL322
         01:D0D3  90 0C      			bcc	.LL322
 7572                        	
 7573                        		.dbg	line,	"include\routines_LEVELS.c", 1613; {
 7574                        	
 7575                        		.dbg	line,	"include\routines_LEVELS.c", 1614; // THE CAMERA CAN NOT MOVE LOWER //
 7576                        	
 7577                        		.dbg	line,	"include\routines_LEVELS.c", 1615; sgx_map_pxl_y = camera_max_y_position;
 7578                        		__ld.wm		_camera_max_y_position
         01:D0D5  AD CC 24   			lda.l	_camera_max_y_position
         01:D0D8  AC CD 24   			ldy.h	_camera_max_y_position
 7579                        		__st.wmq	_sgx_map_pxl_y
         01:D0DB  8D 86 26   			sta.l	_sgx_map_pxl_y
         01:D0DE  8C 87 26   			sty.h	_sgx_map_pxl_y
 7580                        	
 7581                        		.dbg	line,	"include\routines_LEVELS.c", 1616; }
 7582                        	
 7583                        		.dbg	line,	"include\routines_LEVELS.c", 1618; // THE PLAYER STAYS AT ITS BASE Y POSITION //
 7584                        	
 7585                        		.dbg	line,	"include\routines_LEVELS.c", 1619; player_pos_y = PLAYER_BASE_Y_POS;
 7586    01:D0E1             	.LL322:
 7587                        		__st.wmiq	128, _player_pos_y
         01:D0E1  A9 80      			lda.l	#128
         01:D0E3  8D CA 24   			sta.l	_player_pos_y
         01:D0E6  9C CB 24   			stz.h	_player_pos_y
 7588                        	
 7589                        		.dbg	line,	"include\routines_LEVELS.c", 1620; }
 7590                        	
 7591                        		.dbg	line,	"include\routines_LEVELS.c", 1623; // UPDATE JUMP INDEX IN THE ARRAY //
 7592                        	
 7593                        		.dbg	line,	"include\routines_LEVELS.c", 1624; // ARRAY MAX ENTRY : 20//
 7594                        	
 7595                        		.dbg	line,	"include\routines_LEVELS.c", 1625; if(player_index_fall < 20)
 7596    01:D0E9             	.LL321:
 7597                        		__ld.umq	_player_index_fall
         01:D0E9  AD 1A 23   			lda	_player_index_fall
 7598                        		__ult_b.uiq	20
         01:D0EC  C9 14      			cmp	#20		; Subtract integer from A.
         01:D0EE  6A         			ror	a		; CC if A < integer.
         01:D0EF  49 80      			eor	#$80
         01:D0F1  2A         			rol	a
 7599                        		__bfalse	.LL323
         01:D0F2  90 03      			bcc	.LL323
 7600                        	
 7601                        		.dbg	line,	"include\routines_LEVELS.c", 1626; {
 7602                        	
 7603                        		.dbg	line,	"include\routines_LEVELS.c", 1627; player_index_fall += 1;
 7604                        		__add_st.umiq	1, _player_index_fall
         01:D0F4  EE 1A 23   			inc	_player_index_fall
 7605                        	
 7606                        		.dbg	line,	"include\routines_LEVELS.c", 1628; }
 7607                        	
 7608                        		.dbg	line,	"include\routines_LEVELS.c", 1631; check_TILE_DEPTH( 15 , 0);
 7609    01:D0F7             	.LL323:
 7610                        		__ld.wi		15
         01:D0F7  A9 0F      			lda.l	#15
         01:D0F9  C2         			cly
 7611                        		__pusharg.wr
         01:D0FA  A6 8D      			ldx	<__sp
         01:D0FC  CA         			dex
         01:D0FD  CA         			dex
         01:D0FE  95 08      			sta.l	<__stack, x
         01:D100  94 09      			sty.h	<__stack, x
         01:D102  86 8D      			stx	<__sp
 7612                        		__ld.wi		0
         01:D104  62         			cla
         01:D105  C2         			cly
 7613                        		__pusharg.wr
         01:D106  A6 8D      			ldx	<__sp
         01:D108  CA         			dex
         01:D109  CA         			dex
         01:D10A  95 08      			sta.l	<__stack, x
         01:D10C  94 09      			sty.h	<__stack, x
         01:D10E  86 8D      			stx	<__sp
 7614                        		__call		_check_TILE_DEPTH
         01:D110  20 4F FF   			call	_check_TILE_DEPTH
 7615                        	
 7616                        		.dbg	line,	"include\routines_LEVELS.c", 1634; if(map_blk_flag == TILE_BG)
 7617                        		__ld.umq	_map_blk_flag
         01:D113  AD A5 2B   			lda	_map_blk_flag
 7618                        		__equ_b.uiq	1
         01:D116  C9 01      			cmp	#1
         01:D118  F0 01      			beq	!+
         01:D11A  18         			clc
         01:D11B             	!:
 7619                        		__bfalse	.LL324
         01:D11B  B0 03 4C D1			bcc	.LL324
         01:D11F  D1          
 7620                        	
 7621                        		.dbg	line,	"include\routines_LEVELS.c", 1635; {
 7622                        	
 7623                        		.dbg	line,	"include\routines_LEVELS.c", 1636; // CALCULATE HOW MANY PIXELS THE PLAYER MOVED INTO THE GROUND //
 7624                        	
 7625                        		.dbg	line,	"include\routines_LEVELS.c", 1637; for(i=1; i<11 ; i++ )
 7626                        		__st.umiq	1, __update_PLAYER_end - 6  /* i */
         01:D120  A9 01      			lda.l	#1
         01:D122  8D 07 23   			sta	__update_PLAYER_end - 6
 7627    01:D125             	.LL325:
 7628                        		__ld.umq	__update_PLAYER_end - 6  /* i */
         01:D125  AD 07 23   			lda	__update_PLAYER_end - 6
 7629                        		__ult_b.uiq	11
         01:D128  C9 0B      			cmp	#11		; Subtract integer from A.
         01:D12A  6A         			ror	a		; CC if A < integer.
         01:D12B  49 80      			eor	#$80
         01:D12D  2A         			rol	a
 7630                        		__btrue		.LL327
         01:D12E  B0 07      			bcs	.LL327
 7631                        		__bra		.LL328
         01:D130  80 7D      			bra	.LL328
 7632    01:D132             	.LL326:
 7633                        		__inc.umq	__update_PLAYER_end - 6  /* i */
         01:D132  EE 07 23   			inc	__update_PLAYER_end - 6
 7634                        		__bra		.LL325
         01:D135  80 EE      			bra	.LL325
 7635    01:D137             	.LL327:
 7636                        	
 7637                        		.dbg	line,	"include\routines_LEVELS.c", 1638; {
 7638                        	
 7639                        		.dbg	line,	"include\routines_LEVELS.c", 1639; //if(player_axis == AXIS_RIGHT)
 7640                        	
 7641                        		.dbg	line,	"include\routines_LEVELS.c", 1640; //{
 7642                        	
 7643                        		.dbg	line,	"include\routines_LEVELS.c", 1641; check_TILE_DEPTH( 15 , i);//20
 7644                        		__ld.wi		15
         01:D137  A9 0F      			lda.l	#15
         01:D139  C2         			cly
 7645                        		__pusharg.wr
         01:D13A  A6 8D      			ldx	<__sp
         01:D13C  CA         			dex
         01:D13D  CA         			dex
         01:D13E  95 08      			sta.l	<__stack, x
         01:D140  94 09      			sty.h	<__stack, x
         01:D142  86 8D      			stx	<__sp
 7646                        		__ld.um		__update_PLAYER_end - 6  /* i */
         01:D144  AD 07 23   			lda	__update_PLAYER_end - 6
         01:D147  C2         			cly
 7647                        		__pusharg.wr
         01:D148  A6 8D      			ldx	<__sp
         01:D14A  CA         			dex
         01:D14B  CA         			dex
         01:D14C  95 08      			sta.l	<__stack, x
         01:D14E  94 09      			sty.h	<__stack, x
         01:D150  86 8D      			stx	<__sp
 7648                        		__call		_check_TILE_DEPTH
         01:D152  20 4F FF   			call	_check_TILE_DEPTH
 7649                        	
 7650                        		.dbg	line,	"include\routines_LEVELS.c", 1642; //}
 7651                        	
 7652                        		.dbg	line,	"include\routines_LEVELS.c", 1644; /*else
 7653                        	
 7654                        		.dbg	line,	"include\routines_LEVELS.c", 1645; {
 7655                        	
 7656                        		.dbg	line,	"include\routines_LEVELS.c", 1646; check_TILE_DEPTH( 10 , i);
 7657                        	
 7658                        		.dbg	line,	"include\routines_LEVELS.c", 1647; }*/
 7659                        	
 7660                        		.dbg	line,	"include\routines_LEVELS.c", 1650; if(map_blk_flag == TILE_EMPTY)
 7661                        		__not.um	_map_blk_flag
         01:D155  AD A5 2B   			lda	_map_blk_flag
         01:D158  18         			clc
         01:D159  D0 01      			bne	!+
         01:D15B  38         			sec
         01:D15C             	!:
 7662                        		__bfalse	.LL329
         01:D15C  90 D4      			bcc	.LL329
 7663                        	
 7664                        		.dbg	line,	"include\routines_LEVELS.c", 1651; {
 7665                        	
 7666                        		.dbg	line,	"include\routines_LEVELS.c", 1652; if(player_pos_y != PLAYER_BASE_Y_POS)
 7667                        		__ld.wm		_player_pos_y
         01:D15E  AD CA 24   			lda.l	_player_pos_y
         01:D161  AC CB 24   			ldy.h	_player_pos_y
 7668                        		__neq_w.wi	128
         01:D164  38         			sec
         01:D165  49 80      			eor.l	#128
         01:D167  D0 06      			bne	!+
         01:D169  98         			tya
         01:D16A  49 00      			eor.h	#128
         01:D16C  D0 01      			bne	!+
         01:D16E  18         			clc
         01:D16F             	!:
 7669                        		__bfalse	.LL330
         01:D16F  90 1E      			bcc	.LL330
 7670                        	
 7671                        		.dbg	line,	"include\routines_LEVELS.c", 1653; {
 7672                        	
 7673                        		.dbg	line,	"include\routines_LEVELS.c", 1654; player_pos_y -= (i - 1);
 7674                        		__ld.um		__update_PLAYER_end - 6  /* i */
         01:D171  AD 07 23   			lda	__update_PLAYER_end - 6
         01:D174  C2         			cly
 7675                        		__sub.wi	1
         01:D175  38         			sec
         01:D176  E9 01      			sbc.l	#1
         01:D178  B0 01      			bcs	!+
         01:D17A  88         			dey
         01:D17B             	!:
 7676                        		__isub_st.wmq	_player_pos_y
         01:D17B  38         			sec
         01:D17C  49 FF      			eor	#$FF
         01:D17E  6D CA 24   			adc.l	_player_pos_y
         01:D181  8D CA 24   			sta.l	_player_pos_y
         01:D184  98         			tya
         01:D185  49 FF      			eor	#$FF
         01:D187  6D CB 24   			adc.h	_player_pos_y
         01:D18A  8D CB 24   			sta.h	_player_pos_y
 7677                        	
 7678                        		.dbg	line,	"include\routines_LEVELS.c", 1655; }
 7679                        	
 7680                        		.dbg	line,	"include\routines_LEVELS.c", 1657; else
 7681                        		__bra		.LL331
         01:D18D  80 20      			bra	.LL331
 7682    01:D18F             	.LL330:
 7683                        	
 7684                        		.dbg	line,	"include\routines_LEVELS.c", 1658; {
 7685                        	
 7686                        		.dbg	line,	"include\routines_LEVELS.c", 1659; sgx_map_pxl_y -= (i - 1);
 7687                        		__ld.um		__update_PLAYER_end - 6  /* i */
         01:D18F  AD 07 23   			lda	__update_PLAYER_end - 6
         01:D192  C2         			cly
 7688                        		__sub.wi	1
         01:D193  38         			sec
         01:D194  E9 01      			sbc.l	#1
         01:D196  B0 01      			bcs	!+
         01:D198  88         			dey
         01:D199             	!:
 7689                        		__isub_st.wmq	_sgx_map_pxl_y
         01:D199  38         			sec
         01:D19A  49 FF      			eor	#$FF
         01:D19C  6D 86 26   			adc.l	_sgx_map_pxl_y
         01:D19F  8D 86 26   			sta.l	_sgx_map_pxl_y
         01:D1A2  98         			tya
         01:D1A3  49 FF      			eor	#$FF
         01:D1A5  6D 87 26   			adc.h	_sgx_map_pxl_y
         01:D1A8  8D 87 26   			sta.h	_sgx_map_pxl_y
 7690                        	
 7691                        		.dbg	line,	"include\routines_LEVELS.c", 1660; }
 7692    01:D1AB             	.LL331	.alias		.LL328
 7693                        	
 7694                        		.dbg	line,	"include\routines_LEVELS.c", 1663; break;
 7695                        		__bra		.LL328
         01:D1AB  80 02      			bra	.LL328
 7696                        	
 7697                        		.dbg	line,	"include\routines_LEVELS.c", 1664; }
 7698                        	
 7699                        		.dbg	line,	"include\routines_LEVELS.c", 1666; }
 7700    01:D1AD             	.LL329	.alias		.LL326
 7701                        		__bra		.LL326
         01:D1AD  80 83      			bra	.LL326
 7702    01:D1AF             	.LL328:
 7703                        	
 7704                        		.dbg	line,	"include\routines_LEVELS.c", 1668; spr_y(player_pos_y);
 7705                        		__ld.wm		_player_pos_y
         01:D1AF  AD CA 24   			lda.l	_player_pos_y
         01:D1B2  AC CB 24   			ldy.h	_player_pos_y
 7706                        		__call		_spr_y.1
         01:D1B5  20 19 E8   			call	_spr_y.1
 7707                        	
 7708                        		.dbg	line,	"include\routines_LEVELS.c", 1670; player_counter_anim = 1;
 7709                        		__st.umiq	1, _player_counter_anim
         01:D1B8  A9 01      			lda.l	#1
         01:D1BA  8D 18 23   			sta	_player_counter_anim
 7710                        	
 7711                        		.dbg	line,	"include\routines_LEVELS.c", 1671; player_index_jump = 0;
 7712                        		__st.umiq	0, _player_index_jump
         01:D1BD  9C 19 23   			stz	_player_index_jump
 7713                        	
 7714                        		.dbg	line,	"include\routines_LEVELS.c", 1672; player_index_fall = 0;
 7715                        		__st.umiq	0, _player_index_fall
         01:D1C0  9C 1A 23   			stz	_player_index_fall
 7716                        	
 7717                        		.dbg	line,	"include\routines_LEVELS.c", 1673; jump_ladder = FALSE;
 7718                        		__st.umiq	0, _jump_ladder
         01:D1C3  9C 1B 23   			stz	_jump_ladder
 7719                        	
 7720                        		.dbg	line,	"include\routines_LEVELS.c", 1674; jump_max_index = 34;
 7721                        		__st.umiq	34, _jump_max_index
         01:D1C6  A9 22      			lda.l	#34
         01:D1C8  8D 1C 23   			sta	_jump_max_index
 7722                        	
 7723                        		.dbg	line,	"include\routines_LEVELS.c", 1675; player_state = STATE_IDLE;
 7724                        		__st.umiq	0, _player_state
         01:D1CB  9C 15 23   			stz	_player_state
 7725                        	
 7726                        		.dbg	line,	"include\routines_LEVELS.c", 1676; return;
 7727                        		__bra		.LL180
         01:D1CE  4C 58 D6   			bra	.LL180
 7728                        	
 7729                        		.dbg	line,	"include\routines_LEVELS.c", 1677; }
 7730                        	
 7731                        		.dbg	line,	"include\routines_LEVELS.c", 1680; check_BG( 16 , 16 );
 7732    01:D1D1             	.LL324:
 7733                        		__ld.wi		16
         01:D1D1  A9 10      			lda.l	#16
         01:D1D3  C2         			cly
 7734                        		__pusharg.wr
         01:D1D4  A6 8D      			ldx	<__sp
         01:D1D6  CA         			dex
         01:D1D7  CA         			dex
         01:D1D8  95 08      			sta.l	<__stack, x
         01:D1DA  94 09      			sty.h	<__stack, x
         01:D1DC  86 8D      			stx	<__sp
 7735                        		__ld.wi		16
         01:D1DE  A9 10      			lda.l	#16
         01:D1E0  C2         			cly
 7736                        		__pusharg.wr
         01:D1E1  A6 8D      			ldx	<__sp
         01:D1E3  CA         			dex
         01:D1E4  CA         			dex
         01:D1E5  95 08      			sta.l	<__stack, x
         01:D1E7  94 09      			sty.h	<__stack, x
         01:D1E9  86 8D      			stx	<__sp
 7737                        		__call		_check_BG
         01:D1EB  20 6D FF   			call	_check_BG
 7738                        	
 7739                        		.dbg	line,	"include\routines_LEVELS.c", 1682; // IF PLAYER HITS THE LADDER //
 7740                        	
 7741                        		.dbg	line,	"include\routines_LEVELS.c", 1683; if(map_blk_flag == TILE_LADDER)
 7742                        		__ld.umq	_map_blk_flag
         01:D1EE  AD A5 2B   			lda	_map_blk_flag
 7743                        		__equ_b.uiq	2
         01:D1F1  C9 02      			cmp	#2
         01:D1F3  F0 01      			beq	!+
         01:D1F5  18         			clc
         01:D1F6             	!:
 7744                        		__bfalse	.LL332
         01:D1F6  90 6B      			bcc	.LL332
 7745                        	
 7746                        		.dbg	line,	"include\routines_LEVELS.c", 1684; {
 7747                        	
 7748                        		.dbg	line,	"include\routines_LEVELS.c", 1685; // CAMERA GOES 8 PX BACKWARD //
 7749                        	
 7750                        		.dbg	line,	"include\routines_LEVELS.c", 1686; sgx_map_pxl_x = ( (sgx_map_pxl_x >> 3) << 3 );
 7751                        		__ld.wm		_sgx_map_pxl_x
         01:D1F8  AD 84 26   			lda.l	_sgx_map_pxl_x
         01:D1FB  AC 85 26   			ldy.h	_sgx_map_pxl_x
 7752                        		__lsr.wi	3
         01:D1FE  84 00      			sty	__temp
         01:D200  20 3A E2   			jsr	lsrw3
 7753                        		__asl.wi	3
         01:D203  84 00      			sty	__temp
         01:D205  20 D7 E1   			jsr	aslw3
 7754                        		__st.wmq	_sgx_map_pxl_x
         01:D208  8D 84 26   			sta.l	_sgx_map_pxl_x
         01:D20B  8C 85 26   			sty.h	_sgx_map_pxl_x
 7755                        	
 7756                        		.dbg	line,	"include\routines_LEVELS.c", 1688; // SO WE UPDATE THE MAP //
 7757                        	
 7758                        		.dbg	line,	"include\routines_LEVELS.c", 1689; sgx_scroll_map();
 7759                        		__call		_sgx_scroll_map
         01:D20E  20 81 FF   			call	_sgx_scroll_map
 7760                        	
 7761                        		.dbg	line,	"include\routines_LEVELS.c", 1691; // CHECK IF THE PLAYER STANDS RIGHT TO THE LADDER //
 7762                        	
 7763                        		.dbg	line,	"include\routines_LEVELS.c", 1692; check_BG( 31 , 16 );
 7764                        		__ld.wi		31
         01:D211  A9 1F      			lda.l	#31
         01:D213  C2         			cly
 7765                        		__pusharg.wr
         01:D214  A6 8D      			ldx	<__sp
         01:D216  CA         			dex
         01:D217  CA         			dex
         01:D218  95 08      			sta.l	<__stack, x
         01:D21A  94 09      			sty.h	<__stack, x
         01:D21C  86 8D      			stx	<__sp
 7766                        		__ld.wi		16
         01:D21E  A9 10      			lda.l	#16
         01:D220  C2         			cly
 7767                        		__pusharg.wr
         01:D221  A6 8D      			ldx	<__sp
         01:D223  CA         			dex
         01:D224  CA         			dex
         01:D225  95 08      			sta.l	<__stack, x
         01:D227  94 09      			sty.h	<__stack, x
         01:D229  86 8D      			stx	<__sp
 7768                        		__call		_check_BG
         01:D22B  20 6D FF   			call	_check_BG
 7769                        	
 7770                        		.dbg	line,	"include\routines_LEVELS.c", 1694; if(map_blk_flag == TILE_LADDER)
 7771                        		__ld.umq	_map_blk_flag
         01:D22E  AD A5 2B   			lda	_map_blk_flag
 7772                        		__equ_b.uiq	2
         01:D231  C9 02      			cmp	#2
         01:D233  F0 01      			beq	!+
         01:D235  18         			clc
         01:D236             	!:
 7773                        		__bfalse	.LL333
         01:D236  90 0E      			bcc	.LL333
 7774                        	
 7775                        		.dbg	line,	"include\routines_LEVELS.c", 1695; {
 7776                        	
 7777                        		.dbg	line,	"include\routines_LEVELS.c", 1696; sgx_map_pxl_x += 8;
 7778                        		__add_st.wmiq	8, _sgx_map_pxl_x
         01:D238  18         			clc
         01:D239  AD 84 26   			lda.l	_sgx_map_pxl_x
         01:D23C  69 08      			adc.l	#8
         01:D23E  8D 84 26   			sta.l	_sgx_map_pxl_x
         01:D241  90 03      			bcc	!+
         01:D243  EE 85 26   			inc.h	_sgx_map_pxl_x
         01:D246             	!:
 7779                        	
 7780                        		.dbg	line,	"include\routines_LEVELS.c", 1697; }
 7781                        	
 7782                        		.dbg	line,	"include\routines_LEVELS.c", 1699; player_counter_anim = 1;
 7783    01:D246             	.LL333:
 7784                        		__st.umiq	1, _player_counter_anim
         01:D246  A9 01      			lda.l	#1
         01:D248  8D 18 23   			sta	_player_counter_anim
 7785                        	
 7786                        		.dbg	line,	"include\routines_LEVELS.c", 1700; player_index_jump = 0;
 7787                        		__st.umiq	0, _player_index_jump
         01:D24B  9C 19 23   			stz	_player_index_jump
 7788                        	
 7789                        		.dbg	line,	"include\routines_LEVELS.c", 1701; player_index_fall = 0;
 7790                        		__st.umiq	0, _player_index_fall
         01:D24E  9C 1A 23   			stz	_player_index_fall
 7791                        	
 7792                        		.dbg	line,	"include\routines_LEVELS.c", 1702; jump_ladder = TRUE;
 7793                        		__st.umiq	1, _jump_ladder
         01:D251  A9 01      			lda.l	#1
         01:D253  8D 1B 23   			sta	_jump_ladder
 7794                        	
 7795                        		.dbg	line,	"include\routines_LEVELS.c", 1703; jump_max_index = 29;
 7796                        		__st.umiq	29, _jump_max_index
         01:D256  A9 1D      			lda.l	#29
         01:D258  8D 1C 23   			sta	_jump_max_index
 7797                        	
 7798                        		.dbg	line,	"include\routines_LEVELS.c", 1704; player_state = STATE_HANG;
 7799                        		__st.umiq	10, _player_state
         01:D25B  A9 0A      			lda.l	#10
         01:D25D  8D 15 23   			sta	_player_state
 7800                        	
 7801                        		.dbg	line,	"include\routines_LEVELS.c", 1705; return;
 7802                        		__bra		.LL180
         01:D260  4C 58 D6   			bra	.LL180
 7803                        	
 7804                        		.dbg	line,	"include\routines_LEVELS.c", 1706; }
 7805                        	
 7806                        		.dbg	line,	"include\routines_LEVELS.c", 1709; spr_y(player_pos_y);
 7807    01:D263             	.LL332:
 7808                        		__ld.wm		_player_pos_y
         01:D263  AD CA 24   			lda.l	_player_pos_y
         01:D266  AC CB 24   			ldy.h	_player_pos_y
 7809                        		__call		_spr_y.1
         01:D269  20 19 E8   			call	_spr_y.1
 7810                        	
 7811                        		.dbg	line,	"include\routines_LEVELS.c", 1710; }
 7812                        	
 7813                        		.dbg	line,	"include\routines_LEVELS.c", 1713; else if(player_state == STATE_HANG)
 7814                        		__bra		.LL334
         01:D26C  4C 58 D6   			bra	.LL334
 7815    01:D26F             	.LL320:
 7816                        		__ld.umq	_player_state
         01:D26F  AD 15 23   			lda	_player_state
 7817                        		__equ_b.uiq	10
         01:D272  C9 0A      			cmp	#10
         01:D274  F0 01      			beq	!+
         01:D276  18         			clc
         01:D277             	!:
 7818                        		__bfalse	.LL335
         01:D277  90 32      			bcc	.LL335
 7819                        	
 7820                        		.dbg	line,	"include\routines_LEVELS.c", 1714; {
 7821                        	
 7822                        		.dbg	line,	"include\routines_LEVELS.c", 1715; recenter_CAMERA();
 7823                        		__call		_recenter_CAMERA
         01:D279  20 59 FF   			call	_recenter_CAMERA
 7824                        	
 7825                        		.dbg	line,	"include\routines_LEVELS.c", 1717; if(player_counter_anim == 1)
 7826                        		__ld.umq	_player_counter_anim
         01:D27C  AD 18 23   			lda	_player_counter_anim
 7827                        		__equ_b.uiq	1
         01:D27F  C9 01      			cmp	#1
         01:D281  F0 01      			beq	!+
         01:D283  18         			clc
         01:D284             	!:
 7828                        		__bfalse	.LL336
         01:D284  B0 03 4C 58			bcc	.LL336
         01:D288  D6          
 7829                        	
 7830                        		.dbg	line,	"include\routines_LEVELS.c", 1718; {
 7831                        	
 7832                        		.dbg	line,	"include\routines_LEVELS.c", 1719; load_vram(PLAYER_VRAM_ADR, tiles_SPR_PLAYER + TILES_144 , TILES_16);
 7833                        		__st.wmiq	6144, _di
         01:D289  64 F0      			stz.l	_di
         01:D28B  A9 18      			lda.h	#6144
         01:D28D  85 F1      			sta.h	_di
 7834                        		__farptr	_tiles_SPR_PLAYER + 4608, _bp_bank, _bp
         01:D28F  A9 E0      			lda.l	#$6000 + ($1FFF & (_tiles_SPR_PLAYER + 4608))
         01:D291  85 EC      			sta.l	_bp
         01:D293  A9 7B      			lda.h	#$6000 + ($1FFF & (_tiles_SPR_PLAYER + 4608))
         01:D295  85 ED      			sta.h	_bp
         01:D297  A9 0E      			lda	#bank(_tiles_SPR_PLAYER + 4608)
         01:D299  85 02      			sta	_bp_bank
 7835                        		__st.wmiq	256, _ax
         01:D29B  64 F8      			stz.l	_ax
         01:D29D  A9 01      			lda.h	#256
         01:D29F  85 F9      			sta.h	_ax
 7836                        		 _load_vram.3
         01:D2A1  82         			clx				; Offset to PCE VDC.
         01:D2A2  20 63 FF   			call	load_vram_x
 7837                        	
 7838                        		.dbg	line,	"include\routines_LEVELS.c", 1721; player_counter_anim = 0;
 7839                        		__st.umiq	0, _player_counter_anim
         01:D2A5  9C 18 23   			stz	_player_counter_anim
 7840                        	
 7841                        		.dbg	line,	"include\routines_LEVELS.c", 1722; }
 7842                        	
 7843                        		.dbg	line,	"include\routines_LEVELS.c", 1723; }
 7844    01:D2A8             	.LL336	.alias		.LL337
 7845                        	
 7846                        		.dbg	line,	"include\routines_LEVELS.c", 1726; else if(player_state == STATE_CLIMB_UP)
 7847                        		__bra		.LL337
         01:D2A8  4C 58 D6   			bra	.LL337
 7848    01:D2AB             	.LL335:
 7849                        		__ld.umq	_player_state
         01:D2AB  AD 15 23   			lda	_player_state
 7850                        		__equ_b.uiq	11
         01:D2AE  C9 0B      			cmp	#11
         01:D2B0  F0 01      			beq	!+
         01:D2B2  18         			clc
         01:D2B3             	!:
 7851                        		__bfalse	.LL338
         01:D2B3  B0 03 4C BD			bcc	.LL338
         01:D2B7  D3          
 7852                        	
 7853                        		.dbg	line,	"include\routines_LEVELS.c", 1727; {
 7854                        	
 7855                        		.dbg	line,	"include\routines_LEVELS.c", 1728; if(player_counter_anim == 0)
 7856                        		__not.um	_player_counter_anim
         01:D2B8  AD 18 23   			lda	_player_counter_anim
         01:D2BB  18         			clc
         01:D2BC  D0 01      			bne	!+
         01:D2BE  38         			sec
         01:D2BF             	!:
 7857                        		__bfalse	.LL339
         01:D2BF  90 1F      			bcc	.LL339
 7858                        	
 7859                        		.dbg	line,	"include\routines_LEVELS.c", 1729; {
 7860                        	
 7861                        		.dbg	line,	"include\routines_LEVELS.c", 1730; load_vram(PLAYER_VRAM_ADR, tiles_SPR_PLAYER + TILES_160 , TILES_16);
 7862                        		__st.wmiq	6144, _di
         01:D2C1  64 F0      			stz.l	_di
         01:D2C3  A9 18      			lda.h	#6144
         01:D2C5  85 F1      			sta.h	_di
 7863                        		__farptr	_tiles_SPR_PLAYER + 5120, _bp_bank, _bp
         01:D2C7  A9 E0      			lda.l	#$6000 + ($1FFF & (_tiles_SPR_PLAYER + 5120))
         01:D2C9  85 EC      			sta.l	_bp
         01:D2CB  A9 7D      			lda.h	#$6000 + ($1FFF & (_tiles_SPR_PLAYER + 5120))
         01:D2CD  85 ED      			sta.h	_bp
         01:D2CF  A9 0E      			lda	#bank(_tiles_SPR_PLAYER + 5120)
         01:D2D1  85 02      			sta	_bp_bank
 7864                        		__st.wmiq	256, _ax
         01:D2D3  64 F8      			stz.l	_ax
         01:D2D5  A9 01      			lda.h	#256
         01:D2D7  85 F9      			sta.h	_ax
 7865                        		 _load_vram.3
         01:D2D9  82         			clx				; Offset to PCE VDC.
         01:D2DA  20 63 FF   			call	load_vram_x
 7866                        	
 7867                        		.dbg	line,	"include\routines_LEVELS.c", 1731; }
 7868                        	
 7869                        		.dbg	line,	"include\routines_LEVELS.c", 1733; else if(player_counter_anim == 3)
 7870                        		__bra		.LL340
         01:D2DD  4C A7 D3   			bra	.LL340
 7871    01:D2E0             	.LL339:
 7872                        		__ld.umq	_player_counter_anim
         01:D2E0  AD 18 23   			lda	_player_counter_anim
 7873                        		__equ_b.uiq	3
         01:D2E3  C9 03      			cmp	#3
         01:D2E5  F0 01      			beq	!+
         01:D2E7  18         			clc
         01:D2E8             	!:
 7874                        		__bfalse	.LL341
         01:D2E8  90 1F      			bcc	.LL341
 7875                        	
 7876                        		.dbg	line,	"include\routines_LEVELS.c", 1734; {
 7877                        	
 7878                        		.dbg	line,	"include\routines_LEVELS.c", 1735; load_vram(PLAYER_VRAM_ADR, tiles_SPR_PLAYER + TILES_176 , TILES_16);
 7879                        		__st.wmiq	6144, _di
         01:D2EA  64 F0      			stz.l	_di
         01:D2EC  A9 18      			lda.h	#6144
         01:D2EE  85 F1      			sta.h	_di
 7880                        		__farptr	_tiles_SPR_PLAYER + 5632, _bp_bank, _bp
         01:D2F0  A9 E0      			lda.l	#$6000 + ($1FFF & (_tiles_SPR_PLAYER + 5632))
         01:D2F2  85 EC      			sta.l	_bp
         01:D2F4  A9 7F      			lda.h	#$6000 + ($1FFF & (_tiles_SPR_PLAYER + 5632))
         01:D2F6  85 ED      			sta.h	_bp
         01:D2F8  A9 0E      			lda	#bank(_tiles_SPR_PLAYER + 5632)
         01:D2FA  85 02      			sta	_bp_bank
 7881                        		__st.wmiq	256, _ax
         01:D2FC  64 F8      			stz.l	_ax
         01:D2FE  A9 01      			lda.h	#256
         01:D300  85 F9      			sta.h	_ax
 7882                        		 _load_vram.3
         01:D302  82         			clx				; Offset to PCE VDC.
         01:D303  20 63 FF   			call	load_vram_x
 7883                        	
 7884                        		.dbg	line,	"include\routines_LEVELS.c", 1736; }
 7885                        	
 7886                        		.dbg	line,	"include\routines_LEVELS.c", 1738; else if(player_counter_anim == 6)
 7887                        		__bra		.LL342
         01:D306  4C A7 D3   			bra	.LL342
 7888    01:D309             	.LL341:
 7889                        		__ld.umq	_player_counter_anim
         01:D309  AD 18 23   			lda	_player_counter_anim
 7890                        		__equ_b.uiq	6
         01:D30C  C9 06      			cmp	#6
         01:D30E  F0 01      			beq	!+
         01:D310  18         			clc
         01:D311             	!:
 7891                        		__bfalse	.LL343
         01:D311  90 1E      			bcc	.LL343
 7892                        	
 7893                        		.dbg	line,	"include\routines_LEVELS.c", 1739; {
 7894                        	
 7895                        		.dbg	line,	"include\routines_LEVELS.c", 1740; load_vram(PLAYER_VRAM_ADR, tiles_SPR_PLAYER + TILES_192 , TILES_16);
 7896                        		__st.wmiq	6144, _di
         01:D313  64 F0      			stz.l	_di
         01:D315  A9 18      			lda.h	#6144
         01:D317  85 F1      			sta.h	_di
 7897                        		__farptr	_tiles_SPR_PLAYER + 6144, _bp_bank, _bp
         01:D319  A9 E0      			lda.l	#$6000 + ($1FFF & (_tiles_SPR_PLAYER + 6144))
         01:D31B  85 EC      			sta.l	_bp
         01:D31D  A9 61      			lda.h	#$6000 + ($1FFF & (_tiles_SPR_PLAYER + 6144))
         01:D31F  85 ED      			sta.h	_bp
         01:D321  A9 0F      			lda	#bank(_tiles_SPR_PLAYER + 6144)
         01:D323  85 02      			sta	_bp_bank
 7898                        		__st.wmiq	256, _ax
         01:D325  64 F8      			stz.l	_ax
         01:D327  A9 01      			lda.h	#256
         01:D329  85 F9      			sta.h	_ax
 7899                        		 _load_vram.3
         01:D32B  82         			clx				; Offset to PCE VDC.
         01:D32C  20 63 FF   			call	load_vram_x
 7900                        	
 7901                        		.dbg	line,	"include\routines_LEVELS.c", 1741; }
 7902                        	
 7903                        		.dbg	line,	"include\routines_LEVELS.c", 1743; else if(player_counter_anim == 9)
 7904                        		__bra		.LL344
         01:D32F  80 76      			bra	.LL344
 7905    01:D331             	.LL343:
 7906                        		__ld.umq	_player_counter_anim
         01:D331  AD 18 23   			lda	_player_counter_anim
 7907                        		__equ_b.uiq	9
         01:D334  C9 09      			cmp	#9
         01:D336  F0 01      			beq	!+
         01:D338  18         			clc
         01:D339             	!:
 7908                        		__bfalse	.LL345
         01:D339  90 1E      			bcc	.LL345
 7909                        	
 7910                        		.dbg	line,	"include\routines_LEVELS.c", 1744; {
 7911                        	
 7912                        		.dbg	line,	"include\routines_LEVELS.c", 1745; load_vram(PLAYER_VRAM_ADR, tiles_SPR_PLAYER + TILES_208 , TILES_16);
 7913                        		__st.wmiq	6144, _di
         01:D33B  64 F0      			stz.l	_di
         01:D33D  A9 18      			lda.h	#6144
         01:D33F  85 F1      			sta.h	_di
 7914                        		__farptr	_tiles_SPR_PLAYER + 6656, _bp_bank, _bp
         01:D341  A9 E0      			lda.l	#$6000 + ($1FFF & (_tiles_SPR_PLAYER + 6656))
         01:D343  85 EC      			sta.l	_bp
         01:D345  A9 63      			lda.h	#$6000 + ($1FFF & (_tiles_SPR_PLAYER + 6656))
         01:D347  85 ED      			sta.h	_bp
         01:D349  A9 0F      			lda	#bank(_tiles_SPR_PLAYER + 6656)
         01:D34B  85 02      			sta	_bp_bank
 7915                        		__st.wmiq	256, _ax
         01:D34D  64 F8      			stz.l	_ax
         01:D34F  A9 01      			lda.h	#256
         01:D351  85 F9      			sta.h	_ax
 7916                        		 _load_vram.3
         01:D353  82         			clx				; Offset to PCE VDC.
         01:D354  20 63 FF   			call	load_vram_x
 7917                        	
 7918                        		.dbg	line,	"include\routines_LEVELS.c", 1746; }
 7919                        	
 7920                        		.dbg	line,	"include\routines_LEVELS.c", 1748; else if(player_counter_anim == 12)
 7921                        		__bra		.LL346
         01:D357  80 4E      			bra	.LL346
 7922    01:D359             	.LL345:
 7923                        		__ld.umq	_player_counter_anim
         01:D359  AD 18 23   			lda	_player_counter_anim
 7924                        		__equ_b.uiq	12
         01:D35C  C9 0C      			cmp	#12
         01:D35E  F0 01      			beq	!+
         01:D360  18         			clc
         01:D361             	!:
 7925                        		__bfalse	.LL347
         01:D361  90 1E      			bcc	.LL347
 7926                        	
 7927                        		.dbg	line,	"include\routines_LEVELS.c", 1749; {
 7928                        	
 7929                        		.dbg	line,	"include\routines_LEVELS.c", 1750; load_vram(PLAYER_VRAM_ADR, tiles_SPR_PLAYER + TILES_192 , TILES_16);
 7930                        		__st.wmiq	6144, _di
         01:D363  64 F0      			stz.l	_di
         01:D365  A9 18      			lda.h	#6144
         01:D367  85 F1      			sta.h	_di
 7931                        		__farptr	_tiles_SPR_PLAYER + 6144, _bp_bank, _bp
         01:D369  A9 E0      			lda.l	#$6000 + ($1FFF & (_tiles_SPR_PLAYER + 6144))
         01:D36B  85 EC      			sta.l	_bp
         01:D36D  A9 61      			lda.h	#$6000 + ($1FFF & (_tiles_SPR_PLAYER + 6144))
         01:D36F  85 ED      			sta.h	_bp
         01:D371  A9 0F      			lda	#bank(_tiles_SPR_PLAYER + 6144)
         01:D373  85 02      			sta	_bp_bank
 7932                        		__st.wmiq	256, _ax
         01:D375  64 F8      			stz.l	_ax
         01:D377  A9 01      			lda.h	#256
         01:D379  85 F9      			sta.h	_ax
 7933                        		 _load_vram.3
         01:D37B  82         			clx				; Offset to PCE VDC.
         01:D37C  20 63 FF   			call	load_vram_x
 7934                        	
 7935                        		.dbg	line,	"include\routines_LEVELS.c", 1751; }
 7936                        	
 7937                        		.dbg	line,	"include\routines_LEVELS.c", 1753; else if(player_counter_anim == 15)
 7938                        		__bra		.LL348
         01:D37F  80 26      			bra	.LL348
 7939    01:D381             	.LL347:
 7940                        		__ld.umq	_player_counter_anim
         01:D381  AD 18 23   			lda	_player_counter_anim
 7941                        		__equ_b.uiq	15
         01:D384  C9 0F      			cmp	#15
         01:D386  F0 01      			beq	!+
         01:D388  18         			clc
         01:D389             	!:
 7942                        		__bfalse	.LL349
         01:D389  90 1C      			bcc	.LL349
 7943                        	
 7944                        		.dbg	line,	"include\routines_LEVELS.c", 1754; {
 7945                        	
 7946                        		.dbg	line,	"include\routines_LEVELS.c", 1755; load_vram(PLAYER_VRAM_ADR, tiles_SPR_PLAYER + TILES_176 , TILES_16);
 7947                        		__st.wmiq	6144, _di
         01:D38B  64 F0      			stz.l	_di
         01:D38D  A9 18      			lda.h	#6144
         01:D38F  85 F1      			sta.h	_di
 7948                        		__farptr	_tiles_SPR_PLAYER + 5632, _bp_bank, _bp
         01:D391  A9 E0      			lda.l	#$6000 + ($1FFF & (_tiles_SPR_PLAYER + 5632))
         01:D393  85 EC      			sta.l	_bp
         01:D395  A9 7F      			lda.h	#$6000 + ($1FFF & (_tiles_SPR_PLAYER + 5632))
         01:D397  85 ED      			sta.h	_bp
         01:D399  A9 0E      			lda	#bank(_tiles_SPR_PLAYER + 5632)
         01:D39B  85 02      			sta	_bp_bank
 7949                        		__st.wmiq	256, _ax
         01:D39D  64 F8      			stz.l	_ax
         01:D39F  A9 01      			lda.h	#256
         01:D3A1  85 F9      			sta.h	_ax
 7950                        		 _load_vram.3
         01:D3A3  82         			clx				; Offset to PCE VDC.
         01:D3A4  20 63 FF   			call	load_vram_x
 7951                        	
 7952                        		.dbg	line,	"include\routines_LEVELS.c", 1756; }
 7953                        	
 7954                        		.dbg	line,	"include\routines_LEVELS.c", 1759; player_counter_anim += 1;
 7955    01:D3A7             	.LL349:
 7956    01:D3A7             	.LL348:
 7957    01:D3A7             	.LL346:
 7958    01:D3A7             	.LL344:
 7959    01:D3A7             	.LL342:
 7960    01:D3A7             	.LL340:
 7961                        		__add_st.umiq	1, _player_counter_anim
         01:D3A7  EE 18 23   			inc	_player_counter_anim
 7962                        	
 7963                        		.dbg	line,	"include\routines_LEVELS.c", 1761; if(player_counter_anim == 17)
 7964                        		__ld.umq	_player_counter_anim
         01:D3AA  AD 18 23   			lda	_player_counter_anim
 7965                        		__equ_b.uiq	17
         01:D3AD  C9 11      			cmp	#17
         01:D3AF  F0 01      			beq	!+
         01:D3B1  18         			clc
         01:D3B2             	!:
 7966                        		__bfalse	.LL350
         01:D3B2  90 03      			bcc	.LL350
 7967                        	
 7968                        		.dbg	line,	"include\routines_LEVELS.c", 1762; {
 7969                        	
 7970                        		.dbg	line,	"include\routines_LEVELS.c", 1763; player_counter_anim = 0;
 7971                        		__st.umiq	0, _player_counter_anim
         01:D3B4  9C 18 23   			stz	_player_counter_anim
 7972                        	
 7973                        		.dbg	line,	"include\routines_LEVELS.c", 1764; }
 7974                        	
 7975                        		.dbg	line,	"include\routines_LEVELS.c", 1766; recenter_CAMERA();
 7976    01:D3B7             	.LL350:
 7977                        		__call		_recenter_CAMERA
         01:D3B7  20 59 FF   			call	_recenter_CAMERA
 7978                        	
 7979                        		.dbg	line,	"include\routines_LEVELS.c", 1767; }
 7980                        	
 7981                        		.dbg	line,	"include\routines_LEVELS.c", 1770; else if(player_state == STATE_CLIMB_DOWN)
 7982                        		__bra		.LL351
         01:D3BA  4C 58 D6   			bra	.LL351
 7983    01:D3BD             	.LL338:
 7984                        		__ld.umq	_player_state
         01:D3BD  AD 15 23   			lda	_player_state
 7985                        		__equ_b.uiq	12
         01:D3C0  C9 0C      			cmp	#12
         01:D3C2  F0 01      			beq	!+
         01:D3C4  18         			clc
         01:D3C5             	!:
 7986                        		__bfalse	.LL352
         01:D3C5  B0 03 4C CF			bcc	.LL352
         01:D3C9  D4          
 7987                        	
 7988                        		.dbg	line,	"include\routines_LEVELS.c", 1771; {
 7989                        	
 7990                        		.dbg	line,	"include\routines_LEVELS.c", 1772; if(player_counter_anim == 0)
 7991                        		__not.um	_player_counter_anim
         01:D3CA  AD 18 23   			lda	_player_counter_anim
         01:D3CD  18         			clc
         01:D3CE  D0 01      			bne	!+
         01:D3D0  38         			sec
         01:D3D1             	!:
 7992                        		__bfalse	.LL353
         01:D3D1  90 1F      			bcc	.LL353
 7993                        	
 7994                        		.dbg	line,	"include\routines_LEVELS.c", 1773; {
 7995                        	
 7996                        		.dbg	line,	"include\routines_LEVELS.c", 1774; load_vram(PLAYER_VRAM_ADR, tiles_SPR_PLAYER + TILES_176 , TILES_16);
 7997                        		__st.wmiq	6144, _di
         01:D3D3  64 F0      			stz.l	_di
         01:D3D5  A9 18      			lda.h	#6144
         01:D3D7  85 F1      			sta.h	_di
 7998                        		__farptr	_tiles_SPR_PLAYER + 5632, _bp_bank, _bp
         01:D3D9  A9 E0      			lda.l	#$6000 + ($1FFF & (_tiles_SPR_PLAYER + 5632))
         01:D3DB  85 EC      			sta.l	_bp
         01:D3DD  A9 7F      			lda.h	#$6000 + ($1FFF & (_tiles_SPR_PLAYER + 5632))
         01:D3DF  85 ED      			sta.h	_bp
         01:D3E1  A9 0E      			lda	#bank(_tiles_SPR_PLAYER + 5632)
         01:D3E3  85 02      			sta	_bp_bank
 7999                        		__st.wmiq	256, _ax
         01:D3E5  64 F8      			stz.l	_ax
         01:D3E7  A9 01      			lda.h	#256
         01:D3E9  85 F9      			sta.h	_ax
 8000                        		 _load_vram.3
         01:D3EB  82         			clx				; Offset to PCE VDC.
         01:D3EC  20 63 FF   			call	load_vram_x
 8001                        	
 8002                        		.dbg	line,	"include\routines_LEVELS.c", 1775; }
 8003                        	
 8004                        		.dbg	line,	"include\routines_LEVELS.c", 1777; else if(player_counter_anim == 3)
 8005                        		__bra		.LL354
         01:D3EF  4C B9 D4   			bra	.LL354
 8006    01:D3F2             	.LL353:
 8007                        		__ld.umq	_player_counter_anim
         01:D3F2  AD 18 23   			lda	_player_counter_anim
 8008                        		__equ_b.uiq	3
         01:D3F5  C9 03      			cmp	#3
         01:D3F7  F0 01      			beq	!+
         01:D3F9  18         			clc
         01:D3FA             	!:
 8009                        		__bfalse	.LL355
         01:D3FA  90 1F      			bcc	.LL355
 8010                        	
 8011                        		.dbg	line,	"include\routines_LEVELS.c", 1778; {
 8012                        	
 8013                        		.dbg	line,	"include\routines_LEVELS.c", 1779; load_vram(PLAYER_VRAM_ADR, tiles_SPR_PLAYER + TILES_192 , TILES_16);
 8014                        		__st.wmiq	6144, _di
         01:D3FC  64 F0      			stz.l	_di
         01:D3FE  A9 18      			lda.h	#6144
         01:D400  85 F1      			sta.h	_di
 8015                        		__farptr	_tiles_SPR_PLAYER + 6144, _bp_bank, _bp
         01:D402  A9 E0      			lda.l	#$6000 + ($1FFF & (_tiles_SPR_PLAYER + 6144))
         01:D404  85 EC      			sta.l	_bp
         01:D406  A9 61      			lda.h	#$6000 + ($1FFF & (_tiles_SPR_PLAYER + 6144))
         01:D408  85 ED      			sta.h	_bp
         01:D40A  A9 0F      			lda	#bank(_tiles_SPR_PLAYER + 6144)
         01:D40C  85 02      			sta	_bp_bank
 8016                        		__st.wmiq	256, _ax
         01:D40E  64 F8      			stz.l	_ax
         01:D410  A9 01      			lda.h	#256
         01:D412  85 F9      			sta.h	_ax
 8017                        		 _load_vram.3
         01:D414  82         			clx				; Offset to PCE VDC.
         01:D415  20 63 FF   			call	load_vram_x
 8018                        	
 8019                        		.dbg	line,	"include\routines_LEVELS.c", 1780; }
 8020                        	
 8021                        		.dbg	line,	"include\routines_LEVELS.c", 1782; else if(player_counter_anim == 6)
 8022                        		__bra		.LL356
         01:D418  4C B9 D4   			bra	.LL356
 8023    01:D41B             	.LL355:
 8024                        		__ld.umq	_player_counter_anim
         01:D41B  AD 18 23   			lda	_player_counter_anim
 8025                        		__equ_b.uiq	6
         01:D41E  C9 06      			cmp	#6
         01:D420  F0 01      			beq	!+
         01:D422  18         			clc
         01:D423             	!:
 8026                        		__bfalse	.LL357
         01:D423  90 1E      			bcc	.LL357
 8027                        	
 8028                        		.dbg	line,	"include\routines_LEVELS.c", 1783; {
 8029                        	
 8030                        		.dbg	line,	"include\routines_LEVELS.c", 1784; load_vram(PLAYER_VRAM_ADR, tiles_SPR_PLAYER + TILES_208 , TILES_16);
 8031                        		__st.wmiq	6144, _di
         01:D425  64 F0      			stz.l	_di
         01:D427  A9 18      			lda.h	#6144
         01:D429  85 F1      			sta.h	_di
 8032                        		__farptr	_tiles_SPR_PLAYER + 6656, _bp_bank, _bp
         01:D42B  A9 E0      			lda.l	#$6000 + ($1FFF & (_tiles_SPR_PLAYER + 6656))
         01:D42D  85 EC      			sta.l	_bp
         01:D42F  A9 63      			lda.h	#$6000 + ($1FFF & (_tiles_SPR_PLAYER + 6656))
         01:D431  85 ED      			sta.h	_bp
         01:D433  A9 0F      			lda	#bank(_tiles_SPR_PLAYER + 6656)
         01:D435  85 02      			sta	_bp_bank
 8033                        		__st.wmiq	256, _ax
         01:D437  64 F8      			stz.l	_ax
         01:D439  A9 01      			lda.h	#256
         01:D43B  85 F9      			sta.h	_ax
 8034                        		 _load_vram.3
         01:D43D  82         			clx				; Offset to PCE VDC.
         01:D43E  20 63 FF   			call	load_vram_x
 8035                        	
 8036                        		.dbg	line,	"include\routines_LEVELS.c", 1785; }
 8037                        	
 8038                        		.dbg	line,	"include\routines_LEVELS.c", 1787; else if(player_counter_anim == 9)
 8039                        		__bra		.LL358
         01:D441  80 76      			bra	.LL358
 8040    01:D443             	.LL357:
 8041                        		__ld.umq	_player_counter_anim
         01:D443  AD 18 23   			lda	_player_counter_anim
 8042                        		__equ_b.uiq	9
         01:D446  C9 09      			cmp	#9
         01:D448  F0 01      			beq	!+
         01:D44A  18         			clc
         01:D44B             	!:
 8043                        		__bfalse	.LL359
         01:D44B  90 1E      			bcc	.LL359
 8044                        	
 8045                        		.dbg	line,	"include\routines_LEVELS.c", 1788; {
 8046                        	
 8047                        		.dbg	line,	"include\routines_LEVELS.c", 1789; load_vram(PLAYER_VRAM_ADR, tiles_SPR_PLAYER + TILES_192 , TILES_16);
 8048                        		__st.wmiq	6144, _di
         01:D44D  64 F0      			stz.l	_di
         01:D44F  A9 18      			lda.h	#6144
         01:D451  85 F1      			sta.h	_di
 8049                        		__farptr	_tiles_SPR_PLAYER + 6144, _bp_bank, _bp
         01:D453  A9 E0      			lda.l	#$6000 + ($1FFF & (_tiles_SPR_PLAYER + 6144))
         01:D455  85 EC      			sta.l	_bp
         01:D457  A9 61      			lda.h	#$6000 + ($1FFF & (_tiles_SPR_PLAYER + 6144))
         01:D459  85 ED      			sta.h	_bp
         01:D45B  A9 0F      			lda	#bank(_tiles_SPR_PLAYER + 6144)
         01:D45D  85 02      			sta	_bp_bank
 8050                        		__st.wmiq	256, _ax
         01:D45F  64 F8      			stz.l	_ax
         01:D461  A9 01      			lda.h	#256
         01:D463  85 F9      			sta.h	_ax
 8051                        		 _load_vram.3
         01:D465  82         			clx				; Offset to PCE VDC.
         01:D466  20 63 FF   			call	load_vram_x
 8052                        	
 8053                        		.dbg	line,	"include\routines_LEVELS.c", 1790; }
 8054                        	
 8055                        		.dbg	line,	"include\routines_LEVELS.c", 1792; else if(player_counter_anim == 12)
 8056                        		__bra		.LL360
         01:D469  80 4E      			bra	.LL360
 8057    01:D46B             	.LL359:
 8058                        		__ld.umq	_player_counter_anim
         01:D46B  AD 18 23   			lda	_player_counter_anim
 8059                        		__equ_b.uiq	12
         01:D46E  C9 0C      			cmp	#12
         01:D470  F0 01      			beq	!+
         01:D472  18         			clc
         01:D473             	!:
 8060                        		__bfalse	.LL361
         01:D473  90 1E      			bcc	.LL361
 8061                        	
 8062                        		.dbg	line,	"include\routines_LEVELS.c", 1793; {
 8063                        	
 8064                        		.dbg	line,	"include\routines_LEVELS.c", 1794; load_vram(PLAYER_VRAM_ADR, tiles_SPR_PLAYER + TILES_176 , TILES_16);
 8065                        		__st.wmiq	6144, _di
         01:D475  64 F0      			stz.l	_di
         01:D477  A9 18      			lda.h	#6144
         01:D479  85 F1      			sta.h	_di
 8066                        		__farptr	_tiles_SPR_PLAYER + 5632, _bp_bank, _bp
         01:D47B  A9 E0      			lda.l	#$6000 + ($1FFF & (_tiles_SPR_PLAYER + 5632))
         01:D47D  85 EC      			sta.l	_bp
         01:D47F  A9 7F      			lda.h	#$6000 + ($1FFF & (_tiles_SPR_PLAYER + 5632))
         01:D481  85 ED      			sta.h	_bp
         01:D483  A9 0E      			lda	#bank(_tiles_SPR_PLAYER + 5632)
         01:D485  85 02      			sta	_bp_bank
 8067                        		__st.wmiq	256, _ax
         01:D487  64 F8      			stz.l	_ax
         01:D489  A9 01      			lda.h	#256
         01:D48B  85 F9      			sta.h	_ax
 8068                        		 _load_vram.3
         01:D48D  82         			clx				; Offset to PCE VDC.
         01:D48E  20 63 FF   			call	load_vram_x
 8069                        	
 8070                        		.dbg	line,	"include\routines_LEVELS.c", 1795; }
 8071                        	
 8072                        		.dbg	line,	"include\routines_LEVELS.c", 1797; else if(player_counter_anim == 15)
 8073                        		__bra		.LL362
         01:D491  80 26      			bra	.LL362
 8074    01:D493             	.LL361:
 8075                        		__ld.umq	_player_counter_anim
         01:D493  AD 18 23   			lda	_player_counter_anim
 8076                        		__equ_b.uiq	15
         01:D496  C9 0F      			cmp	#15
         01:D498  F0 01      			beq	!+
         01:D49A  18         			clc
         01:D49B             	!:
 8077                        		__bfalse	.LL363
         01:D49B  90 1C      			bcc	.LL363
 8078                        	
 8079                        		.dbg	line,	"include\routines_LEVELS.c", 1798; {
 8080                        	
 8081                        		.dbg	line,	"include\routines_LEVELS.c", 1799; load_vram(PLAYER_VRAM_ADR, tiles_SPR_PLAYER + TILES_160 , TILES_16);
 8082                        		__st.wmiq	6144, _di
         01:D49D  64 F0      			stz.l	_di
         01:D49F  A9 18      			lda.h	#6144
         01:D4A1  85 F1      			sta.h	_di
 8083                        		__farptr	_tiles_SPR_PLAYER + 5120, _bp_bank, _bp
         01:D4A3  A9 E0      			lda.l	#$6000 + ($1FFF & (_tiles_SPR_PLAYER + 5120))
         01:D4A5  85 EC      			sta.l	_bp
         01:D4A7  A9 7D      			lda.h	#$6000 + ($1FFF & (_tiles_SPR_PLAYER + 5120))
         01:D4A9  85 ED      			sta.h	_bp
         01:D4AB  A9 0E      			lda	#bank(_tiles_SPR_PLAYER + 5120)
         01:D4AD  85 02      			sta	_bp_bank
 8084                        		__st.wmiq	256, _ax
         01:D4AF  64 F8      			stz.l	_ax
         01:D4B1  A9 01      			lda.h	#256
         01:D4B3  85 F9      			sta.h	_ax
 8085                        		 _load_vram.3
         01:D4B5  82         			clx				; Offset to PCE VDC.
         01:D4B6  20 63 FF   			call	load_vram_x
 8086                        	
 8087                        		.dbg	line,	"include\routines_LEVELS.c", 1800; }
 8088                        	
 8089                        		.dbg	line,	"include\routines_LEVELS.c", 1803; player_counter_anim += 1;
 8090    01:D4B9             	.LL363:
 8091    01:D4B9             	.LL362:
 8092    01:D4B9             	.LL360:
 8093    01:D4B9             	.LL358:
 8094    01:D4B9             	.LL356:
 8095    01:D4B9             	.LL354:
 8096                        		__add_st.umiq	1, _player_counter_anim
         01:D4B9  EE 18 23   			inc	_player_counter_anim
 8097                        	
 8098                        		.dbg	line,	"include\routines_LEVELS.c", 1805; if(player_counter_anim == 17)
 8099                        		__ld.umq	_player_counter_anim
         01:D4BC  AD 18 23   			lda	_player_counter_anim
 8100                        		__equ_b.uiq	17
         01:D4BF  C9 11      			cmp	#17
         01:D4C1  F0 01      			beq	!+
         01:D4C3  18         			clc
         01:D4C4             	!:
 8101                        		__bfalse	.LL364
         01:D4C4  90 03      			bcc	.LL364
 8102                        	
 8103                        		.dbg	line,	"include\routines_LEVELS.c", 1806; {
 8104                        	
 8105                        		.dbg	line,	"include\routines_LEVELS.c", 1807; player_counter_anim = 0;
 8106                        		__st.umiq	0, _player_counter_anim
         01:D4C6  9C 18 23   			stz	_player_counter_anim
 8107                        	
 8108                        		.dbg	line,	"include\routines_LEVELS.c", 1808; }
 8109                        	
 8110                        		.dbg	line,	"include\routines_LEVELS.c", 1810; recenter_CAMERA();
 8111    01:D4C9             	.LL364:
 8112                        		__call		_recenter_CAMERA
         01:D4C9  20 59 FF   			call	_recenter_CAMERA
 8113                        	
 8114                        		.dbg	line,	"include\routines_LEVELS.c", 1811; }
 8115                        	
 8116                        		.dbg	line,	"include\routines_LEVELS.c", 1814; else if(player_state == STATE_JUMP_LADDER)
 8117                        		__bra		.LL365
         01:D4CC  4C 58 D6   			bra	.LL365
 8118    01:D4CF             	.LL352:
 8119                        		__ld.umq	_player_state
         01:D4CF  AD 15 23   			lda	_player_state
 8120                        		__equ_b.uiq	13
         01:D4D2  C9 0D      			cmp	#13
         01:D4D4  F0 01      			beq	!+
         01:D4D6  18         			clc
         01:D4D7             	!:
 8121                        		__bfalse	.LL366
         01:D4D7  B0 03 4C 58			bcc	.LL366
         01:D4DB  D6          
 8122                        	
 8123                        		.dbg	line,	"include\routines_LEVELS.c", 1815; {
 8124                        	
 8125                        		.dbg	line,	"include\routines_LEVELS.c", 1816; unsigned char i;
 8126                        	
 8127                        		.dbg	line,	"include\routines_LEVELS.c", 1817; i = 1;
 8128                        		__st.umiq	1, __update_PLAYER_end - 8  /* i */
         01:D4DC  A9 01      			lda.l	#1
         01:D4DE  8D 05 23   			sta	__update_PLAYER_end - 8
 8129                        	
 8130                        		.dbg	line,	"include\routines_LEVELS.c", 1820; if(player_counter_anim == 0)
 8131                        		__not.um	_player_counter_anim
         01:D4E1  AD 18 23   			lda	_player_counter_anim
         01:D4E4  18         			clc
         01:D4E5  D0 01      			bne	!+
         01:D4E7  38         			sec
         01:D4E8             	!:
 8132                        		__bfalse	.LL367
         01:D4E8  90 21      			bcc	.LL367
 8133                        	
 8134                        		.dbg	line,	"include\routines_LEVELS.c", 1821; {
 8135                        	
 8136                        		.dbg	line,	"include\routines_LEVELS.c", 1822; load_vram(PLAYER_VRAM_ADR, tiles_SPR_PLAYER + TILES_112 , TILES_16);
 8137                        		__st.wmiq	6144, _di
         01:D4EA  64 F0      			stz.l	_di
         01:D4EC  A9 18      			lda.h	#6144
         01:D4EE  85 F1      			sta.h	_di
 8138                        		__farptr	_tiles_SPR_PLAYER + 3584, _bp_bank, _bp
         01:D4F0  A9 E0      			lda.l	#$6000 + ($1FFF & (_tiles_SPR_PLAYER + 3584))
         01:D4F2  85 EC      			sta.l	_bp
         01:D4F4  A9 77      			lda.h	#$6000 + ($1FFF & (_tiles_SPR_PLAYER + 3584))
         01:D4F6  85 ED      			sta.h	_bp
         01:D4F8  A9 0E      			lda	#bank(_tiles_SPR_PLAYER + 3584)
         01:D4FA  85 02      			sta	_bp_bank
 8139                        		__st.wmiq	256, _ax
         01:D4FC  64 F8      			stz.l	_ax
         01:D4FE  A9 01      			lda.h	#256
         01:D500  85 F9      			sta.h	_ax
 8140                        		 _load_vram.3
         01:D502  82         			clx				; Offset to PCE VDC.
         01:D503  20 63 FF   			call	load_vram_x
 8141                        	
 8142                        		.dbg	line,	"include\routines_LEVELS.c", 1824; player_counter_anim = 1;
 8143                        		__st.umiq	1, _player_counter_anim
         01:D506  A9 01      			lda.l	#1
         01:D508  8D 18 23   			sta	_player_counter_anim
 8144                        	
 8145                        		.dbg	line,	"include\routines_LEVELS.c", 1825; }
 8146                        	
 8147                        		.dbg	line,	"include\routines_LEVELS.c", 1828; player_pos_y += TABLE_PLAYER_JUMP_V[player_index_jump];
 8148    01:D50B             	.LL367:
 8149                        		__ldx.umq	_player_index_jump
         01:D50B  AE 19 23   			ldx	_player_index_jump
 8150                        		__ld.bax	_TABLE_PLAYER_JUMP_V
         01:D50E  BD A2 60   			lda	_TABLE_PLAYER_JUMP_V, x
         01:D511  C2         			cly
         01:D512  10 01      			bpl	!+
         01:D514  88         			dey
         01:D515             	!:
 8151                        		__add_st.wmq	_player_pos_y
         01:D515  18         			clc
         01:D516  6D CA 24   			adc.l	_player_pos_y
         01:D519  8D CA 24   			sta.l	_player_pos_y
         01:D51C  98         			tya
         01:D51D  6D CB 24   			adc.h	_player_pos_y
         01:D520  8D CB 24   			sta.h	_player_pos_y
 8152                        	
 8153                        		.dbg	line,	"include\routines_LEVELS.c", 1830; // CHECK COLLISION WITH CEILING //
 8154                        	
 8155                        		.dbg	line,	"include\routines_LEVELS.c", 1831; check_BG( 15 , 8 );
 8156                        		__ld.wi		15
         01:D523  A9 0F      			lda.l	#15
         01:D525  C2         			cly
 8157                        		__pusharg.wr
         01:D526  A6 8D      			ldx	<__sp
         01:D528  CA         			dex
         01:D529  CA         			dex
         01:D52A  95 08      			sta.l	<__stack, x
         01:D52C  94 09      			sty.h	<__stack, x
         01:D52E  86 8D      			stx	<__sp
 8158                        		__ld.wi		8
         01:D530  A9 08      			lda.l	#8
         01:D532  C2         			cly
 8159                        		__pusharg.wr
         01:D533  A6 8D      			ldx	<__sp
         01:D535  CA         			dex
         01:D536  CA         			dex
         01:D537  95 08      			sta.l	<__stack, x
         01:D539  94 09      			sty.h	<__stack, x
         01:D53B  86 8D      			stx	<__sp
 8160                        		__call		_check_BG
         01:D53D  20 6D FF   			call	_check_BG
 8161                        	
 8162                        		.dbg	line,	"include\routines_LEVELS.c", 1833; if(map_blk_flag == TILE_BG)
 8163                        		__ld.umq	_map_blk_flag
         01:D540  AD A5 2B   			lda	_map_blk_flag
 8164                        		__equ_b.uiq	1
         01:D543  C9 01      			cmp	#1
         01:D545  F0 01      			beq	!+
         01:D547  18         			clc
         01:D548             	!:
 8165                        		__bfalse	.LL368
         01:D548  90 5A      			bcc	.LL368
 8166                        	
 8167                        		.dbg	line,	"include\routines_LEVELS.c", 1834; {
 8168                        	
 8169                        		.dbg	line,	"include\routines_LEVELS.c", 1835; for(i=1 ; i<8 ; i++)
 8170                        		__st.umiq	1, __update_PLAYER_end - 8  /* i */
         01:D54A  A9 01      			lda.l	#1
         01:D54C  8D 05 23   			sta	__update_PLAYER_end - 8
 8171    01:D54F             	.LL369:
 8172                        		__ld.umq	__update_PLAYER_end - 8  /* i */
         01:D54F  AD 05 23   			lda	__update_PLAYER_end - 8
 8173                        		__ult_b.uiq	8
         01:D552  C9 08      			cmp	#8		; Subtract integer from A.
         01:D554  6A         			ror	a		; CC if A < integer.
         01:D555  49 80      			eor	#$80
         01:D557  2A         			rol	a
 8174                        		__btrue		.LL371
         01:D558  B0 07      			bcs	.LL371
 8175                        		__bra		.LL372
         01:D55A  80 48      			bra	.LL372
 8176    01:D55C             	.LL370:
 8177                        		__inc.umq	__update_PLAYER_end - 8  /* i */
         01:D55C  EE 05 23   			inc	__update_PLAYER_end - 8
 8178                        		__bra		.LL369
         01:D55F  80 EE      			bra	.LL369
 8179    01:D561             	.LL371:
 8180                        	
 8181                        		.dbg	line,	"include\routines_LEVELS.c", 1836; {
 8182                        	
 8183                        		.dbg	line,	"include\routines_LEVELS.c", 1837; check_BG( 15 , 8 + i );
 8184                        		__ld.wi		15
         01:D561  A9 0F      			lda.l	#15
         01:D563  C2         			cly
 8185                        		__pusharg.wr
         01:D564  A6 8D      			ldx	<__sp
         01:D566  CA         			dex
         01:D567  CA         			dex
         01:D568  95 08      			sta.l	<__stack, x
         01:D56A  94 09      			sty.h	<__stack, x
         01:D56C  86 8D      			stx	<__sp
 8186                        		__ld.wi		8
         01:D56E  A9 08      			lda.l	#8
         01:D570  C2         			cly
 8187                        		__add.um	__update_PLAYER_end - 8  /* i */
         01:D571  18         			clc
         01:D572  6D 05 23   			adc	__update_PLAYER_end - 8
         01:D575  90 01      			bcc	!+
         01:D577  C8         			iny
         01:D578             	!:
 8188                        		__pusharg.wr
         01:D578  A6 8D      			ldx	<__sp
         01:D57A  CA         			dex
         01:D57B  CA         			dex
         01:D57C  95 08      			sta.l	<__stack, x
         01:D57E  94 09      			sty.h	<__stack, x
         01:D580  86 8D      			stx	<__sp
 8189                        		__call		_check_BG
         01:D582  20 6D FF   			call	_check_BG
 8190                        	
 8191                        		.dbg	line,	"include\routines_LEVELS.c", 1838; {
 8192                        	
 8193                        		.dbg	line,	"include\routines_LEVELS.c", 1839; if(map_blk_flag == TILE_EMPTY)
 8194                        		__not.um	_map_blk_flag
         01:D585  AD A5 2B   			lda	_map_blk_flag
         01:D588  18         			clc
         01:D589  D0 01      			bne	!+
         01:D58B  38         			sec
         01:D58C             	!:
 8195                        		__bfalse	.LL373
         01:D58C  90 CE      			bcc	.LL373
 8196                        	
 8197                        		.dbg	line,	"include\routines_LEVELS.c", 1840; {
 8198                        	
 8199                        		.dbg	line,	"include\routines_LEVELS.c", 1841; player_pos_y += i;
 8200                        		__ld.um		__update_PLAYER_end - 8  /* i */
         01:D58E  AD 05 23   			lda	__update_PLAYER_end - 8
         01:D591  C2         			cly
 8201                        		__add_st.wmq	_player_pos_y
         01:D592  18         			clc
         01:D593  6D CA 24   			adc.l	_player_pos_y
         01:D596  8D CA 24   			sta.l	_player_pos_y
         01:D599  98         			tya
         01:D59A  6D CB 24   			adc.h	_player_pos_y
         01:D59D  8D CB 24   			sta.h	_player_pos_y
 8202                        	
 8203                        		.dbg	line,	"include\routines_LEVELS.c", 1842; break;
 8204                        		__bra		.LL372
         01:D5A0  80 02      			bra	.LL372
 8205                        	
 8206                        		.dbg	line,	"include\routines_LEVELS.c", 1843; }
 8207                        	
 8208                        		.dbg	line,	"include\routines_LEVELS.c", 1844; }
 8209    01:D5A2             	.LL373	.alias		.LL370
 8210                        	
 8211                        		.dbg	line,	"include\routines_LEVELS.c", 1845; }
 8212                        		__bra		.LL370
         01:D5A2  80 B8      			bra	.LL370
 8213    01:D5A4             	.LL372:
 8214                        	
 8215                        		.dbg	line,	"include\routines_LEVELS.c", 1846; }
 8216                        	
 8217                        		.dbg	line,	"include\routines_LEVELS.c", 1848; spr_set(player_id);
 8218    01:D5A4             	.LL368:
 8219                        		__ld.umq	_player_id
         01:D5A4  AD 14 23   			lda	_player_id
 8220                        		__call		_spr_set.1
         01:D5A7  20 DD E7   			call	_spr_set.1
 8221                        	
 8222                        		.dbg	line,	"include\routines_LEVELS.c", 1849; spr_y(player_pos_y);
 8223                        		__ld.wm		_player_pos_y
         01:D5AA  AD CA 24   			lda.l	_player_pos_y
         01:D5AD  AC CB 24   			ldy.h	_player_pos_y
 8224                        		__call		_spr_y.1
         01:D5B0  20 19 E8   			call	_spr_y.1
 8225                        	
 8226                        		.dbg	line,	"include\routines_LEVELS.c", 1853; if(player_index_jump < 34)
 8227                        		__ld.umq	_player_index_jump
         01:D5B3  AD 19 23   			lda	_player_index_jump
 8228                        		__ult_b.uiq	34
         01:D5B6  C9 22      			cmp	#34		; Subtract integer from A.
         01:D5B8  6A         			ror	a		; CC if A < integer.
         01:D5B9  49 80      			eor	#$80
         01:D5BB  2A         			rol	a
 8229                        		__bfalse	.LL374
         01:D5BC  90 03      			bcc	.LL374
 8230                        	
 8231                        		.dbg	line,	"include\routines_LEVELS.c", 1854; {
 8232                        	
 8233                        		.dbg	line,	"include\routines_LEVELS.c", 1855; player_index_jump += 1;
 8234                        		__add_st.umiq	1, _player_index_jump
         01:D5BE  EE 19 23   			inc	_player_index_jump
 8235                        	
 8236                        		.dbg	line,	"include\routines_LEVELS.c", 1856; }
 8237                        	
 8238                        		.dbg	line,	"include\routines_LEVELS.c", 1861; //--------------------------------------------------------------------------------------//
 8239                        	
 8240                        		.dbg	line,	"include\routines_LEVELS.c", 1862; //                                   LADDER COLLISION                                   //
 8241                        	
 8242                        		.dbg	line,	"include\routines_LEVELS.c", 1863; //--------------------------------------------------------------------------------------//
 8243                        	
 8244                        		.dbg	line,	"include\routines_LEVELS.c", 1865; if(player_index_jump > 18)
 8245    01:D5C1             	.LL374:
 8246                        		__ld.umq	_player_index_jump
         01:D5C1  AD 19 23   			lda	_player_index_jump
 8247                        		__ugt_b.uiq	18
         01:D5C4  18         			clc			; Subtract integer+1 from A.
         01:D5C5  E9 12      			sbc	#18		; CS if A > integer.
 8248                        		__bfalse	.LL375
         01:D5C7  B0 03 4C 58			bcc	.LL375
         01:D5CB  D6          
 8249                        	
 8250                        		.dbg	line,	"include\routines_LEVELS.c", 1866; {
 8251                        	
 8252                        		.dbg	line,	"include\routines_LEVELS.c", 1867; // CHECK COLLISION WITH LADDERS //
 8253                        	
 8254                        		.dbg	line,	"include\routines_LEVELS.c", 1868; check_BG( 16 , 8 );
 8255                        		__ld.wi		16
         01:D5CC  A9 10      			lda.l	#16
         01:D5CE  C2         			cly
 8256                        		__pusharg.wr
         01:D5CF  A6 8D      			ldx	<__sp
         01:D5D1  CA         			dex
         01:D5D2  CA         			dex
         01:D5D3  95 08      			sta.l	<__stack, x
         01:D5D5  94 09      			sty.h	<__stack, x
         01:D5D7  86 8D      			stx	<__sp
 8257                        		__ld.wi		8
         01:D5D9  A9 08      			lda.l	#8
         01:D5DB  C2         			cly
 8258                        		__pusharg.wr
         01:D5DC  A6 8D      			ldx	<__sp
         01:D5DE  CA         			dex
         01:D5DF  CA         			dex
         01:D5E0  95 08      			sta.l	<__stack, x
         01:D5E2  94 09      			sty.h	<__stack, x
         01:D5E4  86 8D      			stx	<__sp
 8259                        		__call		_check_BG
         01:D5E6  20 6D FF   			call	_check_BG
 8260                        	
 8261                        		.dbg	line,	"include\routines_LEVELS.c", 1870; // IF PLAYER HITS THE LADDER //
 8262                        	
 8263                        		.dbg	line,	"include\routines_LEVELS.c", 1871; if(map_blk_flag == TILE_LADDER)
 8264                        		__ld.umq	_map_blk_flag
         01:D5E9  AD A5 2B   			lda	_map_blk_flag
 8265                        		__equ_b.uiq	2
         01:D5EC  C9 02      			cmp	#2
         01:D5EE  F0 01      			beq	!+
         01:D5F0  18         			clc
         01:D5F1             	!:
 8266                        		__bfalse	.LL376
         01:D5F1  90 65      			bcc	.LL376
 8267                        	
 8268                        		.dbg	line,	"include\routines_LEVELS.c", 1872; {
 8269                        	
 8270                        		.dbg	line,	"include\routines_LEVELS.c", 1873; // CAMERA GOES 8 PX BACKWARD //
 8271                        	
 8272                        		.dbg	line,	"include\routines_LEVELS.c", 1874; sgx_map_pxl_x = ( (sgx_map_pxl_x >> 3) << 3 );
 8273                        		__ld.wm		_sgx_map_pxl_x
         01:D5F3  AD 84 26   			lda.l	_sgx_map_pxl_x
         01:D5F6  AC 85 26   			ldy.h	_sgx_map_pxl_x
 8274                        		__lsr.wi	3
         01:D5F9  84 00      			sty	__temp
         01:D5FB  20 3A E2   			jsr	lsrw3
 8275                        		__asl.wi	3
         01:D5FE  84 00      			sty	__temp
         01:D600  20 D7 E1   			jsr	aslw3
 8276                        		__st.wmq	_sgx_map_pxl_x
         01:D603  8D 84 26   			sta.l	_sgx_map_pxl_x
         01:D606  8C 85 26   			sty.h	_sgx_map_pxl_x
 8277                        	
 8278                        		.dbg	line,	"include\routines_LEVELS.c", 1876; // SO WE UPDATE THE MAP //
 8279                        	
 8280                        		.dbg	line,	"include\routines_LEVELS.c", 1877; sgx_scroll_map();
 8281                        		__call		_sgx_scroll_map
         01:D609  20 81 FF   			call	_sgx_scroll_map
 8282                        	
 8283                        		.dbg	line,	"include\routines_LEVELS.c", 1879; // CHECK IF THE PLAYER STANDS RIGHT TO THE LADDER //
 8284                        	
 8285                        		.dbg	line,	"include\routines_LEVELS.c", 1880; check_BG( 31 , 8 );
 8286                        		__ld.wi		31
         01:D60C  A9 1F      			lda.l	#31
         01:D60E  C2         			cly
 8287                        		__pusharg.wr
         01:D60F  A6 8D      			ldx	<__sp
         01:D611  CA         			dex
         01:D612  CA         			dex
         01:D613  95 08      			sta.l	<__stack, x
         01:D615  94 09      			sty.h	<__stack, x
         01:D617  86 8D      			stx	<__sp
 8288                        		__ld.wi		8
         01:D619  A9 08      			lda.l	#8
         01:D61B  C2         			cly
 8289                        		__pusharg.wr
         01:D61C  A6 8D      			ldx	<__sp
         01:D61E  CA         			dex
         01:D61F  CA         			dex
         01:D620  95 08      			sta.l	<__stack, x
         01:D622  94 09      			sty.h	<__stack, x
         01:D624  86 8D      			stx	<__sp
 8290                        		__call		_check_BG
         01:D626  20 6D FF   			call	_check_BG
 8291                        	
 8292                        		.dbg	line,	"include\routines_LEVELS.c", 1882; if(map_blk_flag == TILE_LADDER)
 8293                        		__ld.umq	_map_blk_flag
         01:D629  AD A5 2B   			lda	_map_blk_flag
 8294                        		__equ_b.uiq	2
         01:D62C  C9 02      			cmp	#2
         01:D62E  F0 01      			beq	!+
         01:D630  18         			clc
         01:D631             	!:
 8295                        		__bfalse	.LL377
         01:D631  90 0E      			bcc	.LL377
 8296                        	
 8297                        		.dbg	line,	"include\routines_LEVELS.c", 1883; {
 8298                        	
 8299                        		.dbg	line,	"include\routines_LEVELS.c", 1884; sgx_map_pxl_x += 8;
 8300                        		__add_st.wmiq	8, _sgx_map_pxl_x
         01:D633  18         			clc
         01:D634  AD 84 26   			lda.l	_sgx_map_pxl_x
         01:D637  69 08      			adc.l	#8
         01:D639  8D 84 26   			sta.l	_sgx_map_pxl_x
         01:D63C  90 03      			bcc	!+
         01:D63E  EE 85 26   			inc.h	_sgx_map_pxl_x
         01:D641             	!:
 8301                        	
 8302                        		.dbg	line,	"include\routines_LEVELS.c", 1885; }
 8303                        	
 8304                        		.dbg	line,	"include\routines_LEVELS.c", 1887; player_counter_anim = 1;
 8305    01:D641             	.LL377:
 8306                        		__st.umiq	1, _player_counter_anim
         01:D641  A9 01      			lda.l	#1
         01:D643  8D 18 23   			sta	_player_counter_anim
 8307                        	
 8308                        		.dbg	line,	"include\routines_LEVELS.c", 1888; player_index_jump = 0;
 8309                        		__st.umiq	0, _player_index_jump
         01:D646  9C 19 23   			stz	_player_index_jump
 8310                        	
 8311                        		.dbg	line,	"include\routines_LEVELS.c", 1889; jump_ladder = TRUE;
 8312                        		__st.umiq	1, _jump_ladder
         01:D649  A9 01      			lda.l	#1
         01:D64B  8D 1B 23   			sta	_jump_ladder
 8313                        	
 8314                        		.dbg	line,	"include\routines_LEVELS.c", 1890; jump_max_index = 29;
 8315                        		__st.umiq	29, _jump_max_index
         01:D64E  A9 1D      			lda.l	#29
         01:D650  8D 1C 23   			sta	_jump_max_index
 8316                        	
 8317                        		.dbg	line,	"include\routines_LEVELS.c", 1891; player_state = STATE_HANG;
 8318                        		__st.umiq	10, _player_state
         01:D653  A9 0A      			lda.l	#10
         01:D655  8D 15 23   			sta	_player_state
 8319                        	
 8320                        		.dbg	line,	"include\routines_LEVELS.c", 1892; }
 8321                        	
 8322                        		.dbg	line,	"include\routines_LEVELS.c", 1893; }
 8323    01:D658             	.LL376:
 8324                        	
 8325                        		.dbg	line,	"include\routines_LEVELS.c", 1894; }
 8326    01:D658             	.LL375:
 8327                        	
 8328                        		.dbg	line,	"include\routines_LEVELS.c", 1896; }
 8329    01:D658             	.LL366:
 8330    01:D658             	.LL365:
 8331    01:D658             	.LL351:
 8332    01:D658             	.LL337:
 8333    01:D658             	.LL334:
 8334    01:D658             	.LL319:
 8335    01:D658             	.LL316:
 8336    01:D658             	.LL279:
 8337    01:D658             	.LL242:
 8338    01:D658             	.LL216:
 8339    01:D658             	.LL185:
 8340    01:D658             	.LL180:
 8341                        		__return	0
         01:D658  4C EF FF   			jmp	leave_proc
 8342                        		.dbg	clear
 8343                        		.endp
 8344               7960     		.data
 8345               2305     		.bss
 8346    F8:2305             	__update_PLAYER_loc:
 8347    F8:2305             			ds	8
 8348    F8:230D             	__update_PLAYER_end:
 8349               E309     		.code
 8350                        		.pceas
 8351                        	
 8352                        		.dbg	line,	"main.c", 23; #include "include/routines_SHOP.c"
 8353                        		.dbg	line,	"include\routines_SHOP.c", 1; #include "huc.h"
 8354                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 1; #ifndef _hucc_legacy_h
 8355                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 2; #define _hucc_legacy_h
 8356                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 4; /****************************************************************************
 8357                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 5; ; ***************************************************************************
 8358                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 6; ;
 8359                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 7; ; huc.h
 8360                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 8; ;
 8361                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 9; ; HuCC wrapper file to include a default set of HuC-compatible functions.
 8362                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 10; ;
 8363                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 11; ; Copyright John Brandwood 2024.
 8364                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 12; ;
 8365                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 13; ; Distributed under the Boost Software License, Version 1.0.
 8366                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 14; ; (See accompanying file LICENSE_1_0.txt or copy at
 8367                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 15; ;  http://www.boost.org/LICENSE_1_0.txt)
 8368                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 16; ;
 8369                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 17; ; ***************************************************************************
 8370                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 18; ; ***************************************************************************
 8371                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 19; ;
 8372                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 20; ; When the HuCC compiler is invoked with the "--legacy" option to compile old
 8373                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 21; ; projects, then this "huc.h" file is automatically included.
 8374                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 22; ;
 8375                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 23; ; This file includes a set of the individual HuCC headers which correspond to
 8376                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 24; ; HuC's built-in functions and MagicKit library.
 8377                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 25; ;
 8378                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 26; ; New HuCC projects should, preferably, include the specific headers that are
 8379                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 27; ; needed, which will then allow them to replace parts of the standard library
 8380                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 28; ; with newer functions, or they can just manually include this "huc.h" file.
 8381                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 29; ;
 8382                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 30; ; ***************************************************************************
 8383                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 31; ; **************************************************************************/
 8384                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 33; #include "hucc-systemcard.h"
 8385                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 34; #include "hucc-baselib.h"
 8386                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 35; #include "hucc-gfx.h"
 8387                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 36; #include "hucc-string.h"
 8388                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 37; #include "hucc-old-scroll.h"
 8389                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 38; #include "hucc-old-spr.h"
 8390                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 39; #include "hucc-old-map.h"
 8391                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 40; #include "hucc-old-line.h"
 8392                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 42; #endif // _hucc_legacy_h
 8393                        		.dbg	line,	"include\routines_SHOP.c", 2; #include "hucc-scroll.h"
 8394                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 1; #ifndef _hucc_scroll_h
 8395                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 2; #define _hucc_scroll_h
 8396                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 4; /****************************************************************************
 8397                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 5; ; ***************************************************************************
 8398                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 6; ;
 8399                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 7; ; hucc-scroll.h
 8400                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 8; ;
 8401                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 9; ; Routines for a fast split-screen scrolling system.
 8402                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 10; ;
 8403                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 11; ; Copyright John Brandwood 2024.
 8404                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 12; ;
 8405                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 13; ; Distributed under the Boost Software License, Version 1.0.
 8406                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 14; ; (See accompanying file LICENSE_1_0.txt or copy at
 8407                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 15; ;  http://www.boost.org/LICENSE_1_0.txt)
 8408                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 16; ;
 8409                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 17; ; ***************************************************************************
 8410                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 18; ; ***************************************************************************
 8411                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 19; ;
 8412                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 20; ; The maximum number of splits for each screen layer is set in your project's
 8413                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 21; ; "hucc-config.inc" file, with the library having a limit of 128-per-layer.
 8414                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 22; ;
 8415                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 23; ; Your first active split must be defined to start at screen line 0, and then
 8416                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 24; ; the rest of the active splits must be in increasing line order to match the
 8417                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 25; ; way that the PC Engine displays the output image.
 8418                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 26; ;
 8419                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 27; ; You can have disabled splits interleaved with your active splits.
 8420                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 28; ;
 8421                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 29; ; Splits that are normally disabled can be used to create full screen effects
 8422                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 30; ; such as bouncing the screen up and down by adding blank areas at the top or
 8423                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 31; ; bottom of the screen, and then rapidly changing the height of those areas.
 8424                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 32; ;
 8425                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 33; ; ***************************************************************************
 8426                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 34; ; **************************************************************************/
 8427                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 36; // *************
 8428                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 37; // VDC bits for display_flags ...
 8429                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 38; // *************
 8430                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 40; #ifndef BKG_OFF
 8431                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 41; #define BKG_OFF 0x00
 8432                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 42; #endif
 8433                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 44; #ifndef SPR_OFF
 8434                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 45; #define SPR_OFF 0x00
 8435                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 46; #endif
 8436                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 48; #ifndef BKG_ON
 8437                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 49; #define BKG_ON 0x80
 8438                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 50; #endif
 8439                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 52; #ifndef SPR_ON
 8440                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 53; #define SPR_ON 0x40
 8441                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 54; #endif
 8442                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 56; // *************
 8443                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 57; // Functions in hucc-scroll.asm ...
 8444                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 58; // *************
 8445                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 60; #ifdef __HUCC__
 8446                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 62; #asmdef	HUCC_USES_NEW_SCROLL 1
 8447                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 64; extern void __fastcall scroll_split( unsigned char index<_al>, unsigned char screen_line<_ah>, unsigned int bat_x<_bx>, unsigned int bat_y<_cx>, unsigned char display_flags<_dl> );
 8448                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 65; extern void __fastcall sgx_scroll_split( unsigned char index<_al>, unsigned char screen_line<_ah>, unsigned int bat_x<_bx>, unsigned int bat_y<_cx>, unsigned char display_flags<_dl> );
 8449                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 67; extern void __fastcall disable_split( unsigned char index<acc> );
 8450                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 68; extern void __fastcall sgx_disable_split( unsigned char index<acc> );
 8451                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 70; extern void __fastcall __macro disable_all_splits( void );
 8452                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 71; extern void __fastcall __macro sgx_disable_all_splits( void );
 8453                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 73; #asm
 8454                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 74; .macro	_disable_all_splits
 8455                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 75; ldy	#HUCC_PCE_SPLITS - 1
 8456                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 76; !loop:		tya
 8457                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 77; call	_disable_split.1
 8458                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 78; dey
 8459                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 79; bpl	!loop-
 8460                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 80; .endm
 8461                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 82; .macro	_sgx_disable_all_splits
 8462                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 83; ldy	#HUCC_SGX_SPLITS - 1
 8463                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 84; !loop:		tya
 8464                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 85; call	_sgx_disable_split.1
 8465                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 86; dey
 8466                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 87; bpl	!loop-
 8467                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 88; .endm
 8468                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 89; #endasm
 8469                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 91; #endif // __HUCC__
 8470                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 93; #endif // _hucc_scroll_h
 8471                        		.dbg	line,	"include\routines_SHOP.c", 3; #include "hucc-chrmap.h"
 8472                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 1; #ifndef _hucc_chrmap_h
 8473                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 2; #define _hucc_chrmap_h
 8474                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 4; /****************************************************************************
 8475                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 5; ; ***************************************************************************
 8476                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 6; ;
 8477                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 7; ; hucc-chrmap.h
 8478                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 8; ;
 8479                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 9; ; A simple map system based on 8x8 characters (aka "tiles") in BAT format.
 8480                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 10; ;
 8481                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 11; ; Copyright John Brandwood 2025.
 8482                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 12; ;
 8483                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 13; ; Distributed under the Boost Software License, Version 1.0.
 8484                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 14; ; (See accompanying file LICENSE_1_0.txt or copy at
 8485                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 15; ;  http://www.boost.org/LICENSE_1_0.txt)
 8486                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 16; ;
 8487                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 17; ; ***************************************************************************
 8488                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 18; ; ***************************************************************************
 8489                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 19; ;
 8490                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 20; ; The maximum X and Y size for chrmaps is 256 characters (2048 pixels).
 8491                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 21; ;
 8492                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 22; ; The maximum total size for a chrmap is 16KBytes, which allows for maps up
 8493                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 23; ; to 256x32 tiles (2048x256 pixels).
 8494                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 24; ;
 8495                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 25; ; ***************************************************************************
 8496                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 26; ; **************************************************************************/
 8497                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 28; // *************
 8498                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 29; // This code extends the blkmap library ...
 8499                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 30; // *************
 8500                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 32; #include "hucc-blkmap.h"
 8501                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 34; // *************
 8502                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 35; // Functions in chrmap.asm ...
 8503                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 36; // *************
 8504                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 38; #ifdef __HUCC__
 8505                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 40; #asmdef	HUCC_USES_CHRMAP 1
 8506                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 42; extern void __fastcall __nop set_chrmap( unsigned char __far *chrmap<vdc_map_bank:vdc_map_addr>, unsigned char tiles_w<vdc_map_line_w> );
 8507                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 44; extern void __fastcall draw_bat( void );
 8508                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 45; extern void __fastcall scroll_bat( void );
 8509                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 47; extern void __fastcall blit_bat( unsigned char tile_x<map_bat_x>, unsigned char tile_y<map_bat_y>, unsigned char tile_w<map_draw_x>, unsigned char tile_h<map_draw_y> );
 8510                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 49; #ifdef _SGX
 8511                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 51; extern void __fastcall __nop sgx_set_chrmap( unsigned char __far *chrmap<sgx_map_bank:sgx_map_addr>, unsigned char tiles_w<sgx_map_line_w> );
 8512                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 53; extern void __fastcall sgx_draw_bat( void );
 8513                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 54; extern void __fastcall sgx_scroll_bat( void );
 8514                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 56; extern void __fastcall sgx_blit_bat( unsigned char tile_x<map_bat_x>, unsigned char tile_y<map_bat_y>, unsigned char tile_w<map_draw_x>, unsigned char tile_h<map_draw_y> );
 8515                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 58; #endif
 8516                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 60; #endif // __HUCC__
 8517                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 62; #endif // _hucc_chrmap_h
 8518                        		.dbg	line,	"include\routines_SHOP.c", 4; #include "hucc-blkmap.h"
 8519                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 1; #ifndef _hucc_blkmap_h
 8520                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 2; #define _hucc_blkmap_h
 8521                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 4; /****************************************************************************
 8522                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 5; ; ***************************************************************************
 8523                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 6; ;
 8524                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 7; ; hucc-blkmap.h
 8525                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 8; ;
 8526                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 9; ; A map system based on 16x16 meta-tiles (aka "blocks", aka CHR/BLK/MAP).
 8527                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 10; ;
 8528                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 11; ; Copyright John Brandwood 2025.
 8529                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 12; ;
 8530                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 13; ; Distributed under the Boost Software License, Version 1.0.
 8531                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 14; ; (See accompanying file LICENSE_1_0.txt or copy at
 8532                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 15; ;  http://www.boost.org/LICENSE_1_0.txt)
 8533                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 16; ;
 8534                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 17; ; ***************************************************************************
 8535                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 18; ; ***************************************************************************
 8536                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 19; ;
 8537                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 20; ; The maximum X and Y size for blkmaps is 128 blocks (2048 pixels).
 8538                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 21; ;
 8539                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 22; ; The maximum total size for a blkmap is 16KBytes, which allows for maps up
 8540                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 23; ; to 128x128 blocks (2048x2048 pixels).
 8541                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 24; ;
 8542                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 25; ; Huge multi-screen blkmaps are also supported (optionally).
 8543                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 26; ;
 8544                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 27; ; The maximum X and Y for multi-screen maps is 128 screens (32768 pixels).
 8545                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 28; ;
 8546                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 29; ; The maximum total size for a multi-screen map is 8KBytes, which allows for
 8547                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 30; ; a total of 1024 screens.
 8548                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 31; ;
 8549                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 32; ; ***************************************************************************
 8550                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 33; ; **************************************************************************/
 8551                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 35; // *************
 8552                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 36; // Functions in blkmap.asm ...
 8553                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 37; // *************
 8554                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 39; #ifdef __HUCC__
 8555                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 41; #asmdef	HUCC_USES_BLKMAP 1
 8556                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 43; // Current top-left of drawn map in pixels.
 8557                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 44; extern unsigned int   vdc_map_pxl_x;
 8558                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 45; extern unsigned int   vdc_map_pxl_y;
 8559                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 47; // Width and height to draw/scroll in characters (not tiles).
 8560                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 48; extern unsigned char  vdc_map_draw_w;
 8561                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 49; extern unsigned char  vdc_map_draw_h;
 8562                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 51; // Width of map (or multi-screen BAT) in tiles.
 8563                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 52; extern unsigned char  vdc_map_line_w;
 8564                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 54; // Width of map in screens (if multi-screen map).
 8565                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 55; extern unsigned char  vdc_map_scrn_w;
 8566                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 57; // Extra information returned by get_map_block() and sgx_get_map_block(),
 8567                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 58; // which are the collision flags and the mask/overlay sprite for the BLK.
 8568                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 59; extern unsigned char  map_blk_flag;
 8569                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 60; extern unsigned char  map_blk_mask;
 8570                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 62; extern unsigned char  vdc_scr_bank;
 8571                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 63; extern unsigned char *vdc_scr_addr;
 8572                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 65; extern unsigned char  vdc_map_bank;
 8573                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 66; extern unsigned char *vdc_map_addr;
 8574                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 68; extern unsigned char  vdc_blk_bank;
 8575                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 69; extern unsigned char *vdc_blk_addr;
 8576                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 71; extern unsigned char  vdc_tbl_bank;
 8577                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 72; extern unsigned char *vdc_tbl_addr;
 8578                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 74; extern void __fastcall set_blocks( unsigned char __far *blk_def<vdc_blk_bank:vdc_blk_addr>, unsigned char __far *flg_def<vdc_tbl_bank:vdc_tbl_addr>, unsigned char number_of_blocks<_al> );
 8579                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 75; extern void __fastcall __macro set_blkmap( unsigned char __far *blk_map<vdc_map_bank:vdc_map_addr>, unsigned char blocks_w<vdc_map_line_w> );
 8580                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 76; extern void __fastcall __macro set_multimap( unsigned char __far *multi_map<vdc_scr_bank:vdc_scr_addr>, unsigned char screens_w<vdc_map_scrn_w> );
 8581                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 78; extern void __fastcall draw_map( void );
 8582                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 79; extern void __fastcall scroll_map( void );
 8583                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 81; extern void __fastcall blit_map( unsigned char tile_x<map_bat_x>, unsigned char tile_y<map_bat_y>, unsigned char tile_w<map_draw_x>, unsigned char tile_h<map_draw_y> );
 8584                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 83; extern unsigned char __fastcall get_map_block( unsigned int x<map_pxl_x>, unsigned int y<map_pxl_y> );
 8585                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 85; #asm
 8586                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 86; .macro	_set_blkmap.2
 8587                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 87; stz	vdc_scr_bank
 8588                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 88; .endm
 8589                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 90; .macro	_set_multimap.2
 8590                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 91; lda	vdc_bat_width
 8591                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 92; lsr	a
 8592                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 93; sta	vdc_map_line_w
 8593                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 94; .endm
 8594                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 96; .macro	SCREEN
 8595                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 97; db	(((\1) & $1FFF) | $6000) >> 8, bank(\1)
 8596                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 98; db	(((\2) & $1FFF) | $4000) >> 8, bank(\2)
 8597                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 99; db	(((\3) & $1FFF) | $6000) >> 8, bank(\3)
 8598                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 100; dw	(\4)
 8599                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 101; .endm
 8600                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 102; #endasm
 8601                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 104; #ifdef _SGX
 8602                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 106; // Current top-left of drawn map in pixels.
 8603                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 107; extern unsigned int   sgx_map_pxl_x;
 8604                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 108; extern unsigned int   sgx_map_pxl_y;
 8605                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 110; // Width and height to draw/scroll in characters (not tiles).
 8606                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 111; extern unsigned char  sgx_map_draw_w;
 8607                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 112; extern unsigned char  sgx_map_draw_h;
 8608                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 114; // Width of map (or multi-screen BAT) in tiles.
 8609                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 115; extern unsigned char  sgx_map_line_w;
 8610                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 117; // Width of map in screens (if multi-screen map).
 8611                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 118; extern unsigned char  sgx_map_scrn_w;
 8612                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 120; extern unsigned char  sgx_scr_bank;
 8613                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 121; extern unsigned char *sgx_scr_addr;
 8614                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 123; extern unsigned char  sgx_map_bank;
 8615                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 124; extern unsigned char *sgx_map_addr;
 8616                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 126; extern unsigned char  sgx_blk_bank;
 8617                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 127; extern unsigned char *sgx_blk_addr;
 8618                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 129; extern unsigned char  sgx_tbl_bank;
 8619                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 130; extern unsigned char *sgx_tbl_addr;
 8620                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 132; extern void __fastcall sgx_set_blocks( unsigned char __far *blk_def<sgx_blk_bank:sgx_blk_addr>, unsigned char __far *flg_def<sgx_tbl_bank:sgx_tbl_addr>, unsigned char number_of_blocks<_al> );
 8621                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 133; extern void __fastcall __macro sgx_set_blkmap( unsigned char __far *blk_map<sgx_map_bank:sgx_map_addr>, unsigned char blocks_w<sgx_map_line_w> );
 8622                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 134; extern void __fastcall __macro sgx_set_multimap( unsigned char __far *multi_map<sgx_scr_bank:sgx_scr_addr>, unsigned char screens_w<sgx_map_scrn_w> );
 8623                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 136; extern void __fastcall sgx_draw_map( void );
 8624                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 137; extern void __fastcall sgx_scroll_map( void );
 8625                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 139; extern void __fastcall sgx_blit_map( unsigned char tile_x<map_bat_x>, unsigned char tile_y<map_bat_y>, unsigned char tile_w<map_draw_x>, unsigned char tile_h<map_draw_y> );
 8626                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 141; extern unsigned char __fastcall sgx_get_map_block( unsigned int x<map_pxl_x>, unsigned int y<map_pxl_y> );
 8627                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 143; #asm
 8628                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 144; .macro	_sgx_set_blkmap.2
 8629                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 145; stz	sgx_scr_bank
 8630                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 146; .endm
 8631                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 148; .macro	_sgx_set_multimap.2
 8632                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 149; lda	sgx_bat_width
 8633                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 150; lsr	a
 8634                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 151; sta	sgx_map_line_w
 8635                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 152; .endm
 8636                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 153; #endasm
 8637                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 155; #endif
 8638                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 157; #endif // __HUCC__
 8639                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 159; #endif // _hucc_blkmap_h
 8640                        		.dbg	line,	"include\routines_SHOP.c", 13; void joypad_BUTTONS_SHOP()
 8641                        		.dbg	line,	"include\routines_SHOP.c", 14; {
 8642                        	;***********************
 8643                        	;***********************
 8644                        	
 8645                        		.hucc
 8646    10:D960             		.proc		_joypad_BUTTONS_SHOP
 8647                        		__enter		_joypad_BUTTONS_SHOP
 8648                        	
 8649                        		.dbg	line,	"include\routines_SHOP.c", 15; if(joytrg(JOYPAD_1) & JOY_RIGHT)
 8650                        		__ld.uiq	0
         10:D960  62         			cla
 8651                        		 _joytrg.1
         10:D961  AA         			tax
         10:D962  BD 2D 22   			lda	joytrg, x
         10:D965  BC DD 22   			ldy	joy6trg, x
 8652                        		__tand.wi	32
         10:D968  29 20      			and	#32
         10:D96A  C9 01      	!:		cmp	#1
 8653                        		__bfalse	.LL379
         10:D96C  90 59      			bcc	.LL379
 8654                        	
 8655                        		.dbg	line,	"include\routines_SHOP.c", 16; {   
 8656                        	
 8657                        		.dbg	line,	"include\routines_SHOP.c", 17; char max_index;
 8658                        	
 8659                        		.dbg	line,	"include\routines_SHOP.c", 18; 
 8660                        	
 8661                        		.dbg	line,	"include\routines_SHOP.c", 19; if(index_y == 0)
 8662                        		__not.um	_index_y
         10:D96E  AD C6 23   			lda	_index_y
         10:D971  18         			clc
         10:D972  D0 01      			bne	!+
         10:D974  38         			sec
         10:D975             	!:
 8663                        		__bfalse	.LL380
         10:D975  90 07      			bcc	.LL380
 8664                        	
 8665                        		.dbg	line,	"include\routines_SHOP.c", 20; {
 8666                        	
 8667                        		.dbg	line,	"include\routines_SHOP.c", 21; max_index = 4;
 8668                        		__st.umiq	4, __joypad_BUTTONS_SHOP_end - 1  /* max_index */
         10:D977  A9 04      			lda.l	#4
         10:D979  8D 0D 23   			sta	__joypad_BUTTONS_SHOP_end - 1
 8669                        	
 8670                        		.dbg	line,	"include\routines_SHOP.c", 22; }
 8671                        	
 8672                        		.dbg	line,	"include\routines_SHOP.c", 24; else
 8673                        		__bra		.LL381
         10:D97C  80 05      			bra	.LL381
 8674    10:D97E             	.LL380:
 8675                        	
 8676                        		.dbg	line,	"include\routines_SHOP.c", 25; {
 8677                        	
 8678                        		.dbg	line,	"include\routines_SHOP.c", 26; max_index = 5;
 8679                        		__st.umiq	5, __joypad_BUTTONS_SHOP_end - 1  /* max_index */
         10:D97E  A9 05      			lda.l	#5
         10:D980  8D 0D 23   			sta	__joypad_BUTTONS_SHOP_end - 1
 8680                        	
 8681                        		.dbg	line,	"include\routines_SHOP.c", 27; }
 8682    10:D983             	.LL381:
 8683                        	
 8684                        		.dbg	line,	"include\routines_SHOP.c", 29; if(index_x < max_index)
 8685                        		__ld.umq	_index_x
         10:D983  AD C5 23   			lda	_index_x
 8686                        		__ult_b.umq	__joypad_BUTTONS_SHOP_end - 1  /* max_index */
         10:D986  CD 0D 23   			cmp	__joypad_BUTTONS_SHOP_end - 1		; Subtract memory from A.
         10:D989  6A         			ror	a		; CC if A < memory.
         10:D98A  49 80      			eor	#$80
         10:D98C  2A         			rol	a
 8687                        		__bfalse	.LL382
         10:D98D  B0 03 4C EC			bcc	.LL382
         10:D991  DE          
 8688                        	
 8689                        		.dbg	line,	"include\routines_SHOP.c", 30; {
 8690                        	
 8691                        		.dbg	line,	"include\routines_SHOP.c", 31; index_x += 1;
 8692                        		__add_st.umiq	1, _index_x
         10:D992  EE C5 23   			inc	_index_x
 8693                        	
 8694                        		.dbg	line,	"include\routines_SHOP.c", 32; item_index = (index_x + (index_y * 5));
 8695                        		__ld.um		_index_y
         10:D995  AD C6 23   			lda	_index_y
         10:D998  C2         			cly
 8696                        		__mul.wi	5
         10:D999  85 00      			sta.l	__temp
         10:D99B  84 01      			sty.h	__temp
                             		__asl.wr
         10:D99D  0A         			asl	a
         10:D99E  42         			say
         10:D99F  2A         			rol	a
         10:D9A0  42         			say
                             		__asl.wr
         10:D9A1  0A         			asl	a
         10:D9A2  42         			say
         10:D9A3  2A         			rol	a
         10:D9A4  42         			say
                             		__add.wm	__temp
         10:D9A5  18         			clc
         10:D9A6  65 00      			adc.l	__temp
         10:D9A8  42         			say
         10:D9A9  65 01      			adc.h	__temp
         10:D9AB  42         			say
 8697                        		__add.um	_index_x
         10:D9AC  18         			clc
         10:D9AD  6D C5 23   			adc	_index_x
         10:D9B0  90 01      			bcc	!+
         10:D9B2  C8         			iny
         10:D9B3             	!:
 8698                        		__st.umq	_item_index
         10:D9B3  8D C7 23   			sta	_item_index
 8699                        	
 8700                        		.dbg	line,	"include\routines_SHOP.c", 34; spr_set(0);
 8701                        		__ld.uiq	0
         10:D9B6  62         			cla
 8702                        		__call		_spr_set.1
         10:D9B7  20 DD E7   			call	_spr_set.1
 8703                        	
 8704                        		.dbg	line,	"include\routines_SHOP.c", 35; spr_x(TABLE_CURSOR_POS_X[item_index]);
 8705                        		__ldx.umq	_item_index
         10:D9BA  AE C7 23   			ldx	_item_index
 8706                        		__ld.uax	_TABLE_CURSOR_POS_X
         10:D9BD  BD 34 61   			lda	_TABLE_CURSOR_POS_X, x
         10:D9C0  C2         			cly
 8707                        		__call		_spr_x.1
         10:D9C1  20 0A E8   			call	_spr_x.1
 8708                        	
 8709                        		.dbg	line,	"include\routines_SHOP.c", 36; }
 8710                        	
 8711                        		.dbg	line,	"include\routines_SHOP.c", 37; }
 8712    10:D9C4             	.LL382	.alias		.LL383
 8713                        	
 8714                        		.dbg	line,	"include\routines_SHOP.c", 39; 
 8715                        	
 8716                        		.dbg	line,	"include\routines_SHOP.c", 40; else if(joytrg(JOYPAD_1) & JOY_LEFT)
 8717                        		__bra		.LL383
         10:D9C4  4C EC DE   			bra	.LL383
 8718    10:D9C7             	.LL379:
 8719                        		__ld.uiq	0
         10:D9C7  62         			cla
 8720                        		 _joytrg.1
         10:D9C8  AA         			tax
         10:D9C9  BD 2D 22   			lda	joytrg, x
         10:D9CC  BC DD 22   			ldy	joy6trg, x
 8721                        		__tand.wi	128
         10:D9CF  29 80      			and	#128
         10:D9D1  C9 01      	!:		cmp	#1
 8722                        		__bfalse	.LL384
         10:D9D3  90 40      			bcc	.LL384
 8723                        	
 8724                        		.dbg	line,	"include\routines_SHOP.c", 41; {
 8725                        	
 8726                        		.dbg	line,	"include\routines_SHOP.c", 42; if(index_x > 0)
 8727                        		__ld.umq	_index_x
         10:D9D5  AD C5 23   			lda	_index_x
 8728                        		__ugt_b.uiq	0
         10:D9D8  18         			clc			; Subtract integer+1 from A.
         10:D9D9  E9 00      			sbc	#0		; CS if A > integer.
 8729                        		__bfalse	.LL385
         10:D9DB  B0 03 4C EC			bcc	.LL385
         10:D9DF  DE          
 8730                        	
 8731                        		.dbg	line,	"include\routines_SHOP.c", 43; {
 8732                        	
 8733                        		.dbg	line,	"include\routines_SHOP.c", 44; index_x -= 1;
 8734                        		__sub_st.umiq	1, _index_x
         10:D9E0  CE C5 23   			dec	_index_x
 8735                        	
 8736                        		.dbg	line,	"include\routines_SHOP.c", 45; item_index = (index_x + (index_y * 5));
 8737                        		__ld.um		_index_y
         10:D9E3  AD C6 23   			lda	_index_y
         10:D9E6  C2         			cly
 8738                        		__mul.wi	5
         10:D9E7  85 00      			sta.l	__temp
         10:D9E9  84 01      			sty.h	__temp
                             		__asl.wr
         10:D9EB  0A         			asl	a
         10:D9EC  42         			say
         10:D9ED  2A         			rol	a
         10:D9EE  42         			say
                             		__asl.wr
         10:D9EF  0A         			asl	a
         10:D9F0  42         			say
         10:D9F1  2A         			rol	a
         10:D9F2  42         			say
                             		__add.wm	__temp
         10:D9F3  18         			clc
         10:D9F4  65 00      			adc.l	__temp
         10:D9F6  42         			say
         10:D9F7  65 01      			adc.h	__temp
         10:D9F9  42         			say
 8739                        		__add.um	_index_x
         10:D9FA  18         			clc
         10:D9FB  6D C5 23   			adc	_index_x
         10:D9FE  90 01      			bcc	!+
         10:DA00  C8         			iny
         10:DA01             	!:
 8740                        		__st.umq	_item_index
         10:DA01  8D C7 23   			sta	_item_index
 8741                        	
 8742                        		.dbg	line,	"include\routines_SHOP.c", 47; spr_set(0);
 8743                        		__ld.uiq	0
         10:DA04  62         			cla
 8744                        		__call		_spr_set.1
         10:DA05  20 DD E7   			call	_spr_set.1
 8745                        	
 8746                        		.dbg	line,	"include\routines_SHOP.c", 48; spr_x(TABLE_CURSOR_POS_X[item_index]);
 8747                        		__ldx.umq	_item_index
         10:DA08  AE C7 23   			ldx	_item_index
 8748                        		__ld.uax	_TABLE_CURSOR_POS_X
         10:DA0B  BD 34 61   			lda	_TABLE_CURSOR_POS_X, x
         10:DA0E  C2         			cly
 8749                        		__call		_spr_x.1
         10:DA0F  20 0A E8   			call	_spr_x.1
 8750                        	
 8751                        		.dbg	line,	"include\routines_SHOP.c", 49; }
 8752                        	
 8753                        		.dbg	line,	"include\routines_SHOP.c", 50; }
 8754    10:DA12             	.LL385	.alias		.LL386
 8755                        	
 8756                        		.dbg	line,	"include\routines_SHOP.c", 53; else if(joytrg(JOYPAD_1) & JOY_UP)
 8757                        		__bra		.LL386
         10:DA12  4C EC DE   			bra	.LL386
 8758    10:DA15             	.LL384:
 8759                        		__ld.uiq	0
         10:DA15  62         			cla
 8760                        		 _joytrg.1
         10:DA16  AA         			tax
         10:DA17  BD 2D 22   			lda	joytrg, x
         10:DA1A  BC DD 22   			ldy	joy6trg, x
 8761                        		__tand.wi	16
         10:DA1D  29 10      			and	#16
         10:DA1F  C9 01      	!:		cmp	#1
 8762                        		__bfalse	.LL387
         10:DA21  90 4A      			bcc	.LL387
 8763                        	
 8764                        		.dbg	line,	"include\routines_SHOP.c", 54; {
 8765                        	
 8766                        		.dbg	line,	"include\routines_SHOP.c", 55; if(index_y > 0)
 8767                        		__ld.umq	_index_y
         10:DA23  AD C6 23   			lda	_index_y
 8768                        		__ugt_b.uiq	0
         10:DA26  18         			clc			; Subtract integer+1 from A.
         10:DA27  E9 00      			sbc	#0		; CS if A > integer.
 8769                        		__bfalse	.LL388
         10:DA29  B0 03 4C EC			bcc	.LL388
         10:DA2D  DE          
 8770                        	
 8771                        		.dbg	line,	"include\routines_SHOP.c", 56; {
 8772                        	
 8773                        		.dbg	line,	"include\routines_SHOP.c", 57; if(item_index != 10)
 8774                        		__ld.umq	_item_index
         10:DA2E  AD C7 23   			lda	_item_index
 8775                        		__neq_b.uiq	10
         10:DA31  38         			sec
         10:DA32  49 0A      			eor	#10
         10:DA34  D0 01      			bne	!+
         10:DA36  18         			clc
         10:DA37             	!:
 8776                        		__bfalse	.LL389
         10:DA37  B0 03 4C EC			bcc	.LL389
         10:DA3B  DE          
 8777                        	
 8778                        		.dbg	line,	"include\routines_SHOP.c", 58; {
 8779                        	
 8780                        		.dbg	line,	"include\routines_SHOP.c", 59; index_y -= 1;
 8781                        		__sub_st.umiq	1, _index_y
         10:DA3C  CE C6 23   			dec	_index_y
 8782                        	
 8783                        		.dbg	line,	"include\routines_SHOP.c", 60; item_index = (index_x + (index_y * 5));
 8784                        		__ld.um		_index_y
         10:DA3F  AD C6 23   			lda	_index_y
         10:DA42  C2         			cly
 8785                        		__mul.wi	5
         10:DA43  85 00      			sta.l	__temp
         10:DA45  84 01      			sty.h	__temp
                             		__asl.wr
         10:DA47  0A         			asl	a
         10:DA48  42         			say
         10:DA49  2A         			rol	a
         10:DA4A  42         			say
                             		__asl.wr
         10:DA4B  0A         			asl	a
         10:DA4C  42         			say
         10:DA4D  2A         			rol	a
         10:DA4E  42         			say
                             		__add.wm	__temp
         10:DA4F  18         			clc
         10:DA50  65 00      			adc.l	__temp
         10:DA52  42         			say
         10:DA53  65 01      			adc.h	__temp
         10:DA55  42         			say
 8786                        		__add.um	_index_x
         10:DA56  18         			clc
         10:DA57  6D C5 23   			adc	_index_x
         10:DA5A  90 01      			bcc	!+
         10:DA5C  C8         			iny
         10:DA5D             	!:
 8787                        		__st.umq	_item_index
         10:DA5D  8D C7 23   			sta	_item_index
 8788                        	
 8789                        		.dbg	line,	"include\routines_SHOP.c", 62; spr_set(0);
 8790                        		__ld.uiq	0
         10:DA60  62         			cla
 8791                        		__call		_spr_set.1
         10:DA61  20 DD E7   			call	_spr_set.1
 8792                        	
 8793                        		.dbg	line,	"include\routines_SHOP.c", 63; spr_y(144);
 8794                        		__ld.wi		144
         10:DA64  A9 90      			lda.l	#144
         10:DA66  C2         			cly
 8795                        		__call		_spr_y.1
         10:DA67  20 19 E8   			call	_spr_y.1
 8796                        	
 8797                        		.dbg	line,	"include\routines_SHOP.c", 64; }
 8798                        	
 8799                        		.dbg	line,	"include\routines_SHOP.c", 65; }
 8800    10:DA6A             	.LL389	.alias		.LL390
 8801                        	
 8802                        		.dbg	line,	"include\routines_SHOP.c", 66; }
 8803    10:DA6A             	.LL388	.alias		.LL390
 8804                        	
 8805                        		.dbg	line,	"include\routines_SHOP.c", 69; else if(joytrg(JOYPAD_1) & JOY_DOWN)
 8806                        		__bra		.LL390
         10:DA6A  4C EC DE   			bra	.LL390
 8807    10:DA6D             	.LL387:
 8808                        		__ld.uiq	0
         10:DA6D  62         			cla
 8809                        		 _joytrg.1
         10:DA6E  AA         			tax
         10:DA6F  BD 2D 22   			lda	joytrg, x
         10:DA72  BC DD 22   			ldy	joy6trg, x
 8810                        		__tand.wi	64
         10:DA75  29 40      			and	#64
         10:DA77  C9 01      	!:		cmp	#1
 8811                        		__bfalse	.LL391
         10:DA79  90 3F      			bcc	.LL391
 8812                        	
 8813                        		.dbg	line,	"include\routines_SHOP.c", 70; {
 8814                        	
 8815                        		.dbg	line,	"include\routines_SHOP.c", 71; if(index_y < 1)
 8816                        		__ld.umq	_index_y
         10:DA7B  AD C6 23   			lda	_index_y
 8817                        		__ult_b.uiq	1
         10:DA7E  C9 01      			cmp	#1		; Subtract integer from A.
         10:DA80  6A         			ror	a		; CC if A < integer.
         10:DA81  49 80      			eor	#$80
         10:DA83  2A         			rol	a
 8818                        		__bfalse	.LL392
         10:DA84  B0 03 4C EC			bcc	.LL392
         10:DA88  DE          
 8819                        	
 8820                        		.dbg	line,	"include\routines_SHOP.c", 72; {
 8821                        	
 8822                        		.dbg	line,	"include\routines_SHOP.c", 73; index_y += 1;
 8823                        		__add_st.umiq	1, _index_y
         10:DA89  EE C6 23   			inc	_index_y
 8824                        	
 8825                        		.dbg	line,	"include\routines_SHOP.c", 74; item_index = (index_x + (index_y * 5));
 8826                        		__ld.um		_index_y
         10:DA8C  AD C6 23   			lda	_index_y
         10:DA8F  C2         			cly
 8827                        		__mul.wi	5
         10:DA90  85 00      			sta.l	__temp
         10:DA92  84 01      			sty.h	__temp
                             		__asl.wr
         10:DA94  0A         			asl	a
         10:DA95  42         			say
         10:DA96  2A         			rol	a
         10:DA97  42         			say
                             		__asl.wr
         10:DA98  0A         			asl	a
         10:DA99  42         			say
         10:DA9A  2A         			rol	a
         10:DA9B  42         			say
                             		__add.wm	__temp
         10:DA9C  18         			clc
         10:DA9D  65 00      			adc.l	__temp
         10:DA9F  42         			say
         10:DAA0  65 01      			adc.h	__temp
         10:DAA2  42         			say
 8828                        		__add.um	_index_x
         10:DAA3  18         			clc
         10:DAA4  6D C5 23   			adc	_index_x
         10:DAA7  90 01      			bcc	!+
         10:DAA9  C8         			iny
         10:DAAA             	!:
 8829                        		__st.umq	_item_index
         10:DAAA  8D C7 23   			sta	_item_index
 8830                        	
 8831                        		.dbg	line,	"include\routines_SHOP.c", 76; spr_set(0);
 8832                        		__ld.uiq	0
         10:DAAD  62         			cla
 8833                        		__call		_spr_set.1
         10:DAAE  20 DD E7   			call	_spr_set.1
 8834                        	
 8835                        		.dbg	line,	"include\routines_SHOP.c", 77; spr_y(168);
 8836                        		__ld.wi		168
         10:DAB1  A9 A8      			lda.l	#168
         10:DAB3  C2         			cly
 8837                        		__call		_spr_y.1
         10:DAB4  20 19 E8   			call	_spr_y.1
 8838                        	
 8839                        		.dbg	line,	"include\routines_SHOP.c", 78; }
 8840                        	
 8841                        		.dbg	line,	"include\routines_SHOP.c", 79; }
 8842    10:DAB7             	.LL392	.alias		.LL393
 8843                        	
 8844                        		.dbg	line,	"include\routines_SHOP.c", 82; else if(joytrg(JOYPAD_1) & JOY_I)
 8845                        		__bra		.LL393
         10:DAB7  4C EC DE   			bra	.LL393
 8846    10:DABA             	.LL391:
 8847                        		__ld.uiq	0
         10:DABA  62         			cla
 8848                        		 _joytrg.1
         10:DABB  AA         			tax
         10:DABC  BD 2D 22   			lda	joytrg, x
         10:DABF  BC DD 22   			ldy	joy6trg, x
 8849                        		__tand.wi	1
         10:DAC2  29 01      			and	#1
         10:DAC4  C9 01      	!:		cmp	#1
 8850                        		__bfalse	.LL394
         10:DAC6  B0 03 4C EC			bcc	.LL394
         10:DACA  DE          
 8851                        	
 8852                        		.dbg	line,	"include\routines_SHOP.c", 83; {
 8853                        	
 8854                        		.dbg	line,	"include\routines_SHOP.c", 84; switch(item_index)
 8855                        		__ld.umq	_item_index
         10:DACB  AD C7 23   			lda	_item_index
 8856                        		__bra		.LL395
         10:DACE  4C C9 DE   			bra	.LL395
 8857                        	
 8858                        		.dbg	line,	"include\routines_SHOP.c", 85; {
 8859                        	
 8860                        		.dbg	line,	"include\routines_SHOP.c", 86; // WEAPON 2 //
 8861                        	
 8862                        		.dbg	line,	"include\routines_SHOP.c", 87; case 0:
 8863    10:DAD1             	.LL397:
 8864                        		__case		0
 8865                        	
 8866                        		.dbg	line,	"include\routines_SHOP.c", 88; if(zenny_amount >= shop_prices[0])
 8867                        		__ld.wm		_zenny_amount
         10:DAD1  AD 22 26   			lda.l	_zenny_amount
         10:DAD4  AC 23 26   			ldy.h	_zenny_amount
 8868                        		__sge_w.wm	_shop_prices
         10:DAD7  CD 26 26   			cmp.l	_shop_prices		; Subtract memory from Y:A.
         10:DADA  98         			tya
         10:DADB  ED 27 26   			sbc.h	_shop_prices
         10:DADE  50 02      			bvc	!+
         10:DAE0  49 80      			eor	#$80		; +ve if Y:A >= memory (signed).
         10:DAE2  49 80      	!:		eor	#$80
         10:DAE4  0A         			asl	a
 8869                        		__bfalse	.LL398
         10:DAE5  B0 03 4C EC			bcc	.LL398
         10:DAE9  DE          
 8870                        	
 8871                        		.dbg	line,	"include\routines_SHOP.c", 89; {
 8872                        	
 8873                        		.dbg	line,	"include\routines_SHOP.c", 90; if(weapon_level < 2)
 8874                        		__ld.umq	_weapon_level
         10:DAEA  AD 1E 23   			lda	_weapon_level
 8875                        		__ult_b.uiq	2
         10:DAED  C9 02      			cmp	#2		; Subtract integer from A.
         10:DAEF  6A         			ror	a		; CC if A < integer.
         10:DAF0  49 80      			eor	#$80
         10:DAF2  2A         			rol	a
 8876                        		__bfalse	.LL399
         10:DAF3  B0 03 4C EC			bcc	.LL399
         10:DAF7  DE          
 8877                        	
 8878                        		.dbg	line,	"include\routines_SHOP.c", 91; {
 8879                        	
 8880                        		.dbg	line,	"include\routines_SHOP.c", 92; weapon_level = 2;
 8881                        		__st.umiq	2, _weapon_level
         10:DAF8  A9 02      			lda.l	#2
         10:DAFA  8D 1E 23   			sta	_weapon_level
 8882                        	
 8883                        		.dbg	line,	"include\routines_SHOP.c", 93; load_vram( WEAPON_VRAM_ADR, tileset_WEAPON_2, SIZEOF(tileset_WEAPON_2) >> 1 );
 8884                        		__st.wmiq	4256, _di
         10:DAFD  A9 A0      			lda.l	#4256
         10:DAFF  85 F0      			sta.l	_di
         10:DB01  A9 10      			lda.h	#4256
         10:DB03  85 F1      			sta.h	_di
 8885                        		__farptr	_tileset_WEAPON_2, _bp_bank, _bp
         10:DB05  A9 80      			lda.l	#$6000 + ($1FFF & (_tileset_WEAPON_2))
         10:DB07  85 EC      			sta.l	_bp
         10:DB09  A9 77      			lda.h	#$6000 + ($1FFF & (_tileset_WEAPON_2))
         10:DB0B  85 ED      			sta.h	_bp
         10:DB0D  A9 03      			lda	#bank(_tileset_WEAPON_2)
         10:DB0F  85 02      			sta	_bp_bank
 8886                        		__ld.wi		___sizeof__tileset_WEAPON_2
         10:DB11  A9 80      			lda.l	#___sizeof__tileset_WEAPON_2
         10:DB13  A0 00      			ldy.h	#___sizeof__tileset_WEAPON_2
 8887                        		__lsr.wi	1
         10:DB15  42         			say
         10:DB16  4A         			lsr	a
         10:DB17  42         			say
         10:DB18  6A         			ror	a
 8888                        		__st.wmq	_ax
         10:DB19  85 F8      			sta.l	_ax
         10:DB1B  84 F9      			sty.h	_ax
 8889                        		 _load_vram.3
         10:DB1D  82         			clx				; Offset to PCE VDC.
         10:DB1E  20 63 FF   			call	load_vram_x
 8890                        	
 8891                        		.dbg	line,	"include\routines_SHOP.c", 95; zenny_amount -= shop_prices[0];
 8892                        		__ld.wm		_shop_prices
         10:DB21  AD 26 26   			lda.l	_shop_prices
         10:DB24  AC 27 26   			ldy.h	_shop_prices
 8893                        		__isub_st.wmq	_zenny_amount
         10:DB27  38         			sec
         10:DB28  49 FF      			eor	#$FF
         10:DB2A  6D 22 26   			adc.l	_zenny_amount
         10:DB2D  8D 22 26   			sta.l	_zenny_amount
         10:DB30  98         			tya
         10:DB31  49 FF      			eor	#$FF
         10:DB33  6D 23 26   			adc.h	_zenny_amount
         10:DB36  8D 23 26   			sta.h	_zenny_amount
 8894                        	
 8895                        		.dbg	line,	"include\routines_SHOP.c", 96; display_ZENNY();
 8896                        		__call		_display_ZENNY
         10:DB39  20 45 FF   			call	_display_ZENNY
 8897                        	
 8898                        		.dbg	line,	"include\routines_SHOP.c", 97; }
 8899                        	
 8900                        		.dbg	line,	"include\routines_SHOP.c", 98; }
 8901    10:DB3C             	.LL399	.alias		.LL396
 8902                        	
 8903                        		.dbg	line,	"include\routines_SHOP.c", 100; break;   
 8904    10:DB3C             	.LL398	.alias		.LL396
 8905                        		__bra		.LL396
         10:DB3C  4C EC DE   			bra	.LL396
 8906                        	
 8907                        		.dbg	line,	"include\routines_SHOP.c", 103; // WEAPON 4 //
 8908                        	
 8909                        		.dbg	line,	"include\routines_SHOP.c", 104; case 1:
 8910    10:DB3F             	.LL400:
 8911                        		__case		1
 8912                        	
 8913                        		.dbg	line,	"include\routines_SHOP.c", 105; if(zenny_amount >= shop_prices[1])
 8914                        		__ld.wm		_zenny_amount
         10:DB3F  AD 22 26   			lda.l	_zenny_amount
         10:DB42  AC 23 26   			ldy.h	_zenny_amount
 8915                        		__sge_w.wm	_shop_prices + 2
         10:DB45  CD 28 26   			cmp.l	_shop_prices + 2		; Subtract memory from Y:A.
         10:DB48  98         			tya
         10:DB49  ED 29 26   			sbc.h	_shop_prices + 2
         10:DB4C  50 02      			bvc	!+
         10:DB4E  49 80      			eor	#$80		; +ve if Y:A >= memory (signed).
         10:DB50  49 80      	!:		eor	#$80
         10:DB52  0A         			asl	a
 8916                        		__bfalse	.LL401
         10:DB53  B0 03 4C EC			bcc	.LL401
         10:DB57  DE          
 8917                        	
 8918                        		.dbg	line,	"include\routines_SHOP.c", 106; {
 8919                        	
 8920                        		.dbg	line,	"include\routines_SHOP.c", 107; if(weapon_level < 4)
 8921                        		__ld.umq	_weapon_level
         10:DB58  AD 1E 23   			lda	_weapon_level
 8922                        		__ult_b.uiq	4
         10:DB5B  C9 04      			cmp	#4		; Subtract integer from A.
         10:DB5D  6A         			ror	a		; CC if A < integer.
         10:DB5E  49 80      			eor	#$80
         10:DB60  2A         			rol	a
 8923                        		__bfalse	.LL402
         10:DB61  B0 03 4C EC			bcc	.LL402
         10:DB65  DE          
 8924                        	
 8925                        		.dbg	line,	"include\routines_SHOP.c", 108; {
 8926                        	
 8927                        		.dbg	line,	"include\routines_SHOP.c", 109; weapon_level = 4;
 8928                        		__st.umiq	4, _weapon_level
         10:DB66  A9 04      			lda.l	#4
         10:DB68  8D 1E 23   			sta	_weapon_level
 8929                        	
 8930                        		.dbg	line,	"include\routines_SHOP.c", 110; load_vram( WEAPON_VRAM_ADR, tileset_WEAPON_4, SIZEOF(tileset_WEAPON_4) >> 1 );
 8931                        		__st.wmiq	4256, _di
         10:DB6B  A9 A0      			lda.l	#4256
         10:DB6D  85 F0      			sta.l	_di
         10:DB6F  A9 10      			lda.h	#4256
         10:DB71  85 F1      			sta.h	_di
 8932                        		__farptr	_tileset_WEAPON_4, _bp_bank, _bp
         10:DB73  A9 00      			lda.l	#$6000 + ($1FFF & (_tileset_WEAPON_4))
         10:DB75  85 EC      			sta.l	_bp
         10:DB77  A9 78      			lda.h	#$6000 + ($1FFF & (_tileset_WEAPON_4))
         10:DB79  85 ED      			sta.h	_bp
         10:DB7B  A9 03      			lda	#bank(_tileset_WEAPON_4)
         10:DB7D  85 02      			sta	_bp_bank
 8933                        		__ld.wi		___sizeof__tileset_WEAPON_4
         10:DB7F  A9 80      			lda.l	#___sizeof__tileset_WEAPON_4
         10:DB81  A0 00      			ldy.h	#___sizeof__tileset_WEAPON_4
 8934                        		__lsr.wi	1
         10:DB83  42         			say
         10:DB84  4A         			lsr	a
         10:DB85  42         			say
         10:DB86  6A         			ror	a
 8935                        		__st.wmq	_ax
         10:DB87  85 F8      			sta.l	_ax
         10:DB89  84 F9      			sty.h	_ax
 8936                        		 _load_vram.3
         10:DB8B  82         			clx				; Offset to PCE VDC.
         10:DB8C  20 63 FF   			call	load_vram_x
 8937                        	
 8938                        		.dbg	line,	"include\routines_SHOP.c", 112; zenny_amount -= shop_prices[1];
 8939                        		__ld.wm		_shop_prices + 2
         10:DB8F  AD 28 26   			lda.l	_shop_prices + 2
         10:DB92  AC 29 26   			ldy.h	_shop_prices + 2
 8940                        		__isub_st.wmq	_zenny_amount
         10:DB95  38         			sec
         10:DB96  49 FF      			eor	#$FF
         10:DB98  6D 22 26   			adc.l	_zenny_amount
         10:DB9B  8D 22 26   			sta.l	_zenny_amount
         10:DB9E  98         			tya
         10:DB9F  49 FF      			eor	#$FF
         10:DBA1  6D 23 26   			adc.h	_zenny_amount
         10:DBA4  8D 23 26   			sta.h	_zenny_amount
 8941                        	
 8942                        		.dbg	line,	"include\routines_SHOP.c", 113; display_ZENNY();
 8943                        		__call		_display_ZENNY
         10:DBA7  20 45 FF   			call	_display_ZENNY
 8944                        	
 8945                        		.dbg	line,	"include\routines_SHOP.c", 114; }
 8946                        	
 8947                        		.dbg	line,	"include\routines_SHOP.c", 115; }
 8948    10:DBAA             	.LL402	.alias		.LL396
 8949                        	
 8950                        		.dbg	line,	"include\routines_SHOP.c", 117; break; 
 8951    10:DBAA             	.LL401	.alias		.LL396
 8952                        		__bra		.LL396
         10:DBAA  4C EC DE   			bra	.LL396
 8953                        	
 8954                        		.dbg	line,	"include\routines_SHOP.c", 120; // WEAPON 5 //
 8955                        	
 8956                        		.dbg	line,	"include\routines_SHOP.c", 121; case 2:
 8957    10:DBAD             	.LL403:
 8958                        		__case		2
 8959                        	
 8960                        		.dbg	line,	"include\routines_SHOP.c", 122; if(zenny_amount >= shop_prices[2])
 8961                        		__ld.wm		_zenny_amount
         10:DBAD  AD 22 26   			lda.l	_zenny_amount
         10:DBB0  AC 23 26   			ldy.h	_zenny_amount
 8962                        		__sge_w.wm	_shop_prices + 4
         10:DBB3  CD 2A 26   			cmp.l	_shop_prices + 4		; Subtract memory from Y:A.
         10:DBB6  98         			tya
         10:DBB7  ED 2B 26   			sbc.h	_shop_prices + 4
         10:DBBA  50 02      			bvc	!+
         10:DBBC  49 80      			eor	#$80		; +ve if Y:A >= memory (signed).
         10:DBBE  49 80      	!:		eor	#$80
         10:DBC0  0A         			asl	a
 8963                        		__bfalse	.LL404
         10:DBC1  B0 03 4C EC			bcc	.LL404
         10:DBC5  DE          
 8964                        	
 8965                        		.dbg	line,	"include\routines_SHOP.c", 123; {
 8966                        	
 8967                        		.dbg	line,	"include\routines_SHOP.c", 124; if(weapon_level < 5)
 8968                        		__ld.umq	_weapon_level
         10:DBC6  AD 1E 23   			lda	_weapon_level
 8969                        		__ult_b.uiq	5
         10:DBC9  C9 05      			cmp	#5		; Subtract integer from A.
         10:DBCB  6A         			ror	a		; CC if A < integer.
         10:DBCC  49 80      			eor	#$80
         10:DBCE  2A         			rol	a
 8970                        		__bfalse	.LL405
         10:DBCF  B0 03 4C EC			bcc	.LL405
         10:DBD3  DE          
 8971                        	
 8972                        		.dbg	line,	"include\routines_SHOP.c", 125; {
 8973                        	
 8974                        		.dbg	line,	"include\routines_SHOP.c", 126; weapon_level = 5;
 8975                        		__st.umiq	5, _weapon_level
         10:DBD4  A9 05      			lda.l	#5
         10:DBD6  8D 1E 23   			sta	_weapon_level
 8976                        	
 8977                        		.dbg	line,	"include\routines_SHOP.c", 127; load_vram( WEAPON_VRAM_ADR, tileset_WEAPON_5, SIZEOF(tileset_WEAPON_5) >> 1 );
 8978                        		__st.wmiq	4256, _di
         10:DBD9  A9 A0      			lda.l	#4256
         10:DBDB  85 F0      			sta.l	_di
         10:DBDD  A9 10      			lda.h	#4256
         10:DBDF  85 F1      			sta.h	_di
 8979                        		__farptr	_tileset_WEAPON_5, _bp_bank, _bp
         10:DBE1  A9 80      			lda.l	#$6000 + ($1FFF & (_tileset_WEAPON_5))
         10:DBE3  85 EC      			sta.l	_bp
         10:DBE5  A9 78      			lda.h	#$6000 + ($1FFF & (_tileset_WEAPON_5))
         10:DBE7  85 ED      			sta.h	_bp
         10:DBE9  A9 03      			lda	#bank(_tileset_WEAPON_5)
         10:DBEB  85 02      			sta	_bp_bank
 8980                        		__ld.wi		___sizeof__tileset_WEAPON_5
         10:DBED  A9 80      			lda.l	#___sizeof__tileset_WEAPON_5
         10:DBEF  A0 00      			ldy.h	#___sizeof__tileset_WEAPON_5
 8981                        		__lsr.wi	1
         10:DBF1  42         			say
         10:DBF2  4A         			lsr	a
         10:DBF3  42         			say
         10:DBF4  6A         			ror	a
 8982                        		__st.wmq	_ax
         10:DBF5  85 F8      			sta.l	_ax
         10:DBF7  84 F9      			sty.h	_ax
 8983                        		 _load_vram.3
         10:DBF9  82         			clx				; Offset to PCE VDC.
         10:DBFA  20 63 FF   			call	load_vram_x
 8984                        	
 8985                        		.dbg	line,	"include\routines_SHOP.c", 129; zenny_amount -= shop_prices[2];
 8986                        		__ld.wm		_shop_prices + 4
         10:DBFD  AD 2A 26   			lda.l	_shop_prices + 4
         10:DC00  AC 2B 26   			ldy.h	_shop_prices + 4
 8987                        		__isub_st.wmq	_zenny_amount
         10:DC03  38         			sec
         10:DC04  49 FF      			eor	#$FF
         10:DC06  6D 22 26   			adc.l	_zenny_amount
         10:DC09  8D 22 26   			sta.l	_zenny_amount
         10:DC0C  98         			tya
         10:DC0D  49 FF      			eor	#$FF
         10:DC0F  6D 23 26   			adc.h	_zenny_amount
         10:DC12  8D 23 26   			sta.h	_zenny_amount
 8988                        	
 8989                        		.dbg	line,	"include\routines_SHOP.c", 130; display_ZENNY();
 8990                        		__call		_display_ZENNY
         10:DC15  20 45 FF   			call	_display_ZENNY
 8991                        	
 8992                        		.dbg	line,	"include\routines_SHOP.c", 131; }
 8993                        	
 8994                        		.dbg	line,	"include\routines_SHOP.c", 132; }
 8995    10:DC18             	.LL405	.alias		.LL396
 8996                        	
 8997                        		.dbg	line,	"include\routines_SHOP.c", 134; break;   
 8998    10:DC18             	.LL404	.alias		.LL396
 8999                        		__bra		.LL396
         10:DC18  4C EC DE   			bra	.LL396
 9000                        	
 9001                        		.dbg	line,	"include\routines_SHOP.c", 137; // WEAPON 8 //
 9002                        	
 9003                        		.dbg	line,	"include\routines_SHOP.c", 138; case 3:
 9004    10:DC1B             	.LL406:
 9005                        		__case		3
 9006                        	
 9007                        		.dbg	line,	"include\routines_SHOP.c", 139; if(zenny_amount >= shop_prices[3])
 9008                        		__ld.wm		_zenny_amount
         10:DC1B  AD 22 26   			lda.l	_zenny_amount
         10:DC1E  AC 23 26   			ldy.h	_zenny_amount
 9009                        		__sge_w.wm	_shop_prices + 6
         10:DC21  CD 2C 26   			cmp.l	_shop_prices + 6		; Subtract memory from Y:A.
         10:DC24  98         			tya
         10:DC25  ED 2D 26   			sbc.h	_shop_prices + 6
         10:DC28  50 02      			bvc	!+
         10:DC2A  49 80      			eor	#$80		; +ve if Y:A >= memory (signed).
         10:DC2C  49 80      	!:		eor	#$80
         10:DC2E  0A         			asl	a
 9010                        		__bfalse	.LL407
         10:DC2F  B0 03 4C EC			bcc	.LL407
         10:DC33  DE          
 9011                        	
 9012                        		.dbg	line,	"include\routines_SHOP.c", 140; {
 9013                        	
 9014                        		.dbg	line,	"include\routines_SHOP.c", 141; if(weapon_level < 8)
 9015                        		__ld.umq	_weapon_level
         10:DC34  AD 1E 23   			lda	_weapon_level
 9016                        		__ult_b.uiq	8
         10:DC37  C9 08      			cmp	#8		; Subtract integer from A.
         10:DC39  6A         			ror	a		; CC if A < integer.
         10:DC3A  49 80      			eor	#$80
         10:DC3C  2A         			rol	a
 9017                        		__bfalse	.LL408
         10:DC3D  B0 03 4C EC			bcc	.LL408
         10:DC41  DE          
 9018                        	
 9019                        		.dbg	line,	"include\routines_SHOP.c", 142; {
 9020                        	
 9021                        		.dbg	line,	"include\routines_SHOP.c", 143; weapon_level = 8;
 9022                        		__st.umiq	8, _weapon_level
         10:DC42  A9 08      			lda.l	#8
         10:DC44  8D 1E 23   			sta	_weapon_level
 9023                        	
 9024                        		.dbg	line,	"include\routines_SHOP.c", 144; load_vram( WEAPON_VRAM_ADR, tileset_WEAPON_8, SIZEOF(tileset_WEAPON_8) >> 1 );
 9025                        		__st.wmiq	4256, _di
         10:DC47  A9 A0      			lda.l	#4256
         10:DC49  85 F0      			sta.l	_di
         10:DC4B  A9 10      			lda.h	#4256
         10:DC4D  85 F1      			sta.h	_di
 9026                        		__farptr	_tileset_WEAPON_8, _bp_bank, _bp
         10:DC4F  A9 00      			lda.l	#$6000 + ($1FFF & (_tileset_WEAPON_8))
         10:DC51  85 EC      			sta.l	_bp
         10:DC53  A9 79      			lda.h	#$6000 + ($1FFF & (_tileset_WEAPON_8))
         10:DC55  85 ED      			sta.h	_bp
         10:DC57  A9 03      			lda	#bank(_tileset_WEAPON_8)
         10:DC59  85 02      			sta	_bp_bank
 9027                        		__ld.wi		___sizeof__tileset_WEAPON_8
         10:DC5B  A9 80      			lda.l	#___sizeof__tileset_WEAPON_8
         10:DC5D  A0 00      			ldy.h	#___sizeof__tileset_WEAPON_8
 9028                        		__lsr.wi	1
         10:DC5F  42         			say
         10:DC60  4A         			lsr	a
         10:DC61  42         			say
         10:DC62  6A         			ror	a
 9029                        		__st.wmq	_ax
         10:DC63  85 F8      			sta.l	_ax
         10:DC65  84 F9      			sty.h	_ax
 9030                        		 _load_vram.3
         10:DC67  82         			clx				; Offset to PCE VDC.
         10:DC68  20 63 FF   			call	load_vram_x
 9031                        	
 9032                        		.dbg	line,	"include\routines_SHOP.c", 146; zenny_amount -= shop_prices[3];
 9033                        		__ld.wm		_shop_prices + 6
         10:DC6B  AD 2C 26   			lda.l	_shop_prices + 6
         10:DC6E  AC 2D 26   			ldy.h	_shop_prices + 6
 9034                        		__isub_st.wmq	_zenny_amount
         10:DC71  38         			sec
         10:DC72  49 FF      			eor	#$FF
         10:DC74  6D 22 26   			adc.l	_zenny_amount
         10:DC77  8D 22 26   			sta.l	_zenny_amount
         10:DC7A  98         			tya
         10:DC7B  49 FF      			eor	#$FF
         10:DC7D  6D 23 26   			adc.h	_zenny_amount
         10:DC80  8D 23 26   			sta.h	_zenny_amount
 9035                        	
 9036                        		.dbg	line,	"include\routines_SHOP.c", 147; display_ZENNY();
 9037                        		__call		_display_ZENNY
         10:DC83  20 45 FF   			call	_display_ZENNY
 9038                        	
 9039                        		.dbg	line,	"include\routines_SHOP.c", 148; }
 9040                        	
 9041                        		.dbg	line,	"include\routines_SHOP.c", 149; }
 9042    10:DC86             	.LL408	.alias		.LL396
 9043                        	
 9044                        		.dbg	line,	"include\routines_SHOP.c", 151; break;  
 9045    10:DC86             	.LL407	.alias		.LL396
 9046                        		__bra		.LL396
         10:DC86  4C EC DE   			bra	.LL396
 9047                        	
 9048                        		.dbg	line,	"include\routines_SHOP.c", 154; // KEY //
 9049                        	
 9050                        		.dbg	line,	"include\routines_SHOP.c", 155; case 4:
 9051    10:DC89             	.LL409:
 9052                        		__case		4
 9053                        	
 9054                        		.dbg	line,	"include\routines_SHOP.c", 156; if(zenny_amount >= shop_prices[4])
 9055                        		__ld.wm		_zenny_amount
         10:DC89  AD 22 26   			lda.l	_zenny_amount
         10:DC8C  AC 23 26   			ldy.h	_zenny_amount
 9056                        		__sge_w.wm	_shop_prices + 8
         10:DC8F  CD 2E 26   			cmp.l	_shop_prices + 8		; Subtract memory from Y:A.
         10:DC92  98         			tya
         10:DC93  ED 2F 26   			sbc.h	_shop_prices + 8
         10:DC96  50 02      			bvc	!+
         10:DC98  49 80      			eor	#$80		; +ve if Y:A >= memory (signed).
         10:DC9A  49 80      	!:		eor	#$80
         10:DC9C  0A         			asl	a
 9057                        		__bfalse	.LL410
         10:DC9D  B0 03 4C EC			bcc	.LL410
         10:DCA1  DE          
 9058                        	
 9059                        		.dbg	line,	"include\routines_SHOP.c", 157; {
 9060                        	
 9061                        		.dbg	line,	"include\routines_SHOP.c", 158; key_amount += 1;
 9062                        		__add_st.umiq	1, _key_amount
         10:DCA2  EE 20 23   			inc	_key_amount
 9063                        	
 9064                        		.dbg	line,	"include\routines_SHOP.c", 160; zenny_amount -= shop_prices[4];
 9065                        		__ld.wm		_shop_prices + 8
         10:DCA5  AD 2E 26   			lda.l	_shop_prices + 8
         10:DCA8  AC 2F 26   			ldy.h	_shop_prices + 8
 9066                        		__isub_st.wmq	_zenny_amount
         10:DCAB  38         			sec
         10:DCAC  49 FF      			eor	#$FF
         10:DCAE  6D 22 26   			adc.l	_zenny_amount
         10:DCB1  8D 22 26   			sta.l	_zenny_amount
         10:DCB4  98         			tya
         10:DCB5  49 FF      			eor	#$FF
         10:DCB7  6D 23 26   			adc.h	_zenny_amount
         10:DCBA  8D 23 26   			sta.h	_zenny_amount
 9067                        	
 9068                        		.dbg	line,	"include\routines_SHOP.c", 161; display_KEY();
 9069                        		__call		_display_KEY
         10:DCBD  20 8B FF   			call	_display_KEY
 9070                        	
 9071                        		.dbg	line,	"include\routines_SHOP.c", 162; }
 9072                        	
 9073                        		.dbg	line,	"include\routines_SHOP.c", 164; break;   
 9074    10:DCC0             	.LL410	.alias		.LL396
 9075                        		__bra		.LL396
         10:DCC0  4C EC DE   			bra	.LL396
 9076                        	
 9077                        		.dbg	line,	"include\routines_SHOP.c", 167; // ARMOR 1 //
 9078                        	
 9079                        		.dbg	line,	"include\routines_SHOP.c", 168; case 5:
 9080    10:DCC3             	.LL411:
 9081                        		__case		5
 9082                        	
 9083                        		.dbg	line,	"include\routines_SHOP.c", 169; if(zenny_amount >= shop_prices[5])
 9084                        		__ld.wm		_zenny_amount
         10:DCC3  AD 22 26   			lda.l	_zenny_amount
         10:DCC6  AC 23 26   			ldy.h	_zenny_amount
 9085                        		__sge_w.wm	_shop_prices + 10
         10:DCC9  CD 30 26   			cmp.l	_shop_prices + 10		; Subtract memory from Y:A.
         10:DCCC  98         			tya
         10:DCCD  ED 31 26   			sbc.h	_shop_prices + 10
         10:DCD0  50 02      			bvc	!+
         10:DCD2  49 80      			eor	#$80		; +ve if Y:A >= memory (signed).
         10:DCD4  49 80      	!:		eor	#$80
         10:DCD6  0A         			asl	a
 9086                        		__bfalse	.LL412
         10:DCD7  B0 03 4C EC			bcc	.LL412
         10:DCDB  DE          
 9087                        	
 9088                        		.dbg	line,	"include\routines_SHOP.c", 170; {
 9089                        	
 9090                        		.dbg	line,	"include\routines_SHOP.c", 171; if(armor_level < 1)
 9091                        		__ld.umq	_armor_level
         10:DCDC  AD 1D 23   			lda	_armor_level
 9092                        		__ult_b.uiq	1
         10:DCDF  C9 01      			cmp	#1		; Subtract integer from A.
         10:DCE1  6A         			ror	a		; CC if A < integer.
         10:DCE2  49 80      			eor	#$80
         10:DCE4  2A         			rol	a
 9093                        		__bfalse	.LL413
         10:DCE5  B0 03 4C EC			bcc	.LL413
         10:DCE9  DE          
 9094                        	
 9095                        		.dbg	line,	"include\routines_SHOP.c", 172; {
 9096                        	
 9097                        		.dbg	line,	"include\routines_SHOP.c", 173; armor_level = 1;
 9098                        		__st.umiq	1, _armor_level
         10:DCEA  A9 01      			lda.l	#1
         10:DCEC  8D 1D 23   			sta	_armor_level
 9099                        	
 9100                        		.dbg	line,	"include\routines_SHOP.c", 174; load_vram( ARMOR_VRAM_ADR, tileset_ARMOR_1, SIZEOF(tileset_ARMOR_1) >> 1 );
 9101                        		__st.wmiq	4320, _di
         10:DCEF  A9 E0      			lda.l	#4320
         10:DCF1  85 F0      			sta.l	_di
         10:DCF3  A9 10      			lda.h	#4320
         10:DCF5  85 F1      			sta.h	_di
 9102                        		__farptr	_tileset_ARMOR_1, _bp_bank, _bp
         10:DCF7  A9 00      			lda.l	#$6000 + ($1FFF & (_tileset_ARMOR_1))
         10:DCF9  85 EC      			sta.l	_bp
         10:DCFB  A9 75      			lda.h	#$6000 + ($1FFF & (_tileset_ARMOR_1))
         10:DCFD  85 ED      			sta.h	_bp
         10:DCFF  A9 03      			lda	#bank(_tileset_ARMOR_1)
         10:DD01  85 02      			sta	_bp_bank
 9103                        		__ld.wi		___sizeof__tileset_ARMOR_1
         10:DD03  A9 80      			lda.l	#___sizeof__tileset_ARMOR_1
         10:DD05  A0 00      			ldy.h	#___sizeof__tileset_ARMOR_1
 9104                        		__lsr.wi	1
         10:DD07  42         			say
         10:DD08  4A         			lsr	a
         10:DD09  42         			say
         10:DD0A  6A         			ror	a
 9105                        		__st.wmq	_ax
         10:DD0B  85 F8      			sta.l	_ax
         10:DD0D  84 F9      			sty.h	_ax
 9106                        		 _load_vram.3
         10:DD0F  82         			clx				; Offset to PCE VDC.
         10:DD10  20 63 FF   			call	load_vram_x
 9107                        	
 9108                        		.dbg	line,	"include\routines_SHOP.c", 176; zenny_amount -= shop_prices[5];
 9109                        		__ld.wm		_shop_prices + 10
         10:DD13  AD 30 26   			lda.l	_shop_prices + 10
         10:DD16  AC 31 26   			ldy.h	_shop_prices + 10
 9110                        		__isub_st.wmq	_zenny_amount
         10:DD19  38         			sec
         10:DD1A  49 FF      			eor	#$FF
         10:DD1C  6D 22 26   			adc.l	_zenny_amount
         10:DD1F  8D 22 26   			sta.l	_zenny_amount
         10:DD22  98         			tya
         10:DD23  49 FF      			eor	#$FF
         10:DD25  6D 23 26   			adc.h	_zenny_amount
         10:DD28  8D 23 26   			sta.h	_zenny_amount
 9111                        	
 9112                        		.dbg	line,	"include\routines_SHOP.c", 177; display_ZENNY();
 9113                        		__call		_display_ZENNY
         10:DD2B  20 45 FF   			call	_display_ZENNY
 9114                        	
 9115                        		.dbg	line,	"include\routines_SHOP.c", 178; }
 9116                        	
 9117                        		.dbg	line,	"include\routines_SHOP.c", 179; }
 9118    10:DD2E             	.LL413	.alias		.LL396
 9119                        	
 9120                        		.dbg	line,	"include\routines_SHOP.c", 181; break;   
 9121    10:DD2E             	.LL412	.alias		.LL396
 9122                        		__bra		.LL396
         10:DD2E  4C EC DE   			bra	.LL396
 9123                        	
 9124                        		.dbg	line,	"include\routines_SHOP.c", 184; // ARMOR 2 //
 9125                        	
 9126                        		.dbg	line,	"include\routines_SHOP.c", 185; case 6:
 9127    10:DD31             	.LL414:
 9128                        		__case		6
 9129                        	
 9130                        		.dbg	line,	"include\routines_SHOP.c", 186; if(zenny_amount >= shop_prices[6])
 9131                        		__ld.wm		_zenny_amount
         10:DD31  AD 22 26   			lda.l	_zenny_amount
         10:DD34  AC 23 26   			ldy.h	_zenny_amount
 9132                        		__sge_w.wm	_shop_prices + 12
         10:DD37  CD 32 26   			cmp.l	_shop_prices + 12		; Subtract memory from Y:A.
         10:DD3A  98         			tya
         10:DD3B  ED 33 26   			sbc.h	_shop_prices + 12
         10:DD3E  50 02      			bvc	!+
         10:DD40  49 80      			eor	#$80		; +ve if Y:A >= memory (signed).
         10:DD42  49 80      	!:		eor	#$80
         10:DD44  0A         			asl	a
 9133                        		__bfalse	.LL415
         10:DD45  B0 03 4C EC			bcc	.LL415
         10:DD49  DE          
 9134                        	
 9135                        		.dbg	line,	"include\routines_SHOP.c", 187; {
 9136                        	
 9137                        		.dbg	line,	"include\routines_SHOP.c", 188; if(armor_level < 2)
 9138                        		__ld.umq	_armor_level
         10:DD4A  AD 1D 23   			lda	_armor_level
 9139                        		__ult_b.uiq	2
         10:DD4D  C9 02      			cmp	#2		; Subtract integer from A.
         10:DD4F  6A         			ror	a		; CC if A < integer.
         10:DD50  49 80      			eor	#$80
         10:DD52  2A         			rol	a
 9140                        		__bfalse	.LL416
         10:DD53  B0 03 4C EC			bcc	.LL416
         10:DD57  DE          
 9141                        	
 9142                        		.dbg	line,	"include\routines_SHOP.c", 189; {
 9143                        	
 9144                        		.dbg	line,	"include\routines_SHOP.c", 190; armor_level = 2;
 9145                        		__st.umiq	2, _armor_level
         10:DD58  A9 02      			lda.l	#2
         10:DD5A  8D 1D 23   			sta	_armor_level
 9146                        	
 9147                        		.dbg	line,	"include\routines_SHOP.c", 191; load_vram( ARMOR_VRAM_ADR, tileset_ARMOR_2, SIZEOF(tileset_ARMOR_2) >> 1 );
 9148                        		__st.wmiq	4320, _di
         10:DD5D  A9 E0      			lda.l	#4320
         10:DD5F  85 F0      			sta.l	_di
         10:DD61  A9 10      			lda.h	#4320
         10:DD63  85 F1      			sta.h	_di
 9149                        		__farptr	_tileset_ARMOR_2, _bp_bank, _bp
         10:DD65  A9 80      			lda.l	#$6000 + ($1FFF & (_tileset_ARMOR_2))
         10:DD67  85 EC      			sta.l	_bp
         10:DD69  A9 75      			lda.h	#$6000 + ($1FFF & (_tileset_ARMOR_2))
         10:DD6B  85 ED      			sta.h	_bp
         10:DD6D  A9 03      			lda	#bank(_tileset_ARMOR_2)
         10:DD6F  85 02      			sta	_bp_bank
 9150                        		__ld.wi		___sizeof__tileset_ARMOR_2
         10:DD71  A9 80      			lda.l	#___sizeof__tileset_ARMOR_2
         10:DD73  A0 00      			ldy.h	#___sizeof__tileset_ARMOR_2
 9151                        		__lsr.wi	1
         10:DD75  42         			say
         10:DD76  4A         			lsr	a
         10:DD77  42         			say
         10:DD78  6A         			ror	a
 9152                        		__st.wmq	_ax
         10:DD79  85 F8      			sta.l	_ax
         10:DD7B  84 F9      			sty.h	_ax
 9153                        		 _load_vram.3
         10:DD7D  82         			clx				; Offset to PCE VDC.
         10:DD7E  20 63 FF   			call	load_vram_x
 9154                        	
 9155                        		.dbg	line,	"include\routines_SHOP.c", 193; zenny_amount -= shop_prices[6];
 9156                        		__ld.wm		_shop_prices + 12
         10:DD81  AD 32 26   			lda.l	_shop_prices + 12
         10:DD84  AC 33 26   			ldy.h	_shop_prices + 12
 9157                        		__isub_st.wmq	_zenny_amount
         10:DD87  38         			sec
         10:DD88  49 FF      			eor	#$FF
         10:DD8A  6D 22 26   			adc.l	_zenny_amount
         10:DD8D  8D 22 26   			sta.l	_zenny_amount
         10:DD90  98         			tya
         10:DD91  49 FF      			eor	#$FF
         10:DD93  6D 23 26   			adc.h	_zenny_amount
         10:DD96  8D 23 26   			sta.h	_zenny_amount
 9158                        	
 9159                        		.dbg	line,	"include\routines_SHOP.c", 194; display_ZENNY();
 9160                        		__call		_display_ZENNY
         10:DD99  20 45 FF   			call	_display_ZENNY
 9161                        	
 9162                        		.dbg	line,	"include\routines_SHOP.c", 195; }
 9163                        	
 9164                        		.dbg	line,	"include\routines_SHOP.c", 196; }
 9165    10:DD9C             	.LL416	.alias		.LL396
 9166                        	
 9167                        		.dbg	line,	"include\routines_SHOP.c", 198; break;    
 9168    10:DD9C             	.LL415	.alias		.LL396
 9169                        		__bra		.LL396
         10:DD9C  4C EC DE   			bra	.LL396
 9170                        	
 9171                        		.dbg	line,	"include\routines_SHOP.c", 201; // ARMOR 4 //
 9172                        	
 9173                        		.dbg	line,	"include\routines_SHOP.c", 202; case 7:
 9174    10:DD9F             	.LL417:
 9175                        		__case		7
 9176                        	
 9177                        		.dbg	line,	"include\routines_SHOP.c", 203; if(zenny_amount >= shop_prices[7])
 9178                        		__ld.wm		_zenny_amount
         10:DD9F  AD 22 26   			lda.l	_zenny_amount
         10:DDA2  AC 23 26   			ldy.h	_zenny_amount
 9179                        		__sge_w.wm	_shop_prices + 14
         10:DDA5  CD 34 26   			cmp.l	_shop_prices + 14		; Subtract memory from Y:A.
         10:DDA8  98         			tya
         10:DDA9  ED 35 26   			sbc.h	_shop_prices + 14
         10:DDAC  50 02      			bvc	!+
         10:DDAE  49 80      			eor	#$80		; +ve if Y:A >= memory (signed).
         10:DDB0  49 80      	!:		eor	#$80
         10:DDB2  0A         			asl	a
 9180                        		__bfalse	.LL418
         10:DDB3  B0 03 4C EC			bcc	.LL418
         10:DDB7  DE          
 9181                        	
 9182                        		.dbg	line,	"include\routines_SHOP.c", 204; {
 9183                        	
 9184                        		.dbg	line,	"include\routines_SHOP.c", 205; if(armor_level < 4)
 9185                        		__ld.umq	_armor_level
         10:DDB8  AD 1D 23   			lda	_armor_level
 9186                        		__ult_b.uiq	4
         10:DDBB  C9 04      			cmp	#4		; Subtract integer from A.
         10:DDBD  6A         			ror	a		; CC if A < integer.
         10:DDBE  49 80      			eor	#$80
         10:DDC0  2A         			rol	a
 9187                        		__bfalse	.LL419
         10:DDC1  B0 03 4C EC			bcc	.LL419
         10:DDC5  DE          
 9188                        	
 9189                        		.dbg	line,	"include\routines_SHOP.c", 206; {
 9190                        	
 9191                        		.dbg	line,	"include\routines_SHOP.c", 207; armor_level = 4;
 9192                        		__st.umiq	4, _armor_level
         10:DDC6  A9 04      			lda.l	#4
         10:DDC8  8D 1D 23   			sta	_armor_level
 9193                        	
 9194                        		.dbg	line,	"include\routines_SHOP.c", 208; load_vram( ARMOR_VRAM_ADR, tileset_ARMOR_4, SIZEOF(tileset_ARMOR_4) >> 1 );
 9195                        		__st.wmiq	4320, _di
         10:DDCB  A9 E0      			lda.l	#4320
         10:DDCD  85 F0      			sta.l	_di
         10:DDCF  A9 10      			lda.h	#4320
         10:DDD1  85 F1      			sta.h	_di
 9196                        		__farptr	_tileset_ARMOR_4, _bp_bank, _bp
         10:DDD3  A9 00      			lda.l	#$6000 + ($1FFF & (_tileset_ARMOR_4))
         10:DDD5  85 EC      			sta.l	_bp
         10:DDD7  A9 76      			lda.h	#$6000 + ($1FFF & (_tileset_ARMOR_4))
         10:DDD9  85 ED      			sta.h	_bp
         10:DDDB  A9 03      			lda	#bank(_tileset_ARMOR_4)
         10:DDDD  85 02      			sta	_bp_bank
 9197                        		__ld.wi		___sizeof__tileset_ARMOR_4
         10:DDDF  A9 80      			lda.l	#___sizeof__tileset_ARMOR_4
         10:DDE1  A0 00      			ldy.h	#___sizeof__tileset_ARMOR_4
 9198                        		__lsr.wi	1
         10:DDE3  42         			say
         10:DDE4  4A         			lsr	a
         10:DDE5  42         			say
         10:DDE6  6A         			ror	a
 9199                        		__st.wmq	_ax
         10:DDE7  85 F8      			sta.l	_ax
         10:DDE9  84 F9      			sty.h	_ax
 9200                        		 _load_vram.3
         10:DDEB  82         			clx				; Offset to PCE VDC.
         10:DDEC  20 63 FF   			call	load_vram_x
 9201                        	
 9202                        		.dbg	line,	"include\routines_SHOP.c", 210; zenny_amount -= shop_prices[7];
 9203                        		__ld.wm		_shop_prices + 14
         10:DDEF  AD 34 26   			lda.l	_shop_prices + 14
         10:DDF2  AC 35 26   			ldy.h	_shop_prices + 14
 9204                        		__isub_st.wmq	_zenny_amount
         10:DDF5  38         			sec
         10:DDF6  49 FF      			eor	#$FF
         10:DDF8  6D 22 26   			adc.l	_zenny_amount
         10:DDFB  8D 22 26   			sta.l	_zenny_amount
         10:DDFE  98         			tya
         10:DDFF  49 FF      			eor	#$FF
         10:DE01  6D 23 26   			adc.h	_zenny_amount
         10:DE04  8D 23 26   			sta.h	_zenny_amount
 9205                        	
 9206                        		.dbg	line,	"include\routines_SHOP.c", 211; display_ZENNY();
 9207                        		__call		_display_ZENNY
         10:DE07  20 45 FF   			call	_display_ZENNY
 9208                        	
 9209                        		.dbg	line,	"include\routines_SHOP.c", 212; }
 9210                        	
 9211                        		.dbg	line,	"include\routines_SHOP.c", 213; }
 9212    10:DE0A             	.LL419	.alias		.LL396
 9213                        	
 9214                        		.dbg	line,	"include\routines_SHOP.c", 215; break;   
 9215    10:DE0A             	.LL418	.alias		.LL396
 9216                        		__bra		.LL396
         10:DE0A  4C EC DE   			bra	.LL396
 9217                        	
 9218                        		.dbg	line,	"include\routines_SHOP.c", 218; // ARMOR 8 //
 9219                        	
 9220                        		.dbg	line,	"include\routines_SHOP.c", 219; case 8:
 9221    10:DE0D             	.LL420:
 9222                        		__case		8
 9223                        	
 9224                        		.dbg	line,	"include\routines_SHOP.c", 220; if(zenny_amount >= shop_prices[8])
 9225                        		__ld.wm		_zenny_amount
         10:DE0D  AD 22 26   			lda.l	_zenny_amount
         10:DE10  AC 23 26   			ldy.h	_zenny_amount
 9226                        		__sge_w.wm	_shop_prices + 16
         10:DE13  CD 36 26   			cmp.l	_shop_prices + 16		; Subtract memory from Y:A.
         10:DE16  98         			tya
         10:DE17  ED 37 26   			sbc.h	_shop_prices + 16
         10:DE1A  50 02      			bvc	!+
         10:DE1C  49 80      			eor	#$80		; +ve if Y:A >= memory (signed).
         10:DE1E  49 80      	!:		eor	#$80
         10:DE20  0A         			asl	a
 9227                        		__bfalse	.LL421
         10:DE21  B0 03 4C EC			bcc	.LL421
         10:DE25  DE          
 9228                        	
 9229                        		.dbg	line,	"include\routines_SHOP.c", 221; {
 9230                        	
 9231                        		.dbg	line,	"include\routines_SHOP.c", 222; if(armor_level < 8)
 9232                        		__ld.umq	_armor_level
         10:DE26  AD 1D 23   			lda	_armor_level
 9233                        		__ult_b.uiq	8
         10:DE29  C9 08      			cmp	#8		; Subtract integer from A.
         10:DE2B  6A         			ror	a		; CC if A < integer.
         10:DE2C  49 80      			eor	#$80
         10:DE2E  2A         			rol	a
 9234                        		__bfalse	.LL422
         10:DE2F  B0 03 4C EC			bcc	.LL422
         10:DE33  DE          
 9235                        	
 9236                        		.dbg	line,	"include\routines_SHOP.c", 223; {
 9237                        	
 9238                        		.dbg	line,	"include\routines_SHOP.c", 224; armor_level = 8;
 9239                        		__st.umiq	8, _armor_level
         10:DE34  A9 08      			lda.l	#8
         10:DE36  8D 1D 23   			sta	_armor_level
 9240                        	
 9241                        		.dbg	line,	"include\routines_SHOP.c", 225; load_vram( ARMOR_VRAM_ADR, tileset_ARMOR_8, SIZEOF(tileset_ARMOR_8) >> 1 );
 9242                        		__st.wmiq	4320, _di
         10:DE39  A9 E0      			lda.l	#4320
         10:DE3B  85 F0      			sta.l	_di
         10:DE3D  A9 10      			lda.h	#4320
         10:DE3F  85 F1      			sta.h	_di
 9243                        		__farptr	_tileset_ARMOR_8, _bp_bank, _bp
         10:DE41  A9 80      			lda.l	#$6000 + ($1FFF & (_tileset_ARMOR_8))
         10:DE43  85 EC      			sta.l	_bp
         10:DE45  A9 76      			lda.h	#$6000 + ($1FFF & (_tileset_ARMOR_8))
         10:DE47  85 ED      			sta.h	_bp
         10:DE49  A9 03      			lda	#bank(_tileset_ARMOR_8)
         10:DE4B  85 02      			sta	_bp_bank
 9244                        		__ld.wi		___sizeof__tileset_ARMOR_8
         10:DE4D  A9 80      			lda.l	#___sizeof__tileset_ARMOR_8
         10:DE4F  A0 00      			ldy.h	#___sizeof__tileset_ARMOR_8
 9245                        		__lsr.wi	1
         10:DE51  42         			say
         10:DE52  4A         			lsr	a
         10:DE53  42         			say
         10:DE54  6A         			ror	a
 9246                        		__st.wmq	_ax
         10:DE55  85 F8      			sta.l	_ax
         10:DE57  84 F9      			sty.h	_ax
 9247                        		 _load_vram.3
         10:DE59  82         			clx				; Offset to PCE VDC.
         10:DE5A  20 63 FF   			call	load_vram_x
 9248                        	
 9249                        		.dbg	line,	"include\routines_SHOP.c", 227; zenny_amount -= shop_prices[8];
 9250                        		__ld.wm		_shop_prices + 16
         10:DE5D  AD 36 26   			lda.l	_shop_prices + 16
         10:DE60  AC 37 26   			ldy.h	_shop_prices + 16
 9251                        		__isub_st.wmq	_zenny_amount
         10:DE63  38         			sec
         10:DE64  49 FF      			eor	#$FF
         10:DE66  6D 22 26   			adc.l	_zenny_amount
         10:DE69  8D 22 26   			sta.l	_zenny_amount
         10:DE6C  98         			tya
         10:DE6D  49 FF      			eor	#$FF
         10:DE6F  6D 23 26   			adc.h	_zenny_amount
         10:DE72  8D 23 26   			sta.h	_zenny_amount
 9252                        	
 9253                        		.dbg	line,	"include\routines_SHOP.c", 228; display_ZENNY();
 9254                        		__call		_display_ZENNY
         10:DE75  20 45 FF   			call	_display_ZENNY
 9255                        	
 9256                        		.dbg	line,	"include\routines_SHOP.c", 229; }
 9257                        	
 9258                        		.dbg	line,	"include\routines_SHOP.c", 230; }
 9259    10:DE78             	.LL422	.alias		.LL396
 9260                        	
 9261                        		.dbg	line,	"include\routines_SHOP.c", 232; break;   
 9262    10:DE78             	.LL421	.alias		.LL396
 9263                        		__bra		.LL396
         10:DE78  80 72      			bra	.LL396
 9264                        	
 9265                        		.dbg	line,	"include\routines_SHOP.c", 235; // POTION //
 9266                        	
 9267                        		.dbg	line,	"include\routines_SHOP.c", 236; case 9:
 9268    10:DE7A             	.LL423:
 9269                        		__case		9
 9270                        	
 9271                        		.dbg	line,	"include\routines_SHOP.c", 237; if(zenny_amount >= shop_prices[9])
 9272                        		__ld.wm		_zenny_amount
         10:DE7A  AD 22 26   			lda.l	_zenny_amount
         10:DE7D  AC 23 26   			ldy.h	_zenny_amount
 9273                        		__sge_w.wm	_shop_prices + 18
         10:DE80  CD 38 26   			cmp.l	_shop_prices + 18		; Subtract memory from Y:A.
         10:DE83  98         			tya
         10:DE84  ED 39 26   			sbc.h	_shop_prices + 18
         10:DE87  50 02      			bvc	!+
         10:DE89  49 80      			eor	#$80		; +ve if Y:A >= memory (signed).
         10:DE8B  49 80      	!:		eor	#$80
         10:DE8D  0A         			asl	a
 9274                        		__bfalse	.LL424
         10:DE8E  90 5C      			bcc	.LL424
 9275                        	
 9276                        		.dbg	line,	"include\routines_SHOP.c", 238; {
 9277                        	
 9278                        		.dbg	line,	"include\routines_SHOP.c", 239; potion_amount += 1;
 9279                        		__add_st.umiq	1, _potion_amount
         10:DE90  EE 21 23   			inc	_potion_amount
 9280                        	
 9281                        		.dbg	line,	"include\routines_SHOP.c", 241; zenny_amount -= shop_prices[9];
 9282                        		__ld.wm		_shop_prices + 18
         10:DE93  AD 38 26   			lda.l	_shop_prices + 18
         10:DE96  AC 39 26   			ldy.h	_shop_prices + 18
 9283                        		__isub_st.wmq	_zenny_amount
         10:DE99  38         			sec
         10:DE9A  49 FF      			eor	#$FF
         10:DE9C  6D 22 26   			adc.l	_zenny_amount
         10:DE9F  8D 22 26   			sta.l	_zenny_amount
         10:DEA2  98         			tya
         10:DEA3  49 FF      			eor	#$FF
         10:DEA5  6D 23 26   			adc.h	_zenny_amount
         10:DEA8  8D 23 26   			sta.h	_zenny_amount
 9284                        	
 9285                        		.dbg	line,	"include\routines_SHOP.c", 242; display_POTION();
 9286                        		__call		_display_POTION
         10:DEAB  20 3B FF   			call	_display_POTION
 9287                        	
 9288                        		.dbg	line,	"include\routines_SHOP.c", 243; }
 9289                        	
 9290                        		.dbg	line,	"include\routines_SHOP.c", 245; break;   
 9291    10:DEAE             	.LL424	.alias		.LL396
 9292                        		__bra		.LL396
         10:DEAE  80 3C      			bra	.LL396
 9293                        	
 9294                        		.dbg	line,	"include\routines_SHOP.c", 248; // EXIT //
 9295                        	
 9296                        		.dbg	line,	"include\routines_SHOP.c", 249; case 10:
 9297    10:DEB0             	.LL425:
 9298                        		__case		10
 9299                        	
 9300                        		.dbg	line,	"include\routines_SHOP.c", 250; // HIDE CURSOR //
 9301                        	
 9302                        		.dbg	line,	"include\routines_SHOP.c", 251; spr_set(0);
 9303                        		__ld.uiq	0
         10:DEB0  62         			cla
 9304                        		__call		_spr_set.1
         10:DEB1  20 DD E7   			call	_spr_set.1
 9305                        	
 9306                        		.dbg	line,	"include\routines_SHOP.c", 252; spr_hide();
 9307                        		__call		_spr_hide
         10:DEB4  20 F8 E7   			call	_spr_hide
 9308                        	
 9309                        		.dbg	line,	"include\routines_SHOP.c", 254; // REINIT PLAYER //
 9310                        	
 9311                        		.dbg	line,	"include\routines_SHOP.c", 255; init_PLAYER();
 9312                        		__call		_init_PLAYER
         10:DEB7  20 31 FF   			call	_init_PLAYER
 9313                        	
 9314                        		.dbg	line,	"include\routines_SHOP.c", 258; respawn = RESPAWN_SHOP;
 9315                        		__st.umiq	2, _respawn
         10:DEBA  A9 02      			lda.l	#2
         10:DEBC  8D 13 23   			sta	_respawn
 9316                        	
 9317                        		.dbg	line,	"include\routines_SHOP.c", 259; sequence_loaded = FALSE;
 9318                        		__st.umiq	0, _sequence_loaded
         10:DEBF  9C 11 23   			stz	_sequence_loaded
 9319                        	
 9320                        		.dbg	line,	"include\routines_SHOP.c", 260; sequence_id = SEQUENCE_GAME;
 9321                        		__st.umiq	2, _sequence_id
         10:DEC2  A9 02      			lda.l	#2
         10:DEC4  8D 10 23   			sta	_sequence_id
 9322                        	
 9323                        		.dbg	line,	"include\routines_SHOP.c", 261; break;                  
 9324                        		__bra		.LL396
         10:DEC7  80 23      			bra	.LL396
 9325                        	
 9326                        		.dbg	line,	"include\routines_SHOP.c", 262; }
 9327    10:DEC9             	.LL395:
 9328                        		__switch_r.ur	0, 10
         10:DEC9  C9 0B      			cmp	#(10 - 0) + 1
         10:DECB  90 02      			bcc	!found+
         10:DECD  A9 0B      	!default:	lda	#(10 - 0) + 1
         10:DECF  0A         	!found:		asl	a
         10:DED0  AA         			tax
         10:DED1  7C D4 DE   			jmp	[!table+, x]
 9329                        	
 9330    10:DED4  D1 DA      	!table:		dw	.LL397, .LL400, .LL403, .LL406, .LL409, .LL411, .LL414, .LL417
         10:DED6  3F DB       
         10:DED8  AD DB       
         10:DEDA  1B DC       
         10:DEDC  89 DC       
         10:DEDE  C3 DC       
         10:DEE0  31 DD       
         10:DEE2  9F DD       
 9331    10:DEE4  0D DE      			dw	.LL420, .LL423, .LL425
         10:DEE6  7A DE       
         10:DEE8  B0 DE       
 9332    10:DEEA  EC DE      			dw	.LL396
 9333    10:DEEC             	.LL396:
 9334                        	
 9335                        		.dbg	line,	"include\routines_SHOP.c", 263; }
 9336                        	
 9337                        		.dbg	line,	"include\routines_SHOP.c", 264; }
 9338    10:DEEC             	.LL394:
 9339    10:DEEC             	.LL393:
 9340    10:DEEC             	.LL390:
 9341    10:DEEC             	.LL386:
 9342    10:DEEC             	.LL383:
 9343    10:DEEC             	.LL378:
 9344                        		__return	0
         10:DEEC  4C EF FF   			jmp	leave_proc
 9345                        		.dbg	clear
 9346                        		.endp
 9347               7960     		.data
 9348               230D     		.bss
 9349    F8:230D             	__joypad_BUTTONS_SHOP_loc:
 9350    F8:230D             			ds	1
 9351    F8:230E             	__joypad_BUTTONS_SHOP_end:
 9352               E309     		.code
 9353                        		.pceas
 9354                        	
 9355                        		.dbg	line,	"main.c", 24; #include "include/init.c"
 9356                        		.dbg	line,	"include\init.c", 1; #include "huc.h"
 9357                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 1; #ifndef _hucc_legacy_h
 9358                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 2; #define _hucc_legacy_h
 9359                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 4; /****************************************************************************
 9360                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 5; ; ***************************************************************************
 9361                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 6; ;
 9362                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 7; ; huc.h
 9363                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 8; ;
 9364                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 9; ; HuCC wrapper file to include a default set of HuC-compatible functions.
 9365                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 10; ;
 9366                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 11; ; Copyright John Brandwood 2024.
 9367                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 12; ;
 9368                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 13; ; Distributed under the Boost Software License, Version 1.0.
 9369                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 14; ; (See accompanying file LICENSE_1_0.txt or copy at
 9370                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 15; ;  http://www.boost.org/LICENSE_1_0.txt)
 9371                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 16; ;
 9372                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 17; ; ***************************************************************************
 9373                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 18; ; ***************************************************************************
 9374                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 19; ;
 9375                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 20; ; When the HuCC compiler is invoked with the "--legacy" option to compile old
 9376                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 21; ; projects, then this "huc.h" file is automatically included.
 9377                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 22; ;
 9378                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 23; ; This file includes a set of the individual HuCC headers which correspond to
 9379                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 24; ; HuC's built-in functions and MagicKit library.
 9380                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 25; ;
 9381                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 26; ; New HuCC projects should, preferably, include the specific headers that are
 9382                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 27; ; needed, which will then allow them to replace parts of the standard library
 9383                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 28; ; with newer functions, or they can just manually include this "huc.h" file.
 9384                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 29; ;
 9385                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 30; ; ***************************************************************************
 9386                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 31; ; **************************************************************************/
 9387                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 33; #include "hucc-systemcard.h"
 9388                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 34; #include "hucc-baselib.h"
 9389                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 35; #include "hucc-gfx.h"
 9390                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 36; #include "hucc-string.h"
 9391                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 37; #include "hucc-old-scroll.h"
 9392                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 38; #include "hucc-old-spr.h"
 9393                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 39; #include "hucc-old-map.h"
 9394                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 40; #include "hucc-old-line.h"
 9395                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 42; #endif // _hucc_legacy_h
 9396                        		.dbg	line,	"include\init.c", 2; #include "hucc-scroll.h"
 9397                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 1; #ifndef _hucc_scroll_h
 9398                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 2; #define _hucc_scroll_h
 9399                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 4; /****************************************************************************
 9400                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 5; ; ***************************************************************************
 9401                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 6; ;
 9402                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 7; ; hucc-scroll.h
 9403                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 8; ;
 9404                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 9; ; Routines for a fast split-screen scrolling system.
 9405                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 10; ;
 9406                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 11; ; Copyright John Brandwood 2024.
 9407                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 12; ;
 9408                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 13; ; Distributed under the Boost Software License, Version 1.0.
 9409                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 14; ; (See accompanying file LICENSE_1_0.txt or copy at
 9410                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 15; ;  http://www.boost.org/LICENSE_1_0.txt)
 9411                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 16; ;
 9412                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 17; ; ***************************************************************************
 9413                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 18; ; ***************************************************************************
 9414                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 19; ;
 9415                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 20; ; The maximum number of splits for each screen layer is set in your project's
 9416                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 21; ; "hucc-config.inc" file, with the library having a limit of 128-per-layer.
 9417                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 22; ;
 9418                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 23; ; Your first active split must be defined to start at screen line 0, and then
 9419                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 24; ; the rest of the active splits must be in increasing line order to match the
 9420                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 25; ; way that the PC Engine displays the output image.
 9421                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 26; ;
 9422                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 27; ; You can have disabled splits interleaved with your active splits.
 9423                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 28; ;
 9424                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 29; ; Splits that are normally disabled can be used to create full screen effects
 9425                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 30; ; such as bouncing the screen up and down by adding blank areas at the top or
 9426                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 31; ; bottom of the screen, and then rapidly changing the height of those areas.
 9427                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 32; ;
 9428                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 33; ; ***************************************************************************
 9429                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 34; ; **************************************************************************/
 9430                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 36; // *************
 9431                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 37; // VDC bits for display_flags ...
 9432                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 38; // *************
 9433                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 40; #ifndef BKG_OFF
 9434                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 41; #define BKG_OFF 0x00
 9435                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 42; #endif
 9436                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 44; #ifndef SPR_OFF
 9437                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 45; #define SPR_OFF 0x00
 9438                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 46; #endif
 9439                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 48; #ifndef BKG_ON
 9440                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 49; #define BKG_ON 0x80
 9441                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 50; #endif
 9442                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 52; #ifndef SPR_ON
 9443                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 53; #define SPR_ON 0x40
 9444                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 54; #endif
 9445                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 56; // *************
 9446                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 57; // Functions in hucc-scroll.asm ...
 9447                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 58; // *************
 9448                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 60; #ifdef __HUCC__
 9449                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 62; #asmdef	HUCC_USES_NEW_SCROLL 1
 9450                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 64; extern void __fastcall scroll_split( unsigned char index<_al>, unsigned char screen_line<_ah>, unsigned int bat_x<_bx>, unsigned int bat_y<_cx>, unsigned char display_flags<_dl> );
 9451                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 65; extern void __fastcall sgx_scroll_split( unsigned char index<_al>, unsigned char screen_line<_ah>, unsigned int bat_x<_bx>, unsigned int bat_y<_cx>, unsigned char display_flags<_dl> );
 9452                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 67; extern void __fastcall disable_split( unsigned char index<acc> );
 9453                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 68; extern void __fastcall sgx_disable_split( unsigned char index<acc> );
 9454                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 70; extern void __fastcall __macro disable_all_splits( void );
 9455                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 71; extern void __fastcall __macro sgx_disable_all_splits( void );
 9456                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 73; #asm
 9457                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 74; .macro	_disable_all_splits
 9458                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 75; ldy	#HUCC_PCE_SPLITS - 1
 9459                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 76; !loop:		tya
 9460                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 77; call	_disable_split.1
 9461                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 78; dey
 9462                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 79; bpl	!loop-
 9463                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 80; .endm
 9464                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 82; .macro	_sgx_disable_all_splits
 9465                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 83; ldy	#HUCC_SGX_SPLITS - 1
 9466                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 84; !loop:		tya
 9467                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 85; call	_sgx_disable_split.1
 9468                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 86; dey
 9469                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 87; bpl	!loop-
 9470                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 88; .endm
 9471                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 89; #endasm
 9472                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 91; #endif // __HUCC__
 9473                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 93; #endif // _hucc_scroll_h
 9474                        		.dbg	line,	"include\init.c", 3; #include "hucc-chrmap.h"
 9475                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 1; #ifndef _hucc_chrmap_h
 9476                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 2; #define _hucc_chrmap_h
 9477                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 4; /****************************************************************************
 9478                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 5; ; ***************************************************************************
 9479                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 6; ;
 9480                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 7; ; hucc-chrmap.h
 9481                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 8; ;
 9482                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 9; ; A simple map system based on 8x8 characters (aka "tiles") in BAT format.
 9483                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 10; ;
 9484                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 11; ; Copyright John Brandwood 2025.
 9485                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 12; ;
 9486                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 13; ; Distributed under the Boost Software License, Version 1.0.
 9487                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 14; ; (See accompanying file LICENSE_1_0.txt or copy at
 9488                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 15; ;  http://www.boost.org/LICENSE_1_0.txt)
 9489                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 16; ;
 9490                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 17; ; ***************************************************************************
 9491                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 18; ; ***************************************************************************
 9492                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 19; ;
 9493                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 20; ; The maximum X and Y size for chrmaps is 256 characters (2048 pixels).
 9494                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 21; ;
 9495                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 22; ; The maximum total size for a chrmap is 16KBytes, which allows for maps up
 9496                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 23; ; to 256x32 tiles (2048x256 pixels).
 9497                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 24; ;
 9498                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 25; ; ***************************************************************************
 9499                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 26; ; **************************************************************************/
 9500                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 28; // *************
 9501                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 29; // This code extends the blkmap library ...
 9502                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 30; // *************
 9503                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 32; #include "hucc-blkmap.h"
 9504                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 34; // *************
 9505                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 35; // Functions in chrmap.asm ...
 9506                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 36; // *************
 9507                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 38; #ifdef __HUCC__
 9508                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 40; #asmdef	HUCC_USES_CHRMAP 1
 9509                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 42; extern void __fastcall __nop set_chrmap( unsigned char __far *chrmap<vdc_map_bank:vdc_map_addr>, unsigned char tiles_w<vdc_map_line_w> );
 9510                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 44; extern void __fastcall draw_bat( void );
 9511                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 45; extern void __fastcall scroll_bat( void );
 9512                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 47; extern void __fastcall blit_bat( unsigned char tile_x<map_bat_x>, unsigned char tile_y<map_bat_y>, unsigned char tile_w<map_draw_x>, unsigned char tile_h<map_draw_y> );
 9513                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 49; #ifdef _SGX
 9514                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 51; extern void __fastcall __nop sgx_set_chrmap( unsigned char __far *chrmap<sgx_map_bank:sgx_map_addr>, unsigned char tiles_w<sgx_map_line_w> );
 9515                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 53; extern void __fastcall sgx_draw_bat( void );
 9516                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 54; extern void __fastcall sgx_scroll_bat( void );
 9517                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 56; extern void __fastcall sgx_blit_bat( unsigned char tile_x<map_bat_x>, unsigned char tile_y<map_bat_y>, unsigned char tile_w<map_draw_x>, unsigned char tile_h<map_draw_y> );
 9518                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 58; #endif
 9519                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 60; #endif // __HUCC__
 9520                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 62; #endif // _hucc_chrmap_h
 9521                        		.dbg	line,	"include\init.c", 4; #include "hucc-blkmap.h"
 9522                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 1; #ifndef _hucc_blkmap_h
 9523                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 2; #define _hucc_blkmap_h
 9524                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 4; /****************************************************************************
 9525                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 5; ; ***************************************************************************
 9526                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 6; ;
 9527                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 7; ; hucc-blkmap.h
 9528                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 8; ;
 9529                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 9; ; A map system based on 16x16 meta-tiles (aka "blocks", aka CHR/BLK/MAP).
 9530                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 10; ;
 9531                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 11; ; Copyright John Brandwood 2025.
 9532                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 12; ;
 9533                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 13; ; Distributed under the Boost Software License, Version 1.0.
 9534                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 14; ; (See accompanying file LICENSE_1_0.txt or copy at
 9535                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 15; ;  http://www.boost.org/LICENSE_1_0.txt)
 9536                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 16; ;
 9537                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 17; ; ***************************************************************************
 9538                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 18; ; ***************************************************************************
 9539                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 19; ;
 9540                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 20; ; The maximum X and Y size for blkmaps is 128 blocks (2048 pixels).
 9541                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 21; ;
 9542                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 22; ; The maximum total size for a blkmap is 16KBytes, which allows for maps up
 9543                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 23; ; to 128x128 blocks (2048x2048 pixels).
 9544                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 24; ;
 9545                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 25; ; Huge multi-screen blkmaps are also supported (optionally).
 9546                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 26; ;
 9547                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 27; ; The maximum X and Y for multi-screen maps is 128 screens (32768 pixels).
 9548                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 28; ;
 9549                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 29; ; The maximum total size for a multi-screen map is 8KBytes, which allows for
 9550                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 30; ; a total of 1024 screens.
 9551                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 31; ;
 9552                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 32; ; ***************************************************************************
 9553                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 33; ; **************************************************************************/
 9554                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 35; // *************
 9555                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 36; // Functions in blkmap.asm ...
 9556                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 37; // *************
 9557                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 39; #ifdef __HUCC__
 9558                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 41; #asmdef	HUCC_USES_BLKMAP 1
 9559                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 43; // Current top-left of drawn map in pixels.
 9560                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 44; extern unsigned int   vdc_map_pxl_x;
 9561                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 45; extern unsigned int   vdc_map_pxl_y;
 9562                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 47; // Width and height to draw/scroll in characters (not tiles).
 9563                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 48; extern unsigned char  vdc_map_draw_w;
 9564                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 49; extern unsigned char  vdc_map_draw_h;
 9565                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 51; // Width of map (or multi-screen BAT) in tiles.
 9566                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 52; extern unsigned char  vdc_map_line_w;
 9567                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 54; // Width of map in screens (if multi-screen map).
 9568                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 55; extern unsigned char  vdc_map_scrn_w;
 9569                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 57; // Extra information returned by get_map_block() and sgx_get_map_block(),
 9570                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 58; // which are the collision flags and the mask/overlay sprite for the BLK.
 9571                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 59; extern unsigned char  map_blk_flag;
 9572                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 60; extern unsigned char  map_blk_mask;
 9573                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 62; extern unsigned char  vdc_scr_bank;
 9574                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 63; extern unsigned char *vdc_scr_addr;
 9575                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 65; extern unsigned char  vdc_map_bank;
 9576                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 66; extern unsigned char *vdc_map_addr;
 9577                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 68; extern unsigned char  vdc_blk_bank;
 9578                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 69; extern unsigned char *vdc_blk_addr;
 9579                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 71; extern unsigned char  vdc_tbl_bank;
 9580                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 72; extern unsigned char *vdc_tbl_addr;
 9581                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 74; extern void __fastcall set_blocks( unsigned char __far *blk_def<vdc_blk_bank:vdc_blk_addr>, unsigned char __far *flg_def<vdc_tbl_bank:vdc_tbl_addr>, unsigned char number_of_blocks<_al> );
 9582                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 75; extern void __fastcall __macro set_blkmap( unsigned char __far *blk_map<vdc_map_bank:vdc_map_addr>, unsigned char blocks_w<vdc_map_line_w> );
 9583                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 76; extern void __fastcall __macro set_multimap( unsigned char __far *multi_map<vdc_scr_bank:vdc_scr_addr>, unsigned char screens_w<vdc_map_scrn_w> );
 9584                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 78; extern void __fastcall draw_map( void );
 9585                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 79; extern void __fastcall scroll_map( void );
 9586                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 81; extern void __fastcall blit_map( unsigned char tile_x<map_bat_x>, unsigned char tile_y<map_bat_y>, unsigned char tile_w<map_draw_x>, unsigned char tile_h<map_draw_y> );
 9587                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 83; extern unsigned char __fastcall get_map_block( unsigned int x<map_pxl_x>, unsigned int y<map_pxl_y> );
 9588                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 85; #asm
 9589                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 86; .macro	_set_blkmap.2
 9590                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 87; stz	vdc_scr_bank
 9591                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 88; .endm
 9592                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 90; .macro	_set_multimap.2
 9593                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 91; lda	vdc_bat_width
 9594                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 92; lsr	a
 9595                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 93; sta	vdc_map_line_w
 9596                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 94; .endm
 9597                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 96; .macro	SCREEN
 9598                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 97; db	(((\1) & $1FFF) | $6000) >> 8, bank(\1)
 9599                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 98; db	(((\2) & $1FFF) | $4000) >> 8, bank(\2)
 9600                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 99; db	(((\3) & $1FFF) | $6000) >> 8, bank(\3)
 9601                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 100; dw	(\4)
 9602                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 101; .endm
 9603                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 102; #endasm
 9604                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 104; #ifdef _SGX
 9605                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 106; // Current top-left of drawn map in pixels.
 9606                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 107; extern unsigned int   sgx_map_pxl_x;
 9607                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 108; extern unsigned int   sgx_map_pxl_y;
 9608                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 110; // Width and height to draw/scroll in characters (not tiles).
 9609                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 111; extern unsigned char  sgx_map_draw_w;
 9610                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 112; extern unsigned char  sgx_map_draw_h;
 9611                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 114; // Width of map (or multi-screen BAT) in tiles.
 9612                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 115; extern unsigned char  sgx_map_line_w;
 9613                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 117; // Width of map in screens (if multi-screen map).
 9614                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 118; extern unsigned char  sgx_map_scrn_w;
 9615                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 120; extern unsigned char  sgx_scr_bank;
 9616                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 121; extern unsigned char *sgx_scr_addr;
 9617                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 123; extern unsigned char  sgx_map_bank;
 9618                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 124; extern unsigned char *sgx_map_addr;
 9619                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 126; extern unsigned char  sgx_blk_bank;
 9620                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 127; extern unsigned char *sgx_blk_addr;
 9621                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 129; extern unsigned char  sgx_tbl_bank;
 9622                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 130; extern unsigned char *sgx_tbl_addr;
 9623                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 132; extern void __fastcall sgx_set_blocks( unsigned char __far *blk_def<sgx_blk_bank:sgx_blk_addr>, unsigned char __far *flg_def<sgx_tbl_bank:sgx_tbl_addr>, unsigned char number_of_blocks<_al> );
 9624                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 133; extern void __fastcall __macro sgx_set_blkmap( unsigned char __far *blk_map<sgx_map_bank:sgx_map_addr>, unsigned char blocks_w<sgx_map_line_w> );
 9625                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 134; extern void __fastcall __macro sgx_set_multimap( unsigned char __far *multi_map<sgx_scr_bank:sgx_scr_addr>, unsigned char screens_w<sgx_map_scrn_w> );
 9626                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 136; extern void __fastcall sgx_draw_map( void );
 9627                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 137; extern void __fastcall sgx_scroll_map( void );
 9628                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 139; extern void __fastcall sgx_blit_map( unsigned char tile_x<map_bat_x>, unsigned char tile_y<map_bat_y>, unsigned char tile_w<map_draw_x>, unsigned char tile_h<map_draw_y> );
 9629                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 141; extern unsigned char __fastcall sgx_get_map_block( unsigned int x<map_pxl_x>, unsigned int y<map_pxl_y> );
 9630                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 143; #asm
 9631                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 144; .macro	_sgx_set_blkmap.2
 9632                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 145; stz	sgx_scr_bank
 9633                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 146; .endm
 9634                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 148; .macro	_sgx_set_multimap.2
 9635                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 149; lda	sgx_bat_width
 9636                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 150; lsr	a
 9637                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 151; sta	sgx_map_line_w
 9638                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 152; .endm
 9639                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 153; #endasm
 9640                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 155; #endif
 9641                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 157; #endif // __HUCC__
 9642                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 159; #endif // _hucc_blkmap_h
 9643                        		.dbg	line,	"include\init.c", 13; void init_SYSTEM()
 9644                        		.dbg	line,	"include\init.c", 14; {
 9645                        	;***********************
 9646                        	;***********************
 9647                        	
 9648                        		.hucc
 9649    11:CA22             		.proc		_init_SYSTEM
 9650                        		__enter		_init_SYSTEM
 9651                        	
 9652                        		.dbg	line,	"include\init.c", 15; // DISABLE DISPLAY //
 9653                        	
 9654                        		.dbg	line,	"include\init.c", 16; disp_off();
 9655                        		__call		_disp_off
         11:CA22  20 29 E4   			call	_disp_off
 9656                        	
 9657                        		.dbg	line,	"include\init.c", 18; // VSYNC //
 9658                        	
 9659                        		.dbg	line,	"include\init.c", 19; vsync();
 9660                        		__call		_vsync
         11:CA25  20 09 E3   			call	_vsync
 9661                        	
 9662                        		.dbg	line,	"include\init.c", 21; // LOAD DEFAULT FONT //
 9663                        	
 9664                        		.dbg	line,	"include\init.c", 22; load_default_font();
 9665                        		 _load_default_font
         11:CA28  82         			clx				; Offset to PCE VDC.
         11:CA29  20 C7 FF   			call	huc_monofont_x
 9666                        	
 9667                        		.dbg	line,	"include\init.c", 25; // SET VDC 1 SCREEN SIZE (IN TILES) - 32x32 = 256 PIXELS
 9668                        	
 9669                        		.dbg	line,	"include\init.c", 26; set_screen_size(SCR_SIZE_32x32);
 9670                        		__st.umiq	0, _al
         11:CA2C  64 F8      			stz	_al
 9671                        		__call		_set_screen_size.1
         11:CA2E  20 27 FF   			call	_set_screen_size.1
 9672                        	
 9673                        		.dbg	line,	"include\init.c", 29; // SET VDC 2 SCREEN SIZE (IN TILES) - 32x32 = 256 PIXELS
 9674                        	
 9675                        		.dbg	line,	"include\init.c", 30; sgx_set_screen_size(SCR_SIZE_32x32);
 9676                        		__st.umiq	0, _al
         11:CA31  64 F8      			stz	_al
 9677                        		__call		_sgx_set_screen_size.1
         11:CA33  20 1D FF   			call	_sgx_set_screen_size.1
 9678                        	
 9679                        		.dbg	line,	"include\init.c", 33; // INIT SPRITE ATTRIBUTE TABLE //
 9680                        	
 9681                        		.dbg	line,	"include\init.c", 34; init_satb();
 9682                        		__call		_init_satb
         11:CA36  20 B7 E7   			call	_init_satb
 9683                        	
 9684                        		.dbg	line,	"include\init.c", 37; // ENABLE DISPLAY //
 9685                        	
 9686                        		.dbg	line,	"include\init.c", 38; //disp_on();
 9687                        	
 9688                        		.dbg	line,	"include\init.c", 39; }
 9689    11:CA39             	.LL426:
 9690                        		__return	0
         11:CA39  4C EF FF   			jmp	leave_proc
 9691                        		.dbg	clear
 9692                        		.endp
 9693                        		.pceas
 9694                        	
 9695                        		.dbg	line,	"include\init.c", 42; void init_VARIABLES()
 9696                        		.dbg	line,	"include\init.c", 43; {
 9697                        	;***********************
 9698                        	;***********************
 9699                        	
 9700                        		.hucc
 9701    11:C87C             		.proc		_init_VARIABLES
 9702                        		__enter		_init_VARIABLES
 9703                        	
 9704                        		.dbg	line,	"include\init.c", 44; sequence_id = SEQUENCE_GAME; //SEQUENCE_GAME | SEQUENCE_SHOP
 9705                        		__st.umiq	2, _sequence_id
         11:C87C  A9 02      			lda.l	#2
         11:C87E  8D 10 23   			sta	_sequence_id
 9706                        	
 9707                        		.dbg	line,	"include\init.c", 46; level_id = 1;
 9708                        		__st.umiq	1, _level_id
         11:C881  A9 01      			lda.l	#1
         11:C883  8D 12 23   			sta	_level_id
 9709                        	
 9710                        		.dbg	line,	"include\init.c", 48; key_amount = 0;
 9711                        		__st.umiq	0, _key_amount
         11:C886  9C 20 23   			stz	_key_amount
 9712                        	
 9713                        		.dbg	line,	"include\init.c", 49; potion_amount = 0;
 9714                        		__st.umiq	0, _potion_amount
         11:C889  9C 21 23   			stz	_potion_amount
 9715                        	
 9716                        		.dbg	line,	"include\init.c", 50; zenny_amount = 90000;
 9717                        		__st.wmiq	90000, _zenny_amount
         11:C88C  A9 90      			lda.l	#90000
         11:C88E  8D 22 26   			sta.l	_zenny_amount
         11:C891  A9 5F      			lda.h	#90000
         11:C893  8D 23 26   			sta.h	_zenny_amount
 9718                        	
 9719                        		.dbg	line,	"include\init.c", 52; weapon_level = 1;
 9720                        		__st.umiq	1, _weapon_level
         11:C896  A9 01      			lda.l	#1
         11:C898  8D 1E 23   			sta	_weapon_level
 9721                        	
 9722                        		.dbg	line,	"include\init.c", 53; armor_level = 1;
 9723                        		__st.umiq	1, _armor_level
         11:C89B  A9 01      			lda.l	#1
         11:C89D  8D 1D 23   			sta	_armor_level
 9724                        	
 9725                        		.dbg	line,	"include\init.c", 55; minutes = 1;
 9726                        		__st.umiq	1, _minutes
         11:C8A0  A9 01      			lda.l	#1
         11:C8A2  8D 22 23   			sta	_minutes
 9727                        	
 9728                        		.dbg	line,	"include\init.c", 56; seconds = 59;
 9729                        		__st.umiq	59, _seconds
         11:C8A5  A9 3B      			lda.l	#59
         11:C8A7  8D 23 23   			sta	_seconds
 9730                        	
 9731                        		.dbg	line,	"include\init.c", 57; time_counter = 0;
 9732                        		__st.umiq	0, _time_counter
         11:C8AA  9C 24 23   			stz	_time_counter
 9733                        	
 9734                        		.dbg	line,	"include\init.c", 59; respawn = FALSE;
 9735                        		__st.umiq	0, _respawn
         11:C8AD  9C 13 23   			stz	_respawn
 9736                        	
 9737                        		.dbg	line,	"include\init.c", 61; sequence_loaded = FALSE;
 9738                        		__st.umiq	0, _sequence_loaded
         11:C8B0  9C 11 23   			stz	_sequence_loaded
 9739                        	
 9740                        		.dbg	line,	"include\init.c", 62; }
 9741    11:C8B3             	.LL427:
 9742                        		__return	0
         11:C8B3  4C EF FF   			jmp	leave_proc
 9743                        		.dbg	clear
 9744                        		.endp
 9745                        		.pceas
 9746                        	
 9747                        		.dbg	line,	"include\init.c", 65; void init_PLAYER()
 9748                        		.dbg	line,	"include\init.c", 66; {
 9749                        	;***********************
 9750                        	;***********************
 9751                        	
 9752                        		.hucc
 9753    11:C97C             		.proc		_init_PLAYER
 9754                        		__enter		_init_PLAYER
 9755                        	
 9756                        		.dbg	line,	"include\init.c", 67; player_id = 2;
 9757                        		__st.umiq	2, _player_id
         11:C97C  A9 02      			lda.l	#2
         11:C97E  8D 14 23   			sta	_player_id
 9758                        	
 9759                        		.dbg	line,	"include\init.c", 68; player_axis = AXIS_RIGHT;
 9760                        		__st.umiq	0, _player_axis
         11:C981  9C 16 23   			stz	_player_axis
 9761                        	
 9762                        		.dbg	line,	"include\init.c", 69; player_previous_axis = player_axis;
 9763                        		__ld.um		_player_axis
         11:C984  AD 16 23   			lda	_player_axis
         11:C987  C2         			cly
 9764                        		__st.umq	_player_previous_axis
         11:C988  8D 17 23   			sta	_player_previous_axis
 9765                        	
 9766                        		.dbg	line,	"include\init.c", 70; player_counter_anim = 0;
 9767                        		__st.umiq	0, _player_counter_anim
         11:C98B  9C 18 23   			stz	_player_counter_anim
 9768                        	
 9769                        		.dbg	line,	"include\init.c", 71; player_index_jump = 0;
 9770                        		__st.umiq	0, _player_index_jump
         11:C98E  9C 19 23   			stz	_player_index_jump
 9771                        	
 9772                        		.dbg	line,	"include\init.c", 72; player_index_fall = 0;
 9773                        		__st.umiq	0, _player_index_fall
         11:C991  9C 1A 23   			stz	_player_index_fall
 9774                        	
 9775                        		.dbg	line,	"include\init.c", 73; player_state = STATE_IDLE;
 9776                        		__st.umiq	0, _player_state
         11:C994  9C 15 23   			stz	_player_state
 9777                        	
 9778                        		.dbg	line,	"include\init.c", 74; }
 9779    11:C997             	.LL428:
 9780                        		__return	0
         11:C997  4C EF FF   			jmp	leave_proc
 9781                        		.dbg	clear
 9782                        		.endp
 9783                        		.pceas
 9784                        	
 9785                        		.dbg	line,	"include\init.c", 81; void load_OBJECT_TILES()
 9786                        		.dbg	line,	"include\init.c", 82; {
 9787                        	;***********************
 9788                        	;***********************
 9789                        	
 9790                        		.hucc
 9791    02:CE82             		.proc		_load_OBJECT_TILES
 9792                        		__enter		_load_OBJECT_TILES
 9793                        	
 9794                        		.dbg	line,	"include\init.c", 83; load_vram(POT1_VRAM_ADR, tiles_SPR_POT , SIZEOF(tiles_SPR_POT) >> 1);
 9795                        		__st.wmiq	7168, _di
         02:CE82  64 F0      			stz.l	_di
         02:CE84  A9 1C      			lda.h	#7168
         02:CE86  85 F1      			sta.h	_di
 9796                        		__farptr	_tiles_SPR_POT, _bp_bank, _bp
         02:CE88  A9 60      			lda.l	#$6000 + ($1FFF & (_tiles_SPR_POT))
         02:CE8A  85 EC      			sta.l	_bp
         02:CE8C  A9 7F      			lda.h	#$6000 + ($1FFF & (_tiles_SPR_POT))
         02:CE8E  85 ED      			sta.h	_bp
         02:CE90  A9 0F      			lda	#bank(_tiles_SPR_POT)
         02:CE92  85 02      			sta	_bp_bank
 9797                        		__ld.wi		___sizeof__tiles_SPR_POT
         02:CE94  A9 00      			lda.l	#___sizeof__tiles_SPR_POT
         02:CE96  A0 04      			ldy.h	#___sizeof__tiles_SPR_POT
 9798                        		__lsr.wi	1
         02:CE98  42         			say
         02:CE99  4A         			lsr	a
         02:CE9A  42         			say
         02:CE9B  6A         			ror	a
 9799                        		__st.wmq	_ax
         02:CE9C  85 F8      			sta.l	_ax
         02:CE9E  84 F9      			sty.h	_ax
 9800                        		 _load_vram.3
         02:CEA0  82         			clx				; Offset to PCE VDC.
         02:CEA1  20 63 FF   			call	load_vram_x
 9801                        	
 9802                        		.dbg	line,	"include\init.c", 84; load_vram(POW_VRAM_ADR, tiles_SPR_POW , TILES_4);
 9803                        		__st.wmiq	7680, _di
         02:CEA4  64 F0      			stz.l	_di
         02:CEA6  A9 1E      			lda.h	#7680
         02:CEA8  85 F1      			sta.h	_di
 9804                        		__farptr	_tiles_SPR_POW, _bp_bank, _bp
         02:CEAA  A9 60      			lda.l	#$6000 + ($1FFF & (_tiles_SPR_POW))
         02:CEAC  85 EC      			sta.l	_bp
         02:CEAE  A9 63      			lda.h	#$6000 + ($1FFF & (_tiles_SPR_POW))
         02:CEB0  85 ED      			sta.h	_bp
         02:CEB2  A9 10      			lda	#bank(_tiles_SPR_POW)
         02:CEB4  85 02      			sta	_bp_bank
 9805                        		__st.wmiq	64, _ax
         02:CEB6  A9 40      			lda.l	#64
         02:CEB8  85 F8      			sta.l	_ax
         02:CEBA  64 F9      			stz.h	_ax
 9806                        		 _load_vram.3
         02:CEBC  82         			clx				; Offset to PCE VDC.
         02:CEBD  20 63 FF   			call	load_vram_x
 9807                        	
 9808                        		.dbg	line,	"include\init.c", 85; load_vram(GRAY_KEY_VRAM_ADR, tiles_SPR_GRAY_KEY , TILES_4);
 9809                        		__st.wmiq	7744, _di
         02:CEC0  A9 40      			lda.l	#7744
         02:CEC2  85 F0      			sta.l	_di
         02:CEC4  A9 1E      			lda.h	#7744
         02:CEC6  85 F1      			sta.h	_di
 9810                        		__farptr	_tiles_SPR_GRAY_KEY, _bp_bank, _bp
         02:CEC8  A9 E0      			lda.l	#$6000 + ($1FFF & (_tiles_SPR_GRAY_KEY))
         02:CECA  85 EC      			sta.l	_bp
         02:CECC  A9 7C      			lda.h	#$6000 + ($1FFF & (_tiles_SPR_GRAY_KEY))
         02:CECE  85 ED      			sta.h	_bp
         02:CED0  A9 0F      			lda	#bank(_tiles_SPR_GRAY_KEY)
         02:CED2  85 02      			sta	_bp_bank
 9811                        		__st.wmiq	64, _ax
         02:CED4  A9 40      			lda.l	#64
         02:CED6  85 F8      			sta.l	_ax
         02:CED8  64 F9      			stz.h	_ax
 9812                        		 _load_vram.3
         02:CEDA  82         			clx				; Offset to PCE VDC.
         02:CEDB  20 63 FF   			call	load_vram_x
 9813                        	
 9814                        		.dbg	line,	"include\init.c", 86; load_vram(GOLD_KEY_VRAM_ADR, tiles_SPR_GOLD_KEY , TILES_4);
 9815                        		__st.wmiq	7808, _di
         02:CEDE  A9 80      			lda.l	#7808
         02:CEE0  85 F0      			sta.l	_di
         02:CEE2  A9 1E      			lda.h	#7808
         02:CEE4  85 F1      			sta.h	_di
 9816                        		__farptr	_tiles_SPR_GOLD_KEY, _bp_bank, _bp
         02:CEE6  A9 60      			lda.l	#$6000 + ($1FFF & (_tiles_SPR_GOLD_KEY))
         02:CEE8  85 EC      			sta.l	_bp
         02:CEEA  A9 7D      			lda.h	#$6000 + ($1FFF & (_tiles_SPR_GOLD_KEY))
         02:CEEC  85 ED      			sta.h	_bp
         02:CEEE  A9 0F      			lda	#bank(_tiles_SPR_GOLD_KEY)
         02:CEF0  85 02      			sta	_bp_bank
 9817                        		__st.wmiq	64, _ax
         02:CEF2  A9 40      			lda.l	#64
         02:CEF4  85 F8      			sta.l	_ax
         02:CEF6  64 F9      			stz.h	_ax
 9818                        		 _load_vram.3
         02:CEF8  82         			clx				; Offset to PCE VDC.
         02:CEF9  20 63 FF   			call	load_vram_x
 9819                        	
 9820                        		.dbg	line,	"include\init.c", 87; load_vram(LIFE_VRAM_ADR, tiles_SPR_LIFE , TILES_4);
 9821                        		__st.wmiq	7872, _di
         02:CEFC  A9 C0      			lda.l	#7872
         02:CEFE  85 F0      			sta.l	_di
         02:CF00  A9 1E      			lda.h	#7872
         02:CF02  85 F1      			sta.h	_di
 9822                        		__farptr	_tiles_SPR_LIFE, _bp_bank, _bp
         02:CF04  A9 60      			lda.l	#$6000 + ($1FFF & (_tiles_SPR_LIFE))
         02:CF06  85 EC      			sta.l	_bp
         02:CF08  A9 7E      			lda.h	#$6000 + ($1FFF & (_tiles_SPR_LIFE))
         02:CF0A  85 ED      			sta.h	_bp
         02:CF0C  A9 0F      			lda	#bank(_tiles_SPR_LIFE)
         02:CF0E  85 02      			sta	_bp_bank
 9823                        		__st.wmiq	64, _ax
         02:CF10  A9 40      			lda.l	#64
         02:CF12  85 F8      			sta.l	_ax
         02:CF14  64 F9      			stz.h	_ax
 9824                        		 _load_vram.3
         02:CF16  82         			clx				; Offset to PCE VDC.
         02:CF17  20 63 FF   			call	load_vram_x
 9825                        	
 9826                        		.dbg	line,	"include\init.c", 88; load_vram(COIN_1_VRAM_ADR, tiles_SPR_COIN_1 , TILES_4);
 9827                        		__st.wmiq	7936, _di
         02:CF1A  64 F0      			stz.l	_di
         02:CF1C  A9 1F      			lda.h	#7936
         02:CF1E  85 F1      			sta.h	_di
 9828                        		__farptr	_tiles_SPR_COIN_1, _bp_bank, _bp
         02:CF20  A9 E0      			lda.l	#$6000 + ($1FFF & (_tiles_SPR_COIN_1))
         02:CF22  85 EC      			sta.l	_bp
         02:CF24  A9 78      			lda.h	#$6000 + ($1FFF & (_tiles_SPR_COIN_1))
         02:CF26  85 ED      			sta.h	_bp
         02:CF28  A9 0F      			lda	#bank(_tiles_SPR_COIN_1)
         02:CF2A  85 02      			sta	_bp_bank
 9829                        		__st.wmiq	64, _ax
         02:CF2C  A9 40      			lda.l	#64
         02:CF2E  85 F8      			sta.l	_ax
         02:CF30  64 F9      			stz.h	_ax
 9830                        		 _load_vram.3
         02:CF32  82         			clx				; Offset to PCE VDC.
         02:CF33  20 63 FF   			call	load_vram_x
 9831                        	
 9832                        		.dbg	line,	"include\init.c", 89; load_vram(COIN_5_VRAM_ADR, tiles_SPR_COIN_5 , TILES_4);
 9833                        		__st.wmiq	8000, _di
         02:CF36  A9 40      			lda.l	#8000
         02:CF38  85 F0      			sta.l	_di
         02:CF3A  A9 1F      			lda.h	#8000
         02:CF3C  85 F1      			sta.h	_di
 9834                        		__farptr	_tiles_SPR_COIN_5, _bp_bank, _bp
         02:CF3E  A9 60      			lda.l	#$6000 + ($1FFF & (_tiles_SPR_COIN_5))
         02:CF40  85 EC      			sta.l	_bp
         02:CF42  A9 79      			lda.h	#$6000 + ($1FFF & (_tiles_SPR_COIN_5))
         02:CF44  85 ED      			sta.h	_bp
         02:CF46  A9 0F      			lda	#bank(_tiles_SPR_COIN_5)
         02:CF48  85 02      			sta	_bp_bank
 9835                        		__st.wmiq	64, _ax
         02:CF4A  A9 40      			lda.l	#64
         02:CF4C  85 F8      			sta.l	_ax
         02:CF4E  64 F9      			stz.h	_ax
 9836                        		 _load_vram.3
         02:CF50  82         			clx				; Offset to PCE VDC.
         02:CF51  20 63 FF   			call	load_vram_x
 9837                        	
 9838                        		.dbg	line,	"include\init.c", 90; load_vram(COIN_10_VRAM_ADR, tiles_SPR_COIN_10 , TILES_4);
 9839                        		__st.wmiq	8064, _di
         02:CF54  A9 80      			lda.l	#8064
         02:CF56  85 F0      			sta.l	_di
         02:CF58  A9 1F      			lda.h	#8064
         02:CF5A  85 F1      			sta.h	_di
 9840                        		__farptr	_tiles_SPR_COIN_10, _bp_bank, _bp
         02:CF5C  A9 E0      			lda.l	#$6000 + ($1FFF & (_tiles_SPR_COIN_10))
         02:CF5E  85 EC      			sta.l	_bp
         02:CF60  A9 79      			lda.h	#$6000 + ($1FFF & (_tiles_SPR_COIN_10))
         02:CF62  85 ED      			sta.h	_bp
         02:CF64  A9 0F      			lda	#bank(_tiles_SPR_COIN_10)
         02:CF66  85 02      			sta	_bp_bank
 9841                        		__st.wmiq	64, _ax
         02:CF68  A9 40      			lda.l	#64
         02:CF6A  85 F8      			sta.l	_ax
         02:CF6C  64 F9      			stz.h	_ax
 9842                        		 _load_vram.3
         02:CF6E  82         			clx				; Offset to PCE VDC.
         02:CF6F  20 63 FF   			call	load_vram_x
 9843                        	
 9844                        		.dbg	line,	"include\init.c", 91; load_vram(COIN_50_VRAM_ADR, tiles_SPR_COIN_50 , TILES_4);
 9845                        		__st.wmiq	8128, _di
         02:CF72  A9 C0      			lda.l	#8128
         02:CF74  85 F0      			sta.l	_di
         02:CF76  A9 1F      			lda.h	#8128
         02:CF78  85 F1      			sta.h	_di
 9846                        		__farptr	_tiles_SPR_COIN_50, _bp_bank, _bp
         02:CF7A  A9 60      			lda.l	#$6000 + ($1FFF & (_tiles_SPR_COIN_50))
         02:CF7C  85 EC      			sta.l	_bp
         02:CF7E  A9 7A      			lda.h	#$6000 + ($1FFF & (_tiles_SPR_COIN_50))
         02:CF80  85 ED      			sta.h	_bp
         02:CF82  A9 0F      			lda	#bank(_tiles_SPR_COIN_50)
         02:CF84  85 02      			sta	_bp_bank
 9847                        		__st.wmiq	64, _ax
         02:CF86  A9 40      			lda.l	#64
         02:CF88  85 F8      			sta.l	_ax
         02:CF8A  64 F9      			stz.h	_ax
 9848                        		 _load_vram.3
         02:CF8C  82         			clx				; Offset to PCE VDC.
         02:CF8D  20 63 FF   			call	load_vram_x
 9849                        	
 9850                        		.dbg	line,	"include\init.c", 92; load_vram(COIN_100_VRAM_ADR, tiles_SPR_COIN_100 , TILES_4);
 9851                        		__st.wmiq	8192, _di
         02:CF90  64 F0      			stz.l	_di
         02:CF92  A9 20      			lda.h	#8192
         02:CF94  85 F1      			sta.h	_di
 9852                        		__farptr	_tiles_SPR_COIN_100, _bp_bank, _bp
         02:CF96  A9 E0      			lda.l	#$6000 + ($1FFF & (_tiles_SPR_COIN_100))
         02:CF98  85 EC      			sta.l	_bp
         02:CF9A  A9 7A      			lda.h	#$6000 + ($1FFF & (_tiles_SPR_COIN_100))
         02:CF9C  85 ED      			sta.h	_bp
         02:CF9E  A9 0F      			lda	#bank(_tiles_SPR_COIN_100)
         02:CFA0  85 02      			sta	_bp_bank
 9853                        		__st.wmiq	64, _ax
         02:CFA2  A9 40      			lda.l	#64
         02:CFA4  85 F8      			sta.l	_ax
         02:CFA6  64 F9      			stz.h	_ax
 9854                        		 _load_vram.3
         02:CFA8  82         			clx				; Offset to PCE VDC.
         02:CFA9  20 63 FF   			call	load_vram_x
 9855                        	
 9856                        		.dbg	line,	"include\init.c", 93; load_vram(COIN_500_VRAM_ADR, tiles_SPR_COIN_500 , TILES_4);
 9857                        		__st.wmiq	8256, _di
         02:CFAC  A9 40      			lda.l	#8256
         02:CFAE  85 F0      			sta.l	_di
         02:CFB0  A9 20      			lda.h	#8256
         02:CFB2  85 F1      			sta.h	_di
 9858                        		__farptr	_tiles_SPR_COIN_500, _bp_bank, _bp
         02:CFB4  A9 60      			lda.l	#$6000 + ($1FFF & (_tiles_SPR_COIN_500))
         02:CFB6  85 EC      			sta.l	_bp
         02:CFB8  A9 7B      			lda.h	#$6000 + ($1FFF & (_tiles_SPR_COIN_500))
         02:CFBA  85 ED      			sta.h	_bp
         02:CFBC  A9 0F      			lda	#bank(_tiles_SPR_COIN_500)
         02:CFBE  85 02      			sta	_bp_bank
 9859                        		__st.wmiq	64, _ax
         02:CFC0  A9 40      			lda.l	#64
         02:CFC2  85 F8      			sta.l	_ax
         02:CFC4  64 F9      			stz.h	_ax
 9860                        		 _load_vram.3
         02:CFC6  82         			clx				; Offset to PCE VDC.
         02:CFC7  20 63 FF   			call	load_vram_x
 9861                        	
 9862                        		.dbg	line,	"include\init.c", 94; load_vram(COIN_1000_VRAM_ADR, tiles_SPR_COIN_1000 , TILES_4);
 9863                        		__st.wmiq	8320, _di
         02:CFCA  A9 80      			lda.l	#8320
         02:CFCC  85 F0      			sta.l	_di
         02:CFCE  A9 20      			lda.h	#8320
         02:CFD0  85 F1      			sta.h	_di
 9864                        		__farptr	_tiles_SPR_COIN_1000, _bp_bank, _bp
         02:CFD2  A9 E0      			lda.l	#$6000 + ($1FFF & (_tiles_SPR_COIN_1000))
         02:CFD4  85 EC      			sta.l	_bp
         02:CFD6  A9 7B      			lda.h	#$6000 + ($1FFF & (_tiles_SPR_COIN_1000))
         02:CFD8  85 ED      			sta.h	_bp
         02:CFDA  A9 0F      			lda	#bank(_tiles_SPR_COIN_1000)
         02:CFDC  85 02      			sta	_bp_bank
 9865                        		__st.wmiq	64, _ax
         02:CFDE  A9 40      			lda.l	#64
         02:CFE0  85 F8      			sta.l	_ax
         02:CFE2  64 F9      			stz.h	_ax
 9866                        		 _load_vram.3
         02:CFE4  82         			clx				; Offset to PCE VDC.
         02:CFE5  20 63 FF   			call	load_vram_x
 9867                        	
 9868                        		.dbg	line,	"include\init.c", 95; load_vram(STAR_VRAM_ADR, tiles_SPR_STAR , TILES_4);
 9869                        		__st.wmiq	8384, _di
         02:CFE8  A9 C0      			lda.l	#8384
         02:CFEA  85 F0      			sta.l	_di
         02:CFEC  A9 20      			lda.h	#8384
         02:CFEE  85 F1      			sta.h	_di
 9870                        		__farptr	_tiles_SPR_STAR, _bp_bank, _bp
         02:CFF0  A9 E0      			lda.l	#$6000 + ($1FFF & (_tiles_SPR_STAR))
         02:CFF2  85 EC      			sta.l	_bp
         02:CFF4  A9 63      			lda.h	#$6000 + ($1FFF & (_tiles_SPR_STAR))
         02:CFF6  85 ED      			sta.h	_bp
         02:CFF8  A9 10      			lda	#bank(_tiles_SPR_STAR)
         02:CFFA  85 02      			sta	_bp_bank
 9871                        		__st.wmiq	64, _ax
         02:CFFC  A9 40      			lda.l	#64
         02:CFFE  85 F8      			sta.l	_ax
         02:D000  64 F9      			stz.h	_ax
 9872                        		 _load_vram.3
         02:D002  82         			clx				; Offset to PCE VDC.
         02:D003  20 63 FF   			call	load_vram_x
 9873                        	
 9874                        		.dbg	line,	"include\init.c", 96; load_vram(OCTOPUS_VRAM_ADR, tiles_SPR_OCTOPUS , TILES_4);
 9875                        		__st.wmiq	8448, _di
         02:D006  64 F0      			stz.l	_di
         02:D008  A9 21      			lda.h	#8448
         02:D00A  85 F1      			sta.h	_di
 9876                        		__farptr	_tiles_SPR_OCTOPUS, _bp_bank, _bp
         02:D00C  A9 E0      			lda.l	#$6000 + ($1FFF & (_tiles_SPR_OCTOPUS))
         02:D00E  85 EC      			sta.l	_bp
         02:D010  A9 7E      			lda.h	#$6000 + ($1FFF & (_tiles_SPR_OCTOPUS))
         02:D012  85 ED      			sta.h	_bp
         02:D014  A9 0F      			lda	#bank(_tiles_SPR_OCTOPUS)
         02:D016  85 02      			sta	_bp_bank
 9877                        		__st.wmiq	64, _ax
         02:D018  A9 40      			lda.l	#64
         02:D01A  85 F8      			sta.l	_ax
         02:D01C  64 F9      			stz.h	_ax
 9878                        		 _load_vram.3
         02:D01E  82         			clx				; Offset to PCE VDC.
         02:D01F  20 63 FF   			call	load_vram_x
 9879                        	
 9880                        		.dbg	line,	"include\init.c", 97; load_vram(FRUIT_VRAM_ADR, tiles_SPR_FRUIT , TILES_4);
 9881                        		__st.wmiq	8512, _di
         02:D022  A9 40      			lda.l	#8512
         02:D024  85 F0      			sta.l	_di
         02:D026  A9 21      			lda.h	#8512
         02:D028  85 F1      			sta.h	_di
 9882                        		__farptr	_tiles_SPR_FRUIT, _bp_bank, _bp
         02:D02A  A9 60      			lda.l	#$6000 + ($1FFF & (_tiles_SPR_FRUIT))
         02:D02C  85 EC      			sta.l	_bp
         02:D02E  A9 7C      			lda.h	#$6000 + ($1FFF & (_tiles_SPR_FRUIT))
         02:D030  85 ED      			sta.h	_bp
         02:D032  A9 0F      			lda	#bank(_tiles_SPR_FRUIT)
         02:D034  85 02      			sta	_bp_bank
 9883                        		__st.wmiq	64, _ax
         02:D036  A9 40      			lda.l	#64
         02:D038  85 F8      			sta.l	_ax
         02:D03A  64 F9      			stz.h	_ax
 9884                        		 _load_vram.3
         02:D03C  82         			clx				; Offset to PCE VDC.
         02:D03D  20 63 FF   			call	load_vram_x
 9885                        	
 9886                        		.dbg	line,	"include\init.c", 98; load_vram(BARREL_VRAM_ADR, tiles_SPR_BARREL , TILES_4);
 9887                        		__st.wmiq	8576, _di
         02:D040  A9 80      			lda.l	#8576
         02:D042  85 F0      			sta.l	_di
         02:D044  A9 21      			lda.h	#8576
         02:D046  85 F1      			sta.h	_di
 9888                        		__farptr	_tiles_SPR_BARREL, _bp_bank, _bp
         02:D048  A9 60      			lda.l	#$6000 + ($1FFF & (_tiles_SPR_BARREL))
         02:D04A  85 EC      			sta.l	_bp
         02:D04C  A9 6C      			lda.h	#$6000 + ($1FFF & (_tiles_SPR_BARREL))
         02:D04E  85 ED      			sta.h	_bp
         02:D050  A9 0F      			lda	#bank(_tiles_SPR_BARREL)
         02:D052  85 02      			sta	_bp_bank
 9889                        		__st.wmiq	64, _ax
         02:D054  A9 40      			lda.l	#64
         02:D056  85 F8      			sta.l	_ax
         02:D058  64 F9      			stz.h	_ax
 9890                        		 _load_vram.3
         02:D05A  82         			clx				; Offset to PCE VDC.
         02:D05B  20 63 FF   			call	load_vram_x
 9891                        	
 9892                        		.dbg	line,	"include\init.c", 99; load_vram(HOURGLASS_VRAM_ADR, tiles_SPR_HOURGLASS , TILES_4);
 9893                        		__st.wmiq	8640, _di
         02:D05E  A9 C0      			lda.l	#8640
         02:D060  85 F0      			sta.l	_di
         02:D062  A9 21      			lda.h	#8640
         02:D064  85 F1      			sta.h	_di
 9894                        		__farptr	_tiles_SPR_HOURGLASS, _bp_bank, _bp
         02:D066  A9 E0      			lda.l	#$6000 + ($1FFF & (_tiles_SPR_HOURGLASS))
         02:D068  85 EC      			sta.l	_bp
         02:D06A  A9 7D      			lda.h	#$6000 + ($1FFF & (_tiles_SPR_HOURGLASS))
         02:D06C  85 ED      			sta.h	_bp
         02:D06E  A9 0F      			lda	#bank(_tiles_SPR_HOURGLASS)
         02:D070  85 02      			sta	_bp_bank
 9895                        		__st.wmiq	64, _ax
         02:D072  A9 40      			lda.l	#64
         02:D074  85 F8      			sta.l	_ax
         02:D076  64 F9      			stz.h	_ax
 9896                        		 _load_vram.3
         02:D078  82         			clx				; Offset to PCE VDC.
         02:D079  20 63 FF   			call	load_vram_x
 9897                        	
 9898                        		.dbg	line,	"include\init.c", 100; load_vram(BAMBOO_VRAM_ADR, tiles_SPR_BAMBOO , TILES_4);
 9899                        		__st.wmiq	8704, _di
         02:D07C  64 F0      			stz.l	_di
         02:D07E  A9 22      			lda.h	#8704
         02:D080  85 F1      			sta.h	_di
 9900                        		__farptr	_tiles_SPR_BAMBOO, _bp_bank, _bp
         02:D082  A9 60      			lda.l	#$6000 + ($1FFF & (_tiles_SPR_BAMBOO))
         02:D084  85 EC      			sta.l	_bp
         02:D086  A9 64      			lda.h	#$6000 + ($1FFF & (_tiles_SPR_BAMBOO))
         02:D088  85 ED      			sta.h	_bp
         02:D08A  A9 10      			lda	#bank(_tiles_SPR_BAMBOO)
         02:D08C  85 02      			sta	_bp_bank
 9901                        		__st.wmiq	64, _ax
         02:D08E  A9 40      			lda.l	#64
         02:D090  85 F8      			sta.l	_ax
         02:D092  64 F9      			stz.h	_ax
 9902                        		 _load_vram.3
         02:D094  82         			clx				; Offset to PCE VDC.
         02:D095  20 63 FF   			call	load_vram_x
 9903                        	
 9904                        		.dbg	line,	"include\init.c", 101; load_vram(YASHICHI_VRAM_ADR, tiles_SPR_YASHICHI , TILES_4);
 9905                        		__st.wmiq	8768, _di
         02:D098  A9 40      			lda.l	#8768
         02:D09A  85 F0      			sta.l	_di
         02:D09C  A9 22      			lda.h	#8768
         02:D09E  85 F1      			sta.h	_di
 9906                        		__farptr	_tiles_SPR_YASHICHI, _bp_bank, _bp
         02:D0A0  A9 E0      			lda.l	#$6000 + ($1FFF & (_tiles_SPR_YASHICHI))
         02:D0A2  85 EC      			sta.l	_bp
         02:D0A4  A9 64      			lda.h	#$6000 + ($1FFF & (_tiles_SPR_YASHICHI))
         02:D0A6  85 ED      			sta.h	_bp
         02:D0A8  A9 10      			lda	#bank(_tiles_SPR_YASHICHI)
         02:D0AA  85 02      			sta	_bp_bank
 9907                        		__st.wmiq	64, _ax
         02:D0AC  A9 40      			lda.l	#64
         02:D0AE  85 F8      			sta.l	_ax
         02:D0B0  64 F9      			stz.h	_ax
 9908                        		 _load_vram.3
         02:D0B2  82         			clx				; Offset to PCE VDC.
         02:D0B3  20 63 FF   			call	load_vram_x
 9909                        	
 9910                        		.dbg	line,	"include\init.c", 102; load_vram(ELEPHANT_VRAM_ADR, tiles_SPR_ELEPHANT , TILES_4);
 9911                        		__st.wmiq	8832, _di
         02:D0B6  A9 80      			lda.l	#8832
         02:D0B8  85 F0      			sta.l	_di
         02:D0BA  A9 22      			lda.h	#8832
         02:D0BC  85 F1      			sta.h	_di
 9912                        		__farptr	_tiles_SPR_ELEPHANT, _bp_bank, _bp
         02:D0BE  A9 60      			lda.l	#$6000 + ($1FFF & (_tiles_SPR_ELEPHANT))
         02:D0C0  85 EC      			sta.l	_bp
         02:D0C2  A9 65      			lda.h	#$6000 + ($1FFF & (_tiles_SPR_ELEPHANT))
         02:D0C4  85 ED      			sta.h	_bp
         02:D0C6  A9 10      			lda	#bank(_tiles_SPR_ELEPHANT)
         02:D0C8  85 02      			sta	_bp_bank
 9913                        		__st.wmiq	64, _ax
         02:D0CA  A9 40      			lda.l	#64
         02:D0CC  85 F8      			sta.l	_ax
         02:D0CE  64 F9      			stz.h	_ax
 9914                        		 _load_vram.3
         02:D0D0  82         			clx				; Offset to PCE VDC.
         02:D0D1  20 63 FF   			call	load_vram_x
 9915                        	
 9916                        		.dbg	line,	"include\init.c", 103; load_vram(DRAGONFLY_VRAM_ADR, tiles_SPR_DRAGONFLY , TILES_4);
 9917                        		__st.wmiq	8896, _di
         02:D0D4  A9 C0      			lda.l	#8896
         02:D0D6  85 F0      			sta.l	_di
         02:D0D8  A9 22      			lda.h	#8896
         02:D0DA  85 F1      			sta.h	_di
 9918                        		__farptr	_tiles_SPR_DRAGONFLY, _bp_bank, _bp
         02:D0DC  A9 E0      			lda.l	#$6000 + ($1FFF & (_tiles_SPR_DRAGONFLY))
         02:D0DE  85 EC      			sta.l	_bp
         02:D0E0  A9 65      			lda.h	#$6000 + ($1FFF & (_tiles_SPR_DRAGONFLY))
         02:D0E2  85 ED      			sta.h	_bp
         02:D0E4  A9 10      			lda	#bank(_tiles_SPR_DRAGONFLY)
         02:D0E6  85 02      			sta	_bp_bank
 9919                        		__st.wmiq	64, _ax
         02:D0E8  A9 40      			lda.l	#64
         02:D0EA  85 F8      			sta.l	_ax
         02:D0EC  64 F9      			stz.h	_ax
 9920                        		 _load_vram.3
         02:D0EE  82         			clx				; Offset to PCE VDC.
         02:D0EF  20 63 FF   			call	load_vram_x
 9921                        	
 9922                        		.dbg	line,	"include\init.c", 104; load_vram(COW_VRAM_ADR, tiles_SPR_COW , TILES_4);
 9923                        		__st.wmiq	8960, _di
         02:D0F2  64 F0      			stz.l	_di
         02:D0F4  A9 23      			lda.h	#8960
         02:D0F6  85 F1      			sta.h	_di
 9924                        		__farptr	_tiles_SPR_COW, _bp_bank, _bp
         02:D0F8  A9 60      			lda.l	#$6000 + ($1FFF & (_tiles_SPR_COW))
         02:D0FA  85 EC      			sta.l	_bp
         02:D0FC  A9 66      			lda.h	#$6000 + ($1FFF & (_tiles_SPR_COW))
         02:D0FE  85 ED      			sta.h	_bp
         02:D100  A9 10      			lda	#bank(_tiles_SPR_COW)
         02:D102  85 02      			sta	_bp_bank
 9925                        		__st.wmiq	64, _ax
         02:D104  A9 40      			lda.l	#64
         02:D106  85 F8      			sta.l	_ax
         02:D108  64 F9      			stz.h	_ax
 9926                        		 _load_vram.3
         02:D10A  82         			clx				; Offset to PCE VDC.
         02:D10B  20 63 FF   			call	load_vram_x
 9927                        	
 9928                        		.dbg	line,	"include\init.c", 105; load_vram(MOBICHAN_VRAM_ADR, tiles_SPR_MOBICHAN , TILES_4);
 9929                        		__st.wmiq	9024, _di
         02:D10E  A9 40      			lda.l	#9024
         02:D110  85 F0      			sta.l	_di
         02:D112  A9 23      			lda.h	#9024
         02:D114  85 F1      			sta.h	_di
 9930                        		__farptr	_tiles_SPR_MOBICHAN, _bp_bank, _bp
         02:D116  A9 E0      			lda.l	#$6000 + ($1FFF & (_tiles_SPR_MOBICHAN))
         02:D118  85 EC      			sta.l	_bp
         02:D11A  A9 66      			lda.h	#$6000 + ($1FFF & (_tiles_SPR_MOBICHAN))
         02:D11C  85 ED      			sta.h	_bp
         02:D11E  A9 10      			lda	#bank(_tiles_SPR_MOBICHAN)
         02:D120  85 02      			sta	_bp_bank
 9931                        		__st.wmiq	64, _ax
         02:D122  A9 40      			lda.l	#64
         02:D124  85 F8      			sta.l	_ax
         02:D126  64 F9      			stz.h	_ax
 9932                        		 _load_vram.3
         02:D128  82         			clx				; Offset to PCE VDC.
         02:D129  20 63 FF   			call	load_vram_x
 9933                        	
 9934                        		.dbg	line,	"include\init.c", 106; }
 9935    02:D12C             	.LL429:
 9936                        		__return	0
         02:D12C  4C EF FF   			jmp	leave_proc
 9937                        		.dbg	clear
 9938                        		.endp
 9939                        		.pceas
 9940                        	
 9941                        		.dbg	line,	"include\init.c", 109; void load_CHEST_TILES()
 9942                        		.dbg	line,	"include\init.c", 110; {
 9943                        	;***********************
 9944                        	;***********************
 9945                        	
 9946                        		.hucc
 9947    11:C90F             		.proc		_load_CHEST_TILES
 9948                        		__enter		_load_CHEST_TILES
 9949                        	
 9950                        		.dbg	line,	"include\init.c", 111; load_vram(CHEST_VRAM_ADR, tiles_SPR_CHEST , SIZEOF(tiles_SPR_CHEST) >> 1);
 9951                        		__st.wmiq	9216, _di
         11:C90F  64 F0      			stz.l	_di
         11:C911  A9 24      			lda.h	#9216
         11:C913  85 F1      			sta.h	_di
 9952                        		__farptr	_tiles_SPR_CHEST, _bp_bank, _bp
         11:C915  A9 E0      			lda.l	#$6000 + ($1FFF & (_tiles_SPR_CHEST))
         11:C917  85 EC      			sta.l	_bp
         11:C919  A9 6C      			lda.h	#$6000 + ($1FFF & (_tiles_SPR_CHEST))
         11:C91B  85 ED      			sta.h	_bp
         11:C91D  A9 0F      			lda	#bank(_tiles_SPR_CHEST)
         11:C91F  85 02      			sta	_bp_bank
 9953                        		__ld.wi		___sizeof__tiles_SPR_CHEST
         11:C921  A9 00      			lda.l	#___sizeof__tiles_SPR_CHEST
         11:C923  A0 0C      			ldy.h	#___sizeof__tiles_SPR_CHEST
 9954                        		__lsr.wi	1
         11:C925  42         			say
         11:C926  4A         			lsr	a
         11:C927  42         			say
         11:C928  6A         			ror	a
 9955                        		__st.wmq	_ax
         11:C929  85 F8      			sta.l	_ax
         11:C92B  84 F9      			sty.h	_ax
 9956                        		 _load_vram.3
         11:C92D  82         			clx				; Offset to PCE VDC.
         11:C92E  20 63 FF   			call	load_vram_x
 9957                        	
 9958                        		.dbg	line,	"include\init.c", 112; }
 9959    11:C931             	.LL430:
 9960                        		__return	0
         11:C931  4C EF FF   			jmp	leave_proc
 9961                        		.dbg	clear
 9962                        		.endp
 9963                        		.pceas
 9964                        	
 9965                        		.dbg	line,	"include\init.c", 115; void load_NPC_TILES()
 9966                        		.dbg	line,	"include\init.c", 116; {
 9967                        	;***********************
 9968                        	;***********************
 9969                        	
 9970                        		.hucc
 9971    11:C934             		.proc		_load_NPC_TILES
 9972                        		__enter		_load_NPC_TILES
 9973                        	
 9974                        		.dbg	line,	"include\init.c", 117; load_vram(NPC_VRAM_ADR, tiles_SPR_NPC , SIZEOF(tiles_SPR_NPC) >> 1);
 9975                        		__st.wmiq	10752, _di
         11:C934  64 F0      			stz.l	_di
         11:C936  A9 2A      			lda.h	#10752
         11:C938  85 F1      			sta.h	_di
 9976                        		__farptr	_tiles_SPR_NPC, _bp_bank, _bp
         11:C93A  A9 60      			lda.l	#$6000 + ($1FFF & (_tiles_SPR_NPC))
         11:C93C  85 EC      			sta.l	_bp
         11:C93E  A9 6B      			lda.h	#$6000 + ($1FFF & (_tiles_SPR_NPC))
         11:C940  85 ED      			sta.h	_bp
         11:C942  A9 10      			lda	#bank(_tiles_SPR_NPC)
         11:C944  85 02      			sta	_bp_bank
 9977                        		__ld.wi		___sizeof__tiles_SPR_NPC
         11:C946  A9 00      			lda.l	#___sizeof__tiles_SPR_NPC
         11:C948  A0 0C      			ldy.h	#___sizeof__tiles_SPR_NPC
 9978                        		__lsr.wi	1
         11:C94A  42         			say
         11:C94B  4A         			lsr	a
         11:C94C  42         			say
         11:C94D  6A         			ror	a
 9979                        		__st.wmq	_ax
         11:C94E  85 F8      			sta.l	_ax
         11:C950  84 F9      			sty.h	_ax
 9980                        		 _load_vram.3
         11:C952  82         			clx				; Offset to PCE VDC.
         11:C953  20 63 FF   			call	load_vram_x
 9981                        	
 9982                        		.dbg	line,	"include\init.c", 118; }
 9983    11:C956             	.LL431:
 9984                        		__return	0
         11:C956  4C EF FF   			jmp	leave_proc
 9985                        		.dbg	clear
 9986                        		.endp
 9987                        		.pceas
 9988                        	
 9989                        		.dbg	line,	"include\init.c", 121; void init_OBJECT_LV1()
 9990                        		.dbg	line,	"include\init.c", 122; {
 9991                        	;***********************
 9992                        	;***********************
 9993                        	
 9994                        		.hucc
 9995    02:DBA5             		.proc		_init_OBJECT_LV1
 9996                        		__enter		_init_OBJECT_LV1
 9997                        	
 9998                        		.dbg	line,	"include\init.c", 123; signed char i;
 9999                        	
10000                        		.dbg	line,	"include\init.c", 125; for(i=0 ; i<level_object_number ; i++)
10001                        		__st.umiq	0, __init_OBJECT_LV1_end - 1  /* i */
         02:DBA5  9C 3F 26   			stz	__init_OBJECT_LV1_end - 1
10002    02:DBA8             	.LL433:
10003                        		__ld.bm		__init_OBJECT_LV1_end - 1  /* i */
         02:DBA8  AD 3F 26   			lda	__init_OBJECT_LV1_end - 1
         02:DBAB  C2         			cly
         02:DBAC  10 01      			bpl	!+
         02:DBAE  88         			dey
         02:DBAF             	!:
10004                        		__slt_w.um	_level_object_number
         02:DBAF  CD 26 23   			cmp	_level_object_number		; Subtract memory from Y:A.
         02:DBB2  98         			tya
         02:DBB3  E9 00      			sbc	#0
         02:DBB5  50 02      			bvc	!+
         02:DBB7  49 80      			eor	#$80		; -ve if Y:A < memory (signed).
         02:DBB9  0A         	!:		asl	a
10005                        		__btrue		.LL435
         02:DBBA  B0 08      			bcs	.LL435
10006                        		__bra		.LL436
         02:DBBC  4C DF DC   			bra	.LL436
10007    02:DBBF             	.LL434:
10008                        		__inc.umq	__init_OBJECT_LV1_end - 1  /* i */
         02:DBBF  EE 3F 26   			inc	__init_OBJECT_LV1_end - 1
10009                        		__bra		.LL433
         02:DBC2  80 E4      			bra	.LL433
10010    02:DBC4             	.LL435:
10011                        	
10012                        		.dbg	line,	"include\init.c", 126; {
10013                        	
10014                        		.dbg	line,	"include\init.c", 127; // SET OBJECT PROPERTIES //
10015                        	
10016                        		.dbg	line,	"include\init.c", 128; list_object_type[i] = TABLE_OBJECT_TYPE_LV1[i];
10017                        		__ldx.bmq	__init_OBJECT_LV1_end - 1  /* i */
         02:DBC4  AE 3F 26   			ldx	__init_OBJECT_LV1_end - 1
10018                        		__ld.uax	_TABLE_OBJECT_TYPE_LV1
         02:DBC7  BD 27 60   			lda	_TABLE_OBJECT_TYPE_LV1, x
         02:DBCA  C2         			cly
10019                        		__ldx.bmq	__init_OBJECT_LV1_end - 1  /* i */
         02:DBCB  AE 3F 26   			ldx	__init_OBJECT_LV1_end - 1
10020                        		__st.uaxq	_list_object_type
         02:DBCE  9D 28 23   			sta	_list_object_type, x
10021                        	
10022                        		.dbg	line,	"include\init.c", 129; list_object_x_pos_ref[i] = TABLE_OBJECT_X_POS_REF_LV1[i];
10023                        		__ld2x.bmq	__init_OBJECT_LV1_end - 1  /* i */
         02:DBD1  AD 3F 26   			lda	__init_OBJECT_LV1_end - 1
         02:DBD4  0A         			asl	a
         02:DBD5  AA         			tax
10024                        		__ld.wax	_TABLE_OBJECT_X_POS_REF_LV1
         02:DBD6  BD 3E 60   			lda.l	_TABLE_OBJECT_X_POS_REF_LV1, x
         02:DBD9  BC 3F 60   			ldy.h	_TABLE_OBJECT_X_POS_REF_LV1, x
10025                        		__ld2x.bm	__init_OBJECT_LV1_end - 1  /* i */
         02:DBDC  AA         			tax
         02:DBDD  AD 3F 26   			lda	__init_OBJECT_LV1_end - 1
         02:DBE0  0A         			asl	a
         02:DBE1  22         			sax
10026                        		__st.waxq	_list_object_x_pos_ref
         02:DBE2  9D 36 25   			sta.l	_list_object_x_pos_ref, x
         02:DBE5  98         			tya
         02:DBE6  9D 37 25   			sta.h	_list_object_x_pos_ref, x
10027                        	
10028                        		.dbg	line,	"include\init.c", 130; list_object_y_pos_ref[i] = TABLE_OBJECT_Y_POS_REF_LV1[i];
10029                        		__ld2x.bmq	__init_OBJECT_LV1_end - 1  /* i */
         02:DBE9  AD 3F 26   			lda	__init_OBJECT_LV1_end - 1
         02:DBEC  0A         			asl	a
         02:DBED  AA         			tax
10030                        		__ld.wax	_TABLE_OBJECT_Y_POS_REF_LV1
         02:DBEE  BD 6C 60   			lda.l	_TABLE_OBJECT_Y_POS_REF_LV1, x
         02:DBF1  BC 6D 60   			ldy.h	_TABLE_OBJECT_Y_POS_REF_LV1, x
10031                        		__ld2x.bm	__init_OBJECT_LV1_end - 1  /* i */
         02:DBF4  AA         			tax
         02:DBF5  AD 3F 26   			lda	__init_OBJECT_LV1_end - 1
         02:DBF8  0A         			asl	a
         02:DBF9  22         			sax
10032                        		__st.waxq	_list_object_y_pos_ref
         02:DBFA  9D 68 25   			sta.l	_list_object_y_pos_ref, x
         02:DBFD  98         			tya
         02:DBFE  9D 69 25   			sta.h	_list_object_y_pos_ref, x
10033                        	
10034                        		.dbg	line,	"include\init.c", 131; list_object_x_pos[i] = -16;
10035                        		__ld2x.bmq	__init_OBJECT_LV1_end - 1  /* i */
         02:DC01  AD 3F 26   			lda	__init_OBJECT_LV1_end - 1
         02:DC04  0A         			asl	a
         02:DC05  AA         			tax
10036                        		__st.waxiq	-16, _list_object_x_pos
         02:DC06  A9 F0      			lda.l	#-16
         02:DC08  9D D2 24   			sta.l	_list_object_x_pos, x
         02:DC0B  A9 FF      			lda.h	#-16
         02:DC0D  9D D3 24   			sta.h	_list_object_x_pos, x
10037                        	
10038                        		.dbg	line,	"include\init.c", 132; list_object_y_pos[i] = -16;
10039                        		__ld2x.bmq	__init_OBJECT_LV1_end - 1  /* i */
         02:DC10  AD 3F 26   			lda	__init_OBJECT_LV1_end - 1
         02:DC13  0A         			asl	a
         02:DC14  AA         			tax
10040                        		__st.waxiq	-16, _list_object_y_pos
         02:DC15  A9 F0      			lda.l	#-16
         02:DC17  9D 04 25   			sta.l	_list_object_y_pos, x
         02:DC1A  A9 FF      			lda.h	#-16
         02:DC1C  9D 05 25   			sta.h	_list_object_y_pos, x
10041                        	
10042                        		.dbg	line,	"include\init.c", 133; 
10043                        	
10044                        		.dbg	line,	"include\init.c", 134; // IF THE PLAYERS ENTERS THE LEVEL FOR THE 1RST TIME //
10045                        	
10046                        		.dbg	line,	"include\init.c", 135; // ALL OBJECTS ARE ACTIVE //
10047                        	
10048                        		.dbg	line,	"include\init.c", 136; if(respawn == FALSE)
10049                        		__not.um	_respawn
         02:DC1F  AD 13 23   			lda	_respawn
         02:DC22  18         			clc
         02:DC23  D0 01      			bne	!+
         02:DC25  38         			sec
         02:DC26             	!:
10050                        		__bfalse	.LL437
         02:DC26  90 06      			bcc	.LL437
10051                        	
10052                        		.dbg	line,	"include\init.c", 137; {
10053                        	
10054                        		.dbg	line,	"include\init.c", 138; list_object_state[i] = STATE_ACTIVE;
10055                        		__ldx.bmq	__init_OBJECT_LV1_end - 1  /* i */
         02:DC28  AE 3F 26   			ldx	__init_OBJECT_LV1_end - 1
10056                        		__st.uaxiq	0, _list_object_state
         02:DC2B  9E 41 23   			stz	_list_object_state, x
10057                        	
10058                        		.dbg	line,	"include\init.c", 139; }
10059                        	
10060                        		.dbg	line,	"include\init.c", 142; // SET OBJECT SPRITE //
10061                        	
10062                        		.dbg	line,	"include\init.c", 143; spr_set(i + object_start_index);
10063    02:DC2E             	.LL437:
10064                        		__ld.bm		__init_OBJECT_LV1_end - 1  /* i */
         02:DC2E  AD 3F 26   			lda	__init_OBJECT_LV1_end - 1
         02:DC31  C2         			cly
         02:DC32  10 01      			bpl	!+
         02:DC34  88         			dey
         02:DC35             	!:
10065                        		__add.um	_object_start_index
         02:DC35  18         			clc
         02:DC36  6D 25 23   			adc	_object_start_index
         02:DC39  90 01      			bcc	!+
         02:DC3B  C8         			iny
         02:DC3C             	!:
10066                        		__call		_spr_set.1
         02:DC3C  20 DD E7   			call	_spr_set.1
10067                        	
10068                        		.dbg	line,	"include\init.c", 144; spr_x(list_object_x_pos[i]);
10069                        		__ld2x.bmq	__init_OBJECT_LV1_end - 1  /* i */
         02:DC3F  AD 3F 26   			lda	__init_OBJECT_LV1_end - 1
         02:DC42  0A         			asl	a
         02:DC43  AA         			tax
10070                        		__ld.wax	_list_object_x_pos
         02:DC44  BD D2 24   			lda.l	_list_object_x_pos, x
         02:DC47  BC D3 24   			ldy.h	_list_object_x_pos, x
10071                        		__call		_spr_x.1
         02:DC4A  20 0A E8   			call	_spr_x.1
10072                        	
10073                        		.dbg	line,	"include\init.c", 145; spr_y(list_object_y_pos[i]);
10074                        		__ld2x.bmq	__init_OBJECT_LV1_end - 1  /* i */
         02:DC4D  AD 3F 26   			lda	__init_OBJECT_LV1_end - 1
         02:DC50  0A         			asl	a
         02:DC51  AA         			tax
10075                        		__ld.wax	_list_object_y_pos
         02:DC52  BD 04 25   			lda.l	_list_object_y_pos, x
         02:DC55  BC 05 25   			ldy.h	_list_object_y_pos, x
10076                        		__call		_spr_y.1
         02:DC58  20 19 E8   			call	_spr_y.1
10077                        	
10078                        		.dbg	line,	"include\init.c", 146; spr_pri(FALSE);
10079                        		__ld.uiq	0
         02:DC5B  62         			cla
10080                        		__call		_spr_pri.1
         02:DC5C  20 5C E8   			call	_spr_pri.1
10081                        	
10082                        		.dbg	line,	"include\init.c", 149; if(list_object_type[i] == TYPE_HOURGLASS)
10083                        		__ldx.bmq	__init_OBJECT_LV1_end - 1  /* i */
         02:DC5F  AE 3F 26   			ldx	__init_OBJECT_LV1_end - 1
10084                        		__not.uax	_list_object_type
         02:DC62  BD 28 23   			lda	_list_object_type, x
         02:DC65  18         			clc
         02:DC66  D0 01      			bne	!+
         02:DC68  38         			sec
         02:DC69             	!:
10085                        		__bfalse	.LL438
         02:DC69  90 1D      			bcc	.LL438
10086                        	
10087                        		.dbg	line,	"include\init.c", 150; {
10088                        	
10089                        		.dbg	line,	"include\init.c", 151; list_object_energy[i] = 0;
10090                        		__ldx.bmq	__init_OBJECT_LV1_end - 1  /* i */
         02:DC6B  AE 3F 26   			ldx	__init_OBJECT_LV1_end - 1
10091                        		__st.uaxiq	0, _list_object_energy
         02:DC6E  9E 5A 23   			stz	_list_object_energy, x
10092                        	
10093                        		.dbg	line,	"include\init.c", 152; spr_pal(18);
10094                        		__ld.uiq	18
         02:DC71  A9 12      			lda	#18
10095                        		__call		_spr_pal.1
         02:DC73  20 4D E8   			call	_spr_pal.1
10096                        	
10097                        		.dbg	line,	"include\init.c", 153; spr_pattern(HOURGLASS_VRAM_ADR);
10098                        		__ld.wi		8640
         02:DC76  A9 C0      			lda.l	#8640
         02:DC78  A0 21      			ldy.h	#8640
10099                        		__call		_spr_pattern.1
         02:DC7A  20 26 E8   			call	_spr_pattern.1
10100                        	
10101                        		.dbg	line,	"include\init.c", 154; spr_ctrl(FLIP_MAS|SIZE_MAS, NO_FLIP|SZ_16x16);
10102                        		__st.umiq	185, _al
         02:DC7D  A9 B9      			lda.l	#185
         02:DC7F  85 F8      			sta	_al
10103                        		__ld.uiq	0
         02:DC81  62         			cla
10104                        		__call		_spr_ctrl.2
         02:DC82  20 3C E8   			call	_spr_ctrl.2
10105                        	
10106                        		.dbg	line,	"include\init.c", 155; }
10107                        	
10108                        		.dbg	line,	"include\init.c", 157; else if(list_object_type[i] == TYPE_POT)
10109                        		__bra		.LL439
         02:DC85  4C BF DB   			bra	.LL439
10110    02:DC88             	.LL438:
10111                        		__ldx.bmq	__init_OBJECT_LV1_end - 1  /* i */
         02:DC88  AE 3F 26   			ldx	__init_OBJECT_LV1_end - 1
10112                        		__ld.uaxq	_list_object_type
         02:DC8B  BD 28 23   			lda	_list_object_type, x
10113                        		__equ_b.uiq	1
         02:DC8E  C9 01      			cmp	#1
         02:DC90  F0 01      			beq	!+
         02:DC92  18         			clc
         02:DC93             	!:
10114                        		__bfalse	.LL440
         02:DC93  90 1E      			bcc	.LL440
10115                        	
10116                        		.dbg	line,	"include\init.c", 158; {
10117                        	
10118                        		.dbg	line,	"include\init.c", 159; list_object_energy[i] = 2;
10119                        		__ldx.bmq	__init_OBJECT_LV1_end - 1  /* i */
         02:DC95  AE 3F 26   			ldx	__init_OBJECT_LV1_end - 1
10120                        		__st.uaxiq	2, _list_object_energy
         02:DC98  A9 02      			lda.l	#2
         02:DC9A  9D 5A 23   			sta	_list_object_energy, x
10121                        	
10122                        		.dbg	line,	"include\init.c", 160; spr_pal(17);
10123                        		__ld.uiq	17
         02:DC9D  A9 11      			lda	#17
10124                        		__call		_spr_pal.1
         02:DC9F  20 4D E8   			call	_spr_pal.1
10125                        	
10126                        		.dbg	line,	"include\init.c", 161; spr_pattern(POT1_VRAM_ADR);
10127                        		__ld.wi		7168
         02:DCA2  62         			cla
         02:DCA3  A0 1C      			ldy.h	#7168
10128                        		__call		_spr_pattern.1
         02:DCA5  20 26 E8   			call	_spr_pattern.1
10129                        	
10130                        		.dbg	line,	"include\init.c", 162; spr_ctrl(FLIP_MAS|SIZE_MAS, NO_FLIP|SZ_16x16);
10131                        		__st.umiq	185, _al
         02:DCA8  A9 B9      			lda.l	#185
         02:DCAA  85 F8      			sta	_al
10132                        		__ld.uiq	0
         02:DCAC  62         			cla
10133                        		__call		_spr_ctrl.2
         02:DCAD  20 3C E8   			call	_spr_ctrl.2
10134                        	
10135                        		.dbg	line,	"include\init.c", 163; }
10136                        	
10137                        		.dbg	line,	"include\init.c", 165; else if(list_object_type[i] == TYPE_POW)
10138                        		__bra		.LL441
         02:DCB0  4C BF DB   			bra	.LL441
10139    02:DCB3             	.LL440:
10140                        		__ldx.bmq	__init_OBJECT_LV1_end - 1  /* i */
         02:DCB3  AE 3F 26   			ldx	__init_OBJECT_LV1_end - 1
10141                        		__ld.uaxq	_list_object_type
         02:DCB6  BD 28 23   			lda	_list_object_type, x
10142                        		__equ_b.uiq	2
         02:DCB9  C9 02      			cmp	#2
         02:DCBB  F0 01      			beq	!+
         02:DCBD  18         			clc
         02:DCBE             	!:
10143                        		__bfalse	.LL442
         02:DCBE  B0 03 4C BF			bcc	.LL442
         02:DCC2  DB          
10144                        	
10145                        		.dbg	line,	"include\init.c", 166; {
10146                        	
10147                        		.dbg	line,	"include\init.c", 167; list_object_energy[i] = 0;
10148                        		__ldx.bmq	__init_OBJECT_LV1_end - 1  /* i */
         02:DCC3  AE 3F 26   			ldx	__init_OBJECT_LV1_end - 1
10149                        		__st.uaxiq	0, _list_object_energy
         02:DCC6  9E 5A 23   			stz	_list_object_energy, x
10150                        	
10151                        		.dbg	line,	"include\init.c", 168; spr_pal(18);
10152                        		__ld.uiq	18
         02:DCC9  A9 12      			lda	#18
10153                        		__call		_spr_pal.1
         02:DCCB  20 4D E8   			call	_spr_pal.1
10154                        	
10155                        		.dbg	line,	"include\init.c", 169; spr_pattern(POW_VRAM_ADR);
10156                        		__ld.wi		7680
         02:DCCE  62         			cla
         02:DCCF  A0 1E      			ldy.h	#7680
10157                        		__call		_spr_pattern.1
         02:DCD1  20 26 E8   			call	_spr_pattern.1
10158                        	
10159                        		.dbg	line,	"include\init.c", 170; spr_ctrl(FLIP_MAS|SIZE_MAS, NO_FLIP|SZ_16x16);
10160                        		__st.umiq	185, _al
         02:DCD4  A9 B9      			lda.l	#185
         02:DCD6  85 F8      			sta	_al
10161                        		__ld.uiq	0
         02:DCD8  62         			cla
10162                        		__call		_spr_ctrl.2
         02:DCD9  20 3C E8   			call	_spr_ctrl.2
10163                        	
10164                        		.dbg	line,	"include\init.c", 171; }
10165                        	
10166                        		.dbg	line,	"include\init.c", 172; }
10167    02:DCDC             	.LL442	.alias		.LL434
10168    02:DCDC             	.LL441	.alias		.LL434
10169    02:DCDC             	.LL439	.alias		.LL434
10170                        		__bra		.LL434
         02:DCDC  4C BF DB   			bra	.LL434
10171    02:DCDF             	.LL436:
10172                        	
10173                        		.dbg	line,	"include\init.c", 173; }
10174    02:DCDF             	.LL432:
10175                        		__return	0
         02:DCDF  4C EF FF   			jmp	leave_proc
10176                        		.dbg	clear
10177                        		.endp
10178                        		.pceas
10179                        	
10180                        		.dbg	line,	"include\init.c", 176; void init_CHEST_LV1()
10181                        		.dbg	line,	"include\init.c", 177; {
10182                        	;***********************
10183                        	;***********************
10184                        	
10185                        		.hucc
10186    11:C1A8             		.proc		_init_CHEST_LV1
10187                        		__enter		_init_CHEST_LV1
10188                        	
10189                        		.dbg	line,	"include\init.c", 178; signed char i;
10190                        	
10191                        		.dbg	line,	"include\init.c", 180; for(i=0 ; i<level_chest_number ; i++)
10192                        		__st.umiq	0, __init_CHEST_LV1_end - 1  /* i */
         11:C1A8  9C 3F 26   			stz	__init_CHEST_LV1_end - 1
10193    11:C1AB             	.LL444:
10194                        		__ld.bm		__init_CHEST_LV1_end - 1  /* i */
         11:C1AB  AD 3F 26   			lda	__init_CHEST_LV1_end - 1
         11:C1AE  C2         			cly
         11:C1AF  10 01      			bpl	!+
         11:C1B1  88         			dey
         11:C1B2             	!:
10195                        		__slt_w.um	_level_chest_number
         11:C1B2  CD 95 23   			cmp	_level_chest_number		; Subtract memory from Y:A.
         11:C1B5  98         			tya
         11:C1B6  E9 00      			sbc	#0
         11:C1B8  50 02      			bvc	!+
         11:C1BA  49 80      			eor	#$80		; -ve if Y:A < memory (signed).
         11:C1BC  0A         	!:		asl	a
10196                        		__btrue		.LL446
         11:C1BD  B0 08      			bcs	.LL446
10197                        		__bra		.LL447
         11:C1BF  4C 6C C2   			bra	.LL447
10198    11:C1C2             	.LL445:
10199                        		__inc.umq	__init_CHEST_LV1_end - 1  /* i */
         11:C1C2  EE 3F 26   			inc	__init_CHEST_LV1_end - 1
10200                        		__bra		.LL444
         11:C1C5  80 E4      			bra	.LL444
10201    11:C1C7             	.LL446:
10202                        	
10203                        		.dbg	line,	"include\init.c", 181; {
10204                        	
10205                        		.dbg	line,	"include\init.c", 182; // SET CHEST PROPERTIES //
10206                        	
10207                        		.dbg	line,	"include\init.c", 183; list_chest_x_pos_ref[i] = TABLE_CHEST_X_POS_REF_LV1[i];
10208                        		__ld2x.bmq	__init_CHEST_LV1_end - 1  /* i */
         11:C1C7  AD 3F 26   			lda	__init_CHEST_LV1_end - 1
         11:C1CA  0A         			asl	a
         11:C1CB  AA         			tax
10209                        		__ld.wax	_TABLE_CHEST_X_POS_REF_LV1
         11:C1CC  BD 9A 60   			lda.l	_TABLE_CHEST_X_POS_REF_LV1, x
         11:C1CF  BC 9B 60   			ldy.h	_TABLE_CHEST_X_POS_REF_LV1, x
10210                        		__ld2x.bm	__init_CHEST_LV1_end - 1  /* i */
         11:C1D2  AA         			tax
         11:C1D3  AD 3F 26   			lda	__init_CHEST_LV1_end - 1
         11:C1D6  0A         			asl	a
         11:C1D7  22         			sax
10211                        		__st.waxq	_list_chest_x_pos_ref
         11:C1D8  9D BA 25   			sta.l	_list_chest_x_pos_ref, x
         11:C1DB  98         			tya
         11:C1DC  9D BB 25   			sta.h	_list_chest_x_pos_ref, x
10212                        	
10213                        		.dbg	line,	"include\init.c", 184; list_chest_y_pos_ref[i] = TABLE_CHEST_Y_POS_REF_LV1[i];
10214                        		__ld2x.bmq	__init_CHEST_LV1_end - 1  /* i */
         11:C1DF  AD 3F 26   			lda	__init_CHEST_LV1_end - 1
         11:C1E2  0A         			asl	a
         11:C1E3  AA         			tax
10215                        		__ld.wax	_TABLE_CHEST_Y_POS_REF_LV1
         11:C1E4  BD 9E 60   			lda.l	_TABLE_CHEST_Y_POS_REF_LV1, x
         11:C1E7  BC 9F 60   			ldy.h	_TABLE_CHEST_Y_POS_REF_LV1, x
10216                        		__ld2x.bm	__init_CHEST_LV1_end - 1  /* i */
         11:C1EA  AA         			tax
         11:C1EB  AD 3F 26   			lda	__init_CHEST_LV1_end - 1
         11:C1EE  0A         			asl	a
         11:C1EF  22         			sax
10217                        		__st.waxq	_list_chest_y_pos_ref
         11:C1F0  9D CA 25   			sta.l	_list_chest_y_pos_ref, x
         11:C1F3  98         			tya
         11:C1F4  9D CB 25   			sta.h	_list_chest_y_pos_ref, x
10218                        	
10219                        		.dbg	line,	"include\init.c", 185; list_chest_x_pos[i] = -32;
10220                        		__ld2x.bmq	__init_CHEST_LV1_end - 1  /* i */
         11:C1F7  AD 3F 26   			lda	__init_CHEST_LV1_end - 1
         11:C1FA  0A         			asl	a
         11:C1FB  AA         			tax
10221                        		__st.waxiq	-32, _list_chest_x_pos
         11:C1FC  A9 E0      			lda.l	#-32
         11:C1FE  9D 9A 25   			sta.l	_list_chest_x_pos, x
         11:C201  A9 FF      			lda.h	#-32
         11:C203  9D 9B 25   			sta.h	_list_chest_x_pos, x
10222                        	
10223                        		.dbg	line,	"include\init.c", 186; list_chest_y_pos[i] = -32;
10224                        		__ld2x.bmq	__init_CHEST_LV1_end - 1  /* i */
         11:C206  AD 3F 26   			lda	__init_CHEST_LV1_end - 1
         11:C209  0A         			asl	a
         11:C20A  AA         			tax
10225                        		__st.waxiq	-32, _list_chest_y_pos
         11:C20B  A9 E0      			lda.l	#-32
         11:C20D  9D AA 25   			sta.l	_list_chest_y_pos, x
         11:C210  A9 FF      			lda.h	#-32
         11:C212  9D AB 25   			sta.h	_list_chest_y_pos, x
10226                        	
10227                        		.dbg	line,	"include\init.c", 188; if(respawn == FALSE)
10228                        		__not.um	_respawn
         11:C215  AD 13 23   			lda	_respawn
         11:C218  18         			clc
         11:C219  D0 01      			bne	!+
         11:C21B  38         			sec
         11:C21C             	!:
10229                        		__bfalse	.LL448
         11:C21C  90 06      			bcc	.LL448
10230                        	
10231                        		.dbg	line,	"include\init.c", 189; {
10232                        	
10233                        		.dbg	line,	"include\init.c", 190; list_chest_state[i] = STATE_ACTIVE;
10234                        		__ldx.bmq	__init_CHEST_LV1_end - 1  /* i */
         11:C21E  AE 3F 26   			ldx	__init_CHEST_LV1_end - 1
10235                        		__st.uaxiq	0, _list_chest_state
         11:C221  9E 97 23   			stz	_list_chest_state, x
10236                        	
10237                        		.dbg	line,	"include\init.c", 191; }
10238                        	
10239                        		.dbg	line,	"include\init.c", 194; // SET CHEST SPRITE //
10240                        	
10241                        		.dbg	line,	"include\init.c", 195; spr_set(i + chest_start_index);
10242    11:C224             	.LL448:
10243                        		__ld.bm		__init_CHEST_LV1_end - 1  /* i */
         11:C224  AD 3F 26   			lda	__init_CHEST_LV1_end - 1
         11:C227  C2         			cly
         11:C228  10 01      			bpl	!+
         11:C22A  88         			dey
         11:C22B             	!:
10244                        		__add.um	_chest_start_index
         11:C22B  18         			clc
         11:C22C  6D 94 23   			adc	_chest_start_index
         11:C22F  90 01      			bcc	!+
         11:C231  C8         			iny
         11:C232             	!:
10245                        		__call		_spr_set.1
         11:C232  20 DD E7   			call	_spr_set.1
10246                        	
10247                        		.dbg	line,	"include\init.c", 196; spr_x(list_chest_x_pos[i]);
10248                        		__ld2x.bmq	__init_CHEST_LV1_end - 1  /* i */
         11:C235  AD 3F 26   			lda	__init_CHEST_LV1_end - 1
         11:C238  0A         			asl	a
         11:C239  AA         			tax
10249                        		__ld.wax	_list_chest_x_pos
         11:C23A  BD 9A 25   			lda.l	_list_chest_x_pos, x
         11:C23D  BC 9B 25   			ldy.h	_list_chest_x_pos, x
10250                        		__call		_spr_x.1
         11:C240  20 0A E8   			call	_spr_x.1
10251                        	
10252                        		.dbg	line,	"include\init.c", 197; spr_y(list_chest_y_pos[i]);
10253                        		__ld2x.bmq	__init_CHEST_LV1_end - 1  /* i */
         11:C243  AD 3F 26   			lda	__init_CHEST_LV1_end - 1
         11:C246  0A         			asl	a
         11:C247  AA         			tax
10254                        		__ld.wax	_list_chest_y_pos
         11:C248  BD AA 25   			lda.l	_list_chest_y_pos, x
         11:C24B  BC AB 25   			ldy.h	_list_chest_y_pos, x
10255                        		__call		_spr_y.1
         11:C24E  20 19 E8   			call	_spr_y.1
10256                        	
10257                        		.dbg	line,	"include\init.c", 198; spr_pri(FALSE);
10258                        		__ld.uiq	0
         11:C251  62         			cla
10259                        		__call		_spr_pri.1
         11:C252  20 5C E8   			call	_spr_pri.1
10260                        	
10261                        		.dbg	line,	"include\init.c", 201; spr_pal(18);
10262                        		__ld.uiq	18
         11:C255  A9 12      			lda	#18
10263                        		__call		_spr_pal.1
         11:C257  20 4D E8   			call	_spr_pal.1
10264                        	
10265                        		.dbg	line,	"include\init.c", 202; spr_pattern(CHEST_VRAM_ADR);
10266                        		__ld.wi		9216
         11:C25A  62         			cla
         11:C25B  A0 24      			ldy.h	#9216
10267                        		__call		_spr_pattern.1
         11:C25D  20 26 E8   			call	_spr_pattern.1
10268                        	
10269                        		.dbg	line,	"include\init.c", 203; spr_ctrl(FLIP_MAS|SIZE_MAS, NO_FLIP|SZ_32x32);
10270                        		__st.umiq	185, _al
         11:C260  A9 B9      			lda.l	#185
         11:C262  85 F8      			sta	_al
10271                        		__ld.uiq	17
         11:C264  A9 11      			lda	#17
10272                        		__call		_spr_ctrl.2
         11:C266  20 3C E8   			call	_spr_ctrl.2
10273                        	
10274                        		.dbg	line,	"include\init.c", 204; }
10275                        		__bra		.LL445
         11:C269  4C C2 C1   			bra	.LL445
10276    11:C26C             	.LL447:
10277                        	
10278                        		.dbg	line,	"include\init.c", 205; }
10279    11:C26C             	.LL443:
10280                        		__return	0
         11:C26C  4C EF FF   			jmp	leave_proc
10281                        		.dbg	clear
10282                        		.endp
10283                        		.pceas
10284                        	
10285                        		.dbg	line,	"include\init.c", 208; void init_NPC_LV1()
10286                        		.dbg	line,	"include\init.c", 209; {
10287                        	;***********************
10288                        	;***********************
10289                        	
10290                        		.hucc
10291    11:C0D4             		.proc		_init_NPC_LV1
10292                        		__enter		_init_NPC_LV1
10293                        	
10294                        		.dbg	line,	"include\init.c", 210; signed char i;
10295                        	
10296                        		.dbg	line,	"include\init.c", 212; for(i=0 ; i<level_npc_number ; i++)
10297                        		__st.umiq	0, __init_NPC_LV1_end - 1  /* i */
         11:C0D4  9C 3F 26   			stz	__init_NPC_LV1_end - 1
10298    11:C0D7             	.LL450:
10299                        		__ld.bm		__init_NPC_LV1_end - 1  /* i */
         11:C0D7  AD 3F 26   			lda	__init_NPC_LV1_end - 1
         11:C0DA  C2         			cly
         11:C0DB  10 01      			bpl	!+
         11:C0DD  88         			dey
         11:C0DE             	!:
10300                        		__slt_w.um	_level_npc_number
         11:C0DE  CD A8 23   			cmp	_level_npc_number		; Subtract memory from Y:A.
         11:C0E1  98         			tya
         11:C0E2  E9 00      			sbc	#0
         11:C0E4  50 02      			bvc	!+
         11:C0E6  49 80      			eor	#$80		; -ve if Y:A < memory (signed).
         11:C0E8  0A         	!:		asl	a
10301                        		__btrue		.LL452
         11:C0E9  B0 08      			bcs	.LL452
10302                        		__bra		.LL453
         11:C0EB  4C A5 C1   			bra	.LL453
10303    11:C0EE             	.LL451:
10304                        		__inc.umq	__init_NPC_LV1_end - 1  /* i */
         11:C0EE  EE 3F 26   			inc	__init_NPC_LV1_end - 1
10305                        		__bra		.LL450
         11:C0F1  80 E4      			bra	.LL450
10306    11:C0F3             	.LL452:
10307                        	
10308                        		.dbg	line,	"include\init.c", 213; {
10309                        	
10310                        		.dbg	line,	"include\init.c", 214; // SET NPC PROPERTIES //
10311                        	
10312                        		.dbg	line,	"include\init.c", 215; list_npc_type[i] = TABLE_NPC_TYPE_LV1[i];
10313                        		__ldx.bmq	__init_NPC_LV1_end - 1  /* i */
         11:C0F3  AE 3F 26   			ldx	__init_NPC_LV1_end - 1
10314                        		__ld.uax	_TABLE_NPC_TYPE_LV1
         11:C0F6  BD 1D 60   			lda	_TABLE_NPC_TYPE_LV1, x
         11:C0F9  C2         			cly
10315                        		__ldx.bmq	__init_NPC_LV1_end - 1  /* i */
         11:C0FA  AE 3F 26   			ldx	__init_NPC_LV1_end - 1
10316                        		__st.uaxq	_list_npc_type
         11:C0FD  9D AA 23   			sta	_list_npc_type, x
10317                        	
10318                        		.dbg	line,	"include\init.c", 216; list_npc_x_pos_ref[i] = TABLE_NPC_X_POS_REF_LV1[i];
10319                        		__ld2x.bmq	__init_NPC_LV1_end - 1  /* i */
         11:C100  AD 3F 26   			lda	__init_NPC_LV1_end - 1
         11:C103  0A         			asl	a
         11:C104  AA         			tax
10320                        		__ld.wax	_TABLE_NPC_X_POS_REF_LV1
         11:C105  BD 1F 60   			lda.l	_TABLE_NPC_X_POS_REF_LV1, x
         11:C108  BC 20 60   			ldy.h	_TABLE_NPC_X_POS_REF_LV1, x
10321                        		__ld2x.bm	__init_NPC_LV1_end - 1  /* i */
         11:C10B  AA         			tax
         11:C10C  AD 3F 26   			lda	__init_NPC_LV1_end - 1
         11:C10F  0A         			asl	a
         11:C110  22         			sax
10322                        		__st.waxq	_list_npc_x_pos_ref
         11:C111  9D FE 25   			sta.l	_list_npc_x_pos_ref, x
         11:C114  98         			tya
         11:C115  9D FF 25   			sta.h	_list_npc_x_pos_ref, x
10323                        	
10324                        		.dbg	line,	"include\init.c", 217; list_npc_y_pos_ref[i] = TABLE_NPC_Y_POS_REF_LV1[i];
10325                        		__ld2x.bmq	__init_NPC_LV1_end - 1  /* i */
         11:C118  AD 3F 26   			lda	__init_NPC_LV1_end - 1
         11:C11B  0A         			asl	a
         11:C11C  AA         			tax
10326                        		__ld.wax	_TABLE_NPC_Y_POS_REF_LV1
         11:C11D  BD 23 60   			lda.l	_TABLE_NPC_Y_POS_REF_LV1, x
         11:C120  BC 24 60   			ldy.h	_TABLE_NPC_Y_POS_REF_LV1, x
10327                        		__ld2x.bm	__init_NPC_LV1_end - 1  /* i */
         11:C123  AA         			tax
         11:C124  AD 3F 26   			lda	__init_NPC_LV1_end - 1
         11:C127  0A         			asl	a
         11:C128  22         			sax
10328                        		__st.waxq	_list_npc_y_pos_ref
         11:C129  9D 10 26   			sta.l	_list_npc_y_pos_ref, x
         11:C12C  98         			tya
         11:C12D  9D 11 26   			sta.h	_list_npc_y_pos_ref, x
10329                        	
10330                        		.dbg	line,	"include\init.c", 218; list_npc_x_pos[i] = -32;
10331                        		__ld2x.bmq	__init_NPC_LV1_end - 1  /* i */
         11:C130  AD 3F 26   			lda	__init_NPC_LV1_end - 1
         11:C133  0A         			asl	a
         11:C134  AA         			tax
10332                        		__st.waxiq	-32, _list_npc_x_pos
         11:C135  A9 E0      			lda.l	#-32
         11:C137  9D DA 25   			sta.l	_list_npc_x_pos, x
         11:C13A  A9 FF      			lda.h	#-32
         11:C13C  9D DB 25   			sta.h	_list_npc_x_pos, x
10333                        	
10334                        		.dbg	line,	"include\init.c", 219; list_npc_y_pos[i] = -32;
10335                        		__ld2x.bmq	__init_NPC_LV1_end - 1  /* i */
         11:C13F  AD 3F 26   			lda	__init_NPC_LV1_end - 1
         11:C142  0A         			asl	a
         11:C143  AA         			tax
10336                        		__st.waxiq	-32, _list_npc_y_pos
         11:C144  A9 E0      			lda.l	#-32
         11:C146  9D EC 25   			sta.l	_list_npc_y_pos, x
         11:C149  A9 FF      			lda.h	#-32
         11:C14B  9D ED 25   			sta.h	_list_npc_y_pos, x
10337                        	
10338                        		.dbg	line,	"include\init.c", 221; if(respawn == FALSE)
10339                        		__not.um	_respawn
         11:C14E  AD 13 23   			lda	_respawn
         11:C151  18         			clc
         11:C152  D0 01      			bne	!+
         11:C154  38         			sec
         11:C155             	!:
10340                        		__bfalse	.LL454
         11:C155  90 06      			bcc	.LL454
10341                        	
10342                        		.dbg	line,	"include\init.c", 222; {
10343                        	
10344                        		.dbg	line,	"include\init.c", 223; list_npc_state[i] = STATE_ACTIVE;
10345                        		__ldx.bmq	__init_NPC_LV1_end - 1  /* i */
         11:C157  AE 3F 26   			ldx	__init_NPC_LV1_end - 1
10346                        		__st.uaxiq	0, _list_npc_state
         11:C15A  9E B3 23   			stz	_list_npc_state, x
10347                        	
10348                        		.dbg	line,	"include\init.c", 224; }
10349                        	
10350                        		.dbg	line,	"include\init.c", 227; // SET NPC SPRITE //
10351                        	
10352                        		.dbg	line,	"include\init.c", 228; spr_set(i + npc_start_index);
10353    11:C15D             	.LL454:
10354                        		__ld.bm		__init_NPC_LV1_end - 1  /* i */
         11:C15D  AD 3F 26   			lda	__init_NPC_LV1_end - 1
         11:C160  C2         			cly
         11:C161  10 01      			bpl	!+
         11:C163  88         			dey
         11:C164             	!:
10355                        		__add.um	_npc_start_index
         11:C164  18         			clc
         11:C165  6D A7 23   			adc	_npc_start_index
         11:C168  90 01      			bcc	!+
         11:C16A  C8         			iny
         11:C16B             	!:
10356                        		__call		_spr_set.1
         11:C16B  20 DD E7   			call	_spr_set.1
10357                        	
10358                        		.dbg	line,	"include\init.c", 229; spr_x(list_npc_x_pos[i]);
10359                        		__ld2x.bmq	__init_NPC_LV1_end - 1  /* i */
         11:C16E  AD 3F 26   			lda	__init_NPC_LV1_end - 1
         11:C171  0A         			asl	a
         11:C172  AA         			tax
10360                        		__ld.wax	_list_npc_x_pos
         11:C173  BD DA 25   			lda.l	_list_npc_x_pos, x
         11:C176  BC DB 25   			ldy.h	_list_npc_x_pos, x
10361                        		__call		_spr_x.1
         11:C179  20 0A E8   			call	_spr_x.1
10362                        	
10363                        		.dbg	line,	"include\init.c", 230; spr_y(list_npc_y_pos[i]);
10364                        		__ld2x.bmq	__init_NPC_LV1_end - 1  /* i */
         11:C17C  AD 3F 26   			lda	__init_NPC_LV1_end - 1
         11:C17F  0A         			asl	a
         11:C180  AA         			tax
10365                        		__ld.wax	_list_npc_y_pos
         11:C181  BD EC 25   			lda.l	_list_npc_y_pos, x
         11:C184  BC ED 25   			ldy.h	_list_npc_y_pos, x
10366                        		__call		_spr_y.1
         11:C187  20 19 E8   			call	_spr_y.1
10367                        	
10368                        		.dbg	line,	"include\init.c", 231; spr_pri(FALSE);
10369                        		__ld.uiq	0
         11:C18A  62         			cla
10370                        		__call		_spr_pri.1
         11:C18B  20 5C E8   			call	_spr_pri.1
10371                        	
10372                        		.dbg	line,	"include\init.c", 234; spr_pal(17);
10373                        		__ld.uiq	17
         11:C18E  A9 11      			lda	#17
10374                        		__call		_spr_pal.1
         11:C190  20 4D E8   			call	_spr_pal.1
10375                        	
10376                        		.dbg	line,	"include\init.c", 235; spr_pattern(NPC_VRAM_ADR);
10377                        		__ld.wi		10752
         11:C193  62         			cla
         11:C194  A0 2A      			ldy.h	#10752
10378                        		__call		_spr_pattern.1
         11:C196  20 26 E8   			call	_spr_pattern.1
10379                        	
10380                        		.dbg	line,	"include\init.c", 236; spr_ctrl(FLIP_MAS|SIZE_MAS, NO_FLIP|SZ_32x32);
10381                        		__st.umiq	185, _al
         11:C199  A9 B9      			lda.l	#185
         11:C19B  85 F8      			sta	_al
10382                        		__ld.uiq	17
         11:C19D  A9 11      			lda	#17
10383                        		__call		_spr_ctrl.2
         11:C19F  20 3C E8   			call	_spr_ctrl.2
10384                        	
10385                        		.dbg	line,	"include\init.c", 237; }
10386                        		__bra		.LL451
         11:C1A2  4C EE C0   			bra	.LL451
10387    11:C1A5             	.LL453:
10388                        	
10389                        		.dbg	line,	"include\init.c", 238; }
10390    11:C1A5             	.LL449:
10391                        		__return	0
         11:C1A5  4C EF FF   			jmp	leave_proc
10392                        		.dbg	clear
10393                        		.endp
10394                        		.pceas
10395                        	
10396                        		.dbg	line,	"include\init.c", 245; void init_HUD()
10397                        		.dbg	line,	"include\init.c", 246; {
10398                        	;***********************
10399                        	;***********************
10400                        	
10401                        		.hucc
10402    02:CB92             		.proc		_init_HUD
10403                        		__enter		_init_HUD
10404                        	
10405                        		.dbg	line,	"include\init.c", 247; //**************************************************************************************//
10406                        	
10407                        		.dbg	line,	"include\init.c", 248; //                                                                                      //
10408                        	
10409                        		.dbg	line,	"include\init.c", 249; //                                        VDC 1                                         //
10410                        	
10411                        		.dbg	line,	"include\init.c", 250; //                                                                                      //
10412                        	
10413                        		.dbg	line,	"include\init.c", 251; //**************************************************************************************//
10414                        	
10415                        		.dbg	line,	"include\init.c", 253; //--------------------------------------------------------------------------------------//
10416                        	
10417                        		.dbg	line,	"include\init.c", 254; //                                      LOAD FONT                                       //
10418                        	
10419                        		.dbg	line,	"include\init.c", 255; //--------------------------------------------------------------------------------------//
10420                        	
10421                        		.dbg	line,	"include\init.c", 257; load_vram( 0x0800, tileset_FONT, SIZEOF(tileset_FONT) >> 1 );
10422                        		__st.wmiq	2048, _di
         02:CB92  64 F0      			stz.l	_di
         02:CB94  A9 08      			lda.h	#2048
         02:CB96  85 F1      			sta.h	_di
10423                        		__farptr	_tileset_FONT, _bp_bank, _bp
         02:CB98  A9 00      			lda.l	#$6000 + ($1FFF & (_tileset_FONT))
         02:CB9A  85 EC      			sta.l	_bp
         02:CB9C  A9 60      			lda.h	#$6000 + ($1FFF & (_tileset_FONT))
         02:CB9E  85 ED      			sta.h	_bp
         02:CBA0  A9 03      			lda	#bank(_tileset_FONT)
         02:CBA2  85 02      			sta	_bp_bank
10424                        		__ld.wi		___sizeof__tileset_FONT
         02:CBA4  A9 00      			lda.l	#___sizeof__tileset_FONT
         02:CBA6  A0 0C      			ldy.h	#___sizeof__tileset_FONT
10425                        		__lsr.wi	1
         02:CBA8  42         			say
         02:CBA9  4A         			lsr	a
         02:CBAA  42         			say
         02:CBAB  6A         			ror	a
10426                        		__st.wmq	_ax
         02:CBAC  85 F8      			sta.l	_ax
         02:CBAE  84 F9      			sty.h	_ax
10427                        		 _load_vram.3
         02:CBB0  82         			clx				; Offset to PCE VDC.
         02:CBB1  20 63 FF   			call	load_vram_x
10428                        	
10429                        		.dbg	line,	"include\init.c", 259; set_font_pal(15);
10430                        		__ld.uiq	15
         02:CBB4  A9 0F      			lda	#15
10431                        		__call		_set_font_pal.1
         02:CBB6  20 09 E6   			call	_set_font_pal.1
10432                        	
10433                        		.dbg	line,	"include\init.c", 262; //--------------------------------------------------------------------------------------//
10434                        	
10435                        		.dbg	line,	"include\init.c", 263; //                                    LOAD TILESET                                      //
10436                        	
10437                        		.dbg	line,	"include\init.c", 264; //--------------------------------------------------------------------------------------//
10438                        	
10439                        		.dbg	line,	"include\init.c", 266; load_vram( 0x1000, tileset_HUD, SIZEOF(tileset_HUD) >> 1 );
10440                        		__st.wmiq	4096, _di
         02:CBB9  64 F0      			stz.l	_di
         02:CBBB  A9 10      			lda.h	#4096
         02:CBBD  85 F1      			sta.h	_di
10441                        		__farptr	_tileset_HUD, _bp_bank, _bp
         02:CBBF  A9 A0      			lda.l	#$6000 + ($1FFF & (_tileset_HUD))
         02:CBC1  85 EC      			sta.l	_bp
         02:CBC3  A9 79      			lda.h	#$6000 + ($1FFF & (_tileset_HUD))
         02:CBC5  85 ED      			sta.h	_bp
         02:CBC7  A9 09      			lda	#bank(_tileset_HUD)
         02:CBC9  85 02      			sta	_bp_bank
10442                        		__ld.wi		___sizeof__tileset_HUD
         02:CBCB  A9 60      			lda.l	#___sizeof__tileset_HUD
         02:CBCD  A0 06      			ldy.h	#___sizeof__tileset_HUD
10443                        		__lsr.wi	1
         02:CBCF  42         			say
         02:CBD0  4A         			lsr	a
         02:CBD1  42         			say
         02:CBD2  6A         			ror	a
10444                        		__st.wmq	_ax
         02:CBD3  85 F8      			sta.l	_ax
         02:CBD5  84 F9      			sty.h	_ax
10445                        		 _load_vram.3
         02:CBD7  82         			clx				; Offset to PCE VDC.
         02:CBD8  20 63 FF   			call	load_vram_x
10446                        	
10447                        		.dbg	line,	"include\init.c", 269; //--------------------------------------------------------------------------------------//
10448                        	
10449                        		.dbg	line,	"include\init.c", 270; //                                 LOAD LIFEBAR TILES                                   //
10450                        	
10451                        		.dbg	line,	"include\init.c", 271; //--------------------------------------------------------------------------------------//
10452                        	
10453                        		.dbg	line,	"include\init.c", 273; load_vram( LIFEBAR_1_VRAM_ADR, tileset_LIFE_RED, SIZEOF(tileset_LIFE_RED) >> 1 );
10454                        		__st.wmiq	4096, _di
         02:CBDB  64 F0      			stz.l	_di
         02:CBDD  A9 10      			lda.h	#4096
         02:CBDF  85 F1      			sta.h	_di
10455                        		__farptr	_tileset_LIFE_RED, _bp_bank, _bp
         02:CBE1  A9 00      			lda.l	#$6000 + ($1FFF & (_tileset_LIFE_RED))
         02:CBE3  85 EC      			sta.l	_bp
         02:CBE5  A9 74      			lda.h	#$6000 + ($1FFF & (_tileset_LIFE_RED))
         02:CBE7  85 ED      			sta.h	_bp
         02:CBE9  A9 03      			lda	#bank(_tileset_LIFE_RED)
         02:CBEB  85 02      			sta	_bp_bank
10456                        		__ld.wi		___sizeof__tileset_LIFE_RED
         02:CBED  A9 40      			lda.l	#___sizeof__tileset_LIFE_RED
         02:CBEF  A0 00      			ldy.h	#___sizeof__tileset_LIFE_RED
10457                        		__lsr.wi	1
         02:CBF1  42         			say
         02:CBF2  4A         			lsr	a
         02:CBF3  42         			say
         02:CBF4  6A         			ror	a
10458                        		__st.wmq	_ax
         02:CBF5  85 F8      			sta.l	_ax
         02:CBF7  84 F9      			sty.h	_ax
10459                        		 _load_vram.3
         02:CBF9  82         			clx				; Offset to PCE VDC.
         02:CBFA  20 63 FF   			call	load_vram_x
10460                        	
10461                        		.dbg	line,	"include\init.c", 274; load_vram( LIFEBAR_2_VRAM_ADR, tileset_LIFE_ORANGE, SIZEOF(tileset_LIFE_ORANGE) >> 1 );
10462                        		__st.wmiq	4128, _di
         02:CBFD  A9 20      			lda.l	#4128
         02:CBFF  85 F0      			sta.l	_di
         02:CC01  A9 10      			lda.h	#4128
         02:CC03  85 F1      			sta.h	_di
10463                        		__farptr	_tileset_LIFE_ORANGE, _bp_bank, _bp
         02:CC05  A9 40      			lda.l	#$6000 + ($1FFF & (_tileset_LIFE_ORANGE))
         02:CC07  85 EC      			sta.l	_bp
         02:CC09  A9 74      			lda.h	#$6000 + ($1FFF & (_tileset_LIFE_ORANGE))
         02:CC0B  85 ED      			sta.h	_bp
         02:CC0D  A9 03      			lda	#bank(_tileset_LIFE_ORANGE)
         02:CC0F  85 02      			sta	_bp_bank
10464                        		__ld.wi		___sizeof__tileset_LIFE_ORANGE
         02:CC11  A9 40      			lda.l	#___sizeof__tileset_LIFE_ORANGE
         02:CC13  A0 00      			ldy.h	#___sizeof__tileset_LIFE_ORANGE
10465                        		__lsr.wi	1
         02:CC15  42         			say
         02:CC16  4A         			lsr	a
         02:CC17  42         			say
         02:CC18  6A         			ror	a
10466                        		__st.wmq	_ax
         02:CC19  85 F8      			sta.l	_ax
         02:CC1B  84 F9      			sty.h	_ax
10467                        		 _load_vram.3
         02:CC1D  82         			clx				; Offset to PCE VDC.
         02:CC1E  20 63 FF   			call	load_vram_x
10468                        	
10469                        		.dbg	line,	"include\init.c", 275; load_vram( LIFEBAR_3_VRAM_ADR, tileset_LIFE_YELLOW, SIZEOF(tileset_LIFE_YELLOW) >> 1 );
10470                        		__st.wmiq	4160, _di
         02:CC21  A9 40      			lda.l	#4160
         02:CC23  85 F0      			sta.l	_di
         02:CC25  A9 10      			lda.h	#4160
         02:CC27  85 F1      			sta.h	_di
10471                        		__farptr	_tileset_LIFE_YELLOW, _bp_bank, _bp
         02:CC29  A9 80      			lda.l	#$6000 + ($1FFF & (_tileset_LIFE_YELLOW))
         02:CC2B  85 EC      			sta.l	_bp
         02:CC2D  A9 74      			lda.h	#$6000 + ($1FFF & (_tileset_LIFE_YELLOW))
         02:CC2F  85 ED      			sta.h	_bp
         02:CC31  A9 03      			lda	#bank(_tileset_LIFE_YELLOW)
         02:CC33  85 02      			sta	_bp_bank
10472                        		__ld.wi		___sizeof__tileset_LIFE_YELLOW
         02:CC35  A9 40      			lda.l	#___sizeof__tileset_LIFE_YELLOW
         02:CC37  A0 00      			ldy.h	#___sizeof__tileset_LIFE_YELLOW
10473                        		__lsr.wi	1
         02:CC39  42         			say
         02:CC3A  4A         			lsr	a
         02:CC3B  42         			say
         02:CC3C  6A         			ror	a
10474                        		__st.wmq	_ax
         02:CC3D  85 F8      			sta.l	_ax
         02:CC3F  84 F9      			sty.h	_ax
10475                        		 _load_vram.3
         02:CC41  82         			clx				; Offset to PCE VDC.
         02:CC42  20 63 FF   			call	load_vram_x
10476                        	
10477                        		.dbg	line,	"include\init.c", 276; load_vram( LIFEBAR_4_VRAM_ADR, tileset_LIFE_YELLOW, SIZEOF(tileset_LIFE_YELLOW) >> 1 );
10478                        		__st.wmiq	4192, _di
         02:CC45  A9 60      			lda.l	#4192
         02:CC47  85 F0      			sta.l	_di
         02:CC49  A9 10      			lda.h	#4192
         02:CC4B  85 F1      			sta.h	_di
10479                        		__farptr	_tileset_LIFE_YELLOW, _bp_bank, _bp
         02:CC4D  A9 80      			lda.l	#$6000 + ($1FFF & (_tileset_LIFE_YELLOW))
         02:CC4F  85 EC      			sta.l	_bp
         02:CC51  A9 74      			lda.h	#$6000 + ($1FFF & (_tileset_LIFE_YELLOW))
         02:CC53  85 ED      			sta.h	_bp
         02:CC55  A9 03      			lda	#bank(_tileset_LIFE_YELLOW)
         02:CC57  85 02      			sta	_bp_bank
10480                        		__ld.wi		___sizeof__tileset_LIFE_YELLOW
         02:CC59  A9 40      			lda.l	#___sizeof__tileset_LIFE_YELLOW
         02:CC5B  A0 00      			ldy.h	#___sizeof__tileset_LIFE_YELLOW
10481                        		__lsr.wi	1
         02:CC5D  42         			say
         02:CC5E  4A         			lsr	a
         02:CC5F  42         			say
         02:CC60  6A         			ror	a
10482                        		__st.wmq	_ax
         02:CC61  85 F8      			sta.l	_ax
         02:CC63  84 F9      			sty.h	_ax
10483                        		 _load_vram.3
         02:CC65  82         			clx				; Offset to PCE VDC.
         02:CC66  20 63 FF   			call	load_vram_x
10484                        	
10485                        		.dbg	line,	"include\init.c", 277; load_vram( LIFEBAR_5_VRAM_ADR, tileset_LIFE_EMPTY, SIZEOF(tileset_LIFE_EMPTY) >> 1 );
10486                        		__st.wmiq	4224, _di
         02:CC69  A9 80      			lda.l	#4224
         02:CC6B  85 F0      			sta.l	_di
         02:CC6D  A9 10      			lda.h	#4224
         02:CC6F  85 F1      			sta.h	_di
10487                        		__farptr	_tileset_LIFE_EMPTY, _bp_bank, _bp
         02:CC71  A9 C0      			lda.l	#$6000 + ($1FFF & (_tileset_LIFE_EMPTY))
         02:CC73  85 EC      			sta.l	_bp
         02:CC75  A9 74      			lda.h	#$6000 + ($1FFF & (_tileset_LIFE_EMPTY))
         02:CC77  85 ED      			sta.h	_bp
         02:CC79  A9 03      			lda	#bank(_tileset_LIFE_EMPTY)
         02:CC7B  85 02      			sta	_bp_bank
10488                        		__ld.wi		___sizeof__tileset_LIFE_EMPTY
         02:CC7D  A9 40      			lda.l	#___sizeof__tileset_LIFE_EMPTY
         02:CC7F  A0 00      			ldy.h	#___sizeof__tileset_LIFE_EMPTY
10489                        		__lsr.wi	1
         02:CC81  42         			say
         02:CC82  4A         			lsr	a
         02:CC83  42         			say
         02:CC84  6A         			ror	a
10490                        		__st.wmq	_ax
         02:CC85  85 F8      			sta.l	_ax
         02:CC87  84 F9      			sty.h	_ax
10491                        		 _load_vram.3
         02:CC89  82         			clx				; Offset to PCE VDC.
         02:CC8A  20 63 FF   			call	load_vram_x
10492                        	
10493                        		.dbg	line,	"include\init.c", 280; //--------------------------------------------------------------------------------------//
10494                        	
10495                        		.dbg	line,	"include\init.c", 281; //                               LOAD WEAPON + ARMOR TILES                              //
10496                        	
10497                        		.dbg	line,	"include\init.c", 282; //--------------------------------------------------------------------------------------//
10498                        	
10499                        		.dbg	line,	"include\init.c", 284; if(weapon_level == 1)
10500                        		__ld.umq	_weapon_level
         02:CC8D  AD 1E 23   			lda	_weapon_level
10501                        		__equ_b.uiq	1
         02:CC90  C9 01      			cmp	#1
         02:CC92  F0 01      			beq	!+
         02:CC94  18         			clc
         02:CC95             	!:
10502                        		__bfalse	.LL456
         02:CC95  90 27      			bcc	.LL456
10503                        	
10504                        		.dbg	line,	"include\init.c", 285; {
10505                        	
10506                        		.dbg	line,	"include\init.c", 286; load_vram( WEAPON_VRAM_ADR, tileset_WEAPON_1, SIZEOF(tileset_WEAPON_1) >> 1 );
10507                        		__st.wmiq	4256, _di
         02:CC97  A9 A0      			lda.l	#4256
         02:CC99  85 F0      			sta.l	_di
         02:CC9B  A9 10      			lda.h	#4256
         02:CC9D  85 F1      			sta.h	_di
10508                        		__farptr	_tileset_WEAPON_1, _bp_bank, _bp
         02:CC9F  A9 00      			lda.l	#$6000 + ($1FFF & (_tileset_WEAPON_1))
         02:CCA1  85 EC      			sta.l	_bp
         02:CCA3  A9 77      			lda.h	#$6000 + ($1FFF & (_tileset_WEAPON_1))
         02:CCA5  85 ED      			sta.h	_bp
         02:CCA7  A9 03      			lda	#bank(_tileset_WEAPON_1)
         02:CCA9  85 02      			sta	_bp_bank
10509                        		__ld.wi		___sizeof__tileset_WEAPON_1
         02:CCAB  A9 80      			lda.l	#___sizeof__tileset_WEAPON_1
         02:CCAD  A0 00      			ldy.h	#___sizeof__tileset_WEAPON_1
10510                        		__lsr.wi	1
         02:CCAF  42         			say
         02:CCB0  4A         			lsr	a
         02:CCB1  42         			say
         02:CCB2  6A         			ror	a
10511                        		__st.wmq	_ax
         02:CCB3  85 F8      			sta.l	_ax
         02:CCB5  84 F9      			sty.h	_ax
10512                        		 _load_vram.3
         02:CCB7  82         			clx				; Offset to PCE VDC.
         02:CCB8  20 63 FF   			call	load_vram_x
10513                        	
10514                        		.dbg	line,	"include\init.c", 287; }
10515                        	
10516                        		.dbg	line,	"include\init.c", 289; else if(weapon_level == 2)
10517                        		__bra		.LL457
         02:CCBB  4C 7D CD   			bra	.LL457
10518    02:CCBE             	.LL456:
10519                        		__ld.umq	_weapon_level
         02:CCBE  AD 1E 23   			lda	_weapon_level
10520                        		__equ_b.uiq	2
         02:CCC1  C9 02      			cmp	#2
         02:CCC3  F0 01      			beq	!+
         02:CCC5  18         			clc
         02:CCC6             	!:
10521                        		__bfalse	.LL458
         02:CCC6  90 27      			bcc	.LL458
10522                        	
10523                        		.dbg	line,	"include\init.c", 290; {
10524                        	
10525                        		.dbg	line,	"include\init.c", 291; load_vram( WEAPON_VRAM_ADR, tileset_WEAPON_2, SIZEOF(tileset_WEAPON_2) >> 1 );
10526                        		__st.wmiq	4256, _di
         02:CCC8  A9 A0      			lda.l	#4256
         02:CCCA  85 F0      			sta.l	_di
         02:CCCC  A9 10      			lda.h	#4256
         02:CCCE  85 F1      			sta.h	_di
10527                        		__farptr	_tileset_WEAPON_2, _bp_bank, _bp
         02:CCD0  A9 80      			lda.l	#$6000 + ($1FFF & (_tileset_WEAPON_2))
         02:CCD2  85 EC      			sta.l	_bp
         02:CCD4  A9 77      			lda.h	#$6000 + ($1FFF & (_tileset_WEAPON_2))
         02:CCD6  85 ED      			sta.h	_bp
         02:CCD8  A9 03      			lda	#bank(_tileset_WEAPON_2)
         02:CCDA  85 02      			sta	_bp_bank
10528                        		__ld.wi		___sizeof__tileset_WEAPON_2
         02:CCDC  A9 80      			lda.l	#___sizeof__tileset_WEAPON_2
         02:CCDE  A0 00      			ldy.h	#___sizeof__tileset_WEAPON_2
10529                        		__lsr.wi	1
         02:CCE0  42         			say
         02:CCE1  4A         			lsr	a
         02:CCE2  42         			say
         02:CCE3  6A         			ror	a
10530                        		__st.wmq	_ax
         02:CCE4  85 F8      			sta.l	_ax
         02:CCE6  84 F9      			sty.h	_ax
10531                        		 _load_vram.3
         02:CCE8  82         			clx				; Offset to PCE VDC.
         02:CCE9  20 63 FF   			call	load_vram_x
10532                        	
10533                        		.dbg	line,	"include\init.c", 292; }
10534                        	
10535                        		.dbg	line,	"include\init.c", 294; else if(weapon_level == 3)
10536                        		__bra		.LL459
         02:CCEC  4C 7D CD   			bra	.LL459
10537    02:CCEF             	.LL458:
10538                        		__ld.umq	_weapon_level
         02:CCEF  AD 1E 23   			lda	_weapon_level
10539                        		__equ_b.uiq	3
         02:CCF2  C9 03      			cmp	#3
         02:CCF4  F0 01      			beq	!+
         02:CCF6  18         			clc
         02:CCF7             	!:
10540                        		__bfalse	.LL460
         02:CCF7  90 26      			bcc	.LL460
10541                        	
10542                        		.dbg	line,	"include\init.c", 295; {
10543                        	
10544                        		.dbg	line,	"include\init.c", 296; load_vram( WEAPON_VRAM_ADR, tileset_WEAPON_4, SIZEOF(tileset_WEAPON_4) >> 1 );
10545                        		__st.wmiq	4256, _di
         02:CCF9  A9 A0      			lda.l	#4256
         02:CCFB  85 F0      			sta.l	_di
         02:CCFD  A9 10      			lda.h	#4256
         02:CCFF  85 F1      			sta.h	_di
10546                        		__farptr	_tileset_WEAPON_4, _bp_bank, _bp
         02:CD01  A9 00      			lda.l	#$6000 + ($1FFF & (_tileset_WEAPON_4))
         02:CD03  85 EC      			sta.l	_bp
         02:CD05  A9 78      			lda.h	#$6000 + ($1FFF & (_tileset_WEAPON_4))
         02:CD07  85 ED      			sta.h	_bp
         02:CD09  A9 03      			lda	#bank(_tileset_WEAPON_4)
         02:CD0B  85 02      			sta	_bp_bank
10547                        		__ld.wi		___sizeof__tileset_WEAPON_4
         02:CD0D  A9 80      			lda.l	#___sizeof__tileset_WEAPON_4
         02:CD0F  A0 00      			ldy.h	#___sizeof__tileset_WEAPON_4
10548                        		__lsr.wi	1
         02:CD11  42         			say
         02:CD12  4A         			lsr	a
         02:CD13  42         			say
         02:CD14  6A         			ror	a
10549                        		__st.wmq	_ax
         02:CD15  85 F8      			sta.l	_ax
         02:CD17  84 F9      			sty.h	_ax
10550                        		 _load_vram.3
         02:CD19  82         			clx				; Offset to PCE VDC.
         02:CD1A  20 63 FF   			call	load_vram_x
10551                        	
10552                        		.dbg	line,	"include\init.c", 297; }
10553                        	
10554                        		.dbg	line,	"include\init.c", 299; else if(weapon_level == 4)
10555                        		__bra		.LL461
         02:CD1D  80 5E      			bra	.LL461
10556    02:CD1F             	.LL460:
10557                        		__ld.umq	_weapon_level
         02:CD1F  AD 1E 23   			lda	_weapon_level
10558                        		__equ_b.uiq	4
         02:CD22  C9 04      			cmp	#4
         02:CD24  F0 01      			beq	!+
         02:CD26  18         			clc
         02:CD27             	!:
10559                        		__bfalse	.LL462
         02:CD27  90 26      			bcc	.LL462
10560                        	
10561                        		.dbg	line,	"include\init.c", 300; {
10562                        	
10563                        		.dbg	line,	"include\init.c", 301; load_vram( WEAPON_VRAM_ADR, tileset_WEAPON_5, SIZEOF(tileset_WEAPON_5) >> 1 );
10564                        		__st.wmiq	4256, _di
         02:CD29  A9 A0      			lda.l	#4256
         02:CD2B  85 F0      			sta.l	_di
         02:CD2D  A9 10      			lda.h	#4256
         02:CD2F  85 F1      			sta.h	_di
10565                        		__farptr	_tileset_WEAPON_5, _bp_bank, _bp
         02:CD31  A9 80      			lda.l	#$6000 + ($1FFF & (_tileset_WEAPON_5))
         02:CD33  85 EC      			sta.l	_bp
         02:CD35  A9 78      			lda.h	#$6000 + ($1FFF & (_tileset_WEAPON_5))
         02:CD37  85 ED      			sta.h	_bp
         02:CD39  A9 03      			lda	#bank(_tileset_WEAPON_5)
         02:CD3B  85 02      			sta	_bp_bank
10566                        		__ld.wi		___sizeof__tileset_WEAPON_5
         02:CD3D  A9 80      			lda.l	#___sizeof__tileset_WEAPON_5
         02:CD3F  A0 00      			ldy.h	#___sizeof__tileset_WEAPON_5
10567                        		__lsr.wi	1
         02:CD41  42         			say
         02:CD42  4A         			lsr	a
         02:CD43  42         			say
         02:CD44  6A         			ror	a
10568                        		__st.wmq	_ax
         02:CD45  85 F8      			sta.l	_ax
         02:CD47  84 F9      			sty.h	_ax
10569                        		 _load_vram.3
         02:CD49  82         			clx				; Offset to PCE VDC.
         02:CD4A  20 63 FF   			call	load_vram_x
10570                        	
10571                        		.dbg	line,	"include\init.c", 302; }
10572                        	
10573                        		.dbg	line,	"include\init.c", 304; else if(weapon_level == 5)
10574                        		__bra		.LL463
         02:CD4D  80 2E      			bra	.LL463
10575    02:CD4F             	.LL462:
10576                        		__ld.umq	_weapon_level
         02:CD4F  AD 1E 23   			lda	_weapon_level
10577                        		__equ_b.uiq	5
         02:CD52  C9 05      			cmp	#5
         02:CD54  F0 01      			beq	!+
         02:CD56  18         			clc
         02:CD57             	!:
10578                        		__bfalse	.LL464
         02:CD57  90 24      			bcc	.LL464
10579                        	
10580                        		.dbg	line,	"include\init.c", 305; {
10581                        	
10582                        		.dbg	line,	"include\init.c", 306; load_vram( WEAPON_VRAM_ADR, tileset_WEAPON_8, SIZEOF(tileset_WEAPON_8) >> 1 );
10583                        		__st.wmiq	4256, _di
         02:CD59  A9 A0      			lda.l	#4256
         02:CD5B  85 F0      			sta.l	_di
         02:CD5D  A9 10      			lda.h	#4256
         02:CD5F  85 F1      			sta.h	_di
10584                        		__farptr	_tileset_WEAPON_8, _bp_bank, _bp
         02:CD61  A9 00      			lda.l	#$6000 + ($1FFF & (_tileset_WEAPON_8))
         02:CD63  85 EC      			sta.l	_bp
         02:CD65  A9 79      			lda.h	#$6000 + ($1FFF & (_tileset_WEAPON_8))
         02:CD67  85 ED      			sta.h	_bp
         02:CD69  A9 03      			lda	#bank(_tileset_WEAPON_8)
         02:CD6B  85 02      			sta	_bp_bank
10585                        		__ld.wi		___sizeof__tileset_WEAPON_8
         02:CD6D  A9 80      			lda.l	#___sizeof__tileset_WEAPON_8
         02:CD6F  A0 00      			ldy.h	#___sizeof__tileset_WEAPON_8
10586                        		__lsr.wi	1
         02:CD71  42         			say
         02:CD72  4A         			lsr	a
         02:CD73  42         			say
         02:CD74  6A         			ror	a
10587                        		__st.wmq	_ax
         02:CD75  85 F8      			sta.l	_ax
         02:CD77  84 F9      			sty.h	_ax
10588                        		 _load_vram.3
         02:CD79  82         			clx				; Offset to PCE VDC.
         02:CD7A  20 63 FF   			call	load_vram_x
10589                        	
10590                        		.dbg	line,	"include\init.c", 307; }
10591                        	
10592                        		.dbg	line,	"include\init.c", 312; if(armor_level == 1)
10593    02:CD7D             	.LL464:
10594    02:CD7D             	.LL463:
10595    02:CD7D             	.LL461:
10596    02:CD7D             	.LL459:
10597    02:CD7D             	.LL457:
10598                        		__ld.umq	_armor_level
         02:CD7D  AD 1D 23   			lda	_armor_level
10599                        		__equ_b.uiq	1
         02:CD80  C9 01      			cmp	#1
         02:CD82  F0 01      			beq	!+
         02:CD84  18         			clc
         02:CD85             	!:
10600                        		__bfalse	.LL465
         02:CD85  90 27      			bcc	.LL465
10601                        	
10602                        		.dbg	line,	"include\init.c", 313; {
10603                        	
10604                        		.dbg	line,	"include\init.c", 314; load_vram( ARMOR_VRAM_ADR, tileset_ARMOR_1, SIZEOF(tileset_ARMOR_1) >> 1 );
10605                        		__st.wmiq	4320, _di
         02:CD87  A9 E0      			lda.l	#4320
         02:CD89  85 F0      			sta.l	_di
         02:CD8B  A9 10      			lda.h	#4320
         02:CD8D  85 F1      			sta.h	_di
10606                        		__farptr	_tileset_ARMOR_1, _bp_bank, _bp
         02:CD8F  A9 00      			lda.l	#$6000 + ($1FFF & (_tileset_ARMOR_1))
         02:CD91  85 EC      			sta.l	_bp
         02:CD93  A9 75      			lda.h	#$6000 + ($1FFF & (_tileset_ARMOR_1))
         02:CD95  85 ED      			sta.h	_bp
         02:CD97  A9 03      			lda	#bank(_tileset_ARMOR_1)
         02:CD99  85 02      			sta	_bp_bank
10607                        		__ld.wi		___sizeof__tileset_ARMOR_1
         02:CD9B  A9 80      			lda.l	#___sizeof__tileset_ARMOR_1
         02:CD9D  A0 00      			ldy.h	#___sizeof__tileset_ARMOR_1
10608                        		__lsr.wi	1
         02:CD9F  42         			say
         02:CDA0  4A         			lsr	a
         02:CDA1  42         			say
         02:CDA2  6A         			ror	a
10609                        		__st.wmq	_ax
         02:CDA3  85 F8      			sta.l	_ax
         02:CDA5  84 F9      			sty.h	_ax
10610                        		 _load_vram.3
         02:CDA7  82         			clx				; Offset to PCE VDC.
         02:CDA8  20 63 FF   			call	load_vram_x
10611                        	
10612                        		.dbg	line,	"include\init.c", 315; }
10613                        	
10614                        		.dbg	line,	"include\init.c", 317; else if(armor_level == 2)
10615                        		__bra		.LL466
         02:CDAB  4C 3C CE   			bra	.LL466
10616    02:CDAE             	.LL465:
10617                        		__ld.umq	_armor_level
         02:CDAE  AD 1D 23   			lda	_armor_level
10618                        		__equ_b.uiq	2
         02:CDB1  C9 02      			cmp	#2
         02:CDB3  F0 01      			beq	!+
         02:CDB5  18         			clc
         02:CDB6             	!:
10619                        		__bfalse	.LL467
         02:CDB6  90 26      			bcc	.LL467
10620                        	
10621                        		.dbg	line,	"include\init.c", 318; {
10622                        	
10623                        		.dbg	line,	"include\init.c", 319; load_vram( ARMOR_VRAM_ADR, tileset_ARMOR_2, SIZEOF(tileset_ARMOR_2) >> 1 );
10624                        		__st.wmiq	4320, _di
         02:CDB8  A9 E0      			lda.l	#4320
         02:CDBA  85 F0      			sta.l	_di
         02:CDBC  A9 10      			lda.h	#4320
         02:CDBE  85 F1      			sta.h	_di
10625                        		__farptr	_tileset_ARMOR_2, _bp_bank, _bp
         02:CDC0  A9 80      			lda.l	#$6000 + ($1FFF & (_tileset_ARMOR_2))
         02:CDC2  85 EC      			sta.l	_bp
         02:CDC4  A9 75      			lda.h	#$6000 + ($1FFF & (_tileset_ARMOR_2))
         02:CDC6  85 ED      			sta.h	_bp
         02:CDC8  A9 03      			lda	#bank(_tileset_ARMOR_2)
         02:CDCA  85 02      			sta	_bp_bank
10626                        		__ld.wi		___sizeof__tileset_ARMOR_2
         02:CDCC  A9 80      			lda.l	#___sizeof__tileset_ARMOR_2
         02:CDCE  A0 00      			ldy.h	#___sizeof__tileset_ARMOR_2
10627                        		__lsr.wi	1
         02:CDD0  42         			say
         02:CDD1  4A         			lsr	a
         02:CDD2  42         			say
         02:CDD3  6A         			ror	a
10628                        		__st.wmq	_ax
         02:CDD4  85 F8      			sta.l	_ax
         02:CDD6  84 F9      			sty.h	_ax
10629                        		 _load_vram.3
         02:CDD8  82         			clx				; Offset to PCE VDC.
         02:CDD9  20 63 FF   			call	load_vram_x
10630                        	
10631                        		.dbg	line,	"include\init.c", 320; }
10632                        	
10633                        		.dbg	line,	"include\init.c", 322; else if(armor_level == 3)
10634                        		__bra		.LL468
         02:CDDC  80 5E      			bra	.LL468
10635    02:CDDE             	.LL467:
10636                        		__ld.umq	_armor_level
         02:CDDE  AD 1D 23   			lda	_armor_level
10637                        		__equ_b.uiq	3
         02:CDE1  C9 03      			cmp	#3
         02:CDE3  F0 01      			beq	!+
         02:CDE5  18         			clc
         02:CDE6             	!:
10638                        		__bfalse	.LL469
         02:CDE6  90 26      			bcc	.LL469
10639                        	
10640                        		.dbg	line,	"include\init.c", 323; {
10641                        	
10642                        		.dbg	line,	"include\init.c", 324; load_vram( ARMOR_VRAM_ADR, tileset_ARMOR_4, SIZEOF(tileset_ARMOR_4) >> 1 );
10643                        		__st.wmiq	4320, _di
         02:CDE8  A9 E0      			lda.l	#4320
         02:CDEA  85 F0      			sta.l	_di
         02:CDEC  A9 10      			lda.h	#4320
         02:CDEE  85 F1      			sta.h	_di
10644                        		__farptr	_tileset_ARMOR_4, _bp_bank, _bp
         02:CDF0  A9 00      			lda.l	#$6000 + ($1FFF & (_tileset_ARMOR_4))
         02:CDF2  85 EC      			sta.l	_bp
         02:CDF4  A9 76      			lda.h	#$6000 + ($1FFF & (_tileset_ARMOR_4))
         02:CDF6  85 ED      			sta.h	_bp
         02:CDF8  A9 03      			lda	#bank(_tileset_ARMOR_4)
         02:CDFA  85 02      			sta	_bp_bank
10645                        		__ld.wi		___sizeof__tileset_ARMOR_4
         02:CDFC  A9 80      			lda.l	#___sizeof__tileset_ARMOR_4
         02:CDFE  A0 00      			ldy.h	#___sizeof__tileset_ARMOR_4
10646                        		__lsr.wi	1
         02:CE00  42         			say
         02:CE01  4A         			lsr	a
         02:CE02  42         			say
         02:CE03  6A         			ror	a
10647                        		__st.wmq	_ax
         02:CE04  85 F8      			sta.l	_ax
         02:CE06  84 F9      			sty.h	_ax
10648                        		 _load_vram.3
         02:CE08  82         			clx				; Offset to PCE VDC.
         02:CE09  20 63 FF   			call	load_vram_x
10649                        	
10650                        		.dbg	line,	"include\init.c", 325; }
10651                        	
10652                        		.dbg	line,	"include\init.c", 327; else if(armor_level == 4)
10653                        		__bra		.LL470
         02:CE0C  80 2E      			bra	.LL470
10654    02:CE0E             	.LL469:
10655                        		__ld.umq	_armor_level
         02:CE0E  AD 1D 23   			lda	_armor_level
10656                        		__equ_b.uiq	4
         02:CE11  C9 04      			cmp	#4
         02:CE13  F0 01      			beq	!+
         02:CE15  18         			clc
         02:CE16             	!:
10657                        		__bfalse	.LL471
         02:CE16  90 24      			bcc	.LL471
10658                        	
10659                        		.dbg	line,	"include\init.c", 328; {
10660                        	
10661                        		.dbg	line,	"include\init.c", 329; load_vram( ARMOR_VRAM_ADR, tileset_ARMOR_8, SIZEOF(tileset_ARMOR_8) >> 1 );
10662                        		__st.wmiq	4320, _di
         02:CE18  A9 E0      			lda.l	#4320
         02:CE1A  85 F0      			sta.l	_di
         02:CE1C  A9 10      			lda.h	#4320
         02:CE1E  85 F1      			sta.h	_di
10663                        		__farptr	_tileset_ARMOR_8, _bp_bank, _bp
         02:CE20  A9 80      			lda.l	#$6000 + ($1FFF & (_tileset_ARMOR_8))
         02:CE22  85 EC      			sta.l	_bp
         02:CE24  A9 76      			lda.h	#$6000 + ($1FFF & (_tileset_ARMOR_8))
         02:CE26  85 ED      			sta.h	_bp
         02:CE28  A9 03      			lda	#bank(_tileset_ARMOR_8)
         02:CE2A  85 02      			sta	_bp_bank
10664                        		__ld.wi		___sizeof__tileset_ARMOR_8
         02:CE2C  A9 80      			lda.l	#___sizeof__tileset_ARMOR_8
         02:CE2E  A0 00      			ldy.h	#___sizeof__tileset_ARMOR_8
10665                        		__lsr.wi	1
         02:CE30  42         			say
         02:CE31  4A         			lsr	a
         02:CE32  42         			say
         02:CE33  6A         			ror	a
10666                        		__st.wmq	_ax
         02:CE34  85 F8      			sta.l	_ax
         02:CE36  84 F9      			sty.h	_ax
10667                        		 _load_vram.3
         02:CE38  82         			clx				; Offset to PCE VDC.
         02:CE39  20 63 FF   			call	load_vram_x
10668                        	
10669                        		.dbg	line,	"include\init.c", 330; }
10670                        	
10671                        		.dbg	line,	"include\init.c", 335; //--------------------------------------------------------------------------------------//
10672                        	
10673                        		.dbg	line,	"include\init.c", 336; //                                     SET MULTIMAP                                     //
10674                        	
10675                        		.dbg	line,	"include\init.c", 337; //--------------------------------------------------------------------------------------//
10676                        	
10677                        		.dbg	line,	"include\init.c", 339; // multimap is 2 screens wide //
10678                        	
10679                        		.dbg	line,	"include\init.c", 340; set_multimap( multimap_LV1_BG_A , 5 );
10680    02:CE3C             	.LL471:
10681    02:CE3C             	.LL470:
10682    02:CE3C             	.LL468:
10683    02:CE3C             	.LL466:
10684                        		__farptr	_multimap_LV1_BG_A, vdc_scr_bank, vdc_scr_addr
         02:CE3C  A9 00      			lda.l	#$6000 + ($1FFF & (_multimap_LV1_BG_A))
         02:CE3E  8D B2 2B   			sta.l	vdc_scr_addr
         02:CE41  A9 78      			lda.h	#$6000 + ($1FFF & (_multimap_LV1_BG_A))
         02:CE43  8D B3 2B   			sta.h	vdc_scr_addr
         02:CE46  A9 0B      			lda	#bank(_multimap_LV1_BG_A)
         02:CE48  8D B4 2B   			sta	vdc_scr_bank
10685                        		__st.umiq	5, vdc_map_scrn_w
         02:CE4B  A9 05      			lda.l	#5
         02:CE4D  8D 73 26   			sta	vdc_map_scrn_w
10686                        		 _set_multimap.2
         02:CE50  AD 6B 26   			lda	vdc_bat_width
         02:CE53  4A         			lsr	a
         02:CE54  8D 72 26   			sta	vdc_map_line_w
10687                        	
10688                        		.dbg	line,	"include\init.c", 343; //--------------------------------------------------------------------------------------//
10689                        	
10690                        		.dbg	line,	"include\init.c", 344; //                                    DRAW TILEMAP                                      //
10691                        	
10692                        		.dbg	line,	"include\init.c", 345; //--------------------------------------------------------------------------------------//
10693                        	
10694                        		.dbg	line,	"include\init.c", 347; // The blkmap is drawn using global variables for the top-left coordinate
10695                        	
10696                        		.dbg	line,	"include\init.c", 348; // in pixels, and the draw width and height in terms of 8x8 characters.
10697                        	
10698                        		.dbg	line,	"include\init.c", 350; vdc_map_pxl_x = 0;
10699                        		__st.wmiq	0, _vdc_map_pxl_x
         02:CE57  9C 74 26   			stz.l	_vdc_map_pxl_x
         02:CE5A  9C 75 26   			stz.h	_vdc_map_pxl_x
10700                        	
10701                        		.dbg	line,	"include\init.c", 351; vdc_map_pxl_y = 0;
10702                        		__st.wmiq	0, _vdc_map_pxl_y
         02:CE5D  9C 76 26   			stz.l	_vdc_map_pxl_y
         02:CE60  9C 77 26   			stz.h	_vdc_map_pxl_y
10703                        	
10704                        		.dbg	line,	"include\init.c", 353; vdc_map_draw_w = 32;
10705                        		__st.umiq	32, _vdc_map_draw_w
         02:CE63  A9 20      			lda.l	#32
         02:CE65  8D 70 26   			sta	_vdc_map_draw_w
10706                        	
10707                        		.dbg	line,	"include\init.c", 354; vdc_map_draw_h = 28;
10708                        		__st.umiq	28, _vdc_map_draw_h
         02:CE68  A9 1C      			lda.l	#28
         02:CE6A  8D 71 26   			sta	_vdc_map_draw_h
10709                        	
10710                        		.dbg	line,	"include\init.c", 356; draw_map();
10711                        		__call		_draw_map
         02:CE6D  20 13 FF   			call	_draw_map
10712                        	
10713                        		.dbg	line,	"include\init.c", 358; display_SCORE();
10714                        		__call		_display_SCORE
         02:CE70  20 09 FF   			call	_display_SCORE
10715                        	
10716                        		.dbg	line,	"include\init.c", 359; display_TIME();
10717                        		__call		_display_TIME
         02:CE73  20 FF FE   			call	_display_TIME
10718                        	
10719                        		.dbg	line,	"include\init.c", 360; display_KEY();
10720                        		__call		_display_KEY
         02:CE76  20 8B FF   			call	_display_KEY
10721                        	
10722                        		.dbg	line,	"include\init.c", 361; display_POTION();
10723                        		__call		_display_POTION
         02:CE79  20 3B FF   			call	_display_POTION
10724                        	
10725                        		.dbg	line,	"include\init.c", 362; display_ZENNY();
10726                        		__call		_display_ZENNY
         02:CE7C  20 45 FF   			call	_display_ZENNY
10727                        	
10728                        		.dbg	line,	"include\init.c", 363; }
10729    02:CE7F             	.LL455:
10730                        		__return	0
         02:CE7F  4C EF FF   			jmp	leave_proc
10731                        		.dbg	clear
10732                        		.endp
10733                        		.pceas
10734                        	
10735                        		.dbg	line,	"include\init.c", 366; void init_LEVEL()
10736                        		.dbg	line,	"include\init.c", 367; {
10737                        	;***********************
10738                        	;***********************
10739                        	
10740                        		.hucc
10741    02:D3C1             		.proc		_init_LEVEL
10742                        		__enter		_init_LEVEL
10743                        	
10744                        		.dbg	line,	"include\init.c", 368; if(level_id == 1)
10745                        		__ld.umq	_level_id
         02:D3C1  AD 12 23   			lda	_level_id
10746                        		__equ_b.uiq	1
         02:D3C4  C9 01      			cmp	#1
         02:D3C6  F0 01      			beq	!+
         02:D3C8  18         			clc
         02:D3C9             	!:
10747                        		__bfalse	.LL473
         02:D3C9  B0 03 4C E9			bcc	.LL473
         02:D3CD  D5          
10748                        	
10749                        		.dbg	line,	"include\init.c", 369; {
10750                        	
10751                        		.dbg	line,	"include\init.c", 370; // VSYNC //
10752                        	
10753                        		.dbg	line,	"include\init.c", 371; vsync();
10754                        		__call		_vsync
         02:D3CE  20 09 E3   			call	_vsync
10755                        	
10756                        		.dbg	line,	"include\init.c", 374; // DISABLE DISPLAY //
10757                        	
10758                        		.dbg	line,	"include\init.c", 375; disp_off();
10759                        		__call		_disp_off
         02:D3D1  20 29 E4   			call	_disp_off
10760                        	
10761                        		.dbg	line,	"include\init.c", 378; // SET VDC 1 SCREEN SIZE (IN TILES) - 64x32 = 512x256 PIXELS
10762                        	
10763                        		.dbg	line,	"include\init.c", 379; set_screen_size(SCR_SIZE_64x32);
10764                        		__st.umiq	1, _al
         02:D3D4  A9 01      			lda.l	#1
         02:D3D6  85 F8      			sta	_al
10765                        		__call		_set_screen_size.1
         02:D3D8  20 27 FF   			call	_set_screen_size.1
10766                        	
10767                        		.dbg	line,	"include\init.c", 382; // SET VDC 2 SCREEN SIZE (IN TILES) - 64x32 = 512x256 PIXELS
10768                        	
10769                        		.dbg	line,	"include\init.c", 383; sgx_set_screen_size(SCR_SIZE_64x32);
10770                        		__st.umiq	1, _al
         02:D3DB  A9 01      			lda.l	#1
         02:D3DD  85 F8      			sta	_al
10771                        		__call		_sgx_set_screen_size.1
         02:D3DF  20 1D FF   			call	_sgx_set_screen_size.1
10772                        	
10773                        		.dbg	line,	"include\init.c", 386; // INIT SPRITE ATTRIBUTE TABLE //
10774                        	
10775                        		.dbg	line,	"include\init.c", 387; //init_satb();
10776                        	
10777                        		.dbg	line,	"include\init.c", 392; //**************************************************************************************//
10778                        	
10779                        		.dbg	line,	"include\init.c", 393; //                                                                                      //
10780                        	
10781                        		.dbg	line,	"include\init.c", 394; //                                      VARIABLES                                       //
10782                        	
10783                        		.dbg	line,	"include\init.c", 395; //                                                                                      //
10784                        	
10785                        		.dbg	line,	"include\init.c", 396; //**************************************************************************************//
10786                        	
10787                        		.dbg	line,	"include\init.c", 398; camera_max_y_position = 768;
10788                        		__st.wmiq	768, _camera_max_y_position
         02:D3E2  9C CC 24   			stz.l	_camera_max_y_position
         02:D3E5  A9 03      			lda.h	#768
         02:D3E7  8D CD 24   			sta.h	_camera_max_y_position
10789                        	
10790                        		.dbg	line,	"include\init.c", 399; jump_max_index = 34;
10791                        		__st.umiq	34, _jump_max_index
         02:D3EA  A9 22      			lda.l	#34
         02:D3EC  8D 1C 23   			sta	_jump_max_index
10792                        	
10793                        		.dbg	line,	"include\init.c", 400; score = 0;
10794                        		__st.wmiq	0, _score
         02:D3EF  9C 24 26   			stz.l	_score
         02:D3F2  9C 25 26   			stz.h	_score
10795                        	
10796                        		.dbg	line,	"include\init.c", 401; level_object_number = OBJECT_NUMBER_LV1;
10797                        		__st.umiq	23, _level_object_number
         02:D3F5  A9 17      			lda.l	#23
         02:D3F7  8D 26 23   			sta	_level_object_number
10798                        	
10799                        		.dbg	line,	"include\init.c", 402; level_chest_number = CHEST_NUMBER_LV1;
10800                        		__st.umiq	2, _level_chest_number
         02:D3FA  A9 02      			lda.l	#2
         02:D3FC  8D 95 23   			sta	_level_chest_number
10801                        	
10802                        		.dbg	line,	"include\init.c", 403; level_npc_number = NPC_NUMBER_LV1;
10803                        		__st.umiq	2, _level_npc_number
         02:D3FF  A9 02      			lda.l	#2
         02:D401  8D A8 23   			sta	_level_npc_number
10804                        	
10805                        		.dbg	line,	"include\init.c", 404; object_start_index = OBJECT_START_INDEX_LV1;
10806                        		__st.umiq	3, _object_start_index
         02:D404  A9 03      			lda.l	#3
         02:D406  8D 25 23   			sta	_object_start_index
10807                        	
10808                        		.dbg	line,	"include\init.c", 405; chest_start_index = CHEST_START_INDEX_LV1;
10809                        		__st.umiq	26, _chest_start_index
         02:D409  A9 1A      			lda.l	#26
         02:D40B  8D 94 23   			sta	_chest_start_index
10810                        	
10811                        		.dbg	line,	"include\init.c", 406; npc_start_index = NPC_START_INDEX_LV1;
10812                        		__st.umiq	28, _npc_start_index
         02:D40E  A9 1C      			lda.l	#28
         02:D410  8D A7 23   			sta	_npc_start_index
10813                        	
10814                        		.dbg	line,	"include\init.c", 407; jump_ladder = FALSE;
10815                        		__st.umiq	0, _jump_ladder
         02:D413  9C 1B 23   			stz	_jump_ladder
10816                        	
10817                        		.dbg	line,	"include\init.c", 412; //**************************************************************************************//
10818                        	
10819                        		.dbg	line,	"include\init.c", 413; //                                                                                      //
10820                        	
10821                        		.dbg	line,	"include\init.c", 414; //                                        VDC 2                                         //
10822                        	
10823                        		.dbg	line,	"include\init.c", 415; //                                                                                      //
10824                        	
10825                        		.dbg	line,	"include\init.c", 416; //**************************************************************************************//
10826                        	
10827                        		.dbg	line,	"include\init.c", 418; //--------------------------------------------------------------------------------------//
10828                        	
10829                        		.dbg	line,	"include\init.c", 419; //                                    LOAD TILESET                                      //
10830                        	
10831                        		.dbg	line,	"include\init.c", 420; //--------------------------------------------------------------------------------------//
10832                        	
10833                        		.dbg	line,	"include\init.c", 422; sgx_load_vram( 0x1000, tileset_LV1_BG_B, SIZEOF(tileset_LV1_BG_B) >> 1 );
10834                        		__st.wmiq	4096, _di
         02:D416  64 F0      			stz.l	_di
         02:D418  A9 10      			lda.h	#4096
         02:D41A  85 F1      			sta.h	_di
10835                        		__farptr	_tileset_LV1_BG_B, _bp_bank, _bp
         02:D41C  A9 80      			lda.l	#$6000 + ($1FFF & (_tileset_LV1_BG_B))
         02:D41E  85 EC      			sta.l	_bp
         02:D420  A9 79      			lda.h	#$6000 + ($1FFF & (_tileset_LV1_BG_B))
         02:D422  85 ED      			sta.h	_bp
         02:D424  A9 03      			lda	#bank(_tileset_LV1_BG_B)
         02:D426  85 02      			sta	_bp_bank
10836                        		__ld.wi		___sizeof__tileset_LV1_BG_B
         02:D428  A9 E0      			lda.l	#___sizeof__tileset_LV1_BG_B
         02:D42A  A0 72      			ldy.h	#___sizeof__tileset_LV1_BG_B
10837                        		__lsr.wi	1
         02:D42C  42         			say
         02:D42D  4A         			lsr	a
         02:D42E  42         			say
         02:D42F  6A         			ror	a
10838                        		__st.wmq	_ax
         02:D430  85 F8      			sta.l	_ax
         02:D432  84 F9      			sty.h	_ax
10839                        		 _sgx_load_vram.3
         02:D434  A2 10      			ldx	#SGX_VDC_OFFSET		; Offset to SGX VDC.
         02:D436  20 63 FF   			call	load_vram_x
10840                        	
10841                        		.dbg	line,	"include\init.c", 425; //--------------------------------------------------------------------------------------//
10842                        	
10843                        		.dbg	line,	"include\init.c", 426; //                               LOAD WALL & DOOR TILES                                 //
10844                        	
10845                        		.dbg	line,	"include\init.c", 427; //--------------------------------------------------------------------------------------//
10846                        	
10847                        		.dbg	line,	"include\init.c", 429; sgx_load_vram( LV1_WALL_VRAM_ADR, tileset_LV1_WALL, SIZEOF(tileset_LV1_WALL) >> 1 );
10848                        		__st.wmiq	4096, _di
         02:D439  64 F0      			stz.l	_di
         02:D43B  A9 10      			lda.h	#4096
         02:D43D  85 F1      			sta.h	_di
10849                        		__farptr	_tileset_LV1_WALL, _bp_bank, _bp
         02:D43F  A9 00      			lda.l	#$6000 + ($1FFF & (_tileset_LV1_WALL))
         02:D441  85 EC      			sta.l	_bp
         02:D443  A9 6C      			lda.h	#$6000 + ($1FFF & (_tileset_LV1_WALL))
         02:D445  85 ED      			sta.h	_bp
         02:D447  A9 03      			lda	#bank(_tileset_LV1_WALL)
         02:D449  85 02      			sta	_bp_bank
10850                        		__ld.wi		___sizeof__tileset_LV1_WALL
         02:D44B  A9 00      			lda.l	#___sizeof__tileset_LV1_WALL
         02:D44D  A0 02      			ldy.h	#___sizeof__tileset_LV1_WALL
10851                        		__lsr.wi	1
         02:D44F  42         			say
         02:D450  4A         			lsr	a
         02:D451  42         			say
         02:D452  6A         			ror	a
10852                        		__st.wmq	_ax
         02:D453  85 F8      			sta.l	_ax
         02:D455  84 F9      			sty.h	_ax
10853                        		 _sgx_load_vram.3
         02:D457  A2 10      			ldx	#SGX_VDC_OFFSET		; Offset to SGX VDC.
         02:D459  20 63 FF   			call	load_vram_x
10854                        	
10855                        		.dbg	line,	"include\init.c", 430; sgx_load_vram( LV1_DOOR_VRAM_ADR, tileset_LV1_DOOR_OPEN, SIZEOF(tileset_LV1_DOOR_OPEN) >> 1 );
10856                        		__st.wmiq	4352, _di
         02:D45C  64 F0      			stz.l	_di
         02:D45E  A9 11      			lda.h	#4352
         02:D460  85 F1      			sta.h	_di
10857                        		__farptr	_tileset_LV1_DOOR_OPEN, _bp_bank, _bp
         02:D462  A9 00      			lda.l	#$6000 + ($1FFF & (_tileset_LV1_DOOR_OPEN))
         02:D464  85 EC      			sta.l	_bp
         02:D466  A9 6E      			lda.h	#$6000 + ($1FFF & (_tileset_LV1_DOOR_OPEN))
         02:D468  85 ED      			sta.h	_bp
         02:D46A  A9 03      			lda	#bank(_tileset_LV1_DOOR_OPEN)
         02:D46C  85 02      			sta	_bp_bank
10858                        		__ld.wi		___sizeof__tileset_LV1_DOOR_OPEN
         02:D46E  A9 00      			lda.l	#___sizeof__tileset_LV1_DOOR_OPEN
         02:D470  A0 03      			ldy.h	#___sizeof__tileset_LV1_DOOR_OPEN
10859                        		__lsr.wi	1
         02:D472  42         			say
         02:D473  4A         			lsr	a
         02:D474  42         			say
         02:D475  6A         			ror	a
10860                        		__st.wmq	_ax
         02:D476  85 F8      			sta.l	_ax
         02:D478  84 F9      			sty.h	_ax
10861                        		 _sgx_load_vram.3
         02:D47A  A2 10      			ldx	#SGX_VDC_OFFSET		; Offset to SGX VDC.
         02:D47C  20 63 FF   			call	load_vram_x
10862                        	
10863                        		.dbg	line,	"include\init.c", 433; //--------------------------------------------------------------------------------------//
10864                        	
10865                        		.dbg	line,	"include\init.c", 434; //                                     SET MULTIMAP                                     //
10866                        	
10867                        		.dbg	line,	"include\init.c", 435; //--------------------------------------------------------------------------------------//
10868                        	
10869                        		.dbg	line,	"include\init.c", 437; // multimap is 5 screens wide //
10870                        	
10871                        		.dbg	line,	"include\init.c", 438; sgx_set_multimap( multimap_LV1_BG_B , 5 );
10872                        		__farptr	_multimap_LV1_BG_B, sgx_scr_bank, sgx_scr_addr
         02:D47F  A9 00      			lda.l	#$6000 + ($1FFF & (_multimap_LV1_BG_B))
         02:D481  8D C2 2B   			sta.l	sgx_scr_addr
         02:D484  A9 79      			lda.h	#$6000 + ($1FFF & (_multimap_LV1_BG_B))
         02:D486  8D C3 2B   			sta.h	sgx_scr_addr
         02:D489  A9 09      			lda	#bank(_multimap_LV1_BG_B)
         02:D48B  8D C4 2B   			sta	sgx_scr_bank
10873                        		__st.umiq	5, sgx_map_scrn_w
         02:D48E  A9 05      			lda.l	#5
         02:D490  8D 83 26   			sta	sgx_map_scrn_w
10874                        		 _sgx_set_multimap.2
         02:D493  AD 7B 26   			lda	sgx_bat_width
         02:D496  4A         			lsr	a
         02:D497  8D 82 26   			sta	sgx_map_line_w
10875                        	
10876                        		.dbg	line,	"include\init.c", 441; //--------------------------------------------------------------------------------------//
10877                        	
10878                        		.dbg	line,	"include\init.c", 442; //                                    DRAW TILEMAP                                      //
10879                        	
10880                        		.dbg	line,	"include\init.c", 443; //--------------------------------------------------------------------------------------//
10881                        	
10882                        		.dbg	line,	"include\init.c", 445; // The blkmap is drawn using global variables for the top-left coordinate
10883                        	
10884                        		.dbg	line,	"include\init.c", 446; // in pixels, and the draw width and height in terms of 8x8 characters.
10885                        	
10886                        		.dbg	line,	"include\init.c", 448; if(respawn == FALSE)
10887                        		__not.um	_respawn
         02:D49A  AD 13 23   			lda	_respawn
         02:D49D  18         			clc
         02:D49E  D0 01      			bne	!+
         02:D4A0  38         			sec
         02:D4A1             	!:
10888                        		__bfalse	.LL474
         02:D4A1  90 12      			bcc	.LL474
10889                        	
10890                        		.dbg	line,	"include\init.c", 449; {
10891                        	
10892                        		.dbg	line,	"include\init.c", 450; sgx_map_pxl_x = 96;
10893                        		__st.wmiq	96, _sgx_map_pxl_x
         02:D4A3  A9 60      			lda.l	#96
         02:D4A5  8D 84 26   			sta.l	_sgx_map_pxl_x
         02:D4A8  9C 85 26   			stz.h	_sgx_map_pxl_x
10894                        	
10895                        		.dbg	line,	"include\init.c", 451; sgx_map_pxl_y = 768;
10896                        		__st.wmiq	768, _sgx_map_pxl_y
         02:D4AB  9C 86 26   			stz.l	_sgx_map_pxl_y
         02:D4AE  A9 03      			lda.h	#768
         02:D4B0  8D 87 26   			sta.h	_sgx_map_pxl_y
10897                        	
10898                        		.dbg	line,	"include\init.c", 452; }
10899                        	
10900                        		.dbg	line,	"include\init.c", 454; else if(respawn == RESPAWN_SHOP)
10901                        		__bra		.LL475
         02:D4B3  80 22      			bra	.LL475
10902    02:D4B5             	.LL474:
10903                        		__ld.umq	_respawn
         02:D4B5  AD 13 23   			lda	_respawn
10904                        		__equ_b.uiq	2
         02:D4B8  C9 02      			cmp	#2
         02:D4BA  F0 01      			beq	!+
         02:D4BC  18         			clc
         02:D4BD             	!:
10905                        		__bfalse	.LL476
         02:D4BD  90 18      			bcc	.LL476
10906                        	
10907                        		.dbg	line,	"include\init.c", 455; {
10908                        	
10909                        		.dbg	line,	"include\init.c", 456; sgx_map_pxl_x = camera_pos_x_backup;
10910                        		__ld.wm		_camera_pos_x_backup
         02:D4BF  AD CE 24   			lda.l	_camera_pos_x_backup
         02:D4C2  AC CF 24   			ldy.h	_camera_pos_x_backup
10911                        		__st.wmq	_sgx_map_pxl_x
         02:D4C5  8D 84 26   			sta.l	_sgx_map_pxl_x
         02:D4C8  8C 85 26   			sty.h	_sgx_map_pxl_x
10912                        	
10913                        		.dbg	line,	"include\init.c", 457; sgx_map_pxl_y = camera_pos_y_backup;
10914                        		__ld.wm		_camera_pos_y_backup
         02:D4CB  AD D0 24   			lda.l	_camera_pos_y_backup
         02:D4CE  AC D1 24   			ldy.h	_camera_pos_y_backup
10915                        		__st.wmq	_sgx_map_pxl_y
         02:D4D1  8D 86 26   			sta.l	_sgx_map_pxl_y
         02:D4D4  8C 87 26   			sty.h	_sgx_map_pxl_y
10916                        	
10917                        		.dbg	line,	"include\init.c", 458; }
10918                        	
10919                        		.dbg	line,	"include\init.c", 461; sgx_map_draw_w = 63;
10920    02:D4D7             	.LL476:
10921    02:D4D7             	.LL475:
10922                        		__st.umiq	63, _sgx_map_draw_w
         02:D4D7  A9 3F      			lda.l	#63
         02:D4D9  8D 80 26   			sta	_sgx_map_draw_w
10923                        	
10924                        		.dbg	line,	"include\init.c", 462; sgx_map_draw_h = 29;
10925                        		__st.umiq	29, _sgx_map_draw_h
         02:D4DC  A9 1D      			lda.l	#29
         02:D4DE  8D 81 26   			sta	_sgx_map_draw_h
10926                        	
10927                        		.dbg	line,	"include\init.c", 464; sgx_draw_map();
10928                        		__call		_sgx_draw_map
         02:D4E1  20 F5 FE   			call	_sgx_draw_map
10929                        	
10930                        		.dbg	line,	"include\init.c", 469; //**************************************************************************************//
10931                        	
10932                        		.dbg	line,	"include\init.c", 470; //                                                                                      //
10933                        	
10934                        		.dbg	line,	"include\init.c", 471; //                                         HUD                                          //
10935                        	
10936                        		.dbg	line,	"include\init.c", 472; //                                                                                      //
10937                        	
10938                        		.dbg	line,	"include\init.c", 473; //**************************************************************************************//
10939                        	
10940                        		.dbg	line,	"include\init.c", 475; init_HUD();
10941                        		__call		_init_HUD
         02:D4E4  20 EB FE   			call	_init_HUD
10942                        	
10943                        		.dbg	line,	"include\init.c", 480; //**************************************************************************************//
10944                        	
10945                        		.dbg	line,	"include\init.c", 481; //                                                                                      //
10946                        	
10947                        		.dbg	line,	"include\init.c", 482; //                                  SETUP SCROLL_SPLIT                                  //
10948                        	
10949                        		.dbg	line,	"include\init.c", 483; //                                                                                      //
10950                        	
10951                        		.dbg	line,	"include\init.c", 484; //**************************************************************************************//
10952                        	
10953                        		.dbg	line,	"include\init.c", 486; //--------------------------------------------------------------------------------------//
10954                        	
10955                        		.dbg	line,	"include\init.c", 487; //                                        VDC 2                                         //
10956                        	
10957                        		.dbg	line,	"include\init.c", 488; //--------------------------------------------------------------------------------------//
10958                        	
10959                        		.dbg	line,	"include\init.c", 490; sgx_scroll_map();
10960                        		__call		_sgx_scroll_map
         02:D4E7  20 81 FF   			call	_sgx_scroll_map
10961                        	
10962                        		.dbg	line,	"include\init.c", 492; sgx_scroll_split(0,   0, sgx_map_pxl_x & (BAT_SIZE_W - 1), sgx_map_pxl_y & (BAT_SIZE_H - 1), BKG_ON | SPR_ON);
10963                        		__st.umiq	0, _al
         02:D4EA  64 F8      			stz	_al
10964                        		__st.umiq	0, _ah
         02:D4EC  64 F9      			stz	_ah
10965                        		__ld.wm		_sgx_map_pxl_x
         02:D4EE  AD 84 26   			lda.l	_sgx_map_pxl_x
         02:D4F1  AC 85 26   			ldy.h	_sgx_map_pxl_x
10966                        		__and.wi	2047
         02:D4F4  29 FF      			and.l	#2047
         02:D4F6  42         			say
         02:D4F7  29 07      			and.h	#2047
         02:D4F9  42         			say
10967                        		__st.wmq	_bx
         02:D4FA  85 FA      			sta.l	_bx
         02:D4FC  84 FB      			sty.h	_bx
10968                        		__ld.wm		_sgx_map_pxl_y
         02:D4FE  AD 86 26   			lda.l	_sgx_map_pxl_y
         02:D501  AC 87 26   			ldy.h	_sgx_map_pxl_y
10969                        		__and.wi	255
         02:D504  29 FF      			and	#255
         02:D506  C2         			cly
10970                        		__st.wmq	_cx
         02:D507  85 FC      			sta.l	_cx
         02:D509  84 FD      			sty.h	_cx
10971                        		__st.umiq	192, _dl
         02:D50B  A9 C0      			lda.l	#192
         02:D50D  85 FE      			sta	_dl
10972                        		__call		_sgx_scroll_split.5
         02:D50F  20 77 FF   			call	_sgx_scroll_split.5
10973                        	
10974                        		.dbg	line,	"include\init.c", 497; //--------------------------------------------------------------------------------------//
10975                        	
10976                        		.dbg	line,	"include\init.c", 498; //                                   LOAD BG PALETTES                                   //
10977                        	
10978                        		.dbg	line,	"include\init.c", 499; //--------------------------------------------------------------------------------------//
10979                        	
10980                        		.dbg	line,	"include\init.c", 501; // LOAD ALL PALETTES AT BG PALETTE 0 //
10981                        	
10982                        		.dbg	line,	"include\init.c", 502; load_palette( 0, palette_LV1, 16 );
10983                        		__st.umiq	0, _al
         02:D512  64 F8      			stz	_al
10984                        		__farptr	_palette_LV1, _bp_bank, _bp
         02:D514  A9 A0      			lda.l	#$6000 + ($1FFF & (_palette_LV1))
         02:D516  85 EC      			sta.l	_bp
         02:D518  A9 78      			lda.h	#$6000 + ($1FFF & (_palette_LV1))
         02:D51A  85 ED      			sta.h	_bp
         02:D51C  A9 0B      			lda	#bank(_palette_LV1)
         02:D51E  85 02      			sta	_bp_bank
10985                        		__st.umiq	16, _ah
         02:D520  A9 10      			lda.l	#16
         02:D522  85 F9      			sta	_ah
10986                        		__call		_load_palette.3
         02:D524  20 E1 FE   			call	_load_palette.3
10987                        	
10988                        		.dbg	line,	"include\init.c", 507; //**************************************************************************************//
10989                        	
10990                        		.dbg	line,	"include\init.c", 508; //                                                                                      //
10991                        	
10992                        		.dbg	line,	"include\init.c", 509; //                                       SPRITES                                        //
10993                        	
10994                        		.dbg	line,	"include\init.c", 510; //                                                                                      //
10995                        	
10996                        		.dbg	line,	"include\init.c", 511; //**************************************************************************************//
10997                        	
10998                        		.dbg	line,	"include\init.c", 513; //--------------------------------------------------------------------------------------//
10999                        	
11000                        		.dbg	line,	"include\init.c", 514; //                                        PLAYER                                        //
11001                        	
11002                        		.dbg	line,	"include\init.c", 515; //--------------------------------------------------------------------------------------//
11003                        	
11004                        		.dbg	line,	"include\init.c", 517; // LOAD PLAYER TILES //
11005                        	
11006                        		.dbg	line,	"include\init.c", 518; // 0x2000
11007                        	
11008                        		.dbg	line,	"include\init.c", 519; // 32 TILES = 512 //
11009                        	
11010                        		.dbg	line,	"include\init.c", 520; // LOAD PLAYER FIRST FRAME OF ANIMATION (IDLE)
11011                        	
11012                        		.dbg	line,	"include\init.c", 521; load_vram(PLAYER_VRAM_ADR, tiles_SPR_PLAYER , TILES_16);
11013                        		__st.wmiq	6144, _di
         02:D527  64 F0      			stz.l	_di
         02:D529  A9 18      			lda.h	#6144
         02:D52B  85 F1      			sta.h	_di
11014                        		__farptr	_tiles_SPR_PLAYER, _bp_bank, _bp
         02:D52D  A9 E0      			lda.l	#$6000 + ($1FFF & (_tiles_SPR_PLAYER))
         02:D52F  85 EC      			sta.l	_bp
         02:D531  A9 69      			lda.h	#$6000 + ($1FFF & (_tiles_SPR_PLAYER))
         02:D533  85 ED      			sta.h	_bp
         02:D535  A9 0E      			lda	#bank(_tiles_SPR_PLAYER)
         02:D537  85 02      			sta	_bp_bank
11015                        		__st.wmiq	256, _ax
         02:D539  64 F8      			stz.l	_ax
         02:D53B  A9 01      			lda.h	#256
         02:D53D  85 F9      			sta.h	_ax
11016                        		 _load_vram.3
         02:D53F  82         			clx				; Offset to PCE VDC.
         02:D540  20 63 FF   			call	load_vram_x
11017                        	
11018                        		.dbg	line,	"include\init.c", 524; // SELECT PLAYER CORE SPRITE //
11019                        	
11020                        		.dbg	line,	"include\init.c", 525; spr_set(player_id); // ID : 2
11021                        		__ld.umq	_player_id
         02:D543  AD 14 23   			lda	_player_id
11022                        		__call		_spr_set.1
         02:D546  20 DD E7   			call	_spr_set.1
11023                        	
11024                        		.dbg	line,	"include\init.c", 528; player_pos_x = 112;
11025                        		__st.wmiq	112, _player_pos_x
         02:D549  A9 70      			lda.l	#112
         02:D54B  8D C8 24   			sta.l	_player_pos_x
         02:D54E  9C C9 24   			stz.h	_player_pos_x
11026                        	
11027                        		.dbg	line,	"include\init.c", 529; player_pos_y = PLAYER_BASE_Y_POS;
11028                        		__st.wmiq	128, _player_pos_y
         02:D551  A9 80      			lda.l	#128
         02:D553  8D CA 24   			sta.l	_player_pos_y
         02:D556  9C CB 24   			stz.h	_player_pos_y
11029                        	
11030                        		.dbg	line,	"include\init.c", 532; spr_x(player_pos_x);
11031                        		__ld.wm		_player_pos_x
         02:D559  AD C8 24   			lda.l	_player_pos_x
         02:D55C  AC C9 24   			ldy.h	_player_pos_x
11032                        		__call		_spr_x.1
         02:D55F  20 0A E8   			call	_spr_x.1
11033                        	
11034                        		.dbg	line,	"include\init.c", 533; spr_y(player_pos_y);
11035                        		__ld.wm		_player_pos_y
         02:D562  AD CA 24   			lda.l	_player_pos_y
         02:D565  AC CB 24   			ldy.h	_player_pos_y
11036                        		__call		_spr_y.1
         02:D568  20 19 E8   			call	_spr_y.1
11037                        	
11038                        		.dbg	line,	"include\init.c", 535; // SET TILES DATA FOR THE PLAYER //
11039                        	
11040                        		.dbg	line,	"include\init.c", 536; spr_pattern(PLAYER_VRAM_ADR);
11041                        		__ld.wi		6144
         02:D56B  62         			cla
         02:D56C  A0 18      			ldy.h	#6144
11042                        		__call		_spr_pattern.1
         02:D56E  20 26 E8   			call	_spr_pattern.1
11043                        	
11044                        		.dbg	line,	"include\init.c", 538; // SET SPRITE FLIP //
11045                        	
11046                        		.dbg	line,	"include\init.c", 539; spr_ctrl(FLIP_MAS|SIZE_MAS, NO_FLIP|SZ_32x32);
11047                        		__st.umiq	185, _al
         02:D571  A9 B9      			lda.l	#185
         02:D573  85 F8      			sta	_al
11048                        		__ld.uiq	17
         02:D575  A9 11      			lda	#17
11049                        		__call		_spr_ctrl.2
         02:D577  20 3C E8   			call	_spr_ctrl.2
11050                        	
11051                        		.dbg	line,	"include\init.c", 541; 
11052                        	
11053                        		.dbg	line,	"include\init.c", 544; spr_pal(0);
11054                        		__ld.uiq	0
         02:D57A  62         			cla
11055                        		__call		_spr_pal.1
         02:D57B  20 4D E8   			call	_spr_pal.1
11056                        	
11057                        		.dbg	line,	"include\init.c", 545; spr_pri(TRUE);
11058                        		__ld.uiq	1
         02:D57E  A9 01      			lda	#1
11059                        		__call		_spr_pri.1
         02:D580  20 5C E8   			call	_spr_pri.1
11060                        	
11061                        		.dbg	line,	"include\init.c", 548; //--------------------------------------------------------------------------------------//
11062                        	
11063                        		.dbg	line,	"include\init.c", 549; //                                       OBJECTS                                        //
11064                        	
11065                        		.dbg	line,	"include\init.c", 550; //--------------------------------------------------------------------------------------//
11066                        	
11067                        		.dbg	line,	"include\init.c", 552; load_OBJECT_TILES();
11068                        		__call		_load_OBJECT_TILES
         02:D583  20 D7 FE   			call	_load_OBJECT_TILES
11069                        	
11070                        		.dbg	line,	"include\init.c", 553; init_OBJECT_LV1();
11071                        		__call		_init_OBJECT_LV1
         02:D586  20 CD FE   			call	_init_OBJECT_LV1
11072                        	
11073                        		.dbg	line,	"include\init.c", 554; scroll_object();
11074                        		__call		_scroll_object
         02:D589  20 C3 FE   			call	_scroll_object
11075                        	
11076                        		.dbg	line,	"include\init.c", 557; //--------------------------------------------------------------------------------------//
11077                        	
11078                        		.dbg	line,	"include\init.c", 558; //                                        CHESTS                                        //
11079                        	
11080                        		.dbg	line,	"include\init.c", 559; //--------------------------------------------------------------------------------------//
11081                        	
11082                        		.dbg	line,	"include\init.c", 561; load_CHEST_TILES();
11083                        		__call		_load_CHEST_TILES
         02:D58C  20 B9 FE   			call	_load_CHEST_TILES
11084                        	
11085                        		.dbg	line,	"include\init.c", 562; init_CHEST_LV1();
11086                        		__call		_init_CHEST_LV1
         02:D58F  20 AF FE   			call	_init_CHEST_LV1
11087                        	
11088                        		.dbg	line,	"include\init.c", 563; scroll_chest();
11089                        		__call		_scroll_chest
         02:D592  20 A5 FE   			call	_scroll_chest
11090                        	
11091                        		.dbg	line,	"include\init.c", 566; //--------------------------------------------------------------------------------------//
11092                        	
11093                        		.dbg	line,	"include\init.c", 567; //                                         NPCS                                         //
11094                        	
11095                        		.dbg	line,	"include\init.c", 568; //--------------------------------------------------------------------------------------//
11096                        	
11097                        		.dbg	line,	"include\init.c", 570; load_NPC_TILES();
11098                        		__call		_load_NPC_TILES
         02:D595  20 9B FE   			call	_load_NPC_TILES
11099                        	
11100                        		.dbg	line,	"include\init.c", 571; init_NPC_LV1();
11101                        		__call		_init_NPC_LV1
         02:D598  20 91 FE   			call	_init_NPC_LV1
11102                        	
11103                        		.dbg	line,	"include\init.c", 577; // UPDATE PCE SAT //
11104                        	
11105                        		.dbg	line,	"include\init.c", 578; satb_update();
11106                        		__call		_satb_update
         02:D59B  20 87 FE   			call	_satb_update
11107                        	
11108                        		.dbg	line,	"include\init.c", 583; //--------------------------------------------------------------------------------------//
11109                        	
11110                        		.dbg	line,	"include\init.c", 584; //                                LOAD SPRITES PALETTES                                 //
11111                        	
11112                        		.dbg	line,	"include\init.c", 585; //--------------------------------------------------------------------------------------//
11113                        	
11114                        		.dbg	line,	"include\init.c", 587; load_palette( 16, palette_PLAYER,    1 );
11115                        		__st.umiq	16, _al
         02:D59E  A9 10      			lda.l	#16
         02:D5A0  85 F8      			sta	_al
11116                        		__farptr	_palette_PLAYER, _bp_bank, _bp
         02:D5A2  A9 E0      			lda.l	#$6000 + ($1FFF & (_palette_PLAYER))
         02:D5A4  85 EC      			sta.l	_bp
         02:D5A6  A9 69      			lda.h	#$6000 + ($1FFF & (_palette_PLAYER))
         02:D5A8  85 ED      			sta.h	_bp
         02:D5AA  A9 0F      			lda	#bank(_palette_PLAYER)
         02:D5AC  85 02      			sta	_bp_bank
11117                        		__st.umiq	1, _ah
         02:D5AE  A9 01      			lda.l	#1
         02:D5B0  85 F9      			sta	_ah
11118                        		__call		_load_palette.3
         02:D5B2  20 E1 FE   			call	_load_palette.3
11119                        	
11120                        		.dbg	line,	"include\init.c", 588; load_palette( 17, palette_objects_1, 1 );
11121                        		__st.umiq	17, _al
         02:D5B5  A9 11      			lda.l	#17
         02:D5B7  85 F8      			sta	_al
11122                        		__farptr	_palette_objects_1, _bp_bank, _bp
         02:D5B9  A9 60      			lda.l	#$6000 + ($1FFF & (_palette_objects_1))
         02:D5BB  85 EC      			sta.l	_bp
         02:D5BD  A9 67      			lda.h	#$6000 + ($1FFF & (_palette_objects_1))
         02:D5BF  85 ED      			sta.h	_bp
         02:D5C1  A9 10      			lda	#bank(_palette_objects_1)
         02:D5C3  85 02      			sta	_bp_bank
11123                        		__st.umiq	1, _ah
         02:D5C5  A9 01      			lda.l	#1
         02:D5C7  85 F9      			sta	_ah
11124                        		__call		_load_palette.3
         02:D5C9  20 E1 FE   			call	_load_palette.3
11125                        	
11126                        		.dbg	line,	"include\init.c", 589; load_palette( 18, palette_objects_2, 1 );
11127                        		__st.umiq	18, _al
         02:D5CC  A9 12      			lda.l	#18
         02:D5CE  85 F8      			sta	_al
11128                        		__farptr	_palette_objects_2, _bp_bank, _bp
         02:D5D0  A9 60      			lda.l	#$6000 + ($1FFF & (_palette_objects_2))
         02:D5D2  85 EC      			sta.l	_bp
         02:D5D4  A9 69      			lda.h	#$6000 + ($1FFF & (_palette_objects_2))
         02:D5D6  85 ED      			sta.h	_bp
         02:D5D8  A9 10      			lda	#bank(_palette_objects_2)
         02:D5DA  85 02      			sta	_bp_bank
11129                        		__st.umiq	1, _ah
         02:D5DC  A9 01      			lda.l	#1
         02:D5DE  85 F9      			sta	_ah
11130                        		__call		_load_palette.3
         02:D5E0  20 E1 FE   			call	_load_palette.3
11131                        	
11132                        		.dbg	line,	"include\init.c", 597; // VSYNC //
11133                        	
11134                        		.dbg	line,	"include\init.c", 598; vsync();
11135                        		__call		_vsync
         02:D5E3  20 09 E3   			call	_vsync
11136                        	
11137                        		.dbg	line,	"include\init.c", 600; // ENABLE DISPLAY //
11138                        	
11139                        		.dbg	line,	"include\init.c", 601; disp_on();
11140                        		__call		_disp_on
         02:D5E6  20 16 E4   			call	_disp_on
11141                        	
11142                        		.dbg	line,	"include\init.c", 602; }
11143                        	
11144                        		.dbg	line,	"include\init.c", 603; }
11145    02:D5E9             	.LL473:
11146    02:D5E9             	.LL472:
11147                        		__return	0
         02:D5E9  4C EF FF   			jmp	leave_proc
11148                        		.dbg	clear
11149                        		.endp
11150                        		.pceas
11151                        	
11152                        		.dbg	line,	"include\init.c", 606; void init_SHOP()
11153                        		.dbg	line,	"include\init.c", 607; {
11154                        	;***********************
11155                        	;***********************
11156                        	
11157                        		.hucc
11158    02:C417             		.proc		_init_SHOP
11159                        		__enter		_init_SHOP
11160                        	
11161                        		.dbg	line,	"include\init.c", 608; char i;
11162                        	
11163                        		.dbg	line,	"include\init.c", 609; char item_id;
11164                        	
11165                        		.dbg	line,	"include\init.c", 612; // DISABLE DISPLAY //
11166                        	
11167                        		.dbg	line,	"include\init.c", 613; disp_off();
11168                        		__call		_disp_off
         02:C417  20 29 E4   			call	_disp_off
11169                        	
11170                        		.dbg	line,	"include\init.c", 614; 
11171                        	
11172                        		.dbg	line,	"include\init.c", 616; // VSYNC //
11173                        	
11174                        		.dbg	line,	"include\init.c", 617; vsync();
11175                        		__call		_vsync
         02:C41A  20 09 E3   			call	_vsync
11176                        	
11177                        		.dbg	line,	"include\init.c", 620; // HIDE ALL LEVEL SPRITES //
11178                        	
11179                        		.dbg	line,	"include\init.c", 621; hide_LEVEL_SPRITES();
11180                        		__call		_hide_LEVEL_SPRITES
         02:C41D  20 7D FE   			call	_hide_LEVEL_SPRITES
11181                        	
11182                        		.dbg	line,	"include\init.c", 624; // SET VDC 1 SCREEN SIZE (IN TILES) - 32x32 = 256 PIXELS
11183                        	
11184                        		.dbg	line,	"include\init.c", 625; set_screen_size(SCR_SIZE_64x32);
11185                        		__st.umiq	1, _al
         02:C420  A9 01      			lda.l	#1
         02:C422  85 F8      			sta	_al
11186                        		__call		_set_screen_size.1
         02:C424  20 27 FF   			call	_set_screen_size.1
11187                        	
11188                        		.dbg	line,	"include\init.c", 628; // SET VDC 2 SCREEN SIZE (IN TILES) - 32x32 = 256 PIXELS
11189                        	
11190                        		.dbg	line,	"include\init.c", 629; sgx_set_screen_size(SCR_SIZE_32x32);
11191                        		__st.umiq	0, _al
         02:C427  64 F8      			stz	_al
11192                        		__call		_sgx_set_screen_size.1
         02:C429  20 1D FF   			call	_sgx_set_screen_size.1
11193                        	
11194                        		.dbg	line,	"include\init.c", 634; //**************************************************************************************//
11195                        	
11196                        		.dbg	line,	"include\init.c", 635; //                                                                                      //
11197                        	
11198                        		.dbg	line,	"include\init.c", 636; //                                      VARIABLES                                       //
11199                        	
11200                        		.dbg	line,	"include\init.c", 637; //                                                                                      //
11201                        	
11202                        		.dbg	line,	"include\init.c", 638; //**************************************************************************************//
11203                        	
11204                        		.dbg	line,	"include\init.c", 640; index_x = 0;
11205                        		__st.umiq	0, _index_x
         02:C42C  9C C5 23   			stz	_index_x
11206                        	
11207                        		.dbg	line,	"include\init.c", 641; index_y = 0;
11208                        		__st.umiq	0, _index_y
         02:C42F  9C C6 23   			stz	_index_y
11209                        	
11210                        		.dbg	line,	"include\init.c", 642; item_index = 0;
11211                        		__st.umiq	0, _item_index
         02:C432  9C C7 23   			stz	_item_index
11212                        	
11213                        		.dbg	line,	"include\init.c", 644; minutes = 0;
11214                        		__st.umiq	0, _minutes
         02:C435  9C 22 23   			stz	_minutes
11215                        	
11216                        		.dbg	line,	"include\init.c", 645; seconds = 30;
11217                        		__st.umiq	30, _seconds
         02:C438  A9 1E      			lda.l	#30
         02:C43A  8D 23 23   			sta	_seconds
11218                        	
11219                        		.dbg	line,	"include\init.c", 647; if(level_id == 1)
11220                        		__ld.umq	_level_id
         02:C43D  AD 12 23   			lda	_level_id
11221                        		__equ_b.uiq	1
         02:C440  C9 01      			cmp	#1
         02:C442  F0 01      			beq	!+
         02:C444  18         			clc
         02:C445             	!:
11222                        		__bfalse	.LL478
         02:C445  90 0A      			bcc	.LL478
11223                        	
11224                        		.dbg	line,	"include\init.c", 648; {
11225                        	
11226                        		.dbg	line,	"include\init.c", 649; ptr_SHOP_ITEM_PRICES = &TABLE_SHOP_PRICES_LV1[0];
11227                        		__ld.wi		_TABLE_SHOP_PRICES_LV1
         02:C447  A9 02      			lda.l	#_TABLE_SHOP_PRICES_LV1
         02:C449  A0 61      			ldy.h	#_TABLE_SHOP_PRICES_LV1
11228                        		__st.wmq	_ptr_SHOP_ITEM_PRICES
         02:C44B  8D 3A 26   			sta.l	_ptr_SHOP_ITEM_PRICES
         02:C44E  8C 3B 26   			sty.h	_ptr_SHOP_ITEM_PRICES
11229                        	
11230                        		.dbg	line,	"include\init.c", 650; }
11231                        	
11232                        		.dbg	line,	"include\init.c", 651; 
11233                        	
11234                        		.dbg	line,	"include\init.c", 656; //**************************************************************************************//
11235                        	
11236                        		.dbg	line,	"include\init.c", 657; //                                                                                      //
11237                        	
11238                        		.dbg	line,	"include\init.c", 658; //                                        VDC 2                                         //
11239                        	
11240                        		.dbg	line,	"include\init.c", 659; //                                                                                      //
11241                        	
11242                        		.dbg	line,	"include\init.c", 660; //**************************************************************************************//
11243                        	
11244                        		.dbg	line,	"include\init.c", 662; //--------------------------------------------------------------------------------------//
11245                        	
11246                        		.dbg	line,	"include\init.c", 663; //                                      LOAD FONT                                       //
11247                        	
11248                        		.dbg	line,	"include\init.c", 664; //--------------------------------------------------------------------------------------//
11249                        	
11250                        		.dbg	line,	"include\init.c", 666; load_vram( 0x0800, tileset_FONT, SIZEOF(tileset_FONT) >> 1 );
11251    02:C451             	.LL478:
11252                        		__st.wmiq	2048, _di
         02:C451  64 F0      			stz.l	_di
         02:C453  A9 08      			lda.h	#2048
         02:C455  85 F1      			sta.h	_di
11253                        		__farptr	_tileset_FONT, _bp_bank, _bp
         02:C457  A9 00      			lda.l	#$6000 + ($1FFF & (_tileset_FONT))
         02:C459  85 EC      			sta.l	_bp
         02:C45B  A9 60      			lda.h	#$6000 + ($1FFF & (_tileset_FONT))
         02:C45D  85 ED      			sta.h	_bp
         02:C45F  A9 03      			lda	#bank(_tileset_FONT)
         02:C461  85 02      			sta	_bp_bank
11254                        		__ld.wi		___sizeof__tileset_FONT
         02:C463  A9 00      			lda.l	#___sizeof__tileset_FONT
         02:C465  A0 0C      			ldy.h	#___sizeof__tileset_FONT
11255                        		__lsr.wi	1
         02:C467  42         			say
         02:C468  4A         			lsr	a
         02:C469  42         			say
         02:C46A  6A         			ror	a
11256                        		__st.wmq	_ax
         02:C46B  85 F8      			sta.l	_ax
         02:C46D  84 F9      			sty.h	_ax
11257                        		 _load_vram.3
         02:C46F  82         			clx				; Offset to PCE VDC.
         02:C470  20 63 FF   			call	load_vram_x
11258                        	
11259                        		.dbg	line,	"include\init.c", 668; set_font_pal(15);
11260                        		__ld.uiq	15
         02:C473  A9 0F      			lda	#15
11261                        		__call		_set_font_pal.1
         02:C475  20 09 E6   			call	_set_font_pal.1
11262                        	
11263                        		.dbg	line,	"include\init.c", 671; //--------------------------------------------------------------------------------------//
11264                        	
11265                        		.dbg	line,	"include\init.c", 672; //                                    LOAD TILESET                                      //
11266                        	
11267                        		.dbg	line,	"include\init.c", 673; //--------------------------------------------------------------------------------------//
11268                        	
11269                        		.dbg	line,	"include\init.c", 675; sgx_load_vram( 0x1000, tileset_SHOP_BG_B, SIZEOF(tileset_SHOP_BG_B) >> 1 );
11270                        		__st.wmiq	4096, _di
         02:C478  64 F0      			stz.l	_di
         02:C47A  A9 10      			lda.h	#4096
         02:C47C  85 F1      			sta.h	_di
11271                        		__farptr	_tileset_SHOP_BG_B, _bp_bank, _bp
         02:C47E  A9 A0      			lda.l	#$6000 + ($1FFF & (_tileset_SHOP_BG_B))
         02:C480  85 EC      			sta.l	_bp
         02:C482  A9 7A      			lda.h	#$6000 + ($1FFF & (_tileset_SHOP_BG_B))
         02:C484  85 ED      			sta.h	_bp
         02:C486  A9 0B      			lda	#bank(_tileset_SHOP_BG_B)
         02:C488  85 02      			sta	_bp_bank
11272                        		__ld.wi		___sizeof__tileset_SHOP_BG_B
         02:C48A  A9 60      			lda.l	#___sizeof__tileset_SHOP_BG_B
         02:C48C  A0 39      			ldy.h	#___sizeof__tileset_SHOP_BG_B
11273                        		__lsr.wi	1
         02:C48E  42         			say
         02:C48F  4A         			lsr	a
         02:C490  42         			say
         02:C491  6A         			ror	a
11274                        		__st.wmq	_ax
         02:C492  85 F8      			sta.l	_ax
         02:C494  84 F9      			sty.h	_ax
11275                        		 _sgx_load_vram.3
         02:C496  A2 10      			ldx	#SGX_VDC_OFFSET		; Offset to SGX VDC.
         02:C498  20 63 FF   			call	load_vram_x
11276                        	
11277                        		.dbg	line,	"include\init.c", 678; //--------------------------------------------------------------------------------------//
11278                        	
11279                        		.dbg	line,	"include\init.c", 679; //                                      LOAD ITEMS                                      //
11280                        	
11281                        		.dbg	line,	"include\init.c", 680; //--------------------------------------------------------------------------------------//
11282                        	
11283                        		.dbg	line,	"include\init.c", 682; for(i=0 ; i<10 ; i++)
11284                        		__st.umiq	0, __init_SHOP_end - 1  /* i */
         02:C49B  9C 0F 23   			stz	__init_SHOP_end - 1
11285    02:C49E             	.LL479:
11286                        		__ld.umq	__init_SHOP_end - 1  /* i */
         02:C49E  AD 0F 23   			lda	__init_SHOP_end - 1
11287                        		__ult_b.uiq	10
         02:C4A1  C9 0A      			cmp	#10		; Subtract integer from A.
         02:C4A3  6A         			ror	a		; CC if A < integer.
         02:C4A4  49 80      			eor	#$80
         02:C4A6  2A         			rol	a
11288                        		__btrue		.LL481
         02:C4A7  B0 07      			bcs	.LL481
11289                        		__bra		.LL482
         02:C4A9  80 42      			bra	.LL482
11290    02:C4AB             	.LL480:
11291                        		__inc.umq	__init_SHOP_end - 1  /* i */
         02:C4AB  EE 0F 23   			inc	__init_SHOP_end - 1
11292                        		__bra		.LL479
         02:C4AE  80 EE      			bra	.LL479
11293    02:C4B0             	.LL481:
11294                        	
11295                        		.dbg	line,	"include\init.c", 683; {
11296                        	
11297                        		.dbg	line,	"include\init.c", 684; set_far_base(TABLE_SHOP_ITEMS_TILES_BANK[i],TABLE_SHOP_ITEMS_TILES_ADR[i]);
11298                        		__ldx.umq	__init_SHOP_end - 1  /* i */
         02:C4B0  AE 0F 23   			ldx	__init_SHOP_end - 1
11299                        		__ld.uax	_TABLE_SHOP_ITEMS_TILES_BANK
         02:C4B3  BD 2A 61   			lda	_TABLE_SHOP_ITEMS_TILES_BANK, x
         02:C4B6  C2         			cly
11300                        		__st.umq	_bp_bank
         02:C4B7  85 02      			sta	_bp_bank
11301                        		__ld2x.umq	__init_SHOP_end - 1  /* i */
         02:C4B9  AD 0F 23   			lda	__init_SHOP_end - 1
         02:C4BC  0A         			asl	a
         02:C4BD  AA         			tax
11302                        		__ld.wax	_TABLE_SHOP_ITEMS_TILES_ADR
         02:C4BE  BD 16 61   			lda.l	_TABLE_SHOP_ITEMS_TILES_ADR, x
         02:C4C1  BC 17 61   			ldy.h	_TABLE_SHOP_ITEMS_TILES_ADR, x
11303                        		__st.wmq	_bp
         02:C4C4  85 EC      			sta.l	_bp
         02:C4C6  84 ED      			sty.h	_bp
11304                        	
11305                        		.dbg	line,	"include\init.c", 685; sgx_far_load_vram( 0x1000 + (i * TILES_4), TILES_4 );
11306                        		__ld.um		__init_SHOP_end - 1  /* i */
         02:C4C8  AD 0F 23   			lda	__init_SHOP_end - 1
         02:C4CB  C2         			cly
11307                        		__asl.wi	6
         02:C4CC  85 00      			sta	__temp
         02:C4CE  98         			tya
         02:C4CF  4A         			lsr	a
         02:C4D0  20 CB E1   			jsr	aslw6
         02:C4D3  29 C0      			and.l	#$FF << 6
11308                        		__add.wi	4096
         02:C4D5  18         			clc
         02:C4D6  69 00      			adc.l	#4096
         02:C4D8  42         			say
         02:C4D9  69 10      			adc.h	#4096
         02:C4DB  42         			say
11309                        		__st.wmq	_di
         02:C4DC  85 F0      			sta.l	_di
         02:C4DE  84 F1      			sty.h	_di
11310                        		__st.wmiq	64, _ax
         02:C4E0  A9 40      			lda.l	#64
         02:C4E2  85 F8      			sta.l	_ax
         02:C4E4  64 F9      			stz.h	_ax
11311                        		 _sgx_far_load_vram.2
         02:C4E6  A2 10      			ldx	#SGX_VDC_OFFSET		; Offset to SGX VDC.
         02:C4E8  20 63 FF   			call	load_vram_x
11312                        	
11313                        		.dbg	line,	"include\init.c", 686; }
11314                        		__bra		.LL480
         02:C4EB  80 BE      			bra	.LL480
11315    02:C4ED             	.LL482:
11316                        	
11317                        		.dbg	line,	"include\init.c", 689; //--------------------------------------------------------------------------------------//
11318                        	
11319                        		.dbg	line,	"include\init.c", 690; //                                      SET BLOCKS                                      //
11320                        	
11321                        		.dbg	line,	"include\init.c", 691; //--------------------------------------------------------------------------------------//
11322                        	
11323                        		.dbg	line,	"include\init.c", 693; sgx_set_blocks( blocks_SHOP_BG_B , tilemap_mask , 256 );
11324                        		__farptr	_blocks_SHOP_BG_B, sgx_blk_bank, sgx_blk_addr
         02:C4ED  A9 00      			lda.l	#$6000 + ($1FFF & (_blocks_SHOP_BG_B))
         02:C4EF  8D BC 2B   			sta.l	sgx_blk_addr
         02:C4F2  A9 78      			lda.h	#$6000 + ($1FFF & (_blocks_SHOP_BG_B))
         02:C4F4  8D BD 2B   			sta.h	sgx_blk_addr
         02:C4F7  A9 0D      			lda	#bank(_blocks_SHOP_BG_B)
         02:C4F9  8D BE 2B   			sta	sgx_blk_bank
11325                        		__farptr	_tilemap_mask, sgx_tbl_bank, sgx_tbl_addr
         02:C4FC  A9 C8      			lda.l	#$6000 + ($1FFF & (_tilemap_mask))
         02:C4FE  8D B9 2B   			sta.l	sgx_tbl_addr
         02:C501  A9 63      			lda.h	#$6000 + ($1FFF & (_tilemap_mask))
         02:C503  8D BA 2B   			sta.h	sgx_tbl_addr
         02:C506  A9 F8      			lda	#bank(_tilemap_mask)
         02:C508  8D BB 2B   			sta	sgx_tbl_bank
11326                        		__st.umiq	256, _al
         02:C50B  A9 00      			lda.l	#256
         02:C50D  85 F8      			sta	_al
11327                        		__call		_sgx_set_blocks.3
         02:C50F  20 73 FE   			call	_sgx_set_blocks.3
11328                        	
11329                        		.dbg	line,	"include\init.c", 697; //--------------------------------------------------------------------------------------//
11330                        	
11331                        		.dbg	line,	"include\init.c", 698; //                                       SET MAP                                        //
11332                        	
11333                        		.dbg	line,	"include\init.c", 699; //--------------------------------------------------------------------------------------//
11334                        	
11335                        		.dbg	line,	"include\init.c", 701; sgx_set_blkmap( map_SHOP_BG_B, COUNTOF(map_SHOP_BG_B) );
11336                        		__farptr	_map_SHOP_BG_B, sgx_map_bank, sgx_map_addr
         02:C512  A9 00      			lda.l	#$6000 + ($1FFF & (_map_SHOP_BG_B))
         02:C514  8D BF 2B   			sta.l	sgx_map_addr
         02:C517  A9 60      			lda.h	#$6000 + ($1FFF & (_map_SHOP_BG_B))
         02:C519  8D C0 2B   			sta.h	sgx_map_addr
         02:C51C  A9 0E      			lda	#bank(_map_SHOP_BG_B)
         02:C51E  8D C1 2B   			sta	sgx_map_bank
11337                        		__ld.wi		___countof__map_SHOP_BG_B
         02:C521  A9 10      			lda.l	#___countof__map_SHOP_BG_B
         02:C523  A0 00      			ldy.h	#___countof__map_SHOP_BG_B
11338                        		__st.umq	sgx_map_line_w
         02:C525  8D 82 26   			sta	sgx_map_line_w
11339                        		 _sgx_set_blkmap.2
         02:C528  9C C4 2B   			stz	sgx_scr_bank
11340                        	
11341                        		.dbg	line,	"include\init.c", 704; //--------------------------------------------------------------------------------------//
11342                        	
11343                        		.dbg	line,	"include\init.c", 705; //                                    DRAW TILEMAP                                      //
11344                        	
11345                        		.dbg	line,	"include\init.c", 706; //--------------------------------------------------------------------------------------//
11346                        	
11347                        		.dbg	line,	"include\init.c", 708; // The blkmap is drawn using global variables for the top-left coordinate
11348                        	
11349                        		.dbg	line,	"include\init.c", 709; // in pixels, and the draw width and height in terms of 8x8 characters.
11350                        	
11351                        		.dbg	line,	"include\init.c", 711; sgx_map_pxl_x = 0;
11352                        		__st.wmiq	0, _sgx_map_pxl_x
         02:C52B  9C 84 26   			stz.l	_sgx_map_pxl_x
         02:C52E  9C 85 26   			stz.h	_sgx_map_pxl_x
11353                        	
11354                        		.dbg	line,	"include\init.c", 712; sgx_map_pxl_y = 0;
11355                        		__st.wmiq	0, _sgx_map_pxl_y
         02:C531  9C 86 26   			stz.l	_sgx_map_pxl_y
         02:C534  9C 87 26   			stz.h	_sgx_map_pxl_y
11356                        	
11357                        		.dbg	line,	"include\init.c", 714; sgx_map_draw_w = 32;
11358                        		__st.umiq	32, _sgx_map_draw_w
         02:C537  A9 20      			lda.l	#32
         02:C539  8D 80 26   			sta	_sgx_map_draw_w
11359                        	
11360                        		.dbg	line,	"include\init.c", 715; sgx_map_draw_h = 28;
11361                        		__st.umiq	28, _sgx_map_draw_h
         02:C53C  A9 1C      			lda.l	#28
         02:C53E  8D 81 26   			sta	_sgx_map_draw_h
11362                        	
11363                        		.dbg	line,	"include\init.c", 718; //**************************************************************************************//
11364                        	
11365                        		.dbg	line,	"include\init.c", 719; //                                                                                      //
11366                        	
11367                        		.dbg	line,	"include\init.c", 720; //                                  SETUP SCROLL_SPLIT                                  //
11368                        	
11369                        		.dbg	line,	"include\init.c", 721; //                                                                                      //
11370                        	
11371                        		.dbg	line,	"include\init.c", 722; //**************************************************************************************//
11372                        	
11373                        		.dbg	line,	"include\init.c", 724; sgx_draw_map();
11374                        		__call		_sgx_draw_map
         02:C541  20 F5 FE   			call	_sgx_draw_map
11375                        	
11376                        		.dbg	line,	"include\init.c", 726; sgx_scroll_split(0,   0, sgx_map_pxl_x & (BAT_SIZE_W - 1), sgx_map_pxl_y & (BAT_SIZE_H - 1), BKG_ON | SPR_ON);
11377                        		__st.umiq	0, _al
         02:C544  64 F8      			stz	_al
11378                        		__st.umiq	0, _ah
         02:C546  64 F9      			stz	_ah
11379                        		__ld.wm		_sgx_map_pxl_x
         02:C548  AD 84 26   			lda.l	_sgx_map_pxl_x
         02:C54B  AC 85 26   			ldy.h	_sgx_map_pxl_x
11380                        		__and.wi	2047
         02:C54E  29 FF      			and.l	#2047
         02:C550  42         			say
         02:C551  29 07      			and.h	#2047
         02:C553  42         			say
11381                        		__st.wmq	_bx
         02:C554  85 FA      			sta.l	_bx
         02:C556  84 FB      			sty.h	_bx
11382                        		__ld.wm		_sgx_map_pxl_y
         02:C558  AD 86 26   			lda.l	_sgx_map_pxl_y
         02:C55B  AC 87 26   			ldy.h	_sgx_map_pxl_y
11383                        		__and.wi	255
         02:C55E  29 FF      			and	#255
         02:C560  C2         			cly
11384                        		__st.wmq	_cx
         02:C561  85 FC      			sta.l	_cx
         02:C563  84 FD      			sty.h	_cx
11385                        		__st.umiq	192, _dl
         02:C565  A9 C0      			lda.l	#192
         02:C567  85 FE      			sta	_dl
11386                        		__call		_sgx_scroll_split.5
         02:C569  20 77 FF   			call	_sgx_scroll_split.5
11387                        	
11388                        		.dbg	line,	"include\init.c", 731; //**************************************************************************************//
11389                        	
11390                        		.dbg	line,	"include\init.c", 732; //                                                                                      //
11391                        	
11392                        		.dbg	line,	"include\init.c", 733; //                                         HUD                                          //
11393                        	
11394                        		.dbg	line,	"include\init.c", 734; //                                                                                      //
11395                        	
11396                        		.dbg	line,	"include\init.c", 735; //**************************************************************************************//
11397                        	
11398                        		.dbg	line,	"include\init.c", 737; init_HUD();
11399                        		__call		_init_HUD
         02:C56C  20 EB FE   			call	_init_HUD
11400                        	
11401                        		.dbg	line,	"include\init.c", 740; //--------------------------------------------------------------------------------------//
11402                        	
11403                        		.dbg	line,	"include\init.c", 741; //                                     DRAW PRICES                                      //
11404                        	
11405                        		.dbg	line,	"include\init.c", 742; //--------------------------------------------------------------------------------------//
11406                        	
11407                        		.dbg	line,	"include\init.c", 744; shop_prices[0] = *(ptr_SHOP_ITEM_PRICES);
11408                        		__ld.wm		_ptr_SHOP_ITEM_PRICES
         02:C56F  AD 3A 26   			lda.l	_ptr_SHOP_ITEM_PRICES
         02:C572  AC 3B 26   			ldy.h	_ptr_SHOP_ITEM_PRICES
11409                        		__st.wm		__ptr
         02:C575  85 88      			sta.l	__ptr
         02:C577  84 89      			sty.h	__ptr
11410                        		__ld.wp		__ptr
         02:C579  A0 01      			ldy	#1
         02:C57B  B1 88      			lda	[__ptr], y
         02:C57D  A8         			tay
         02:C57E  B2 88      			lda	[__ptr]
11411                        		__st.wmq	_shop_prices
         02:C580  8D 26 26   			sta.l	_shop_prices
         02:C583  8C 27 26   			sty.h	_shop_prices
11412                        	
11413                        		.dbg	line,	"include\init.c", 745; shop_prices[1] = *(ptr_SHOP_ITEM_PRICES+1);
11414                        		__ld.wm		_ptr_SHOP_ITEM_PRICES
         02:C586  AD 3A 26   			lda.l	_ptr_SHOP_ITEM_PRICES
         02:C589  AC 3B 26   			ldy.h	_ptr_SHOP_ITEM_PRICES
11415                        		__add.wi	2
         02:C58C  18         			clc
         02:C58D  69 02      			adc.l	#2
         02:C58F  90 01      			bcc	!+
         02:C591  C8         			iny
         02:C592             	!:
11416                        		__st.wm		__ptr
         02:C592  85 88      			sta.l	__ptr
         02:C594  84 89      			sty.h	__ptr
11417                        		__ld.wp		__ptr
         02:C596  A0 01      			ldy	#1
         02:C598  B1 88      			lda	[__ptr], y
         02:C59A  A8         			tay
         02:C59B  B2 88      			lda	[__ptr]
11418                        		__st.wmq	_shop_prices + 2
         02:C59D  8D 28 26   			sta.l	_shop_prices + 2
         02:C5A0  8C 29 26   			sty.h	_shop_prices + 2
11419                        	
11420                        		.dbg	line,	"include\init.c", 746; shop_prices[2] = *(ptr_SHOP_ITEM_PRICES+2);
11421                        		__ld.wm		_ptr_SHOP_ITEM_PRICES
         02:C5A3  AD 3A 26   			lda.l	_ptr_SHOP_ITEM_PRICES
         02:C5A6  AC 3B 26   			ldy.h	_ptr_SHOP_ITEM_PRICES
11422                        		__add.wi	4
         02:C5A9  18         			clc
         02:C5AA  69 04      			adc.l	#4
         02:C5AC  90 01      			bcc	!+
         02:C5AE  C8         			iny
         02:C5AF             	!:
11423                        		__st.wm		__ptr
         02:C5AF  85 88      			sta.l	__ptr
         02:C5B1  84 89      			sty.h	__ptr
11424                        		__ld.wp		__ptr
         02:C5B3  A0 01      			ldy	#1
         02:C5B5  B1 88      			lda	[__ptr], y
         02:C5B7  A8         			tay
         02:C5B8  B2 88      			lda	[__ptr]
11425                        		__st.wmq	_shop_prices + 4
         02:C5BA  8D 2A 26   			sta.l	_shop_prices + 4
         02:C5BD  8C 2B 26   			sty.h	_shop_prices + 4
11426                        	
11427                        		.dbg	line,	"include\init.c", 747; shop_prices[3] = *(ptr_SHOP_ITEM_PRICES+3);
11428                        		__ld.wm		_ptr_SHOP_ITEM_PRICES
         02:C5C0  AD 3A 26   			lda.l	_ptr_SHOP_ITEM_PRICES
         02:C5C3  AC 3B 26   			ldy.h	_ptr_SHOP_ITEM_PRICES
11429                        		__add.wi	6
         02:C5C6  18         			clc
         02:C5C7  69 06      			adc.l	#6
         02:C5C9  90 01      			bcc	!+
         02:C5CB  C8         			iny
         02:C5CC             	!:
11430                        		__st.wm		__ptr
         02:C5CC  85 88      			sta.l	__ptr
         02:C5CE  84 89      			sty.h	__ptr
11431                        		__ld.wp		__ptr
         02:C5D0  A0 01      			ldy	#1
         02:C5D2  B1 88      			lda	[__ptr], y
         02:C5D4  A8         			tay
         02:C5D5  B2 88      			lda	[__ptr]
11432                        		__st.wmq	_shop_prices + 6
         02:C5D7  8D 2C 26   			sta.l	_shop_prices + 6
         02:C5DA  8C 2D 26   			sty.h	_shop_prices + 6
11433                        	
11434                        		.dbg	line,	"include\init.c", 748; shop_prices[4] = *(ptr_SHOP_ITEM_PRICES+4);
11435                        		__ld.wm		_ptr_SHOP_ITEM_PRICES
         02:C5DD  AD 3A 26   			lda.l	_ptr_SHOP_ITEM_PRICES
         02:C5E0  AC 3B 26   			ldy.h	_ptr_SHOP_ITEM_PRICES
11436                        		__add.wi	8
         02:C5E3  18         			clc
         02:C5E4  69 08      			adc.l	#8
         02:C5E6  90 01      			bcc	!+
         02:C5E8  C8         			iny
         02:C5E9             	!:
11437                        		__st.wm		__ptr
         02:C5E9  85 88      			sta.l	__ptr
         02:C5EB  84 89      			sty.h	__ptr
11438                        		__ld.wp		__ptr
         02:C5ED  A0 01      			ldy	#1
         02:C5EF  B1 88      			lda	[__ptr], y
         02:C5F1  A8         			tay
         02:C5F2  B2 88      			lda	[__ptr]
11439                        		__st.wmq	_shop_prices + 8
         02:C5F4  8D 2E 26   			sta.l	_shop_prices + 8
         02:C5F7  8C 2F 26   			sty.h	_shop_prices + 8
11440                        	
11441                        		.dbg	line,	"include\init.c", 749; 
11442                        	
11443                        		.dbg	line,	"include\init.c", 750; shop_prices[5] = *(ptr_SHOP_ITEM_PRICES+5);
11444                        		__ld.wm		_ptr_SHOP_ITEM_PRICES
         02:C5FA  AD 3A 26   			lda.l	_ptr_SHOP_ITEM_PRICES
         02:C5FD  AC 3B 26   			ldy.h	_ptr_SHOP_ITEM_PRICES
11445                        		__add.wi	10
         02:C600  18         			clc
         02:C601  69 0A      			adc.l	#10
         02:C603  90 01      			bcc	!+
         02:C605  C8         			iny
         02:C606             	!:
11446                        		__st.wm		__ptr
         02:C606  85 88      			sta.l	__ptr
         02:C608  84 89      			sty.h	__ptr
11447                        		__ld.wp		__ptr
         02:C60A  A0 01      			ldy	#1
         02:C60C  B1 88      			lda	[__ptr], y
         02:C60E  A8         			tay
         02:C60F  B2 88      			lda	[__ptr]
11448                        		__st.wmq	_shop_prices + 10
         02:C611  8D 30 26   			sta.l	_shop_prices + 10
         02:C614  8C 31 26   			sty.h	_shop_prices + 10
11449                        	
11450                        		.dbg	line,	"include\init.c", 751; shop_prices[6] = *(ptr_SHOP_ITEM_PRICES+6);
11451                        		__ld.wm		_ptr_SHOP_ITEM_PRICES
         02:C617  AD 3A 26   			lda.l	_ptr_SHOP_ITEM_PRICES
         02:C61A  AC 3B 26   			ldy.h	_ptr_SHOP_ITEM_PRICES
11452                        		__add.wi	12
         02:C61D  18         			clc
         02:C61E  69 0C      			adc.l	#12
         02:C620  90 01      			bcc	!+
         02:C622  C8         			iny
         02:C623             	!:
11453                        		__st.wm		__ptr
         02:C623  85 88      			sta.l	__ptr
         02:C625  84 89      			sty.h	__ptr
11454                        		__ld.wp		__ptr
         02:C627  A0 01      			ldy	#1
         02:C629  B1 88      			lda	[__ptr], y
         02:C62B  A8         			tay
         02:C62C  B2 88      			lda	[__ptr]
11455                        		__st.wmq	_shop_prices + 12
         02:C62E  8D 32 26   			sta.l	_shop_prices + 12
         02:C631  8C 33 26   			sty.h	_shop_prices + 12
11456                        	
11457                        		.dbg	line,	"include\init.c", 752; shop_prices[7] = *(ptr_SHOP_ITEM_PRICES+7);
11458                        		__ld.wm		_ptr_SHOP_ITEM_PRICES
         02:C634  AD 3A 26   			lda.l	_ptr_SHOP_ITEM_PRICES
         02:C637  AC 3B 26   			ldy.h	_ptr_SHOP_ITEM_PRICES
11459                        		__add.wi	14
         02:C63A  18         			clc
         02:C63B  69 0E      			adc.l	#14
         02:C63D  90 01      			bcc	!+
         02:C63F  C8         			iny
         02:C640             	!:
11460                        		__st.wm		__ptr
         02:C640  85 88      			sta.l	__ptr
         02:C642  84 89      			sty.h	__ptr
11461                        		__ld.wp		__ptr
         02:C644  A0 01      			ldy	#1
         02:C646  B1 88      			lda	[__ptr], y
         02:C648  A8         			tay
         02:C649  B2 88      			lda	[__ptr]
11462                        		__st.wmq	_shop_prices + 14
         02:C64B  8D 34 26   			sta.l	_shop_prices + 14
         02:C64E  8C 35 26   			sty.h	_shop_prices + 14
11463                        	
11464                        		.dbg	line,	"include\init.c", 753; shop_prices[8] = *(ptr_SHOP_ITEM_PRICES+8);
11465                        		__ld.wm		_ptr_SHOP_ITEM_PRICES
         02:C651  AD 3A 26   			lda.l	_ptr_SHOP_ITEM_PRICES
         02:C654  AC 3B 26   			ldy.h	_ptr_SHOP_ITEM_PRICES
11466                        		__add.wi	16
         02:C657  18         			clc
         02:C658  69 10      			adc.l	#16
         02:C65A  90 01      			bcc	!+
         02:C65C  C8         			iny
         02:C65D             	!:
11467                        		__st.wm		__ptr
         02:C65D  85 88      			sta.l	__ptr
         02:C65F  84 89      			sty.h	__ptr
11468                        		__ld.wp		__ptr
         02:C661  A0 01      			ldy	#1
         02:C663  B1 88      			lda	[__ptr], y
         02:C665  A8         			tay
         02:C666  B2 88      			lda	[__ptr]
11469                        		__st.wmq	_shop_prices + 16
         02:C668  8D 36 26   			sta.l	_shop_prices + 16
         02:C66B  8C 37 26   			sty.h	_shop_prices + 16
11470                        	
11471                        		.dbg	line,	"include\init.c", 754; shop_prices[9] = *(ptr_SHOP_ITEM_PRICES+9);
11472                        		__ld.wm		_ptr_SHOP_ITEM_PRICES
         02:C66E  AD 3A 26   			lda.l	_ptr_SHOP_ITEM_PRICES
         02:C671  AC 3B 26   			ldy.h	_ptr_SHOP_ITEM_PRICES
11473                        		__add.wi	18
         02:C674  18         			clc
         02:C675  69 12      			adc.l	#18
         02:C677  90 01      			bcc	!+
         02:C679  C8         			iny
         02:C67A             	!:
11474                        		__st.wm		__ptr
         02:C67A  85 88      			sta.l	__ptr
         02:C67C  84 89      			sty.h	__ptr
11475                        		__ld.wp		__ptr
         02:C67E  A0 01      			ldy	#1
         02:C680  B1 88      			lda	[__ptr], y
         02:C682  A8         			tay
         02:C683  B2 88      			lda	[__ptr]
11476                        		__st.wmq	_shop_prices + 18
         02:C685  8D 38 26   			sta.l	_shop_prices + 18
         02:C688  8C 39 26   			sty.h	_shop_prices + 18
11477                        	
11478                        		.dbg	line,	"include\init.c", 757; put_number(shop_prices[0],4,2,20);
11479                        		__ld.wm		_shop_prices
         02:C68B  AD 26 26   			lda.l	_shop_prices
         02:C68E  AC 27 26   			ldy.h	_shop_prices
11480                        		__st.wmq	_bx
         02:C691  85 FA      			sta.l	_bx
         02:C693  84 FB      			sty.h	_bx
11481                        		__st.umiq	4, _cl
         02:C695  A9 04      			lda.l	#4
         02:C697  85 FC      			sta	_cl
11482                        		__st.umiq	2, _dil
         02:C699  A9 02      			lda.l	#2
         02:C69B  85 F0      			sta	_dil
11483                        		__st.umiq	20, _dih
         02:C69D  A9 14      			lda.l	#20
         02:C69F  85 F1      			sta	_dih
11484                        		__call		_put_number.4
         02:C6A1  20 9F FF   			call	_put_number.4
11485                        	
11486                        		.dbg	line,	"include\init.c", 758; put_number(shop_prices[1],4,7,20);
11487                        		__ld.wm		_shop_prices + 2
         02:C6A4  AD 28 26   			lda.l	_shop_prices + 2
         02:C6A7  AC 29 26   			ldy.h	_shop_prices + 2
11488                        		__st.wmq	_bx
         02:C6AA  85 FA      			sta.l	_bx
         02:C6AC  84 FB      			sty.h	_bx
11489                        		__st.umiq	4, _cl
         02:C6AE  A9 04      			lda.l	#4
         02:C6B0  85 FC      			sta	_cl
11490                        		__st.umiq	7, _dil
         02:C6B2  A9 07      			lda.l	#7
         02:C6B4  85 F0      			sta	_dil
11491                        		__st.umiq	20, _dih
         02:C6B6  A9 14      			lda.l	#20
         02:C6B8  85 F1      			sta	_dih
11492                        		__call		_put_number.4
         02:C6BA  20 9F FF   			call	_put_number.4
11493                        	
11494                        		.dbg	line,	"include\init.c", 759; put_number(shop_prices[2],4,12,20);
11495                        		__ld.wm		_shop_prices + 4
         02:C6BD  AD 2A 26   			lda.l	_shop_prices + 4
         02:C6C0  AC 2B 26   			ldy.h	_shop_prices + 4
11496                        		__st.wmq	_bx
         02:C6C3  85 FA      			sta.l	_bx
         02:C6C5  84 FB      			sty.h	_bx
11497                        		__st.umiq	4, _cl
         02:C6C7  A9 04      			lda.l	#4
         02:C6C9  85 FC      			sta	_cl
11498                        		__st.umiq	12, _dil
         02:C6CB  A9 0C      			lda.l	#12
         02:C6CD  85 F0      			sta	_dil
11499                        		__st.umiq	20, _dih
         02:C6CF  A9 14      			lda.l	#20
         02:C6D1  85 F1      			sta	_dih
11500                        		__call		_put_number.4
         02:C6D3  20 9F FF   			call	_put_number.4
11501                        	
11502                        		.dbg	line,	"include\init.c", 760; put_number(shop_prices[3],4,17,20);
11503                        		__ld.wm		_shop_prices + 6
         02:C6D6  AD 2C 26   			lda.l	_shop_prices + 6
         02:C6D9  AC 2D 26   			ldy.h	_shop_prices + 6
11504                        		__st.wmq	_bx
         02:C6DC  85 FA      			sta.l	_bx
         02:C6DE  84 FB      			sty.h	_bx
11505                        		__st.umiq	4, _cl
         02:C6E0  A9 04      			lda.l	#4
         02:C6E2  85 FC      			sta	_cl
11506                        		__st.umiq	17, _dil
         02:C6E4  A9 11      			lda.l	#17
         02:C6E6  85 F0      			sta	_dil
11507                        		__st.umiq	20, _dih
         02:C6E8  A9 14      			lda.l	#20
         02:C6EA  85 F1      			sta	_dih
11508                        		__call		_put_number.4
         02:C6EC  20 9F FF   			call	_put_number.4
11509                        	
11510                        		.dbg	line,	"include\init.c", 761; put_number(shop_prices[4],4,22,20);
11511                        		__ld.wm		_shop_prices + 8
         02:C6EF  AD 2E 26   			lda.l	_shop_prices + 8
         02:C6F2  AC 2F 26   			ldy.h	_shop_prices + 8
11512                        		__st.wmq	_bx
         02:C6F5  85 FA      			sta.l	_bx
         02:C6F7  84 FB      			sty.h	_bx
11513                        		__st.umiq	4, _cl
         02:C6F9  A9 04      			lda.l	#4
         02:C6FB  85 FC      			sta	_cl
11514                        		__st.umiq	22, _dil
         02:C6FD  A9 16      			lda.l	#22
         02:C6FF  85 F0      			sta	_dil
11515                        		__st.umiq	20, _dih
         02:C701  A9 14      			lda.l	#20
         02:C703  85 F1      			sta	_dih
11516                        		__call		_put_number.4
         02:C705  20 9F FF   			call	_put_number.4
11517                        	
11518                        		.dbg	line,	"include\init.c", 763; put_number(shop_prices[5],4,2,23);
11519                        		__ld.wm		_shop_prices + 10
         02:C708  AD 30 26   			lda.l	_shop_prices + 10
         02:C70B  AC 31 26   			ldy.h	_shop_prices + 10
11520                        		__st.wmq	_bx
         02:C70E  85 FA      			sta.l	_bx
         02:C710  84 FB      			sty.h	_bx
11521                        		__st.umiq	4, _cl
         02:C712  A9 04      			lda.l	#4
         02:C714  85 FC      			sta	_cl
11522                        		__st.umiq	2, _dil
         02:C716  A9 02      			lda.l	#2
         02:C718  85 F0      			sta	_dil
11523                        		__st.umiq	23, _dih
         02:C71A  A9 17      			lda.l	#23
         02:C71C  85 F1      			sta	_dih
11524                        		__call		_put_number.4
         02:C71E  20 9F FF   			call	_put_number.4
11525                        	
11526                        		.dbg	line,	"include\init.c", 764; put_number(shop_prices[6],4,7,23);
11527                        		__ld.wm		_shop_prices + 12
         02:C721  AD 32 26   			lda.l	_shop_prices + 12
         02:C724  AC 33 26   			ldy.h	_shop_prices + 12
11528                        		__st.wmq	_bx
         02:C727  85 FA      			sta.l	_bx
         02:C729  84 FB      			sty.h	_bx
11529                        		__st.umiq	4, _cl
         02:C72B  A9 04      			lda.l	#4
         02:C72D  85 FC      			sta	_cl
11530                        		__st.umiq	7, _dil
         02:C72F  A9 07      			lda.l	#7
         02:C731  85 F0      			sta	_dil
11531                        		__st.umiq	23, _dih
         02:C733  A9 17      			lda.l	#23
         02:C735  85 F1      			sta	_dih
11532                        		__call		_put_number.4
         02:C737  20 9F FF   			call	_put_number.4
11533                        	
11534                        		.dbg	line,	"include\init.c", 765; put_number(shop_prices[7],4,12,23);
11535                        		__ld.wm		_shop_prices + 14
         02:C73A  AD 34 26   			lda.l	_shop_prices + 14
         02:C73D  AC 35 26   			ldy.h	_shop_prices + 14
11536                        		__st.wmq	_bx
         02:C740  85 FA      			sta.l	_bx
         02:C742  84 FB      			sty.h	_bx
11537                        		__st.umiq	4, _cl
         02:C744  A9 04      			lda.l	#4
         02:C746  85 FC      			sta	_cl
11538                        		__st.umiq	12, _dil
         02:C748  A9 0C      			lda.l	#12
         02:C74A  85 F0      			sta	_dil
11539                        		__st.umiq	23, _dih
         02:C74C  A9 17      			lda.l	#23
         02:C74E  85 F1      			sta	_dih
11540                        		__call		_put_number.4
         02:C750  20 9F FF   			call	_put_number.4
11541                        	
11542                        		.dbg	line,	"include\init.c", 766; put_number(shop_prices[8],4,17,23);
11543                        		__ld.wm		_shop_prices + 16
         02:C753  AD 36 26   			lda.l	_shop_prices + 16
         02:C756  AC 37 26   			ldy.h	_shop_prices + 16
11544                        		__st.wmq	_bx
         02:C759  85 FA      			sta.l	_bx
         02:C75B  84 FB      			sty.h	_bx
11545                        		__st.umiq	4, _cl
         02:C75D  A9 04      			lda.l	#4
         02:C75F  85 FC      			sta	_cl
11546                        		__st.umiq	17, _dil
         02:C761  A9 11      			lda.l	#17
         02:C763  85 F0      			sta	_dil
11547                        		__st.umiq	23, _dih
         02:C765  A9 17      			lda.l	#23
         02:C767  85 F1      			sta	_dih
11548                        		__call		_put_number.4
         02:C769  20 9F FF   			call	_put_number.4
11549                        	
11550                        		.dbg	line,	"include\init.c", 767; put_number(shop_prices[9],4,22,23);
11551                        		__ld.wm		_shop_prices + 18
         02:C76C  AD 38 26   			lda.l	_shop_prices + 18
         02:C76F  AC 39 26   			ldy.h	_shop_prices + 18
11552                        		__st.wmq	_bx
         02:C772  85 FA      			sta.l	_bx
         02:C774  84 FB      			sty.h	_bx
11553                        		__st.umiq	4, _cl
         02:C776  A9 04      			lda.l	#4
         02:C778  85 FC      			sta	_cl
11554                        		__st.umiq	22, _dil
         02:C77A  A9 16      			lda.l	#22
         02:C77C  85 F0      			sta	_dil
11555                        		__st.umiq	23, _dih
         02:C77E  A9 17      			lda.l	#23
         02:C780  85 F1      			sta	_dih
11556                        		__call		_put_number.4
         02:C782  20 9F FF   			call	_put_number.4
11557                        	
11558                        		.dbg	line,	"include\init.c", 772; //--------------------------------------------------------------------------------------//
11559                        	
11560                        		.dbg	line,	"include\init.c", 773; //                                   LOAD BG PALETTES                                   //
11561                        	
11562                        		.dbg	line,	"include\init.c", 774; //--------------------------------------------------------------------------------------//
11563                        	
11564                        		.dbg	line,	"include\init.c", 776; load_palette( 0, palette_SHOP, 16 );
11565                        		__st.umiq	0, _al
         02:C785  64 F8      			stz	_al
11566                        		__farptr	_palette_SHOP, _bp_bank, _bp
         02:C787  A9 E0      			lda.l	#$6000 + ($1FFF & (_palette_SHOP))
         02:C789  85 EC      			sta.l	_bp
         02:C78B  A9 65      			lda.h	#$6000 + ($1FFF & (_palette_SHOP))
         02:C78D  85 ED      			sta.h	_bp
         02:C78F  A9 0E      			lda	#bank(_palette_SHOP)
         02:C791  85 02      			sta	_bp_bank
11567                        		__st.umiq	16, _ah
         02:C793  A9 10      			lda.l	#16
         02:C795  85 F9      			sta	_ah
11568                        		__call		_load_palette.3
         02:C797  20 E1 FE   			call	_load_palette.3
11569                        	
11570                        		.dbg	line,	"include\init.c", 781; //**************************************************************************************//
11571                        	
11572                        		.dbg	line,	"include\init.c", 782; //                                                                                      //
11573                        	
11574                        		.dbg	line,	"include\init.c", 783; //                                       SPRITES                                        //
11575                        	
11576                        		.dbg	line,	"include\init.c", 784; //                                                                                      //
11577                        	
11578                        		.dbg	line,	"include\init.c", 785; //**************************************************************************************//
11579                        	
11580                        		.dbg	line,	"include\init.c", 787; //--------------------------------------------------------------------------------------//
11581                        	
11582                        		.dbg	line,	"include\init.c", 788; //                                        CURSOR                                        //
11583                        	
11584                        		.dbg	line,	"include\init.c", 789; //--------------------------------------------------------------------------------------//
11585                        	
11586                        		.dbg	line,	"include\init.c", 791; // LOAD CURSOR TILES //
11587                        	
11588                        		.dbg	line,	"include\init.c", 792; load_vram(0x2000, tiles_SPR_CURSOR , TILES_16);
11589                        		__st.wmiq	8192, _di
         02:C79A  64 F0      			stz.l	_di
         02:C79C  A9 20      			lda.h	#8192
         02:C79E  85 F1      			sta.h	_di
11590                        		__farptr	_tiles_SPR_CURSOR, _bp_bank, _bp
         02:C7A0  A9 60      			lda.l	#$6000 + ($1FFF & (_tiles_SPR_CURSOR))
         02:C7A2  85 EC      			sta.l	_bp
         02:C7A4  A9 77      			lda.h	#$6000 + ($1FFF & (_tiles_SPR_CURSOR))
         02:C7A6  85 ED      			sta.h	_bp
         02:C7A8  A9 10      			lda	#bank(_tiles_SPR_CURSOR)
         02:C7AA  85 02      			sta	_bp_bank
11591                        		__st.wmiq	256, _ax
         02:C7AC  64 F8      			stz.l	_ax
         02:C7AE  A9 01      			lda.h	#256
         02:C7B0  85 F9      			sta.h	_ax
11592                        		 _load_vram.3
         02:C7B2  82         			clx				; Offset to PCE VDC.
         02:C7B3  20 63 FF   			call	load_vram_x
11593                        	
11594                        		.dbg	line,	"include\init.c", 795; // SELECT CURSOR SPRITE //
11595                        	
11596                        		.dbg	line,	"include\init.c", 796; spr_set(0);
11597                        		__ld.uiq	0
         02:C7B6  62         			cla
11598                        		__call		_spr_set.1
         02:C7B7  20 DD E7   			call	_spr_set.1
11599                        	
11600                        		.dbg	line,	"include\init.c", 799; spr_x(24);
11601                        		__ld.wi		24
         02:C7BA  A9 18      			lda.l	#24
         02:C7BC  C2         			cly
11602                        		__call		_spr_x.1
         02:C7BD  20 0A E8   			call	_spr_x.1
11603                        	
11604                        		.dbg	line,	"include\init.c", 800; spr_y(144);
11605                        		__ld.wi		144
         02:C7C0  A9 90      			lda.l	#144
         02:C7C2  C2         			cly
11606                        		__call		_spr_y.1
         02:C7C3  20 19 E8   			call	_spr_y.1
11607                        	
11608                        		.dbg	line,	"include\init.c", 802; // SET TILES DATA FOR THE CURSOR //
11609                        	
11610                        		.dbg	line,	"include\init.c", 803; spr_pattern(0x2000);
11611                        		__ld.wi		8192
         02:C7C6  62         			cla
         02:C7C7  A0 20      			ldy.h	#8192
11612                        		__call		_spr_pattern.1
         02:C7C9  20 26 E8   			call	_spr_pattern.1
11613                        	
11614                        		.dbg	line,	"include\init.c", 806; spr_ctrl(FLIP_MAS|SIZE_MAS, NO_FLIP|SZ_32x32);
11615                        		__st.umiq	185, _al
         02:C7CC  A9 B9      			lda.l	#185
         02:C7CE  85 F8      			sta	_al
11616                        		__ld.uiq	17
         02:C7D0  A9 11      			lda	#17
11617                        		__call		_spr_ctrl.2
         02:C7D2  20 3C E8   			call	_spr_ctrl.2
11618                        	
11619                        		.dbg	line,	"include\init.c", 809; spr_pal(16);
11620                        		__ld.uiq	16
         02:C7D5  A9 10      			lda	#16
11621                        		__call		_spr_pal.1
         02:C7D7  20 4D E8   			call	_spr_pal.1
11622                        	
11623                        		.dbg	line,	"include\init.c", 810; spr_pri(TRUE);
11624                        		__ld.uiq	1
         02:C7DA  A9 01      			lda	#1
11625                        		__call		_spr_pri.1
         02:C7DC  20 5C E8   			call	_spr_pri.1
11626                        	
11627                        		.dbg	line,	"include\init.c", 813; // UPDATE PCE SAT //
11628                        	
11629                        		.dbg	line,	"include\init.c", 814; satb_update();
11630                        		__call		_satb_update
         02:C7DF  20 87 FE   			call	_satb_update
11631                        	
11632                        		.dbg	line,	"include\init.c", 818; //--------------------------------------------------------------------------------------//
11633                        	
11634                        		.dbg	line,	"include\init.c", 819; //                                LOAD SPRITES PALETTES                                 //
11635                        	
11636                        		.dbg	line,	"include\init.c", 820; //--------------------------------------------------------------------------------------//
11637                        	
11638                        		.dbg	line,	"include\init.c", 822; load_palette( 16, palette_objects_2, 1 );
11639                        		__st.umiq	16, _al
         02:C7E2  A9 10      			lda.l	#16
         02:C7E4  85 F8      			sta	_al
11640                        		__farptr	_palette_objects_2, _bp_bank, _bp
         02:C7E6  A9 60      			lda.l	#$6000 + ($1FFF & (_palette_objects_2))
         02:C7E8  85 EC      			sta.l	_bp
         02:C7EA  A9 69      			lda.h	#$6000 + ($1FFF & (_palette_objects_2))
         02:C7EC  85 ED      			sta.h	_bp
         02:C7EE  A9 10      			lda	#bank(_palette_objects_2)
         02:C7F0  85 02      			sta	_bp_bank
11641                        		__st.umiq	1, _ah
         02:C7F2  A9 01      			lda.l	#1
         02:C7F4  85 F9      			sta	_ah
11642                        		__call		_load_palette.3
         02:C7F6  20 E1 FE   			call	_load_palette.3
11643                        	
11644                        		.dbg	line,	"include\init.c", 826; // VSYNC //
11645                        	
11646                        		.dbg	line,	"include\init.c", 827; vsync();
11647                        		__call		_vsync
         02:C7F9  20 09 E3   			call	_vsync
11648                        	
11649                        		.dbg	line,	"include\init.c", 829; // ENABLE DISPLAY //
11650                        	
11651                        		.dbg	line,	"include\init.c", 830; disp_on();
11652                        		__call		_disp_on
         02:C7FC  20 16 E4   			call	_disp_on
11653                        	
11654                        		.dbg	line,	"include\init.c", 831; }
11655    02:C7FF             	.LL477:
11656                        		__return	0
         02:C7FF  4C EF FF   			jmp	leave_proc
11657                        		.dbg	clear
11658                        		.endp
11659               7960     		.data
11660               230E     		.bss
11661    F8:230E             	__init_SHOP_loc:
11662    F8:230E             			ds	2
11663    F8:2310             	__init_SHOP_end:
11664               E309     		.code
11665                        		.pceas
11666                        	
11667                        		.dbg	line,	"main.c", 31; main()
11668                        		.dbg	line,	"main.c", 32; {
11669                        	;***********************
11670                        	;***********************
11671                        	
11672                        		.hucc
11673    02:DDE9             		.proc		_main
11674                        		__enter		_main
11675                        	
11676                        		.dbg	line,	"main.c", 33; if(!sgx_detect())
11677                        		 _sgx_detect
         02:DDE9  AD E8 22   			lda	sgx_detected
         02:DDEC  C2         			cly
11678                        		__not.wr
         02:DDED  84 00      			sty	__temp
         02:DDEF  05 00      			ora	__temp
         02:DDF1  18         			clc
         02:DDF2  D0 01      			bne	!+
         02:DDF4  38         			sec
         02:DDF5             	!:
11679                        		__bfalse	.LL484
         02:DDF5  90 14      			bcc	.LL484
11680                        	
11681                        		.dbg	line,	"main.c", 34; {
11682                        	
11683                        		.dbg	line,	"main.c", 35; put_string("Halt: SGX hardware not found", 2, 13);
11684                        		__ld.wi		__const1+0
         02:DDF7  62         			cla
         02:DDF8  A0 60      			ldy.h	#__const1+0
11685                        		__st.wmq	_bp
         02:DDFA  85 EC      			sta.l	_bp
         02:DDFC  84 ED      			sty.h	_bp
11686                        		__st.umiq	2, _dil
         02:DDFE  A9 02      			lda.l	#2
         02:DE00  85 F0      			sta	_dil
11687                        		__st.umiq	13, _dih
         02:DE02  A9 0D      			lda.l	#13
         02:DE04  85 F1      			sta	_dih
11688                        		__call		_put_string.3
         02:DE06  20 68 E6   			call	_put_string.3
11689                        	
11690                        		.dbg	line,	"main.c", 37; for(;;)
11691    02:DE09             	.LL485	.alias		.LL487
11692    02:DE09             	.LL486	.alias		.LL487
11693    02:DE09             	.LL487:
11694                        	
11695                        		.dbg	line,	"main.c", 38; {
11696                        	
11697                        		.dbg	line,	"main.c", 39; // INFINITE LOOP //
11698                        	
11699                        		.dbg	line,	"main.c", 40; }
11700                        		__bra		.LL487
         02:DE09  80 FE      			bra	.LL487
11701    02:DE0B             	.LL488:
11702                        	
11703                        		.dbg	line,	"main.c", 41; }
11704                        	
11705                        		.dbg	line,	"main.c", 46; init_SYSTEM();
11706    02:DE0B             	.LL484:
11707                        		__call		_init_SYSTEM
         02:DE0B  20 69 FE   			call	_init_SYSTEM
11708                        	
11709                        		.dbg	line,	"main.c", 47; 
11710                        	
11711                        		.dbg	line,	"main.c", 48; 
11712                        	
11713                        		.dbg	line,	"main.c", 49; init_VARIABLES();
11714                        		__call		_init_VARIABLES
         02:DE0E  20 5F FE   			call	_init_VARIABLES
11715                        	
11716                        		.dbg	line,	"main.c", 52; init_PLAYER();
11717                        		__call		_init_PLAYER
         02:DE11  20 31 FF   			call	_init_PLAYER
11718                        	
11719                        		.dbg	line,	"main.c", 57; //**************************************************************************************//
11720                        	
11721                        		.dbg	line,	"main.c", 58; //                                                                                      //
11722                        	
11723                        		.dbg	line,	"main.c", 59; //                                         MAIN                                         //
11724                        	
11725                        		.dbg	line,	"main.c", 60; //                                                                                      //
11726                        	
11727                        		.dbg	line,	"main.c", 61; //**************************************************************************************//
11728                        	
11729                        		.dbg	line,	"main.c", 62; for(;;)
11730    02:DE14             	.LL489:
11731    02:DE14             	.LL490:
11732    02:DE14             	.LL491:
11733                        	
11734                        		.dbg	line,	"main.c", 63; {
11735                        	
11736                        		.dbg	line,	"main.c", 64; switch(sequence_id)
11737                        		__ld.umq	_sequence_id
         02:DE14  AD 10 23   			lda	_sequence_id
11738                        		__bra		.LL493
         02:DE17  4C AD DE   			bra	.LL493
11739                        	
11740                        		.dbg	line,	"main.c", 65; {
11741                        	
11742                        		.dbg	line,	"main.c", 66; //-----------------------------------------------------------------------------//
11743                        	
11744                        		.dbg	line,	"main.c", 67; //                                    TITLE                                    //
11745                        	
11746                        		.dbg	line,	"main.c", 68; //-----------------------------------------------------------------------------//
11747                        	
11748                        		.dbg	line,	"main.c", 69; case SEQUENCE_TITLE:
11749    02:DE1A             	.LL495:
11750                        		__case		0
11751                        	
11752                        		.dbg	line,	"main.c", 70; break;
11753                        		__bra		.LL494
         02:DE1A  80 F8      			bra	.LL494
11754                        	
11755                        		.dbg	line,	"main.c", 73; //-----------------------------------------------------------------------------//
11756                        	
11757                        		.dbg	line,	"main.c", 74; //                                    INTRO                                    //
11758                        	
11759                        		.dbg	line,	"main.c", 75; //-----------------------------------------------------------------------------//
11760                        	
11761                        		.dbg	line,	"main.c", 76; case SEQUENCE_INTRO:
11762    02:DE1C             	.LL496:
11763                        		__case		1
11764                        	
11765                        		.dbg	line,	"main.c", 77; break;
11766                        		__bra		.LL494
         02:DE1C  80 F6      			bra	.LL494
11767                        	
11768                        		.dbg	line,	"main.c", 80; //-----------------------------------------------------------------------------//
11769                        	
11770                        		.dbg	line,	"main.c", 81; //                                    GAME                                     //
11771                        	
11772                        		.dbg	line,	"main.c", 82; //-----------------------------------------------------------------------------//
11773                        	
11774                        		.dbg	line,	"main.c", 83; case SEQUENCE_GAME:
11775    02:DE1E             	.LL497:
11776                        		__case		2
11777                        	
11778                        		.dbg	line,	"main.c", 84; if(sequence_loaded == FALSE)
11779                        		__not.um	_sequence_loaded
         02:DE1E  AD 11 23   			lda	_sequence_loaded
         02:DE21  18         			clc
         02:DE22  D0 01      			bne	!+
         02:DE24  38         			sec
         02:DE25             	!:
11780                        		__bfalse	.LL498
         02:DE25  90 0A      			bcc	.LL498
11781                        	
11782                        		.dbg	line,	"main.c", 85; {
11783                        	
11784                        		.dbg	line,	"main.c", 86; init_LEVEL();
11785                        		__call		_init_LEVEL
         02:DE27  20 55 FE   			call	_init_LEVEL
11786                        	
11787                        		.dbg	line,	"main.c", 88; sequence_loaded = TRUE;
11788                        		__st.umiq	1, _sequence_loaded
         02:DE2A  A9 01      			lda.l	#1
         02:DE2C  8D 11 23   			sta	_sequence_loaded
11789                        	
11790                        		.dbg	line,	"main.c", 89; }
11791                        	
11792                        		.dbg	line,	"main.c", 92; else
11793                        		__bra		.LL499
         02:DE2F  80 E3      			bra	.LL499
11794    02:DE31             	.LL498:
11795                        	
11796                        		.dbg	line,	"main.c", 93; {
11797                        	
11798                        		.dbg	line,	"main.c", 94; switch(level_id)
11799                        		__ld.umq	_level_id
         02:DE31  AD 12 23   			lda	_level_id
11800                        		__bra		.LL500
         02:DE34  80 3A      			bra	.LL500
11801                        	
11802                        		.dbg	line,	"main.c", 95; {
11803                        	
11804                        		.dbg	line,	"main.c", 96; case 1:
11805    02:DE36             	.LL502:
11806                        		__case		1
11807                        	
11808                        		.dbg	line,	"main.c", 97; vsync();
11809                        		__call		_vsync
         02:DE36  20 09 E3   			call	_vsync
11810                        	
11811                        		.dbg	line,	"main.c", 99; update_PLAYER();
11812                        		__call		_update_PLAYER
         02:DE39  20 4B FE   			call	_update_PLAYER
11813                        	
11814                        		.dbg	line,	"main.c", 100; 
11815                        	
11816                        		.dbg	line,	"main.c", 101; //put_number(player_state,1,0,0);
11817                        	
11818                        		.dbg	line,	"main.c", 103; joypad_DIR();
11819                        		__call		_joypad_DIR
         02:DE3C  20 41 FE   			call	_joypad_DIR
11820                        	
11821                        		.dbg	line,	"main.c", 104; joypad_BUTTONS();
11822                        		__call		_joypad_BUTTONS
         02:DE3F  20 37 FE   			call	_joypad_BUTTONS
11823                        	
11824                        		.dbg	line,	"main.c", 106; scroll_object();
11825                        		__call		_scroll_object
         02:DE42  20 C3 FE   			call	_scroll_object
11826                        	
11827                        		.dbg	line,	"main.c", 107; scroll_chest();
11828                        		__call		_scroll_chest
         02:DE45  20 A5 FE   			call	_scroll_chest
11829                        	
11830                        		.dbg	line,	"main.c", 108; scroll_npc();
11831                        		__call		_scroll_npc
         02:DE48  20 2D FE   			call	_scroll_npc
11832                        	
11833                        		.dbg	line,	"main.c", 110; check_OBJECT();
11834                        		__call		_check_OBJECT
         02:DE4B  20 23 FE   			call	_check_OBJECT
11835                        	
11836                        		.dbg	line,	"main.c", 111; check_NPC();
11837                        		__call		_check_NPC
         02:DE4E  20 19 FE   			call	_check_NPC
11838                        	
11839                        		.dbg	line,	"main.c", 113; display_TIME();
11840                        		__call		_display_TIME
         02:DE51  20 FF FE   			call	_display_TIME
11841                        	
11842                        		.dbg	line,	"main.c", 115; satb_update();
11843                        		__call		_satb_update
         02:DE54  20 87 FE   			call	_satb_update
11844                        	
11845                        		.dbg	line,	"main.c", 117; scroll_BG();
11846                        		__call		_scroll_BG
         02:DE57  20 0F FE   			call	_scroll_BG
11847                        	
11848                        		.dbg	line,	"main.c", 118; break;
11849                        		__bra		.LL501
         02:DE5A  80 B8      			bra	.LL501
11850                        	
11851                        		.dbg	line,	"main.c", 121; case 2:
11852    02:DE5C             	.LL503:
11853                        		__case		2
11854                        	
11855                        		.dbg	line,	"main.c", 122; vsync();
11856                        		__call		_vsync
         02:DE5C  20 09 E3   			call	_vsync
11857                        	
11858                        		.dbg	line,	"main.c", 123; break;
11859                        		__bra		.LL501
         02:DE5F  80 B3      			bra	.LL501
11860                        	
11861                        		.dbg	line,	"main.c", 126; case 3:
11862    02:DE61             	.LL504:
11863                        		__case		3
11864                        	
11865                        		.dbg	line,	"main.c", 127; vsync();
11866                        		__call		_vsync
         02:DE61  20 09 E3   			call	_vsync
11867                        	
11868                        		.dbg	line,	"main.c", 128; break;
11869                        		__bra		.LL501
         02:DE64  80 AE      			bra	.LL501
11870                        	
11871                        		.dbg	line,	"main.c", 131; case 4:
11872    02:DE66             	.LL505:
11873                        		__case		4
11874                        	
11875                        		.dbg	line,	"main.c", 132; vsync();
11876                        		__call		_vsync
         02:DE66  20 09 E3   			call	_vsync
11877                        	
11878                        		.dbg	line,	"main.c", 133; break;
11879                        		__bra		.LL501
         02:DE69  80 A9      			bra	.LL501
11880                        	
11881                        		.dbg	line,	"main.c", 136; case 5:
11882    02:DE6B             	.LL506:
11883                        		__case		5
11884                        	
11885                        		.dbg	line,	"main.c", 137; vsync();
11886                        		__call		_vsync
         02:DE6B  20 09 E3   			call	_vsync
11887                        	
11888                        		.dbg	line,	"main.c", 138; break;
11889                        		__bra		.LL501
         02:DE6E  80 A4      			bra	.LL501
11890                        	
11891                        		.dbg	line,	"main.c", 140; }
11892    02:DE70             	.LL500:
11893                        		__switch_r.ur	0, 5
         02:DE70  C9 06      			cmp	#(5 - 0) + 1
         02:DE72  90 02      			bcc	!found+
         02:DE74  A9 06      	!default:	lda	#(5 - 0) + 1
         02:DE76  0A         	!found:		asl	a
         02:DE77  AA         			tax
         02:DE78  7C 7B DE   			jmp	[!table+, x]
11894                        	
11895    02:DE7B  14 DE      	!table:		dw	.LL501, .LL502, .LL503, .LL504, .LL505, .LL506
         02:DE7D  36 DE       
         02:DE7F  5C DE       
         02:DE81  61 DE       
         02:DE83  66 DE       
         02:DE85  6B DE       
11896    02:DE87  14 DE      			dw	.LL501
11897    02:DE89             	.LL501	.alias		.LL494
11898                        	
11899                        		.dbg	line,	"main.c", 141; }
11900    02:DE89             	.LL499	.alias		.LL494
11901                        	
11902                        		.dbg	line,	"main.c", 143; break;
11903                        		__bra		.LL494
         02:DE89  80 89      			bra	.LL494
11904                        	
11905                        		.dbg	line,	"main.c", 146; //-----------------------------------------------------------------------------//
11906                        	
11907                        		.dbg	line,	"main.c", 147; //                                     NPC                                     //
11908                        	
11909                        		.dbg	line,	"main.c", 148; //-----------------------------------------------------------------------------//
11910                        	
11911                        		.dbg	line,	"main.c", 149; case SEQUENCE_NPC:
11912    02:DE8B             	.LL507:
11913                        		__case		3
11914                        	
11915                        		.dbg	line,	"main.c", 150; break;
11916                        		__bra		.LL494
         02:DE8B  80 87      			bra	.LL494
11917                        	
11918                        		.dbg	line,	"main.c", 153; //-----------------------------------------------------------------------------//
11919                        	
11920                        		.dbg	line,	"main.c", 154; //                                    SHOP                                     //
11921                        	
11922                        		.dbg	line,	"main.c", 155; //-----------------------------------------------------------------------------//
11923                        	
11924                        		.dbg	line,	"main.c", 156; case SEQUENCE_SHOP:
11925    02:DE8D             	.LL508:
11926                        		__case		4
11927                        	
11928                        		.dbg	line,	"main.c", 157; if(sequence_loaded == FALSE)
11929                        		__not.um	_sequence_loaded
         02:DE8D  AD 11 23   			lda	_sequence_loaded
         02:DE90  18         			clc
         02:DE91  D0 01      			bne	!+
         02:DE93  38         			sec
         02:DE94             	!:
11930                        		__bfalse	.LL509
         02:DE94  90 0B      			bcc	.LL509
11931                        	
11932                        		.dbg	line,	"main.c", 158; {
11933                        	
11934                        		.dbg	line,	"main.c", 159; init_SHOP();
11935                        		__call		_init_SHOP
         02:DE96  20 05 FE   			call	_init_SHOP
11936                        	
11937                        		.dbg	line,	"main.c", 161; sequence_loaded = TRUE;
11938                        		__st.umiq	1, _sequence_loaded
         02:DE99  A9 01      			lda.l	#1
         02:DE9B  8D 11 23   			sta	_sequence_loaded
11939                        	
11940                        		.dbg	line,	"main.c", 162; }
11941                        	
11942                        		.dbg	line,	"main.c", 163; 
11943                        	
11944                        		.dbg	line,	"main.c", 164; else
11945                        		__bra		.LL510
         02:DE9E  4C 14 DE   			bra	.LL510
11946    02:DEA1             	.LL509:
11947                        	
11948                        		.dbg	line,	"main.c", 165; {
11949                        	
11950                        		.dbg	line,	"main.c", 166; vsync();
11951                        		__call		_vsync
         02:DEA1  20 09 E3   			call	_vsync
11952                        	
11953                        		.dbg	line,	"main.c", 168; joypad_BUTTONS_SHOP();
11954                        		__call		_joypad_BUTTONS_SHOP
         02:DEA4  20 FB FD   			call	_joypad_BUTTONS_SHOP
11955                        	
11956                        		.dbg	line,	"main.c", 170; //put_number(item_index,1,0,0);
11957                        	
11958                        		.dbg	line,	"main.c", 172; satb_update();
11959                        		__call		_satb_update
         02:DEA7  20 87 FE   			call	_satb_update
11960                        	
11961                        		.dbg	line,	"main.c", 173; }
11962    02:DEAA             	.LL510	.alias		.LL494
11963                        	
11964                        		.dbg	line,	"main.c", 175; break;
11965                        		__bra		.LL494
         02:DEAA  4C 14 DE   			bra	.LL494
11966                        	
11967                        		.dbg	line,	"main.c", 176; }
11968    02:DEAD             	.LL493:
11969                        		__switch_r.ur	0, 4
         02:DEAD  C9 05      			cmp	#(4 - 0) + 1
         02:DEAF  90 02      			bcc	!found+
         02:DEB1  A9 05      	!default:	lda	#(4 - 0) + 1
         02:DEB3  0A         	!found:		asl	a
         02:DEB4  AA         			tax
         02:DEB5  7C B8 DE   			jmp	[!table+, x]
11970                        	
11971    02:DEB8  1A DE      	!table:		dw	.LL495, .LL496, .LL497, .LL507, .LL508
         02:DEBA  1C DE       
         02:DEBC  1E DE       
         02:DEBE  8B DE       
         02:DEC0  8D DE       
11972    02:DEC2  14 DE      			dw	.LL494
11973    02:DEC4             	.LL494	.alias		.LL491
11974                        	
11975                        		.dbg	line,	"main.c", 177; }
11976                        		__bra		.LL491
         02:DEC4  4C 14 DE   			bra	.LL491
11977    02:DEC7             	.LL492:
11978                        	
11979                        		.dbg	line,	"main.c", 178; }
11980    02:DEC7             	.LL483:
11981                        		__return	1
         02:DEC7  AA         			tax
         02:DEC8  4C EF FF   			jmp	leave_proc
11982                        		.dbg	clear
11983                        		.endp
11984                        		.pceas
11985                        	
11986                        		.dbg	clear
11987               6000     		.rodata
11988    01:6000             	__const1:
11989    01:6000  48 61 6C 74			db	'H','a','l','t',':',' ','S','G'
         01:6004  3A 20 53 47 
11990    01:6008  58 20 68 61			db	'X',' ','h','a','r','d','w','a'
         01:600C  72 64 77 61 
11991    01:6010  72 65 20 6E			db	'r','e',' ','n','o','t',' ','f'
         01:6014  6F 74 20 66 
11992    01:6018  6F 75 6E 64			db	'o','u','n','d',$00
         01:601C  00          
11993    01:601D             	_TABLE_NPC_TYPE_LV1:
11994    01:601D  01         			db	1
11995    01:601E  00         			db	0
11996    01:601F             	_TABLE_NPC_X_POS_REF_LV1:
11997    01:601F  90 03      			dw	912
11998    01:6021  D0 04      			dw	1232
11999    01:6023             	_TABLE_NPC_Y_POS_REF_LV1:
12000    01:6023  40 02      			dw	576
12001    01:6025  90 01      			dw	400
12002    01:6027             	_TABLE_OBJECT_TYPE_LV1:
12003    01:6027  00         			db	0
12004    01:6028  01         			db	1
12005    01:6029  01         			db	1
12006    01:602A  01         			db	1
12007    01:602B  01         			db	1
12008    01:602C  01         			db	1
12009    01:602D  01         			db	1
12010    01:602E  02         			db	2
12011    01:602F  01         			db	1
12012    01:6030  01         			db	1
12013    01:6031  01         			db	1
12014    01:6032  01         			db	1
12015    01:6033  01         			db	1
12016    01:6034  01         			db	1
12017    01:6035  01         			db	1
12018    01:6036  01         			db	1
12019    01:6037  01         			db	1
12020    01:6038  01         			db	1
12021    01:6039  01         			db	1
12022    01:603A  01         			db	1
12023    01:603B  01         			db	1
12024    01:603C  01         			db	1
12025    01:603D  01         			db	1
12026    01:603E             	_TABLE_OBJECT_X_POS_REF_LV1:
12027    01:603E  90 06      			dw	1680
12028    01:6040  00 05      			dw	1280
12029    01:6042  C0 05      			dw	1472
12030    01:6044  A0 05      			dw	1440
12031    01:6046  90 04      			dw	1168
12032    01:6048  B0 04      			dw	1200
12033    01:604A  C0 03      			dw	960
12034    01:604C  D8 03      			dw	984
12035    01:604E  50 05      			dw	1360
12036    01:6050  70 05      			dw	1392
12037    01:6052  10 06      			dw	1552
12038    01:6054  90 06      			dw	1680
12039    01:6056  B0 06      			dw	1712
12040    01:6058  D0 06      			dw	1744
12041    01:605A  E0 04      			dw	1248
12042    01:605C  00 05      			dw	1280
12043    01:605E  90 04      			dw	1168
12044    01:6060  10 04      			dw	1040
12045    01:6062  80 02      			dw	640
12046    01:6064  A0 02      			dw	672
12047    01:6066  50 01      			dw	336
12048    01:6068  70 01      			dw	368
12049    01:606A  A0 01      			dw	416
12050    01:606C             	_TABLE_OBJECT_Y_POS_REF_LV1:
12051    01:606C  80 01      			dw	384
12052    01:606E  A0 01      			dw	416
12053    01:6070  E0 01      			dw	480
12054    01:6072  F0 01      			dw	496
12055    01:6074  30 02      			dw	560
12056    01:6076  30 02      			dw	560
12057    01:6078  50 02      			dw	592
12058    01:607A  50 02      			dw	592
12059    01:607C  50 02      			dw	592
12060    01:607E  50 02      			dw	592
12061    01:6080  C0 02      			dw	704
12062    01:6082  D0 02      			dw	720
12063    01:6084  D0 02      			dw	720
12064    01:6086  D0 02      			dw	720
12065    01:6088  E0 02      			dw	736
12066    01:608A  E0 02      			dw	736
12067    01:608C  F0 02      			dw	752
12068    01:608E  50 03      			dw	848
12069    01:6090  70 03      			dw	880
12070    01:6092  70 03      			dw	880
12071    01:6094  80 03      			dw	896
12072    01:6096  80 03      			dw	896
12073    01:6098  80 03      			dw	896
12074    01:609A             	_TABLE_CHEST_X_POS_REF_LV1:
12075    01:609A  30 04      			dw	1072
12076    01:609C  30 03      			dw	816
12077    01:609E             	_TABLE_CHEST_Y_POS_REF_LV1:
12078    01:609E  40 03      			dw	832
12079    01:60A0  50 03      			dw	848
12080    01:60A2             	_TABLE_PLAYER_JUMP_V:
12081    01:60A2  FC         			db	-4
12082    01:60A3  FB         			db	-5
12083    01:60A4  F6         			db	-10
12084    01:60A5  FC         			db	-4
12085    01:60A6  FC         			db	-4
12086    01:60A7  F9         			db	-7
12087    01:60A8  FA         			db	-6
12088    01:60A9  FD         			db	-3
12089    01:60AA  FB         			db	-5
12090    01:60AB  FE         			db	-2
12091    01:60AC  FC         			db	-4
12092    01:60AD  FF         			db	-1
12093    01:60AE  FF         			db	-1
12094    01:60AF  FF         			db	-1
12095    01:60B0  FF         			db	-1
12096    01:60B1  00         			db	0
12097    01:60B2  00         			db	0
12098    01:60B3  00         			db	0
12099    01:60B4  00         			db	0
12100    01:60B5  01         			db	1
12101    01:60B6  01         			db	1
12102    01:60B7  01         			db	1
12103    01:60B8  01         			db	1
12104    01:60B9  04         			db	4
12105    01:60BA  02         			db	2
12106    01:60BB  05         			db	5
12107    01:60BC  03         			db	3
12108    01:60BD  06         			db	6
12109    01:60BE  07         			db	7
12110    01:60BF  04         			db	4
12111    01:60C0  04         			db	4
12112    01:60C1  0A         			db	10
12113    01:60C2  04         			db	4
12114    01:60C3  04         			db	4
12115    01:60C4  05         			db	5
12116    01:60C5             	_TABLE_PLAYER_FALL:
12117    01:60C5  00         			db	0
12118    01:60C6  00         			db	0
12119    01:60C7  00         			db	0
12120    01:60C8  00         			db	0
12121    01:60C9  01         			db	1
12122    01:60CA  01         			db	1
12123    01:60CB  01         			db	1
12124    01:60CC  01         			db	1
12125    01:60CD  02         			db	2
12126    01:60CE  02         			db	2
12127    01:60CF  02         			db	2
12128    01:60D0  02         			db	2
12129    01:60D1  03         			db	3
12130    01:60D2  03         			db	3
12131    01:60D3  03         			db	3
12132    01:60D4  04         			db	4
12133    01:60D5  04         			db	4
12134    01:60D6  04         			db	4
12135    01:60D7  04         			db	4
12136    01:60D8  04         			db	4
12137    01:60D9  05         			db	5
12138    01:60DA             	_TABLE_PLAYER_JUMP_LADDER:
12139    01:60DA  FC         			db	-4
12140    01:60DB  FC         			db	-4
12141    01:60DC  FD         			db	-3
12142    01:60DD  FD         			db	-3
12143    01:60DE  FD         			db	-3
12144    01:60DF  FE         			db	-2
12145    01:60E0  FE         			db	-2
12146    01:60E1  FE         			db	-2
12147    01:60E2  FF         			db	-1
12148    01:60E3  FF         			db	-1
12149    01:60E4  FF         			db	-1
12150    01:60E5  FF         			db	-1
12151    01:60E6  FF         			db	-1
12152    01:60E7  00         			db	0
12153    01:60E8  00         			db	0
12154    01:60E9  00         			db	0
12155    01:60EA  00         			db	0
12156    01:60EB  01         			db	1
12157    01:60EC  01         			db	1
12158    01:60ED  01         			db	1
12159    01:60EE  01         			db	1
12160    01:60EF  01         			db	1
12161    01:60F0  02         			db	2
12162    01:60F1  02         			db	2
12163    01:60F2  02         			db	2
12164    01:60F3  03         			db	3
12165    01:60F4  03         			db	3
12166    01:60F5  03         			db	3
12167    01:60F6  04         			db	4
12168    01:60F7  04         			db	4
12169    01:60F8             	_TABLE_SHOP_ITEMS_LV1:
12170    01:60F8  00         			db	0
12171    01:60F9  01         			db	1
12172    01:60FA  02         			db	2
12173    01:60FB  03         			db	3
12174    01:60FC  04         			db	4
12175    01:60FD  05         			db	5
12176    01:60FE  06         			db	6
12177    01:60FF  07         			db	7
12178    01:6100  08         			db	8
12179    01:6101  09         			db	9
12180    01:6102             	_TABLE_SHOP_PRICES_LV1:
12181    01:6102  64 00      			dw	100
12182    01:6104  E8 03      			dw	1000
12183    01:6106  60 09      			dw	2400
12184    01:6108  80 25      			dw	9600
12185    01:610A  1E 00      			dw	30
12186    01:610C  50 00      			dw	80
12187    01:610E  2C 01      			dw	300
12188    01:6110  20 03      			dw	800
12189    01:6112  40 06      			dw	1600
12190    01:6114  96 00      			dw	150
12191    01:6116             	_TABLE_SHOP_ITEMS_TILES_ADR:
12192    01:6116  E0 60      			dw	_tiles_ITEM_WEAPON_2
12193    01:6118  60 61      			dw	_tiles_ITEM_WEAPON_3
12194    01:611A  E0 61      			dw	_tiles_ITEM_WEAPON_4
12195    01:611C  60 62      			dw	_tiles_ITEM_WEAPON_5
12196    01:611E  E0 62      			dw	_tiles_ITEM_KEY
12197    01:6120  60 63      			dw	_tiles_ITEM_ARMOR_2
12198    01:6122  E0 63      			dw	_tiles_ITEM_ARMOR_3
12199    01:6124  60 64      			dw	_tiles_ITEM_ARMOR_4
12200    01:6126  E0 64      			dw	_tiles_ITEM_ARMOR_5
12201    01:6128  60 65      			dw	_tiles_ITEM_POTION
12202    01:612A             	_TABLE_SHOP_ITEMS_TILES_BANK:
12203    01:612A  0E         			db	^_tiles_ITEM_WEAPON_2
12204    01:612B  0E         			db	^_tiles_ITEM_WEAPON_3
12205    01:612C  0E         			db	^_tiles_ITEM_WEAPON_4
12206    01:612D  0E         			db	^_tiles_ITEM_WEAPON_5
12207    01:612E  0E         			db	^_tiles_ITEM_KEY
12208    01:612F  0E         			db	^_tiles_ITEM_ARMOR_2
12209    01:6130  0E         			db	^_tiles_ITEM_ARMOR_3
12210    01:6131  0E         			db	^_tiles_ITEM_ARMOR_4
12211    01:6132  0E         			db	^_tiles_ITEM_ARMOR_5
12212    01:6133  0E         			db	^_tiles_ITEM_POTION
12213    01:6134             	_TABLE_CURSOR_POS_X:
12214    01:6134  18         			db	24
12215    01:6135  38         			db	56
12216    01:6136  60         			db	96
12217    01:6137  88         			db	136
12218    01:6138  B0         			db	176
12219    01:6139  18         			db	24
12220    01:613A  38         			db	56
12221    01:613B  60         			db	96
12222    01:613C  88         			db	136
12223    01:613D  B0         			db	176
12224    01:613E  D4         			db	212
12225                        	
12226               2310     		.bss
12227    F8:2310             	_sequence_id:
12228    F8:2310             			ds	1
12229    F8:2311             	_sequence_loaded:
12230    F8:2311             			ds	1
12231    F8:2312             	_level_id:
12232    F8:2312             			ds	1
12233    F8:2313             	_respawn:
12234    F8:2313             			ds	1
12235    F8:2314             	_player_id:
12236    F8:2314             			ds	1
12237    F8:2315             	_player_state:
12238    F8:2315             			ds	1
12239    F8:2316             	_player_axis:
12240    F8:2316             			ds	1
12241    F8:2317             	_player_previous_axis:
12242    F8:2317             			ds	1
12243    F8:2318             	_player_counter_anim:
12244    F8:2318             			ds	1
12245    F8:2319             	_player_index_jump:
12246    F8:2319             			ds	1
12247    F8:231A             	_player_index_fall:
12248    F8:231A             			ds	1
12249    F8:231B             	_jump_ladder:
12250    F8:231B             			ds	1
12251    F8:231C             	_jump_max_index:
12252    F8:231C             			ds	1
12253    F8:231D             	_armor_level:
12254    F8:231D             			ds	1
12255    F8:231E             	_weapon_level:
12256    F8:231E             			ds	1
12257    F8:231F             	_life_amount:
12258    F8:231F             			ds	1
12259    F8:2320             	_key_amount:
12260    F8:2320             			ds	1
12261    F8:2321             	_potion_amount:
12262    F8:2321             			ds	1
12263    F8:2322             	_minutes:
12264    F8:2322             			ds	1
12265    F8:2323             	_seconds:
12266    F8:2323             			ds	1
12267    F8:2324             	_time_counter:
12268    F8:2324             			ds	1
12269    F8:2325             	_object_start_index:
12270    F8:2325             			ds	1
12271    F8:2326             	_level_object_number:
12272    F8:2326             			ds	1
12273    F8:2327             	_onscreen_object_number:
12274    F8:2327             			ds	1
12275    F8:2328             	_list_object_type:
12276    F8:2328             			ds	25
12277    F8:2341             	_list_object_state:
12278    F8:2341             			ds	25
12279    F8:235A             	_list_object_energy:
12280    F8:235A             			ds	25
12281    F8:2373             	_list_reward_type:
12282    F8:2373             			ds	25
12283    F8:238C             	_list_onscreen_object:
12284    F8:238C             			ds	8
12285    F8:2394             	_chest_start_index:
12286    F8:2394             			ds	1
12287    F8:2395             	_level_chest_number:
12288    F8:2395             			ds	1
12289    F8:2396             	_onscreen_chest_number:
12290    F8:2396             			ds	1
12291    F8:2397             	_list_chest_state:
12292    F8:2397             			ds	8
12293    F8:239F             	_list_onscreen_chest:
12294    F8:239F             			ds	8
12295    F8:23A7             	_npc_start_index:
12296    F8:23A7             			ds	1
12297    F8:23A8             	_level_npc_number:
12298    F8:23A8             			ds	1
12299    F8:23A9             	_onscreen_npc_number:
12300    F8:23A9             			ds	1
12301    F8:23AA             	_list_npc_type:
12302    F8:23AA             			ds	9
12303    F8:23B3             	_list_npc_state:
12304    F8:23B3             			ds	9
12305    F8:23BC             	_list_onscreen_npc:
12306    F8:23BC             			ds	9
12307    F8:23C5             	_index_x:
12308    F8:23C5             			ds	1
12309    F8:23C6             	_index_y:
12310    F8:23C6             			ds	1
12311    F8:23C7             	_item_index:
12312    F8:23C7             			ds	1
12313    F8:23C8             	_tilemap_mask:
12314    F8:23C8             			ds	256
12315    F8:24C8             	_player_pos_x:
12316    F8:24C8             			ds	2
12317    F8:24CA             	_player_pos_y:
12318    F8:24CA             			ds	2
12319    F8:24CC             	_camera_max_y_position:
12320    F8:24CC             			ds	2
12321    F8:24CE             	_camera_pos_x_backup:
12322    F8:24CE             			ds	2
12323    F8:24D0             	_camera_pos_y_backup:
12324    F8:24D0             			ds	2
12325    F8:24D2             	_list_object_x_pos:
12326    F8:24D2             			ds	50
12327    F8:2504             	_list_object_y_pos:
12328    F8:2504             			ds	50
12329    F8:2536             	_list_object_x_pos_ref:
12330    F8:2536             			ds	50
12331    F8:2568             	_list_object_y_pos_ref:
12332    F8:2568             			ds	50
12333    F8:259A             	_list_chest_x_pos:
12334    F8:259A             			ds	16
12335    F8:25AA             	_list_chest_y_pos:
12336    F8:25AA             			ds	16
12337    F8:25BA             	_list_chest_x_pos_ref:
12338    F8:25BA             			ds	16
12339    F8:25CA             	_list_chest_y_pos_ref:
12340    F8:25CA             			ds	16
12341    F8:25DA             	_list_npc_x_pos:
12342    F8:25DA             			ds	18
12343    F8:25EC             	_list_npc_y_pos:
12344    F8:25EC             			ds	18
12345    F8:25FE             	_list_npc_x_pos_ref:
12346    F8:25FE             			ds	18
12347    F8:2610             	_list_npc_y_pos_ref:
12348    F8:2610             			ds	18
12349    F8:2622             	_zenny_amount:
12350    F8:2622             			ds	2
12351    F8:2624             	_score:
12352    F8:2624             			ds	2
12353    F8:2626             	_shop_prices:
12354    F8:2626             			ds	20
12355    F8:263A             	_ptr_SHOP_ITEM_PRICES:
12356    F8:263A             			ds	2
12357                        	
12358                        	
12359                        	;0 error(s) in compilation
12360                        	;	literal pool:29
12361                        	;	constant pool:290
12362                        	;	global pool:501
12363                        	;	Macro pool:264
12364    F8:263C             	leaf_loc:
12365    F8:263C             			ds	4
12366    F8:2640             	__hide_LEVEL_SPRITES_end:
12367    F8:2640             	__scroll_object_end:
12368    F8:2640             	__scroll_chest_end:
12369    F8:2640             	__scroll_npc_end:
12370    F8:2640             	__check_TILE_DEPTH_end:
12371    F8:2640             	__check_BG_end:
12372    F8:2640             	__check_NPC_end:
12373    F8:2640             	__recenter_CAMERA_end:
12374    F8:2640             	__init_OBJECT_LV1_end:
12375    F8:2640             	__init_CHEST_LV1_end:
12376    F8:2640             	__init_NPC_LV1_end:
12377                        	
12378    F8:2640             	__bss_init:
12379                        	
12380    F8:2640             	__heap_start:
                             #[2]   "..\..\..\include\hucc\hucc-final.asm"
    1                        	; ***************************************************************************
    2                        	; ***************************************************************************
    3                        	;
    4                        	; hucc-final.asm
    5                        	;
    6                        	; PCEAS auto-includes this file at the end of every pass in HuCC or SDCC.
    7                        	;
    8                        	; Copyright John Brandwood 2024.
    9                        	;
   10                        	; Distributed under the Boost Software License, Version 1.0.
   11                        	; (See accompanying file LICENSE_1_0.txt or copy at
   12                        	;  http://www.boost.org/LICENSE_1_0.txt)
   13                        	;
   14                        	; ***************************************************************************
   15                        	; ***************************************************************************
   16                        	;
   17                        	; This is used to select which assembly-language library files to include in
   18                        	; a HuCC project, using labels defined in the compiler's header files.
   19                        	;
   20                        	; ***************************************************************************
   21                        	; ***************************************************************************
   22                        	
   23                        			; Allow projects to customize what is included at the end
   24                        			; of a pass without replacing the entire "hucc-final.asm".
   25                        	
   26               E309     			.code
   27               0000     			.bank	CORE_BANK
   28               E309     			.page	CORE_PAGE
   29                        	
                             #[3]   "..\..\..\include\hucc\hucc-final-extra.asm"
   30                        			include	"hucc-final-extra.asm"
    1                        	; ***************************************************************************
    2                        	; ***************************************************************************
    3                        	;
    4                        	; hucc-final-extra.asm
    5                        	;
    6                        	; hucc-final.asm includes this file at the end of every pass in HuCC or SDCC.
    7                        	;
    8                        	; Copyright John Brandwood 2024.
    9                        	;
   10                        	; Distributed under the Boost Software License, Version 1.0.
   11                        	; (See accompanying file LICENSE_1_0.txt or copy at
   12                        	;  http://www.boost.org/LICENSE_1_0.txt)
   13                        	;
   14                        	; ***************************************************************************
   15                        	; ***************************************************************************
   16                        	;
   17                        	; This is used to select which assembly-language library files to include in
   18                        	; a HuCC project, using labels defined in the compiler's header files.
   19                        	;
   20                        	; ***************************************************************************
   21                        	; ***************************************************************************
                             #[2]   "..\..\..\include\hucc\hucc-final.asm"
   31                        	
   32                        			; Libraries required for basic functionality.
   33                        	
   34               E309     			.code
   35               0000     			.bank	CORE_BANK
   36               E309     			.page	CORE_PAGE
   37                        	
                             #[3]   "..\..\..\include\hucc\common.asm"
   38                        			include	"common.asm"		; Common helpers.
    1                        	; ***************************************************************************
    2                        	; ***************************************************************************
    3                        	;
    4                        	; common.asm
    5                        	;
    6                        	; Small, generic, PCE subroutines that are commonly useful when developing.
    7                        	;
    8                        	; These should be located in permanently-accessible memory!
    9                        	;
   10                        	; Copyright John Brandwood 2021-2024.
   11                        	;
   12                        	; Distributed under the Boost Software License, Version 1.0.
   13                        	; (See accompanying file LICENSE_1_0.txt or copy at
   14                        	;  http://www.boost.org/LICENSE_1_0.txt)
   15                        	;
   16                        	; ***************************************************************************
   17                        	; ***************************************************************************
   18                        	
   19                        	
   20                        	
   21                        	; ***************************************************************************
   22                        	; ***************************************************************************
   23                        	;
   24                        	; Wait for the next VBLANK IRQ.
   25                        	;
   26                        	
   27    00:E309  AD 41 22   	wait_vsync:	lda	irq_cnt			; System Card variable, changed
   28    00:E30C  CD 41 22   	.loop:		cmp	irq_cnt			; every VBLANK interrupt.
   29    00:E30F  F0 FB      			beq	.loop
   30               0001     		.ifdef	HUCC
   31    00:E311  8D EB 22   			sta	old_cnt			; Remember the frame count.
   32                        		.endif
   33    00:E314  60         			rts
   34                        	
   35                        	
   36                        	
   37                        	; ***************************************************************************
   38                        	; ***************************************************************************
   39                        	;
   40                        	; Delay for the next Y VBLANK IRQs.
   41                        	;
   42                        	
   43               0001     		.ifdef	HUCC
   44    00:E315             	_vsync		.alias	wait_vsync
   45                        	
   46    00:E315  AD 41 22   	_vsync.1:	lda	irq_cnt			; HuCC's vsync(n) was defined
   47    00:E318  38         			sec				; as frames from the previous
   48    00:E319  ED EB 22   			sbc	old_cnt			; vsync() call, 1 to 255.
   49    00:E31C  38         			sec
   50    00:E31D  E5 F8      			sbc	<_al
   51    00:E31F  90 02      			bcc	!+
   52    00:E321  A9 FF      			lda	#$FF
   53    00:E323  49 FF      	!:		eor	#$FF
   54    00:E325  1A         			inc	a
   55    00:E326  A8         			tay
   56                        		.endif
   57                        	
   58    00:E327  44 E0      	wait_nvsync:	bsr	wait_vsync		; # of VBLANK IRQs to wait in
   59    00:E329  88         			dey				; the Y register.
   60    00:E32A  D0 FB      			bne	wait_nvsync
   61    00:E32C  60         			rts
   62                        	
   63                        	
   64                        	
   65               0000     		.ifndef	HUCC
  101                        		.endif
  102                        	
  103                        	
  104                        	
  105                        	; ***************************************************************************
  106                        	; ***************************************************************************
  107                        	;
  108                        	; Map the _bp data far-pointer into MPR3 (& MPR4).
  109                        	;
  110                        	; Because the 16KB RAM region at $2000-$5FFF is composed of two separate
  111                        	; banks, with the 2nd bank having no specific relation to the 1st, there
  112                        	; is no way to deal with a bank-increment, so do not map that region.
  113                        	;
  114                        	; N.B. Library code relies on this preserving X and V!
  115                        	;
  116                        	
  117    00:E32D  98         	map_bp_to_mpr3:	tya				; Put bank into MPR3.
  118    00:E32E  F0 0A      			beq	!+
  119    00:E330  53 08      			tam3
  120    00:E332  A5 ED      			lda.h	<_bp			; Do not remap a ptr to RAM,
  121    00:E334  29 1F      			and	#$1F			; Remap ptr to MPR3.
  122    00:E336  09 60      			ora	#$60
  123    00:E338  85 ED      			sta.h	<_bp
  124    00:E33A  60         	!:		rts
  125                        	
  126    00:E33B  98         	map_bp_to_mpr34:tya				; Put bank into MPR3.
  127    00:E33C  F0 0D      			beq	!+
  128    00:E33E  53 08      			tam3
  129    00:E340  1A         			inc	a			; Put next into MPR4.
  130    00:E341  53 10      			tam4
  131    00:E343  A5 ED      			lda.h	<_bp			; Do not remap a ptr to RAM,
  132    00:E345  29 1F      			and	#$1F			; Remap ptr to MPR3.
  133    00:E347  09 60      			ora	#$60
  134    00:E349  85 ED      			sta.h	<_bp
  135    00:E34B  60         	!:		rts
  136                        	
  137                        	
  138                        	
  139                        	; ***************************************************************************
  140                        	; ***************************************************************************
  141                        	;
  142                        	; Increment the hi-byte of _bp and change TMA3 if necessary.
  143                        	;
  144                        	; N.B. Library code relies on this preserving A,X,Y and V!
  145                        	;
  146                        	
  147    00:E34C  E6 ED      	inc.h_bp_mpr3:	inc.h	<_bp			; Increment hi-byte of _bp.
  148    00:E34E  10 0B      			bpl	!+			; OK if within MPR0-MPR3.
  149    00:E350  48         			pha				; Increment the bank in MPR3,
  150    00:E351  43 08      			tma3				; usually when pointer moves
  151    00:E353  1A         			inc	a			; from $7FFF -> $8000.
  152    00:E354  53 08      			tam3
  153    00:E356  A9 60      			lda	#$60
  154    00:E358  85 ED      			sta.h	<_bp
  155    00:E35A  68         			pla
  156    00:E35B  60         	!:		rts
  157                        	
  158                        	
  159                        	
  160                        	; ***************************************************************************
  161                        	; ***************************************************************************
  162                        	;
  163                        	; Increment the hi-byte of _bp and change TMA3 and TMA4 if necessary.
  164                        	;
  165                        	; N.B. Library code relies on this preserving A,X,Y and V!
  166                        	;
  167                        	
  168    00:E35C  E6 ED      	inc.h_bp_mpr34:	inc.h	<_bp			; Increment hi-byte of _bp.
  169    00:E35E  10 0D      			bpl	!+			; OK if within MPR0-MPR3.
  170    00:E360  48         			pha				; Increment the bank in MPR3,
  171    00:E361  43 10      			tma4				; usually when pointer moves
  172    00:E363  53 08      			tam3				; from $7FFF -> $8000.
  173    00:E365  1A         			inc	a
  174    00:E366  53 10      			tam4
  175    00:E368  A9 60      			lda	#$60
  176    00:E36A  85 ED      			sta.h	<_bp
  177    00:E36C  68         			pla
  178    00:E36D  60         	!:		rts
  179                        	
  180                        	
  181                        	
  182                        	; ***************************************************************************
  183                        	; ***************************************************************************
  184                        	;
  185                        	; Put the _di data pointer into the VDC's MARR or MAWR register.
  186                        	;
  187                        	; N.B. Library code relies on this preserving Y!
  188                        	;
  189                        	
  190               0001     		.if	SUPPORT_SGX
  191    00:E36E  A2 10      	sgx_di_to_marr:	ldx	#SGX_VDC_OFFSET		; Offset to SGX VDC.
  192    00:E370  F0         			db	$F0			; Turn "clx" into a "beq".
  193                        		.endif
  194                        	
  195    00:E371  82         	vdc_di_to_marr:	clx				; Offset to PCE VDC.
  196                        	
  197    00:E372  A9 01      	set_di_to_marr	lda	#VDC_MARR		; Set VDC or SGX destination
  198    00:E374  95 F7      			sta	<vdc_reg, x		; address.
  199    00:E376  9D 00 02   			sta	VDC_AR, x
  200    00:E379  80 09      			bra	!+
  201                        	
  202               0001     		.if	SUPPORT_SGX
  203    00:E37B  A2 10      	sgx_di_to_mawr:	ldx	#SGX_VDC_OFFSET		; Offset to SGX VDC.
  204    00:E37D  F0         			db	$F0			; Turn "clx" into a "beq".
  205                        		.endif
  206                        	
  207    00:E37E  82         	vdc_di_to_mawr:	clx				; Offset to PCE VDC.
  208                        	
  209    00:E37F             	set_di_to_mawr;	lda	#VDC_MAWR		; Set VDC or SGX destination
  210    00:E37F  74 F7      			stz	<vdc_reg, x		; address.
  211    00:E381  9E 00 02   			stz	VDC_AR, x
  212                        	
  213    00:E384  A5 F0      	!:		lda	<_di + 0
  214    00:E386  9D 02 02   			sta	VDC_DL, x
  215    00:E389  A5 F1      			lda	<_di + 1
  216    00:E38B  9D 03 02   			sta	VDC_DH, x
  217                        	
  218    00:E38E  A9 02      			lda	#VDC_VWR		; Select the VRR/VWR data
  219    00:E390  95 F7      			sta	<vdc_reg, x		; register.
  220    00:E392  9D 00 02   			sta	VDC_AR, x
  221    00:E395  60         			rts
  222                        	
  223                        	
  224                        	
  225                        	; ***************************************************************************
  226                        	; ***************************************************************************
  227                        	;
  228                        	; Increment the hi-byte of _di and change TMA4 if necessary.
  229                        	;
  230                        	
  231               0000     		.if	0				; Save memory, for now.
  250                        		.endif
  251                        	
  252                        	
  253                        	
  254                        	; ***************************************************************************
  255                        	; ***************************************************************************
  256                        	;
  257                        	; Far-call a function in another bank.
  258                        	;
  259                        	; This is a potential alternative procedure call trampoline that uses only 10
  260                        	; bytes of common memory per bank of procedures, instead of 10 bytes for each
  261                        	; individual procedure call, BUT it uses the X register as a procedure-index,
  262                        	; and it needs a table of addresses at the end of every procedure bank.
  263                        	;
  264                        	; To use this ...
  265                        	;
  266                        	;  ldx #procedure-index
  267                        	;  jsr far_call_nn
  268                        	;
  269                        	; The called .PROC routine must exit with "jmp leave_proc" and not "rts".
  270                        	;
  271                        	; leave_proc:	pla
  272                        	;		tam6
  273                        	;		tya
  274                        	;		rts
  275                        	;
  276                        	; N.B. This costs 21 cycles vs 18 for the .newproc trampoline code (when you
  277                        	;      exclude preserving YA in zero-page).
  278                        	;
  279                        	; N.B. This was written as an excerise, and definitely not for HuC!
  280                        	;
  281                        	
  282               0000     		.if	0
  295                        		.endif					; 21
                             #[2]   "..\..\..\include\hucc\hucc-final.asm"
                             #[3]   "..\..\..\include\hucc\vce.asm"
   39                        			include	"vce.asm"		; Useful VCE routines.
    1                        	; ***************************************************************************
    2                        	; ***************************************************************************
    3                        	;
    4                        	; vce.asm
    5                        	;
    6                        	; Useful routines for operating the HuC6260 Video Color Encoder
    7                        	;
    8                        	; These should be located in permanently-accessible memory!
    9                        	;
   10                        	; Copyright John Brandwood 2021-2025.
   11                        	;
   12                        	; Distributed under the Boost Software License, Version 1.0.
   13                        	; (See accompanying file LICENSE_1_0.txt or copy at
   14                        	;  http://www.boost.org/LICENSE_1_0.txt)
   15                        	;
   16                        	; ***************************************************************************
   17                        	; ***************************************************************************
   18                        	
   19                        	;
   20                        	; Configure Library ...
   21                        	;
   22                        	
   23               0000     		.ifndef VCE_SPLIT_CROSS
   25                        		.endif
   26                        	
   27                        	
   28                        	
   29                        	; ***************************************************************************
   30                        	; ***************************************************************************
   31                        	;
   32                        	; xfer_palettes - Update the VCE with the queued palettes changes.
   33                        	;
   34                        	; This is normally called in a developer's vsync_hook handler, but it can
   35                        	; be called manually as long as it will not also be called in an interrupt.
   36                        	;
   37                        	; The queued transfers are split into 32-byte chunks so that an HSYNC and/or
   38                        	; TIMER IRQ is not delayed for too long during the VBLANK.
   39                        	;
   40                        	
   41    00:E396  A9 80      	xfer_palettes:	lda	#$80			; Acquire color mutex to avoid
   42    00:E398  0C 40 26   			tsb	color_mutex		; conflict with a delayed VBL.
   43    00:E39B  30 5F      			bmi	.busy
   44                        	
   45    00:E39D  AC 41 26   			ldy	color_queue_r		; Are there any palette xfers
   46    00:E3A0  CC 42 26   			cpy	color_queue_w		; queued up?
   47    00:E3A3  F0 54      			beq	.exit
   48                        	
   49    00:E3A5  08         			php				; Enable interrupts so that an
   50    00:E3A6  58         			cli				; HSYNC or TIMER IRQ can occur.
   51                        	
   52    00:E3A7  43 08      			tma3				; Preserve MPR3 & MPR4 because
   53    00:E3A9  48         			pha				; this normally runs in the
   54    00:E3AA  43 10      			tma4				; VBLANK IRQ.
   55    00:E3AC  48         			pha
   56                        	
   57               0001     		.if	!CDROM
   58    00:E3AD  73 02 E4 86			tii	.tia_func, color_tia, 8 ; Copy TIA to RAM.
         00:E3B1  22 08 00    
   59                        		.endif
   60                        	
   61    00:E3B4  B9 43 26   	.next_item:	lda	color_index, y		; Get the next set of palettes
   62    00:E3B7  0A         			asl	a			; from the queue.
   63    00:E3B8  0A         			asl	a
   64    00:E3B9  0A         			asl	a
   65    00:E3BA  0A         			asl	a
   66    00:E3BB  8D 02 04   			sta	VCE_CTA + 0
   67    00:E3BE  62         			cla
   68    00:E3BF  2A         			rol	a
   69    00:E3C0  8D 03 04   			sta	VCE_CTA + 1
   70                        	
   71    00:E3C3  BE 4B 26   			ldx	color_count,y		; How many palettes to xfer?
   72                        	
   73    00:E3C6  B9 63 26   			lda	color_bank, y		; Map data into MPR3 & MPR4.
   74    00:E3C9  53 08      			tam3
   75    00:E3CB  1A         			inc	a
   76    00:E3CC  53 10      			tam4
   77    00:E3CE  B9 5B 26   			lda	color_addr_h, y
   78    00:E3D1  8D 88 22   			sta	.ram_tia + 2
   79    00:E3D4  B9 53 26   			lda	color_addr_l, y
   80    00:E3D7  8D 87 22   	.palette_loop:	sta	.ram_tia + 1
   81                        	
   82               0000     		.if	CDROM
   84                        		.else
   85    00:E3DA  20 86 22   			jsr	.ram_tia		; Copy 32-bytes to the VCE.
   86                        		.endif
   87                        	
   88    00:E3DD  18         			clc				; Increment the data ptr to
   89    00:E3DE  69 20      			adc	#32			; the next 32-byte palette.
   90    00:E3E0  B0 1B      			bcs	.next_page
   91                        	
   92    00:E3E2  CA         	.next_palette:	dex				; Any palettes left to xfer?
   93    00:E3E3  D0 F2      			bne	.palette_loop
   94                        	
   95    00:E3E5  C8         			iny				; Increment the queue index.
   96    00:E3E6  98         			tya
   97    00:E3E7  29 07      			and	#7
   98    00:E3E9  A8         			tay
   99                        	
  100    00:E3EA  CC 42 26   			cpy	color_queue_w		; Any more items in the queue?
  101    00:E3ED  D0 C5      			bne	.next_item
  102    00:E3EF  8C 41 26   			sty	color_queue_r		; Signal the queue is empty.
  103                        	
  104    00:E3F2  68         			pla				; Restore MPR3 & MPR4.
  105    00:E3F3  53 10      			tam4
  106    00:E3F5  68         			pla
  107    00:E3F6  53 08      			tam3
  108                        	
  109    00:E3F8  28         			plp				; Restore interrupt state.
  110                        	
  111    00:E3F9  9C 40 26   	.exit:		stz	color_mutex		; Release color mutex.
  112                        	
  113    00:E3FC  60         	.busy:		rts
  114                        	
  115    00:E3FD  EE 88 22   	.next_page:	inc	.ram_tia + 2
  116    00:E400  80 E0      			bra	.next_palette
  117                        	
  118               0001     		.if	!CDROM
  119               2286     	.ram_tia	=	color_tia		; Use a TIA in RAM.
  120                        	
  121    00:E402  E3 00 00 04	.tia_func:	tia	0, VCE_CTW, 32
         00:E406  04 20 00    
  122    00:E409  60         			rts
  123                        		.endif	!CDROM
  124                        	
  125               2640     			.bss
  126                        	
  127    F8:2640             	color_mutex:	ds	1			; Mutex for VCE changes.
  128    F8:2641             	color_queue_r:	ds	1			; Ring buffer read index.
  129    F8:2642             	color_queue_w:	ds	1			; Ring buffer write index.
  130    F8:2643             	color_index:	ds	8			; Ring buffer - Palette index.
  131    F8:264B             	color_count:	ds	8			; Ring buffer - Palette count.
  132    F8:2653             	color_addr_l:	ds	8			; Ring buffer - Data Ptr (lo).
  133    F8:265B             	color_addr_h:	ds	8			; Ring buffer - Data Ptr (hi).
  134    F8:2663             	color_bank:	ds	8			; Ring buffer - Data Ptr (bank).
  135                        	
  136               E40A     			.code
  137                        	
  138                        	
  139                        	
  140                        	; ***************************************************************************
  141                        	; ***************************************************************************
  142                        	;
  143                        	; load_palettes - Queue a set of palettes to upload to the VCE next VBLANK.
  144                        	;
  145                        	; Args: _al = Palette index (0..15 for BG, 16..31 for SPR).
  146                        	; Args: _ah = Palette count (1..32).
  147                        	; Args: _bp = Pointer to palette data.
  148                        	; Args:   Y = Bank to map into MPR3 & MPR4, or zero to leave unchanged.
  149                        	;
  150                        	; N.B. Y==0 is only useful if the palette data is permanently mapped!
  151                        	;
  152                        	
  153                        	load_palettes	.proc
  179                        			.endp
  180                        	
  181                        	
  182                        	
  183                        	; ***************************************************************************
  184                        	; ***************************************************************************
  185                        	;
  186                        	; clear_vce - Clear all 512 of the VCE's palette entries.
  187                        	;
  188                        	
  189    11:C9D2             	clear_vce	.proc
  190                        	
  191    11:C9D2  08         			php				; Disable interrupts to avoid
  192    11:C9D3  78         			sei				; VBLANK palette upload.
  193    11:C9D4  C2         			cly
  194    11:C9D5  9C 02 04   			stz	VCE_CTA+0		; Set VCE write address.
  195    11:C9D8  9C 03 04   			stz	VCE_CTA+1
  196    11:C9DB  9C 04 04   	.loop:		stz	VCE_CTW+0		; Set lo-byte of color.
  197    11:C9DE  9C 05 04   			stz	VCE_CTW+1		; Write 1 color value.
  198    11:C9E1  9C 04 04   			stz	VCE_CTW+0		; Set lo-byte of color.
  199    11:C9E4  9C 05 04   			stz	VCE_CTW+1		; Write 1 color value.
  200    11:C9E7  88         			dey
  201    11:C9E8  D0 F1      			bne	.loop
  202    11:C9EA  28         			plp
  203                        	
  204                        			leave				; All done, phew!
         11:C9EB  4C EF FF   			jmp	leave_proc
  205                        	
  206                        			.endp
  207                        	
  208               0001     		.ifdef	HUCC
  209    00:E40A             			.alias	_clear_palette		= clear_vce
  210                        		.endif
  211                        	
  212                        	
  213                        	
  214                        	; ***************************************************************************
  215                        	; ***************************************************************************
  216                        	;
  217                        	; read_palettes - Read palettes from the VCE into a buffer in RAM.
  218                        	;
  219                        	; Args: _al = Palette index (0..15 for BG, 16..31 for SPR).
  220                        	; Args: _ah = Palette count (1..32).
  221                        	; Args: _di = Pointer to palette data destination in RAM.
  222                        	;
  223                        	; The transfer is split into 32-byte chunks so that an HSYNC and/or TIMER
  224                        	; IRQ is not delayed for too long while executing.
  225                        	;
  226                        	
  227                        	read_palettes	.proc
  281                        			.endp
  282                        	
  283               0001     		.ifdef	HUCC
  284    00:E40A             			.alias	_read_palette.3		= read_palettes
  285                        		.endif
  286                        	
  287                        	
  288                        	
  289                        	vce_fade_funcs	.procgroup
  516                        			.endprocgroup
  517                        	
  518                        	
  519                        	
  520                        	; ***************************************************************************
  521                        	; ***************************************************************************
  522                        	;
  523                        	; cross_fade_to - Cross fade a palette in RAM towards a reference palette.
  524                        	;
  525                        	; Args: _al = Number of colors (1..256).
  526                        	; Args: _di = Pointer to faded palette destination in RAM.
  527                        	; Args: _bp = Pointer to reference palette data.
  528                        	; Args:   Y = Bank to map into MPR3 & MPR4, or zero to leave unchanged.
  529                        	;
  530                        	; N.B. Y==0 is only useful if the reference palette data is already mapped!
  531                        	;
  532                        	; N.B. This only updates the palette in RAM by 1 RGB step, so it will need
  533                        	;      to be called 7 times to guarantee that you've reached the target.
  534                        	;
  535                        	
  536                        	cross_fade_to	.proc
  658                        			.endp
                             #[2]   "..\..\..\include\hucc\hucc-final.asm"
                             #[3]   "..\..\..\include\hucc\vdc.asm"
   40                        			include	"vdc.asm"		; Useful VDC routines.
    1                        	; ***************************************************************************
    2                        	; ***************************************************************************
    3                        	;
    4                        	; vdc.asm
    5                        	;
    6                        	; Useful routines for operating the HuC6270 Video Display Controller.
    7                        	;
    8                        	; These should be located in permanently-accessible memory!
    9                        	;
   10                        	; Copyright John Brandwood 2021-2025.
   11                        	;
   12                        	; Distributed under the Boost Software License, Version 1.0.
   13                        	; (See accompanying file LICENSE_1_0.txt or copy at
   14                        	;  http://www.boost.org/LICENSE_1_0.txt)
   15                        	;
   16                        	; ***************************************************************************
   17                        	; ***************************************************************************
   18                        	
   19                        	;
   20                        	; Include dependancies ...
   21                        	;
   22                        	
   23                        			include "common.asm"		; Common helpers.
   24                        			include "vce.asm"		; Useful VCE routines.
   25                        	
   26                        	;
   27                        	; Choose how much to transfer to VRAM in a single chunk, normally 16-bytes.
   28                        	;
   29                        	; The cycle timings for a TIA-to-VRAM depend upon how the VDC's MWR CPU slots
   30                        	; line up to the CPU's writes, and how long the VDC has to halt the CPU while
   31                        	; it fetches the next scanline's sprite data.
   32                        	;
   33                        	; These cycle timings are for 0 sprites (best) and 16 sprites (worst) ...
   34                        	;
   35                        	; 32-byte TIA takes 270..364 cycles in 5MHz, 242..312 cycles in 7MHz. (8.44 cycles-per-byte best-case at 5MHz.)
   36                        	; 24-byte TIA takes 210..298 cycles in 5MHz, 186..256 cycles in 7MHz. (8.75 cycles-per-byte best-case at 5MHz.)
   37                        	; 16-byte TIA takes 142..234 cycles in 5MHz, 128..200 cycles in 7MHz. (8.88 cycles-per-byte best-case at 5MHz.)
   38                        	;
   39                        	; If a user wishes to be able to put RCR interrupts one-line-after-another,
   40                        	; then it is only safe to use 32-byte chunks if there are no TIMER or IRQ2
   41                        	; interrupts ... which is almost-impossible to rely on in library code!
   42                        	;
   43                        	
   44               0000     		.ifndef	VRAM_XFER_SIZE
   46                        		.endif
   47                        	
   48                        	;
   49                        	; Enable BG & SPR layers, and RCR interrupt.
   50                        	;
   51                        	
   52    00:E40A  A9 04      	set_rcron:	lda	#$04			; Enable RCR interrupt.
   53    00:E40C  80 0A      			bra	!+
   54                        	
   55    00:E40E  A9 80      	set_bgon:	lda	#$80			; Enable BG layer.
   56    00:E410  80 06      			bra	!+
   57                        	
   58    00:E412  A9 40      	set_spron:	lda	#$40			; Enable SPR layer.
   59    00:E414  80 02      			bra	!+
   60                        	
   61    00:E416  A9 C0      	set_dspon:	lda	#$C0			; Enable BG & SPR layers.
   62                        	
   63    00:E418  04 F3      	!:		tsb	<vdc_crl		; These take effect when
   64               0001     		.if	SUPPORT_SGX			; the next VBLANK occurs.
   65    00:E41A  04 03      			tsb	<sgx_crl
   66                        		.endif
   67    00:E41C  60         			rts
   68                        	
   69                        	;
   70                        	; Disable BG & SPR layers, and RCR interrupt.
   71                        	;
   72                        	
   73    00:E41D  A9 04      	set_rcroff:	lda	#$04			; Disable RCR interrupt.
   74    00:E41F  80 0A      			bra	!+
   75                        	
   76    00:E421  A9 80      	set_bgoff:	lda	#$80			; Disable BG layer.
   77    00:E423  80 06      			bra	!+
   78                        	
   79    00:E425  A9 40      	set_sproff:	lda	#$40			; Disable SPR layer.
   80    00:E427  80 02      			bra	!+
   81                        	
   82    00:E429  A9 C0      	set_dspoff:	lda	#$C0			; Disable BG & SPR layers.
   83                        	
   84    00:E42B  14 F3      	!:		trb	<vdc_crl		; These take effect when
   85               0001     		.if	SUPPORT_SGX			; the next VBLANK occurs.
   86    00:E42D  14 03      			trb	<sgx_crl
   87                        		.endif
   88    00:E42F  60         			rts
   89                        	
   90                        	
   91                        	
   92                        	; ***************************************************************************
   93                        	; ***************************************************************************
   94                        	;
   95                        	; Put the _di data pointer into the VDC's MARR or MAWR register.
   96                        	;
   97                        	; N.B. Library code relies on this preserving Y!
   98                        	;
   99                        	; Args: _di + 0 = BAT X coordinate.
  100                        	; Args: _di + 1 = BAT Y coordinate.
  101                        	;
  102                        	; Here because it relies on the "vdc_bat_width" that is defined in this file.
  103                        	;
  104                        	
  105               0001     		.if	SUPPORT_SGX
  106    00:E430  A2 10      	sgx_di_xy_marr:	ldx	#SGX_VDC_OFFSET		; Offset to SGX VDC.
  107    00:E432  F0         			db	$F0			; Turn "clx" into a "beq".
  108                        		.endif
  109                        	
  110    00:E433  82         	vdc_di_xy_marr:	clx				; Offset to PCE VDC.
  111                        	
  112    00:E434  62         	set_di_xy_mawr:	cla
  113    00:E435  3C 6B 26   			bit	vdc_bat_width, x	; Set by set_bat_size().
  114    00:E438  30 08      			bmi	.w128
  115    00:E43A  70 03      			bvs	.w64
  116    00:E43C  46 F1      	.w32:		lsr.h	<_di
  117    00:E43E  6A         			ror	a
  118    00:E43F  46 F1      	.w64:		lsr.h	<_di
  119    00:E441  6A         			ror	a
  120    00:E442  46 F1      	.w128:		lsr.h	<_di
  121    00:E444  6A         			ror	a
  122    00:E445  05 F0      			ora.l	<_di
  123    00:E447  85 F0      			sta.l	<_di
  124    00:E449  4C 7F E3   			jmp	set_di_to_mawr		; In "common.asm".
  125                        	
  126                        	
  127                        	
  128    11:C73E             	vdc_clear_vram	.procgroup			; These routines share code!
  129                        	
  130                        	; ***************************************************************************
  131                        	; ***************************************************************************
  132                        	;
  133                        	; clear_vram_sgx - Clear all of VRAM in the SGX VDC.
  134                        	; clear_vram_vdc - Clear all of VRAM in the PCE VDC.
  135                        	;
  136                        	; Args: _ax = word value to write to the BAT.
  137                        	; Args: _bl = hi-byte of size of BAT (# of words).
  138                        	;
  139                        	
  140               0001     		.if	SUPPORT_SGX
  141    11:C73E             	clear_vram_sgx	.proc
  142                        	
  143    11:C73E  A2 10      			ldx	#SGX_VDC_OFFSET		; Offset to SGX VDC.
  144    11:C740  F0         			db	$F0			; Turn "clx" into a "beq".
  145                        	
  146    11:C741             			.ref	clear_vram_vdc		; Need clear_vram_vdc
  147                        			.endp
  148                        		.endif
  149                        	
  150    11:C741             	clear_vram_vdc	.proc
  151                        	
  152    11:C741  82         			clx				; Offset to PCE VDC.
  153                        	
  154    11:C742  20 E7 FD   	clear_vram_x:	call	clear_bat_x		; Clear the BAT.
  155                        	
  156    11:C745  A9 80      			lda	#$80			; Xvert hi-byte of # words
  157    11:C747  38         			sec				; in screen to loop count.
  158    11:C748  E5 FA      			sbc	<_bl
  159    11:C74A  4A         			lsr	a
  160                        	
  161                        	;		cly				; Clear the rest of VRAM.
  162    11:C74B  9E 02 02   			stz	VDC_DL, x
  163    11:C74E  9E 03 02   	.clr_loop:	stz	VDC_DH, x		; Seperate writes to minimize
  164    11:C751  88         			dey				; VDC MWR penalty.
  165    11:C752  9E 03 02   			stz	VDC_DH, x
  166    11:C755  D0 F7      			bne	.clr_loop
  167    11:C757  3A         			dec	a
  168    11:C758  D0 F4      			bne	.clr_loop
  169                        	
  170                        			leave				; All done, phew!
         11:C75A  4C EF FF   			jmp	leave_proc
  171                        	
  172                        			.endp
  173                        	
  174                        	
  175                        	
  176                        	; ***************************************************************************
  177                        	; ***************************************************************************
  178                        	;
  179                        	; clear_bat_sgx - Clear the BAT in the SGX VDC.
  180                        	; clear_bat_vdc - Clear the BAT in the PCE VDC.
  181                        	;
  182                        	; Args: _ax = word value to write to the BAT.
  183                        	; Args: _bl = hi-byte of size of BAT (# of words).
  184                        	;
  185                        	
  186               0001     		.if	SUPPORT_SGX
  187                        	clear_bat_sgx	.proc
  193                        			.endp
  194                        		.endif
  195                        	
  196    11:C75D             	clear_bat_vdc	.proc
  197                        	
  198    11:C75D  82         			clx				; Offset to PCE VDC.
  199                        	
  200    11:C75E             			.ref	clear_bat_x		; Need clear_bat_x
  201                        			.endp
  202                        	
  203    11:C75E             	clear_bat_x	.proc				; HuCC uses this entry point.
  204                        	
  205    11:C75E  64 F0      			stz	<_di + 0		; Set VDC or SGX destination
  206    11:C760  64 F1      			stz	<_di + 1		; address.
  207    11:C762  20 7F E3   			jsr	set_di_to_mawr
  208                        	
  209    11:C765  A5 FA      			lda	<_bl			; Xvert hi-byte of # words
  210    11:C767  4A         			lsr	a			; in screen to loop count.
  211                        	
  212    11:C768  C2         			cly
  213    11:C769  48         	.bat_loop:	pha
  214    11:C76A  A5 F8      			lda	<_ax + 0
  215    11:C76C  9D 02 02   			sta	VDC_DL, x
  216    11:C76F  A5 F9      			lda	<_ax + 1
  217    11:C771  9D 03 02   	.bat_pair:	sta	VDC_DH, x		; Seperate writes to minimize
  218    11:C774  88         			dey				; VDC MWR penalty.
  219    11:C775  9D 03 02   			sta	VDC_DH, x
  220    11:C778  D0 F7      			bne	.bat_pair
  221                        	
  222    11:C77A  68         			pla
  223    11:C77B  3A         			dec	a
  224    11:C77C  D0 EB      			bne	.bat_loop
  225                        	
  226                        			leave
         11:C77E  4C EF FF   			jmp	leave_proc
  227                        	
  228                        			.endp
  229                        	
  230                        			.endprocgroup
  231                        	
  232                        	;
  233                        	;
  234                        	;
  235                        	
  236    02:DECB             	vdc_set_mode	.procgroup			; These routines share code!
  237                        	
  238                        	; ***************************************************************************
  239                        	; ***************************************************************************
  240                        	;
  241                        	; set_mode_sgx - Set video hardware registers from a data table.
  242                        	; set_mode_vdc - Set video hardware registers from a data table.
  243                        	;
  244                        	; Args: _bp, Y = _farptr to data table mapped into MPR3 & MPR4.
  245                        	;
  246                        	
  247               0001     		.if	SUPPORT_SGX
  248    02:DECB             	set_mode_sgx	.proc
  249                        	
  250    02:DECB  A2 10      			ldx	#SGX_VDC_OFFSET		; Offset to SGX VDC.
  251    02:DECD  F0         			db	$F0			; Turn "clx" into a "beq".
  252                        	
  253                        			.endp
  254                        		.endif
  255                        	
  256    02:DECE             	set_mode_vdc	.proc
  257                        	
  258    02:DECE  82         			clx				; Offset to PCE VDC.
  259                        	
  260    02:DECF  F7 F8      			smb7	<_al			; Signal no set_bat_size() yet.
  261                        	
  262    02:DED1  43 08      			tma3				; Preserve MPR3.
  263    02:DED3  48         			pha
  264    02:DED4  43 10      			tma4				; Preserve MPR4.
  265    02:DED6  48         			pha
  266                        	
  267    02:DED7  20 3B E3   			jsr	map_bp_to_mpr34		; Map data to MPR3 & MPR4.
  268                        	
  269    02:DEDA  08         			php				; Disable interrupts.
  270    02:DEDB  78         			sei
  271                        	
  272    02:DEDC  C2         			cly				; Table size is < 256 bytes.
  273                        	
  274    02:DEDD  B1 EC      	.loop:		lda	[_bp], y		; Get the register #, +ve for
  275    02:DEDF  F0 46      			beq	.done			; VDC, -128 for VCE_CR.
  276    02:DEE1  10 0C      			bpl	.set_vdc_reg
  277                        	
  278                        			; Set the VCE_CR register.
  279                        	
  280    02:DEE3  C8         	.set_vce_cr:	iny
  281                        	
  282    02:DEE4  B1 EC      			lda	[_bp], y		; Get lo-byte of register.
  283    02:DEE6  C8         			iny
  284    02:DEE7  8D 44 22   			sta	vce_cr			; No SGX shadow for this!
  285    02:DEEA  8D 00 04   			sta	VCE_CR			; Set the VCE clock speed.
  286    02:DEED  80 EE      			bra	.loop			; Do not set VDC_MWR reg bits!
  287                        	
  288                        			; Set a VDC register.
  289                        	
  290    02:DEEF  C8         	.set_vdc_reg:	iny
  291    02:DEF0  9D 00 02   			sta	VDC_AR, x		; Set which VDC register.
  292                        	
  293    02:DEF3  C9 05      			cmp	#VDC_CR			; CS if VDC_CR or higher.
  294    02:DEF5  F0 14      			beq	.skip_cc
  295    02:DEF7  18         			clc				; CC if not VDC_CR.
  296                        	
  297    02:DEF8  49 09      			eor	#VDC_MWR		; Check if this the VDC_MWR
  298    02:DEFA  D0 0F      			bne	.skip_cc		; without changing CC.
  299                        	
  300    02:DEFC  B1 EC      			lda	[_bp], y		; Remember the BAT size so that
  301    02:DEFE  8D 42 22   			sta	vdc_mwr			; set_bat_size() can be called.
  302    02:DF01  4A         			lsr	a
  303    02:DF02  4A         			lsr	a
  304    02:DF03  4A         			lsr	a
  305    02:DF04  4A         			lsr	a
  306    02:DF05  85 F8      			sta	<_al
  307    02:DF07  C8         			iny
  308    02:DF08  C8         			iny
  309    02:DF09  80 D2      			bra	.loop
  310                        	
  311    02:DF0B  B1 EC      	.skip_cc:	lda	[_bp], y		; Get lo-byte of register.
  312    02:DF0D  C8         			iny
  313    02:DF0E  90 08      			bcc	.not_vdc_cr
  314                        	
  315               0001     		.if	SUPPORT_SGX
  316    02:DF10  E0 00      			cpx	#0			; Writing to the VDC or SGX?
  317    02:DF12  F0 02      			beq	.save_crl
  318    02:DF14  29 F7      			and	#$F7			; We only need 1 vblank IRQ!
  319                        		.endif
  320                        	
  321    02:DF16  95 F3      	.save_crl:	sta	<vdc_crl, x		; Save VDC_CR shadow register.
  322                        	
  323    02:DF18  9D 02 02   	.not_vdc_cr:	sta	VDC_DL, x		; Write to VDC.
  324                        	
  325    02:DF1B  B1 EC      			lda	[_bp], y		; Get hi-byte of register.
  326    02:DF1D  C8         			iny
  327    02:DF1E  9D 03 02   			sta	VDC_DH, x
  328    02:DF21  90 BA      			bcc	.loop			; Next register, please!
  329                        	
  330    02:DF23  95 F4      			sta	<vdc_crh, x		; Save VDC_CR shadow register.
  331                        	
  332    02:DF25  80 B6      			bra	.loop			; Next register, please!
  333                        	
  334                        			; All registers set!
  335                        	
  336    02:DF27  A9 02      	.done:		lda	#VDC_VWR		; Leave with VDC_VWR set.
  337    02:DF29  95 F7      			sta	<vdc_reg, x
  338                        	;		lda	<vdc_reg, x		; Restore previous VDC_AR from
  339    02:DF2B  9D 00 02   			sta	VDC_AR, x		; the shadow variable.
  340                        	
  341    02:DF2E  28         			plp				; Restore interrupts.
  342                        	
  343    02:DF2F  68         			pla				; Restore MPR4.
  344    02:DF30  53 10      			tam4
  345    02:DF32  68         			pla				; Restore MPR3.
  346    02:DF33  53 08      			tam3
  347                        	
  348    02:DF35  7F F8 07   			bbr7	<_al, set_bat_size	; Update if BAT size changed.
  349                        	
  350                        			leave				; All done, phew!
         02:DF38  4C EF FF   			jmp	leave_proc
  351                        	
  352    02:DF3B             			.ref	set_bat_vdc
  353                        			.endp
  354                        	
  355                        	
  356                        	
  357                        	; ***************************************************************************
  358                        	; ***************************************************************************
  359                        	;
  360                        	; set_bat_sgx - Change the SGX BAT size and initialize variables based on it.
  361                        	; set_bat_vdc - Change the PCE BAT size and initialize variables based on it.
  362                        	;
  363                        	; Args: _al = new size (0-7).
  364                        	;
  365                        	; (VDC_MWR_32x32  >> 4) or in HuCC, SCR_SIZE_32x32.
  366                        	; (VDC_MWR_32x64  >> 4) or in HuCC, SCR_SIZE_32x64.
  367                        	; (VDC_MWR_64x32  >> 4) or in HuCC, SCR_SIZE_64x32.
  368                        	; (VDC_MWR_64x64  >> 4) or in HuCC, SCR_SIZE_64x64.
  369                        	; (VDC_MWR_128x32 >> 4) or in HuCC, SCR_SIZE_128x32.
  370                        	; (VDC_MWR_128x64 >> 4) or in HuCC, SCR_SIZE_128x64.
  371                        	;
  372                        	
  373               0001     		.if	SUPPORT_SGX
  374    02:DF3B             	set_bat_sgx	.proc
  375                        	
  376    02:DF3B  A2 10      			ldx	#SGX_VDC_OFFSET		; Offset to SGX VDC.
  377    02:DF3D  F0         			db	$F0			; Turn "clx" into a "beq".
  378                        	
  379    02:DF3E             			.ref	set_bat_vdc
  380                        			.endp
  381                        		.endif
  382                        	
  383    02:DF3E             	set_bat_vdc	.proc
  384                        	
  385    02:DF3E  82         			clx				; Offset to PCE VDC.
  386                        	
  387    02:DF3F  A5 F8      	set_bat_size:	lda	<_al			; Get BAT size value.
  388    02:DF41  29 07      			and	#7			; Sanitize screen size value.
  389    02:DF43  A8         			tay
  390    02:DF44  0A         			asl	a			; Put it in bits 4..6.
  391    02:DF45  0A         			asl	a
  392    02:DF46  0A         			asl	a
  393    02:DF47  0A         			asl	a
  394    02:DF48  85 00      			sta	<__temp
  395                        	
  396    02:DF4A  B9 8A DF   			lda	.width, y
  397    02:DF4D  9D 6B 26   			sta	vdc_bat_width, x
  398    02:DF50  3A         			dec	a
  399    02:DF51  9D 6D 26   			sta	vdc_bat_x_mask, x
  400                        	
  401    02:DF54  B9 92 DF   			lda	.height, y
  402    02:DF57  9D 6C 26   			sta	vdc_bat_height, x
  403    02:DF5A  3A         			dec	a
  404    02:DF5B  9D 6E 26   			sta	vdc_bat_y_mask, x
  405                        	
  406    02:DF5E  B9 9A DF   			lda	.limit, y
  407    02:DF61  9D 6F 26   			sta	vdc_bat_limit, x
  408                        	
  409    02:DF64  B9 A2 DF   			lda	.increment, y		; Put the VRAM increment for a
  410    02:DF67  95 F4      			sta	<vdc_crh, x		; line into vdc_crh for later.
  411                        	
  412    02:DF69  08         			php
  413    02:DF6A  78         			sei
  414                        	
  415    02:DF6B  A9 09      			lda	#VDC_MWR
  416    02:DF6D  9D 00 02   			sta	VDC_AR, x
  417                        	
  418    02:DF70  AD 42 22   			lda	vdc_mwr			; Get the MWR access width bits.
  419    02:DF73  29 8F      			and	#%10001111
  420    02:DF75  05 00      			ora	<__temp
  421               0001     		.if	SUPPORT_SGX
  422    02:DF77  E0 00      			cpx	#PCE_VDC_OFFSET		; This has no SGX shadow!
  423    02:DF79  D0 03      			bne	!+
  424                        		.endif
  425    02:DF7B  8D 42 22   			sta	vdc_mwr
  426    02:DF7E  9D 02 02   	!:		sta	VDC_DL, x
  427                        	
  428    02:DF81  B5 F7      			lda	<vdc_reg, x		; Restore previous VDC_AR from
  429    02:DF83  9D 00 02   			sta	VDC_AR, x		; the shadow variable.
  430                        	
  431    02:DF86  28         			plp
  432                        	
  433                        			leave
         02:DF87  4C EF FF   			jmp	leave_proc
  434                        	
  435    02:DF8A  20 40 80 80	.width:		db	$20,$40,$80,$80,$20,$40,$80,$80
         02:DF8E  20 40 80 80 
  436    02:DF92  20 20 20 20	.height:	db	$20,$20,$20,$20,$40,$40,$40,$40
         02:DF96  40 40 40 40 
  437    02:DF9A  03 07 0F 0F	.limit:		db	$03,$07,$0F,$0F,$07,$0F,$1F,$1F
         02:DF9E  07 0F 1F 1F 
  438    02:DFA2  08 10 18 18	.increment	db	$08,$10,$18,$18,$08,$10,$18,$18
         02:DFA6  08 10 18 18 
  439                        	
  440               266B     			.bss
  441                        	
  442                        	; **************
  443                        	; 16-bytes of VDC BAT information.
  444                        	;
  445                        	; N.B. MUST be 16-bytes before the SGX versions to use PCE_VDC_OFFSET.
  446                        	;
  447                        	; N.B. Declared inside this .proc so that they can be stripped if unused.
  448                        	
  449                        	; Initialized by set_bat_vdc.
  450    F8:266B             	vdc_bat_width:	ds	1	; $20, $40, $80
  451    F8:266C             	vdc_bat_height:	ds	1	; $20, $40
  452    F8:266D             	vdc_bat_x_mask:	ds	1	; $1F, $3F, $7F
  453    F8:266E             	vdc_bat_y_mask:	ds	1	; $1F, $3F
  454    F8:266F             	vdc_bat_limit:	ds	1	; (>$03FF), (>$07FF), (>$0FFF), (>$1FFF)
  455                        	
  456                        	; From blkmap.asm just to avoid wasting .bss space with padding.
  457    F8:2670             	vdc_map_draw_w:	ds	1	; (SCR_WIDTH / 8) + 1
  458    F8:2671             	vdc_map_draw_h:	ds	1	; (SCR_HEIGHT / 8) + 1
  459    F8:2672             	vdc_map_line_w:	ds	1	; Line width of map data in tiles.
  460    F8:2673             	vdc_map_scrn_w:	ds	1	; Line width of map data in screens.
  461    F8:2674             	vdc_map_pxl_x:	ds	2	; Current top-left X in pixels.
  462    F8:2676             	vdc_map_pxl_y:	ds	2	; Current top-left Y in pixels.
  463    F8:2678             	vdc_map_option:	ds	1	; Flags to disable BAT alignment.
  464                        	
  465                        	; From hucc-old-spr.asm just to avoid wasting .bss space with padding.
  466    F8:2679             	spr_max:	ds	1
  467    F8:267A             	spr_clr:	ds	1
  468                        	
  469               0001     		.if	SUPPORT_SGX
  470                        	
  471                        	; **************
  472                        	; 16-bytes of SGX BAT information.
  473                        	;
  474                        	; N.B. MUST be 16-bytes after the VDC versions to use SGX_VDC_OFFSET.
  475                        	;
  476                        	; N.B. Declared inside this .proc so that they can be stripped if unused.
  477                        	
  478                        	; Initialized by set_bat_sgx.
  479    F8:267B             	sgx_bat_width:	ds	1	; $20, $40, $80
  480    F8:267C             	sgx_bat_height:	ds	1	; $20, $40
  481    F8:267D             	sgx_bat_x_mask:	ds	1	; $1F, $3F, $7F
  482    F8:267E             	sgx_bat_y_mask:	ds	1	; $1F, $3F
  483    F8:267F             	sgx_bat_limit:	ds	1	; (>$03FF), (>$07FF), (>$0FFF), (>$1FFF)
  484                        	
  485                        	; From blkmap.asm just to avoid wasting .bss space with padding.
  486    F8:2680             	sgx_map_draw_w:	ds	1	; (SCR_WIDTH / 8) + 1
  487    F8:2681             	sgx_map_draw_h:	ds	1	; (SCR_HEIGHT / 8) + 1
  488    F8:2682             	sgx_map_line_w:	ds	1	; Line width of map data in tiles.
  489    F8:2683             	sgx_map_scrn_w:	ds	1	; Line width of map data in screens.
  490    F8:2684             	sgx_map_pxl_x:	ds	2	; Current top-left X in pixels.
  491    F8:2686             	sgx_map_pxl_y:	ds	2	; Current top-left Y in pixels.
  492    F8:2688             	sgx_map_option:	ds	1	; Flags to disable BAT alignment.
  493                        	
  494                        	; From hucc-old-spr.asm just to avoid wasting .bss space with padding.
  495    F8:2689             	sgx_spr_max:	ds	1
  496    F8:268A             	sgx_spr_clr:	ds	1
  497                        	
  498                        		.endif
  499                        	
  500               DFAA     			.code
  501                        	
  502                        			.endp
  503                        	
  504                        			.endprocgroup
  505                        	
  506                        	
  507                        	
  508                        	; ***************************************************************************
  509                        	; ***************************************************************************
  510                        	;
  511                        	; sgx_detect - Detect whether we're running on a SuperGrafx (and init VPC).
  512                        	;
  513                        	; Returns: X,C-flag, and "sgx_detected" = NZ, CS if detected.
  514                        	;
  515                        	; ***************************************************************************
  516                        	;
  517                        	; https://web.archive.org/web/20161129055659/http://cgfm2.emuviews.com/txt/sgxtech.txt
  518                        	;
  519                        	; ***************************************************************************
  520                        	;
  521                        	; HuC6202 VIDEO PRIORITY CONTROLLER (huge thanks to Charles MacDonald!)
  522                        	;
  523                        	; The VPC has no access to sprite priority data, it can only sort pixels
  524                        	; based upon which VDC and whether they are "sprite" or "background".
  525                        	;
  526                        	; This can sometimes lead to unexpected results with low-priority sprites.
  527                        	;
  528                        	; VPC registers $0008 and $0009 make up four 4-bit values that define the
  529                        	; enabled layers and priority setting for the four possible window areas.
  530                        	;
  531                        	; Bits 3-0 of $0008 are for the region where Window 1 and 2 overlap
  532                        	; Bits 7-4 of $0008 are for the region occupied by only Window 2
  533                        	; Bits 3-0 of $0009 are for the region occupied by only Window 1
  534                        	; Bits 7-4 of $0009 are for the region where no Window is present
  535                        	;
  536                        	;  Each 4-bit value has the same format:
  537                        	;
  538                        	;  Bit 0: VDC #1 graphics are 0=disabled, 1=enabled
  539                        	;  Bit 1: VDC #2 graphics are 0=disabled, 1=enabled
  540                        	;  Bit 2: Bit 0 of priority setting
  541                        	;  Bit 3: Bit 1 of priority setting
  542                        	;
  543                        	;   Priority Setting 0b00xx: (useful when VDC #1 is a fullscreen HUD)
  544                        	;
  545                        	;    FRONT
  546                        	;     SP1 = VDC #1 (pce) sprite pixels
  547                        	;     BG1 = VDC #1 (pce) background pixels
  548                        	;     SP2 = VDC #2 (sgx) sprite pixels
  549                        	;     BG2 = VDC #2 (sgx) background pixels
  550                        	;    BACK
  551                        	;
  552                        	;   Priority Setting 0b01xx: (useful for parallax backgrounds)
  553                        	;
  554                        	;    FRONT
  555                        	;     SP1 = VDC #1 (pce) sprite pixels
  556                        	;     SP2 = VDC #2 (sgx) sprite pixels
  557                        	;     BG1 = VDC #1 (pce) background pixels
  558                        	;     BG2 = VDC #2 (sgx) background pixels
  559                        	;    BACK
  560                        	;
  561                        	;   Priority Setting 0b10xx: (only useful for special effects)
  562                        	;
  563                        	;    FRONT
  564                        	;     BG1 = VDC #1 (pce) background pixels (transparent where sprites)
  565                        	;     BG2 = VDC #2 (sgx) background pixels
  566                        	;     SP1 = VDC #1 (pce) sprite pixels
  567                        	;     SP2 = VDC #2 (sgx) sprite pixels
  568                        	;    BACK
  569                        	
  570               0001     		.if	SUPPORT_SGX
  571               0001     		.if	1
  572    11:C781             	sgx_detect	.proc
  573                        	
  574    11:C781  A0 7F      			ldy	#$7F			; Use VRAM address $7F7F
  575    11:C783  84 F0      			sty.l	<_di			; because it won't cause
  576    11:C785  84 F1      			sty.h	<_di			; a screen glitch.
  577                        	
  578    11:C787  20 7B E3   			jsr	sgx_di_to_mawr		; Write $0001 to SGX VRAM.
  579    11:C78A  A0 01      			ldy	#$01
  580    11:C78C  8C 12 02   			sty	SGX_DL
  581    11:C78F  9C 13 02   			stz	SGX_DH
  582                        	
  583    11:C792  20 7E E3   			jsr	vdc_di_to_mawr		; Write $0000 to VDC VRAM.
  584    11:C795  9C 02 02   			stz	VDC_DL
  585    11:C798  9C 03 02   			stz	VDC_DH
  586                        	
  587    11:C79B  20 6E E3   			jsr	sgx_di_to_marr		; Check value in SGX VRAM.
  588    11:C79E  AC 12 02   			ldy	SGX_DL			; $01 if found, $00 if not.
  589    11:C7A1  8C E8 22   			sty	sgx_detected
  590    11:C7A4  F0 10      			beq	!+			; Skip the rest if not SGX.
  591                        	
  592    11:C7A6  20 7B E3   			jsr	sgx_di_to_mawr		; Write $0000 to SGX VRAM
  593    11:C7A9  9C 12 02   			stz	SGX_DL			; to clean VRAM contents.
  594    11:C7AC  9C 13 02   			stz	SGX_DH
  595                        	
  596    11:C7AF  73 BC C7 08			tii	.vpc_mode, VPC_CR, 8	; Initialize the HuC6202 VPC.
         11:C7B3  02 08 00    
  597                        	
  598    11:C7B6  98         	!:		tya
  599    11:C7B7  AA         			tax				; "leave" copies X back to A.
  600    11:C7B8  4A         			lsr	a			; Also CC if PCE, CS if SGX.
  601                        	
  602                        			leave				; All done, phew!
         11:C7B9  4C EF FF   			jmp	leave_proc
  603                        		.else
  618                        		.endif
  619                        	
  620               0000     		.ifndef	SGX_PARALLAX
  622                        		.endif
  623                        	
  624               0001     		.if	SGX_PARALLAX
  625    11:C7BC  00 70      	.vpc_mode:	dw	$7000			; Use SGX as a parallax layer
  626    11:C7BE  00 00      			dw	$0000			; behind a VDC background.
  627    11:C7C0  00 00      			dw	$0000
  628    11:C7C2  00 00      			dw	$0000
  629                        		.else
  634                        		.endif	SGX_PARALLAX
  635                        	
  636                        			.endp
  637                        	
  638               0000     		.ifndef	CORE_VERSION			; CORE has this in the kernel.
  642                        		.endif	CORE_VERSION
  643                        	
  644                        		.endif	SUPPORT_SGX
  645                        	
  646                        	
  647                        	
  648                        	
  649                        	vdc_copy_to	.procgroup			; These routines share code!
  799                        			.endprocgroup
  800                        	
  801                        	
  802                        	
  803                        	; ***************************************************************************
  804                        	; ***************************************************************************
  805                        	;
  806                        	; init_240x208 - An example of initializing screen and VRAM.
  807                        	;
  808                        	; This can be used as-is, or copied to your own program and modified.
  809                        	;
  810                        	
  811                        	init_240x208	.proc
  892                        			.endp
  893                        	
  894                        	
  895                        	
  896                        	; ***************************************************************************
  897                        	; ***************************************************************************
  898                        	;
  899                        	; init_256x224 - An example of initializing screen and VRAM.
  900                        	;
  901                        	; This can be used as-is, or copied to your own program and modified.
  902                        	;
  903                        	
  904                        	init_256x224	.proc
  985                        			.endp
  986                        	
  987                        	
  988                        	
  989                        	; ***************************************************************************
  990                        	; ***************************************************************************
  991                        	;
  992                        	; init_352x224 - An example of initializing screen and VRAM.
  993                        	;
  994                        	; This can be used as-is, or copied to your own program and modified.
  995                        	;
  996                        	
  997                        	init_352x224	.proc
 1078                        			.endp
 1079                        	
 1080                        	
 1081                        	
 1082                        	; ***************************************************************************
 1083                        	; ***************************************************************************
 1084                        	;
 1085                        	; init_512x224 - An example of initializing screen and VRAM.
 1086                        	;
 1087                        	; This can be used as-is, or copied to your own program and modified.
 1088                        	;
 1089                        	
 1090                        	init_512x224	.proc
 1171                        			.endp
 1172                        	
 1173                        	
 1174                        	
 1175                        	; ***************************************************************************
 1176                        	; ***************************************************************************
 1177                        	;
 1178                        	; init_320x208 - An example of initializing screen and VRAM.
 1179                        	;
 1180                        	; This can be used as-is, or copied to your own program and modified.
 1181                        	;
 1182                        	; This resolution is rarely-seen, but it has no overscan, so it has a use.
 1183                        	;
 1184                        	
 1185                        	init_320x208	.proc
 1266                        			.endp
                             #[2]   "..\..\..\include\hucc\hucc-final.asm"
   41                        	
                             #[3]   "..\..\..\include\hucc\hucc-math.asm"
   42                        			include	"hucc-math.asm"		; HuCC multiply and divide.
    1                        	; ***************************************************************************
    2                        	; ***************************************************************************
    3                        	;
    4                        	; hucc-math.asm
    5                        	;
    6                        	; Basic (i.e. very slow) 8-bit and 16-bit multiply and divide routines.
    7                        	;
    8                        	; Copyright John Brandwood 2021-2024.
    9                        	;
   10                        	; Distributed under the Boost Software License, Version 1.0.
   11                        	; (See accompanying file LICENSE_1_0.txt or copy at
   12                        	;  http://www.boost.org/LICENSE_1_0.txt)
   13                        	;
   14                        	; ***************************************************************************
   15                        	; ***************************************************************************
   16                        	;
   17                        	; This is basically a set of SDCC-compatible routines, but using Y:A for the
   18                        	; primary register instead of X:A.
   19                        	;
   20                        	; Using Y:A makes the routines instantly usable with HuCC, and it also makes
   21                        	; them usable with SDCC with just an "sxy" before and after the call.
   22                        	;
   23                        	; ***************************************************************************
   24                        	; ***************************************************************************
   25                        	
   26               E44C     			.code
   27                        	
   28               2000     	multiplier	=	__temp
   29               2094     	multiplicand	=	___SDCC_m6502_ret0
   30               2094     	product		=	multiplicand
   31                        	
   32               2000     	__mulint_PARM_2	=	multiplier
   33                        	
   34               2000     	divisor		=	__temp
   35               2094     	dividend	=	___SDCC_m6502_ret0
   36               2094     	quotient	=	dividend
   37               2096     	remainder	=	___SDCC_m6502_ret2
   38                        	
   39               2000     	__moduint_PARM_2 =	divisor
   40               2000     	__modsint_PARM_2 =	divisor
   41               2000     	__divuint_PARM_2 =	divisor
   42               2000     	__divsint_PARM_2 =	divisor
   43                        	
   44                        	
   45                        	
   46                        	; ***************************************************************************
   47                        	; int
   48                        	; _mulint (int a, int b)
   49                        	;
   50                        	; 1st parameter in Y:A (multiplicand)
   51                        	; 2nd parameter in __mulint_PARM_2 (multiplier)
   52                        	; result in Y:A
   53                        	;
   54                        	; N.B. signed and unsigned multiply only differ in the top 16 of the 32bits!
   55                        	
   56    00:E44C  85 94      	__mulint:	sta	<multiplicand + 0
   57    00:E44E  84 95      			sty	<multiplicand + 1
   58                        	
   59    00:E450  A2 10      			ldx	#16			; Loop 16 times.
   60                        	
   61    00:E452  46 95      			lsr	<multiplicand + 1	; Divide multiplicand by 2
   62    00:E454  66 94      			ror	<multiplicand + 0	; and clear the 16th bit.
   63                        	
   64    00:E456  62         			cla				; Clear top word of product.
   65    00:E457  85 96      			sta.l	<multiplicand + 2
   66    00:E459  90 0B      			bcc	.rotate
   67                        	
   68    00:E45B  A8         	.add:		tay				; Add the 16-bit multiplier to
   69    00:E45C  18         			clc				; top 16-bits of the product.
   70    00:E45D  A5 96      			lda	<multiplicand + 2
   71    00:E45F  65 00      			adc.l	<multiplier
   72    00:E461  85 96      			sta	<multiplicand + 2
   73    00:E463  98         			tya
   74    00:E464  65 01      			adc.h	<multiplier
   75                        	
   76    00:E466  6A         	.rotate:	ror	a			; Rotate product into the top
   77    00:E467  66 96      			ror	<multiplicand + 2	; bits of the multiplicand ...
   78    00:E469  66 95      			ror	<multiplicand + 1	; and divide multiplicand by 2.
   79    00:E46B  66 94      			ror	<multiplicand + 0
   80                        	
   81    00:E46D  CA         			dex
   82    00:E46E  B0 EB      			bcs	.add			; Add multiplier to top word?
   83    00:E470  D0 F4      			bne	.rotate			; Completed 16 bits?
   84                        	
   85    00:E472  85 97      			sta	<multiplicand + 3	; Save top byte of product.
   86                        	
   87    00:E474  A5 94      			lda.l	<multiplicand		; Return the bottom 16-bits of
   88    00:E476  A4 95      			ldy.h	<multiplicand		; the 32-bit product.
   89                        	
   90    00:E478  60         			rts
   91                        	
   92                        	
   93                        	
   94                        	; ***************************************************************************
   95                        	; unsigned int
   96                        	; _divuint (unsigned int x, unsigned int y)
   97                        	;
   98                        	; 1st parameter in Y:A (unsigned dividend)
   99                        	; 2nd parameter in __divuint_PARM_2 (unsigned divisor)
  100                        	; result in Y:A
  101                        	
  102    00:E479  20 81 E4   	__divuint:	jsr	__moduint		; Call the basic uint division.
  103                        	
  104    00:E47C  A5 94      			lda.l	<quotient		; Then get the result from where
  105    00:E47E  A4 95      			ldy.h	<quotient		; it was calculated.
  106    00:E480  60         			rts
  107                        	
  108                        	
  109                        	
  110                        	; ***************************************************************************
  111                        	; unsigned int
  112                        	; _moduint (unsigned int x, unsigned int y)
  113                        	;
  114                        	; 1st parameter in Y:A (unsigned dividend)
  115                        	; 2nd parameter in __moduint_PARM_2 (unsigned divisor)
  116                        	; result in Y:A
  117                        	;
  118                        	; If the dividend has more bits than the divisor, then we need to check the
  119                        	; 17th bit of the remainder!
  120                        	
  121               0000     		.if	0
  176                        		.else
  177                        	
  178    00:E481  85 94      	__moduint:	sta.l	<dividend		; 1st SDCC parameter in Y:A.
  179    00:E483  84 95      			sty.h	<dividend
  180                        	
  181    00:E485  A5 00      	divmoduint:	lda.l	<divisor		; Check for a divide-by-zero.
  182    00:E487  05 01      			ora.h	<divisor
  183    00:E489  F0 FE      	.zero:		beq	.zero
  184                        	
  185    00:E48B  A2 11      			ldx	#16 + 1
  186                        	
  187    00:E48D  C2         			cly				; Clear remainder.
  188    00:E48E  84 97      			sty.h	<remainder
  189                        	
  190    00:E490  98         	.skip:		tya				; Restore remainder lo-byte.
  191                        	
  192    00:E491  26 94      	.loop:		rol.l	<dividend		; Quotient bit -> dividend LSB.
  193    00:E493  26 95      			rol.h	<dividend		; Rotate dividend, MSB -> C.
  194                        	
  195    00:E495  CA         			dex
  196    00:E496  F0 14      			beq	.finished
  197                        	
  198    00:E498  2A         			rol	a			; Rotate C into remainder.
  199    00:E499  26 97      			rol.h	<remainder
  200                        	;		php				; Preserve remainder 17th bit.
  201                        	
  202    00:E49B  A8         			tay				; Preserve remainder lo-byte.
  203                        	
  204    00:E49C  C5 00      			cmp.l	<divisor		; Test divisor.
  205    00:E49E  A5 97      			lda.h	<remainder
  206    00:E4A0  E5 01      			sbc.h	<divisor
  207    00:E4A2  90 EC      			bcc	.skip			; CC if divisor > remainder.
  208                        	
  209                        	;		cmp.l	<divisor		; If the dividend has more bits
  210                        	;		lda.h	<remainder		; than the divisor then we need
  211                        	;		sbc.h	<divisor		; to check the remainder hi-bit.
  212                        	;		bcs	.subtract		; CS if divisor <= remainder.
  213                        	;		plp				; Restore remainder 17th bit.
  214                        	;		bcc	.skip			; CC if divisor > remainder.
  215                        	;		db	$90			; Turn "plp" into "bcc" to skip.
  216                        	;.subtract:	plp				; Discard remainder 17th bit.
  217                        	;		sec
  218                        	
  219    00:E4A4  85 97      			sta.h	<remainder		; Subtract divisor.
  220    00:E4A6  98         			tya
  221    00:E4A7  E5 00      			sbc.l	<divisor
  222    00:E4A9  38         			sec				
  223    00:E4AA  80 E5      			bra	.loop
  224                        	
  225    00:E4AC  A4 97      	.finished:	ldy.h	<remainder		; Get the remainder hi-byte.
  226                        	
  227    00:E4AE  60         			rts
  228                        	
  229                        		.endif
  230                        	
  231                        	
  232                        	
  233                        	; ***************************************************************************
  234                        	; int
  235                        	; _divsint (int x, int y)
  236                        	;
  237                        	; 1st parameter in Y:A (signed dividend)
  238                        	; 2nd parameter in __divsint_PARM_2 (signed divisor)
  239                        	; result in Y:A
  240                        	
  241    00:E4AF  20 B7 E4   	__divsint:	jsr	__modsint		; Call the basic sint division.
  242                        	
  243    00:E4B2  A5 94      			lda.l	<quotient		; Then get the result from where
  244    00:E4B4  A4 95      			ldy.h	<quotient		; it was calculated.
  245    00:E4B6  60         			rts
  246                        	
  247                        	
  248                        	
  249                        	; ***************************************************************************
  250                        	; int
  251                        	; _modsint (int x, int y)
  252                        	;
  253                        	; 1st parameter in Y:A (signed dividend)
  254                        	; 2nd parameter in __modsint_PARM_2 (signed divisor)
  255                        	; result in Y:A
  256                        	
  257    00:E4B7  84 95      	__modsint:	sty.h	<dividend
  258                        	
  259    00:E4B9  C0 80      			cpy	#$80			; Remainder -ve if dividend
  260    00:E4BB  08         			php				; was -ve.
  261    00:E4BC  90 03      			bcc	!+
  262    00:E4BE  20 0E E5   			jsr	neg_yacs		; Negate the dividend.
  263                        	
  264    00:E4C1  85 94      	!:		sta.l	<dividend		; Store the dividend.
  265    00:E4C3  A5 95      			lda.h	<dividend
  266    00:E4C5  84 95      			sty.h	<dividend
  267                        	
  268    00:E4C7  45 01      			eor.h	<divisor		; Quotient is -ve if divisor
  269    00:E4C9  08         			php				; and dividend signs differ.
  270                        	
  271    00:E4CA  A5 01      			lda.h	<divisor		; Is the divisor -ve?
  272    00:E4CC  10 0B      			bpl	!+
  273                        	
  274    00:E4CE  38         			sec				; Negate the divisor.
  275    00:E4CF  62         			cla
  276    00:E4D0  E5 00      			sbc.l	<divisor
  277    00:E4D2  85 00      			sta.l	<divisor
  278    00:E4D4  62         			cla
  279    00:E4D5  E5 01      			sbc.h	<divisor
  280    00:E4D7  85 01      			sta.h	<divisor
  281                        	
  282    00:E4D9  20 85 E4   	!:		jsr	divmoduint		; Do the unsigned division.
  283                        	
  284    00:E4DC  28         	.result:	plp				; Should the quotient be -ve?
  285    00:E4DD  10 0D      			bpl	.remainder
  286                        	
  287    00:E4DF  AA         			tax				; Preserve remainder lo-byte.
  288                        	
  289    00:E4E0  38         			sec				; Then negate the quotient.
  290    00:E4E1  62         			cla
  291    00:E4E2  E5 94      			sbc.l	<dividend
  292    00:E4E4  85 94      			sta.l	<dividend
  293    00:E4E6  62         			cla
  294    00:E4E7  E5 95      			sbc.h	<dividend
  295    00:E4E9  85 95      			sta.h	<dividend
  296                        	
  297    00:E4EB  8A         			txa				; Restore remainder lo-byte.
  298                        	
  299    00:E4EC  28         	.remainder:	plp				; Was the dividend -ve?
  300    00:E4ED  B0 1F      			bcs	neg_yacs		; Then negate the remainder.
  301    00:E4EF  60         			rts
  302                        	
  303                        	
  304                        	
  305                        	; ***************************************************************************
  306                        	; unsigned int
  307                        	; _muluchar (unsigned char x, unsigned char y)
  308                        	;
  309                        	; 1st parameter in A (unsigned multiplicand)
  310                        	; 2nd parameter in Y (unsigned multiplier)
  311                        	; result in Y:A
  312                        	
  313    00:E4F0  84 00      	__muluchar:	sty	<multiplier
  314                        	
  315    00:E4F2  A0 08      	muluchar_a:	ldy	#8			; Loop 8 times.
  316                        	
  317    00:E4F4  4A         			lsr	a			; Divide multiplicand by 2
  318    00:E4F5  85 94      			sta	<multiplicand		; and clear the 8th bit.
  319                        	
  320    00:E4F7  62         			cla				; Clear top byte of product.
  321    00:E4F8  90 03      			bcc	.rotate
  322                        	
  323    00:E4FA  18         	.add:		clc				; Add the 8-bit multiplier to
  324    00:E4FB  65 00      			adc	<multiplier		; top 8-bits of the product.
  325                        	
  326    00:E4FD  6A         	.rotate:	ror	a			; Rotate product into the top
  327    00:E4FE  66 94      			ror	<multiplicand		; bits of the multiplicand.
  328                        	
  329    00:E500  88         			dey
  330    00:E501  B0 F7      			bcs	.add			; Add multiplier to top byte?
  331    00:E503  D0 F8      			bne	.rotate			; Completed 8 bits?
  332                        	
  333    00:E505  A8         			tay				; Return the 16-bit product.
  334    00:E506  A5 94      			lda	<multiplicand
  335                        	
  336    00:E508  60         			rts
  337                        	
  338                        	
  339                        	
  340                        	; ***************************************************************************
  341                        	; signed int
  342                        	; abs (signed int x)
  343                        	;
  344                        	; 1st parameter in Y:A (signed)
  345                        	; result in Y:A
  346                        	
  347    00:E509  C0 80      	_abs:		cpy	#$80			; Is the hi-byte -ve?
  348    00:E50B  90 0B      			bcc	!+
  349                        	
  350    00:E50D  38         	neg_ya:		sec
  351    00:E50E  49 FF      	neg_yacs:	eor	#$FF
  352    00:E510  69 00      			adc	#0
  353    00:E512  42         			say
  354    00:E513  49 FF      			eor	#$FF
  355    00:E515  69 00      			adc	#0
  356    00:E517  42         			say
  357    00:E518  60         	!:		rts
  358                        	
  359    00:E519             	_abs.1		.alias	_abs
  360                        	
  361                        	
  362                        	
  363                        	; ***************************************************************************
  364                        	; signed int
  365                        	; _mulschar (signed char x, signed char y)
  366                        	;
  367                        	; 1st parameter in A (signed multiplicand)
  368                        	; 2nd parameter in Y (signed multiplier)
  369                        	; result in Y:A
  370                        	;
  371                        	; N.B. Y and A get swapped to make the code shorter.
  372                        	
  373    00:E519  85 94      	__mulschar:	sta	<multiplicand		; Remember multiplicand sign.
  374                        	
  375    00:E51B  C9 80      			cmp	#$80			; Is the multiplicand -ve?
  376    00:E51D  90 03      			bcc	!+
  377    00:E51F  49 FF      			eor	#$FF			; Negate the multiplicand.
  378    00:E521  1A         			inc	a
  379    00:E522  85 00      	!:		sta	<multiplier		; Then save it as multiplier.
  380                        	
  381    00:E524  98         			tya				; Product -ve if multiplicand
  382    00:E525  45 94      			eor	<multiplicand		; and multiplier signs differ.
  383    00:E527  08         			php				; Remember product sign.
  384                        	
  385    00:E528  98         			tya				; Is the multiplicand -ve?
  386    00:E529  10 03      			bpl	!+
  387    00:E52B  49 FF      			eor	#$FF			; Negate the multiplicand.
  388    00:E52D  1A         			inc	a
  389                        	
  390    00:E52E  20 F2 E4   	!:		jsr	muluchar_a		; Multiplier already saved.
  391                        	
  392    00:E531  28         			plp				; Is the product -ve?
  393    00:E532  30 D9      			bmi	neg_ya
  394    00:E534  60         			rts
  395                        	
  396                        	
  397                        	
  398                        	; ***************************************************************************
  399                        	; unsigned int
  400                        	; _mulsuchar (signed char x, signed char y)
  401                        	;
  402                        	; 1st parameter in A (unsigned multiplicand)
  403                        	; 2nd parameter in Y (signed multiplier)
  404                        	; result in Y:A
  405                        	;
  406                        	; N.B. Y and A get swapped to make the code shorter.
  407                        	
  408    00:E535  42         	__mulsuchar:	say				; Put the signed param in A.
  409                        			; drop through to __muluschar
  410                        	
  411                        	
  412                        	
  413                        	; ***************************************************************************
  414                        	; signed int
  415                        	; _muluschar (unsigned char x, unsigned char y)
  416                        	;
  417                        	; 1st parameter in A (signed multiplicand)
  418                        	; 2nd parameter in Y (unsigned multiplier)
  419                        	; result in Y:A
  420                        	
  421    00:E536  C9 80      	__muluschar:	cmp	#$80			; Is multiplicand -ve?
  422    00:E538  08         			php				; Remember the sign.
  423    00:E539  90 03      			bcc	!+
  424    00:E53B  49 FF      			eor	#$FF			; Negate multiplicand.
  425    00:E53D  1A         			inc	a
  426                        	
  427    00:E53E  20 F0 E4   	!:		jsr	__muluchar		; Do the unsigned multiply.
  428                        	
  429    00:E541  28         			plp				; Was multiplicand -ve?
  430    00:E542  B0 CA      			bcs	neg_yacs		; Then negate the product.
  431    00:E544  60         			rts
  432                        	
  433                        	
  434                        	
  435                        	; ***************************************************************************
  436                        	; unsigned int
  437                        	; _moduchar (unsigned char x, unsigned char y)
  438                        	;
  439                        	; 1st parameter in A (unsigned dividend)
  440                        	; 2nd parameter in Y (unsigned divisor)
  441                        	; result in Y:A
  442                        	
  443    00:E545  84 00      	__moduchar:	sty.l	<divisor
  444                        	
  445    00:E547  0A         	divmodu8_a:	asl	a			; Rotate dividend, MSB -> C.
  446    00:E548  85 94      			sta.l	<dividend
  447    00:E54A  64 95      			stz.h	<dividend		; Clear quotient hi-byte.
  448                        	
  449    00:E54C  A0 08      			ldy	#8
  450    00:E54E  62         			cla				; Clear remainder.
  451    00:E54F  2A         	.loop:		rol	a			; Rotate C into remainder.
  452    00:E550  C5 00      			cmp	<divisor		; Test divisor.
  453    00:E552  90 02      			bcc	.skip			; CC if divisor > remainder.
  454    00:E554  E5 00      			sbc	<divisor		; Subtract divisor.
  455    00:E556  26 94      	.skip:		rol	<dividend		; Quotient bit -> dividend LSB.
  456    00:E558  88         			dey
  457    00:E559  D0 F4      			bne	.loop
  458                        	
  459    00:E55B  C2         			cly				; Clear hi-byte of return.
  460    00:E55C  60         			rts				; Return the 16-bit remainder.
  461                        	
  462                        	
  463                        	
  464                        	; ***************************************************************************
  465                        	; unsigned int
  466                        	; _divuchar (unsigned char x, unsigned char y)
  467                        	;
  468                        	; 1st parameter in A (unsigned dividend)
  469                        	; 2nd parameter in Y (unsigned divisor)
  470                        	; result in Y:A
  471                        	
  472    00:E55D  20 45 E5   	__divuchar:	jsr	__moduchar
  473                        	
  474    00:E560  A5 94      			lda	<dividend		; Get the dividend lo-byte.
  475    00:E562  60         			rts				; Return the 16-bit dividend.
  476                        	
  477                        	
  478                        	
  479                        	; ***************************************************************************
  480                        	; signed int
  481                        	; _modschar (signed char x, signed char y)
  482                        	;
  483                        	; 1st parameter in A (signed dividend)
  484                        	; 2nd parameter in Y (signed divisor)
  485                        	; result in Y:A
  486                        	
  487    00:E563  AA         	__modschar:	tax				; Preserve the dividend.
  488    00:E564  08         			php				; Remember remainder sign.
  489                        	
  490    00:E565  84 00      			sty	<divisor		; Quotient negative if divisor
  491    00:E567  45 00      			eor	<divisor		; and dividend signs differ.
  492    00:E569  08         			php				; Remember the quotient sign.
  493                        	
  494    00:E56A  98         			tya				; Is the divisor -ve?
  495    00:E56B  10 05      			bpl	!+
  496    00:E56D  49 FF      			eor	#$FF			; Negate the divisor.
  497    00:E56F  1A         			inc	a
  498    00:E570  85 00      			sta	<divisor
  499                        	
  500    00:E572  8A         	!:		txa				; Is the dividend -ve?
  501    00:E573  10 03      			bpl	divmods8_a
  502                        	
  503    00:E575  49 FF      	divmods8_neg:	eor	#$FF			; Negate the dividend.
  504    00:E577  1A         			inc	a
  505                        	
  506    00:E578  20 47 E5   	divmods8_a:	jsr	divmodu8_a		; Do the unsigned division.
  507                        	
  508    00:E57B  28         			plp				; Should the quotient be -ve?
  509    00:E57C  10 0C      			bpl	!+
  510                        	
  511    00:E57E  AA         			tax				; Preserve remainder lo-byte.
  512                        	
  513    00:E57F  38         			sec				; Negate the quotient.
  514    00:E580  62         			cla
  515    00:E581  E5 94      			sbc.l	<dividend
  516    00:E583  85 94      			sta.l	<dividend
  517    00:E585  A9 FF      			lda	#$FF
  518    00:E587  85 95      			sta.h	<dividend
  519                        	
  520    00:E589  8A         			txa				; Restore remainder lo-byte.
  521                        	
  522    00:E58A  28         	!:		plp				; Was the dividend -ve?
  523    00:E58B  10 05      			bpl	!+
  524                        	
  525    00:E58D  49 FF      			eor	#$FF			; Then negate the remainder.
  526    00:E58F  1A         			inc	a
  527    00:E590  A0 FF      			ldy	#$FF
  528                        	
  529    00:E592  60         	!:		rts
  530                        	
  531                        	
  532                        	
  533                        	; ***************************************************************************
  534                        	; signed int
  535                        	; _moduschar (unsigned char x, unsigned char y)
  536                        	;
  537                        	; 1st parameter in A (signed dividend)
  538                        	; 2nd parameter in Y (unsigned divisor)
  539                        	; result in Y:A
  540                        	
  541    00:E593  84 00      	__moduschar:	sty.l	<divisor
  542                        	
  543    00:E595  A8         			tay				; Is the dividend -ve?
  544    00:E596  08         			php				; Remember remainder sign.
  545    00:E597  08         			php				; Remember quotient sign.
  546    00:E598  30 DB      			bmi	divmods8_neg
  547    00:E59A  80 DC      			bra	divmods8_a
  548                        	
  549                        	
  550                        	
  551                        	; ***************************************************************************
  552                        	; unsigned int
  553                        	; _modsuchar (signed char x, signed char y)
  554                        	;
  555                        	; 1st parameter in A (unsigned dividend)
  556                        	; 2nd parameter in Y (signed divisor)
  557                        	; result in Y:A
  558                        	
  559    00:E59C  AA         	__modsuchar:	tax				; Preserve the dividend.
  560    00:E59D  08         			php				; Remember remainder sign.
  561                        	
  562    00:E59E  98         			tya				; Check the divisor sign.
  563    00:E59F  08         			php				; Remember quotient sign.
  564    00:E5A0  10 03      			bpl	!+
  565    00:E5A2  49 FF      			eor	#$FF			; Negate the divisor.
  566    00:E5A4  1A         			inc	a
  567    00:E5A5  85 00      	!:		sta.l	<divisor
  568                        	
  569    00:E5A7  8A         			txa				; Restore the dividend.
  570    00:E5A8  80 CE      			bra	divmods8_a
  571                        	
  572                        	
  573                        	
  574                        	; ***************************************************************************
  575                        	; signed int
  576                        	; _divschar (signed char x, signed char y)
  577                        	;
  578                        	; 1st parameter in A (signed dividend)
  579                        	; 2nd parameter in Y (signed divisor)
  580                        	; result in Y:A
  581                        	
  582    00:E5AA  20 63 E5   	__divschar:	jsr	__modschar
  583                        	
  584    00:E5AD  A5 94      			lda.l	<dividend
  585    00:E5AF  A4 95      			ldy.h	<dividend
  586    00:E5B1  60         			rts
  587                        	
  588                        	
  589                        	
  590                        	; ***************************************************************************
  591                        	; signed int
  592                        	; _divuschar (unsigned char x, unsigned char y)
  593                        	;
  594                        	; 1st parameter in A (signed dividend)
  595                        	; 2nd parameter in Y (unsigned divisor)
  596                        	; result in Y:A
  597                        	
  598    00:E5B2  20 93 E5   	__divuschar:	jsr	__moduschar
  599                        	
  600    00:E5B5  A5 94      			lda.l	<dividend
  601    00:E5B7  A4 95      			ldy.h	<dividend
  602    00:E5B9  60         			rts
  603                        	
  604                        	
  605                        	
  606                        	; ***************************************************************************
  607                        	; unsigned int
  608                        	; _divsuchar (signed char x, signed char y)
  609                        	;
  610                        	; 1st parameter in A (unsigned dividend)
  611                        	; 2nd parameter in Y (signed divisor)
  612                        	; result in Y:A
  613                        	
  614    00:E5BA  20 9C E5   	__divsuchar:	jsr	__modsuchar
  615                        	
  616    00:E5BD  A5 94      			lda.l	<dividend
  617    00:E5BF  A4 95      			ldy.h	<dividend
  618    00:E5C1  60         			rts
                             #[2]   "..\..\..\include\hucc\hucc-final.asm"
   43                        	
   44                        			; Define in hucc-config.inc to remove this.
   45                        	
   46               0001     		.ifndef	HUCC_NO_DEFAULT_RANDOM
                             #[3]   "..\..\..\include\hucc\random.asm"
   47                        			include	"random.asm"		; Random number generator.
    1                        	; ***************************************************************************
    2                        	; ***************************************************************************
    3                        	;
    4                        	; random.asm
    5                        	;
    6                        	; Pseudo-random number generator (https://github.com/bbbradsmith/prng_6502)
    7                        	;
    8                        	; Copyright Brad Smith 2019.
    9                        	;
   10                        	; License:
   11                        	;
   12                        	; This code and may be used, reused, and modified for any purpose, commercial
   13                        	; or non-commercial.
   14                        	;
   15                        	; Attribution in released binaries or documentation is appreciated but not
   16                        	; required.
   17                        	;
   18                        	; ***************************************************************************
   19                        	; ***************************************************************************
   20                        	;
   21                        	; This is a linear feedback shift register (LFSR) in Galois form, which is
   22                        	; iterated 8 times to produce an 8-bit pseudo-random number.
   23                        	;
   24                        	; Two widths of LFSR are provided:
   25                        	;
   26                        	;  24-bit requires 3 bytes, and repeats after 16777215 calls.
   27                        	;  32-bit requires 4 bytes, and repeats after 4294967295 calls.
   28                        	;
   29                        	; Usage:
   30                        	;
   31                        	;  Initialize the zero-page "random" variable to any value other than 0.
   32                        	;  The size of "random" is 3 or 4 bytes, depending on the width of LFSR
   33                        	;  chosen.
   34                        	;
   35                        	;  Call one of the RNG functions and an 8-bit result will be returned in the
   36                        	;  A-register (with flags), and the Y-register will be clobbered.
   37                        	;
   38                        	;  Do not mix RNGs of different width in the same program, unless you can
   39                        	;  give them each separate "random" state storage.
   40                        	;
   41                        	; ***************************************************************************
   42                        	; ***************************************************************************
   43                        	
   44                        	
   45               0001     		.ifndef	_KICKC				; Variables defined in C?
   46               2098     			.zp
   47    F8:2098             	random:		.ds	4			; Seed is 3 or 4 bytes.
   48               E5C2     			.code
   49                        		.endif	_KICKC
   50                        	
   51                        	
   52                        	
   53                        	; ***************************************************************************
   54                        	; ***************************************************************************
   55                        	;
   56                        	; init_random - Initialize a 32-bit LFSR using an 8-bit seed value in Y.
   57                        	;
   58                        	; The LFSR is initialized to n'th entry of a standard CRC-32 lookup-table,
   59                        	; which gives it a decent distribution of bits.
   60                        	;
   61                        	; Since seed is an 8-bit value, there are 255 (256-1) possible starting
   62                        	; states for the LFSR, because 0 would generate a 0 state.
   63                        	;
   64                        	; CRC-32 code by Paul Guertin. See http://6502.org/source/integers/crc.htm
   65                        	;
   66                        	
   67    11:C841             	init_random	.proc
   68                        	
   69    11:C841  A9 01      			lda	#1			; Init CRC-32 table value.
   70    11:C843  85 98      			sta	<random + 0
   71    11:C845  98         			tya				; Get and check the seed value.
   72    11:C846  D0 01      			bne	.reverse_seed
   73    11:C848  3A         			dec	a			; Which must be non-zero!
   74    11:C849  4A         	.reverse_seed:	lsr	a			; Reverse the bits so that small changes
   75    11:C84A  26 98      			rol	<random + 0		; in the seed make larger differences in
   76    11:C84C  90 FB      			bcc	.reverse_seed		; the initial state.
   77                        	
   78    11:C84E  64 99      			stz	<random + 1		; A contains the high byte of the CRC-32.
   79    11:C850  64 9A      			stz	<random + 2		; The other three bytes are in memory.
   80    11:C852  62         			cla
   81                        	
   82    11:C853  A0 08      			ldy	#8			; Y counts bits in a byte.
   83    11:C855  4A         	.bit_loop:	lsr	a			; The CRC-32 algorithm is similar to CRC-16
   84    11:C856  66 9A      			ror	<random + 2		; except that it is reversed (originally for
   85    11:C858  66 99      			ror	<random + 1		; hardware reasons). This is why we shift
   86    11:C85A  66 98      			ror	<random + 0		; right instead of left here.
   87    11:C85C  90 16      			bcc	.no_add			; Do nothing if no overflow,
   88    11:C85E  49 ED      			eor	#$ED			; else add CRC-32 polynomial $EDB88320.
   89                        	
   90    11:C860  48         			pha				; Save high byte while we do others.
   91    11:C861  A5 9A      			lda	<random + 2
   92    11:C863  49 B8      			eor	#$B8			; Most reference books give the CRC-32 poly
   93    11:C865  85 9A      			sta	<random + 2		; as $04C11DB7. This is actually the same if
   94    11:C867  A5 99      			lda	<random + 1		; you write it in binary and read it right-
   95    11:C869  49 83      			eor	#$83			; to-left instead of left-to-right. Doing it
   96    11:C86B  85 99      			sta	<random + 1		; this way means we won't have to explicitly
   97    11:C86D  A5 98      			lda	<random + 0		; reverse things afterwards.
   98    11:C86F  49 20      			eor	#$20
   99    11:C871  85 98      			sta	<random + 0
  100    11:C873  68         			pla				; Restore high byte.
  101                        	
  102    11:C874  88         	.no_add:	dey				; Do next bit.
  103    11:C875  D0 DE      			bne	.bit_loop
  104                        	
  105    11:C877  85 9B      			sta	<random + 3		; Save CRC-32 high-byte.
  106                        	
  107                        			leave				; All done!
         11:C879  4C EF FF   			jmp	leave_proc
  108                        	
  109                        			.endp
  110                        	
  111                        	
  112                        	
  113                        	; ***************************************************************************
  114                        	; ***************************************************************************
  115                        	;
  116                        	; get_random - 8-bit LFSR pseudo-random number with a 24-bit cycle.
  117                        	;
  118                        	; The pseudo-random sequence repeats after (2^24)-1 calls.
  119                        	;
  120                        	; Written by Wim Couwenberg, see ...
  121                        	;
  122                        	; "https://wimcouwenberg.wordpress.com/2020/11/15/ ...
  123                        	;  a-fast-24-bit-prng-algorithm-for-the-6502-processor/"
  124                        	;
  125                        	; Takes 68 cycles on the HuC6280, incl JSR & RTS.
  126                        	;
  127                        	; N.B. HuCC library code relies on this preserving X and Y!
  128                        	;
  129                        	
  130    00:E5C2  C2         	_rand8:		cly				; Entry point for HuCC.
  131                        	
  132    00:E5C3  A5 98      	get_random:	lda	<random + 0		; Operation 7 (with carry clear).
  133    00:E5C5  0A         			asl	a
  134    00:E5C6  45 99      			eor	<random + 1
  135    00:E5C8  85 99      			sta	<random + 1
  136    00:E5CA  2A         			rol	a             		; Operation 9.
  137    00:E5CB  45 9A      			eor	<random + 2
  138    00:E5CD  85 9A      			sta	<random + 2
  139    00:E5CF  45 98      			eor	<random + 0		; Operation 5.
  140    00:E5D1  85 98      			sta	<random + 0
  141    00:E5D3  A5 99      			lda	<random + 1		; Operation 15.
  142    00:E5D5  6A         			ror	a
  143    00:E5D6  45 9A      			eor	<random + 2
  144    00:E5D8  85 9A      			sta	<random + 2
  145    00:E5DA  45 99      			eor	<random + 1		; Operation 6.
  146    00:E5DC  85 99      			sta	<random + 1
  147    00:E5DE  60         			rts
  148                        	
  149                        	
  150                        	
  151               0000     		.if	0
  316                        		.endif
                             #[2]   "..\..\..\include\hucc\hucc-final.asm"
   48                        		.endif
   49                        	
   50                        			; Optional libraries that get used when their header files
   51                        			; are included in a HuCC project.
   52                        			;
   53                        			; When the HuCC compiler is invoked with the "--legacy"
   54                        			; option to compile old projects, then the "huc.h" file
   55                        			; is automatically included, which then includes a list
   56                        			; of specific headers corresponding to HuC's library.
   57                        	
   58               0001     		.ifdef	HUCC_USES_GFX
                             #[3]   "..\..\..\include\hucc\hucc-gfx.asm"
   59                        			include	"hucc-gfx.asm"		; Set in hucc_gfx.h
    1                        	; ***************************************************************************
    2                        	; ***************************************************************************
    3                        	;
    4                        	; huc-gfx.asm
    5                        	;
    6                        	; Based on the original HuC and MagicKit functions by David Michel and the
    7                        	; other original HuC developers.
    8                        	;
    9                        	; Modifications copyright John Brandwood 2024-2025.
   10                        	;
   11                        	; Distributed under the Boost Software License, Version 1.0.
   12                        	; (See accompanying file LICENSE_1_0.txt or copy at
   13                        	;  http://www.boost.org/LICENSE_1_0.txt)
   14                        	;
   15                        	; ***************************************************************************
   16                        	; ***************************************************************************
   17                        	
   18                        	;
   19                        	; Include dependancies ...
   20                        	;
   21                        	
   22                        			include "common.asm"		; Common helpers.
   23                        			include "vce.asm"		; Useful VCE routines.
   24                        			include "vdc.asm"		; Useful VCE routines.
   25                        	
   26                        	
   27                        	
   28                        	; ***************************************************************************
   29                        	; ***************************************************************************
   30                        	;
   31                        	; void __fastcall disp_on( void );
   32                        	; void __fastcall disp_off( void );
   33                        	
   34    00:E5DF             			.alias	_disp_on		= set_dspon
   35    00:E5DF             			.alias	_disp_off		= set_dspoff
   36                        	
   37                        	
   38                        	
   39                        	; ***************************************************************************
   40                        	; ***************************************************************************
   41                        	;
   42                        	; void __fastcall set_screen_size( unsigned char value<_al> );
   43                        	; void __fastcall sgx_set_screen_size( unsigned char value<_al> );
   44                        	;
   45                        	
   46    00:E5DF             			.alias	_set_screen_size.1	= set_bat_vdc
   47    00:E5DF             			.alias	_sgx_set_screen_size.1	= set_bat_sgx
   48                        	
   49                        	
   50                        	
   51                        	; ***************************************************************************
   52                        	; ***************************************************************************
   53                        	;
   54                        	; void __fastcall init_256x224( void );
   55                        	
   56    11:C691             	_init_256x224	.proc
   57                        	
   58               0800     	.BAT_SIZE	=	64 * 32
   59               0080     	.CHR_0x20	=	.BAT_SIZE / 16		; 1st tile # after the BAT.
   60               7F00     	.SAT_ADDR	=	$7F00			; SAT takes 16 tiles of VRAM.
   61                        	
   62    11:C691  08         			php				; Disable interrupts.
   63    11:C692  78         			sei
   64                        	
   65    11:C693  20 DD FD   			call	clear_vce		; Clear all palettes.
   66                        	
   67    11:C696  A9 80      			lda.l	#.CHR_0x20		; CHR # of ASCII ' '.
   68    11:C698  85 F8      			sta.l	<_ax
   69    11:C69A  A9 00      			lda.h	#.CHR_0x20
   70    11:C69C  85 F9      			sta.h	<_ax
   71                        	
   72    11:C69E  A9 08      			lda	#>.BAT_SIZE		; Size of BAT in words.
   73    11:C6A0  85 FA      			sta	<_bl
   74                        	
   75    11:C6A2  20 F1 FD   			call	clear_vram_vdc		; Clear VRAM.
   76               0001     		.if	SUPPORT_SGX
   77    11:C6A5  20 D3 FD   			call	clear_vram_sgx
   78                        		.endif
   79                        	
   80    11:C6A8  A9 CC      			lda	#<.mode_256x224		; Disable BKG & SPR layers but
   81    11:C6AA  85 EC      			sta.l	<_bp			; enable RCR & VBLANK IRQ.
   82    11:C6AC  A9 C6      			lda	#>.mode_256x224
   83    11:C6AE  85 ED      			sta.h	<_bp
   84                        	
   85               0001     		.if	SUPPORT_SGX
   86    11:C6B0  20 C9 FD   			call	sgx_detect		; Are we really on an SGX?
   87    11:C6B3  90 05      			bcc	!+
   88    11:C6B5  A0 11      			ldy	#^.mode_256x224		; Set SGX 1st, with no VBL.
   89    11:C6B7  20 BF FD   			call	set_mode_sgx
   90                        		.endif
   91    11:C6BA  A0 11      	!:		ldy	#^.mode_256x224		; Set VDC 2nd, VBL allowed.
   92    11:C6BC  20 B5 FD   			call	set_mode_vdc
   93                        	
   94               0001     		.if	SUPPORT_SGX
   95    11:C6BF  2C 10 02   			bit	SGX_SR			; Purge any overdue RCR.
   96                        		.endif
   97    11:C6C2  2C 00 02   			bit	VDC_SR			; Purge any overdue VBL.
   98    11:C6C5  28         			plp				; Restore interrupts.
   99                        	
  100    11:C6C6  20 09 E3   			call	wait_vsync		; Wait for the next VBLANK.
  101                        	
  102                        			leave				; All done, phew!
         11:C6C9  4C EF FF   			jmp	leave_proc
  103                        	
  104                        			; A standard 256x224 screen with overscan.
  105                        	
  106    11:C6CC  80         	.mode_256x224:	db	$80			; VCE Control Register.
  107    11:C6CD  04         			db	VCE_CR_5MHz + XRES_SOFT	;   Video Clock + Artifact Reduction
  108                        	
  109    11:C6CE  09         			db	VDC_MWR			; Memory-access Width Register
  110    11:C6CF  10 00      			dw	VDC_MWR_64x32 + VDC_MWR_1CYCLE
  111    11:C6D1  0A         			db	VDC_HSR			; Horizontal Sync Register
  112    11:C6D2  02 02      			dw	VDC_HSR_256
  113    11:C6D4  0B         			db	VDC_HDR			; Horizontal Display Register
  114    11:C6D5  1F 04      			dw	VDC_HDR_256
  115    11:C6D7  0C         			db	VDC_VPR			; Vertical Sync Register
  116    11:C6D8  02 17      			dw	VDC_VPR_224
  117    11:C6DA  0D         			db	VDC_VDW			; Vertical Display Register
  118    11:C6DB  DF 00      			dw	VDC_VDW_224
  119    11:C6DD  0E         			db	VDC_VCR			; Vertical Display END position Register
  120    11:C6DE  FF 00      			dw	VDC_VCR_224
  121    11:C6E0  0F         			db	VDC_DCR			; DMA Control Register
  122    11:C6E1  10 00      			dw	$0010			;   Enable automatic VRAM->SATB
  123    11:C6E3  13         			db	VDC_DVSSR		; VRAM->SATB address $7F00
  124    11:C6E4  00 7F      			dw	.SAT_ADDR
  125    11:C6E6  07         			db	VDC_BXR			; Background X-Scroll Register
  126    11:C6E7  00 00      			dw	$0000
  127    11:C6E9  08         			db	VDC_BYR			; Background Y-Scroll Register
  128    11:C6EA  00 00      			dw	$0000
  129    11:C6EC  06         			db	VDC_RCR			; Raster Counter Register
  130    11:C6ED  00 00      			dw	$0000			;   Never occurs!
  131    11:C6EF  05         			db	VDC_CR			; Control Register
  132    11:C6F0  0C 00      			dw	$000C			;   Enable VSYNC & RCR IRQ
  133    11:C6F2  00         			db	0
  134                        	
  135                        			.endp
  136                        	
  137                        	
  138                        	
  139                        	; ***************************************************************************
  140                        	; ***************************************************************************
  141                        	;
  142                        	; void __fastcall init_240x208( void );
  143                        	
  144                        	_init_240x208	.proc
  223                        			.endp
  224                        	
  225                        	
  226                        	
  227                        	; ***************************************************************************
  228                        	; ***************************************************************************
  229                        	;
  230                        	; void __fastcall _macro set_xres( unsigned int x_pixels<_ax> );
  231                        	; void __fastcall _macro sgx_set_xres( unsigned int x_pixels<_ax> );
  232                        	;
  233                        	; void __fastcall set_xres( unsigned int x_pixels<_ax>, unsigned char blur_flag<_bl> );
  234                        	; void __fastcall sgx_set_xres( unsigned int x_pixels<_ax>, unsigned char blur_flag<_bl> );
  235                        	;
  236                        	; blur_flag = XRES_SOFT (default if not specified), XRES_SHARP or XRES_KEEP
  237                        	
  238                        	set_xres_group	.procgroup			; These routines share code!
  337                        			.endprocgroup	; set_xres_group
  338                        	
  339                        	
  340                        	
  341                        	; ***************************************************************************
  342                        	; ***************************************************************************
  343                        	;
  344                        	; HuC VRAM Functions
  345                        	;
  346                        	; ***************************************************************************
  347                        	; ***************************************************************************
  348                        	
  349                        	
  350    11:C5C3             	load_vram_group	.procgroup			; These routines share code!
  351                        	
  352                        	; ***************************************************************************
  353                        	; ***************************************************************************
  354                        	;
  355                        	; void __fastcall load_vram( unsigned int vram<_di>, unsigned char __far *data<_bp_bank:_bp>, unsigned int num_words<_ax> );
  356                        	; void __fastcall sgx_load_vram( unsigned int vram<_di>, unsigned char __far *data<_bp_bank:_bp>, unsigned int num_words<_ax> );
  357                        	;
  358                        	; void __fastcall far_load_vram( unsigned int vram<_di>, unsigned int num_words<_ax> );
  359                        	; void __fastcall sgx_far_load_vram( unsigned int vram<_di>, unsigned int num_words<_ax> );
  360                        	;
  361                        	; load_vram_sgx -  copy a block of memory to VRAM
  362                        	; load_vram_vdc -  copy a block of memory to VRAM
  363                        	;
  364                        	; _bp		= BAT memory location
  365                        	; _bp_bank	= BAT bank
  366                        	; _di		= VRAM base address
  367                        	; _ax		= nb of words to copy
  368                        	; ----
  369                        	; N.B. BAT data *must* be word-aligned!
  370                        	
  371               0000     		.ifndef	VRAM_XFER_SIZE
  373                        		.endif
  374                        	
  375    11:C5C3             	load_vram_x	.proc
  376                        	
  377    11:C5C3  43 08      			tma3
  378    11:C5C5  48         			pha
  379    11:C5C6  43 10      			tma4
  380    11:C5C8  48         			pha
  381                        	
  382    11:C5C9  A4 02      			ldy	<_bp_bank
  383    11:C5CB  20 3B E3   			jsr	map_bp_to_mpr34		; Map data to MPR3 & MPR4.
  384                        	
  385    11:C5CE  20 7F E3   			jsr	set_di_to_mawr
  386                        	
  387                        	;		tii	.vdc_tai, ram_tia, 8
  388                        	
  389               0001     		.if	SUPPORT_SGX
  390    11:C5D1  8A         			txa				; Select which VDC to write
  391    11:C5D2  1A         			inc	a			; to.
  392    11:C5D3  1A         			inc	a
  393    11:C5D4  8D F3 22   			sta.l	ram_tia_dst
  394                        		.endif
  395                        	
  396    11:C5D7  A9 10      			lda	#VRAM_XFER_SIZE		; Split into 16-byte chunks
  397    11:C5D9  8D F5 22   			sta.l	ram_tia_len		; for stable IRQ response.
  398                        	
  399    11:C5DC  A6 EC      			ldx.l	<_bp
  400    11:C5DE  8E F1 22   			stx.l	ram_tia_src
  401    11:C5E1  A4 ED      			ldy.h	<_bp
  402    11:C5E3  8C F2 22   			sty.h	ram_tia_src
  403                        	
  404    11:C5E6  A5 F8      			lda.l	<_ax			; Length in words.
  405    11:C5E8  48         			pha				; Preserve length.l
  406                        	
  407    11:C5E9  46 F9      			lsr.h	<_ax
  408    11:C5EB  6A         			ror	a
  409    11:C5EC  46 F9      			lsr.h	<_ax
  410    11:C5EE  6A         			ror	a
  411    11:C5EF  46 F9      			lsr.h	<_ax
  412    11:C5F1  6A         			ror	a
  413               0000     		.if	VRAM_XFER_SIZE == 32
  416                        		.endif
  417                        	
  418    11:C5F2  22         			sax				; x=chunks-lo
  419    11:C5F3  F0 1F      			beq	.next_block		; a=source-lo, y=source-hi
  420                        	
  421    11:C5F5  20 F0 22   	.chunk_loop:	jsr	ram_tia			; transfer 16-bytes
  422                        	
  423    11:C5F8  18         			clc				; increment source
  424    11:C5F9  69 10      			adc	#VRAM_XFER_SIZE
  425    11:C5FB  8D F1 22   			sta.l	ram_tia_src
  426    11:C5FE  90 11      			bcc	.same_page
  427    11:C600  C8         			iny
  428    11:C601  10 0B      			bpl	.same_bank		; remap_data
  429                        	
  430    11:C603  42         			say
  431    11:C604  43 10      			tma4
  432    11:C606  53 08      			tam3
  433    11:C608  1A         			inc	a
  434    11:C609  53 10      			tam4
  435    11:C60B  A9 60      			lda	#$60
  436    11:C60D  42         			say
  437                        	
  438    11:C60E  8C F2 22   	.same_bank:	sty.h	ram_tia_src
  439                        	
  440    11:C611  CA         	.same_page:	dex
  441    11:C612  D0 E1      			bne	.chunk_loop
  442                        	
  443    11:C614  C6 F9      	.next_block:	dec.h	<_ax
  444    11:C616  10 DD      			bpl	.chunk_loop
  445                        	
  446    11:C618  68         			pla				; Restore length.l
  447    11:C619  29 07      			and	#VRAM_XFER_SIZE / 2 - 1
  448    11:C61B  F0 07      			beq	.done
  449                        	
  450    11:C61D  0A         			asl	a			; Convert words to bytes.
  451    11:C61E  8D F5 22   			sta.l	ram_tia_len
  452                        	
  453    11:C621  20 F0 22   			jsr	ram_tia			; transfer remainder
  454                        	
  455    11:C624  68         	.done:		pla
  456    11:C625  53 10      			tam4
  457    11:C627  68         			pla
  458    11:C628  53 08      			tam3
  459                        	
  460                        			leave
         11:C62A  4C EF FF   			jmp	leave_proc
  461                        	
  462                        			.endp
  463                        	
  464                        			.endprocgroup	; load_vram_group
  465                        	
  466                        	
  467                        	
  468                        	; ***************************************************************************
  469                        	; ***************************************************************************
  470                        	;
  471                        	; void __fastcall load_bat( unsigned int vram<_di>, unsigned char __far *data<_bp_bank:_bp>, unsigned char tiles_w<_al>, unsigned char tiles_h<_ah> );
  472                        	; void __fastcall sgx_load_bat( unsigned int vram<_di>, unsigned char __far *data<_bp_bank:_bp>, unsigned char tiles_w<_al>, unsigned char tiles_h<_ah> );
  473                        	;
  474                        	; void __fastcall far_load_bat( unsigned int vram<_di>, unsigned char tiles_w<_al>, unsigned char tiles_h<_ah> );
  475                        	; void __fastcall sgx_far_load_bat( unsigned int vram<_di>, unsigned char tiles_w<_al>, unsigned char tiles_h<_ah> );
  476                        	;
  477                        	; load_bat_sgx - transfer a BAT to VRAM
  478                        	; load_bat_vdc - transfer a BAT to VRAM
  479                        	;
  480                        	; transfer a BAT to VRAM
  481                        	; ----
  482                        	; _bp		= BAT memory location
  483                        	; _bp_bank	= BAT bank
  484                        	; _di		= VRAM base address
  485                        	; _al		= nb of column to copy
  486                        	; _ah		= nb of row
  487                        	; ----
  488                        	; N.B. BAT data *must* be word-aligned!
  489                        	
  490               20EC     	_gfx_load_bat_PARM_2	=	_bp
  491               20F0     	_gfx_load_bat_PARM_3	=	_di
  492               20F8     	_gfx_load_bat_PARM_4	=	_al
  493               20F9     	_gfx_load_bat_PARM_5	=	_ah
  494                        	
  495    11:C7C4             	load_bat_group	.procgroup			; These routines share code!
  496                        	
  497               0001     		.if	SUPPORT_SGX
  498                        			.proc	_sgx_load_bat.4
  505                        			.endp
  506                        		.endif
  507                        	
  508    11:C7C4             			.proc	_load_bat.4
  509    11:C7C4             			.alias	_far_load_bat.3		= _load_bat.4
  510                        	
  511    11:C7C4  82         			clx				; Offset to PCE VDC.
  512                        	
  513    11:C7C5  43 08      			tma3
  514    11:C7C7  48         			pha
  515                        	
  516    11:C7C8  A4 02      			ldy	<_bp_bank
  517    11:C7CA  20 2D E3   			jsr	map_bp_to_mpr3		; Map data to MPR3.
  518                        	
  519    11:C7CD  A4 EC      			ldy.l	<_bp
  520    11:C7CF  64 EC      			stz.l	<_bp
  521                        	
  522    11:C7D1  20 7F E3   	.line_loop:	jsr	set_di_to_mawr
  523                        	
  524    11:C7D4  A5 F8      			lda	<_al
  525    11:C7D6  85 00      			sta	<__temp
  526    11:C7D8  B1 EC      	.tile_loop:	lda	[_bp], y
  527    11:C7DA  9D 02 02   			sta	VDC_DL, x
  528    11:C7DD  C8         			iny
  529    11:C7DE  B1 EC      			lda	[_bp], y
  530    11:C7E0  9D 03 02   			sta	VDC_DH, x
  531    11:C7E3  C8         			iny
  532    11:C7E4  D0 03      			bne	!+
  533    11:C7E6  20 4C E3   			jsr	inc.h_bp_mpr3
  534    11:C7E9  C6 00      	!:		dec	<__temp
  535    11:C7EB  D0 EB      			bne	.tile_loop
  536                        	
  537    11:C7ED  BD 6B 26   			lda	vdc_bat_width, x
  538    11:C7F0  18         			clc
  539    11:C7F1  65 F0      			adc.l	<_di
  540    11:C7F3  85 F0      			sta.l	<_di
  541    11:C7F5  90 02      			bcc	!+
  542    11:C7F7  E6 F1      			inc.h	<_di
  543                        	
  544    11:C7F9  C6 F9      	!:		dec	<_ah
  545    11:C7FB  D0 D4      			bne	.line_loop
  546                        	
  547    11:C7FD  68         			pla
  548    11:C7FE  53 08      			tam3
  549                        	
  550                        			leave
         11:C800  4C EF FF   			jmp	leave_proc
  551                        	
  552                        			.endp
  553                        	
  554                        			.endprocgroup	; load_bat_group
  555                        	
  556                        	
  557                        	
  558                        	; ***************************************************************************
  559                        	; ***************************************************************************
  560                        	;
  561                        	; void __fastcall load_palette( unsigned char palette<_al>, unsigned char __far *data<_bp_bank:_bp>, unsigned char num_palettes<_ah> );
  562                        	;
  563                        	; void __fastcall far_load_palette( unsigned char palette<_al>, unsigned char num_palettes<_ah> );
  564                        	
  565    11:C8E4             			.proc	_load_palette.3
  566    11:C8E4             			.alias	_far_load_palette.2	= _load_palette.3
  567                        	
  568    11:C8E4  AC 42 26   			ldy	color_queue_w		; Get the queue's write index.
  569                        	
  570    11:C8E7  A5 EC      			lda.l	<_bp			; Add this set of palettes to
  571    11:C8E9  99 53 26   			sta	color_addr_l, y		; the queue.
  572    11:C8EC  A5 ED      			lda.h	<_bp
  573    11:C8EE  99 5B 26   			sta	color_addr_h, y
  574    11:C8F1  A5 02      			lda	<_bp_bank
  575    11:C8F3  99 63 26   			sta	color_bank, y
  576    11:C8F6  A5 F8      			lda	<_al
  577    11:C8F8  99 43 26   			sta	color_index, y
  578    11:C8FB  A5 F9      			lda	<_ah
  579    11:C8FD  99 4B 26   			sta	color_count, y
  580                        	
  581    11:C900  C8         			iny				; Increment the queue index.
  582    11:C901  98         			tya
  583    11:C902  29 07      			and	#7
  584                        	
  585    11:C904  CD 41 26   	.wait:		cmp	color_queue_r		; If the queue is full, wait
  586    11:C907  F0 FB      			beq	.wait			; for the next VBLANK.
  587                        	
  588    11:C909  8D 42 26   			sta	color_queue_w		; Signal item is in the queue.
  589                        	
  590                        			leave				; All done, phew!
         11:C90C  4C EF FF   			jmp	leave_proc
  591                        	
  592                        			.endp
  593                        	
  594                        	
  595                        	
  596               0000     		.if	0
  620                        		.endif
  621                        	
  622                        	
  623                        	
  624                        	; ***************************************************************************
  625                        	; ***************************************************************************
  626                        	;
  627                        	; void __fastcall load_background( unsigned char __far *tiles<_bp_bank:_bp>, unsigned char __far *palettes<__fbank:__fptr>, unsigned char __far *bat<_cl:_bx>, unsigned char w<_dl>, unsigned char w<_dh> );
  628                        	
  629                        			.proc	_load_background.5
  667                        			.endp
  668                        	
  669                        	
  670                        	
  671                        	; ***************************************************************************
  672                        	; ***************************************************************************
  673                        	;
  674                        	; void __fastcall vram2vram( unsigned int vram_dst<_ax>, unsigned int vram_src<_bx>, unsigned int word_len<_cx> );
  675                        	; void __fastcall sgx_vram2vram( unsigned int vram_dst<_ax>, unsigned int vram_src<_bx>, unsigned int word_len<_cx> );
  676                        	;
  677                        	
  678               0001     		.if	SUPPORT_SGX
  679                        			.proc	_sgx_vram2vram.3
  685                        			.endp
  686                        		.endif
  687                        	
  688    11:C803             			.proc	_vram2vram.3
  689                        	
  690    11:C803  82         			clx				; Offset to PCE VDC.
  691                        	
  692    11:C804  08         			php
  693    11:C805  78         			sei
  694    11:C806  A9 11      			lda	#VDC_DESR
  695    11:C808  9D 00 02   			sta	VDC_AR, x
  696    11:C80B  A5 F8      			lda.l	<_ax
  697    11:C80D  9D 02 02   			sta	VDC_DL, x
  698    11:C810  A5 F9      			lda.h	<_ax
  699    11:C812  9D 03 02   			sta	VDC_DH, x
  700                        	
  701    11:C815  A9 10      			lda	#VDC_SOUR
  702    11:C817  9D 00 02   			sta	VDC_AR, x
  703    11:C81A  A5 FA      			lda.l	<_bx
  704    11:C81C  9D 02 02   			sta	VDC_DL, x
  705    11:C81F  A5 FB      			lda.h	<_bx
  706    11:C821  9D 03 02   			sta	VDC_DH, x
  707                        	
  708    11:C824  A9 12      			lda	#VDC_LENR
  709    11:C826  9D 00 02   			sta	VDC_AR, x
  710    11:C829  18         			clc
  711    11:C82A  A5 FC      			lda.l	<_cx
  712    11:C82C  69 FF      			adc	#$FF
  713    11:C82E  9D 02 02   			sta	VDC_DL, x
  714    11:C831  A5 FD      			lda.h	<_cx
  715    11:C833  69 FF      			adc	#$FF
  716    11:C835  9D 03 02   			sta	VDC_DH, x
  717                        	
  718    11:C838  B5 F7      			lda	<vdc_reg, x
  719    11:C83A  8D 00 02   			sta	VDC_AR
  720    11:C83D  28         			plp
  721                        	
  722                        			leave
         11:C83E  4C EF FF   			jmp	leave_proc
  723                        	
  724                        			.endp
  725                        	
  726                        	
  727                        	
  728                        	; ***************************************************************************
  729                        	; ***************************************************************************
  730                        	;
  731                        	; HuC Font Functions
  732                        	;
  733                        	; ***************************************************************************
  734                        	; ***************************************************************************
  735                        	
  736                        	
  737                        	
  738               268B     			.bss
  739                        	
  740                        	; **************
  741                        	; 16-bytes of VDC BAT information.
  742                        	;
  743                        	; N.B. MUST be 16-bytes before the SGX versions to use PCE_VDC_OFFSET.
  744                        	
  745    F8:268B             	_vdc_font_base:	ds	2	; Tile number of ASCII '\0'.
  746                        	
  747                        	; From hucc-printf.asm just to avoid wasting .bss space with padding.
  748    F8:268D             	_vdc_tty_x_lhs:	ds	1	; TTY minimum X position.
  749    F8:268E             	_vdc_tty_y_top:	ds	1	; TTY minimum Y position.
  750    F8:268F             	_vdc_tty_x:	ds	1	; TTY current X position.
  751    F8:2690             	_vdc_tty_y:	ds	1	; TTY current Y position.
  752                        	
  753               0001     		.if	SUPPORT_SGX
  754                        	
  755                        	; **************
  756                        	; 16-bytes of SGX BAT information.
  757                        	;
  758                        	; N.B. MUST be 16-bytes after the VDC versions to use SGX_VDC_OFFSET.
  759                        	
  760    F8:2691             			ds	10	; Padding to ensure the 16-byte delta.
  761                        	
  762    F8:269B             	_sgx_font_base:	ds	2	; Tile number of ASCII '\0'.
  763                        	
  764                        	; From hucc-printf.asm just to avoid wasting .bss space with padding.
  765    F8:269D             	_sgx_tty_x_lhs:	ds	1	; TTY minimum X position.
  766    F8:269E             	_sgx_tty_y_top:	ds	1	; TTY minimum Y position.
  767    F8:269F             	_sgx_tty_x:	ds	1	; TTY current X position.
  768    F8:26A0             	_sgx_tty_y:	ds	1	; TTY current Y position.
  769                        	
  770                        		.endif
  771                        	
  772                        	;_font_base	.alias	vdc_font_base
  773                        	
  774               E5DF     			.code
  775                        	
  776                        	
  777                        	
  778                        	; ***************************************************************************
  779                        	; ***************************************************************************
  780                        	;
  781                        	; void __fastcall set_font_addr( unsigned int vram<acc> );
  782                        	; void __fastcall sgx_set_font_addr( unsigned int vram<acc> );
  783                        	
  784               0001     		.if	SUPPORT_SGX
  785    00:E5DF             	_sgx_set_font_addr.1:
  786    00:E5DF  A2 10      			ldx	#SGX_VDC_OFFSET		; Offset to SGX VDC.
  787    00:E5E1  F0         			db	$F0			; Turn "clx" into a "beq".
  788                        		.endif
  789                        	
  790    00:E5E2             	_set_font_addr.1:
  791    00:E5E2  82         			clx				; Offset to PCE VDC.
  792                        	
  793    00:E5E3  84 00      	set_font_addr:	sty	<__temp
  794    00:E5E5  46 00      			lsr	<__temp
  795    00:E5E7  6A         			ror	a
  796    00:E5E8  46 00      			lsr	<__temp
  797    00:E5EA  6A         			ror	a
  798    00:E5EB  46 00      			lsr	<__temp
  799    00:E5ED  6A         			ror	a
  800    00:E5EE  46 00      			lsr	<__temp
  801    00:E5F0  6A         			ror	a
  802    00:E5F1  38         			sec
  803    00:E5F2  E9 20      			sbc	#$20
  804    00:E5F4  9D 8B 26   			sta.l	_vdc_font_base,x
  805    00:E5F7  B0 02      			bcs	!+
  806    00:E5F9  C6 00      			dec	<__temp
  807                        	
  808    00:E5FB  BD 8C 26   	!:		lda.h	_vdc_font_base, x
  809    00:E5FE  29 F0      			and	#$F0
  810    00:E600  05 00      			ora	<__temp
  811    00:E602  9D 8C 26   			sta.h	_vdc_font_base, x
  812    00:E605  60         			rts
  813                        	
  814                        	
  815                        	
  816                        	; ***************************************************************************
  817                        	; ***************************************************************************
  818                        	;
  819                        	; void __fastcall set_font_pal( unsigned char palette<acc> );
  820                        	; void __fastcall sgx_set_font_pal( unsigned char palette<acc> );
  821                        	
  822               0001     		.if	SUPPORT_SGX
  823    00:E606             	_sgx_set_font_pal.1:
  824    00:E606  A2 10      			ldx	#SGX_VDC_OFFSET		; Offset to SGX VDC.
  825    00:E608  F0         			db	$F0			; Turn "clx" into a "beq".
  826                        		.endif
  827                        	
  828    00:E609             	_set_font_pal:					; For compatibility with HuC.
  829    00:E609             	_set_font_pal.1:
  830    00:E609  82         			clx				; Offset to PCE VDC.
  831    00:E60A  0A         			asl	a
  832    00:E60B  0A         			asl	a
  833    00:E60C  0A         			asl	a
  834    00:E60D  0A         			asl	a
  835    00:E60E  85 00      			sta	<__temp
  836                        	
  837    00:E610  BD 8C 26   			lda.h	_vdc_font_base, x
  838    00:E613  29 0F      			and	#$0F
  839    00:E615  05 00      			ora	<__temp
  840    00:E617  9D 8C 26   			sta.h	_vdc_font_base, x
  841    00:E61A  60         			rts
  842                        	
  843                        	
  844                        	
  845                        	; ***************************************************************************
  846                        	; ***************************************************************************
  847                        	;
  848                        	; void __fastcall load_font( char far *font<_bp_bank:_bp>, unsigned char count<_al> );
  849                        	;
  850                        	; void __fastcall load_font( char far *font<_bp_bank:_bp>, unsigned char count<_al>, unsigned int vram<acc> );
  851                        	; void __fastcall sgx_load_font( char far *font<_bp_bank:_bp>, unsigned char count<_al>, unsigned int vram<acc> );
  852                        	;
  853                        	; void __fastcall far_load_font( unsigned char count<_al>, unsigned int vram<acc> );
  854                        	; void __fastcall sgx_far_load_font( unsigned char count<_al>, unsigned int vram<acc> );
  855                        	
  856    00:E61B  AC 6F 26   	_load_font.2:	ldy	vdc_bat_limit		; Load the font directly
  857    00:E61E  C8         			iny				; after the BAT (stupid!).
  858    00:E61F  62         			cla
  859    00:E620  80 03      			bra	_load_font.3
  860                        	
  861               0001     		.if	SUPPORT_SGX
  862    00:E622             	_sgx_load_font.3:
  863    00:E622  A2 10      			ldx	#SGX_VDC_OFFSET		; Offset to SGX VDC.
  864    00:E624  F0         			db	$F0			; Turn "clx" into a "beq".
  865                        		.endif
  866                        	
  867    00:E625  82         	_load_font.3:	clx				; Offset to PCE VDC.
  868                        	
  869    00:E626  85 F0      			sta.l	<_di			; Load the font directly
  870    00:E628  84 F1      			sty.h	<_di			; after the BAT (stupid!).
  871                        	
  872    00:E62A  20 E3 E5   			jsr	set_font_addr		; Set xxx_font_base from addr.
  873                        	
  874    00:E62D  A5 F8      			lda	<__al			; Convert #tiles into #words.
  875    00:E62F  64 F9      			stz	<__ah
  876    00:E631  0A         			asl	a
  877    00:E632  26 F9      			rol	<__ah
  878    00:E634  0A         			asl	a
  879    00:E635  26 F9      			rol	<__ah
  880    00:E637  0A         			asl	a
  881    00:E638  26 F9      			rol	<__ah
  882    00:E63A  0A         			asl	a
  883    00:E63B  26 F9      			rol	<__ah
  884    00:E63D  85 F8      			sta	<__al
  885    00:E63F  4C 63 FF   			jmp	load_vram_x
  886                        	
  887    00:E642             			.alias	_far_load_font.2	= _load_font.3
  888    00:E642             			.alias	_sgx_far_load_font.2	= _sgx_load_font.3
  889                        	
  890                        	
  891                        	
  892                        	; ***************************************************************************
  893                        	; ***************************************************************************
  894                        	;
  895                        	; void __fastcall cls();
  896                        	; void __fastcall sgx_cls();
  897                        	;
  898                        	; void __fastcall cls( int tile<acc> );
  899                        	; void __fastcall sgx_cls( int tile<acc> );
  900                        	
  901               0001     		.if	SUPPORT_SGX
  902    00:E642  A2 10      	_sgx_cls:	ldx	#SGX_VDC_OFFSET		; Offset to SGX VDC.
  903    00:E644  F0         			db	$F0			; Turn "clx" into a "beq".
  904                        		.endif
  905                        	
  906    00:E645  82         	_cls:		clx				; Offset to PCE VDC.
  907                        	
  908    00:E646  BD 8B 26   	clear_tty_x:	lda.l	_vdc_font_base, x
  909    00:E649  BC 8C 26   			ldy.h	_vdc_font_base, x
  910    00:E64C  18         			clc
  911    00:E64D  69 20      			adc	#' '
  912    00:E64F  90 07      			bcc	!+
  913    00:E651  C8         			iny
  914    00:E652  80 04      			bra	!+
  915                        	
  916               0001     		.if	SUPPORT_SGX
  917    00:E654  A2 10      	_sgx_cls.1:	ldx	#SGX_VDC_OFFSET		; Offset to SGX VDC.
  918    00:E656  F0         			db	$F0			; Turn "clx" into a "beq".
  919                        		.endif
  920                        	
  921    00:E657  82         	_cls.1:		clx
  922                        	
  923    00:E658  85 F8      	!:		sta.l	<_ax			; VRAM word to write.
  924    00:E65A  84 F9      			sty.h	<_ax
  925    00:E65C  BD 6F 26   			lda	vdc_bat_limit, x	; BAT size hi-byte.
  926    00:E65F  1A         			inc	a
  927    00:E660  85 FA      			sta	<_bl
  928    00:E662  4C E7 FD   			jmp	clear_bat_x
  929                        	
  930                        	
  931                        	
  932                        	; ***************************************************************************
  933                        	; ***************************************************************************
  934                        	;
  935                        	; void __fastcall __macro load_default_font( void );
  936                        	; void __fastcall __macro sgx_load_default_font( void );
  937                        	;
  938                        	; Args: _bp, _bp_bank = _farptr to font data mapped into MPR3 & MPR4.
  939                        	; Args: _di = VRAM destination address.
  940                        	; Args: monofont_fg = font color (0..15)
  941                        	; Args: monofont_bg = background color (0..15)
  942                        	; Args: _al = number of tiles (aka characters) 0==256
  943                        	
  944    02:C802             	huc_monofont_x	.proc
  945                        	
  946               26A1     			.bss
  947    F8:26A1             	monofont_fg:	.ds	1
  948    F8:26A2             	monofont_bg:	.ds	1
  949               C802     			.code
  950                        	
  951    02:C802  BC 6F 26   			ldy	vdc_bat_limit, x	; BAT limit mask hi-byte.
  952    02:C805  C8         			iny
  953    02:C806  62         			cla
  954    02:C807  85 F0      			sta.l	<_di			; Load the font directly
  955    02:C809  84 F1      			sty.h	<_di			; after the BAT (stupid!).
  956                        	
  957    02:C80B  20 E3 E5   			jsr	set_font_addr		; Set xxx_font_base from addr.
  958                        	
  959    02:C80E  A9 92      			lda.l	#.font
  960    02:C810  85 EC      			sta.l	<_bp
  961    02:C812  A9 C8      			lda.h	#.font
  962    02:C814  85 ED      			sta.h	<_bp
  963                        	
  964    02:C816  A9 60      			lda	#$60			; #characters.
  965    02:C818  85 F8      			sta	<_al
  966                        	
  967    02:C81A  20 7F E3   			jsr	set_di_to_mawr
  968                        	
  969    02:C81D  AD A1 26   			lda	monofont_fg		; Foreground pixel color.
  970    02:C820  85 00      			sta	<__temp
  971    02:C822  AD A2 26   			lda	monofont_bg		; Background pixel color.
  972    02:C825  DA         			phx
  973    02:C826  A2 FC      			ldx.l	#_cx			; Create a bit mask for each
  974    02:C828  9E 00 20   	.bg_loop:	stz	$2000, x		; plane of the background.
  975    02:C82B  4A         			lsr	a
  976    02:C82C  90 03      			bcc	.bg_plane
  977    02:C82E  DE 00 20   			dec	$2000, x
  978    02:C831  E8         	.bg_plane:	inx
  979    02:C832  D0 F4      			bne	.bg_loop
  980    02:C834  FA         			plx
  981                        	
  982    02:C835  C2         	.tile_loop:	cly
  983                        	
  984    02:C836  B1 EC      	.plane01:	lda	[_bp], y		; Get font byte.
  985    02:C838  8F 00 06   			bbs0	<__temp, .set_plane0
  986    02:C83B  49 FF      	.clr_plane0:	eor	#$FF			; Clr font bits in background.
  987    02:C83D  25 FC      			and	<_cx + 0
  988    02:C83F  80 02      			bra	.put_plane0
  989    02:C841  05 FC      	.set_plane0:	ora	<_cx + 0		; Set font bits in background.
  990    02:C843  9D 02 02   	.put_plane0:	sta	VDC_DL, x
  991                        	
  992    02:C846  B1 EC      			lda	[_bp], y		; Get font byte.
  993    02:C848  9F 00 06   			bbs1	<__temp, .set_plane1
  994    02:C84B  49 FF      	.clr_plane1:	eor	#$FF			; Clr font bits in background.
  995    02:C84D  25 FD      			and	<_cx + 1
  996    02:C84F  80 02      			bra	.put_plane1
  997    02:C851  05 FD      	.set_plane1:	ora	<_cx + 1		; Set font bits in background.
  998    02:C853  9D 03 02   	.put_plane1:	sta	VDC_DH, x
  999                        	
 1000    02:C856  C8         			iny
 1001    02:C857  C0 08      			cpy	#8
 1002    02:C859  90 DB      			bcc	.plane01
 1003                        	
 1004    02:C85B  C2         			cly
 1005                        	
 1006    02:C85C  B1 EC      	.plane23:	lda	[_bp], y		; Get font byte.
 1007    02:C85E  AF 00 06   			bbs2	<__temp, .set_plane2
 1008    02:C861  49 FF      	.clr_plane2:	eor	#$FF			; Clr font bits in background.
 1009    02:C863  25 FE      			and	<_cx + 2
 1010    02:C865  80 02      			bra	.put_plane2
 1011    02:C867  05 FE      	.set_plane2:	ora	<_cx + 2		; Set font bits in background.
 1012    02:C869  9D 02 02   	.put_plane2:	sta	VDC_DL, x
 1013                        	
 1014    02:C86C  B1 EC      			lda	[_bp], y		; Get font byte.
 1015    02:C86E  BF 00 06   			bbs3	<__temp, .set_plane3
 1016    02:C871  49 FF      	.clr_plane3:	eor	#$FF			; Clr font bits in background.
 1017    02:C873  25 FF      			and	<_cx + 3
 1018    02:C875  80 02      			bra	.put_plane3
 1019    02:C877  05 FF      	.set_plane3:	ora	<_cx + 3		; Set font bits in background.
 1020    02:C879  9D 03 02   	.put_plane3:	sta	VDC_DH, x
 1021                        	
 1022    02:C87C  C8         			iny
 1023    02:C87D  C0 08      			cpy	#8
 1024    02:C87F  90 DB      			bcc	.plane23
 1025                        	
 1026    02:C881  A5 EC      			lda.l	<_bp
 1027    02:C883  69 07      			adc	#8-1
 1028    02:C885  85 EC      			sta.l	<_bp
 1029    02:C887  90 02      			bcc	!+
 1030    02:C889  E6 ED      			inc.h	<_bp
 1031                        	
 1032    02:C88B  C6 F8      	!:		dec	<_al
 1033    02:C88D  D0 A6      			bne	.tile_loop
 1034                        	
 1035                        			leave				; All done, phew!
         02:C88F  4C EF FF   			jmp	leave_proc
 1036                        	
 1037    02:C892             	.font:		incbin	"data/font8x8-bold-short-iso646-fr.dat", 128
 1038                        	
 1039                        			.endp
 1040                        	
 1041                        	
 1042                        	
 1043                        	; ***************************************************************************
 1044                        	; ***************************************************************************
 1045                        	;
 1046                        	; HuC Text Output
 1047                        	;
 1048                        	; ***************************************************************************
 1049                        	; ***************************************************************************
 1050                        	
 1051                        	
 1052                        	
 1053    11:C26F             	vdc_tty_out	.procgroup			; These routines share code!
 1054                        	
 1055                        	; ***************************************************************************
 1056                        	; ***************************************************************************
 1057                        	;
 1058                        	; void __fastcall put_char( unsigned char digit<_bl>, unsigned char bat_x<_dil>, unsigned char bat_y<_dih> );
 1059                        	
 1060               0001     		.if	SUPPORT_SGX
 1061                        	put_char_sgx	.proc
 1067                        			.endp
 1068                        		.endif
 1069                        	
 1070    11:C26F             	put_char_vdc	.proc
 1071                        	
 1072    11:C26F  82         			clx				; Offset to PCE VDC.
 1073                        	
 1074    11:C270  20 34 E4   			jsr	set_di_xy_mawr
 1075                        	
 1076    11:C273  62         			cla				; Push EOL marker.
 1077    11:C274  48         			pha
 1078                        	
 1079    11:C275  A5 FA      			lda	<_bl
 1080    11:C277  48         			pha				; Push character to output.
 1081    11:C278  80 58      			bra	!output+
 1082                        	
 1083    11:C27A             			.ref	put_hex_vdc		; Need put_number_vdc
 1084                        			.endp
 1085                        	
 1086    11:C27A             			.alias	_put_char.3		= put_char_vdc
 1087                        	
 1088                        	
 1089                        	
 1090                        	; ***************************************************************************
 1091                        	; ***************************************************************************
 1092                        	;
 1093                        	; void __fastcall put_digit( unsigned char digit<_bl>, unsigned char bat_x<_dil>, unsigned char bat_y<_dih> );
 1094                        	
 1095               0001     		.if	SUPPORT_SGX
 1096                        	put_digit_sgx	.proc
 1102                        			.endp
 1103                        		.endif
 1104                        	
 1105    11:C27A             	put_digit_vdc	.proc
 1106                        	
 1107    11:C27A  82         			clx				; Offset to PCE VDC.
 1108                        	
 1109    11:C27B  20 34 E4   			jsr	set_di_xy_mawr
 1110                        	
 1111    11:C27E  62         			cla				; Push EOL marker.
 1112    11:C27F  48         			pha
 1113                        	
 1114    11:C280  A5 FA      			lda	<_bl			; Convert hex digit to ASCII.
 1115    11:C282  29 0F      			and	#$0F
 1116    11:C284  C9 0A      			cmp	#10
 1117    11:C286  90 02      			bcc	!+
 1118    11:C288  69 06      			adc	#6
 1119    11:C28A  69 30      	!:		adc	#'0'
 1120    11:C28C  48         			pha				; Push character to output.
 1121    11:C28D  80 43      			bra	!output+
 1122                        	
 1123    11:C28F             			.ref	put_hex_vdc		; Need put_number_vdc
 1124                        			.endp
 1125                        	
 1126    11:C28F             			.alias	_put_digit.3		= put_digit_vdc
 1127                        	
 1128                        	
 1129                        	
 1130                        	; ***************************************************************************
 1131                        	; ***************************************************************************
 1132                        	;
 1133                        	; void __fastcall put_hex( unsigned int number<_bx>, unsigned char length<_cl>, unsigned char bat_x<_dil>, unsigned char bat_y<_dih> );
 1134                        	
 1135               0001     		.if	SUPPORT_SGX
 1136                        	put_hex_sgx	.proc
 1141                        			.endp
 1142                        		.endif
 1143                        	
 1144    11:C28F             	put_hex_vdc	.proc
 1145                        	
 1146    11:C28F  82         			clx				; Offset to PCE VDC.
 1147                        	
 1148    11:C290  20 34 E4   			jsr	set_di_xy_mawr
 1149                        	
 1150    11:C293  A4 FC      			ldy	<_cl			; Total #characters to print,
 1151    11:C295  F0 3E      			beq	!exit+			; NOT minimum #characters!
 1152                        	
 1153    11:C297  86 00      			stx	<__temp			; Preserve which VDC.
 1154                        	
 1155    11:C299  82         			clx				; Push EOL marker.
 1156    11:C29A  DA         			phx
 1157                        	
 1158    11:C29B  B5 FA      	.hex_byte:	lda.l	<_bx, x			; Convert hex digit to ASCII.
 1159    11:C29D  29 0F      			and	#$0F
 1160    11:C29F  C9 0A      			cmp	#10
 1161    11:C2A1  90 02      			bcc	!+
 1162    11:C2A3  69 06      			adc	#6
 1163    11:C2A5  69 30      	!:		adc	#'0'
 1164    11:C2A7  48         			pha				; Push character to output.
 1165    11:C2A8  88         			dey
 1166    11:C2A9  F0 15      			beq	.hex_done
 1167                        	
 1168    11:C2AB  B5 FA      			lda.l	<_bx, x			; Convert hex digit to ASCII.
 1169    11:C2AD  4A         			lsr	a
 1170    11:C2AE  4A         			lsr	a
 1171    11:C2AF  4A         			lsr	a
 1172    11:C2B0  4A         			lsr	a
 1173    11:C2B1  C9 0A      			cmp	#10
 1174    11:C2B3  90 02      			bcc	!+
 1175    11:C2B5  69 06      			adc	#6
 1176    11:C2B7  69 30      	!:		adc	#'0'
 1177    11:C2B9  48         			pha				; Push character to output.
 1178    11:C2BA  88         			dey
 1179    11:C2BB  F0 03      			beq	.hex_done
 1180                        	
 1181    11:C2BD  E8         			inx
 1182    11:C2BE  80 DB      			bra	.hex_byte
 1183                        	
 1184    11:C2C0  A6 00      	.hex_done:	ldx	<__temp			; Restore which VDC.
 1185    11:C2C2  80 0E      			bra	!output+
 1186                        	
 1187    11:C2C4  18         	.write:		clc
 1188    11:C2C5  7D 8B 26   			adc.l	_vdc_font_base, x
 1189    11:C2C8  9D 02 02   			sta	VDC_DL, x
 1190    11:C2CB  62         			cla
 1191    11:C2CC  7D 8C 26   			adc.h	_vdc_font_base, x
 1192    11:C2CF  9D 03 02   			sta	VDC_DH, x
 1193                        	
 1194    11:C2D2  68         	!output:	pla				; Pop the digits and output.
 1195    11:C2D3  D0 EF      			bne	.write
 1196                        	
 1197                        	!exit:		leave				; All done!
         11:C2D5  4C EF FF   			jmp	leave_proc
 1198                        	
 1199                        			.endp
 1200                        	
 1201    11:C2D8             			.alias	_put_hex.4 = put_hex_vdc
 1202                        	
 1203                        	
 1204                        	
 1205                        	; ***************************************************************************
 1206                        	; ***************************************************************************
 1207                        	;
 1208                        	; void __fastcall put_number( unsigned int number<_bx>, unsigned char length<_cl>, unsigned char bat_x<_dil>, unsigned char bat_y<_dih> );
 1209                        	
 1210               0001     		.if	SUPPORT_SGX
 1211                        	put_number_sgx	.proc
 1216                        			.endp
 1217                        		.endif
 1218                        	
 1219    11:C2D8             	put_number_vdc	.proc
 1220                        	
 1221    11:C2D8  82         			clx				; Offset to PCE VDC.
 1222                        	
 1223    11:C2D9  20 34 E4   			jsr	set_di_xy_mawr
 1224                        	
 1225    11:C2DC  A4 FC      			ldy	<_cl			; Total #characters to print,
 1226    11:C2DE  F0 F5      			beq	!exit-			; NOT minimum #characters!
 1227                        	
 1228    11:C2E0  86 00      			stx	<__temp			; Preserve which VDC.
 1229                        	
 1230    11:C2E2  82         			clx				; Push EOL marker.
 1231    11:C2E3  DA         			phx
 1232                        	
 1233    11:C2E4  A6 FB      			ldx.h	<_bx			; Is the number -ve?
 1234    11:C2E6  86 FC      			stx	<_cl			; Remember this.
 1235    11:C2E8  10 10      			bpl	.divide_by_ten
 1236                        	
 1237    11:C2EA  38         			sec				; Make the number +ve.
 1238    11:C2EB  A5 FA      			lda.l	<_bx
 1239    11:C2ED  49 FF      			eor	#$FF
 1240    11:C2EF  69 00      			adc	#0
 1241    11:C2F1  85 FA      			sta.l	<_bx
 1242    11:C2F3  8A         			txa
 1243    11:C2F4  49 FF      			eor	#$FF
 1244    11:C2F6  69 00      			adc	#0
 1245    11:C2F8  85 FB      			sta.h	<_bx
 1246                        	
 1247    11:C2FA  A2 10      	.divide_by_ten:	ldx	#16
 1248    11:C2FC  62         			cla				; Clear Remainder.
 1249    11:C2FD  06 FA      			asl.l	<_bx			; Rotate Dividend, MSB -> C.
 1250    11:C2FF  26 FB      			rol.h	<_bx
 1251    11:C301  2A         	.divide_loop:	rol	a			; Rotate C into Remainder.
 1252    11:C302  C9 0A      			cmp	#10			; Test Divisor.
 1253    11:C304  90 02      			bcc	.divide_less		; CC if Divisor > Remainder.
 1254    11:C306  E9 0A      			sbc	#10			; Subtract Divisor.
 1255    11:C308  26 FA      	.divide_less:	rol.l	<_bx			; Quotient bit -> Dividend LSB.
 1256    11:C30A  26 FB      			rol.h	<_bx			; Rotate Dividend, MSB -> C.
 1257    11:C30C  CA         			dex
 1258    11:C30D  D0 F2      			bne	.divide_loop
 1259                        	
 1260    11:C30F  18         			clc
 1261    11:C310  69 30      			adc	#'0'			; Always leaves C clr.
 1262    11:C312  48         			pha				; Push character to output.
 1263    11:C313  88         			dey
 1264    11:C314  F0 10      			beq	!pad+
 1265    11:C316  A5 FA      			lda.l	<_bx			; Repeat while non-zero.
 1266    11:C318  05 FB      			ora.h	<_bx
 1267    11:C31A  D0 DE      			bne	.divide_by_ten
 1268                        	
 1269    11:C31C  A6 00      			ldx	<__temp			; Restore which VDC.
 1270                        	
 1271    11:C31E  A5 FC      			lda	<_cl			; Was the number -ve?
 1272    11:C320  10 04      			bpl	!pad+
 1273    11:C322  A9 2D      			lda	#'-'			; Output a leading '-'.
 1274    11:C324  48         			pha
 1275    11:C325  88         			dey
 1276                        	
 1277    11:C326  A9 20      	!pad:		lda	#' '			; Add padding characters.
 1278    11:C328  88         	.loop:		dey
 1279    11:C329  30 A7      			bmi	!output-
 1280    11:C32B  48         			pha
 1281    11:C32C  80 FA      			bra	.loop
 1282                        	
 1283    11:C32E             			.ref	put_hex_vdc		; Need put_number_vdc
 1284                        	
 1285                        			.endp
 1286                        	
 1287    11:C32E             			.alias	_put_number.4 = put_number_vdc
 1288                        	
 1289                        	
 1290                        	
 1291                        	; ***************************************************************************
 1292                        	; ***************************************************************************
 1293                        	;
 1294                        	; void __fastcall put_raw( unsigned int data<_bx>, unsigned char bat_x<_dil>, unsigned char bat_y<_dih> );
 1295                        	
 1296               0001     		.if	SUPPORT_SGX
 1297                        	put_raw_sgx	.proc
 1302                        			.endp
 1303                        		.endif
 1304                        	
 1305                        	put_raw_vdc	.proc
 1318                        			.endp
 1319                        	
 1320    11:C32E             			.alias	_put_raw.3		= put_raw_vdc
 1321                        	
 1322                        			.endprocgroup			; vdc_tty_out
 1323                        	
 1324                        	
 1325                        	
 1326                        	; ***************************************************************************
 1327                        	; ***************************************************************************
 1328                        	;
 1329                        	; void __fastcall put_string( unsigned char *string<_bp>, unsigned char bat_x<_dil>, unsigned char bat_y<_dih> );
 1330                        	;
 1331                        	; N.B. This is not a .proc right now because it is called from procedures
 1332                        	; that contain embedded strings, and the string aren't banked in before
 1333                        	; printing (yet).
 1334                        	
 1335               0001     		.if	SUPPORT_SGX
 1336    00:E665             	_sgx_put_string.3:
 1337    00:E665  A2 10      			ldx	#SGX_VDC_OFFSET		; Offset to SGX VDC.
 1338    00:E667  F0         			db	$F0			; Turn "clx" into a "beq".
 1339                        		.endif
 1340                        	
 1341    00:E668  82         	_put_string.3:	clx				; Offset to PCE VDC.
 1342                        	
 1343    00:E669  20 34 E4   			jsr	set_di_xy_mawr
 1344                        	
 1345    00:E66C  C2         			cly
 1346    00:E66D  B1 EC      	.chr_loop:	lda	[_bp], y
 1347    00:E66F  F0 15      			beq	.done
 1348                        	
 1349    00:E671  18         			clc
 1350    00:E672  7D 8B 26   			adc.l	_vdc_font_base, x
 1351    00:E675  9D 02 02   			sta	VDC_DL, x
 1352    00:E678  62         			cla
 1353    00:E679  7D 8C 26   			adc.h	_vdc_font_base, x
 1354    00:E67C  9D 03 02   			sta	VDC_DH, x
 1355                        	
 1356    00:E67F  C8         			iny
 1357    00:E680  D0 EB      			bne	.chr_loop
 1358    00:E682  E6 ED      			inc.h	<_bp
 1359    00:E684  80 E7      			bra	.chr_loop
 1360                        	
 1361    00:E686  60         	.done:		rts
 1362                        	
 1363                        	
 1364                        	
 1365                        	; ***************************************************************************
 1366                        	; ***************************************************************************
 1367                        	;
 1368                        	; void __fastcall set_color_rgb( unsigned int index<VCE_CTA>, unsigned char r<_al>, unsigned char g<_ah>, unsigned char b<acc> );
 1369                        	;
 1370                        	; r:	red	RED:	bit 3-5
 1371                        	; g:	green	GREEN:	bit 6-8
 1372                        	; b:	blue	BLUE:	bit 0-2
 1373                        	
 1374    00:E687             	_set_color_rgb.4:
 1375                        	;		and	#7
 1376    00:E687  85 00      			sta	<__temp
 1377    00:E689  A5 F8      			lda	<_al
 1378                        	;		and	#7
 1379    00:E68B  0A         			asl	a
 1380    00:E68C  0A         			asl	a
 1381    00:E68D  0A         			asl	a
 1382    00:E68E  05 00      			ora	<__temp
 1383    00:E690  0A         			asl	a
 1384    00:E691  0A         			asl	a
 1385    00:E692  85 00      			sta	<__temp
 1386    00:E694  A5 F9      			lda	<_ah
 1387                        	;		and	#7
 1388    00:E696  4A         			lsr	a
 1389    00:E697  66 00      			ror	<__temp
 1390    00:E699  4A         			lsr	a
 1391    00:E69A  66 00      			ror	<__temp
 1392    00:E69C  A8         			tay
 1393    00:E69D  A5 00      			lda	<__temp
 1394    00:E69F  8D 04 04   			sta.l	VCE_CTW
 1395    00:E6A2  8C 05 04   			sty.h	VCE_CTW
 1396    00:E6A5  60         			rts
                             #[2]   "..\..\..\include\hucc\hucc-final.asm"
   60                        		.endif
   61                        	
   62               0001     		.ifdef	HUCC_USES_STRING		; Set in hucc_string.h
                             #[3]   "..\..\..\include\hucc\hucc-string.asm"
   63                        			include	"hucc-string.asm"
    1                        	; ***************************************************************************
    2                        	; ***************************************************************************
    3                        	;
    4                        	; hucc-string.asm
    5                        	;
    6                        	; Not-quite-standard, but fast, replacements for <string.h>.
    7                        	;
    8                        	; Copyright John Brandwood 2024.
    9                        	;
   10                        	; Distributed under the Boost Software License, Version 1.0.
   11                        	; (See accompanying file LICENSE_1_0.txt or copy at
   12                        	;  http://www.boost.org/LICENSE_1_0.txt)
   13                        	;
   14                        	; ***************************************************************************
   15                        	; ***************************************************************************
   16                        	;
   17                        	; !!! WARNING : non-standard return values !!!
   18                        	;
   19                        	; Strings are limited to a maximum of 255 characters (+ the terminator)!
   20                        	;
   21                        	; The memcpy(), strcpy() and strcat() functions do NOT return the destination
   22                        	; address, and they are declared "void" to check that the value is not used.
   23                        	;
   24                        	; mempcpy() is provided which returns the end address instead of the starting
   25                        	; address, because this is typically more useful.
   26                        	;
   27                        	; Please note that both memcpy() and memset() are implemented using a TII for
   28                        	; speed, and so the length should be < 16 bytes if used in time-critical bits
   29                        	; of code (such as when using a split screen) because they delay interrupts.
   30                        	;
   31                        	; strncpy() and strncat() are not provided, because strncpy() was not created
   32                        	; for the purpose of avoiding string overruns, and strncat() is just a poorly
   33                        	; designed function.
   34                        	;
   35                        	; POSIX strlcpy() and strlcat() are provided instead, but once again they are
   36                        	; slightly non-standard in that the return value when there is an overflow is
   37                        	; the buffer size (so that the overflow can be detected), instead of the full
   38                        	; size of the destination string that was too big to fit in the buffer.
   39                        	;
   40                        	; ***************************************************************************
   41                        	; ***************************************************************************
   42                        	
   43                        	
   44                        	
   45                        	; ***************************************************************************
   46                        	; ***************************************************************************
   47                        	;
   48                        	; void __fastcall strcpy( char *destination<_di>, char *source<_bp> );
   49                        	; void __fastcall strcat( char *destination<_di>, char *source<_bp> );
   50                        	;
   51                        	; unsigned int __fastcall strlcpy( char *destination<_di>, char *source<_bp>, unsigned char size<acc> );
   52                        	; unsigned int __fastcall strlcat( char *destination<_di>, char *source<_bp>, unsigned char size<acc> );
   53                        	; unsigned int __fastcall strlen( char *source<_bp> );
   54                        	;
   55                        	; NOT WORKING YET (needs compiler changes) ...
   56                        	;
   57                        	; void __fastcall strcpy( char *destination<_di>, char __far *source<_bp_bank:_bp> );
   58                        	; void __fastcall strcat( char *destination<_di>, char __far *source<_bp_bank:_bp> );
   59                        	;
   60                        	; unsigned int __fastcall strlcpy( char *destination<_di>, char __far *source<_bp_bank:_bp>, unsigned char size<acc> );
   61                        	; unsigned int __fastcall strlcat( char *destination<_di>, char __far *source<_bp_bank:_bp>, unsigned char size<acc> );
   62                        	; unsigned int __fastcall strlen( char __far *source<_bp_bank:_bp> );
   63                        	
   64    00:E6A6  62         	_strcat:	cla				; Max string length == 256!
   65    00:E6A7  A0 01      			ldy.h	#256
   66                        	
   67    00:E6A9  AA         	_strlcat:	tax				; X = buffer length (1..256).
   68                        	
   69               0000     		.ifdef	_DEBUG
   74                        		.endif
   75                        	
   76    00:E6AA  43 08      			tma3				; Preserve MPR3 and MPR4.
   77    00:E6AC  48         			pha
   78    00:E6AD  43 10      			tma4
   79    00:E6AF  48         			pha
   80                        	
   81                        	;		ldy	<_bp_bank		; Map the source string.
   82                        	;		beq	.no_bank
   83                        	;		jsr	map_bp_to_mpr34
   84                        	
   85    00:E6B0  C2         	.no_bank:	cly
   86                        	
   87    00:E6B1  B1 F0      	.find:		lda	[_di], y		; Find the end of the string.
   88    00:E6B3  F0 08      			beq	.adjust
   89    00:E6B5  C8         			iny
   90    00:E6B6  CA         			dex
   91    00:E6B7  D0 F8      			bne	.find
   92    00:E6B9  98         			tya				; A:Y = buffer length.
   93    00:E6BA  62         			cla
   94    00:E6BB  80 28      			bra	str_overflow
   95                        	
   96    00:E6BD  98         	.adjust:	tya				; Subtract Y from _bp so that
   97    00:E6BE  49 FF      			eor	#$FF			; _bp and _di use the same Y.
   98    00:E6C0  38         			sec
   99    00:E6C1  65 EC      			adc.l	<_bp
  100    00:E6C3  85 EC      			sta.l	<_bp
  101    00:E6C5  B0 0F      			bcs	str_copy
  102    00:E6C7  C6 ED      			dec.h	<_bp
  103    00:E6C9  80 0B      			bra	str_copy
  104                        	
  105                        			;
  106                        	
  107    00:E6CB  62         	_strcpy:	cla				; Max string length == 256!
  108    00:E6CC  A0 01      			ldy.h	#256
  109                        	
  110    00:E6CE  AA         	_strlcpy:	tax				; X = buffer length (1..256).
  111                        	
  112               0000     		.ifdef	_DEBUG
  117                        		.endif
  118                        	
  119    00:E6CF  43 08      			tma3				; Preserve MPR3 and MPR4.
  120    00:E6D1  48         			pha
  121    00:E6D2  43 10      			tma4
  122    00:E6D4  48         			pha
  123                        	
  124                        	;		ldy	<_bp_bank		; Map the source string.
  125                        	;		beq	.no_bank
  126                        	;		jsr	map_bp_to_mpr34
  127                        	
  128    00:E6D5  C2         	.no_bank:	cly
  129                        	
  130    00:E6D6  B1 EC      	str_copy:	lda	[_bp], y
  131    00:E6D8  91 F0      			sta	[_di], y
  132    00:E6DA  F0 1E      			beq	str_exit		; A:Y = string length.
  133    00:E6DC  C8         			iny
  134    00:E6DD  CA         			dex
  135    00:E6DE  D0 F6      			bne	str_copy
  136                        	
  137    00:E6E0  88         			dey
  138    00:E6E1  62         			cla
  139    00:E6E2  91 F0      			sta	[_di], y
  140    00:E6E4  C8         			iny				; A:Y = buffer length.
  141    00:E6E5  D0 13      	str_overflow:	bne	str_exit
  142    00:E6E7  1A         			inc	a			; A:Y = buffer length = 256.
  143    00:E6E8  80 10      			bra	str_exit
  144                        	
  145                        			;
  146                        	
  147    00:E6EA  43 08      	_strlen:	tma3
  148    00:E6EC  48         			pha
  149    00:E6ED  43 10      			tma4
  150    00:E6EF  48         			pha
  151                        	
  152                        	;		ldy	<_bp_bank
  153                        	;		beq	.no_bank
  154                        	;		jsr	map_bp_to_mpr34
  155                        	
  156    00:E6F0  C2         	.no_bank:	cly
  157                        	
  158    00:E6F1  B1 EC      	.find:		lda	[_bp], y
  159    00:E6F3  F0 05      			beq	str_exit
  160    00:E6F5  C8         			iny
  161    00:E6F6  D0 F9      			bne	.find
  162    00:E6F8  A9 01      			lda.h	#256			; A:Y = overflow length = 256.
  163                        	
  164    00:E6FA  AA         	str_exit:	tax				; X:Y = string or buffer length.
  165                        	
  166    00:E6FB  68         			pla				; Restore MPR3 and MPR4.
  167    00:E6FC  53 10      			tam4
  168    00:E6FE  68         			pla
  169    00:E6FF  53 08      			tam3
  170                        	
  171    00:E701  8A         			txa				; A:Y = string or buffer length.
  172    00:E702  42         			say				; Y:A = string or buffer length.
  173                        	
  174    00:E703  60         			rts
  175                        	
  176    00:E704             			.alias	_strlen.1		= _strlen
  177    00:E704             			.alias	_strcpy.2		= _strcpy
  178    00:E704             			.alias	_strcat.2		= _strcat
  179    00:E704             			.alias	_strlcpy.3		= _strlcpy
  180    00:E704             			.alias	_strlcat.3		= _strlcat
  181                        	
  182                        	
  183                        	
  184                        	; ***************************************************************************
  185                        	; ***************************************************************************
  186                        	;
  187                        	; void __fastcall memcpy( unsigned char *destination<ram_tii_dst>, unsigned char  *source<ram_tii_src>, unsigned int count<acc> );
  188                        	; unsigned char * __fastcall mempcpy( unsigned char *destination<ram_tii_dst>, unsigned char  *source<ram_tii_src>, unsigned int count<acc> );
  189                        	;
  190                        	; void __fastcall farmemcpy( unsigned char *destination<ram_tii_dst>, unsigned char __far *source<_bp_bank:ram_tii_src>, unsigned int count<acc> );
  191                        	; unsigned char * __fastcall farmempcpy( unsigned char *destination<ram_tii_dst>, unsigned char __far *source<_bp_bank:ram_tii_src>, unsigned int count<acc> );
  192                        	;
  193                        	; void __fastcall far_memcpy( unsigned char *destination<ram_tii_dst>, unsigned int count<acc> );
  194                        	; unsigned char * __fastcall far_mempcpy( unsigned char *destination<ram_tii_dst>, unsigned int count<acc> );
  195                        	;
  196                        	
  197    00:E704             	_memcpy.3:
  198    00:E704  64 02      	_mempcpy.3:	stz	<_bp_bank		; Map the source memory.
  199                        	
  200    00:E706             	_farmemcpy.3:
  201    00:E706  8C FE 22   	_farmempcpy.3:	sty.h	ram_tii_len		; Check for zero length.
  202    00:E709  8D FD 22   			sta.l	ram_tii_len
  203    00:E70C  0D FE 22   			ora.h	ram_tii_len
  204    00:E70F  F0 18      			beq	.zero_length
  205                        	
  206    00:E711  43 08      			tma3				; Preserve MPR3 and MPR4.
  207    00:E713  48         			pha
  208    00:E714  43 10      			tma4
  209    00:E716  48         			pha
  210                        	
  211    00:E717  A5 02      			lda	<_bp_bank		; Map the source memory.
  212    00:E719  F0 05      			beq	.no_bank
  213                        	
  214    00:E71B  53 08      			tam3				; Put bank into MPR3.
  215    00:E71D  1A         			inc	a
  216    00:E71E  53 10      			tam4				; Put next into MPR4.
  217                        	
  218                        	;		lda.h	ram_tii_src		; Remap ptr to MPR3.
  219                        	;		and	#$1F
  220                        	;		ora	#$60
  221                        	;		sta.h	ram_tii_src
  222                        	
  223    00:E720  20 F8 22   	.no_bank:	jsr	ram_tii			; Copy the memory.
  224                        	
  225    00:E723  68         			pla				; Restore MPR3 and MPR4.
  226    00:E724  53 10      			tam4
  227    00:E726  68         			pla
  228    00:E727  53 08      			tam3
  229                        	
  230    00:E729  18         	.zero_length:	clc				; Return the end address
  231    00:E72A  AD FB 22   			lda.l	ram_tii_dst		; like mempcpy().
  232    00:E72D  6D FD 22   			adc.l	ram_tii_len
  233    00:E730  A8         			tay
  234    00:E731  AD FC 22   			lda.h	ram_tii_dst
  235    00:E734  6D FE 22   			adc.h	ram_tii_len
  236    00:E737  42         			say
  237                        	
  238    00:E738  60         			rts
  239                        	
  240    00:E739             			.alias	_far_memcpy.2		= _farmemcpy.3
  241    00:E739             			.alias	_far_mempcpy.2		= _farmempcpy.3
  242                        	
  243                        	
  244                        	
  245                        	; ***************************************************************************
  246                        	; ***************************************************************************
  247                        	;
  248                        	; void __fastcall memset( unsigned char *destination<ram_tii_src>, unsigned char value<_al>, unsigned int count<acc> );
  249                        	
  250    00:E739  C9 00      	_memset:	cmp	#0			; Decrement the length, check
  251    00:E73B  D0 05      			bne	!+			; for zero and set C. 
  252    00:E73D  C0 00      			cpy	#0
  253    00:E73F  F0 23      			beq	.zero_length
  254    00:E741  88         			dey
  255    00:E742  3A         	!:		dec	a
  256    00:E743  8D FD 22   			sta.l	ram_tii_len
  257    00:E746  8C FE 22   			sty.h	ram_tii_len
  258                        	
  259    00:E749  AD F9 22   			lda.l	ram_tii_src		; ram_tii_dst = ram_tii_src + 1
  260    00:E74C  85 88      			sta.l	<__ptr
  261    00:E74E  69 00      			adc	#0
  262    00:E750  8D FB 22   			sta.l	ram_tii_dst
  263    00:E753  AD FA 22   			lda.h	ram_tii_src
  264    00:E756  85 89      			sta.h	<__ptr
  265    00:E758  69 00      			adc	#0
  266    00:E75A  8D FC 22   			sta.h	ram_tii_dst
  267                        	
  268    00:E75D  A5 F8      			lda	<_al			; Set the fill value.
  269    00:E75F  92 88      			sta	[__ptr]
  270                        	
  271    00:E761  4C F8 22   			jmp	ram_tii			; Copy the memory.
  272                        	
  273    00:E764  60         	.zero_length:	rts
  274                        	
  275    00:E765             			.alias	_memset.3		= _memset
  276                        	
  277                        	
  278                        	
  279                        	; ***************************************************************************
  280                        	; ***************************************************************************
  281                        	;
  282                        	; int __fastcall strcmp( char *string1<_di>, char *string2<_bp> );
  283                        	; int __fastcall strncmp( char *string1<_di>, char *string2<_bp>, unsigned int count<_ax> );
  284                        	;
  285                        	; int __fastcall __macro memcmp( unsigned char *string1<_di>, unsigned char *string2<_bp>, unsigned int count<_ax> );
  286                        	; int __fastcall farmemcmp( unsigned char *string1<_di>, unsigned char __far *string2<_bp_bank:_bp>, unsigned int count<_ax> );
  287                        	; int __fastcall far_memcmp( unsigned char *string1<_di>, unsigned int count<_ax> );
  288                        	;
  289                        	;  0 	if strings are equal
  290                        	;  1 	if the first non-matching character in string1 > string2 (in ASCII).
  291                        	; -1 	if the first non-matching character in string1 < string2 (in ASCII).
  292                        	
  293    02:DFAA             	hucc_memcmp	.procgroup
  294                        	
  295                        	_strcmp.2	.proc
  300                        			.endp				; Fall through.
  301                        	
  302    02:DFAA             	_strncmp.3	.proc
  303    02:DFAA  64 02      			stz	<_bp_bank		; Assume strings are mapped.
  304    02:DFAC  89 40      			bit	#$40			; Set the V bit for strcmp.
  305    02:DFAE  50         			db	$50			; Turn "clv" into "bvc".
  306    02:DFAF             			.ref	_farmemcmp.3		; Don't strip _farmemcmp.3!
  307                        			.endp				; Fall through.
  308                        	
  309    02:DFAF             	_farmemcmp.3	.proc
  310    02:DFAF  B8         			clv				; Clr the V bit for memcmp.
  311                        	
  312    02:DFB0  43 08      			tma3				; Preserve MPR3 and MPR4.
  313    02:DFB2  48         			pha
  314    02:DFB3  43 10      			tma4
  315    02:DFB5  48         			pha
  316                        	
  317    02:DFB6  A4 02      			ldy	<_bp_bank		; Map string2.
  318    02:DFB8  F0 03      			beq	.no_bank
  319                        	
  320    02:DFBA  20 3B E3   			jsr	map_bp_to_mpr34
  321                        	
  322    02:DFBD  C2         	.no_bank:	cly
  323                        	
  324    02:DFBE  A6 F8      			ldx.l	<_ax			; Increment length.l
  325    02:DFC0  E8         			inx
  326    02:DFC1  CA         	.loop:		dex				; Decrement length.l
  327    02:DFC2  F0 17      			beq	.page
  328    02:DFC4  B1 F0      	.test:		lda	[_di], y		; string1 - string2
  329    02:DFC6  D1 EC      			cmp	[_bp], y
  330    02:DFC8  90 1E      			bcc	.return_neg		; string1 < string2 
  331    02:DFCA  D0 17      			bne	.return_pos		; string1 > string2
  332    02:DFCC  50 04      			bvc	!+			; Only check for end-of-string
  333    02:DFCE  C9 00      			cmp	#0			; if the V flag is set.
  334    02:DFD0  F0 0D      			beq	.return_same
  335    02:DFD2  C8         	!:		iny
  336    02:DFD3  D0 EC      			bne	.loop
  337    02:DFD5  E6 F1      			inc.h	<_di
  338    02:DFD7  E6 ED      			inc.h	<_bp			; Limited to 8KB maximum!
  339                        	;		jsr	inc.h_bp_mpr34
  340    02:DFD9  80 E6      			bra	.loop
  341                        	
  342    02:DFDB  C6 F9      	.page:		dec.h	<_ax			; Decrement length.h 
  343    02:DFDD  10 E5      			bpl	.test			; Limit comparison to 32KB.
  344                        	;		bra	cmp_same
  345                        	
  346    02:DFDF  82         	.return_same:	clx				; Return code in Y:X, X -> A.
  347    02:DFE0  C2         			cly
  348    02:DFE1  80 09      			bra	!+
  349                        	
  350    02:DFE3  A2 01      	.return_pos:	ldx	#$01			; Return code in Y:X, X -> A.
  351    02:DFE5  C2         			cly
  352    02:DFE6  80 04      			bra	!+
  353                        	
  354    02:DFE8  A2 FF      	.return_neg:	ldx	#$FF			; Return code in Y:X, X -> A.
  355    02:DFEA  A0 FF      			ldy	#$FF
  356                        	
  357    02:DFEC  68         	!:		pla				; Restore MPR3 and MPR4.
  358    02:DFED  53 10      			tam4
  359    02:DFEF  68         			pla
  360    02:DFF0  53 08      			tam3
  361                        	
  362                        			leave				; Return and copy X -> A.
         02:DFF2  4C EF FF   			jmp	leave_proc
  363                        	
  364                        			.endp
  365                        	
  366                        			.endprocgroup			; hucc_memcmp
  367                        	
  368    00:E765             			.alias	_far_memcmp.2		= _farmemcmp.3
                             #[2]   "..\..\..\include\hucc\hucc-final.asm"
   64                        		.endif
   65                        	
   66               0001     		.ifdef	HUCC_USES_NEW_SCROLL		; Set in hucc_scroll.h
                             #[3]   "..\..\..\include\hucc\hucc-scroll.asm"
   67                        			include	"hucc-scroll.asm"
    1                        	; ***************************************************************************
    2                        	; ***************************************************************************
    3                        	;
    4                        	; hucc-scroll.asm
    5                        	;
    6                        	; Routines for a fast split-screen scrolling system.
    7                        	;
    8                        	; Copyright John Brandwood 2024.
    9                        	;
   10                        	; Distributed under the Boost Software License, Version 1.0.
   11                        	; (See accompanying file LICENSE_1_0.txt or copy at
   12                        	;  http://www.boost.org/LICENSE_1_0.txt)
   13                        	;
   14                        	; ***************************************************************************
   15                        	; ***************************************************************************
   16                        	;
   17                        	; The maximum number of splits for each screen layer is set in your project's
   18                        	; "hucc-config.inc" file, with the library having a limit of 128-per-layer.
   19                        	;
   20                        	; Your first active split must be defined to start at screen line 0, and then
   21                        	; the rest of the active splits must be in increasing line order to match the
   22                        	; way that the PC Engine displays the output image.
   23                        	;
   24                        	; You can have disabled splits interleaved with your active splits.
   25                        	;
   26                        	; Splits that are normally disabled can be used to create full screen effects
   27                        	; such as bouncing the screen up and down by adding blank areas at the top or
   28                        	; bottom of the screen, and then rapidly changing the height of those areas.
   29                        	;
   30                        	; ***************************************************************************
   31                        	; ***************************************************************************
   32                        	
   33                        	
   34                        	
   35               0000     		.ifndef	HUCC_PCE_SPLITS
   37                        		.endif
   38                        	
   39               0000     		.ifndef	HUCC_SGX_SPLITS
   41                        		.endif
   42                        	
   43               0000     		.if	(HUCC_PCE_SPLITS < 2) || (HUCC_PCE_SPLITS > 128)
   45                        		.endif
   46                        	
   47               0000     		.if	(HUCC_SGX_SPLITS < 2) || (HUCC_SGX_SPLITS > 128)
   49                        		.endif
   50                        	
   51               0144     	HUCC_1ST_RCR	=	$144
   52               00E0     	HUCC_SCR_HEIGHT	=	224
   53                        	
   54               E765     			.code
   55                        	
   56                        	
   57                        	
   58                        	; ***************************************************************************
   59                        	; ***************************************************************************
   60                        	;
   61                        	; void __fastcall scroll_split( unsigned char index<_al>, unsigned char screen_line<_ah>, unsigned int bat_x<_bx>, unsigned int bat_y<_cx>, unsigned char display_flags<_dl> );
   62                        	; void __fastcall sgx_scroll_split( unsigned char index<_al>, unsigned char screen_line<_ah>, unsigned int bat_x<_bx>, unsigned int bat_y<_cx>, unsigned char display_flags<_dl> );
   63                        	;
   64                        	; set screen scrolling
   65                        	
   66                        			.proc	_scroll_split.5
  143                        			.endp
  144                        	
  145               0001     		.if	SUPPORT_SGX
  146                        	
  147    11:C3CB             			.proc	_sgx_scroll_split.5
  148                        	
  149    11:C3CB  08         			php				; Disable interrupts while
  150    11:C3CC  78         			sei				; updating this structure.
  151                        	
  152    11:C3CD  A6 F8      			ldx	<_al			; Region number.
  153    11:C3CF  E0 08      			cpx	#HUCC_SGX_SPLITS
  154    11:C3D1  B0 FE      	.hang:		bcs	.hang			; Better a hang than a crash!
  155                        	
  156    11:C3D3  BD 24 27   			lda	sgx_region_sel, x	; Update the parameter copy
  157    11:C3D6  5D 2C 27   			eor	sgx_region_new, x	; that is not displayed now.
  158    11:C3D9  D0 3B      			bne	.regionA
  159                        	
  160    11:C3DB  A5 F9      	.regionB:	lda	<_ah			; Scanline (i.e. top).
  161    11:C3DD  C9 E0      			cmp	#HUCC_SCR_HEIGHT	; Skip if offscreen.
  162    11:C3DF  B0 31      			bcs	!done+
  163    11:C3E1  9D 4C 27   			sta	sgx_regionB_rcr, x
  164                        	
  165    11:C3E4  C9 00      			cmp	#0			; Either Y at top of the frame
  166    11:C3E6  F0 01      			beq	!+			; or Y-1 because the RCR code
  167    11:C3E8  18         			clc				; sets it on the line before.
  168    11:C3E9  A5 FC      	!:		lda.l	<_cx
  169    11:C3EB  E9 00      			sbc	#0
  170    11:C3ED  9D 7C 27   			sta	sgx_regionB_yl, x
  171    11:C3F0  A5 FD      			lda.h	<_cx
  172    11:C3F2  E9 00      			sbc	#0
  173    11:C3F4  9D 8C 27   			sta	sgx_regionB_yh, x
  174                        	
  175    11:C3F7  A5 FA      			lda.l	<_bx
  176    11:C3F9  9D 5C 27   			sta	sgx_regionB_xl, x
  177    11:C3FC  A5 FB      			lda.h	<_bx
  178    11:C3FE  9D 6C 27   			sta	sgx_regionB_xh, x
  179                        	
  180    11:C401  A5 FE      			lda	<_dl
  181    11:C403  29 C0      			and	#$C0			; Flags (mark it as enabled).
  182    11:C405  09 0C      			ora	#$0C
  183    11:C407  9D 3C 27   			sta	sgx_regionB_crl, x
  184                        	
  185    11:C40A  A9 01      			lda	#1			; Mark that we've changed the
  186    11:C40C  9D 2C 27   			sta	sgx_region_new, x	; selected region.
  187    11:C40F  9D 24 27   			sta	sgx_region_sel, x
  188                        	
  189    11:C412  28         	!done:		plp				; Restore interrupts.
  190                        			leave				; All done!
         11:C413  4C EF FF   			jmp	leave_proc
  191                        	
  192    11:C416  A5 F9      	.regionA:	lda	<_ah			; Scanline (i.e. top).
  193    11:C418  C9 E0      			cmp	#HUCC_SCR_HEIGHT	; Skip if offscreen.
  194    11:C41A  B0 31      			bcs	!done+
  195    11:C41C  9D 44 27   			sta	sgx_regionA_rcr, x
  196                        	
  197    11:C41F  C9 00      			cmp	#0			; Either Y at top of the frame
  198    11:C421  F0 01      			beq	!+			; or Y-1 because the RCR code
  199    11:C423  18         			clc				; sets it on the line before.
  200    11:C424  A5 FC      	!:		lda.l	<_cx
  201    11:C426  E9 00      			sbc	#0
  202    11:C428  9D 74 27   			sta	sgx_regionA_yl, x
  203    11:C42B  A5 FD      			lda.h	<_cx
  204    11:C42D  E9 00      			sbc	#0
  205    11:C42F  9D 84 27   			sta	sgx_regionA_yh, x
  206                        	
  207    11:C432  A5 FA      			lda.l	<_bx
  208    11:C434  9D 54 27   			sta	sgx_regionA_xl, x
  209    11:C437  A5 FB      			lda.h	<_bx
  210    11:C439  9D 64 27   			sta	sgx_regionA_xh, x
  211                        	
  212    11:C43C  A5 FE      			lda	<_dl
  213    11:C43E  29 C0      			and	#$C0			; Flags (mark it as enabled).
  214    11:C440  09 0C      			ora	#$0C
  215    11:C442  9D 34 27   			sta	sgx_regionA_crl, x
  216                        	
  217    11:C445  A9 01      			lda	#1			; Mark that we've changed the
  218    11:C447  9D 2C 27   			sta	sgx_region_new, x	; selected region.
  219    11:C44A  9E 24 27   			stz	sgx_region_sel, x
  220                        	
  221    11:C44D  28         	!done:		plp				; Restore interrupts.
  222                        			leave				; All done!
         11:C44E  4C EF FF   			jmp	leave_proc
  223                        	
  224                        			.endp
  225                        	
  226                        		.endif	SUPPORT_SGX
  227                        	
  228                        	
  229                        	
  230                        	; ***************************************************************************
  231                        	; ***************************************************************************
  232                        	;
  233                        	; void __fastcall disable_split( unsigned char index<acc> );
  234                        	; void __fastcall sgx_disable_split( unsigned char index<acc> );
  235                        	;
  236                        	; disable screen scrolling for a scroll region
  237                        	
  238    00:E765             	_disable_split.1:
  239    00:E765  08         			php				; Disable interrupts while
  240    00:E766  78         			sei				; updating this structure.
  241                        	
  242    00:E767  C9 08      			cmp	#HUCC_PCE_SPLITS	; Better a hang than a crash!
  243    00:E769  B0 FE      	.hang:		bcs	.hang
  244    00:E76B  AA         			tax
  245                        	
  246    00:E76C  BD A3 26   			lda	vdc_region_sel, x	; Update the parameter copy
  247    00:E76F  5D AB 26   			eor	vdc_region_new, x	; that is not displayed now.
  248    00:E772  D0 0D      			bne	.regionA
  249                        	
  250    00:E774  9E BB 26   	.regionB:	stz	vdc_regionB_crl, x	; Region disabled if $00.
  251                        	
  252    00:E777  A9 01      			lda	#1			; Mark that we've changed the
  253    00:E779  9D AB 26   			sta	vdc_region_new, x	; selected region.
  254    00:E77C  9D A3 26   			sta	vdc_region_sel, x
  255                        	
  256    00:E77F  28         			plp				; Restore interrupts.
  257    00:E780  60         			rts
  258                        	
  259    00:E781  9E B3 26   	.regionA:	stz	vdc_regionA_crl, x	; Region disabled if $00.
  260                        	
  261    00:E784  A9 01      			lda	#1			; Mark that we've changed the
  262    00:E786  9D AB 26   			sta	vdc_region_new, x	; selected region.
  263    00:E789  9E A3 26   			stz	vdc_region_sel, x
  264                        	
  265    00:E78C  28         			plp				; Restore interrupts.
  266    00:E78D  60         			rts
  267                        	
  268               0001     		.if	SUPPORT_SGX
  269                        	
  270    00:E78E             	_sgx_disable_split.1:
  271    00:E78E  08         			php				; Disable interrupts while
  272    00:E78F  78         			sei				; updating this structure.
  273                        	
  274    00:E790  C9 08      			cmp	#HUCC_SGX_SPLITS	; Better a hang than a crash!
  275    00:E792  B0 FE      	.hang:		bcs	.hang
  276    00:E794  AA         			tax
  277                        	
  278    00:E795  BD 24 27   			lda	sgx_region_sel, x	; Update the parameter copy
  279    00:E798  5D 2C 27   			eor	sgx_region_new, x	; that is not displayed now.
  280    00:E79B  D0 0D      			bne	.regionA
  281                        	
  282    00:E79D  9E 3C 27   	.regionB:	stz	sgx_regionB_crl, x	; Region disabled if $00.
  283                        	
  284    00:E7A0  A9 01      			lda	#1			; Mark that we've changed the
  285    00:E7A2  9D 2C 27   			sta	sgx_region_new, x	; selected region.
  286    00:E7A5  9D 24 27   			sta	sgx_region_sel, x
  287                        	
  288    00:E7A8  28         			plp				; Restore interrupts.
  289    00:E7A9  60         			rts
  290                        	
  291    00:E7AA  9E 34 27   	.regionA:	stz	sgx_regionA_crl, x	; Region disabled if $00.
  292                        	
  293    00:E7AD  A9 01      			lda	#1			; Mark that we've changed the
  294    00:E7AF  9D 2C 27   			sta	sgx_region_new, x	; selected region.
  295    00:E7B2  9E 24 27   			stz	sgx_region_sel, x
  296                        	
  297    00:E7B5  28         			plp				; Restore interrupts.
  298    00:E7B6  60         			rts
  299                        	
  300                        		.endif	SUPPORT_SGX
  301                        	
  302                        	
  303                        	
  304                        	; ***************************************************************************
  305                        	; ***************************************************************************
  306                        	;
  307                        	; vbl_init_scroll
  308                        	;
  309                        	; From Charles MacDonald's pcetech.txt ...
  310                        	;
  311                        	;  Raster Compare Register (RCR):
  312                        	;
  313                        	;  The range of the RCR is 263 lines, relative to the start of the active
  314                        	;  display period. (defined by VSW, VDS, and VCR) The VDC treats the first
  315                        	;  scanline of the active display period as $0040, so the valid ranges for
  316                        	;  the RCR register are $0040 to $0146.
  317                        	;
  318                        	;  For example, assume VSW=$02, VDS=$17. This positions the first line of
  319                        	;  the active display period at line 25 of the frame. An RCR value of $0040
  320                        	;  (zero) causes an interrupt at line 25, and a value of $0146 (262) causes an
  321                        	;  interrupt at line 24 of the next frame.
  322                        	;
  323                        	;  Any other RCR values that are out of range ($00-$3F, $147-$3FF) will never
  324                        	;  result in a successful line compare.
  325                        	;
  326                        	; Processing time:
  327                        	;
  328                        	; Old HuC rcr_init: 2148 cycles if all 8 regions pre-sorted
  329                        	; Old HuC rcr_init: 4346 cycles if all 8 regions need sorting
  330                        	;
  331                        	; New HuCC vbl_init_scroll:   8 disabled splits:  290 cycles
  332                        	; New HuCC vbl_init_scroll:   8  enabled splits:  384 cycles
  333                        	;
  334                        	; New HuCC vbl_init_scroll:  16 disabled splits:  506 cycles
  335                        	; New HuCC vbl_init_scroll:  16  enabled splits:  672 cycles
  336                        	;
  337                        	; New HuCC vbl_init_scroll:  32 disabled splits:  953 cycles
  338                        	; New HuCC vbl_init_scroll:  32  enabled splits: 1263 cycles
  339                        	;
  340                        	; New HuCC vbl_init_scroll:  64 disabled splits: 1802 cycles
  341                        	; New HuCC vbl_init_scroll:  64  enabled splits: 2400 cycles
  342                        	;
  343                        	; New HuCC vbl_init_scroll: 128 disabled splits: 3530 cycles
  344                        	; New HuCC vbl_init_scroll: 128  enabled splits: 4704 cycles
  345                        	;
  346                        	; Memory used is 16 bytes per scroll per VDC!
  347                        	
  348               26A3     			.bss
  349                        	
  350    F8:26A3             	vdc_region_sel:	.ds	HUCC_PCE_SPLITS		; Use A or B region next frame?
  351    F8:26AB             	vdc_region_new:	.ds	HUCC_PCE_SPLITS		; 1 if vdc_region_sel modified.
  352                        	
  353    F8:26B3             	vdc_regionA_crl:.ds	HUCC_PCE_SPLITS		; Two copies of each setting
  354    F8:26BB             	vdc_regionB_crl:.ds	HUCC_PCE_SPLITS		; HUCC_PCE_SPLITS bytes apart,
  355    F8:26C3             	vdc_regionA_rcr:.ds	HUCC_PCE_SPLITS		; one setting for the current
  356    F8:26CB             	vdc_regionB_rcr:.ds	HUCC_PCE_SPLITS		; frame, and one setting that
  357    F8:26D3             	vdc_regionA_xl:	.ds	HUCC_PCE_SPLITS		; gets modified and then used
  358    F8:26DB             	vdc_regionB_xl:	.ds	HUCC_PCE_SPLITS		; on the next frame after the
  359    F8:26E3             	vdc_regionA_xh:	.ds	HUCC_PCE_SPLITS		; change is made.
  360    F8:26EB             	vdc_regionB_xh:	.ds	HUCC_PCE_SPLITS		; Regions will have different
  361    F8:26F3             	vdc_regionA_yl:	.ds	HUCC_PCE_SPLITS		; A or B currently active!
  362    F8:26FB             	vdc_regionB_yl:	.ds	HUCC_PCE_SPLITS
  363    F8:2703             	vdc_regionA_yh:	.ds	HUCC_PCE_SPLITS
  364    F8:270B             	vdc_regionB_yh:	.ds	HUCC_PCE_SPLITS
  365                        	
  366    F8:2713             	vdc_next_region:.ds	1			; Linked list of region indexes
  367    F8:2714             	vdc_regionA_nxt:.ds	HUCC_PCE_SPLITS		; for the current frame.
  368    F8:271C             	vdc_regionB_nxt:.ds	HUCC_PCE_SPLITS
  369                        	
  370               0001     		.if	SUPPORT_SGX
  371                        	
  372    F8:2724             	sgx_region_sel:	.ds	HUCC_SGX_SPLITS		; Use A or B region next frame?
  373    F8:272C             	sgx_region_new:	.ds	HUCC_SGX_SPLITS		; 1 if sgx_region_sel modified.
  374                        	
  375    F8:2734             	sgx_regionA_crl:.ds	HUCC_SGX_SPLITS		; Two copies of each setting
  376    F8:273C             	sgx_regionB_crl:.ds	HUCC_SGX_SPLITS		; HUCC_SGX_SPLITS bytes apart,
  377    F8:2744             	sgx_regionA_rcr:.ds	HUCC_SGX_SPLITS		; one setting for the current
  378    F8:274C             	sgx_regionB_rcr:.ds	HUCC_SGX_SPLITS		; frame, and one setting that
  379    F8:2754             	sgx_regionA_xl:	.ds	HUCC_SGX_SPLITS		; gets modified and then used
  380    F8:275C             	sgx_regionB_xl:	.ds	HUCC_SGX_SPLITS		; on the next frame after the
  381    F8:2764             	sgx_regionA_xh:	.ds	HUCC_SGX_SPLITS		; change is made.
  382    F8:276C             	sgx_regionB_xh:	.ds	HUCC_SGX_SPLITS		; Regions will have different
  383    F8:2774             	sgx_regionA_yl:	.ds	HUCC_SGX_SPLITS		; A or B currently active!
  384    F8:277C             	sgx_regionB_yl:	.ds	HUCC_SGX_SPLITS
  385    F8:2784             	sgx_regionA_yh:	.ds	HUCC_SGX_SPLITS
  386    F8:278C             	sgx_regionB_yh:	.ds	HUCC_SGX_SPLITS
  387                        	
  388    F8:2794             	sgx_next_region:.ds	1			; Linked list of region indexes
  389    F8:2795             	sgx_regionA_nxt:.ds	HUCC_SGX_SPLITS		; for the current frame.
  390    F8:279D             	sgx_regionB_nxt:.ds	HUCC_SGX_SPLITS
  391                        	
  392                        		.endif
  393                        	
  394               E7B7     			.code
  395                        	
  396    11:C451             	vbl_init_scroll	.proc
  397                        	
  398    11:C451  62         			cla				; A = previous active index
  399    11:C452  A2 08      			ldx	#HUCC_PCE_SPLITS	; so $00 for end-of-screen.
  400                        	
  401    11:C454  18         			clc				; For regionB indexes.
  402                        	
  403    11:C455  CA         	!next_region:	dex				; All regions updated?
  404    11:C456  30 20      			bmi	!save_first+
  405                        	
  406    11:C458  9E AB 26   			stz	vdc_region_new, x	; Clear region modified flag.
  407                        	
  408    11:C45B  BC A3 26   			ldy	vdc_region_sel, x	; 0=regionA or 1=regionB.
  409    11:C45E  F0 0D      			beq	!use_regionA+
  410                        	
  411    11:C460  BC BB 26   	!use_regionB:	ldy	vdc_regionB_crl, x	; Region disabled if $00.
  412    11:C463  F0 F0      			beq	!next_region-
  413    11:C465  9D 1C 27   			sta	vdc_regionB_nxt, x	; Save index of next region.
  414    11:C468  8A         			txa				; A = current region index.
  415    11:C469  69 08      			adc	#HUCC_PCE_SPLITS	; Always leaves CC!
  416    11:C46B  80 E8      			bra	!next_region-
  417                        	
  418    11:C46D  BC B3 26   	!use_regionA:	ldy	vdc_regionA_crl, x	; Region disabled if $00.
  419    11:C470  F0 E3      			beq	!next_region-
  420    11:C472  9D 14 27   			sta	vdc_regionA_nxt, x	; Save index of next region.
  421    11:C475  8A         			txa				; A = current region index.
  422    11:C476  80 DD      			bra	!next_region-
  423                        	
  424    11:C478  8D 13 27   	!save_first:	sta	vdc_next_region		; Save index of 1st region.
  425                        	
  426    11:C47B  AA         			tax				; NZ if first active region
  427    11:C47C  D0 03      			bne	!init_first+		; is not region 0.
  428    11:C47E  98         			tya				; NZ if region 0 is active.
  429    11:C47F  F0 0F      			beq	!+			; If no active leave RCR=0.
  430                        	
  431    11:C481  A9 06      	!init_first:	lda	#VDC_RCR		; 1st RCR always happens just
  432    11:C483  8D 00 02   			sta	VDC_AR			; before the display starts.
  433    11:C486  A9 44      			lda.l	#HUCC_1ST_RCR
  434    11:C488  8D 02 02   			sta	VDC_DL
  435    11:C48B  A9 01      			lda.h	#HUCC_1ST_RCR
  436    11:C48D  8D 03 02   			sta	VDC_DH
  437                        	
  438               0001     		.if	SUPPORT_SGX
  439                        	
  440    11:C490  62         	!:		cla				; A = previous active index
  441    11:C491  A2 08      			ldx	#HUCC_SGX_SPLITS	; so $00 for end-of-screen.
  442                        	
  443    11:C493  18         			clc				; For regionB indexes.
  444                        	
  445    11:C494  CA         	!next_region:	dex				; All regions updated?
  446    11:C495  30 20      			bmi	!save_first+
  447                        	
  448    11:C497  9E 2C 27   			stz	sgx_region_new, x	; Clear region modified flag.
  449                        	
  450    11:C49A  BC 24 27   			ldy	sgx_region_sel, x	; 0=regionA or 1=regionB.
  451    11:C49D  F0 0D      			beq	!use_regionA+
  452                        	
  453    11:C49F  BC 3C 27   	!use_regionB:	ldy	sgx_regionB_crl, x	; Region disabled if $00.
  454    11:C4A2  F0 F0      			beq	!next_region-
  455    11:C4A4  9D 9D 27   			sta	sgx_regionB_nxt, x	; Save index of next region.
  456    11:C4A7  8A         			txa				; A = current region index.
  457    11:C4A8  69 08      			adc	#HUCC_SGX_SPLITS	; Always leaves CC!
  458    11:C4AA  80 E8      			bra	!next_region-
  459                        	
  460    11:C4AC  BC 34 27   	!use_regionA:	ldy	sgx_regionA_crl, x	; Region disabled if $00.
  461    11:C4AF  F0 E3      			beq	!next_region-
  462    11:C4B1  9D 95 27   			sta	sgx_regionA_nxt, x	; Save index of next region.
  463    11:C4B4  8A         			txa				; A = current region index.
  464    11:C4B5  80 DD      			bra	!next_region-
  465                        	
  466    11:C4B7  8D 94 27   	!save_first:	sta	sgx_next_region		; Save index of 1st region.
  467                        	
  468    11:C4BA  AA         			tax				; NZ if first active region
  469    11:C4BB  D0 03      			bne	!init_first+		; is not region 0.
  470    11:C4BD  98         			tya				; NZ if region 0 is active.
  471    11:C4BE  F0 0F      			beq	!+			; If no active leave RCR=0.
  472                        	
  473    11:C4C0  A9 06      	!init_first:	lda	#VDC_RCR		; 1st RCR always happens just
  474    11:C4C2  8D 10 02   			sta	SGX_AR			; before the display starts.
  475    11:C4C5  A9 44      			lda.l	#HUCC_1ST_RCR
  476    11:C4C7  8D 12 02   			sta	SGX_DL
  477    11:C4CA  A9 01      			lda.h	#HUCC_1ST_RCR
  478    11:C4CC  8D 13 02   			sta	SGX_DH
  479                        	
  480                        		.endif	SUPPORT_SGX
  481                        	
  482                        	!:		leave				; All done!
         11:C4CF  4C EF FF   			jmp	leave_proc
  483                        	
  484                        			.endp
  485                        	
  486                        	
  487                        	
  488               0001     		.if	SUPPORT_SGX
  489                        	
  490                        	; ***************************************************************************
  491                        	; ***************************************************************************
  492                        	;
  493                        	; VDC_RCR_MACRO and SGX_RCR_MACRO
  494                        	;
  495                        	; A 16-byte TIA takes 142..234 cycles in 5MHz, 128..200 cycles in 7MHz.
  496                        	; A 32-byte TIA takes 270..364 cycles in 5MHz, 242..312 cycles in 7MHz. (527 DUO)
  497                        	;
  498                        	; You need to write the last RCR setting within 540 cycles in order to catch
  499                        	; the next line (at 256/336/512 resolution).
  500                        	;
  501                        	; That gives 305 cycles from the RCR to write the last setting, or there
  502                        	; will be a visible glitch on the screen.
  503                        	
  504               0000     		.ifndef	USING_RCR_MACROS
  506                        		.endif
  507                        	
  508                        	;		;;;				; 8 (cycles for the INT)
  509                        	;		bbs1	<irq_vec, .hook		; 8
  510                        	;		jmp	[irq1_hook]		; 7
  511                        	
  512                        	;		;;;				; 8 (cycles for the INT)
  513                        	;		jmp	irq1_handler		; 4
  514                        	
  515                        	;irq1_handler:	pha				; 3 Save all registers.
  516                        	;		phx				; 3
  517                        	;		phy				; 3
  518                        	;
  519                        	;		lda	VDC_SR			; 6 Acknowledge the VDC's IRQ.
  520                        	;		sta	<vdc_sr			; 4 Remember what caused it.
  521                        	;
  522                        	;		ldx	SGX_SR			; 6 Read SGX_SR after VDC_SR in
  523                        	;		stx	<sgx_sr			; 4 case this is not an SGX!
  524                        	;
  525                        	;!:		and	#$04			; 2 Is this an HSYNC interrupt?
  526                        	;		beq	!+			; 2
  527                        	
  528                        			.macro	VDC_RCR_MACRO
  529                        	
  530                        			st0	#VDC_RCR		; 5
  531                        	
  532                        			ldx	vdc_next_region		; 5 X and Y can be greater than
  533                        			ldy	vdc_regionA_nxt, x	; 5 HUCC_PCE_SPLITS if regionB!
  534                        			clc				; 2
  535                        			bne	!set_next_rcr+		; 4 Stop RCR if next line is 0.
  536                        	
  537                        			and	const_0000		; 5 A=$00 with the same #cycles
  538                        			bra	!clr_next_rcr+		; 4 as if the branch were taken.
  539                        	
  540                        	!set_next_rcr:	lda	vdc_regionA_rcr, y	; 5 Set next RCR 1 line before
  541                        			adc	#64-1			; 2 the region begins, or 0 to
  542                        	!clr_next_rcr:	sta	VDC_DL			; 6 disable.
  543                        			cla				; 2
  544                        			rol	a			; 2
  545                        			sta	VDC_DH			; 6
  546                        	
  547                        			st0	#VDC_BYR		; 5 Do BYR first to mitigate the
  548                        			lda	vdc_regionA_yl, x	; 5 glitch if the IRQ is delayed.
  549                        			sta	VDC_DL			; 6 = 105 cycles from RCR on SGX
  550                        			lda	vdc_regionA_yh, x	; 5
  551                        			sta	VDC_DH			; 6
  552                        	
  553                        			st0	#VDC_CR			; 5
  554                        			lda	vdc_regionA_crl, x	; 5
  555                        	;		asl	a
  556                        			sta	VDC_DL			; 6
  557                        	
  558                        			st0	#VDC_BXR		; 2
  559                        			lda	vdc_regionA_xl, x	; 5
  560                        			sta	VDC_DL			; 6
  561                        			lda	vdc_regionA_xh, x	; 5
  562                        			sta	VDC_DH			; 6 = 156 cycles from RCR if DUO
  563                        	
  564                        	;		bcc	!+
  565                        	;		lda	vdc_regionA_yh, x	; 5
  566                        	;		sta.l	VCE_CTW			; 6
  567                        	
  568                        			sty	vdc_next_region		; 5
  569                        	
  570                        			.endm
  571                        	
  572                        	;!:		bbr2	<sgx_sr, !+		; 6 Is this an HSYNC interrupt?
  573                        	
  574                        			.macro	SGX_RCR_MACRO
  575                        	
  576                        			lda	#VDC_RCR		; 2
  577                        			sta	SGX_AR			; 6
  578                        	
  579                        			ldx	sgx_next_region		; 5 X and Y can be greater than
  580                        			ldy	sgx_regionA_nxt, x	; 5 HUCC_SGX_SPLITS if regionB!
  581                        			clc				; 2
  582                        			bne	!set_next_rcr+		; 4 Stop RCR if next line is 0.
  583                        	
  584                        			and	const_0000		; 5 A=$00 with the same #cycles
  585                        			bra	!clr_next_rcr+		; 4 as if the branch were taken.
  586                        	
  587                        	!set_next_rcr:	lda	sgx_regionA_rcr, y	; 5 Set next RCR 1 line before
  588                        			adc	#64-1			; 2 the region begins, or 0 to
  589                        	!clr_next_rcr:	sta	SGX_DL			; 6 disable.
  590                        			cla				; 2
  591                        			rol	a			; 2
  592                        			sta	SGX_DH			; 6
  593                        	
  594                        			lda	#VDC_BYR		; 2 Do BYR first to mitigate the
  595                        			sta	SGX_AR			; 6 glitch if the IRQ is delayed.
  596                        			lda	sgx_regionA_yl, x	; 5
  597                        			sta	SGX_DL			; 6
  598                        			lda	sgx_regionA_yh, x	; 5
  599                        			sta	SGX_DH			; 6
  600                        	
  601                        			lda	#VDC_CR			; 2
  602                        			sta	SGX_AR			; 6
  603                        			lda	sgx_regionA_crl, x	; 5
  604                        			sta	SGX_DL			; 6
  605                        	
  606                        			lda	#VDC_BXR		; 2
  607                        			sta	SGX_AR			; 6
  608                        			lda	sgx_regionA_xl, x	; 5
  609                        			sta	SGX_DL			; 6
  610                        			lda	sgx_regionA_xh, x	; 5
  611                        			sta	SGX_DH			; 6 = 293 cycles (282 if no YH)
  612                        	
  613                        			sty	sgx_next_region		; 5
  614                        	
  615                        			.endm
  616                        	
  617                        		.else	SUPPORT_SGX
  697                        		.endif	SUPPORT_SGX
                             #[2]   "..\..\..\include\hucc\hucc-final.asm"
   68                        		.else
   72                        		.endif	HUCC_USES_NEW_SCROLL
   73                        	
   74               0001     		.ifdef	HUCC_USES_OLD_SPR		; Set in hucc_old_spr.h
                             #[3]   "..\..\..\include\hucc\hucc-old-spr.asm"
   75                        			include	"hucc-old-spr.asm"
    1                        	; ***************************************************************************
    2                        	; ***************************************************************************
    3                        	;
    4                        	; hucc-old-spr.asm
    5                        	;
    6                        	; Based on the original HuC and MagicKit functions by David Michel and the
    7                        	; other original HuC developers.
    8                        	;
    9                        	; Modifications copyright John Brandwood 2024.
   10                        	;
   11                        	; Distributed under the Boost Software License, Version 1.0.
   12                        	; (See accompanying file LICENSE_1_0.txt or copy at
   13                        	;  http://www.boost.org/LICENSE_1_0.txt)
   14                        	;
   15                        	; ***************************************************************************
   16                        	; ***************************************************************************
   17                        	
   18                        	;
   19                        	; Include dependancies ...
   20                        	;
   21                        	
   22                        			include "common.asm"		; Common helpers.
   23                        			include "vce.asm"		; Useful VCE routines.
   24                        			include "vdc.asm"		; Useful VCE routines.
   25                        	
   26                        	
   27                        	
   28                        	; ***************************************************************************
   29                        	; ***************************************************************************
   30                        	;
   31                        	; HuC Sprite Functions
   32                        	;
   33                        	; ***************************************************************************
   34                        	; ***************************************************************************
   35                        	
   36               209C     			.zp
   37    F8:209C             	spr_ptr:	ds	2
   38               27A5     			.bss
   39    F8:27A5             	spr_sat:	ds	512
   40               E7B7     			.code
   41                        	
   42               0001     		.if	SUPPORT_SGX
   43               209E     			.zp
   44    F8:209E             	sgx_spr_ptr:	ds	2
   45               29A5     			.bss
   46    F8:29A5             	sgx_spr_sat:	ds	512	; N.B. Directly after spr_sat!
   47               E7B7     			.code
   48                        		.endif
   49                        	
   50                        	; Moved to hucc-old-map.asm just to save space. This NEEDS to be changed!
   51                        	;
   52                        	;		.bss
   53                        	;spr_max:	ds	1
   54                        	;spr_clr:	ds	1
   55                        	;	.if	SUPPORT_SGX
   56                        	;sgx_spr_max:	ds	1
   57                        	;sgx_spr_clr:	ds	1
   58                        	;	.endif
   59                        	;		.code
   60                        	
   61                        	
   62                        	
   63                        	; ***************************************************************************
   64                        	; ***************************************************************************
   65                        	;
   66                        	; void __fastcall init_satb( void );
   67                        	; void __fastcall reset_satb( void );
   68                        	;
   69                        	; void __fastcall sgx_init_satb( void );
   70                        	; void __fastcall sgx_reset_satb( void );
   71                        	
   72    00:E7B7             	_reset_satb:
   73    00:E7B7  C2         	_init_satb:	cly
   74    00:E7B8  62         			cla
   75    00:E7B9  99 A5 27   	!:		sta	spr_sat + $0000, y
   76    00:E7BC  99 A5 28   			sta	spr_sat + $0100, y
   77    00:E7BF  C8         			iny
   78    00:E7C0  D0 F7      			bne	!-
   79    00:E7C2  8C 79 26   			sty	spr_max
   80    00:E7C5  C8         			iny
   81    00:E7C6  8C 7A 26   			sty	spr_clr
   82    00:E7C9  60         			rts
   83                        	
   84               0001     		.if	SUPPORT_SGX
   85    00:E7CA             	_sgx_reset_satb:
   86    00:E7CA  C2         	_sgx_init_satb:	cly
   87    00:E7CB  62         			cla
   88    00:E7CC  99 A5 29   	!:		sta	sgx_spr_sat + $0000, y
   89    00:E7CF  99 A5 2A   			sta	sgx_spr_sat + $0100, y
   90    00:E7D2  C8         			iny
   91    00:E7D3  D0 F7      			bne	!-
   92    00:E7D5  8C 89 26   			sty	sgx_spr_max
   93    00:E7D8  C8         			iny
   94    00:E7D9  8C 8A 26   			sty	sgx_spr_clr
   95    00:E7DC  60         			rts
   96                        		.endif
   97                        	
   98                        	
   99                        	
  100                        	; ***************************************************************************
  101                        	; ***************************************************************************
  102                        	;
  103                        	; void __fastcall satb_update( void );
  104                        	; void __fastcall sgx_satb_update( void );
  105                        	
  106    11:C6F3             	old_satb_group	.procgroup
  107                        	
  108               0001     		.if	SUPPORT_SGX
  109                        			.proc	_sgx_satb_update
  115                        			.endp
  116                        		.endif
  117                        	
  118    11:C6F3             			.proc	_satb_update
  119                        	
  120    11:C6F3  82         			clx				; Offset to PCE VDC.
  121                        	
  122    11:C6F4  A9 7F      			lda.h	#$7F00			; HuC puts the SAT here in VRAM
  123                        	;		lda.h	#$0800			; but we put it here instead
  124    11:C6F6  64 F0      			stz.l	<_di
  125    11:C6F8  85 F1      			sta.h	<_di
  126    11:C6FA  20 7F E3   			jsr	set_di_to_mawr
  127                        	
  128               0001     		.if	SUPPORT_SGX
  129    11:C6FD  8A         			txa				; Select which VDC to write
  130    11:C6FE  1A         			inc	a			; to.
  131    11:C6FF  1A         			inc	a
  132    11:C700  8D F3 22   			sta.l	ram_tia_dst
  133                        		.endif
  134                        	
  135    11:C703  A9 10      			lda	#VRAM_XFER_SIZE		; Split into 16-byte chunks
  136    11:C705  8D F5 22   			sta.l	ram_tia_len		; for stable IRQ response.
  137                        	
  138    11:C708  BC 79 26   			ldy	spr_max, x		; Highest sprite that was set.
  139    11:C70B  C8         			iny
  140                        	
  141    11:C70C  BD 7A 26   			lda	spr_clr, x
  142    11:C70F  F0 05      			beq	!+
  143    11:C711  9E 7A 26   			stz	spr_clr, x
  144    11:C714  A0 40      			ldy	#64
  145                        	
  146    11:C716  98         	!:		tya
  147    11:C717  F0 22      			beq	.exit
  148                        	
  149    11:C719  3A         			dec	a			; round up to the next group of 2 sprites
  150    11:C71A  4A         			lsr	a
  151               0000     		.if	VRAM_XFER_SIZE == 32
  153                        		.endif
  154    11:C71B  1A         			inc	a
  155    11:C71C  A8         			tay
  156                        	
  157    11:C71D  A9 27      			lda.h	#spr_sat
  158                        	
  159               0001     		.if	SUPPORT_SGX
  160    11:C71F  E0 00      			cpx	#0
  161    11:C721  F0 02      			beq	!+
  162                        	
  163    11:C723  A9 29      			lda.h	#sgx_spr_sat
  164                        		.endif
  165                        	
  166    11:C725  8D F2 22   	!:		sta.h	ram_tia_src
  167                        	
  168    11:C728  A9 A5      			lda.l	#spr_sat		; Same for SGX and PCE!
  169    11:C72A  8D F1 22   	.chunk_loop:	sta.l	ram_tia_src
  170                        	
  171    11:C72D  20 F0 22   			jsr	ram_tia			; transfer 16-bytes
  172                        	
  173    11:C730  18         			clc				; increment source
  174    11:C731  69 10      			adc	#VRAM_XFER_SIZE
  175    11:C733  90 03      			bcc	.same_page
  176    11:C735  EE F2 22   			inc.h	ram_tia_src
  177                        	
  178    11:C738  88         	.same_page:	dey
  179    11:C739  D0 EF      			bne	.chunk_loop
  180                        	
  181                        	.exit:		leave
         11:C73B  4C EF FF   			jmp	leave_proc
  182                        	
  183                        			.endp
  184                        	
  185                        			.endprocgroup	; old_satb_group
  186                        	
  187                        	
  188                        	
  189                        	; ***************************************************************************
  190                        	; ***************************************************************************
  191                        	;
  192                        	; void __fastcall spr_set( unsigned char num<acc> );
  193                        	
  194    00:E7DD  CD 79 26   	_spr_set.1:	cmp	spr_max
  195    00:E7E0  90 03      			bcc	!+
  196    00:E7E2  8D 79 26   			sta	spr_max
  197    00:E7E5  A0 27      	!:		ldy.h	#spr_sat
  198    00:E7E7  0A         			asl	a
  199    00:E7E8  0A         			asl	a
  200    00:E7E9  0A         			asl	a
  201    00:E7EA  90 02      			bcc	!+
  202    00:E7EC  C8         			iny
  203    00:E7ED  18         			clc
  204    00:E7EE  69 A5      	!:		adc.l	#spr_sat
  205    00:E7F0  85 9C      			sta.l	<spr_ptr
  206    00:E7F2  90 01      			bcc	!+
  207    00:E7F4  C8         			iny
  208    00:E7F5  84 9D      	!:		sty.h	<spr_ptr
  209    00:E7F7  60         			rts
  210                        	
  211                        	
  212                        	
  213                        	; ***************************************************************************
  214                        	; ***************************************************************************
  215                        	;
  216                        	; void __fastcall spr_hide( void );
  217                        	
  218    00:E7F8  A0 01      	_spr_hide:	ldy	#1
  219    00:E7FA  B1 9C      			lda	[spr_ptr], y
  220    00:E7FC  09 02      			ora	#2
  221    00:E7FE  91 9C      			sta	[spr_ptr], y
  222    00:E800  60         			rts
  223                        	
  224                        	
  225                        	
  226                        	; ***************************************************************************
  227                        	; ***************************************************************************
  228                        	;
  229                        	; void __fastcall spr_show( void );
  230                        	
  231    00:E801  A0 01      	_spr_show:	ldy	#1
  232    00:E803  B1 9C      			lda	[spr_ptr], y
  233    00:E805  29 01      			and	#1
  234    00:E807  91 9C      			sta	[spr_ptr], y
  235    00:E809  60         			rts
  236                        	
  237                        	
  238                        	
  239                        	; ***************************************************************************
  240                        	; ***************************************************************************
  241                        	;
  242                        	; void __fastcall spr_x( unsigned int value<acc> );
  243                        	
  244    00:E80A  02         	_spr_x.1:	sxy
  245    00:E80B  18         			clc
  246    00:E80C  69 20      			adc	#32
  247    00:E80E  A0 02      			ldy	#2
  248    00:E810  91 9C      			sta	[spr_ptr], y
  249    00:E812  8A         			txa
  250    00:E813  69 00      			adc	#0
  251    00:E815  C8         			iny
  252    00:E816  91 9C      			sta	[spr_ptr], y
  253    00:E818  60         			rts
  254                        	
  255                        	
  256                        	
  257                        	; ***************************************************************************
  258                        	; ***************************************************************************
  259                        	;
  260                        	; void __fastcall spr_y( unsigned int value<acc> );
  261                        	
  262    00:E819  18         	_spr_y.1:	clc
  263    00:E81A  69 40      			adc	#64
  264    00:E81C  92 9C      			sta	[spr_ptr]
  265    00:E81E  98         			tya
  266    00:E81F  69 00      			adc	#0
  267    00:E821  A0 01      			ldy	#1
  268    00:E823  91 9C      			sta	[spr_ptr], y
  269    00:E825  60         			rts
  270                        			
  271                        	
  272                        	
  273                        	; ***************************************************************************
  274                        	; ***************************************************************************
  275                        	;
  276                        	; void __fastcall spr_pattern( unsigned int vaddr<acc> );
  277                        	
  278    00:E826  84 00      	_spr_pattern.1:	sty	<__temp		;     zp=fedcba98 a=76543210
  279    00:E828  0A         			asl	a		; c=f zp=edcba987 a=6543210_
  280    00:E829  26 00      			rol	<__temp
  281    00:E82B  2A         			rol	a		; c=e zp=dcba9876 a=543210_f
  282    00:E82C  26 00      			rol	<__temp
  283    00:E82E  2A         			rol	a		; c=d zp=cba98765 a=43210_fe
  284    00:E82F  26 00      			rol	<__temp
  285    00:E831  2A         			rol	a		; c=4 zp=cba98765 a=3210_fed
  286    00:E832  A0 05      			ldy	#5
  287    00:E834  91 9C      			sta	[spr_ptr], y
  288    00:E836  A5 00      			lda	<__temp
  289    00:E838  88         			dey
  290    00:E839  91 9C      			sta	[spr_ptr], y
  291    00:E83B  60         			rts
  292                        	
  293                        	
  294                        	
  295                        	; ***************************************************************************
  296                        	; ***************************************************************************
  297                        	;
  298                        	; void __fastcall spr_ctrl( unsigned char mask<_al>, unsigned char value<acc> );
  299                        	
  300    00:E83C  25 F8      	_spr_ctrl.2:	and	<_al
  301    00:E83E  85 00      			sta	<__temp
  302    00:E840  A5 F8      			lda	<_al
  303    00:E842  49 FF      			eor	#$FF
  304    00:E844  A0 07      			ldy	#7
  305    00:E846  31 9C      			and	[spr_ptr], y
  306    00:E848  05 00      			ora	<__temp
  307    00:E84A  91 9C      			sta	[spr_ptr], y
  308    00:E84C  60         			rts
  309                        	
  310                        	
  311                        	
  312                        	; ***************************************************************************
  313                        	; ***************************************************************************
  314                        	;
  315                        	; void __fastcall spr_pal( unsigned char palette<acc> )
  316                        	
  317    00:E84D  29 0F      	_spr_pal.1:	and	#$0F
  318    00:E84F  85 00      			sta	<__temp
  319    00:E851  A0 06      			ldy	#6
  320    00:E853  B1 9C      			lda	[spr_ptr], y
  321    00:E855  29 F0      			and	#$F0
  322    00:E857  05 00      			ora	<__temp
  323    00:E859  91 9C      			sta	[spr_ptr], y
  324    00:E85B  60         			rts
  325                        	
  326                        	
  327                        	
  328                        	; ***************************************************************************
  329                        	; ***************************************************************************
  330                        	;
  331                        	; void __fastcall spr_pri( unsigned char priority<acc> )
  332                        	
  333    00:E85C  C9 01      	_spr_pri.1:	cmp	#1
  334    00:E85E  A0 06      			ldy	#6
  335    00:E860  B1 9C      			lda	[spr_ptr], y
  336    00:E862  29 7F      			and	#$7F
  337    00:E864  90 02      			bcc	!+
  338    00:E866  09 80      			ora	#$80
  339    00:E868  91 9C      	!:		sta	[spr_ptr], y
  340    00:E86A  60         			rts
  341                        	
  342                        	
  343                        	
  344                        	; ***************************************************************************
  345                        	; ***************************************************************************
  346                        	;
  347                        	; unsigned int __fastcall spr_get_x( void );
  348                        	
  349    00:E86B  38         	_spr_get_x:	sec
  350    00:E86C  A0 02      			ldy	#2
  351    00:E86E  B1 9C      			lda	[spr_ptr], y
  352    00:E870  E9 20      			sbc	#32
  353    00:E872  AA         			tax
  354    00:E873  C8         			iny
  355    00:E874  B1 9C      			lda	[spr_ptr], y
  356    00:E876  E9 00      			sbc	#0
  357    00:E878  A8         			tay
  358    00:E879  8A         			txa
  359    00:E87A  60         			rts
  360                        	
  361                        	
  362                        	
  363                        	; ***************************************************************************
  364                        	; ***************************************************************************
  365                        	;
  366                        	; unsigned int __fastcall spr_get_y( void );
  367                        	
  368    00:E87B  38         	_spr_get_y:	sec
  369    00:E87C  B2 9C      			lda	[spr_ptr]
  370    00:E87E  E9 40      			sbc	#64
  371    00:E880  AA         			tax
  372    00:E881  A0 01      			ldy	#1
  373    00:E883  B1 9C      			lda	[spr_ptr], y
  374    00:E885  E9 00      			sbc	#0
  375    00:E887  A8         			tay
  376    00:E888  8A         			txa
  377    00:E889  60         			rts
  378                        	
  379                        	
  380                        	
  381               0001     		.if	SUPPORT_SGX
  382                        	
  383                        	; ***************************************************************************
  384                        	; ***************************************************************************
  385                        	;
  386                        	; void __fastcall sgx_spr_set( unsigned char num<acc> );
  387                        	
  388    00:E88A  CD 89 26   	_sgx_spr_set.1:	cmp	sgx_spr_max
  389    00:E88D  90 03      			bcc	!+
  390    00:E88F  8D 89 26   			sta	sgx_spr_max
  391    00:E892  A0 29      	!:		ldy.h	#sgx_spr_sat
  392    00:E894  0A         			asl	a
  393    00:E895  0A         			asl	a
  394    00:E896  0A         			asl	a
  395    00:E897  90 02      			bcc	!+
  396    00:E899  C8         			iny
  397    00:E89A  18         			clc
  398    00:E89B  69 A5      	!:		adc.l	#sgx_spr_sat
  399    00:E89D  85 9E      			sta.l	<sgx_spr_ptr
  400    00:E89F  90 01      			bcc	!+
  401    00:E8A1  C8         			iny
  402    00:E8A2  84 9F      	!:		sty.h	<sgx_spr_ptr
  403    00:E8A4  60         			rts
  404                        	
  405                        	
  406                        	
  407                        	; ***************************************************************************
  408                        	; ***************************************************************************
  409                        	;
  410                        	; void __fastcall sgx_spr_hide( void );
  411                        	
  412    00:E8A5  A0 01      	_sgx_spr_hide:	ldy	#1
  413    00:E8A7  B1 9E      			lda	[sgx_spr_ptr], y
  414    00:E8A9  09 02      			ora	#2
  415    00:E8AB  91 9E      			sta	[sgx_spr_ptr], y
  416    00:E8AD  60         			rts
  417                        	
  418                        	
  419                        	
  420                        	; ***************************************************************************
  421                        	; ***************************************************************************
  422                        	;
  423                        	; void __fastcall sgx_spr_show( void );
  424                        	
  425    00:E8AE  A0 01      	_sgx_spr_show:	ldy	#1
  426    00:E8B0  B1 9E      			lda	[sgx_spr_ptr], y
  427    00:E8B2  29 01      			and	#1
  428    00:E8B4  91 9E      			sta	[sgx_spr_ptr], y
  429    00:E8B6  60         			rts
  430                        	
  431                        	
  432                        	
  433                        	; ***************************************************************************
  434                        	; ***************************************************************************
  435                        	;
  436                        	; void __fastcall sgx_spr_x( unsigned int value<acc> );
  437                        	
  438    00:E8B7  02         	_sgx_spr_x.1:	sxy
  439    00:E8B8  18         			clc
  440    00:E8B9  69 20      			adc	#32
  441    00:E8BB  A0 02      			ldy	#2
  442    00:E8BD  91 9E      			sta	[sgx_spr_ptr], y
  443    00:E8BF  8A         			txa
  444    00:E8C0  69 00      			adc	#0
  445    00:E8C2  C8         			iny
  446    00:E8C3  91 9E      			sta	[sgx_spr_ptr], y
  447    00:E8C5  60         			rts
  448                        	
  449                        	
  450                        	
  451                        	; ***************************************************************************
  452                        	; ***************************************************************************
  453                        	;
  454                        	; void __fastcall sgx_spr_y( unsigned int value<acc> );
  455                        	
  456    00:E8C6  18         	_sgx_spr_y.1:	clc
  457    00:E8C7  69 40      			adc	#64
  458    00:E8C9  92 9E      			sta	[sgx_spr_ptr]
  459    00:E8CB  98         			tya
  460    00:E8CC  69 00      			adc	#0
  461    00:E8CE  A0 01      			ldy	#1
  462    00:E8D0  91 9E      			sta	[sgx_spr_ptr], y
  463    00:E8D2  60         			rts
  464                        			
  465                        	
  466                        	
  467                        	; ***************************************************************************
  468                        	; ***************************************************************************
  469                        	;
  470                        	; void __fastcall sgx_spr_pattern( unsigned int vaddr<acc> );
  471                        	
  472    00:E8D3             	_sgx_spr_pattern.1:
  473    00:E8D3  84 00      			sty	<__temp		;     zp=fedcba98 a=76543210
  474    00:E8D5  0A         			asl	a		; c=f zp=edcba987 a=6543210_
  475    00:E8D6  26 00      			rol	<__temp
  476    00:E8D8  2A         			rol	a		; c=e zp=dcba9876 a=543210_f
  477    00:E8D9  26 00      			rol	<__temp
  478    00:E8DB  2A         			rol	a		; c=d zp=cba98765 a=43210_fe
  479    00:E8DC  26 00      			rol	<__temp
  480    00:E8DE  2A         			rol	a		; c=4 zp=cba98765 a=3210_fed
  481    00:E8DF  A0 05      			ldy	#5
  482    00:E8E1  91 9E      			sta	[sgx_spr_ptr], y
  483    00:E8E3  A5 00      			lda	<__temp
  484    00:E8E5  88         			dey
  485    00:E8E6  91 9E      			sta	[sgx_spr_ptr], y
  486    00:E8E8  60         			rts
  487                        	
  488                        	
  489                        	
  490                        	; ***************************************************************************
  491                        	; ***************************************************************************
  492                        	;
  493                        	; void __fastcall sgx_spr_ctrl( unsigned char mask<_al>, unsigned char value<acc> );
  494                        	
  495    00:E8E9  25 F8      	_sgx_spr_ctrl.2:and	<_al
  496    00:E8EB  85 00      			sta	<__temp
  497    00:E8ED  A5 F8      			lda	<_al
  498    00:E8EF  49 FF      			eor	#$FF
  499    00:E8F1  A0 07      			ldy	#7
  500    00:E8F3  31 9E      			and	[sgx_spr_ptr], y
  501    00:E8F5  05 00      			ora	<__temp
  502    00:E8F7  91 9E      			sta	[sgx_spr_ptr], y
  503    00:E8F9  60         			rts
  504                        	
  505                        	
  506                        	
  507                        	; ***************************************************************************
  508                        	; ***************************************************************************
  509                        	;
  510                        	; void __fastcall sgx_spr_pal( unsigned char palette<acc> )
  511                        	
  512    00:E8FA  29 0F      	_sgx_spr_pal.1:	and	#$0F
  513    00:E8FC  85 00      			sta	<__temp
  514    00:E8FE  A0 06      			ldy	#6
  515    00:E900  B1 9E      			lda	[sgx_spr_ptr], y
  516    00:E902  29 F0      			and	#$F0
  517    00:E904  05 00      			ora	<__temp
  518    00:E906  91 9E      			sta	[sgx_spr_ptr], y
  519    00:E908  60         			rts
  520                        	
  521                        	
  522                        	
  523                        	; ***************************************************************************
  524                        	; ***************************************************************************
  525                        	;
  526                        	; void __fastcall sgx_spr_pri( unsigned char priority<acc> )
  527                        	
  528    00:E909  C9 01      	_sgx_spr_pri.1:	cmp	#1
  529    00:E90B  A0 06      			ldy	#6
  530    00:E90D  B1 9E      			lda	[sgx_spr_ptr], y
  531    00:E90F  29 7F      			and	#$7F
  532    00:E911  90 02      			bcc	!+
  533    00:E913  09 80      			ora	#$80
  534    00:E915  91 9E      	!:		sta	[sgx_spr_ptr], y
  535    00:E917  60         			rts
  536                        	
  537                        	
  538                        	
  539                        	; ***************************************************************************
  540                        	; ***************************************************************************
  541                        	;
  542                        	; unsigned int __fastcall sgx_spr_get_x( void );
  543                        	
  544    00:E918  38         	_sgx_spr_get_x:	sec
  545    00:E919  A0 02      			ldy	#2
  546    00:E91B  B1 9E      			lda	[sgx_spr_ptr], y
  547    00:E91D  E9 20      			sbc	#32
  548    00:E91F  AA         			tax
  549    00:E920  C8         			iny
  550    00:E921  B1 9E      			lda	[sgx_spr_ptr], y
  551    00:E923  E9 00      			sbc	#0
  552    00:E925  A8         			tay
  553    00:E926  8A         			txa
  554    00:E927  60         			rts
  555                        	
  556                        	
  557                        	
  558                        	; ***************************************************************************
  559                        	; ***************************************************************************
  560                        	;
  561                        	; unsigned int __fastcall sgx_spr_get_y( void );
  562                        	
  563    00:E928  38         	_sgx_spr_get_y:	sec
  564    00:E929  B2 9E      			lda	[sgx_spr_ptr]
  565    00:E92B  E9 40      			sbc	#64
  566    00:E92D  AA         			tax
  567    00:E92E  A0 01      			ldy	#1
  568    00:E930  B1 9E      			lda	[sgx_spr_ptr], y
  569    00:E932  E9 00      			sbc	#0
  570    00:E934  A8         			tay
  571    00:E935  8A         			txa
  572    00:E936  60         			rts
  573                        	
  574                        		.endif	SUPPORT_SGX
                             #[2]   "..\..\..\include\hucc\hucc-final.asm"
   76                        		.endif
   77                        	
   78               0001     		.ifdef	HUCC_USES_BLKMAP		; Set in hucc_blkmap.h
                             #[3]   "..\..\..\include\hucc\blkmap.asm"
   79                        			include	"blkmap.asm"
    1                        	; ***************************************************************************
    2                        	; ***************************************************************************
    3                        	;
    4                        	; blkmap.asm
    5                        	;
    6                        	; A map system based on 16x16 meta-tiles (aka "blocks", aka CHR/BLK/MAP).
    7                        	;
    8                        	; Copyright John Brandwood 2025.
    9                        	;
   10                        	; Distributed under the Boost Software License, Version 1.0.
   11                        	; (See accompanying file LICENSE_1_0.txt or copy at
   12                        	;  http://www.boost.org/LICENSE_1_0.txt)
   13                        	;
   14                        	; ***************************************************************************
   15                        	; ***************************************************************************
   16                        	;
   17                        	; The maximum X and Y size for blkmaps is 128 blocks (2048 pixels).
   18                        	;
   19                        	; The maximum total size for a blkmap is 16KBytes, which allows for maps up
   20                        	; to 128x128 blocks (2048x2048 pixels).
   21                        	;
   22                        	; Huge multi-screen blkmaps are also supported (optionally).
   23                        	;
   24                        	; The maximum X and Y for multi-screen maps is 128 screens (32768 pixels).
   25                        	;
   26                        	; The maximum total size for a multi-screen map is 8KBytes, which allows for
   27                        	; a total of 1024 screens.
   28                        	;
   29                        	; ***************************************************************************
   30                        	; ***************************************************************************
   31                        	
   32                        	;
   33                        	; Include dependancies ...
   34                        	;
   35                        	
   36                        			include "common.asm"		; Common helpers.
   37                        			include "vce.asm"		; Useful VCE routines.
   38                        			include "vdc.asm"		; Useful VCE routines.
   39                        	
   40                        	;
   41                        	; Support large blkmaps up to 16KBytes instead of the regular 8KBytes?
   42                        	;
   43                        	; The maximum X and Y size for regular blkmaps is 128 tiles (2048 pixels).
   44                        	;
   45                        	; This allows for individual maps up to 128x128 tiles (2048x2048 pixels) vs
   46                        	; default limit of 128x64 or 64x128.
   47                        	;
   48                        	
   49               0000     		.ifndef	BLKMAP_LARGEMAP
   51                        		.endif
   52                        	
   53                        	;
   54                        	; Support huge multi-screen maps, up to 32768 pixels wide/high?
   55                        	;
   56                        	; These are sectorized maps split into individual BAT-sized "screens", with
   57                        	; a maximum of 1024 screens per map.
   58                        	;
   59                        	; The BAT size that is used when drawing *must* be the same as the BAT size
   60                        	; that was chosen when creating the multi-screen map.
   61                        	;
   62                        	; Each screen can use a unique set of block definitions, or it might choose
   63                        	; to share the same block definitions that are used on another screen.
   64                        	;
   65                        	; Each screen may choose which 8KByte banks of character data to select for
   66                        	; the 4 banks (32KBytes) of VRAM that its block definitions use, with a max
   67                        	; of 16 banks of characters per multi-screen map.
   68                        	;
   69                        	; Loading those character banks dynamically is an exercise for the user!
   70                        	;
   71                        	; Enabling support adds extra library code, and slightly slows down the use
   72                        	; of regular blkmaps.
   73                        	;
   74                        	
   75               0000     		.ifndef	BLKMAP_MULTISCR
   77                        		.endif
   78                        	
   79                        	;
   80                        	; Block definitions can either use character data from VRAM $1000..$7FFF or
   81                        	; they can be limited to use the 32KByte of characters in VRAM $1000..$4FFF
   82                        	; which then frees up 2-bits for flag information for each character in the
   83                        	; block.
   84                        	;
   85                        	; These 2-bits are perfect for using as collision information in game maps,
   86                        	; allowing storage of states like transparent, solid, up-slope, down-slope.
   87                        	;
   88                        	; Typically this flag information is set by the map conversion tools from a
   89                        	; seperate "collision" map layer.
   90                        	;
   91                        	
   92               0000     		.ifndef	BLKDEF_CHR_FLAG
   94                        		.endif
   95                        	
   96                        	;
   97                        	; Block definitions are accessed in MPR2 ($4000..$5FFF), and must not cross
   98                        	; the bank boundary.
   99                        	;
  100                        	; When working this way, 8 pointers in ZP are used to access the individual
  101                        	; bytes in the block definition. This is fine when using a regular map on a
  102                        	; PC Engine, but it is awfully slow when using multi-screen maps or drawing
  103                        	; maps on both VDC chips in a SuperGRAFX because the pointer values must be
  104                        	; constantly changed.
  105                        	;
  106                        	; When using multi-screen maps, or when developing a SuperGRAFX game, or if
  107                        	; developing a CDROM game, then it is usually preferable to store the block
  108                        	; definitions with 2KByte alignment, especially if they are normally stored
  109                        	; compressed and then decompressed into a 2KByte buffer in RAM when needed.
  110                        	;
  111                        	; This option controls whether the definitions are stored 2KByte aligned or
  112                        	; if pointers should be used instead.
  113                        	;
  114                        	
  115               0000     		.ifndef	BLKDEF_POINTERS
  117                        		.endif
  118                        	
  119                        	;
  120                        	; Add a timing bar to the scroll_map() to see how long the drawing takes?
  121                        	;
  122                        	
  123               0000     		.ifndef	BLKMAP_TIMETEST
  125                        		.endif
  126                        	
  127                        	;
  128                        	;
  129                        	;
  130                        	
  131               0000     		.if	BLKDEF_POINTERS
  144                        		.else
  145                        	
  146                        		; If the block definititions are 2KByte aligned.
  147                        	
  148               4000     	BLK_4000_TL_L	=	$4000
  149               4100     	BLK_4000_TR_L	=	$4100
  150               4200     	BLK_4000_BL_L	=	$4200
  151               4300     	BLK_4000_BR_L	=	$4300
  152               4400     	BLK_4000_TL_H	=	$4400
  153               4500     	BLK_4000_TR_H	=	$4500
  154               4600     	BLK_4000_BL_H	=	$4600
  155               4700     	BLK_4000_BR_H	=	$4700
  156                        	
  157               4800     	BLK_4800_TL_L	=	$4800
  158               4900     	BLK_4800_TR_L	=	$4900
  159               4A00     	BLK_4800_BL_L	=	$4A00
  160               4B00     	BLK_4800_BR_L	=	$4B00
  161               4C00     	BLK_4800_TL_H	=	$4C00
  162               4D00     	BLK_4800_TR_H	=	$4D00
  163               4E00     	BLK_4800_BL_H	=	$4E00
  164               4F00     	BLK_4800_BR_H	=	$4F00
  165                        	
  166               5000     	BLK_5000_TL_L	=	$5000
  167               5100     	BLK_5000_TR_L	=	$5100
  168               5200     	BLK_5000_BL_L	=	$5200
  169               5300     	BLK_5000_BR_L	=	$5300
  170               5400     	BLK_5000_TL_H	=	$5400
  171               5500     	BLK_5000_TR_H	=	$5500
  172               5600     	BLK_5000_BL_H	=	$5600
  173               5700     	BLK_5000_BR_H	=	$5700
  174                        	
  175               5800     	BLK_5800_TL_L	=	$5800
  176               5900     	BLK_5800_TR_L	=	$5900
  177               5A00     	BLK_5800_BL_L	=	$5A00
  178               5B00     	BLK_5800_BR_L	=	$5B00
  179               5C00     	BLK_5800_TL_H	=	$5C00
  180               5D00     	BLK_5800_TR_H	=	$5D00
  181               5E00     	BLK_5800_BL_H	=	$5E00
  182               5F00     	BLK_5800_BR_H	=	$5F00
  183                        	
  184                        		.endif
  185                        	
  186               0080     	MAP_UNALIGNED_X	=	$80
  187               0040     	MAP_UNALIGNED_Y	=	$40
  188                        	
  189                        	;
  190                        	;
  191                        	;
  192                        	
  193               2BA5     			.bss
  194                        	
  195                        	; **************
  196                        	; 8-byte (or 2-byte) entry for each SCREEN in the MULTI_MAP.
  197                        	
  198               0000     			.rsset	0
  199               0000     		.if	BLKDEF_POINTERS
  202                        		.else
  203               0000     	SCR_MAP_PAGE	.rs	1	; 256-byte aligned.
  204               0001     	SCR_MAP_BANK	.rs	1
  205               0002     	SCR_BLK_PAGE	.rs	1	; >$4000, >$4800, >$5000, or >$5800.
  206               0003     	SCR_BLK_BANK	.rs	1
  207               0004     	SCR_TBL_PAGE	.rs	1	; 256-byte aligned.
  208               0005     	SCR_TBL_BANK	.rs	1
  209               0006     	SCR_CHR_12	.rs	1	; Which CHR banks are used by the BLK, with
  210               0007     	SCR_CHR_34	.rs	1	; a max of 16 CHR banks per MULTI_MAP.
  211                        		.endif
  212                        	
  213                        			; A simple macro to help build a multi-screen map.
  214                        	
  215               0000     		.ifndef	SCREEN
  224                        		.endif
  225                        	
  226    F8:2BA5             	map_blk_flag:	ds	1	; Returned from _get_map_block().
  227    F8:2BA6             	map_blk_mask:	ds	1	; Returned from _get_map_block().
  228                        	
  229                        	; **************
  230                        	; 16-bytes of VDC blkmap info.
  231                        	;
  232                        	; N.B. MUST be 16-bytes before the SGX versions to use PCE_VDC_OFFSET.
  233                        	
  234    F8:2BA7             	vdc_old_chr_x:	ds	1	; Previous top-left X in CHR (lo-byte only).
  235    F8:2BA8             	vdc_old_chr_y:	ds	1	; Previous top-left Y in CHR (lo-byte only).
  236                        	
  237    F8:2BA9             	vdc_tbl_addr:	ds	2	; 256-byte aligned.
  238    F8:2BAB             	vdc_tbl_bank:	ds	1
  239                        	
  240    F8:2BAC             	vdc_blk_addr:	ds	2	; 2KBytes of data, 256-byte aligned.
  241    F8:2BAE             	vdc_blk_bank:	ds	1
  242                        	
  243    F8:2BAF             	vdc_map_addr:	ds	2	; Mapped into MPR3..MPR5, max 16KBytes.
  244    F8:2BB1             	vdc_map_bank:	ds	1
  245                        	
  246    F8:2BB2             	vdc_scr_addr:	ds	2	; 8KByte maximum size.
  247    F8:2BB4             	vdc_scr_bank:	ds	1
  248    F8:2BB5             	vdc_scr_chr12:	ds	1	; Which CHR banks are used by the BLK, with
  249    F8:2BB6             	vdc_scr_chr34:	ds	1	; a max of 16 banks per multi-screen map.
  250                        	
  251               0001     		.if	SUPPORT_SGX
  252                        	
  253                        	; **************
  254                        	; 16-bytes of SGX blkmap info.
  255                        	;
  256                        	; N.B. MUST be 16-bytes after the VDC versions to use SGX_VDC_OFFSET.
  257                        	
  258    F8:2BB7             	sgx_old_chr_x:	ds	1	; Previous top-left X in CHR (lo-byte only).
  259    F8:2BB8             	sgx_old_chr_y:	ds	1	; Previous top-left Y in CHR (lo-byte only).
  260                        	
  261    F8:2BB9             	sgx_tbl_addr:	ds	2	; 256-byte aligned.
  262    F8:2BBB             	sgx_tbl_bank:	ds	1
  263                        	
  264    F8:2BBC             	sgx_blk_addr:	ds	2	; 2KBytes of data, 256-byte aligned.
  265    F8:2BBE             	sgx_blk_bank:	ds	1
  266                        	
  267    F8:2BBF             	sgx_map_addr:	ds	2	; Mapped into MPR3..MPR4, max 8KBytes.
  268    F8:2BC1             	sgx_map_bank:	ds	1
  269                        	
  270    F8:2BC2             	sgx_scr_addr:	ds	2	; 8KByte maximum size.
  271    F8:2BC4             	sgx_scr_bank:	ds	1
  272    F8:2BC5             	sgx_scr_chr12:	ds	1	; Which CHR banks are used by the BLK, with
  273    F8:2BC6             	sgx_scr_chr34:	ds	1	; a max of 16 banks per multi-screen map.
  274                        	
  275                        		.endif	SUPPORT_SGX
  276                        	
  277               0000     		.if	0
  310                        		.endif	0
  311                        	
  312                        	; **************
  313                        	; Aliases for the asm variable names in HuCC.
  314                        	;
  315                        	
  316               0001     		.ifdef	HUCC
  317                        	
  318    F8:2BC7             	_map_blk_flag	.alias	map_blk_flag
  319    F8:2BC7             	_map_blk_mask	.alias	map_blk_mask
  320                        	
  321    F8:2BC7             	_vdc_map_draw_w	.alias	vdc_map_draw_w
  322    F8:2BC7             	_vdc_map_draw_h	.alias	vdc_map_draw_h
  323    F8:2BC7             	_vdc_map_pxl_x	.alias	vdc_map_pxl_x
  324    F8:2BC7             	_vdc_map_pxl_y	.alias	vdc_map_pxl_y
  325    F8:2BC7             	_vdc_old_chr_x	.alias	vdc_old_chr_x
  326    F8:2BC7             	_vdc_old_chr_y	.alias	vdc_old_chr_y
  327    F8:2BC7             	_vdc_tbl_addr	.alias	vdc_tbl_addr
  328    F8:2BC7             	_vdc_tbl_bank	.alias	vdc_tbl_bank
  329    F8:2BC7             	_vdc_blk_addr	.alias	vdc_blk_addr
  330    F8:2BC7             	_vdc_blk_bank	.alias	vdc_blk_bank
  331    F8:2BC7             	_vdc_map_line_w	.alias	vdc_map_line_w
  332    F8:2BC7             	_vdc_map_scrn_w	.alias	vdc_map_scrn_w
  333    F8:2BC7             	_vdc_map_addr	.alias	vdc_map_addr
  334    F8:2BC7             	_vdc_map_bank	.alias	vdc_map_bank
  335    F8:2BC7             	_vdc_scr_addr	.alias	vdc_scr_addr
  336    F8:2BC7             	_vdc_scr_bank	.alias	vdc_scr_bank
  337    F8:2BC7             	_vdc_scr_chr12	.alias	vdc_scr_chr12
  338    F8:2BC7             	_vdc_scr_chr34	.alias	vdc_scr_chr34
  339                        	
  340               0001     		.if	SUPPORT_SGX
  341    F8:2BC7             	_sgx_map_draw_w	.alias	sgx_map_draw_w
  342    F8:2BC7             	_sgx_map_draw_h	.alias	sgx_map_draw_h
  343    F8:2BC7             	_sgx_map_pxl_x	.alias	sgx_map_pxl_x
  344    F8:2BC7             	_sgx_map_pxl_y	.alias	sgx_map_pxl_y
  345    F8:2BC7             	_sgx_old_chr_x	.alias	sgx_old_chr_x
  346    F8:2BC7             	_sgx_old_chr_y	.alias	sgx_old_chr_y
  347    F8:2BC7             	_sgx_tbl_addr	.alias	sgx_tbl_addr
  348    F8:2BC7             	_sgx_tbl_bank	.alias	sgx_tbl_bank
  349    F8:2BC7             	_sgx_blk_addr	.alias	sgx_blk_addr
  350    F8:2BC7             	_sgx_blk_bank	.alias	sgx_blk_bank
  351    F8:2BC7             	_sgx_map_line_w	.alias	sgx_map_line_w
  352    F8:2BC7             	_sgx_map_scrn_w	.alias	sgx_map_scrn_w
  353    F8:2BC7             	_sgx_map_addr	.alias	sgx_map_addr
  354    F8:2BC7             	_sgx_map_bank	.alias	sgx_map_bank
  355    F8:2BC7             	_sgx_scr_addr	.alias	sgx_scr_addr
  356    F8:2BC7             	_sgx_scr_bank	.alias	sgx_scr_bank
  357    F8:2BC7             	_sgx_scr_chr12	.alias	sgx_scr_chr12
  358    F8:2BC7             	_sgx_scr_chr34	.alias	sgx_scr_chr34
  359                        		.endif	SUPPORT_SGX
  360                        	
  361                        		.endif	HUCC
  362                        	
  363                        	; **************
  364                        	; Temporary variables for drawing, using common zero-page locations.
  365                        	;
  366                        	
  367               20F8     	map_bat_x	=	_al	; Set by draw_map(), scroll_map() if drawing
  368               20F9     	map_bat_y	=	_ah	; aligned, or as parameters to blit_map().
  369                        	
  370               20FA     	map_draw_w	=	_bl	; Set by draw_map(), scroll_map(), but given
  371               20FB     	map_draw_h	=	_bh	; as parameters to blit_map().
  372                        	
  373               20FC     	map_pxl_x	=	_cx	; Set by draw_map(), scroll_map() and also by
  374               20FC     	map_chr_x	=	_cl	; blit__map(), from current vdc_map_pxl_x.
  375               20FD     	map_scrn_x	=	_ch
  376                        	
  377               20FE     	map_pxl_y	=	_dx	; Set by draw_map(), scroll_map() and also by
  378               20FE     	map_chr_y	=	_dl	; blit__map(), from current vdc_map_pxl_y.
  379               20FF     	map_scrn_y	=	_dh
  380                        	
  381               20EE     	map_line	=	_si	; Start of map data line being drawn.
  382                        	
  383               2000     	map_count	=	__temp + 0
  384               2001     	map_drawn	=	__temp + 1
  385                        	
  386               E937     			.code
  387                        	
  388                        	
  389                        	
  390    01:D65B             	blkmap_group	.procgroup
  391                        	
  392                        	; ***************************************************************************
  393                        	; ***************************************************************************
  394                        	;
  395                        	; _set_blocks - Initialize the block definition pointers.
  396                        	; _sgx_set_blocks - Initialize the block definition pointers.
  397                        	;
  398                        	; void __fastcall set_blocks( unsigned char __far *blk_def<vdc_blk_bank:vdc_blk_addr>, unsigned char __far *flg_def<vdc_tbl_bank:vdc_tbl_addr>, unsigned char number_of_blk<_al> );
  399                        	; void __fastcall sgx_set_blocks( unsigned char __far *blk_def<sgx_blk_bank:sgx_blk_addr>, unsigned char __far *flg_def<sgx_tbl_bank:sgx_tbl_addr>, unsigned char number_of_blk<_al> );
  400                        	;
  401                        	
  402               0001     		.if	SUPPORT_SGX
  403                        	
  404    01:D65B             			.proc	_sgx_set_blocks.3
  405                        	
  406    01:D65B  A2 10      			ldx	#SGX_VDC_OFFSET		; Offset to SGX VDC.
  407    01:D65D  F0         			db	$F0			; Turn "clx" into a "beq".
  408                        	
  409    01:D65E             			.ref	_set_blocks.3
  410                        			.endp
  411                        		.endif
  412                        	
  413    01:D65E             			.proc	_set_blocks.3
  414                        	
  415    01:D65E  82         			clx				; Offset to PCE VDC.
  416                        	
  417    01:D65F  BD AA 2B   			lda.h	vdc_tbl_addr, x		; Remap the address to MPR2.
  418    01:D662  29 1F      			and	#$1F
  419    01:D664  09 40      			ora	#$40
  420    01:D666  9D AA 2B   			sta.h	vdc_tbl_addr, x
  421                        	
  422    01:D669  BD AD 2B   			lda.h	vdc_blk_addr, x		; Remap the address to MPR2.
  423    01:D66C  29 1F      			and	#$1F
  424    01:D66E  09 40      			ora	#$40
  425    01:D670  9D AD 2B   			sta.h	vdc_blk_addr, x
  426                        	
  427               0000     		.if	BLKDEF_POINTERS
  479                        		.endif	BLKDEF_POINTERS
  480                        	
  481                        			leave
         01:D673  4C EF FF   			jmp	leave_proc
  482                        	
  483                        			.endp
  484                        	
  485                        	
  486                        	
  487                        	; ***************************************************************************
  488                        	; ***************************************************************************
  489                        	;
  490                        	; _draw_map - Draw the entire screen at the current coordinates.
  491                        	; _sgx_draw_map - Draw the entire screen at the current coordinates.
  492                        	;
  493                        	; void __fastcall draw_map( void );
  494                        	; void __fastcall sgx_draw_map( void );
  495                        	;
  496                        	
  497               0001     		.if	SUPPORT_SGX
  498                        	
  499    01:D676             	_sgx_draw_map	.proc
  500                        	
  501    01:D676  A2 10      			ldx	#SGX_VDC_OFFSET		; Offset to SGX VDC.
  502    01:D678  F0         			db	$F0			; Turn "clx" into a "beq".
  503                        	
  504    01:D679             			.ref	_draw_map
  505                        			.endp
  506                        		.endif
  507                        	
  508    01:D679             	_draw_map	.proc
  509                        	
  510    01:D679  82         			clx				; Offset to PCE VDC.
  511                        	
  512    01:D67A  43 04      			tma2				; Preserve MPR2..MPR4.
  513    01:D67C  48         			pha
  514    01:D67D  43 08      			tma3
  515    01:D67F  48         			pha
  516    01:D680  43 10      			tma4
  517    01:D682  48         			pha
  518               0000     		.if	BLKMAP_LARGEMAP
  521                        		.endif
  522                        	
  523    01:D683  20 85 D7   			jsr	map_pxl_2_chr		; Set up the draw coordinates.
  524                        	
  525    01:D686  A5 FC      			lda	<map_chr_x		; Reset previous X position.
  526    01:D688  9D A7 2B   			sta	vdc_old_chr_x, x
  527                        	
  528    01:D68B  A5 FE      			lda	<map_chr_y		; Reset previous Y position,
  529    01:D68D  1A         			inc	a			; ready to draw multiple rows.
  530    01:D68E  9D A8 2B   			sta	vdc_old_chr_y, x
  531                        	
  532    01:D691  BD 70 26   			lda	vdc_map_draw_w, x	; Draw the whole screen.
  533    01:D694  85 FA      			sta	<map_draw_w
  534    01:D696  BD 71 26   			lda	vdc_map_draw_h, x
  535    01:D699  85 FB      			sta	<map_draw_h
  536                        	
  537    01:D69B  20 DB D9   			jsr	map_scroll_y		; Draw N row of CHR to the BAT.
  538                        	
  539               0000     		.if	BLKMAP_LARGEMAP
  542                        		.endif
  543    01:D69E  68         			pla				; Restore MPR2..MPR4.
  544    01:D69F  53 10      			tam4
  545    01:D6A1  68         			pla
  546    01:D6A2  53 08      			tam3
  547    01:D6A4  68         			pla
  548    01:D6A5  53 04      			tam2
  549                        	
  550                        			leave
         01:D6A7  4C EF FF   			jmp	leave_proc
  551                        	
  552                        			.endp
  553                        	
  554                        	
  555                        	
  556                        	; ***************************************************************************
  557                        	; ***************************************************************************
  558                        	;
  559                        	; _scroll_map - Draw a single row of CHR into the BAT to update the edge.
  560                        	; _sgx_scroll_map - Draw a single row of CHR into the BAT to update the edge.
  561                        	;
  562                        	; void __fastcall scroll_map( void );
  563                        	; void __fastcall sgx_scroll_map( void );
  564                        	;
  565                        	
  566               0001     		.if	SUPPORT_SGX
  567                        	
  568    01:D6AA             	_sgx_scroll_map	.proc
  569                        	
  570    01:D6AA  A2 10      			ldx	#SGX_VDC_OFFSET		; Offset to SGX VDC.
  571    01:D6AC  F0         			db	$F0			; Turn "clx" into a "beq".
  572                        	
  573    01:D6AD             			.ref	_scroll_map
  574                        			.endp
  575                        		.endif
  576                        	
  577    01:D6AD             	_scroll_map	.proc
  578                        	
  579    01:D6AD  82         			clx				; Offset to PCE VDC.
  580                        	
  581               0000     		.if	BLKMAP_TIMETEST
  587                        		.endif
  588                        	
  589    01:D6AE  43 04      			tma2				; Preserve MPR2..MPR4.
  590    01:D6B0  48         			pha
  591    01:D6B1  43 08      			tma3
  592    01:D6B3  48         			pha
  593    01:D6B4  43 10      			tma4
  594    01:D6B6  48         			pha
  595               0000     		.if	BLKMAP_LARGEMAP
  598                        		.endif
  599                        	
  600    01:D6B7  20 85 D7   			jsr	map_pxl_2_chr		; Set up the draw coordinates.
  601                        	
  602               0001     		.if	BLKMAP_MULTISCR
  603    01:D6BA  A5 FD      			lda	<map_scrn_x		; map_scroll_x can change this!
  604    01:D6BC  48         			pha
  605                        		.endif
  606                        	
  607    01:D6BD  BD 71 26   			lda	vdc_map_draw_h, x	; Draw new LHS or RHS if needed.
  608    01:D6C0  85 FB      			sta	<map_draw_h
  609                        	;		lda	#1			; map_scroll_x only ever draws a
  610                        	;		sta	<map_draw_w		; single column.
  611    01:D6C2  20 BC D8   			jsr	map_scroll_x
  612                        	
  613    01:D6C5  BD A7 2B   			lda	vdc_old_chr_x, x	; Restore map_chr_x which could
  614    01:D6C8  85 FC      			sta	<map_chr_x		; be changed by map_scroll_x.
  615                        	
  616               0001     		.if	BLKMAP_MULTISCR
  617    01:D6CA  68         			pla				; Restore before map_scroll_y.
  618    01:D6CB  85 FD      			sta	<map_scrn_x
  619                        		.endif
  620                        	
  621    01:D6CD  BD 70 26   			lda	vdc_map_draw_w, x	; Draw new TOP or BTM if needed.
  622    01:D6D0  85 FA      			sta	<map_draw_w
  623    01:D6D2  A9 01      			lda	#1
  624    01:D6D4  85 FB      			sta	<map_draw_h
  625    01:D6D6  20 DB D9   			jsr	map_scroll_y
  626                        	
  627               0000     		.if	BLKMAP_LARGEMAP
  630                        		.endif
  631    01:D6D9  68         			pla				; Restore MPR2..MPR4.
  632    01:D6DA  53 10      			tam4
  633    01:D6DC  68         			pla
  634    01:D6DD  53 08      			tam3
  635    01:D6DF  68         			pla
  636    01:D6E0  53 04      			tam2
  637                        	
  638               0000     		.if	BLKMAP_TIMETEST
  640                        		.endif
  641                        	
  642                        			leave
         01:D6E2  4C EF FF   			jmp	leave_proc
  643                        	
  644                        			.endp
  645                        	
  646                        	
  647                        	
  648                        	; ***************************************************************************
  649                        	; ***************************************************************************
  650                        	;
  651                        	; _blit_map - Draw a map rectangle to specific BAT coordinates.
  652                        	; _sgx_blit_map - Draw a map rectangle to specific BAT coordinates.
  653                        	;
  654                        	; void __fastcall blit_map( unsigned char tile_x<map_bat_x>, unsigned char tile_y<map_bat_y>, unsigned char tile_w<map_draw_x>, unsigned char tile_h<map_draw_y> );
  655                        	; void __fastcall sgx_blit_map( unsigned char tile_x<map_bat_x>, unsigned char tile_y<map_bat_y>, unsigned char tile_w<map_draw_x>, unsigned char tile_h<map_draw_y> );
  656                        	;
  657                        	; Normally you'd just use _draw_map() and _scroll_map(), but for those folks
  658                        	; who really wish to take manual control, you can use this.
  659                        	;
  660                        	
  661               0001     		.if	SUPPORT_SGX
  662                        	
  663                        	_sgx_blit_map	.proc
  669                        			.endp
  670                        		.endif
  671                        	
  672    01:D6E5             	_blit_map	.proc
  673                        	
  674    01:D6E5  82         			clx				; Offset to PCE VDC.
  675                        	
  676    01:D6E6  BD B4 2B   			lda	vdc_scr_bank, x		; Skip this if a multi-screen
  677    01:D6E9  D0 36      			bne	.exit			; blkmap.
  678                        	
  679    01:D6EB  43 04      			tma2				; Preserve MPR2..MPR4.
  680    01:D6ED  48         			pha
  681    01:D6EE  43 08      			tma3
  682    01:D6F0  48         			pha
  683    01:D6F1  43 10      			tma4
  684    01:D6F3  48         			pha
  685               0000     		.if	BLKMAP_LARGEMAP
  688                        		.endif
  689                        	
  690    01:D6F4  BD 78 26   			lda	vdc_map_option, x	; Preserve current map options.
  691    01:D6F7  48         			pha
  692    01:D6F8  09 C0      			ora	#MAP_UNALIGNED_X | MAP_UNALIGNED_Y
  693    01:D6FA  9D 78 26   			sta	vdc_map_option, x
  694                        	
  695    01:D6FD  20 85 D7   			jsr	map_pxl_2_chr		; Set up the draw coordinates.
  696                        	
  697    01:D700  A5 FA      			lda	<map_draw_w		; Are we drawing just 1 column?
  698    01:D702  C9 01      			cmp	#1
  699    01:D704  F0 1E      			beq	.draw_column
  700                        	
  701                        			; Draw N rows.
  702                        	
  703    01:D706  A5 FC      	.draw_rows:	lda	<map_chr_x		; Reset previous X position.
  704    01:D708  9D A7 2B   			sta	vdc_old_chr_x, x
  705                        	
  706    01:D70B  A5 FE      			lda	<map_chr_y		; Reset previous Y position,
  707    01:D70D  1A         			inc	a			; ready to draw rows upwards.
  708    01:D70E  9D A8 2B   			sta	vdc_old_chr_y, x
  709                        	
  710    01:D711  20 DB D9   			jsr	map_scroll_y		; Draw a row of CHR to the BAT.
  711                        	
  712                        			; Drawing completed.
  713                        	
  714    01:D714  68         	.finished:	pla				; Restore previous map options.
  715    01:D715  9D 78 26   			sta	vdc_map_option, x
  716                        	
  717               0000     		.if	BLKMAP_LARGEMAP
  720                        		.endif
  721    01:D718  68         			pla				; Restore MPR2..MPR4.
  722    01:D719  53 10      			tam4
  723    01:D71B  68         			pla
  724    01:D71C  53 08      			tam3
  725    01:D71E  68         			pla
  726    01:D71F  53 04      			tam2
  727                        	
  728                        	.exit:		leave
         01:D721  4C EF FF   			jmp	leave_proc
  729                        	
  730                        			; Draw 1 column.
  731                        	
  732    01:D724  A5 FC      	.draw_column:	lda	<map_chr_x		; Reset previous X position.
  733    01:D726  1A         			inc	a			; ready to draw 1 column.
  734    01:D727  9D A7 2B   			sta	vdc_old_chr_x, x
  735                        	
  736    01:D72A  A5 FE      			lda	<map_chr_y		; Reset previous Y position.
  737    01:D72C  9D A8 2B   			sta	vdc_old_chr_y, x
  738                        	
  739    01:D72F  20 BC D8   			jsr	map_scroll_x		; Draw a single column of CHR.
  740                        	
  741    01:D732  80 E0      			bra	.finished
  742                        	
  743                        			.endp
  744                        	
  745                        	
  746                        	
  747                        	; ***************************************************************************
  748                        	; ***************************************************************************
  749                        	;
  750                        	; _get_map_block - Get the block number used at a map pixel coordinate.
  751                        	; _sgx_get_map_block - Get the block number used at a map pixel coordinate.
  752                        	;
  753                        	; unsigned char __fastcall _get_map_block( unsigned int x<map_pxl_x>, unsigned int y<map_pxl_y> );
  754                        	; unsigned char __fastcall _sgx_get_map_block( unsigned int x<map_pxl_x>, unsigned int y<map_pxl_y> );
  755                        	;
  756                        	
  757               0001     		.if	SUPPORT_SGX
  758                        	
  759                        			.proc	_sgx_get_map_block.2
  765                        			.endp
  766                        		.endif
  767                        	
  768    01:D734             			.proc	_get_map_block.2
  769                        	
  770    01:D734  82         			clx				; Offset to PCE VDC.
  771                        	
  772    01:D735  43 04      			tma2				; Preserve MPR2..MPR4.
  773    01:D737  48         			pha
  774    01:D738  43 08      			tma3
  775    01:D73A  48         			pha
  776    01:D73B  43 10      			tma4
  777    01:D73D  48         			pha
  778               0000     		.if	BLKMAP_LARGEMAP
  781                        		.endif
  782                        	
  783    01:D73E  20 99 D7   			jsr	xvt_pxl_2_chr		; Set up the query coordinates.
  784                        	
  785    01:D741  20 C7 D7   			jsr	map_chr_2_data		; Page in the map address.
  786                        	
  787    01:D744  B2 EC      			lda	[_bp]			; Read the BLK from the map.
  788    01:D746  A8         			tay
  789                        	
  790    01:D747  A5 FC      			lda	<map_chr_x		; Calc the BLK address offset
  791    01:D749  4A         			lsr	a			; use depending upon even/odd
  792    01:D74A  A5 FE      			lda	<map_chr_y		; CHR coordinates (not BAT to
  793    01:D74C  29 01      			and	#1			; support unaligned drawing).
  794    01:D74E  2A         			rol	a
  795    01:D74F  09 04      			ora	#4			; Offset to BLK table top byte.
  796    01:D751  7D AD 2B   			adc.h	vdc_blk_addr, x		; What is the BLK data address?
  797    01:D754  85 ED      			sta.h	<_bp			; $4000, $4800, $5000 or $5800.
  798    01:D756  64 EC      			stz.l	<_bp
  799    01:D758  B1 EC      			lda	[_bp], y		; Read the collision flags from
  800    01:D75A  29 0C      			and	#%00001100		; the top byte of the CHR.
  801    01:D75C  4A         			lsr	a
  802    01:D75D  4A         			lsr	a
  803    01:D75E  4A         			lsr	a			; Swizzle the bottom bit to get
  804    01:D75F  90 02      			bcc	!+			; the same bit order as used in
  805    01:D761  09 02      			ora	#2			; .HALTMAP layer.
  806    01:D763  8D A5 2B   	!:		sta	map_blk_flag
  807                        	
  808    01:D766  BD AB 2B   			lda	vdc_tbl_bank, x		; Is there a table of flags?
  809    01:D769  F0 09      			beq	!+
  810    01:D76B  53 08      			tam3
  811                        	;		inc	a
  812                        	;		tam4
  813                        	;		lda.l	vdc_tbl_addr, x
  814                        	;		sta.l	<_bp
  815    01:D76D  BD AA 2B   			lda.h	vdc_tbl_addr, x		; If so, it must be aligned!
  816    01:D770  85 ED      			sta.h	<_bp
  817    01:D772  B1 EC      			lda	[_bp], y		; Read the .MASKMAP/.OVERMAP
  818    01:D774  8D A6 2B   	!:		sta	map_blk_mask		; flag value for this BLK.
  819                        	
  820               0000     		.if	BLKMAP_LARGEMAP
  823                        		.endif
  824    01:D777  68         			pla				; Restore MPR2..MPR4.
  825    01:D778  53 10      			tam4
  826    01:D77A  68         			pla
  827    01:D77B  53 08      			tam3
  828    01:D77D  68         			pla
  829    01:D77E  53 04      			tam2
  830                        	
  831    01:D780  02         			sxy				; Put the BLK number in X.
  832    01:D781  C2         			cly
  833                        	
  834                        			leave				; All done!
         01:D782  4C EF FF   			jmp	leave_proc
  835                        	
  836                        			.endp
  837                        	
  838                        	
  839                        	
  840                        	; ***************************************************************************
  841                        	; ***************************************************************************
  842                        	;
  843                        	; map_pxl_2_chr - Convert PXL to CHR, BLK and SCR coordinates.
  844                        	;
  845                        	
  846    01:D785  BD 76 26   	map_pxl_2_chr:	lda.l	vdc_map_pxl_y, x	; Get current map Y coordinate.
  847    01:D788  85 FE      			sta.l	<map_pxl_y
  848    01:D78A  BD 77 26   			lda.h	vdc_map_pxl_y, x
  849    01:D78D  85 FF      			sta.h	<map_pxl_y
  850                        	
  851    01:D78F  BD 74 26   			lda.l	vdc_map_pxl_x, x	; Get current map X coordinate.
  852    01:D792  85 FC      			sta.l	<map_pxl_x
  853    01:D794  BD 75 26   			lda.h	vdc_map_pxl_x, x
  854    01:D797  85 FD      			sta.h	<map_pxl_x
  855                        	
  856    01:D799  A5 FD      	xvt_pxl_2_chr:	lda.h	<map_pxl_x		; Xvert map_pxl_x to map_chr_x.
  857               0001     		.if	BLKMAP_MULTISCR
  858    01:D79B  A8         			tay				; Xvert map_pxl_x to map_scrn_x.
  859    01:D79C  3C 6B 26   			bit	vdc_bat_width, x
  860    01:D79F  70 03      			bvs	.w64
  861    01:D7A1  10 02      			bpl	.w32
  862    01:D7A3  4A         	.w128:		lsr	a
  863    01:D7A4  4A         	.w64:		lsr	a
  864    01:D7A5  85 FD      	.w32:		sta	<map_scrn_x
  865    01:D7A7  98         			tya
  866                        		.endif
  867    01:D7A8  4A         			lsr	a
  868    01:D7A9  66 FC      			ror.l	<map_pxl_x
  869    01:D7AB  4A         			lsr	a
  870    01:D7AC  66 FC      			ror.l	<map_pxl_x
  871    01:D7AE  4A         			lsr	a
  872    01:D7AF  66 FC      			ror.l	<map_pxl_x		; Max map width is 256 CHR.
  873                        	
  874    01:D7B1  A5 FF      			lda.h	<map_pxl_y		; Xvert map_pxl_y to map_chr_y.
  875               0001     		.if	BLKMAP_MULTISCR
  876    01:D7B3  A8         			tay				; Xvert map_pxl_y to map_scrn_y.
  877    01:D7B4  3C 6C 26   			bit	vdc_bat_height, x
  878    01:D7B7  50 01      			bvc	.h32
  879    01:D7B9  4A         	.h64:		lsr	a
  880    01:D7BA  85 FF      	.h32:		sta	<map_scrn_y
  881    01:D7BC  98         			tya
  882                        		.endif
  883    01:D7BD  4A         			lsr	a
  884    01:D7BE  66 FE      			ror.l	<map_pxl_y
  885    01:D7C0  4A         			lsr	a
  886    01:D7C1  66 FE      			ror.l	<map_pxl_y
  887    01:D7C3  4A         			lsr	a
  888    01:D7C4  66 FE      			ror.l	<map_pxl_y		; Max map width is 256 CHR.
  889                        	
  890    01:D7C6  60         			rts
  891                        	
  892                        	
  893                        	
  894                        	; ***************************************************************************
  895                        	; ***************************************************************************
  896                        	;
  897                        	; map_chr_2_data - Page in the MAP address for the CHR coordinates.
  898                        	;
  899                        	
  900    01:D7C7             	map_chr_2_data:
  901                        	
  902               0001     		.if	BLKMAP_MULTISCR
  903                        	
  904                        			; Initialization for a multi-screen map.
  905                        	
  906    01:D7C7  BD B4 2B   			lda	vdc_scr_bank, x		; Skip this if regular blkmap.
  907    01:D7CA  F0 3A      			beq	.regular
  908                        	
  909    01:D7CC  A5 FC      	.multiscreen:	lda	<map_chr_x		; Compare old_x with cur_x.
  910    01:D7CE  3D 6D 26   			and	vdc_bat_x_mask, x
  911    01:D7D1  85 F8      			sta	<map_bat_x		; Save BAT X chr coordinate.
  912                        	
  913    01:D7D3  A5 FE      			lda	<map_chr_y		; Save BAT Y chr coordinate.
  914    01:D7D5  3D 6E 26   			and	vdc_bat_y_mask, x
  915    01:D7D8  85 F9      			sta	<map_bat_y
  916    01:D7DA  4A         			lsr	a			; Map BLK Y coordinate.
  917    01:D7DB  85 EF      			sta.h	<map_line
  918    01:D7DD  62         			cla
  919    01:D7DE  3C 6B 26   			bit	vdc_bat_width, x
  920    01:D7E1  30 08      			bmi	.w128
  921    01:D7E3  70 03      			bvs	.w64
  922    01:D7E5  46 EF      	.w32:		lsr.h	<map_line
  923    01:D7E7  6A         			ror	a
  924    01:D7E8  46 EF      	.w64:		lsr.h	<map_line
  925    01:D7EA  6A         			ror	a
  926    01:D7EB  46 EF      	.w128:		lsr.h	<map_line
  927    01:D7ED  6A         			ror	a
  928    01:D7EE  46 EF      			lsr.h	<map_line		; Hi-byte of (BLK Y * width).
  929    01:D7F0  6A         			ror	a
  930    01:D7F1  85 EE      			sta.l	<map_line		; Lo-byte of (BLK Y * width).
  931                        	
  932    01:D7F3  20 47 D8   			jsr	map_set_screen		; Put BLK & MAP in MPR2-MPR5.
  933                        	
  934    01:D7F6  A5 F8      			lda	<map_bat_x		; Calc map data pointer.
  935    01:D7F8  4A         			lsr	a			; Map BLK X coordinate.
  936    01:D7F9  05 EE      			ora.l	<map_line
  937    01:D7FB  85 EC      			sta.l	<_bp
  938    01:D7FD  A5 EF      			lda.h	<map_line
  939    01:D7FF  18         			clc
  940    01:D800  7D B0 2B   			adc.h	vdc_map_addr, x		; N.B. 256-byte aligned!
  941    01:D803  85 ED      			sta.h	<_bp
  942                        	
  943    01:D805  60         			rts
  944                        	
  945                        		.endif	BLKMAP_MULTISCR
  946                        	
  947                        			; Initialization for a regular map.
  948                        	
  949    01:D806  A5 FC      	.regular:	lda	<map_chr_x		; Compare old_x with cur_x.
  950                        	;		bit	vdc_map_option, x	; Set bit7 to disable aligning
  951                        	;		bmi	!+			; BAT X with the map X.
  952    01:D808  3D 6D 26   			and	vdc_bat_x_mask, x
  953    01:D80B  85 F8      			sta	<map_bat_x		; Save BAT X chr coordinate.
  954                        	
  955    01:D80D  A5 FE      	!:		lda	<map_chr_y		; A = map CHR Y coordinate.
  956    01:D80F  A8         			tay
  957    01:D810  4A         			lsr	a
  958    01:D811  42         			say				; Y = map BLK Y coordinate.
  959                        	
  960                        	;		bit	vdc_map_option, x	; Set bit6 to disable aligning
  961                        	;		bvs	!+			; BAT Y with the map Y.
  962    01:D812  3D 6E 26   			and	vdc_bat_y_mask, x
  963    01:D815  85 F9      			sta	<map_bat_y		; Save BAT Y chr coordinate.
  964                        	
  965               0000     		.if	BLKMAP_LARGEMAP
  970                        		.endif
  971                        	
  972    01:D817  BD 72 26   	!:		lda	vdc_map_line_w, x	; Map width in BLK.
  973               0000     		.if	FAST_MULTIPLY
  986                        		.else
  987    01:D81A  84 EF      			sty.h	<map_line		; Takes 144..176 cycles.
  988    01:D81C  A0 08      			ldy	#8
  989    01:D81E  4A         			lsr	a
  990    01:D81F  85 EE      			sta.l	<map_line
  991    01:D821  62         			cla
  992    01:D822  90 03      			bcc	.rotate
  993    01:D824  18         	.add:		clc
  994    01:D825  65 EF      			adc.h	<map_line
  995    01:D827  6A         	.rotate:	ror	a
  996    01:D828  66 EE      			ror.l	<map_line		; Lo-byte of (BLK Y * width).
  997    01:D82A  88         			dey
  998    01:D82B  B0 F7      			bcs	.add
  999    01:D82D  D0 F8      			bne	.rotate
 1000    01:D82F  A8         			tay				; Hi-byte of (BLK Y * width).
 1001                        		.endif
 1002                        	
 1003    01:D830  A5 FC      	!:		lda	<map_chr_x		; Map CHR X coordinate.
 1004    01:D832  4A         			lsr	a			; Map BLK X coordinate.
 1005    01:D833  18         			clc
 1006    01:D834  65 EE      			adc.l	<map_line		; Lo-byte of (BLK Y * width).
 1007    01:D836  90 01      			bcc	!+
 1008    01:D838  C8         			iny				; Hi-byte of (BLK Y * width).
 1009                        	
 1010    01:D839  18         	!:		clc				; Calc map data pointer.
 1011    01:D83A  7D AF 2B   			adc.l	vdc_map_addr, x
 1012    01:D83D  85 EC      			sta.l	<_bp			; Maximum map size is 16KBytes
 1013    01:D83F  98         			tya				; so we don't need to consider
 1014    01:D840  7D B0 2B   			adc.h	vdc_map_addr, x		; bank overflow.
 1015    01:D843  85 ED      			sta.h	<_bp
 1016                        	
 1017    01:D845  80 66      			bra	map_set_banks		; Put BLK & MAP in MPR2-MPR5.
 1018                        	
 1019                        	
 1020                        	
 1021               0001     		.if	BLKMAP_MULTISCR
 1022                        	
 1023                        	; ***************************************************************************
 1024                        	; ***************************************************************************
 1025                        	;
 1026                        	; map_set_screen -
 1027                        	;
 1028                        	; Maximum X and Y dimension of 128 screens (32768 pixels).
 1029                        	; Maximum 8KByte total size of screen data (1024 screens).
 1030                        	;
 1031                        	
 1032    01:D847  A4 FF      	map_set_screen:	ldy	<map_scrn_y		; Map SCR Y coordinate.
 1033    01:D849  BD 73 26   			lda	vdc_map_scrn_w, x	; Map width in SCREENS.
 1034                        	
 1035               0000     		.if	FAST_MULTIPLY
 1048                        		.else
 1049    01:D84C  84 ED      			sty.h	<_bp			; Takes 144..176 cycles.
 1050    01:D84E  A0 08      			ldy	#8
 1051    01:D850  4A         			lsr	a
 1052    01:D851  85 EC      			sta.l	<_bp
 1053    01:D853  62         			cla
 1054    01:D854  90 03      			bcc	.rotate
 1055    01:D856  18         	.add:		clc
 1056    01:D857  65 ED      			adc.h	<_bp
 1057    01:D859  6A         	.rotate:	ror	a
 1058    01:D85A  66 EC      			ror.l	<_bp			; Lo-byte of (SCR Y * width).
 1059    01:D85C  88         			dey
 1060    01:D85D  B0 F7      			bcs	.add
 1061    01:D85F  D0 F8      			bne	.rotate
 1062    01:D861  A8         			tay				; Hi-byte of (SCR Y * width).
 1063                        		.endif
 1064                        	
 1065    01:D862  A5 FD      			lda	<map_scrn_x		; Map SCR X coordinate.
 1066    01:D864  18         			clc
 1067    01:D865  65 EC      			adc.l	<_bp
 1068    01:D867  90 01      			bcc	!+
 1069    01:D869  C8         			iny
 1070                        	
 1071    01:D86A  84 ED      	!:		sty.h	<_bp			; 2 bytes per screen entry, max
 1072    01:D86C  0A         			asl	a			; 8KByte screen table.
 1073    01:D86D  26 ED      			rol.h	<_bp
 1074               0001     		.if	BLKDEF_POINTERS == 0
 1075    01:D86F  0A         			asl	a			; 8 bytes per screen entry when
 1076    01:D870  26 ED      			rol.h	<_bp			; not using BLK pointers.
 1077    01:D872  0A         			asl	a
 1078    01:D873  26 ED      			rol.h	<_bp
 1079                        		.endif
 1080                        	
 1081    01:D875  7D B2 2B   			adc.l	vdc_scr_addr, x		; Calc screen data pointer.
 1082    01:D878  85 EC      			sta.l	<_bp			; Maximum data size is 8KBytes
 1083    01:D87A  A5 ED      			lda.h	<_bp			; so we don't need to consider
 1084    01:D87C  7D B3 2B   			adc.h	vdc_scr_addr, x		; bank overflow.
 1085    01:D87F  85 ED      			sta.h	<_bp
 1086                        	
 1087    01:D881  BD B4 2B   			lda	vdc_scr_bank, x		; Map the SCR data in MPR3..MPR4.
 1088    01:D884  53 08      			tam3
 1089    01:D886  1A         			inc	a
 1090    01:D887  53 10      			tam4
 1091                        	
 1092    01:D889  C2         			cly
 1093    01:D88A  B1 EC      			lda	[_bp], y		; Get SCR_MAP_PAGE.
 1094    01:D88C  9D B0 2B   			sta.h	vdc_map_addr, x
 1095    01:D88F  C8         			iny
 1096    01:D890  B1 EC      			lda	[_bp], y		; Get SCR_MAP_BANK.
 1097    01:D892  9D B1 2B   			sta	vdc_map_bank, x
 1098                        	
 1099               0001     		.if	BLKDEF_POINTERS == 0
 1100    01:D895  C8         			iny
 1101    01:D896  B1 EC      			lda	[_bp], y		; Get SCR_BLK_PAGE.
 1102    01:D898  9D AD 2B   			sta.h	vdc_blk_addr, x
 1103    01:D89B  C8         			iny
 1104    01:D89C  B1 EC      			lda	[_bp], y		; Get SCR_BLK_BANK.
 1105    01:D89E  9D AE 2B   			sta	vdc_blk_bank, x
 1106    01:D8A1  C8         			iny
 1107    01:D8A2  B1 EC      			lda	[_bp], y		; Get SCR_TBL_PAGE.
 1108    01:D8A4  9D AA 2B   			sta.h	vdc_tbl_addr, x
 1109    01:D8A7  C8         			iny
 1110    01:D8A8  B1 EC      			lda	[_bp], y		; Get SCR_TBL_BANK.
 1111    01:D8AA  9D AB 2B   			sta	vdc_tbl_bank, x
 1112               0000     		.if	0				; These are not currently used.
 1119                        		.endif
 1120                        		.endif
 1121                        	
 1122                        	;		lda	vdc_bat_width, x	; Set up the map width.
 1123                        	;		lsr	a			; This should have been set
 1124                        	;		sta	vdc_map_line_w, x	; with the multi-screen map.
 1125                        	
 1126                        	;		jmp	map_set_banks		; Put BLK & MAP in MPR2-MPR5.
 1127                        	
 1128                        			; Fall through to map_set_banks.
 1129                        	
 1130                        		.endif	BLKMAP_MULTISCR
 1131                        	
 1132                        	
 1133                        	
 1134                        	; ***************************************************************************
 1135                        	; ***************************************************************************
 1136                        	;
 1137                        	; map_set_banks - Put BLK & MAP in MPR2-MPR5.
 1138                        	;
 1139                        	
 1140    01:D8AD  BD AE 2B   	map_set_banks:	lda	vdc_blk_bank, x		; Put the BLK into MPR2.
 1141    01:D8B0  53 04      			tam2
 1142                        	
 1143    01:D8B2  BD B1 2B   			lda	vdc_map_bank, x		; Put the MAP into MPR3-MPR5.
 1144    01:D8B5  53 08      			tam3
 1145    01:D8B7  1A         			inc	a
 1146    01:D8B8  53 10      			tam4
 1147               0000     		.if	BLKMAP_LARGEMAP
 1156                        		.endif
 1157                        	
 1158    01:D8BA  60         	!:		rts
 1159                        	
 1160                        	
 1161                        	
 1162                        	; ***************************************************************************
 1163                        	; ***************************************************************************
 1164                        	;
 1165                        	; map_scroll_x - Update the BAT when X coordinate changes.
 1166                        	;
 1167                        	; N.B. This will alter map_chr_x and map_scrn_x if moved in +ve direction!
 1168                        	;
 1169                        	; N.B. This only ever draws a single column!
 1170                        	;
 1171                        	
 1172    01:D8BB  60         	!no_change:	rts
 1173                        	
 1174    01:D8BC             	map_scroll_x:
 1175                        	
 1176               0001     		.if	BLKMAP_MULTISCR
 1177                        	
 1178                        			; Initialization for a multi-screen map.
 1179                        	
 1180    01:D8BC  BD B4 2B   			lda	vdc_scr_bank, x		; Skip this if regular blkmap.
 1181    01:D8BF  F0 56      			beq	.regular
 1182                        	
 1183    01:D8C1  A5 FC      	.multiscreen:	lda	<map_chr_x		; Compare old_x with cur_x.
 1184    01:D8C3  DD A7 2B   			cmp	vdc_old_chr_x, x
 1185               0001     		.if	BLKMAP_TIMETEST == 0
 1186    01:D8C6  F0 F3      			beq	!no_change-		; Do nothing if no change.
 1187                        		.endif
 1188    01:D8C8  9D A7 2B   			sta	vdc_old_chr_x, x
 1189    01:D8CB  30 11      			bmi	!+			; Test the sign of the change.
 1190                        	
 1191    01:D8CD  18         			clc				; Draw RHS if chr_x >= old_x.
 1192    01:D8CE  3D 6D 26   			and	vdc_bat_x_mask, x
 1193    01:D8D1  7D 70 26   			adc	vdc_map_draw_w, x	; Usually (SCR_WIDTH / 8) + 1.
 1194    01:D8D4  3A         			dec	a
 1195    01:D8D5  85 FC      			sta	<map_chr_x		; Update CHR X chr coordinate.
 1196    01:D8D7  3C 6B 26   			bit	vdc_bat_width, x
 1197    01:D8DA  F0 02      			beq	!+
 1198    01:D8DC  E6 FD      			inc	<map_scrn_x		; Wrapped to the next screen.
 1199                        	
 1200    01:D8DE  3D 6D 26   	!:		and	vdc_bat_x_mask, x
 1201    01:D8E1  85 F8      			sta	<map_bat_x		; Save BAT X chr coordinate.
 1202                        	
 1203    01:D8E3  A5 FE      			lda	<map_chr_y		; Save BAT Y chr coordinate.
 1204    01:D8E5  3D 6E 26   			and	vdc_bat_y_mask, x
 1205    01:D8E8  85 F9      			sta	<map_bat_y
 1206    01:D8EA  4A         			lsr	a			; Map BLK Y coordinate.
 1207    01:D8EB  85 EF      			sta.h	<map_line
 1208    01:D8ED  62         			cla
 1209    01:D8EE  3C 6B 26   			bit	vdc_bat_width, x
 1210    01:D8F1  30 08      			bmi	.w128
 1211    01:D8F3  70 03      			bvs	.w64
 1212    01:D8F5  46 EF      	.w32:		lsr.h	<map_line
 1213    01:D8F7  6A         			ror	a
 1214    01:D8F8  46 EF      	.w64:		lsr.h	<map_line
 1215    01:D8FA  6A         			ror	a
 1216    01:D8FB  46 EF      	.w128:		lsr.h	<map_line
 1217    01:D8FD  6A         			ror	a
 1218    01:D8FE  46 EF      			lsr.h	<map_line		; Hi-byte of (BLK Y * width).
 1219    01:D900  6A         			ror	a
 1220    01:D901  85 EE      			sta.l	<map_line		; Lo-byte of (BLK Y * width).
 1221                        	
 1222    01:D903  20 47 D8   			jsr	map_set_screen		; Put BLK & MAP in MPR2-MPR5.
 1223                        	
 1224    01:D906  A5 F8      			lda	<map_bat_x		; Calc map data pointer.
 1225    01:D908  4A         			lsr	a			; Map BLK X coordinate.
 1226    01:D909  05 EE      			ora.l	<map_line
 1227    01:D90B  85 EC      			sta.l	<_bp
 1228    01:D90D  A5 EF      			lda.h	<map_line
 1229    01:D90F  18         			clc
 1230    01:D910  7D B0 2B   			adc.h	vdc_map_addr, x		; N.B. 256-byte aligned!
 1231    01:D913  85 ED      			sta.h	<_bp
 1232                        	
 1233    01:D915  80 5D      			bra	.draw_col		; Now draw it.
 1234                        	
 1235                        		.endif	BLKMAP_MULTISCR
 1236                        	
 1237                        			; Initialization for a regular map.
 1238                        	
 1239    01:D917  A5 FC      	.regular:	lda	<map_chr_x		; Compare old_x with cur_x.
 1240    01:D919  DD A7 2B   			cmp	vdc_old_chr_x, x
 1241               0001     		.if	BLKMAP_TIMETEST == 0
 1242    01:D91C  F0 9D      			beq	!no_change-		; Do nothing if no change.
 1243                        		.endif
 1244    01:D91E  9D A7 2B   			sta	vdc_old_chr_x, x
 1245    01:D921  30 07      			bmi	!+			; Test the sign of the change.
 1246                        	
 1247    01:D923  18         			clc				; Draw RHS if chr_x >= old_x.
 1248    01:D924  7D 70 26   			adc	vdc_map_draw_w, x	; Usually (SCR_WIDTH / 8) + 1.
 1249    01:D927  3A         			dec	a
 1250    01:D928  85 FC      			sta	<map_chr_x		; Update CHR X chr coordinate.
 1251                        	
 1252    01:D92A  3C 78 26   	!:		bit	vdc_map_option, x	; Set bit7 to disable aligning
 1253    01:D92D  30 05      			bmi	!+			; BAT X with the map X.
 1254    01:D92F  3D 6D 26   			and	vdc_bat_x_mask, x
 1255    01:D932  85 F8      			sta	<map_bat_x		; Save BAT X chr coordinate.
 1256                        	
 1257    01:D934  A5 FE      	!:		lda	<map_chr_y		; A = map CHR Y coordinate.
 1258    01:D936  A8         			tay
 1259    01:D937  4A         			lsr	a
 1260    01:D938  42         			say				; Y = map BLK Y coordinate.
 1261                        	
 1262    01:D939  3C 78 26   			bit	vdc_map_option, x	; Set bit6 to disable aligning
 1263    01:D93C  70 05      			bvs	!+			; BAT Y with the map Y.
 1264    01:D93E  3D 6E 26   			and	vdc_bat_y_mask, x
 1265    01:D941  85 F9      			sta	<map_bat_y		; Save BAT Y chr coordinate.
 1266                        	
 1267               0000     		.if	BLKMAP_LARGEMAP
 1272                        		.endif
 1273                        	
 1274    01:D943  BD 72 26   	!:		lda	vdc_map_line_w, x	; Map width in BLK.
 1275               0000     		.if	FAST_MULTIPLY
 1288                        		.else
 1289    01:D946  84 EF      			sty.h	<map_line		; Takes 144..176 cycles.
 1290    01:D948  A0 08      			ldy	#8
 1291    01:D94A  4A         			lsr	a
 1292    01:D94B  85 EE      			sta.l	<map_line
 1293    01:D94D  62         			cla
 1294    01:D94E  90 03      			bcc	.rotate
 1295    01:D950  18         	.add:		clc
 1296    01:D951  65 EF      			adc.h	<map_line
 1297    01:D953  6A         	.rotate:	ror	a
 1298    01:D954  66 EE      			ror.l	<map_line		; Lo-byte of (BLK Y * width).
 1299    01:D956  88         			dey
 1300    01:D957  B0 F7      			bcs	.add
 1301    01:D959  D0 F8      			bne	.rotate
 1302    01:D95B  A8         			tay				; Hi-byte of (BLK Y * width).
 1303                        		.endif
 1304                        	
 1305    01:D95C  A5 FC      	!:		lda	<map_chr_x		; Map CHR X coordinate.
 1306    01:D95E  4A         			lsr	a			; Map BLK X coordinate.
 1307    01:D95F  18         			clc
 1308    01:D960  65 EE      			adc.l	<map_line		; Lo-byte of (BLK Y * width).
 1309    01:D962  90 01      			bcc	!+
 1310    01:D964  C8         			iny				; Hi-byte of (BLK Y * width).
 1311                        	
 1312    01:D965  18         	!:		clc				; Calc map data pointer.
 1313    01:D966  7D AF 2B   			adc.l	vdc_map_addr, x
 1314    01:D969  85 EC      			sta.l	<_bp			; Maximum map size is 16KBytes
 1315    01:D96B  98         			tya				; so we don't need to consider
 1316    01:D96C  7D B0 2B   			adc.h	vdc_map_addr, x		; bank overflow.
 1317    01:D96F  85 ED      			sta.h	<_bp
 1318                        	
 1319    01:D971  20 AD D8   			jsr	map_set_banks		; Put BLK & MAP in MPR2-MPR5.
 1320                        	
 1321                        			; Draw the first part of the column.
 1322                        	
 1323    01:D974  A5 F8      	.draw_col:	lda	<map_bat_x		; Set the BAT VRAM destination
 1324    01:D976  85 F0      			sta.l	<_di			; coordinates.
 1325    01:D978  A5 F9      			lda	<map_bat_y
 1326    01:D97A  85 F1      			sta.h	<_di
 1327                        	
 1328    01:D97C  5D 6E 26   			eor	vdc_bat_y_mask, x	; Calc CHR before wrap.
 1329    01:D97F  1A         			inc	a
 1330    01:D980  DD 71 26   			cmp	vdc_map_draw_h, x	; Usually (SCR_HEIGHT / 8) + 1.
 1331    01:D983  90 03      			bcc	!+
 1332    01:D985  BD 71 26   			lda	vdc_map_draw_h, x	; Maximum CHR to draw.
 1333    01:D988  85 00      	!:		sta	<map_count		; Set number of CHR to draw.
 1334    01:D98A  85 01      			sta	<map_drawn		; Preserve number of CHR drawn.
 1335                        	
 1336    01:D98C  A9 05      			lda	#VDC_CR			; Set VDC auto-increment from
 1337    01:D98E  95 F7      			sta	<vdc_reg, x		; the BAT width, which is set
 1338    01:D990  9D 00 02   			sta	VDC_AR, x		; up by set_screen_size().
 1339    01:D993  B5 F4      			lda	<vdc_crh, x
 1340    01:D995  9D 03 02   			sta	VDC_DH, x
 1341                        	
 1342    01:D998  20 DA DC   			jsr	blk_col_strip		; Draw top of vertical strip.
 1343                        	
 1344                        			; Wrap around and draw the rest of the column (if needed).
 1345                        	
 1346    01:D99B  38         			sec				; Are there any more CHR that
 1347    01:D99C  BD 71 26   			lda	vdc_map_draw_h, x	; need to be drawn?
 1348    01:D99F  E5 01      			sbc	<map_drawn
 1349    01:D9A1  F0 2C      			beq	.done
 1350                        	
 1351    01:D9A3  85 00      			sta	<map_count		; Set number of CHR to draw.
 1352                        	
 1353    01:D9A5  A5 FE      			lda	<map_chr_y		; Update CHR Y coordinate for
 1354    01:D9A7  48         			pha				; drawing unaligned tiles.
 1355    01:D9A8  18         			clc
 1356    01:D9A9  65 01      			adc	<map_drawn
 1357    01:D9AB  85 FE      			sta	<map_chr_y
 1358                        	
 1359               0001     		.if	BLKMAP_MULTISCR
 1360    01:D9AD  BD B4 2B   			lda	vdc_scr_bank, x		; Skip this if regular blkmap.
 1361    01:D9B0  F0 0F      			beq	!+
 1362                        	
 1363    01:D9B2  E6 FF      			inc	<map_scrn_y		; Wrapped to the next screen.
 1364                        	
 1365    01:D9B4  20 47 D8   			jsr	map_set_screen		; Put BLK & MAP in MPR2-MPR5.
 1366                        	
 1367    01:D9B7  A5 F8      			lda	<map_bat_x		; Calc map data pointer.
 1368    01:D9B9  4A         			lsr	a			; Map BLK X coordinate.
 1369    01:D9BA  85 EC      			sta.l	<_bp
 1370    01:D9BC  BD B0 2B   			lda.h	vdc_map_addr, x		; N.B. 256-byte aligned!
 1371    01:D9BF  85 ED      			sta.h	<_bp
 1372                        		.endif
 1373                        	
 1374    01:D9C1  A5 F8      	!:		lda	<map_bat_x		; Set the BAT VRAM destination
 1375    01:D9C3  85 F0      			sta.l	<_di			; coordinates.
 1376    01:D9C5  64 F1      			stz.h	<_di			; Reset 1st row to draw.
 1377                        	
 1378    01:D9C7  20 DA DC   			jsr	blk_col_strip		; Draw btm of vertical strip.
 1379                        	
 1380               0001     		.if	BLKMAP_MULTISCR
 1381    01:D9CA  C6 FF      			dec	<map_scrn_y		; Restore, no check if should.
 1382                        		.endif
 1383                        	
 1384    01:D9CC  68         			pla				; Restore CHR Y coordinate, we
 1385    01:D9CD  85 FE      			sta	<map_chr_y		; might draw another column!
 1386                        	
 1387    01:D9CF  A9 05      	.done:		lda	#VDC_CR			; Set VDC auto-increment to 1.
 1388    01:D9D1  95 F7      			sta	<vdc_reg, x
 1389    01:D9D3  9D 00 02   			sta	VDC_AR, x
 1390    01:D9D6  9E 03 02   			stz	VDC_DH, x
 1391                        	
 1392    01:D9D9  60         			rts
 1393                        	
 1394                        	
 1395                        	
 1396                        	; ***************************************************************************
 1397                        	; ***************************************************************************
 1398                        	;
 1399                        	; map_scroll_y - Update the BAT when Y coordinate changes.
 1400                        	;
 1401                        	; N.B. This will alter map_chr_y and map_scrn_y if moved in +ve direction!
 1402                        	;
 1403                        	; N.B. This draws multiple rows when called from _draw_map or _blit_map.
 1404                        	;
 1405                        	
 1406    01:D9DA  60         	!no_change:	rts
 1407                        	
 1408    01:D9DB             	map_scroll_y:
 1409                        	
 1410               0001     		.if	BLKMAP_MULTISCR
 1411                        	
 1412                        			; Initialization for a multi-screen map.
 1413                        	
 1414    01:D9DB  BD B4 2B   			lda	vdc_scr_bank, x		; Skip this if regular blkmap.
 1415    01:D9DE  F0 56      			beq	.regular
 1416                        	
 1417    01:D9E0  A5 FE      	.multiscr:	lda	<map_chr_y		; Compare old_y with cur_y.
 1418    01:D9E2  DD A8 2B   			cmp	vdc_old_chr_y, x
 1419               0001     		.if	BLKMAP_TIMETEST == 0
 1420    01:D9E5  F0 F3      			beq	!no_change-		; Do nothing if no change.
 1421                        		.endif
 1422    01:D9E7  9D A8 2B   			sta	vdc_old_chr_y, x
 1423    01:D9EA  30 11      			bmi	!+			; Test the sign of the change.
 1424                        	
 1425    01:D9EC  18         			clc				; Draw bottom if chr_y >= old_y.
 1426    01:D9ED  3D 6E 26   			and	vdc_bat_y_mask, x
 1427    01:D9F0  7D 71 26   			adc	vdc_map_draw_h, x	; Usually (SCR_HEIGHT / 8) + 1.
 1428    01:D9F3  3A         			dec	a
 1429    01:D9F4  85 FE      			sta	<map_chr_y		; Update CHR Y chr coordinate.
 1430    01:D9F6  3C 6C 26   			bit	vdc_bat_height, x
 1431    01:D9F9  F0 02      			beq	!+
 1432    01:D9FB  E6 FF      			inc	<map_scrn_y		; Wrapped to the next screen.
 1433                        	
 1434    01:D9FD  3D 6E 26   	!:		and	vdc_bat_y_mask, x
 1435    01:DA00  85 F9      			sta	<map_bat_y		; Save BAT Y chr coordinate.
 1436                        	
 1437    01:DA02  4A         			lsr	a			; Map BLK Y coordinate.
 1438    01:DA03  85 EF      			sta.h	<map_line
 1439    01:DA05  62         			cla
 1440    01:DA06  3C 6B 26   			bit	vdc_bat_width, x
 1441    01:DA09  30 08      			bmi	.w128
 1442    01:DA0B  70 03      			bvs	.w64
 1443    01:DA0D  46 EF      	.w32:		lsr.h	<map_line
 1444    01:DA0F  6A         			ror	a
 1445    01:DA10  46 EF      	.w64:		lsr.h	<map_line
 1446    01:DA12  6A         			ror	a
 1447    01:DA13  46 EF      	.w128:		lsr.h	<map_line
 1448    01:DA15  6A         			ror	a
 1449    01:DA16  46 EF      			lsr.h	<map_line		; Hi-byte of (BLK Y * width).
 1450    01:DA18  6A         			ror	a
 1451    01:DA19  85 EE      			sta.l	<map_line		; Lo-byte of (BLK Y * width).
 1452                        	
 1453    01:DA1B  A5 FC      			lda	<map_chr_x
 1454    01:DA1D  3D 6D 26   			and	vdc_bat_x_mask, x
 1455    01:DA20  85 F8      			sta	<map_bat_x		; Save BAT X chr coordinate.
 1456                        	
 1457                        			; Loop to here if drawing multiple multi-screen rows.
 1458                        	
 1459    01:DA22  20 47 D8   	.multiscr_row:	jsr	map_set_screen		; Put BLK & MAP in MPR2-MPR5.
 1460                        	
 1461    01:DA25  A5 F8      			lda	<map_bat_x		; Calc map data pointer.
 1462    01:DA27  4A         			lsr	a			; Map BLK X coordinate.
 1463    01:DA28  05 EE      			ora.l	<map_line
 1464    01:DA2A  85 EC      			sta.l	<_bp
 1465    01:DA2C  A5 EF      			lda.h	<map_line
 1466    01:DA2E  18         			clc
 1467    01:DA2F  7D B0 2B   			adc.h	vdc_map_addr, x		; N.B. 256-byte aligned!
 1468    01:DA32  85 ED      			sta.h	<_bp
 1469                        	
 1470    01:DA34  80 60      			bra	.draw_row		; Now draw it.
 1471                        	
 1472                        		.endif	BLKMAP_MULTISCR
 1473                        	
 1474                        			; Initialization for a regular blkmap.
 1475                        	
 1476    01:DA36  A5 FE      	.regular:	lda	<map_chr_y		; Compare old_y with cur_y.
 1477    01:DA38  DD A8 2B   			cmp	vdc_old_chr_y, x
 1478               0001     		.if	BLKMAP_TIMETEST == 0
 1479    01:DA3B  F0 9D      			beq	!no_change-		; Do nothing if no change.
 1480                        		.endif
 1481    01:DA3D  9D A8 2B   			sta	vdc_old_chr_y, x
 1482    01:DA40  30 07      			bmi	!+			; Test the sign of the change.
 1483                        	
 1484    01:DA42  18         			clc				; Draw bottom if chr_y >= old_y.
 1485    01:DA43  7D 71 26   			adc	vdc_map_draw_h, x	; Usually (SCR_HEIGHT / 8) + 1.
 1486    01:DA46  3A         			dec	a
 1487    01:DA47  85 FE      			sta	<map_chr_y		; Update CHR Y chr coordinate.
 1488                        	
 1489    01:DA49  A8         	!:		tay				; A = map CHR Y coordinate.
 1490    01:DA4A  4A         			lsr	a
 1491    01:DA4B  42         			say				; Y = map BLK Y coordinate.
 1492                        	
 1493    01:DA4C  3C 78 26   			bit	vdc_map_option, x	; Set bit6 to disable aligning
 1494    01:DA4F  70 05      			bvs	!+			; BAT Y with the map Y.
 1495    01:DA51  3D 6E 26   			and	vdc_bat_y_mask, x
 1496    01:DA54  85 F9      			sta	<map_bat_y		; Save BAT Y chr coordinate.
 1497                        	
 1498    01:DA56  3C 78 26   	!:		bit	vdc_map_option, x	; Set bit7 to disable aligning
 1499    01:DA59  30 07      			bmi	!+			; BAT X with the map X.
 1500    01:DA5B  A5 FC      			lda	<map_chr_x
 1501    01:DA5D  3D 6D 26   			and	vdc_bat_x_mask, x
 1502    01:DA60  85 F8      			sta	<map_bat_x		; Save BAT X chr coordinate.
 1503    01:DA62             	!:
 1504                        	
 1505               0000     		.if	BLKMAP_LARGEMAP
 1510                        		.endif
 1511                        	
 1512    01:DA62  BD 72 26   			lda	vdc_map_line_w, x	; Map width in BLK.
 1513               0000     		.if	FAST_MULTIPLY
 1526                        		.else
 1527    01:DA65  84 EF      			sty.h	<map_line		; Takes 144..176 cycles.
 1528    01:DA67  A0 08      			ldy	#8
 1529    01:DA69  4A         			lsr	a
 1530    01:DA6A  85 EE      			sta.l	<map_line
 1531    01:DA6C  62         			cla
 1532    01:DA6D  90 03      			bcc	.rotate
 1533    01:DA6F  18         	.add:		clc
 1534    01:DA70  65 EF      			adc.h	<map_line
 1535    01:DA72  6A         	.rotate:	ror	a
 1536    01:DA73  66 EE      			ror.l	<map_line		; Lo-byte of (BLK Y * width).
 1537    01:DA75  88         			dey
 1538    01:DA76  B0 F7      			bcs	.add
 1539    01:DA78  D0 F8      			bne	.rotate
 1540    01:DA7A  85 EF      			sta.h	<map_line		; Hi-byte of (BLK Y * width).
 1541                        		.endif
 1542                        	
 1543    01:DA7C  20 AD D8   			jsr	map_set_banks		; Put BLK & MAP in MPR2-MPR5.
 1544                        	
 1545                        			; Loop to here if drawing multiple regular blkmap rows.
 1546                        	
 1547    01:DA7F  A4 EF      	.regular_row:	ldy.h	<map_line		; Hi-byte of (BLK Y * width).
 1548    01:DA81  A5 FC      			lda	<map_chr_x		; Map CHR X coordinate.
 1549    01:DA83  4A         			lsr	a			; Map BLK X coordinate.
 1550    01:DA84  18         			clc
 1551    01:DA85  65 EE      			adc.l	<map_line		; Lo-byte of (BLK Y * width).
 1552    01:DA87  90 01      			bcc	!+
 1553    01:DA89  C8         			iny
 1554    01:DA8A  18         	!:		clc				; Calc map data pointer.
 1555    01:DA8B  7D AF 2B   			adc.l	vdc_map_addr, x
 1556    01:DA8E  85 EC      			sta.l	<_bp			; Maximum map size is 16KBytes
 1557    01:DA90  98         			tya				; so we don't need to consider
 1558    01:DA91  7D B0 2B   			adc.h	vdc_map_addr, x		; bank overflow.
 1559    01:DA94  85 ED      			sta.h	<_bp
 1560                        	
 1561                        			; Draw the first part of the row.
 1562                        	
 1563    01:DA96  A5 F9      	.draw_row:	lda	<map_bat_y		; Set the BAT VRAM destination
 1564    01:DA98  85 F1      			sta.h	<_di			; coordinates.
 1565    01:DA9A  A5 F8      			lda	<map_bat_x
 1566    01:DA9C  85 F0      			sta.l	<_di
 1567                        	
 1568    01:DA9E  5D 6D 26   			eor	vdc_bat_x_mask, x	; Calc CHR before wrap.
 1569    01:DAA1  1A         			inc	a
 1570    01:DAA2  C5 FA      			cmp	<map_draw_w		; Usually (SCR_WIDTH / 8) + 1.
 1571    01:DAA4  90 02      			bcc	!+
 1572    01:DAA6  A5 FA      			lda	<map_draw_w		; Maximum CHR to draw.
 1573    01:DAA8  85 00      	!:		sta	<map_count		; Set number of CHR to draw.
 1574    01:DAAA  85 01      			sta	<map_drawn		; Preserve number of CHR drawn.
 1575                        	
 1576    01:DAAC  20 1C DB   			jsr	blk_row_strip		; Draw lhs of horizontal strip.
 1577                        	
 1578                        			; Wrap around and draw the rest of the row (if needed).
 1579                        	
 1580    01:DAAF  38         			sec				; Are there any more CHR that
 1581    01:DAB0  A5 FA      			lda	<map_draw_w		; need to be drawn?
 1582    01:DAB2  E5 01      			sbc	<map_drawn
 1583    01:DAB4  F0 2E      			beq	.done_row
 1584                        	
 1585    01:DAB6  85 00      			sta	<map_count		; Set number of CHR to draw.
 1586                        	
 1587    01:DAB8  A5 FC      			lda	<map_chr_x		; Update CHR X coordinate for
 1588    01:DABA  48         			pha				; drawing unaligned tiles.
 1589    01:DABB  18         			clc
 1590    01:DABC  65 01      			adc	<map_drawn
 1591    01:DABE  85 FC      			sta	<map_chr_x
 1592                        	
 1593               0001     		.if	BLKMAP_MULTISCR
 1594    01:DAC0  BD B4 2B   			lda	vdc_scr_bank, x		; Skip this if regular blkmap.
 1595    01:DAC3  F0 11      			beq	!+
 1596                        	
 1597    01:DAC5  E6 FD      			inc	<map_scrn_x		; Wrapped to the next screen.
 1598                        	
 1599    01:DAC7  20 47 D8   			jsr	map_set_screen		; Locate screen's BLK and MAP.
 1600                        	
 1601    01:DACA  18         			clc				; Calc map data pointer.
 1602    01:DACB  A5 EE      			lda.l	<map_line
 1603    01:DACD  85 EC      			sta.l	<_bp
 1604    01:DACF  A5 EF      			lda.h	<map_line
 1605    01:DAD1  7D B0 2B   			adc.h	vdc_map_addr, x		; N.B. 256-byte aligned!
 1606    01:DAD4  85 ED      			sta.h	<_bp
 1607                        		.endif
 1608                        	
 1609    01:DAD6  A5 F9      	!:		lda	<map_bat_y		; Set the BAT VRAM destination
 1610    01:DAD8  85 F1      			sta.h	<_di			; coordinates.
 1611    01:DADA  64 F0      			stz.l	<_di			; Reset 1st column to draw.
 1612                        	
 1613    01:DADC  20 1C DB   			jsr	blk_row_strip		; Draw rhs of horizontal strip.
 1614                        	
 1615               0001     		.if	BLKMAP_MULTISCR
 1616    01:DADF  C6 FD      			dec	<map_scrn_x		; Restore, no check if should.
 1617                        		.endif	BLKMAP_MULTISCR
 1618                        	
 1619    01:DAE1  68         			pla				; Restore CHR X coordinate, we
 1620    01:DAE2  85 FC      			sta	<map_chr_x		; might draw another row!
 1621                        	
 1622    01:DAE4  C6 FB      	.done_row:	dec	<map_draw_h		; Are all desired rows drawn?
 1623    01:DAE6  F0 33      			beq	.finished
 1624                        	
 1625    01:DAE8  E6 FE      			inc	<map_chr_y		; Move CHR Y down by 1.
 1626                        	
 1627    01:DAEA  A5 FE      			lda	<map_chr_y		; If new BLK then ...
 1628    01:DAEC  4A         			lsr	a
 1629    01:DAED  B0 0B      			bcs	!+
 1630    01:DAEF  BD 72 26   			lda	vdc_map_line_w, x	; Move the map line pointer to
 1631    01:DAF2  65 EE      			adc.l	<map_line		; the next line.
 1632    01:DAF4  85 EE      			sta.l	<map_line
 1633    01:DAF6  90 02      			bcc	!+
 1634    01:DAF8  E6 EF      			inc.h	<map_line
 1635                        	
 1636    01:DAFA  A5 F9      	!:		lda	<map_bat_y		; Move BAT Y down by 1.
 1637    01:DAFC  1A         			inc	a
 1638    01:DAFD  3D 6E 26   			and	vdc_bat_y_mask, x
 1639    01:DB00  85 F9      			sta	<map_bat_y
 1640                        	
 1641               0001     		.if	BLKMAP_MULTISCR
 1642    01:DB02  BC B4 2B   			ldy	vdc_scr_bank, x		; Skip this if regular blkmap.
 1643    01:DB05  D0 03 4C 7F			beq	.regular_row
         01:DB09  DA          
 1644                        	
 1645    01:DB0A  A8         			tay				; If wrapped to the top line of
 1646    01:DB0B  D0 0B      			bne	!+			; of the BAT then increment the
 1647    01:DB0D  E6 FF      			inc	<map_scrn_y		; screen.
 1648                        	
 1649    01:DB0F  BD 6F 26   			lda	vdc_bat_limit, x	; The map line must wrap around
 1650    01:DB12  4A         			lsr	a			; too. This is simple since its
 1651    01:DB13  4A         			lsr	a			; size (in bytes) is 1/4 of the
 1652    01:DB14  25 EF      			and.h	<map_line		; BAT size (in words) and it is
 1653    01:DB16  85 EF      			sta.h	<map_line		; a power-of-2.
 1654                        	
 1655    01:DB18  4C 22 DA   	!:		jmp	.multiscr_row		; Draw next row.
 1656                        		.else
 1658                        		.endif	BLKMAP_MULTISCR
 1659                        	
 1660    01:DB1B  60         	.finished:	rts
 1661                        	
 1662                        	
 1663                        	
 1664               0000     		.if	BLKDEF_POINTERS
 1858                        		.else	BLKDEF_POINTERS
 1859                        	
 1860                        	
 1861                        	
 1862                        	; ***************************************************************************
 1863                        	; ***************************************************************************
 1864                        	;
 1865                        	; blk_row_strip - Draw a single row of CHR into the BAT.
 1866                        	;
 1867                        	
 1868    01:DB1C  20 34 E4   	blk_row_strip:	jsr	set_di_xy_mawr		; Set the BAT VRAM destination.
 1869                        	
 1870    01:DB1F  A5 FC      			lda	<map_chr_x		; Select what drawing code to
 1871    01:DB21  4A         			lsr	a			; use depending upon even/odd
 1872    01:DB22  A5 FE      			lda	<map_chr_y		; CHR coordinates (not BAT to
 1873    01:DB24  29 01      			and	#1			; support unaligned drawing).
 1874    01:DB26  2A         			rol	a
 1875    01:DB27  0A         			asl	a
 1876    01:DB28  1D AD 2B   			ora.h	vdc_blk_addr, x		; What is the BLK data address?
 1877    01:DB2B  29 1E      			and	#%00011110		; $4000, $4800, $5000 or $5800.
 1878    01:DB2D  A8         			tay
 1879    01:DB2E  B9 3B DB   			lda.h	.jump_table, y		; Push the address of the code.
 1880    01:DB31  48         			pha
 1881    01:DB32  B9 3A DB   			lda.l	.jump_table, y
 1882    01:DB35  48         			pha
 1883                        	
 1884    01:DB36  B2 EC      			lda	[_bp]			; Get the first BLK number.
 1885    01:DB38  A8         			tay
 1886                        	
 1887    01:DB39  60         			rts				; Jump to the drawing code.
 1888                        	
 1889    01:DB3A  5C DB      	.jump_table:	dw	b4000_top_even - 1
 1890    01:DB3C  6F DB      			dw	b4000_top_odd - 1
 1891    01:DB3E  8C DB      			dw	b4000_btm_even - 1
 1892    01:DB40  9F DB      			dw	b4000_btm_odd - 1
 1893                        	
 1894    01:DB42  BC DB      			dw	b4800_top_even - 1
 1895    01:DB44  CF DB      			dw	b4800_top_odd - 1
 1896    01:DB46  EC DB      			dw	b4800_btm_even - 1
 1897    01:DB48  FF DB      			dw	b4800_btm_odd - 1
 1898                        	
 1899    01:DB4A  1C DC      			dw	b5000_top_even - 1
 1900    01:DB4C  2F DC      			dw	b5000_top_odd - 1
 1901    01:DB4E  4C DC      			dw	b5000_btm_even - 1
 1902    01:DB50  5F DC      			dw	b5000_btm_odd - 1
 1903                        	
 1904    01:DB52  7C DC      			dw	b5800_top_even - 1
 1905    01:DB54  8F DC      			dw	b5800_top_odd - 1
 1906    01:DB56  AC DC      			dw	b5800_btm_even - 1
 1907    01:DB58  BF DC      			dw	b5800_btm_odd - 1
 1908                        	
 1909                        			; top horizontal (32+2 rept)
 1910                        			;
 1911                        			; 89 cycles per block * 17 -> 1513 cycles
 1912                        	
 1913    01:DB5A  B2 EC      	!repeat:	lda	[_bp]			; 7
 1914    01:DB5C  A8         			tay				; 2
 1915                        	
 1916    01:DB5D  B9 00 40   	b4000_top_even:	lda	BLK_4000_TL_L, y	; 5
 1917    01:DB60  9D 02 02   			sta	VDC_DL, x		; 6
 1918    01:DB63  B9 00 44   			lda	BLK_4000_TL_H, y	; 5
 1919               0001     		.if	BLKDEF_CHR_FLAG
 1920    01:DB66  29 F3      			and	#%11110011		; 2
 1921                        		.endif
 1922    01:DB68  1A         			inc	a			; 2
 1923    01:DB69  9D 03 02   			sta	VDC_DH, x		; 6
 1924                        	
 1925    01:DB6C  C6 00      			dec	<map_count		; 6
 1926    01:DB6E  F0 19      			beq	!end+			; 2
 1927                        	
 1928    01:DB70  B9 00 41   	b4000_top_odd:	lda	BLK_4000_TR_L, y	; 5
 1929    01:DB73  9D 02 02   			sta	VDC_DL, x		; 6
 1930    01:DB76  B9 00 45   			lda	BLK_4000_TR_H, y	; 5
 1931               0001     		.if	BLKDEF_CHR_FLAG
 1932    01:DB79  29 F3      			and	#%11110011		; 2
 1933                        		.endif
 1934    01:DB7B  1A         			inc	a			; 2
 1935    01:DB7C  9D 03 02   			sta	VDC_DH, x		; 6
 1936                        	
 1937    01:DB7F  E6 EC      			inc.l	<_bp			; 6
 1938    01:DB81  D0 02      			bne	!+			; 2/4
 1939    01:DB83  E6 ED      			inc.h	<_bp			; 6
 1940                        	
 1941    01:DB85  C6 00      	!:		dec	<map_count		; 6
 1942    01:DB87  D0 D1      			bne	!repeat-		; 4
 1943                        	
 1944    01:DB89  60         	!end:		rts
 1945                        	
 1946                        			; btm horizontal (32+2 rept)
 1947                        			;
 1948                        			; 89 cycles per block * 17 -> 1513 cycles
 1949                        	
 1950    01:DB8A  B2 EC      	!repeat:	lda	[_bp]			; 7
 1951    01:DB8C  A8         			tay				; 2
 1952                        	
 1953    01:DB8D  B9 00 42   	b4000_btm_even:	lda	BLK_4000_BL_L, y	; 5
 1954    01:DB90  9D 02 02   			sta	VDC_DL, x		; 6
 1955    01:DB93  B9 00 46   			lda	BLK_4000_BL_H, y	; 5
 1956               0001     		.if	BLKDEF_CHR_FLAG
 1957    01:DB96  29 F3      			and	#%11110011		; 2
 1958                        		.endif
 1959    01:DB98  1A         			inc	a			; 2
 1960    01:DB99  9D 03 02   			sta	VDC_DH, x		; 6
 1961                        	
 1962    01:DB9C  C6 00      			dec	<map_count		; 6
 1963    01:DB9E  F0 19      			beq	!end+			; 2
 1964                        	
 1965    01:DBA0  B9 00 43   	b4000_btm_odd:	lda	BLK_4000_BR_L, y	; 5
 1966    01:DBA3  9D 02 02   			sta	VDC_DL, x		; 6
 1967    01:DBA6  B9 00 47   			lda	BLK_4000_BR_H, y	; 5
 1968               0001     		.if	BLKDEF_CHR_FLAG
 1969    01:DBA9  29 F3      			and	#%11110011		; 2
 1970                        		.endif
 1971    01:DBAB  1A         			inc	a			; 2
 1972    01:DBAC  9D 03 02   			sta	VDC_DH, x		; 6
 1973                        	
 1974    01:DBAF  E6 EC      			inc.l	<_bp			; 6
 1975    01:DBB1  D0 02      			bne	!+			; 2/4
 1976    01:DBB3  E6 ED      			inc.h	<_bp			; 6
 1977                        	
 1978    01:DBB5  C6 00      	!:		dec	<map_count		; 6
 1979    01:DBB7  D0 D1      			bne	!repeat-		; 4
 1980                        	
 1981    01:DBB9  60         	!end:		rts
 1982                        	
 1983                        			; top horizontal (32+2 rept)
 1984                        			;
 1985                        			; 89 cycles per block * 17 -> 1513 cycles
 1986                        	
 1987    01:DBBA  B2 EC      	!repeat:	lda	[_bp]			; 7
 1988    01:DBBC  A8         			tay				; 2
 1989                        	
 1990    01:DBBD  B9 00 48   	b4800_top_even:	lda	BLK_4800_TL_L, y	; 5
 1991    01:DBC0  9D 02 02   			sta	VDC_DL, x		; 6
 1992    01:DBC3  B9 00 4C   			lda	BLK_4800_TL_H, y	; 5
 1993               0001     		.if	BLKDEF_CHR_FLAG
 1994    01:DBC6  29 F3      			and	#%11110011		; 2
 1995                        		.endif
 1996    01:DBC8  1A         			inc	a			; 2
 1997    01:DBC9  9D 03 02   			sta	VDC_DH, x		; 6
 1998                        	
 1999    01:DBCC  C6 00      			dec	<map_count		; 6
 2000    01:DBCE  F0 19      			beq	!end+			; 2
 2001                        	
 2002    01:DBD0  B9 00 49   	b4800_top_odd:	lda	BLK_4800_TR_L, y	; 5
 2003    01:DBD3  9D 02 02   			sta	VDC_DL, x		; 6
 2004    01:DBD6  B9 00 4D   			lda	BLK_4800_TR_H, y	; 5
 2005               0001     		.if	BLKDEF_CHR_FLAG
 2006    01:DBD9  29 F3      			and	#%11110011		; 2
 2007                        		.endif
 2008    01:DBDB  1A         			inc	a			; 2
 2009    01:DBDC  9D 03 02   			sta	VDC_DH, x		; 6
 2010                        	
 2011    01:DBDF  E6 EC      			inc.l	<_bp			; 6
 2012    01:DBE1  D0 02      			bne	!+			; 2/4
 2013    01:DBE3  E6 ED      			inc.h	<_bp			; 6
 2014                        	
 2015    01:DBE5  C6 00      	!:		dec	<map_count		; 6
 2016    01:DBE7  D0 D1      			bne	!repeat-		; 4
 2017                        	
 2018    01:DBE9  60         	!end:		rts
 2019                        	
 2020                        			; btm horizontal (32+2 rept)
 2021                        			;
 2022                        			; 89 cycles per block * 17 -> 1513 cycles
 2023                        	
 2024    01:DBEA  B2 EC      	!repeat:	lda	[_bp]			; 7
 2025    01:DBEC  A8         			tay				; 2
 2026                        	
 2027    01:DBED  B9 00 4A   	b4800_btm_even:	lda	BLK_4800_BL_L, y	; 5
 2028    01:DBF0  9D 02 02   			sta	VDC_DL, x		; 6
 2029    01:DBF3  B9 00 4E   			lda	BLK_4800_BL_H, y	; 5
 2030               0001     		.if	BLKDEF_CHR_FLAG
 2031    01:DBF6  29 F3      			and	#%11110011		; 2
 2032                        		.endif
 2033    01:DBF8  1A         			inc	a			; 2
 2034    01:DBF9  9D 03 02   			sta	VDC_DH, x		; 6
 2035                        	
 2036    01:DBFC  C6 00      			dec	<map_count		; 6
 2037    01:DBFE  F0 19      			beq	!end+			; 2
 2038                        	
 2039    01:DC00  B9 00 4B   	b4800_btm_odd:	lda	BLK_4800_BR_L, y	; 5
 2040    01:DC03  9D 02 02   			sta	VDC_DL, x		; 6
 2041    01:DC06  B9 00 4F   			lda	BLK_4800_BR_H, y	; 5
 2042               0001     		.if	BLKDEF_CHR_FLAG
 2043    01:DC09  29 F3      			and	#%11110011		; 2
 2044                        		.endif
 2045    01:DC0B  1A         			inc	a			; 2
 2046    01:DC0C  9D 03 02   			sta	VDC_DH, x		; 6
 2047                        	
 2048    01:DC0F  E6 EC      			inc.l	<_bp			; 6
 2049    01:DC11  D0 02      			bne	!+			; 2/4
 2050    01:DC13  E6 ED      			inc.h	<_bp			; 6
 2051                        	
 2052    01:DC15  C6 00      	!:		dec	<map_count		; 6
 2053    01:DC17  D0 D1      			bne	!repeat-		; 4
 2054                        	
 2055    01:DC19  60         	!end:		rts
 2056                        	
 2057                        			; top horizontal (32+2 rept)
 2058                        			;
 2059                        			; 89 cycles per block * 17 -> 1513 cycles
 2060                        	
 2061    01:DC1A  B2 EC      	!repeat:	lda	[_bp]			; 7
 2062    01:DC1C  A8         			tay				; 2
 2063                        	
 2064    01:DC1D  B9 00 50   	b5000_top_even:	lda	BLK_5000_TL_L, y	; 5
 2065    01:DC20  9D 02 02   			sta	VDC_DL, x		; 6
 2066    01:DC23  B9 00 54   			lda	BLK_5000_TL_H, y	; 5
 2067               0001     		.if	BLKDEF_CHR_FLAG
 2068    01:DC26  29 F3      			and	#%11110011		; 2
 2069                        		.endif
 2070    01:DC28  1A         			inc	a			; 2
 2071    01:DC29  9D 03 02   			sta	VDC_DH, x		; 6
 2072                        	
 2073    01:DC2C  C6 00      			dec	<map_count		; 6
 2074    01:DC2E  F0 19      			beq	!end+			; 2
 2075                        	
 2076    01:DC30  B9 00 51   	b5000_top_odd:	lda	BLK_5000_TR_L, y	; 5
 2077    01:DC33  9D 02 02   			sta	VDC_DL, x		; 6
 2078    01:DC36  B9 00 55   			lda	BLK_5000_TR_H, y	; 5
 2079               0001     		.if	BLKDEF_CHR_FLAG
 2080    01:DC39  29 F3      			and	#%11110011		; 2
 2081                        		.endif
 2082    01:DC3B  1A         			inc	a			; 2
 2083    01:DC3C  9D 03 02   			sta	VDC_DH, x		; 6
 2084                        	
 2085    01:DC3F  E6 EC      			inc.l	<_bp			; 6
 2086    01:DC41  D0 02      			bne	!+			; 2/4
 2087    01:DC43  E6 ED      			inc.h	<_bp			; 6
 2088                        	
 2089    01:DC45  C6 00      	!:		dec	<map_count		; 6
 2090    01:DC47  D0 D1      			bne	!repeat-		; 4
 2091                        	
 2092    01:DC49  60         	!end:		rts
 2093                        	
 2094                        			; btm horizontal (32+2 rept)
 2095                        			;
 2096                        			; 89 cycles per block * 17 -> 1513 cycles
 2097                        	
 2098    01:DC4A  B2 EC      	!repeat:	lda	[_bp]			; 7
 2099    01:DC4C  A8         			tay				; 2
 2100                        	
 2101    01:DC4D  B9 00 52   	b5000_btm_even:	lda	BLK_5000_BL_L, y	; 5
 2102    01:DC50  9D 02 02   			sta	VDC_DL, x		; 6
 2103    01:DC53  B9 00 56   			lda	BLK_5000_BL_H, y	; 5
 2104               0001     		.if	BLKDEF_CHR_FLAG
 2105    01:DC56  29 F3      			and	#%11110011		; 2
 2106                        		.endif
 2107    01:DC58  1A         			inc	a			; 2
 2108    01:DC59  9D 03 02   			sta	VDC_DH, x		; 6
 2109                        	
 2110    01:DC5C  C6 00      			dec	<map_count		; 6
 2111    01:DC5E  F0 19      			beq	!end+			; 2
 2112                        	
 2113    01:DC60  B9 00 53   	b5000_btm_odd:	lda	BLK_5000_BR_L, y	; 5
 2114    01:DC63  9D 02 02   			sta	VDC_DL, x		; 6
 2115    01:DC66  B9 00 57   			lda	BLK_5000_BR_H, y	; 5
 2116               0001     		.if	BLKDEF_CHR_FLAG
 2117    01:DC69  29 F3      			and	#%11110011		; 2
 2118                        		.endif
 2119    01:DC6B  1A         			inc	a			; 2
 2120    01:DC6C  9D 03 02   			sta	VDC_DH, x		; 6
 2121                        	
 2122    01:DC6F  E6 EC      			inc.l	<_bp			; 6
 2123    01:DC71  D0 02      			bne	!+			; 2/4
 2124    01:DC73  E6 ED      			inc.h	<_bp			; 6
 2125                        	
 2126    01:DC75  C6 00      	!:		dec	<map_count		; 6
 2127    01:DC77  D0 D1      			bne	!repeat-		; 4
 2128                        	
 2129    01:DC79  60         	!end:		rts
 2130                        	
 2131                        			; top horizontal (32+2 rept)
 2132                        			;
 2133                        			; 89 cycles per block * 17 -> 1513 cycles
 2134                        	
 2135    01:DC7A  B2 EC      	!repeat:	lda	[_bp]			; 7
 2136    01:DC7C  A8         			tay				; 2
 2137                        	
 2138    01:DC7D  B9 00 58   	b5800_top_even:	lda	BLK_5800_TL_L, y	; 5
 2139    01:DC80  9D 02 02   			sta	VDC_DL, x		; 6
 2140    01:DC83  B9 00 5C   			lda	BLK_5800_TL_H, y	; 5
 2141               0001     		.if	BLKDEF_CHR_FLAG
 2142    01:DC86  29 F3      			and	#%11110011		; 2
 2143                        		.endif
 2144    01:DC88  1A         			inc	a			; 2
 2145    01:DC89  9D 03 02   			sta	VDC_DH, x		; 6
 2146                        	
 2147    01:DC8C  C6 00      			dec	<map_count		; 6
 2148    01:DC8E  F0 19      			beq	!end+			; 2
 2149                        	
 2150    01:DC90  B9 00 59   	b5800_top_odd:	lda	BLK_5800_TR_L, y	; 5
 2151    01:DC93  9D 02 02   			sta	VDC_DL, x		; 6
 2152    01:DC96  B9 00 5D   			lda	BLK_5800_TR_H, y	; 5
 2153               0001     		.if	BLKDEF_CHR_FLAG
 2154    01:DC99  29 F3      			and	#%11110011		; 2
 2155                        		.endif
 2156    01:DC9B  1A         			inc	a			; 2
 2157    01:DC9C  9D 03 02   			sta	VDC_DH, x		; 6
 2158                        	
 2159    01:DC9F  E6 EC      			inc.l	<_bp			; 6
 2160    01:DCA1  D0 02      			bne	!+			; 2/4
 2161    01:DCA3  E6 ED      			inc.h	<_bp			; 6
 2162                        	
 2163    01:DCA5  C6 00      	!:		dec	<map_count		; 6
 2164    01:DCA7  D0 D1      			bne	!repeat-		; 4
 2165                        	
 2166    01:DCA9  60         	!end:		rts
 2167                        	
 2168                        			; btm horizontal (32+2 rept)
 2169                        			;
 2170                        			; 89 cycles per block * 17 -> 1513 cycles
 2171                        	
 2172    01:DCAA  B2 EC      	!repeat:	lda	[_bp]		; 7
 2173    01:DCAC  A8         			tay				; 2
 2174                        	
 2175    01:DCAD  B9 00 5A   	b5800_btm_even:	lda	BLK_5800_BL_L, y	; 5
 2176    01:DCB0  9D 02 02   			sta	VDC_DL, x		; 6
 2177    01:DCB3  B9 00 5E   			lda	BLK_5800_BL_H, y	; 5
 2178               0001     		.if	BLKDEF_CHR_FLAG
 2179    01:DCB6  29 F3      			and	#%11110011		; 2
 2180                        		.endif
 2181    01:DCB8  1A         			inc	a			; 2
 2182    01:DCB9  9D 03 02   			sta	VDC_DH, x		; 6
 2183                        	
 2184    01:DCBC  C6 00      			dec	<map_count		; 6
 2185    01:DCBE  F0 19      			beq	!end+			; 2
 2186                        	
 2187    01:DCC0  B9 00 5B   	b5800_btm_odd:	lda	BLK_5800_BR_L, y	; 5
 2188    01:DCC3  9D 02 02   			sta	VDC_DL, x		; 6
 2189    01:DCC6  B9 00 5F   			lda	BLK_5800_BR_H, y	; 5
 2190               0001     		.if	BLKDEF_CHR_FLAG
 2191    01:DCC9  29 F3      			and	#%11110011		; 2
 2192                        		.endif
 2193    01:DCCB  1A         			inc	a			; 2
 2194    01:DCCC  9D 03 02   			sta	VDC_DH, x		; 6
 2195                        	
 2196    01:DCCF  E6 EC      			inc.l	<_bp			; 6
 2197    01:DCD1  D0 02      			bne	!+			; 2/4
 2198    01:DCD3  E6 ED      			inc.h	<_bp			; 6
 2199                        	
 2200    01:DCD5  C6 00      	!:		dec	<map_count		; 6
 2201    01:DCD7  D0 D1      			bne	!repeat-		; 4
 2202                        	
 2203    01:DCD9  60         	!end:		rts
 2204                        	
 2205                        	
 2206                        	
 2207                        	; ***************************************************************************
 2208                        	; ***************************************************************************
 2209                        	;
 2210                        	; blk_col_strip - Draw a single column of CHR into the BAT.
 2211                        	;
 2212                        	
 2213    01:DCDA  20 34 E4   	blk_col_strip:	jsr	set_di_xy_mawr		; Set the BAT VRAM destination.
 2214                        	
 2215    01:DCDD  A5 FC      			lda	<map_chr_x		; Select what drawing code to
 2216    01:DCDF  4A         			lsr	a			; use depending upon even/odd
 2217    01:DCE0  A5 FE      			lda	<map_chr_y		; CHR coordinates (not BAT to
 2218    01:DCE2  29 01      			and	#1			; support unaligned drawing).
 2219    01:DCE4  2A         			rol	a
 2220    01:DCE5  0A         			asl	a			; N.B. Always leaves C clear.
 2221    01:DCE6  1D AD 2B   			ora.h	vdc_blk_addr, x		; What is the BLK data address?
 2222    01:DCE9  29 1E      			and	#%00011110		; $4000, $4800, $5000 or $5800.
 2223    01:DCEB  A8         			tay
 2224    01:DCEC  B9 F9 DC   			lda.h	.jump_table, y		; Push the address of the code.
 2225    01:DCEF  48         			pha
 2226    01:DCF0  B9 F8 DC   			lda.l	.jump_table, y
 2227    01:DCF3  48         			pha
 2228                        	
 2229    01:DCF4  B2 EC      			lda	[_bp]			; Get the first BLK number.
 2230    01:DCF6  A8         			tay
 2231                        	
 2232    01:DCF7  60         			rts				; Jump to the drawing code.
 2233                        	
 2234    01:DCF8  1A DD      	.jump_table:	dw	b4000_lhs_even - 1
 2235    01:DCFA  50 DD      			dw	b4000_rhs_even - 1
 2236    01:DCFC  2D DD      			dw	b4000_lhs_odd - 1
 2237    01:DCFE  63 DD      			dw	b4000_rhs_odd - 1
 2238                        	
 2239    01:DD00  86 DD      			dw	b4800_lhs_even - 1
 2240    01:DD02  BC DD      			dw	b4800_rhs_even - 1
 2241    01:DD04  99 DD      			dw	b4800_lhs_odd - 1
 2242    01:DD06  CF DD      			dw	b4800_rhs_odd - 1
 2243                        	
 2244    01:DD08  F2 DD      			dw	b5000_lhs_even - 1
 2245    01:DD0A  28 DE      			dw	b5000_rhs_even - 1
 2246    01:DD0C  05 DE      			dw	b5000_lhs_odd - 1
 2247    01:DD0E  3B DE      			dw	b5000_rhs_odd - 1
 2248                        	
 2249    01:DD10  5E DE      			dw	b5800_lhs_even - 1
 2250    01:DD12  94 DE      			dw	b5800_rhs_even - 1
 2251    01:DD14  71 DE      			dw	b5800_lhs_odd - 1
 2252    01:DD16  A7 DE      			dw	b5800_rhs_odd - 1
 2253                        	
 2254                        			; lhs vertical (28+2 rept)
 2255                        			;
 2256                        			; N.B. C is always clear on entry.
 2257                        			;
 2258                        			; 100 cycles per block * 15 -> 1500 cycles
 2259                        	
 2260    01:DD18  B2 EC      	!repeat:	lda	[_bp]			; 7
 2261    01:DD1A  A8         			tay				; 2
 2262                        	
 2263    01:DD1B  B9 00 40   	b4000_lhs_even:	lda	BLK_4000_TL_L, y	; 5
 2264    01:DD1E  9D 02 02   			sta	VDC_DL, x		; 6
 2265    01:DD21  B9 00 44   			lda	BLK_4000_TL_H, y	; 5
 2266               0001     		.if	BLKDEF_CHR_FLAG
 2267    01:DD24  29 F3      			and	#%11110011		; 2
 2268                        		.endif
 2269    01:DD26  1A         			inc	a			; 2
 2270    01:DD27  9D 03 02   			sta	VDC_DH, x		; 6
 2271                        	
 2272    01:DD2A  C6 00      			dec	<map_count		; 6
 2273    01:DD2C  F0 1F      			beq	!end+			; 2
 2274                        	
 2275    01:DD2E  B9 00 42   	b4000_lhs_odd:	lda	BLK_4000_BL_L, y	; 5
 2276    01:DD31  9D 02 02   			sta	VDC_DL, x		; 6
 2277    01:DD34  B9 00 46   			lda	BLK_4000_BL_H, y	; 5
 2278               0001     		.if	BLKDEF_CHR_FLAG
 2279    01:DD37  29 F3      			and	#%11110011		; 2
 2280                        		.endif
 2281    01:DD39  1A         			inc	a			; 2
 2282    01:DD3A  9D 03 02   			sta	VDC_DH, x		; 6
 2283                        	
 2284    01:DD3D  BD 72 26   			lda	vdc_map_line_w, x	; 5
 2285    01:DD40  65 EC      			adc.l	<_bp			; 4
 2286    01:DD42  85 EC      			sta.l	<_bp			; 4
 2287    01:DD44  90 03      			bcc	!+			; 2/4
 2288    01:DD46  E6 ED      			inc.h	<_bp			; 6
 2289    01:DD48  18         			clc				; 2
 2290                        	
 2291    01:DD49  C6 00      	!:		dec	<map_count		; 6
 2292    01:DD4B  D0 CB      			bne	!repeat-		; 4
 2293                        	
 2294    01:DD4D  60         	!end:		rts
 2295                        	
 2296                        			; rhs vertical (28+2 rept)
 2297                        			;
 2298                        			; N.B. C is always clear on entry.
 2299                        			;
 2300                        			; 100 cycles per block * 15 -> 1500 cycles
 2301                        	
 2302    01:DD4E  B2 EC      	!repeat:	lda	[_bp]			; 7
 2303    01:DD50  A8         			tay				; 2
 2304                        	
 2305    01:DD51  B9 00 41   	b4000_rhs_even:	lda	BLK_4000_TR_L, y	; 5
 2306    01:DD54  9D 02 02   			sta	VDC_DL, x		; 6
 2307    01:DD57  B9 00 45   			lda	BLK_4000_TR_H, y	; 5
 2308               0001     		.if	BLKDEF_CHR_FLAG
 2309    01:DD5A  29 F3      			and	#%11110011		; 2
 2310                        		.endif
 2311    01:DD5C  1A         			inc	a			; 2
 2312    01:DD5D  9D 03 02   			sta	VDC_DH, x		; 6
 2313                        	
 2314    01:DD60  C6 00      			dec	<map_count		; 6
 2315    01:DD62  F0 1F      			beq	!end+			; 2
 2316                        	
 2317    01:DD64  B9 00 43   	b4000_rhs_odd:	lda	BLK_4000_BR_L, y	; 5
 2318    01:DD67  9D 02 02   			sta	VDC_DL, x		; 6
 2319    01:DD6A  B9 00 47   			lda	BLK_4000_BR_H, y	; 5
 2320               0001     		.if	BLKDEF_CHR_FLAG
 2321    01:DD6D  29 F3      			and	#%11110011		; 2
 2322                        		.endif
 2323    01:DD6F  1A         			inc	a			; 2
 2324    01:DD70  9D 03 02   			sta	VDC_DH, x		; 6
 2325                        	
 2326    01:DD73  BD 72 26   			lda	vdc_map_line_w, x	; 5
 2327    01:DD76  65 EC      			adc.l	<_bp			; 4
 2328    01:DD78  85 EC      			sta.l	<_bp			; 4
 2329    01:DD7A  90 03      			bcc	!+			; 2/4
 2330    01:DD7C  E6 ED      			inc.h	<_bp			; 6
 2331    01:DD7E  18         			clc				; 2
 2332                        	
 2333    01:DD7F  C6 00      	!:		dec	<map_count		; 6
 2334    01:DD81  D0 CB      			bne	!repeat-		; 4
 2335                        	
 2336    01:DD83  60         	!end:		rts
 2337                        	
 2338                        			; lhs vertical (28+2 rept)
 2339                        			;
 2340                        			; N.B. C is always clear on entry.
 2341                        			;
 2342                        			; 100 cycles per block * 15 -> 1500 cycles
 2343                        	
 2344    01:DD84  B2 EC      	!repeat:	lda	[_bp]			; 7
 2345    01:DD86  A8         			tay				; 2
 2346                        	
 2347    01:DD87  B9 00 48   	b4800_lhs_even:	lda	BLK_4800_TL_L, y	; 5
 2348    01:DD8A  9D 02 02   			sta	VDC_DL, x		; 6
 2349    01:DD8D  B9 00 4C   			lda	BLK_4800_TL_H, y	; 5
 2350               0001     		.if	BLKDEF_CHR_FLAG
 2351    01:DD90  29 F3      			and	#%11110011		; 2
 2352                        		.endif
 2353    01:DD92  1A         			inc	a			; 2
 2354    01:DD93  9D 03 02   			sta	VDC_DH, x		; 6
 2355                        	
 2356    01:DD96  C6 00      			dec	<map_count		; 6
 2357    01:DD98  F0 1F      			beq	!end+			; 2
 2358                        	
 2359    01:DD9A  B9 00 4A   	b4800_lhs_odd:	lda	BLK_4800_BL_L, y	; 5
 2360    01:DD9D  9D 02 02   			sta	VDC_DL, x		; 6
 2361    01:DDA0  B9 00 4E   			lda	BLK_4800_BL_H, y	; 5
 2362               0001     		.if	BLKDEF_CHR_FLAG
 2363    01:DDA3  29 F3      			and	#%11110011		; 2
 2364                        		.endif
 2365    01:DDA5  1A         			inc	a			; 2
 2366    01:DDA6  9D 03 02   			sta	VDC_DH, x		; 6
 2367                        	
 2368    01:DDA9  BD 72 26   			lda	vdc_map_line_w, x	; 5
 2369    01:DDAC  65 EC      			adc.l	<_bp			; 4
 2370    01:DDAE  85 EC      			sta.l	<_bp			; 4
 2371    01:DDB0  90 03      			bcc	!+			; 2/4
 2372    01:DDB2  E6 ED      			inc.h	<_bp			; 6
 2373    01:DDB4  18         			clc				; 2
 2374                        	
 2375    01:DDB5  C6 00      	!:		dec	<map_count		; 6
 2376    01:DDB7  D0 CB      			bne	!repeat-		; 4
 2377                        	
 2378    01:DDB9  60         	!end:		rts
 2379                        	
 2380                        			; rhs vertical (28+2 rept)
 2381                        			;
 2382                        			; N.B. C is always clear on entry.
 2383                        			;
 2384                        			; 100 cycles per block * 15 -> 1500 cycles
 2385                        	
 2386    01:DDBA  B2 EC      	!repeat:	lda	[_bp]			; 7
 2387    01:DDBC  A8         			tay				; 2
 2388                        	
 2389    01:DDBD  B9 00 49   	b4800_rhs_even:	lda	BLK_4800_TR_L, y	; 5
 2390    01:DDC0  9D 02 02   			sta	VDC_DL, x		; 6
 2391    01:DDC3  B9 00 4D   			lda	BLK_4800_TR_H, y	; 5
 2392               0001     		.if	BLKDEF_CHR_FLAG
 2393    01:DDC6  29 F3      			and	#%11110011		; 2
 2394                        		.endif
 2395    01:DDC8  1A         			inc	a			; 2
 2396    01:DDC9  9D 03 02   			sta	VDC_DH, x		; 6
 2397                        	
 2398    01:DDCC  C6 00      			dec	<map_count		; 6
 2399    01:DDCE  F0 1F      			beq	!end+			; 2
 2400                        	
 2401    01:DDD0  B9 00 4B   	b4800_rhs_odd:	lda	BLK_4800_BR_L, y	; 5
 2402    01:DDD3  9D 02 02   			sta	VDC_DL, x		; 6
 2403    01:DDD6  B9 00 4F   			lda	BLK_4800_BR_H, y	; 5
 2404               0001     		.if	BLKDEF_CHR_FLAG
 2405    01:DDD9  29 F3      			and	#%11110011		; 2
 2406                        		.endif
 2407    01:DDDB  1A         			inc	a			; 2
 2408    01:DDDC  9D 03 02   			sta	VDC_DH, x		; 6
 2409                        	
 2410    01:DDDF  BD 72 26   			lda	vdc_map_line_w, x	; 5
 2411    01:DDE2  65 EC      			adc.l	<_bp			; 4
 2412    01:DDE4  85 EC      			sta.l	<_bp			; 4
 2413    01:DDE6  90 03      			bcc	!+			; 2/4
 2414    01:DDE8  E6 ED      			inc.h	<_bp			; 6
 2415    01:DDEA  18         			clc				; 2
 2416                        	
 2417    01:DDEB  C6 00      	!:		dec	<map_count		; 6
 2418    01:DDED  D0 CB      			bne	!repeat-		; 4
 2419                        	
 2420    01:DDEF  60         	!end:		rts
 2421                        	
 2422                        			; lhs vertical (28+2 rept)
 2423                        			;
 2424                        			; N.B. C is always clear on entry.
 2425                        			;
 2426                        			; 100 cycles per block * 15 -> 1500 cycles
 2427                        	
 2428    01:DDF0  B2 EC      	!repeat:	lda	[_bp]			; 7
 2429    01:DDF2  A8         			tay				; 2
 2430                        	
 2431    01:DDF3  B9 00 50   	b5000_lhs_even:	lda	BLK_5000_TL_L, y	; 5
 2432    01:DDF6  9D 02 02   			sta	VDC_DL, x		; 6
 2433    01:DDF9  B9 00 54   			lda	BLK_5000_TL_H, y	; 5
 2434               0001     		.if	BLKDEF_CHR_FLAG
 2435    01:DDFC  29 F3      			and	#%11110011		; 2
 2436                        		.endif
 2437    01:DDFE  1A         			inc	a			; 2
 2438    01:DDFF  9D 03 02   			sta	VDC_DH, x		; 6
 2439                        	
 2440    01:DE02  C6 00      			dec	<map_count		; 6
 2441    01:DE04  F0 1F      			beq	!end+			; 2
 2442                        	
 2443    01:DE06  B9 00 52   	b5000_lhs_odd:	lda	BLK_5000_BL_L, y	; 5
 2444    01:DE09  9D 02 02   			sta	VDC_DL, x		; 6
 2445    01:DE0C  B9 00 56   			lda	BLK_5000_BL_H, y	; 5
 2446               0001     		.if	BLKDEF_CHR_FLAG
 2447    01:DE0F  29 F3      			and	#%11110011		; 2
 2448                        		.endif
 2449    01:DE11  1A         			inc	a			; 2
 2450    01:DE12  9D 03 02   			sta	VDC_DH, x		; 6
 2451                        	
 2452    01:DE15  BD 72 26   			lda	vdc_map_line_w, x	; 5
 2453    01:DE18  65 EC      			adc.l	<_bp			; 4
 2454    01:DE1A  85 EC      			sta.l	<_bp			; 4
 2455    01:DE1C  90 03      			bcc	!+			; 2/4
 2456    01:DE1E  E6 ED      			inc.h	<_bp			; 6
 2457    01:DE20  18         			clc				; 2
 2458                        	
 2459    01:DE21  C6 00      	!:		dec	<map_count		; 6
 2460    01:DE23  D0 CB      			bne	!repeat-		; 4
 2461                        	
 2462    01:DE25  60         	!end:		rts
 2463                        	
 2464                        			; rhs vertical (28+2 rept)
 2465                        			;
 2466                        			; N.B. C is always clear on entry.
 2467                        			;
 2468                        			; 100 cycles per block * 15 -> 1500 cycles
 2469                        	
 2470    01:DE26  B2 EC      	!repeat:	lda	[_bp]			; 7
 2471    01:DE28  A8         			tay				; 2
 2472                        	
 2473    01:DE29  B9 00 51   	b5000_rhs_even:	lda	BLK_5000_TR_L, y	; 5
 2474    01:DE2C  9D 02 02   			sta	VDC_DL, x		; 6
 2475    01:DE2F  B9 00 55   			lda	BLK_5000_TR_H, y	; 5
 2476               0001     		.if	BLKDEF_CHR_FLAG
 2477    01:DE32  29 F3      			and	#%11110011		; 2
 2478                        		.endif
 2479    01:DE34  1A         			inc	a			; 2
 2480    01:DE35  9D 03 02   			sta	VDC_DH, x		; 6
 2481                        	
 2482    01:DE38  C6 00      			dec	<map_count		; 6
 2483    01:DE3A  F0 1F      			beq	!end+			; 2
 2484                        	
 2485    01:DE3C  B9 00 53   	b5000_rhs_odd:	lda	BLK_5000_BR_L, y	; 5
 2486    01:DE3F  9D 02 02   			sta	VDC_DL, x		; 6
 2487    01:DE42  B9 00 57   			lda	BLK_5000_BR_H, y	; 5
 2488               0001     		.if	BLKDEF_CHR_FLAG
 2489    01:DE45  29 F3      			and	#%11110011		; 2
 2490                        		.endif
 2491    01:DE47  1A         			inc	a			; 2
 2492    01:DE48  9D 03 02   			sta	VDC_DH, x		; 6
 2493                        	
 2494    01:DE4B  BD 72 26   			lda	vdc_map_line_w, x	; 5
 2495    01:DE4E  65 EC      			adc.l	<_bp			; 4
 2496    01:DE50  85 EC      			sta.l	<_bp			; 4
 2497    01:DE52  90 03      			bcc	!+			; 2/4
 2498    01:DE54  E6 ED      			inc.h	<_bp			; 6
 2499    01:DE56  18         			clc				; 2
 2500                        	
 2501    01:DE57  C6 00      	!:		dec	<map_count		; 6
 2502    01:DE59  D0 CB      			bne	!repeat-		; 4
 2503                        	
 2504    01:DE5B  60         	!end:		rts
 2505                        	
 2506                        			; lhs vertical (28+2 rept)
 2507                        			;
 2508                        			; N.B. C is always clear on entry.
 2509                        			;
 2510                        			; 100 cycles per block * 15 -> 1500 cycles
 2511                        	
 2512    01:DE5C  B2 EC      	!repeat:	lda	[_bp]			; 7
 2513    01:DE5E  A8         			tay				; 2
 2514                        	
 2515    01:DE5F  B9 00 58   	b5800_lhs_even:	lda	BLK_5800_TL_L, y	; 5
 2516    01:DE62  9D 02 02   			sta	VDC_DL, x		; 6
 2517    01:DE65  B9 00 5C   			lda	BLK_5800_TL_H, y	; 5
 2518               0001     		.if	BLKDEF_CHR_FLAG
 2519    01:DE68  29 F3      			and	#%11110011		; 2
 2520                        		.endif
 2521    01:DE6A  1A         			inc	a			; 2
 2522    01:DE6B  9D 03 02   			sta	VDC_DH, x		; 6
 2523                        	
 2524    01:DE6E  C6 00      			dec	<map_count		; 6
 2525    01:DE70  F0 1F      			beq	!end+			; 2
 2526                        	
 2527    01:DE72  B9 00 5A   	b5800_lhs_odd:	lda	BLK_5800_BL_L, y	; 5
 2528    01:DE75  9D 02 02   			sta	VDC_DL, x		; 6
 2529    01:DE78  B9 00 5E   			lda	BLK_5800_BL_H, y	; 5
 2530               0001     		.if	BLKDEF_CHR_FLAG
 2531    01:DE7B  29 F3      			and	#%11110011		; 2
 2532                        		.endif
 2533    01:DE7D  1A         			inc	a			; 2
 2534    01:DE7E  9D 03 02   			sta	VDC_DH, x		; 6
 2535                        	
 2536    01:DE81  BD 72 26   			lda	vdc_map_line_w, x	; 5
 2537    01:DE84  65 EC      			adc.l	<_bp			; 4
 2538    01:DE86  85 EC      			sta.l	<_bp			; 4
 2539    01:DE88  90 03      			bcc	!+			; 2/4
 2540    01:DE8A  E6 ED      			inc.h	<_bp			; 6
 2541    01:DE8C  18         			clc				; 2
 2542                        	
 2543    01:DE8D  C6 00      	!:		dec	<map_count		; 6
 2544    01:DE8F  D0 CB      			bne	!repeat-		; 4
 2545                        	
 2546    01:DE91  60         	!end:		rts
 2547                        	
 2548                        			; rhs vertical (28+2 rept)
 2549                        			;
 2550                        			; N.B. C is always clear on entry.
 2551                        			;
 2552                        			; 100 cycles per block * 15 -> 1500 cycles
 2553                        	
 2554    01:DE92  B2 EC      	!repeat:	lda	[_bp]			; 7
 2555    01:DE94  A8         			tay				; 2
 2556                        	
 2557    01:DE95  B9 00 59   	b5800_rhs_even:	lda	BLK_5800_TR_L, y	; 5
 2558    01:DE98  9D 02 02   			sta	VDC_DL, x		; 6
 2559    01:DE9B  B9 00 5D   			lda	BLK_5800_TR_H, y	; 5
 2560               0001     		.if	BLKDEF_CHR_FLAG
 2561    01:DE9E  29 F3      			and	#%11110011		; 2
 2562                        		.endif
 2563    01:DEA0  1A         			inc	a			; 2
 2564    01:DEA1  9D 03 02   			sta	VDC_DH, x		; 6
 2565                        	
 2566    01:DEA4  C6 00      			dec	<map_count		; 6
 2567    01:DEA6  F0 1F      			beq	!end+			; 2
 2568                        	
 2569    01:DEA8  B9 00 5B   	b5800_rhs_odd:	lda	BLK_5800_BR_L, y	; 5
 2570    01:DEAB  9D 02 02   			sta	VDC_DL, x		; 6
 2571    01:DEAE  B9 00 5F   			lda	BLK_5800_BR_H, y	; 5
 2572               0001     		.if	BLKDEF_CHR_FLAG
 2573    01:DEB1  29 F3      			and	#%11110011		; 2
 2574                        		.endif
 2575    01:DEB3  1A         			inc	a			; 2
 2576    01:DEB4  9D 03 02   			sta	VDC_DH, x		; 6
 2577                        	
 2578    01:DEB7  BD 72 26   			lda	vdc_map_line_w, x	; 5
 2579    01:DEBA  65 EC      			adc.l	<_bp			; 4
 2580    01:DEBC  85 EC      			sta.l	<_bp			; 4
 2581    01:DEBE  90 03      			bcc	!+			; 2/4
 2582    01:DEC0  E6 ED      			inc.h	<_bp			; 6
 2583    01:DEC2  18         			clc				; 2
 2584                        	
 2585    01:DEC3  C6 00      	!:		dec	<map_count		; 6
 2586    01:DEC5  D0 CB      			bne	!repeat-		; 4
 2587                        	
 2588    01:DEC7  60         	!end:		rts
 2589                        	
 2590                        		.endif	BLKDEF_POINTERS
 2591                        	
 2592                        		.endprocgroup	; blkmap_group
                             #[2]   "..\..\..\include\hucc\hucc-final.asm"
   80                        		.else
   84                        		.endif	HUCC_USES_BLKMAP
   85                        	
   86               0001     		.ifdef	HUCC_USES_CHRMAP		; Set in hucc_chrmap.h
                             #[3]   "..\..\..\include\hucc\chrmap.asm"
   87                        			include	"chrmap.asm"
    1                        	; ***************************************************************************
    2                        	; ***************************************************************************
    3                        	;
    4                        	; chrmap.asm
    5                        	;
    6                        	; A simple map system based on 8x8 characters (aka "tiles") in BAT format.
    7                        	;
    8                        	; Copyright John Brandwood 2025.
    9                        	;
   10                        	; Distributed under the Boost Software License, Version 1.0.
   11                        	; (See accompanying file LICENSE_1_0.txt or copy at
   12                        	;  http://www.boost.org/LICENSE_1_0.txt)
   13                        	;
   14                        	; ***************************************************************************
   15                        	; ***************************************************************************
   16                        	;
   17                        	; The maximum X and Y size for chrmaps is 256 characters (2048 pixels).
   18                        	;
   19                        	; The maximum total size for a chrmap is 16KBytes, which allows for maps up
   20                        	; to 256x32 tiles (2048x256 pixels).
   21                        	;
   22                        	; ***************************************************************************
   23                        	; ***************************************************************************
   24                        	
   25                        	;
   26                        	; Include dependancies ...
   27                        	;
   28                        	
   29                        			include "blkmap.asm"		; This defines the variables.
   30                        	
   31                        	;
   32                        	; Chrmaps in BAT format normally address all of VRAM from $0400..$7FFF, but
   33                        	; they can be limited to use the 32KByte of characters in VRAM $1000..$4FFF
   34                        	; which then frees up 2-bits for flag information for each character in the
   35                        	; BAT entry.
   36                        	;
   37                        	; These 2-bits are perfect for using as collision information in game maps,
   38                        	; allowing storage of states like transparent, solid, up-slope, down-slope.
   39                        	;
   40                        	; Typically this flag information is set by the map conversion tools from a
   41                        	; seperate "collision" map layer.
   42                        	;
   43                        	
   44               0000     		.ifndef	CHRMAP_BAT_FLAG
   46                        		.endif
   47                        	
   48                        	;
   49                        	;
   50                        	;
   51                        	
   52                        	
   53                        	
   54    02:D12F             	chrmap_group	.procgroup
   55                        	
   56                        	; ***************************************************************************
   57                        	; ***************************************************************************
   58                        	;
   59                        	; _draw_bat - Draw the entire screen at the current coordinates.
   60                        	; _sgx_draw_bat - Draw the entire screen at the current coordinates.
   61                        	;
   62                        	; void __fastcall draw_bat( void );
   63                        	; void __fastcall sgx_draw_bat( void );
   64                        	;
   65                        	
   66               0001     		.if	SUPPORT_SGX
   67                        	
   68                        	_sgx_draw_bat	.proc
   74                        			.endp
   75                        		.endif
   76                        	
   77    02:D12F             	_draw_bat	.proc
   78                        	
   79    02:D12F  82         			clx				; Offset to PCE VDC.
   80                        	
   81    02:D130  43 08      			tma3				; Preserve MPR3..MPR5.
   82    02:D132  48         			pha
   83    02:D133  43 10      			tma4
   84    02:D135  48         			pha
   85    02:D136  43 20      			tma5
   86    02:D138  48         			pha
   87                        	
   88    02:D139  20 DC D1   			jsr	bat_pxl_2_chr		; Set up the draw coordinates.
   89                        	
   90    02:D13C  A5 FC      			lda	<map_chr_x		; Reset previous X position.
   91    02:D13E  9D A7 2B   			sta	vdc_old_chr_x, x
   92                        	
   93    02:D141  A5 FE      			lda	<map_chr_y		; Reset previous Y position,
   94    02:D143  1A         			inc	a			; ready to draw rows upwards.
   95    02:D144  9D A8 2B   			sta	vdc_old_chr_y, x
   96                        	
   97    02:D147  BD 70 26   			lda	vdc_map_draw_w, x	; Draw the whole screen.
   98    02:D14A  85 FA      			sta	<map_draw_w
   99    02:D14C  BD 71 26   			lda	vdc_map_draw_h, x
  100    02:D14F  85 FB      			sta	<map_draw_h
  101                        	
  102    02:D151  20 BF D2   			jsr	bat_scroll_y		; Draw N row of CHR to the BAT.
  103                        	
  104    02:D154  68         			pla				; Restore MPR3..MPR5.
  105    02:D155  53 20      			tam5
  106    02:D157  68         			pla
  107    02:D158  53 10      			tam4
  108    02:D15A  68         			pla
  109    02:D15B  53 08      			tam3
  110                        	
  111                        			leave
         02:D15D  4C EF FF   			jmp	leave_proc
  112                        	
  113                        			.endp
  114                        	
  115                        	
  116                        	
  117                        	; ***************************************************************************
  118                        	; ***************************************************************************
  119                        	;
  120                        	; _scroll_bat - Draw a single row of CHR into the BAT to update the edge.
  121                        	; _sgx_scroll_bat - Draw a single row of CHR into the BAT to update the edge.
  122                        	;
  123                        	; void __fastcall scroll_bat( void );
  124                        	; void __fastcall sgx_scroll_bat( void );
  125                        	;
  126                        	
  127               0001     		.if	SUPPORT_SGX
  128                        	
  129                        	_sgx_scroll_bat	.proc
  135                        			.endp
  136                        		.endif
  137                        	
  138    02:D160             	_scroll_bat	.proc
  139                        	
  140    02:D160  82         			clx				; Offset to PCE VDC.
  141                        	
  142    02:D161  43 08      			tma3				; Preserve MPR3..MPR5.
  143    02:D163  48         			pha
  144    02:D164  43 10      			tma4
  145    02:D166  48         			pha
  146    02:D167  43 20      			tma5
  147    02:D169  48         			pha
  148                        	
  149    02:D16A  20 DC D1   			jsr	bat_pxl_2_chr		; Set up the draw coordinates.
  150                        	
  151    02:D16D  BD 71 26   			lda	vdc_map_draw_h, x	; Draw new LHS or RHS if needed.
  152    02:D170  85 FB      			sta	<map_draw_h
  153                        	;		lda	#1			; bat_scroll_x only ever draws a
  154                        	;		sta	<map_draw_w		; single column.
  155    02:D172  20 00 D2   			jsr	bat_scroll_x
  156                        	
  157    02:D175  BD A7 2B   			lda	vdc_old_chr_x, x	; Restore map_chr_x which could
  158    02:D178  85 FC      			sta	<map_chr_x		; be changed by bat_scroll_x.
  159                        	
  160    02:D17A  BD 70 26   			lda	vdc_map_draw_w, x	; Draw new TOP or BTM if needed.
  161    02:D17D  85 FA      			sta	<map_draw_w
  162    02:D17F  A9 01      			lda	#1
  163    02:D181  85 FB      			sta	<map_draw_h
  164    02:D183  20 BF D2   			jsr	bat_scroll_y
  165                        	
  166    02:D186  68         			pla				; Restore MPR3..MPR5.
  167    02:D187  53 20      			tam5
  168    02:D189  68         			pla
  169    02:D18A  53 10      			tam4
  170    02:D18C  68         			pla
  171    02:D18D  53 08      			tam3
  172                        	
  173                        			leave
         02:D18F  4C EF FF   			jmp	leave_proc
  174                        	
  175                        			.endp
  176                        	
  177                        	
  178                        	
  179                        	; ***************************************************************************
  180                        	; ***************************************************************************
  181                        	;
  182                        	; _blit_bat - Draw a map rectangle to specific BAT coordinates.
  183                        	; _sgx_blit_bat - Draw a map rectangle to specific BAT coordinates.
  184                        	;
  185                        	; void __fastcall blit_bat( unsigned char tile_x<map_bat_x>, unsigned char tile_y<map_bat_y>, unsigned char tile_w<map_draw_x>, unsigned char tile_h<map_draw_y> );
  186                        	; void __fastcall sgx_blit_bat( unsigned char tile_x<map_bat_x>, unsigned char tile_y<map_bat_y>, unsigned char tile_w<map_draw_x>, unsigned char tile_h<map_draw_y> );
  187                        	;
  188                        	; Normally you'd just use _draw_bat() and _scroll_bat(), but for those folks
  189                        	; who really wish to take manual control, you can use this.
  190                        	;
  191                        	
  192               0001     		.if	SUPPORT_SGX
  193                        	
  194                        	_sgx_blit_bat	.proc
  200                        			.endp
  201                        		.endif
  202                        	
  203    02:D192             	_blit_bat	.proc
  204                        	
  205    02:D192  82         			clx				; Offset to PCE VDC.
  206                        	
  207    02:D193  43 08      			tma3				; Preserve MPR3..MPR5.
  208    02:D195  48         			pha
  209    02:D196  43 10      			tma4
  210    02:D198  48         			pha
  211    02:D199  43 20      			tma5
  212    02:D19B  48         			pha
  213                        	
  214    02:D19C  BD 78 26   			lda	vdc_map_option, x	; Preserve current map options.
  215    02:D19F  48         			pha
  216    02:D1A0  09 C0      			ora	#MAP_UNALIGNED_X | MAP_UNALIGNED_Y
  217    02:D1A2  9D 78 26   			sta	vdc_map_option, x
  218                        	
  219    02:D1A5  20 DC D1   			jsr	bat_pxl_2_chr		; Set up the draw coordinates.
  220                        	
  221    02:D1A8  A5 FA      			lda	<map_draw_w		; Are we drawing just 1 column?
  222    02:D1AA  C9 01      			cmp	#1
  223    02:D1AC  F0 1E      			beq	.draw_column
  224                        	
  225                        			; Draw N rows.
  226                        	
  227    02:D1AE  A5 FC      	.draw_rows:	lda	<map_chr_x		; Reset previous X position.
  228    02:D1B0  9D A7 2B   			sta	vdc_old_chr_x, x
  229                        	
  230    02:D1B3  A5 FE      			lda	<map_chr_y		; Reset previous Y position,
  231    02:D1B5  1A         			inc	a			; ready to draw rows upwards.
  232    02:D1B6  9D A8 2B   			sta	vdc_old_chr_y, x
  233                        	
  234    02:D1B9  20 BF D2   			jsr	bat_scroll_y		; Draw a row of CHR to the BAT.
  235                        	
  236                        			; Drawing completed.
  237                        	
  238    02:D1BC  68         	.finished:	pla				; Restore previous map options.
  239    02:D1BD  9D 78 26   			sta	vdc_map_option, x
  240                        	
  241    02:D1C0  68         			pla				; Restore MPR3..MPR5.
  242    02:D1C1  53 20      			tam5
  243    02:D1C3  68         			pla
  244    02:D1C4  53 10      			tam4
  245    02:D1C6  68         			pla
  246    02:D1C7  53 08      			tam3
  247                        	
  248                        	.exit:		leave
         02:D1C9  4C EF FF   			jmp	leave_proc
  249                        	
  250                        			; Draw 1 column.
  251                        	
  252    02:D1CC  A5 FC      	.draw_column:	lda	<map_chr_x		; Reset previous X position.
  253    02:D1CE  1A         			inc	a			; ready to draw 1 column.
  254    02:D1CF  9D A7 2B   			sta	vdc_old_chr_x, x
  255                        	
  256    02:D1D2  A5 FE      			lda	<map_chr_y		; Reset previous Y position.
  257    02:D1D4  9D A8 2B   			sta	vdc_old_chr_y, x
  258                        	
  259    02:D1D7  20 00 D2   			jsr	bat_scroll_x		; Draw a single column of CHR.
  260                        	
  261    02:D1DA  80 E0      			bra	.finished
  262                        	
  263                        			.endp
  264                        	
  265                        	
  266                        	
  267                        	; ***************************************************************************
  268                        	; ***************************************************************************
  269                        	;
  270                        	
  271    02:D1DC  BD 74 26   	bat_pxl_2_chr:	lda.l	vdc_map_pxl_x, x	; Get current map X coordinate.
  272    02:D1DF  85 FC      			sta.l	<map_pxl_x
  273    02:D1E1  BD 75 26   			lda.h	vdc_map_pxl_x, x	; Xvert map_pxl_x to map_chr_x.
  274    02:D1E4  4A         			lsr	a
  275    02:D1E5  66 FC      			ror.l	<map_pxl_x
  276    02:D1E7  4A         			lsr	a
  277    02:D1E8  66 FC      			ror.l	<map_pxl_x
  278    02:D1EA  4A         			lsr	a
  279    02:D1EB  66 FC      			ror.l	<map_pxl_x		; Max map width is 256 CHR.
  280                        	
  281    02:D1ED  BD 76 26   			lda.l	vdc_map_pxl_y, x	; Get current map Y coordinate.
  282    02:D1F0  85 FE      			sta.l	<map_pxl_y
  283    02:D1F2  BD 77 26   			lda.h	vdc_map_pxl_y, x	; Xvert map_pxl_y to map_chr_y.
  284    02:D1F5  4A         			lsr	a
  285    02:D1F6  66 FE      			ror.l	<map_pxl_y
  286    02:D1F8  4A         			lsr	a
  287    02:D1F9  66 FE      			ror.l	<map_pxl_y
  288    02:D1FB  4A         			lsr	a
  289    02:D1FC  66 FE      			ror.l	<map_pxl_y		; Max map width is 256 CHR.
  290                        	
  291    02:D1FE  60         			rts
  292                        	
  293                        	
  294                        	
  295                        	; ***************************************************************************
  296                        	; ***************************************************************************
  297                        	;
  298                        	; bat_scroll_x - Update the BAT when X coordinate changes.
  299                        	;
  300                        	; N.B. This only ever draws a single column!
  301                        	;
  302                        	
  303    02:D1FF  60         	!no_change:	rts
  304                        	
  305    02:D200  A5 FC      	bat_scroll_x:	lda	<map_chr_x		; Compare old_x with cur_x.
  306    02:D202  DD A7 2B   			cmp	vdc_old_chr_x, x
  307    02:D205  F0 F8      			beq	!no_change-		; Do nothing if no change.
  308    02:D207  9D A7 2B   			sta	vdc_old_chr_x, x
  309    02:D20A  30 05      			bmi	.moved			; Test the sign of the change.
  310                        	
  311    02:D20C  18         			clc				; Draw RHS if chr_x >= old_x.
  312    02:D20D  7D 70 26   			adc	vdc_map_draw_w, x	; Usually (SCR_WIDTH / 8) + 1.
  313    02:D210  3A         			dec	a
  314                        	
  315    02:D211  48         	.moved:		pha				; Push chr_x in map section.
  316                        	
  317    02:D212  3C 78 26   			bit	vdc_map_option, x	; Set bit7 to disable aligning
  318    02:D215  30 05      			bmi	!+			; BAT X with the map X.
  319    02:D217  3D 6D 26   			and	vdc_bat_x_mask, x
  320    02:D21A  85 F8      			sta	<map_bat_x		; Save BAT X chr coordinate.
  321                        	
  322    02:D21C  A5 FE      	!:		lda	<map_chr_y		; Y = chr_y in map section.
  323    02:D21E  A8         			tay
  324                        	
  325    02:D21F  3C 78 26   			bit	vdc_map_option, x	; Set bit6 to disable aligning
  326    02:D222  70 05      			bvs	!+			; BAT Y with the map Y.
  327    02:D224  3D 6E 26   			and	vdc_bat_y_mask, x
  328    02:D227  85 F9      			sta	<map_bat_y		; Save BAT Y chr coordinate.
  329                        	
  330               0000     		.if	FAST_MULTIPLY
  333                        		.endif
  334                        	
  335    02:D229  BD 72 26   	!:		lda	vdc_map_line_w, x	; Map width in CHR (0 == 256).
  336    02:D22C  D0 05      			bne	!+
  337                        	
  338    02:D22E  64 EE      			stz.l	<map_line		; Multiply by 256 is easy!
  339    02:D230  98         			tya
  340    02:D231  80 15      			bra	.double
  341                        	
  342               0000     		.if	FAST_MULTIPLY
  354                        		.else
  355    02:D233  84 EF      	!:		sty.h	<map_line		; Takes 144..176 cycles.
  356    02:D235  A0 08      			ldy	#8
  357    02:D237  4A         			lsr	a
  358    02:D238  85 EE      			sta.l	<map_line
  359    02:D23A  62         			cla
  360    02:D23B  90 03      			bcc	.rotate
  361    02:D23D  18         	.add:		clc
  362    02:D23E  65 EF      			adc.h	<map_line
  363    02:D240  6A         	.rotate:	ror	a
  364    02:D241  66 EE      			ror.l	<map_line		; Lo-byte of (CHR Y * width).
  365    02:D243  88         			dey
  366    02:D244  B0 F7      			bcs	.add
  367    02:D246  D0 F8      			bne	.rotate
  368                        		.endif
  369                        	
  370    02:D248  06 EE      	.double:	asl.l	<map_line		; Lo-byte of (CHR Y * width * 2).
  371    02:D24A  2A         			rol	a
  372    02:D24B  A8         			tay				; Hi-byte of (CHR Y * width * 2).
  373                        	
  374    02:D24C  BD B1 2B   			lda	vdc_map_bank, x		; Put the MAP into MPR3-MPR5.
  375    02:D24F  53 08      			tam3				; Allow for 16KByte chrmap.
  376    02:D251  1A         			inc	a
  377    02:D252  53 10      			tam4
  378    02:D254  1A         			inc	a
  379    02:D255  53 20      			tam5
  380                        	
  381    02:D257  68         			pla				; Pop chr_x in map section.
  382    02:D258  0A         			asl	a			; 2-bytes for a BAT value.
  383    02:D259  90 02      			bcc	!+
  384    02:D25B  C8         			iny				; Hi-byte of (CHR Y * width * 2).
  385    02:D25C  18         			clc
  386    02:D25D  65 EE      	!:		adc.l	<map_line		; Lo-byte of (CHR Y * width * 2).
  387    02:D25F  90 01      			bcc	!+
  388    02:D261  C8         			iny
  389                        	
  390    02:D262  18         	!:		clc				; Calc map data pointer.
  391    02:D263  7D AF 2B   			adc.l	vdc_map_addr, x
  392    02:D266  85 EC      			sta.l	<_bp			; Maximum map size is 16KBytes
  393    02:D268  98         			tya				; so we don't need to consider
  394    02:D269  7D B0 2B   			adc.h	vdc_map_addr, x		; bank overflow.
  395    02:D26C  85 ED      			sta.h	<_bp
  396                        	
  397    02:D26E  C2         			cly				; Calculate the map line delta
  398    02:D26F  BD 72 26   			lda	vdc_map_line_w, x	; in bytes.
  399    02:D272  D0 01      			bne	!+
  400    02:D274  C8         			iny
  401    02:D275  0A         	!:		asl	a
  402    02:D276  85 EE      			sta.l	<map_line
  403    02:D278  98         			tya
  404    02:D279  2A         			rol	a
  405    02:D27A  85 EF      			sta.h	<map_line
  406                        	
  407                        			; Draw the first part of the column.
  408                        	
  409    02:D27C  A5 F8      	.draw_col:	lda	<map_bat_x		; Set the BAT VRAM destination
  410    02:D27E  85 F0      			sta.l	<_di			; coordinates.
  411    02:D280  A5 F9      			lda	<map_bat_y
  412    02:D282  85 F1      			sta.h	<_di
  413                        	
  414    02:D284  5D 6E 26   			eor	vdc_bat_y_mask, x	; Calc CHR before wrap.
  415    02:D287  1A         			inc	a
  416    02:D288  C5 FB      			cmp	<map_draw_h		; Usually (SCR_HEIGHT / 8) + 1.
  417    02:D28A  90 02      			bcc	!+
  418    02:D28C  A5 FB      			lda	<map_draw_h		; Maximum CHR to draw.
  419    02:D28E  85 00      	!:		sta	<map_count		; Set number of CHR to draw.
  420    02:D290  85 01      			sta	<map_drawn		; Preserve number of CHR drawn.
  421                        	
  422    02:D292  A9 05      			lda	#VDC_CR			; Set VDC auto-increment from
  423    02:D294  95 F7      			sta	<vdc_reg, x		; the BAT width, which is set
  424    02:D296  9D 00 02   			sta	VDC_AR, x		; up by set_screen_size().
  425    02:D299  B5 F4      			lda	<vdc_crh, x
  426    02:D29B  9D 03 02   			sta	VDC_DH, x
  427                        	
  428    02:D29E  20 A0 D3   			jsr	bat_col_strip		; Draw top of vertical strip.
  429                        	
  430                        			; Wrap around and draw the rest of the column (if needed).
  431                        	
  432    02:D2A1  38         			sec				; Are there any more CHR that
  433    02:D2A2  A5 FB      			lda	<map_draw_h		; need to be drawn?
  434    02:D2A4  E5 01      			sbc	<map_drawn
  435    02:D2A6  F0 0B      			beq	.done
  436                        	
  437    02:D2A8  85 00      			sta	<map_count		; Set number of CHR to draw.
  438                        	
  439    02:D2AA  A5 F8      			lda	<map_bat_x		; Set the BAT VRAM destination
  440    02:D2AC  85 F0      			sta.l	<_di			; coordinates.
  441    02:D2AE  64 F1      			stz.h	<_di			; Reset 1st row to draw.
  442                        	
  443    02:D2B0  20 A0 D3   			jsr	bat_col_strip		; Draw btm of vertical strip.
  444                        	
  445    02:D2B3  A9 05      	.done:		lda	#VDC_CR			; Set VDC auto-increment to 1.
  446    02:D2B5  95 F7      			sta	<vdc_reg, x
  447    02:D2B7  9D 00 02   			sta	VDC_AR, x
  448    02:D2BA  9E 03 02   			stz	VDC_DH, x
  449                        	
  450    02:D2BD  60         			rts
  451                        	
  452                        	
  453                        	
  454                        	; ***************************************************************************
  455                        	; ***************************************************************************
  456                        	;
  457                        	; bat_scroll_y - Update the BAT when Y coordinate changes.
  458                        	;
  459                        	; N.B. This draws multiple rows when called from _draw_bat or _blit_bat.
  460                        	;
  461                        	
  462    02:D2BE  60         	!no_change:	rts
  463                        	
  464    02:D2BF  A5 FE      	bat_scroll_y:	lda	<map_chr_y		; Compare old_y with cur_y.
  465    02:D2C1  DD A8 2B   			cmp	vdc_old_chr_y, x
  466    02:D2C4  F0 F8      			beq	!no_change-		; Do nothing if no change.
  467    02:D2C6  9D A8 2B   			sta	vdc_old_chr_y, x
  468    02:D2C9  30 05      			bmi	.moved			; Test the sign of the change.
  469                        	
  470    02:D2CB  18         			clc				; Draw bottom if chr_y >= old_y.
  471    02:D2CC  7D 71 26   			adc	vdc_map_draw_h, x	; Usually (SCR_HEIGHT / 8) + 1.
  472    02:D2CF  3A         			dec	a
  473                        	
  474    02:D2D0  A8         	.moved:		tay				; Y = chr_y in map section.
  475                        	
  476    02:D2D1  3C 78 26   			bit	vdc_map_option, x	; Set bit6 to disable aligning
  477    02:D2D4  70 05      			bvs	!+			; BAT Y with the map Y.
  478    02:D2D6  3D 6E 26   			and	vdc_bat_y_mask, x
  479    02:D2D9  85 F9      			sta	<map_bat_y		; Save BAT Y chr coordinate.
  480                        	
  481    02:D2DB  3C 78 26   	!:		bit	vdc_map_option, x	; Set bit7 to disable aligning
  482    02:D2DE  30 07      			bmi	!+			; BAT X with the map X.
  483    02:D2E0  A5 FC      			lda	<map_chr_x
  484    02:D2E2  3D 6D 26   			and	vdc_bat_x_mask, x
  485    02:D2E5  85 F8      			sta	<map_bat_x		; Save BAT X chr coordinate.
  486                        	
  487               0000     		.if	FAST_MULTIPLY
  490                        		.endif
  491                        	
  492    02:D2E7  BD 72 26   	!:		lda	vdc_map_line_w, x	; Map width in CHR (0 == 256).
  493    02:D2EA  D0 05      			bne	!+
  494                        	
  495    02:D2EC  64 EE      			stz.l	<map_line		; Multiply by 256 is easy!
  496    02:D2EE  98         			tya
  497    02:D2EF  80 15      			bra	.double
  498                        	
  499               0000     		.if	FAST_MULTIPLY
  511                        		.else
  512    02:D2F1  84 EF      	!:		sty.h	<map_line		; Takes 144..176 cycles.
  513    02:D2F3  A0 08      			ldy	#8
  514    02:D2F5  4A         			lsr	a
  515    02:D2F6  85 EE      			sta.l	<map_line
  516    02:D2F8  62         			cla
  517    02:D2F9  90 03      			bcc	.rotate
  518    02:D2FB  18         	.add:		clc
  519    02:D2FC  65 EF      			adc.h	<map_line
  520    02:D2FE  6A         	.rotate:	ror	a
  521    02:D2FF  66 EE      			ror.l	<map_line		; Lo-byte of (CHR Y * width).
  522    02:D301  88         			dey
  523    02:D302  B0 F7      			bcs	.add
  524    02:D304  D0 F8      			bne	.rotate
  525                        		.endif
  526                        	
  527    02:D306  06 EE      	.double:	asl.l	<map_line		; Lo-byte of (CHR Y * width * 2).
  528    02:D308  2A         			rol	a
  529    02:D309  85 EF      			sta.h	<map_line		; Hi-byte of (CHR Y * width * 2).
  530    02:D30B  A8         			tay
  531                        	
  532    02:D30C  BD B1 2B   			lda	vdc_map_bank, x		; Put the MAP into MPR3-MPR5.
  533    02:D30F  53 08      			tam3				; Allow for 16KByte chrmap.
  534    02:D311  1A         			inc	a
  535    02:D312  53 10      			tam4
  536    02:D314  1A         			inc	a
  537    02:D315  53 20      			tam5
  538                        	
  539                        			; Loop to here if drawing multiple rows.
  540                        	
  541    02:D317  A5 FC      	.next_row:	lda	<map_chr_x		; Map CHR X coordinate.
  542    02:D319  0A         			asl	a			; 2-bytes for a BAT value!
  543    02:D31A  90 02      			bcc	!+
  544    02:D31C  C8         			iny				; Hi-byte of (CHR Y * width * 2).
  545    02:D31D  18         			clc
  546    02:D31E  65 EE      	!:		adc.l	<map_line		; Lo-byte of (CHR Y * width * 2).
  547    02:D320  90 01      			bcc	!+
  548    02:D322  C8         			iny
  549    02:D323  18         	!:		clc				; Calc map data pointer.
  550    02:D324  7D AF 2B   			adc.l	vdc_map_addr, x
  551    02:D327  85 EC      			sta.l	<_bp			; Maximum map size is 16KBytes
  552    02:D329  98         			tya				; so we don't need to consider
  553    02:D32A  7D B0 2B   			adc.h	vdc_map_addr, x		; bank overflow.
  554    02:D32D  85 ED      			sta.h	<_bp
  555                        	
  556                        			; Draw the first part of the row.
  557                        	
  558    02:D32F  A5 F9      	.draw_row:	lda	<map_bat_y		; Set the BAT VRAM destination
  559    02:D331  85 F1      			sta.h	<_di			; coordinates.
  560    02:D333  A5 F8      			lda	<map_bat_x
  561    02:D335  85 F0      			sta.l	<_di
  562                        	
  563    02:D337  5D 6D 26   			eor	vdc_bat_x_mask, x	; Calc CHR before wrap.
  564    02:D33A  1A         			inc	a
  565    02:D33B  C5 FA      			cmp	<map_draw_w		; Usually (SCR_WIDTH / 8) + 1.
  566    02:D33D  90 02      			bcc	!+
  567    02:D33F  A5 FA      			lda	<map_draw_w		; Maximum CHR to draw.
  568    02:D341  85 00      	!:		sta	<map_count		; Set number of CHR to draw.
  569    02:D343  85 01      			sta	<map_drawn		; Preserve number of CHR drawn.
  570                        	
  571    02:D345  20 7F D3   			jsr	bat_row_strip		; Draw lhs of horizontal strip.
  572                        	
  573                        			; Wrap around and draw the rest of the row (if needed).
  574                        	
  575    02:D348  38         			sec				; Are there any more CHR that
  576    02:D349  A5 FA      			lda	<map_draw_w		; need to be drawn?
  577    02:D34B  E5 01      			sbc	<map_drawn
  578    02:D34D  F0 0B      			beq	.done_row
  579                        	
  580    02:D34F  85 00      			sta	<map_count		; Set number of CHR to draw.
  581                        	
  582    02:D351  A5 F9      			lda	<map_bat_y		; Set the BAT VRAM destination
  583    02:D353  85 F1      			sta.h	<_di			; coordinates.
  584    02:D355  64 F0      			stz.l	<_di			; Reset 1st column to draw.
  585                        	
  586    02:D357  20 7F D3   			jsr	bat_row_strip		; Draw rhs of horizontal strip.
  587                        	
  588    02:D35A  C6 FB      	.done_row:	dec	<map_draw_h		; Are all desired rows drawn?
  589    02:D35C  F0 20      			beq	.finished
  590                        	
  591    02:D35E  A5 F9      			lda	<map_bat_y		; Move BAT Y down by 1.
  592    02:D360  1A         			inc	a
  593    02:D361  3D 6E 26   			and	vdc_bat_y_mask, x
  594    02:D364  85 F9      			sta	<map_bat_y
  595                        	
  596    02:D366  A4 EF      			ldy.h	<map_line		; Move the map line pointer to
  597    02:D368  C8         			iny				; the next line.
  598    02:D369  BD 72 26   			lda	vdc_map_line_w, x
  599    02:D36C  F0 0B      			beq	!++			; vdc_map_line_w == 0 == 256.
  600    02:D36E  0A         			asl	a			; 2-bytes for a BAT value!
  601    02:D36F  B0 01      			bcs	!+
  602    02:D371  88         			dey				; Fix if vdc_map_line_w <= 127.
  603    02:D372  18         	!:		clc
  604    02:D373  65 EE      			adc.l	<map_line
  605    02:D375  85 EE      			sta.l	<map_line
  606    02:D377  90 01      			bcc	!++
  607    02:D379  C8         	!:		iny
  608    02:D37A  84 EF      	!:		sty.h	<map_line		; Needed for .next_row!
  609                        	
  610    02:D37C  80 99      			bra	.next_row		; Draw next row.
  611                        	
  612    02:D37E  60         	.finished:	rts
  613                        	
  614                        	
  615                        	
  616                        	; ***************************************************************************
  617                        	; ***************************************************************************
  618                        	;
  619                        	; bat_row_strip - Draw a single row of CHR into the BAT.
  620                        	;
  621                        	
  622    02:D37F  20 34 E4   	bat_row_strip:	jsr	set_di_xy_mawr		; Set the BAT VRAM destination.
  623                        	
  624    02:D382  C2         			cly				; 2
  625    02:D383  B1 EC      	.repeat:	lda	[_bp], y		; 7
  626    02:D385  9D 02 02   			sta	VDC_DL, x		; 6
  627    02:D388  C8         			iny				; 2
  628    02:D389  B1 EC      			lda	[_bp], y		; 7
  629               0000     		.if	CHRMAP_BAT_FLAG
  634                        		.endif
  635    02:D38B  9D 03 02   			sta	VDC_DH, x		; 6
  636    02:D38E  C8         			iny				; 2
  637                        	
  638    02:D38F  C6 00      	!:		dec	<map_count		; 6
  639    02:D391  D0 F0      			bne	.repeat			; 4
  640                        	
  641    02:D393  98         			tya				; 2
  642    02:D394  F0 07      			beq	!+			; 2/4
  643    02:D396  18         			clc				; 2
  644    02:D397  65 EC      			adc.l	<_bp			; 4
  645    02:D399  85 EC      			sta.l	<_bp			; 4
  646    02:D39B  90 02      			bcc	.done			; 2/4
  647    02:D39D  E6 ED      	!:		inc.h	<_bp			; 6
  648                        	
  649    02:D39F  60         	.done:		rts
  650                        	
  651                        	
  652                        	
  653                        	; ***************************************************************************
  654                        	; ***************************************************************************
  655                        	;
  656                        	; bat_col_strip - Draw a single column of CHR into the BAT.
  657                        	;
  658                        	
  659    02:D3A0  20 34 E4   	bat_col_strip:	jsr	set_di_xy_mawr		; Set the BAT VRAM destination.
  660                        	
  661    02:D3A3  A0 01      			ldy	#1			; 2
  662    02:D3A5  B2 EC      	.repeat:	lda	[_bp]			; 7
  663    02:D3A7  9D 02 02   			sta	VDC_DL, x		; 6
  664    02:D3AA  B1 EC      			lda	[_bp], y		; 7
  665               0000     		.if	CHRMAP_BAT_FLAG
  670                        		.endif
  671    02:D3AC  9D 03 02   			sta	VDC_DH, x		; 6
  672                        	
  673    02:D3AF  18         			clc				; 2
  674    02:D3B0  A5 EE      			lda.l	<map_line		; 4
  675    02:D3B2  65 EC      			adc.l	<_bp			; 4
  676    02:D3B4  85 EC      			sta.l	<_bp			; 4
  677    02:D3B6  A5 EF      			lda.h	<map_line		; 4
  678    02:D3B8  65 ED      			adc.h	<_bp			; 4
  679    02:D3BA  85 ED      			sta.h	<_bp			; 4
  680                        	
  681    02:D3BC  C6 00      			dec	<map_count		; 6
  682    02:D3BE  D0 E5      			bne	.repeat			; 4
  683                        	
  684    02:D3C0  60         			rts
  685                        	
  686                        		.endprocgroup	; chrmap_group
                             #[2]   "..\..\..\include\hucc\hucc-final.asm"
   88                        		.endif	HUCC_USES_CHRMAP
   89                        	
   90               0001     		.ifdef	HUCC_USES_OLD_LINE		; Set in hucc_old_line.h
                             #[3]   "..\..\..\include\hucc\hucc-old-line.asm"
   91                        			include	"hucc-old-line.asm"
    1                        	; ***************************************************************************
    2                        	; ***************************************************************************
    3                        	;
    4                        	; hucc-old-line.asm
    5                        	;
    6                        	; Based on the original HuC and MagicKit functions by David Michel and the
    7                        	; other original HuC developers.
    8                        	;
    9                        	; Modifications copyright John Brandwood 2024-2025.
   10                        	;
   11                        	; Distributed under the Boost Software License, Version 1.0.
   12                        	; (See accompanying file LICENSE_1_0.txt or copy at
   13                        	;  http://www.boost.org/LICENSE_1_0.txt)
   14                        	;
   15                        	; ***************************************************************************
   16                        	; ***************************************************************************
   17                        	
   18                        	
   19                        	
   20                        	; ***************************************************************************
   21                        	; ***************************************************************************
   22                        	;
   23                        	; void __fastcall gfx_init( unsigned int start_vram_addr<_ax> );
   24                        	;
   25                        	; initialize graphics mode
   26                        	; - points graphics map to tiles at start_vram_addr
   27                        	
   28                        	_gfx_init.1	.proc
   73                        			.endp
   74                        	
   75                        	
   76                        	
   77                        	; ***************************************************************************
   78                        	; ***************************************************************************
   79                        	;
   80                        	; void __fastcall gfx_clear( unsigned int start_vram_addr<_di> );
   81                        	;
   82                        	; Clear the values in the graphics tiles
   83                        	; - places zeroes in graphics tiles at start_vram_addr
   84                        	
   85                        	_gfx_clear.1	.proc
  105                        			.endp
  106                        	
  107                        	
  108                        	
  109                        	; ***************************************************************************
  110                        	; ***************************************************************************
  111                        	;
  112                        	; void __fastcall gfx_line( unsigned int x1<_gfx_x1>, unsigned int y1<_gfx_y1>, unsigned int x2<_gfx_x2>, unsigned int y2<_gfx_y2>, unsigned char color<_gfx_color> );
  113                        	
  114                        	huc_gfx_line	.procgroup
  459                        			.endprocgroup	; huc_gfx_line
                             #[2]   "..\..\..\include\hucc\hucc-final.asm"
   92                        		.endif
   93                        	
   94               0000     		.ifdef	HUCC_USES_ZX0			; Set in hucc_zx0.h
   96                        		.endif
   97                        	
   98                        	
   99                        	
  100                        	; ***************************************************************************
  101                        	; ***************************************************************************
  102                        	;
  103                        	; Check that C "__zp" declarations aren't overwriting System Card variables.
  104                        	;
  105                        	
  106               20A0     			.zp
  107               0000     		.if	(* > zpg_sys_top) || (USING_PSGDRIVER && (* > zpg_psg_top))
  109                        		.endif
  110                        	
  111                        	
  112                        	
  113                        	; ***************************************************************************
  114                        	; ***************************************************************************
  115                        	;
  116                        	; Check that there isn't too much C "const" data in the ".RODATA" section.
  117                        	;
  118                        	
  119               613F     			.rodata
  120               0000     		.if	(bank(*) - _bank_base) >= (CONST_BANK + 2)
  122                        		.endif
  123               E937     			.code
                             #[1]   "main.s"

PROCEDURE LIST (in order of size):

Size: $151C, Addr: $01:C13F,      .proc _update_PLAYER
Size: $086D, Addr: $01:D65B, .procgroup blkmap_group
Size: $058F, Addr: $10:D960,      .proc _joypad_BUTTONS_SHOP
Size: $0417, Addr: $02:C000,      .proc _joypad_DIR
Size: $03EB, Addr: $02:C417,      .proc _init_SHOP
Size: $0390, Addr: $02:C802,      .proc huc_monofont_x
Size: $02F0, Addr: $02:CB92,      .proc _init_HUD
Size: $02AD, Addr: $02:CE82,      .proc _load_OBJECT_TILES
Size: $0292, Addr: $02:D12F, .procgroup chrmap_group
Size: $022B, Addr: $02:D3C1,      .proc _init_LEVEL
Size: $0184, Addr: $02:D5EC,      .proc _check_OBJECT
Size: $0167, Addr: $02:D770,      .proc _scroll_object
Size: $0167, Addr: $02:D8D7,      .proc _scroll_chest
Size: $0167, Addr: $02:DA3E,      .proc _scroll_npc
Size: $013D, Addr: $02:DBA5,      .proc _init_OBJECT_LV1
Size: $012D, Addr: $01:DEC8,      .proc _check_NPC
Size: $0108, Addr: $10:DEEF,      .proc read_joypads
Size: $0107, Addr: $02:DCE2,      .proc _recenter_CAMERA
Size: $00E2, Addr: $02:DDE9,      .proc _main
Size: $00DF, Addr: $02:DECB, .procgroup vdc_set_mode
Size: $00D4, Addr: $11:C000,      .proc _joypad_BUTTONS
Size: $00D4, Addr: $11:C0D4,      .proc _init_NPC_LV1
Size: $00C7, Addr: $11:C1A8,      .proc _init_CHEST_LV1
Size: $00BF, Addr: $11:C26F, .procgroup vdc_tty_out
Size: $009D, Addr: $11:C32E,      .proc _display_TIME
Size: $0086, Addr: $11:C3CB,      .proc _sgx_scroll_split.5
Size: $0081, Addr: $11:C451,      .proc vbl_init_scroll
Size: $007A, Addr: $11:C4D2,      .proc _check_TILE_DEPTH
Size: $0077, Addr: $11:C54C,      .proc core_main
Size: $006A, Addr: $11:C5C3, .procgroup load_vram_group
Size: $0064, Addr: $11:C62D,      .proc _check_BG
Size: $0062, Addr: $11:C691,      .proc _init_256x224
Size: $004B, Addr: $02:DFAA, .procgroup hucc_memcmp
Size: $004B, Addr: $11:C6F3, .procgroup old_satb_group
Size: $0043, Addr: $11:C73E, .procgroup vdc_clear_vram
Size: $0043, Addr: $11:C781,      .proc sgx_detect
Size: $003F, Addr: $11:C7C4, .procgroup load_bat_group
Size: $003E, Addr: $11:C803,      .proc _vram2vram.3
Size: $003B, Addr: $11:C841,      .proc init_random
Size: $003A, Addr: $11:C87C,      .proc _init_VARIABLES
Size: $002E, Addr: $11:C8B6,      .proc _scroll_BG
Size: $002B, Addr: $11:C8E4,      .proc _load_palette.3
Size: $0025, Addr: $11:C90F,      .proc _load_CHEST_TILES
Size: $0025, Addr: $11:C934,      .proc _load_NPC_TILES
Size: $0023, Addr: $11:C959,      .proc _hide_LEVEL_SPRITES
Size: $001E, Addr: $11:C97C,      .proc _init_PLAYER
Size: $001C, Addr: $11:C99A,      .proc _display_SCORE
Size: $001C, Addr: $11:C9B6,      .proc _display_ZENNY
Size: $001C, Addr: $11:C9D2,      .proc clear_vce
Size: $001A, Addr: $11:C9EE,      .proc _display_KEY
Size: $001A, Addr: $11:CA08,      .proc _display_POTION
Size: $001A, Addr: $11:CA22,      .proc _init_SYSTEM
