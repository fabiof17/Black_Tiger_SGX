                             #[1]   "main.s"
   27                        	
   28               0010     	CORE_VERSION	=	$10			; Version 1.0
   29                        	
   30                        			; Get the user program's configuration settings, this will
   31                        			; be read from the current directory, if it exists, or the
   32                        			; "../include/" directory if not.
   33                        	
                             #[4]   "..\..\..\include\hucc\core-config.inc"
   34                        			include	"core-config.inc"
    1                        	; ***************************************************************************
    2                        	; ***************************************************************************
    3                        	;
    4                        	; core-config.inc
    5                        	;
    6                        	; Configuration settings for the "CORE(not TM)" PC Engine library code.
    7                        	;
    8                        	; Copyright John Brandwood 2021-2024.
    9                        	;
   10                        	; Distributed under the Boost Software License, Version 1.0.
   11                        	; (See accompanying file LICENSE_1_0.txt or copy at
   12                        	;  http://www.boost.org/LICENSE_1_0.txt)
   13                        	;
   14                        	; ***************************************************************************
   15                        	; ***************************************************************************
   16                        	;
   17                        	; The idea is that you, a PCE developer, copy this file from the ../include/
   18                        	; directory and into your project's directory, and then customize the values
   19                        	; to suit your particular project.
   20                        	;
   21                        	; Because PCEAS searches the current (i.e. project) directory for an include
   22                        	; file first, then it will find your customized copy of the file rather than
   23                        	; the original copy in the ../include/ directory.
   24                        	;
   25                        	; That means that all of the different overlay programs in your project will
   26                        	; share the same overall library configuration for your game.
   27                        	;
   28                        	; ***************************************************************************
   29                        	; ***************************************************************************
   30                        	
   31                        	;
   32                        	; Are we going to take over MPR7?
   33                        	;
   34                        	; While this is the default for the "CORE(not TM)" library, it is definitely
   35                        	; possible to use the library to build CD-ROM code that runs with the System
   36                        	; Card in MPR7, and with the 1st bank remaining in MPR2.
   37                        	;
   38                        	; N.B. The CD-ROM Stage1 loader runs the library with USING_MPR7=0 while it
   39                        	;      installs the kernel into PCE RAM in MPR1.
   40                        	;
   41                        	
   42               0000     		.ifndef	USING_MPR7
   44                        		.endif
   45                        	
   46                        	;
   47                        	; Are we building a CD-ROM overlay that uses an already-built CD-ROM Stage1
   48                        	; loader to install the library's kernel code into PCE RAM in MPR1?
   49                        	;
   50                        	; If this is set, the library's kernel code will be excluded from the build,
   51                        	; which will save about 1KB-3KB of code space in every overlay program!
   52                        	;
   53                        	; N.B. The CD-ROM Stage1 loader sets USING_STAGE1=0 so it builds correctly.
   54                        	;
   55                        	
   56               0000     		.ifndef	USING_STAGE1
   58                        		.endif
   59                        	
   60                        	;
   61                        	; Are we currently building the CD-ROM Stage1 loader?
   62                        	;
   63                        	; If this is set, the library's startup code does not call the __sound_init
   64                        	; macro because the sound driver code is not usually a part of the kernel.
   65                        	;
   66                        	; N.B. The CD-ROM Stage1 loader sets BUILDING_STAGE1=1 so it builds correctly.
   67                        	;
   68                        	
   69               0000     		.ifndef	BUILDING_STAGE1
   71                        		.endif
   72                        	
   73                        	;
   74                        	; Is the last track of the CD a duplicate of the main ISO data track?
   75                        	;
   76                        	; Most CD games put two copies of the same ISO track on the CD, so that data
   77                        	; can be read from the secondary track if the drive has a problem reading it
   78                        	; it from the primary location.
   79                        	;
   80                        	; If set, the secondary track will be enabled when the library first starts.
   81                        	;
   82                        	
   83               0000     		.ifndef	SUPPORT_2ISO
   85                        		.endif
   86                        	
   87                        	;
   88                        	; Maximum number of directory entries to use from the ISO.
   89                        	;
   90                        	; The fewer that we choose, the less RAM memory we need. A setting of 64 is
   91                        	; a good compromise to use until you are putting lots of files on the ISO.
   92                        	;
   93                        	
   94               0000     		.ifndef	MAX_DIRSIZE
   96                        		.endif
   97                        	
   98                        	;
   99                        	; Use the System Card's PSG driver code instead of a modern alternative
  100                        	; sound driver like a DefleMask or Furnace player?
  101                        	;
  102                        	
  103               0000     		.ifndef	USING_PSGDRIVER
  105                        		.endif
  106                        	
  107                        	;
  108                        	; Support development for the Turbo EverDrive v2?
  109                        	;
  110                        	; This only applies to HuCard programs, but when chosen, the "CORE(not TM)"
  111                        	; kernel is moved from bank 0 to bank 2, and a minimal set of startup code
  112                        	; is put in bank 0.
  113                        	;
  114                        	; This is because the TED2 hardware occupies the whole of bank 0 when it is
  115                        	; activated, and so we need to run with a different bank in MPR7.
  116                        	;
  117                        	
  118               0000     		.ifndef	SUPPORT_TED2
  120                        		.endif
  121                        	
  122                        	;
  123                        	; Support development for the SuperGRAFX?
  124                        	;
  125                        	; This enables SuperGRAFX support in certain library functions.
  126                        	;
  127                        	
  128               0000     		.ifndef	SUPPORT_SGX
  130                        		.endif
  131                        	
  132                        	;
  133                        	; Choose SuperGRAFX VPC initialization mode.
  134                        	;
  135                        	; SGX_PARALLAX=0 (useful when VDC #1 is a fullscreen HUD)
  136                        	;
  137                        	;  FRONT
  138                        	;   SP1 = VDC #1 (pce) sprite pixels
  139                        	;   BG1 = VDC #1 (pce) background pixels
  140                        	;   SP2 = VDC #2 (sgx) sprite pixels
  141                        	;   BG2 = VDC #2 (sgx) background pixels
  142                        	;  BACK
  143                        	;
  144                        	; SGX_PARALLAX=1
  145                        	;
  146                        	;  FRONT
  147                        	;   SP1 = VDC #1 (pce) sprite pixels
  148                        	;   SP2 = VDC #2 (sgx) sprite pixels
  149                        	;   BG1 = VDC #1 (pce) background pixels
  150                        	;   BG2 = VDC #2 (sgx) background pixels
  151                        	;  BACK
  152                        	;
  153                        	
  154               0000     		.ifndef	SGX_PARALLAX
  156                        		.endif
  157                        	
  158                        	;
  159                        	; Support development for the ArcadeCard?
  160                        	;
  161                        	; This enables ArcadeCard support in certain library functions.
  162                        	;
  163                        	
  164               0000     		.ifndef	SUPPORT_ACD
  166                        		.endif
  167                        	
  168                        	;
  169                        	; Support development for the IFU's ADPCM hardware?
  170                        	;
  171                        	; Developers would normally just use the System Card functions for ADPCM, but
  172                        	; enabling this adds alternative functions, and allows ADPCM use on a HuCARD.
  173                        	;
  174                        	
  175               0000     		.ifndef	SUPPORT_ADPCM
  177                        		.endif
  178                        	
  179                        	;
  180                        	; Select which version of the joystick library code to include, only one of
  181                        	; these can be set to '1' ...
  182                        	;
  183                        	; SUPPORT_2BUTTON : Only returns buttons I and II.
  184                        	; SUPPORT_6BUTTON : Read buttons III-VI, but ignore a mouse.
  185                        	; SUPPORT_MOUSE	  : Read mouse, but ignore buttons III-VI.
  186                        	;
  187                        	; It doesn't make sense to design a game the relies on both the 6-button and
  188                        	; the mouse, so the joystick library is optimized for one or the other.
  189                        	;
  190                        	; Note that both those devices are always detected and no conflicts occur,
  191                        	; this just controls reading either buttons III-VI or the Mouse Y-movement.
  192                        	;
  193                        	
  194               0000     		.ifndef	SUPPORT_6BUTTON
  200                        		.endif
  201                        	
  202                        	;
  203                        	; How many joypad/mouse devices should be supported?
  204                        	;
  205                        	; This is normally 5, but can be set to 3 (or lower) in order to speed up
  206                        	; the processing and free up CPU time for other code, which is especially
  207                        	; useful for mouse games.
  208                        	;
  209                        	
  210               0000     		.ifndef	MAX_PADS
  212                        		.endif
  213                        	
  214                        	;
  215                        	; Implement a HuC-compatible seperate array for accumulating joypad presses?
  216                        	;
  217                        	; This is only really needed if your game is not expected to run at 60Hz and
  218                        	; so you will sometimes miss joypad presses.
  219                        	;
  220                        	; Alternatively you can set ACCUMULATE_JOY so that joypad presses are always
  221                        	; accumulated in the normal joytrg array, which is how asm programmers would
  222                        	; normally deal with this situation.
  223                        	;
  224                        	
  225               0000     		.ifndef HUC_JOY_EVENTS
  227                        		.endif
  228                        	
  229                        	;
  230                        	; Should "joytrg" accumulate presses, and so need to be explicitely cleared
  231                        	; after reading, or should it just be the result of the last read?
  232                        	;
  233                        	; This option has no effect if HUC_JOY_EVENTS is non-zero since that option
  234                        	; takes precedence over this one!
  235                        	;
  236                        	
  237               0000     		.ifndef ACCUMULATE_JOY
  239                        		.endif
  240                        	
  241                        	;
  242                        	; The DATA_BANK location needs to be set as early as possible so that library
  243                        	; code is able to put data in there before the total overall size of the code
  244                        	; is known.
  245                        	;
  246                        	; By default, DATA_BANK is the next bank after the CORE_BANK.
  247                        	;
  248                        	; RESERVE_BANKS allows developers to reserve some banks between the CORE_BANK
  249                        	; and the DATA_BANK that they can use however they wish.
  250                        	;
  251                        	; One use for RESERVE_BANKS is to create empty space that PCEAS can use when
  252                        	; it relocates procedures. This provides a way for a developer to group code
  253                        	; together at the start of memory, and leave the maximum number of banks for
  254                        	; loading dynamic data from CD-ROM.
  255                        	;
  256                        	; The KickC environment sets RESERVE_BANKS=1 (or higher) so that there is a
  257                        	; a bank for the permanent C code and static constants.
  258                        	;
  259                        	
  260               0000     		.ifndef	RESERVE_BANKS
  266                        		.endif	RESERVE_BANKS
                             #[3]   "..\..\..\include\hucc\core.inc"
   35                        	
   36                        	;
   37                        	; This is a simple macro to call System Card functions when using MPR7 for
   38                        	; running the "CORE(not TM)" PC Engine library code.
   39                        	;
   40                        	
   41                        	system		.macro
   42                        			ldy     #<\1
   43                        			jsr	call_bios
   44                        			.endm
   45                        	
   46                        	;
   47                        	; This replaces the System Card's ex_setvec, because "call_bios" uses the
   48                        	; Y register.
   49                        	;
   50                        	
   51                        	setvec		.macro
   52                        			php
   53                        			sei
   54                        			lda.l	#\2
   55                        			sta.l	\1
   56                        			lda.h	#\2
   57                        			sta.h	\1
   58                        			plp
   59                        			.endm
   60                        	
   61                        	;
   62                        	; Repurpose this System Card variable, since nmi_hook is never used.
   63                        	;
   64                        	; We'll use it as a vector to a user-supplied sound driver instead.
   65                        	;
   66                        	
   67               2206     	sound_hook	=	nmi_hook		; Sound Driver to run in VBL.
   68                        	
   69                        	;
   70                        	; CORE Zero-Page variables, relative to the System Card's ZP variables.
   71                        	;
   72                        	
   73               0000     		.if	USING_PSGDRIVER
   75                        		.else
   76               20EC     	core_zpend	=	$F8:20EC
   77                        		.endif	USING_PSGDRIVER
   78                        	
   79               0001     		.if	SUPPORT_SGX
   80                        	
   81                        			; Put some "CORE(not TM)" variables at the start of Zero Page.
   82                        			;
   83                        			; These are at the *start* of ZP so that the SuperGrafx shadow
   84                        			; "sgx_" registers are at a specific offset from their System
   85                        			; Card "vdc_" counterparts, and they MUST NOT be moved!
   86                        			;
   87                        			; This allows us to put SGX_VDC_OFFSET or PCE_VDC_OFFSET into
   88                        			; the X register, and then index into either set of hardware
   89                        			; registers and the "sgx_reg" or "vdc_reg" shadow-variables.
   90                        	
   91               0000     	PCE_VDC_OFFSET	=	$00		; Offset to PCE VDC chip & shadow vars.
   92               0010     	SGX_VDC_OFFSET	=	$10		; Offset to SGX VDC chip & shadow vars.
   93                        	
   94               2000     			.zp
   95               2000     			.org	$2000
   96    F8:2000             	__temp		ds	2		; $F8:2000 Use within any ASM routine.
   97    F8:2002             	_bp_bank	ds	1		; $F8:2002 Use within any ASM/HuCC routine.
   98    F8:2003             	sgx_crl		ds	1		; $F8:2003 SGX shadow (vdc_crl = $20F3).
   99    F8:2004             	sgx_crh		ds	1		; $F8:2004 SGX shadow (vdc_crh = $20F4).
  100    F8:2005             	core_1stbank	ds	1		; $F8:2005 1st bank of library code.
  101    F8:2006             	sgx_sr		ds	1		; $F8:2006 SGX shadow (vdc_sr  = $20F6).
  102    F8:2007             	sgx_reg		ds	1		; $F8:2007 SGX shadow (vdc_reg = $20F7).
  103                        	
  104               2008     	core_zp1st	=	*		; $F8:2008 1st free user address.
  105                        	
  106                        		.else	SUPPORT_SGX
  116                        		.endif	SUPPORT_SGX
  117                        	
  118                        	;
  119                        	; The kernel code in RAM follows the System Card's RAM variables.
  120                        	;
  121                        	
  122               0000     		.if	USING_PSGDRIVER
  124                        		.else
  125               22D0     	core_ram1st     =	$F8:22D0
  126                        		.endif	USING_PSGDRIVER
  127                        	
  128                        	;
  129                        	; Include the "CORE(not TM)" startup code to begin the HuCARD / Overlay.
  130                        	;
  131                        	
                             #[4]   "..\..\..\include\hucc\core-startup.asm"
  132                        			include	"core-startup.asm"
    1                        	; ***************************************************************************
    2                        	; ***************************************************************************
    3                        	;
    4                        	; core-startup.asm
    5                        	;
    6                        	; The "CORE(not TM)" PC Engine library startup code that runs at boot/reset.
    7                        	;
    8                        	; Copyright John Brandwood 2021-2024.
    9                        	;
   10                        	; Distributed under the Boost Software License, Version 1.0.
   11                        	; (See accompanying file LICENSE_1_0.txt or copy at
   12                        	;  http://www.boost.org/LICENSE_1_0.txt)
   13                        	;
   14                        	; ***************************************************************************
   15                        	; ***************************************************************************
   16                        	;
   17                        	; This is the initialization code in the 1st bank, and it is responsible for
   18                        	; setting up a consistant runtime environment for the developer's program,
   19                        	; so that the developer can concentrate on writing the program itself.
   20                        	;
   21                        	; The idea is that when a program is loaded, the first 40KB of it is mapped
   22                        	; as $4000..$DFFF, and initialization starts at $4000, with the developer's
   23                        	; program getting control after initialization, with a jump to "core_main".
   24                        	;
   25                        	; The initializtion sets up a small kernel of code that provides interrupt
   26                        	; handling that mimics a subset of the System Card's behavior, designed to
   27                        	; act in the same way on HuCARD and CD-ROM, with either the System Card in
   28                        	; MPR7, or with an overlay in MPR7.
   29                        	;
   30                        	; The kernel handles reading the joypad/mouse, and it offers handler hooks
   31                        	; for running the developer's interrupt code.  On CD-ROM systems, it also
   32                        	; handles the loading and running of subsequent overlay programs.
   33                        	;
   34                        	; On HuCARD, the kernel itself runs in MPR7; while on CD-ROM systems it is
   35                        	; run from RAM in MPR1, so that overlay programs are independant from each
   36                        	; other, and can be written in different programming languages.
   37                        	;
   38                        	;
   39                        	; 1) If we're running on a HuCARD, the initialization is simple!
   40                        	;
   41                        	;    The PC Engine's memory map is set to ...
   42                        	;
   43                        	;      MPR0 = bank $FF : PCE hardware
   44                        	;      MPR1 = bank $F8 : PCE RAM with Stack & ZP
   45                        	;      MPR2 = bank $00 : HuCARD ROM
   46                        	;      MPR3 = bank $01 : HuCARD ROM
   47                        	;      MPR4 = bank $02 : HuCARD ROM
   48                        	;      MPR5 = bank $03 : HuCARD ROM
   49                        	;      MPR6 = bank $04 : HuCARD ROM
   50                        	;      MPR7 = bank $00 : HuCARD ROM
   51                        	;
   52                        	;
   53                        	; 2) If we're running on a HuCARD that supports the Turbo Everdrive, then the
   54                        	;    first 2 banks are reserved for mapping the TED2 hardware and a RAM bank.
   55                        	;
   56                        	;    The PC Engine's memory map is set to ...
   57                        	;
   58                        	;      MPR0 = bank $FF : PCE hardware
   59                        	;      MPR1 = bank $F8 : PCE RAM with Stack & ZP
   60                        	;      MPR2 = bank $02 : HuCARD ROM
   61                        	;      MPR3 = bank $03 : HuCARD ROM
   62                        	;      MPR4 = bank $04 : HuCARD ROM
   63                        	;      MPR5 = bank $05 : HuCARD ROM
   64                        	;      MPR6 = bank $06 : HuCARD ROM
   65                        	;      MPR7 = bank $02 : HuCARD ROM
   66                        	;
   67                        	;
   68                        	; 3) If we're running on an old CD System, the overlay is loaded from the ISO
   69                        	;    into banks $80-$87 (64KB max).
   70                        	;
   71                        	;    The PC Engine's memory map is set to ...
   72                        	;
   73                        	;      MPR0 = bank $FF : PCE hardware
   74                        	;      MPR1 = bank $F8 : PCE RAM with Stack & ZP
   75                        	;      MPR2 = bank $80 : CD RAM
   76                        	;      MPR3 = bank $81 : CD RAM
   77                        	;      MPR4 = bank $82 : CD RAM
   78                        	;      MPR5 = bank $83 : CD RAM
   79                        	;      MPR6 = bank $84 : CD RAM
   80                        	;      MPR7 = bank $80 : CD RAM or System Card's bank $00
   81                        	;
   82                        	;
   83                        	; 4) If we're running on a SuperCD System, the overlay is loaded from the ISO
   84                        	;    into banks $68-$87 (256KB max).
   85                        	;
   86                        	;    The PC Engine's memory map is set to ...
   87                        	;
   88                        	;      MPR0 = bank $FF : PCE hardware
   89                        	;      MPR1 = bank $F8 : PCE RAM with Stack & ZP
   90                        	;      MPR2 = bank $68 : SCD RAM
   91                        	;      MPR3 = bank $69 : SCD RAM
   92                        	;      MPR4 = bank $6A : SCD RAM
   93                        	;      MPR5 = bank $6B : SCD RAM
   94                        	;      MPR6 = bank $6C : SCD RAM
   95                        	;      MPR7 = bank $68 : SCD RAM or System Card's bank $00
   96                        	;
   97                        	; ***************************************************************************
   98                        	; ***************************************************************************
   99                        	
  100                        	
  101                        	
  102               E000     			.code
  103               0000     			.bank	0
  104                        	
  105               0000     		.if	SUPPORT_TED2			; Do we want to use a TED2?
  177                        		.endif	SUPPORT_TED2
  178                        	
  179                        	
  180                        	
  181               0001     		.if	USING_MPR7
  182                        	
  183                        	; ***************************************************************************
  184                        	; ***************************************************************************
  185                        	;
  186                        	; RESET VECTORS (when running in MPR7, either as a HuCARD, or a CD overlay)
  187                        	;
  188                        	
  189                        			; Hardware reset and interrupt vectors.
  190                        	
  191               FFF4     			.org	$FFF4
  192                        	
  193    00:FFF4  10         	core_version:	db	CORE_VERSION		; CORE(not TM) Version.
  194    00:FFF5  80         			db	$80			; System Card compatibility.
  195                        	
  196    00:FFF6  5D E0      			dw	core_irq2		; IRQ2	(from CD/ADPCM)
  197    00:FFF8  64 E0      			dw	core_irq1		; IRQ1	(from VDC)
  198    00:FFFA  58 E1      			dw	core_timer		; TIMER (from CPU)
  199    00:FFFC  5E E1      			dw	core_rti		; NMI	(unused)
  200               0000     		.if	CDROM
  202                        		.else
  203    00:FFFE  21 E0      			dw	core_hw_reset		; RESET (HuCARD)
  204                        		.endif	CDROM
  205                        	
  206               0001     		.if	USING_NEWPROC			; If the ".proc" trampolines
  207               FFF3     	__trampolineptr =	$FFF3			; are in MPR7, tell PCEAS to
  208                        		.endif					; put them below the vectors.
  209                        	
  210                        		.else	USING_MPR7
  222                        		.endif	USING_MPR7
  223                        	
  224                        	
  225                        	
  226                        	; ***************************************************************************
  227                        	; ***************************************************************************
  228                        	;
  229                        	; !!! THE HuCARD/OVERLAY PROGRAM'S FIRST BANK STARTS HERE !!!
  230                        	;
  231                        	
  232                        			; Switch to MPR2 for the "CORE(not TM)" library init.
  233                        			;
  234                        			; This is also executed by a HuCARD once it has run
  235                        			; its initial hardware-reset code.
  236                        			;
  237                        			; When run, MPR2-MPR6 are always mapped to the 1st 5 banks of
  238                        			; the overlay program, and MPR7 contains the System Card.
  239                        	
  240               4000     			.org	$4000
  241                        	
  242               0000     	CORE_BANK	=	bank(*) - _bank_base	; It isn't always zero! ;-)
  243                        	
  244               0000     			.bank	CORE_BANK, "CORE_BANK"	; Give it a label.
  245                        	
  246               0001     		.if	USING_MPR7
  247               0007     	CORE_PAGE	=	7			; User code runs in MPR7.
  248                        		.else
  250                        		.endif	USING_MPR7
  251                        	
  252    00:4000  4C 06 40   	core_boot:	jmp	* + 6			; Allow someone to patch this.
  253                        	
  254                        			; Add an ident string so isoLINK can autodetect configuration.
  255                        			;
  256                        			; This allows isoLINK to decide whether to use the IPL-SCD boot
  257                        			; sector hack, and whether to include a SuperGRAFX signature in
  258                        			; the boot sector, without the user having to manually use some
  259                        			; command line parameters, although they are free to do that if
  260                        			; they wish.
  261                        	
  262               0001     		.if	SUPPORT_SGX
  263               0000     		.if	BUILDING_STAGE1
  265                        		.else
  266    00:4003  53 47 58   			db	"SGX"			; SGX SuperCD or SGX HuCARD.
  267                        		.endif	BUILDING_STAGE1
  268                        		.else
  282                        		.endif	SUPPORT_SGX
  283                        	
  284               0000     		.if	CDROM
  331                        		.else	CDROM
  332                        	
  333                        			; Set up HuCARD RAM in a compatible way to the System Card.
  334                        			;
  335                        			; Note that the entire RAM is cleared by "core_hw_reset".
  336                        	
  337    00:4006  A9 1F      			lda	#%11111			; Enable joypad soft-reset.
  338    00:4008  8D 27 22   			sta	joyena
  339                        	
  340                        		.endif	CDROM
  341                        	
  342                        			; Now that RAM is initialized ...
  343                        	
  344    00:400B  43 04      			tma2				; Remember overlay's 1st bank
  345    00:400D  85 05      			sta	<core_1stbank		; $00, $02, $68 or $80!
  346               0001     		.if	USING_MPR7
  347    00:400F  53 80      			tam7				; "CORE(not TM)" takes MPR7!
  348                        		.endif
  349                        	
  350    00:4011  A2 FF      			ldx	#$FF			; Initialize stack pointer.
  351    00:4013  9A         			txs
  352                        	
  353    00:4014  20 5F E1   			jsr	core_clr_hooks		; Reset default hooks.
  354                        	
  355                        	;		stz	TIMER_CR		; Stop HuC6280 timer.
  356                        	;		stz	IRQ_ACK			; Clr HuC6280 timer interrupt.
  357                        	;		stz	IRQ_MSK			; Clr HuC6280 interrupt mask.
  358                        	
  359    00:4017  AD 00 02   			lda	VDC_SR			; Purge any overdue VBL.
  360    00:401A  9C 41 22   			stz	irq_cnt			; Make it easy to check.
  361    00:401D  58         			cli				; Restore interrupts.
  362                        	
  363    00:401E  4C E5 FF   			jmp	core_main		; Start the game's code.
  364                        	
  365                        	
  366                        	
  367               0001     		.if	!CDROM
  368                        	
  369                        	; ***************************************************************************
  370                        	; ***************************************************************************
  371                        	;
  372                        	; HuCARD Kernel Code
  373                        	;
  374                        	; core_ram1st - Start of code to relocate to MPR1.
  375                        	; core_ramend - End of code to relocate to MPR1.
  376                        	;
  377                        	
  378                        			; In a HuCARD, BSS variables start as low as possible.
  379                        	
  380               2200     			.bss
  381               22D0     			.org	core_ram1st
  382               22D0     	core_ramend	=	*
  383               4021     			.code
  384                        	
  385                        			; Normal HuCARD hardware-reset code, executed in MPR7.
  386                        			;
  387                        			; This does the basic PCE startup that every HuCARD (including
  388                        			; a System Card) needs to do, and then it remaps memory to be
  389                        			; compatible with the "CORE(not TM)" CD overlay program start.
  390                        	
  391               E021     			.page	7			; This will run in MPR7.
  392                        	
  393    00:E021  78         	core_hw_reset:	sei				; Disable interrupts.
  394    00:E022  D4         			csh				; Set high-speed mode.
  395    00:E023  D8         			cld
  396                        	
  397    00:E024  A2 FF      			ldx	#$FF			; Initialize stack pointer.
  398    00:E026  9A         			txs
  399    00:E027  8A         			txa				; MPR0 = $FF : PCE hardware
  400    00:E028  53 01      			tam0				; MPR1 = $F8 : PCE RAM
  401    00:E02A  A9 F8      			lda	#$F8
  402    00:E02C  53 02      			tam1
  403                        	
  404    00:E02E  9C 01 0C   			stz	TIMER_CR		; HW reset already does these,
  405    00:E031  9C 03 14   			stz	IRQ_ACK			; but this may be a reset from
  406    00:E034  9C 02 14   			stz	IRQ_MSK			; software (i.e. joypad).
  407                        	
  408    00:E037  F3 53 E0 00			tai	const_0000, $2000, 8192 ; Clear RAM.
         00:E03B  20 00 20    
  409                        	
  410    00:E03E  43 80      			tma7				; Not always bank 0!
  411                        	
  412    00:E040  53 04      			tam2				; Set CD-ROM overlay memory map,
  413    00:E042  1A         			inc	a			; 1st 5 banks in MPR2-MPR6.
  414    00:E043  53 08      			tam3
  415    00:E045  1A         			inc	a
  416    00:E046  53 10      			tam4
  417    00:E048  1A         			inc	a
  418    00:E049  53 20      			tam5
  419    00:E04B  1A         			inc	a
  420    00:E04C  53 40      			tam6
  421                        	
  422    00:E04E  4C 00 40   			jmp	core_boot		; Continue execution in MPR2.
  423                        	
  424                        			; In a HuCARD, the kernel code is permanently in MPR7.
  425                        	
                             #[5]   "..\..\..\include\hucc\core-kernel.asm"
  426                        			include "core-kernel.asm"
    1                        	; ***************************************************************************
    2                        	; ***************************************************************************
    3                        	;
    4                        	; core-kernel.asm
    5                        	;
    6                        	; The "CORE(not TM)" PC Engine library kernel code that runs after startup.
    7                        	;
    8                        	; Copyright John Brandwood 2021-2024.
    9                        	;
   10                        	; Distributed under the Boost Software License, Version 1.0.
   11                        	; (See accompanying file LICENSE_1_0.txt or copy at
   12                        	;  http://www.boost.org/LICENSE_1_0.txt)
   13                        	;
   14                        	; ***************************************************************************
   15                        	; ***************************************************************************
   16                        	;
   17                        	; This code is permanently located in either MPR7 (HuCARD), or MPR1 (CD-ROM),
   18                        	; and it provides a consistant method of interrupt-handling on both systems
   19                        	; that is designed to be compatible with the System Card.
   20                        	;
   21                        	; The library uses the "irq1_hook" for its own VDC interrupt handler, and PCE
   22                        	; developers are expected to use "vsync_hook" and "hsync_hook" for their VDC
   23                        	; interrupt functions.  Plenty of memory is available in the 1st bank for the
   24                        	; developer to put those functions.
   25                        	;
   26                        	; The reason for using "irq1_hook", is so that the library can work properly
   27                        	; if either the current overlay program, or the System Card, are mapped into
   28                        	; MPR7 whenever an interrupt occurs.
   29                        	;
   30                        	; The VDC interupt handler itself is changed from the System Card's handler,
   31                        	; and it is designed to provide faster response to vsync_hook, and to enable
   32                        	; interrupts during the slow(ish) joypad and sound driver code, so that both
   33                        	; raster and timer interrupts are not delayed.
   34                        	;
   35                        	; Developers are free to enable interrupts during their own vsync_hook code,
   36                        	; if they wish to do so.
   37                        	;
   38                        	; On CD-ROM systems, this library kernel also provides a function to load and
   39                        	; run a new overlay program, without relying upon any of the code/data within
   40                        	; the current overlay program's memory (unlike HuC v3).
   41                        	;
   42                        	; ***************************************************************************
   43                        	; ***************************************************************************
   44                        	
   45                        	
   46                        	
   47                        	; ***************************************************************************
   48                        	; ***************************************************************************
   49                        	;
   50                        	; core_kernel - Start of kernel code.
   51                        	;
   52                        	
   53               E051     	core_kernel	=	*
   54                        	
   55                        	
   56                        	
   57                        	; ***************************************************************************
   58                        	; ***************************************************************************
   59                        	;
   60                        	; Useful constants, needed by joypad library code, and used by many others.
   61                        	;
   62                        	; The kernel starts with a non-zero byte so that core-startup.asm can check
   63                        	; whether it has already been loaded into RAM.
   64                        	;
   65                        	
   66    00:E051  FF FF      	const_FFFF:	dw	$FFFF			; Useful constant for TAI.
   67    00:E053  00 00      	const_0000:	dw	$0000			; Useful constant for TAI.
   68                        	
   69    00:E055  01 02 04 08	bit_mask:	db	$01,$02,$04,$08,$10,$20,$40,$80
         00:E059  10 20 40 80 
   70                        	
   71                        	
   72                        	
   73                        	; ***************************************************************************
   74                        	; ***************************************************************************
   75                        	;
   76                        	; core_irq2  - Minimal interrupt handler compatible with System Card.
   77                        	; core_irq1  - Minimal interrupt handler compatible with System Card.
   78                        	; core_timer - Minimal interrupt handler compatible with System Card.
   79                        	; core_rti   - Minimal interrupt handler compatible with System Card.
   80                        	;
   81                        	; Note that it takes 8 cycles to respond to an IRQ.
   82                        	;
   83                        	; These routines are copied to a location in RAM that does not vary when
   84                        	; a different overlay program is loaded.
   85                        	;
   86                        	; All overlay programs are set up to vector interrupts to these routines,
   87                        	; which is designed to avoid interrupt-related crashes when loading a new
   88                        	; overlay on top of an old overlay in memory.
   89                        	;
   90                        	; All of the game's actual interrupt handling itself is done in the "hook"
   91                        	; functions so that everything works the same if the System Card is banked
   92                        	; into MPR7 when an interrupt occurs.
   93                        	;
   94                        	; ***************************************************************************
   95                        	; ***************************************************************************
   96                        	;
   97                        	; Bit settings for irq_vec  ...
   98                        	;
   99                        	;   7 : 1 to skip BIOS hsync processsing
  100                        	;   6 : 1 to call [hsync_hook]
  101                        	;   5 : 1 to skip BIOS vsync processsing
  102                        	;   4 : 1 to call [vsync_hook]
  103                        	;
  104                        	;   3 : 1 to jump [nmi_hook]
  105                        	;   2 : 1 to jump [timer_hook]
  106                        	;   1 : 1 to jump [irq1_hook]
  107                        	;   0 : 1 to jump [irq2_hook]
  108                        	;
  109                        	; ***************************************************************************
  110                        	; ***************************************************************************
  111                        	
  112    00:E05D  8F F5 01   	core_irq2:	bbs0	<irq_vec, .hook		; 8 cycles if using hook.
  113                        	
  114               0000     		.if	CDROM
  138                        		.else
  139                        			; Does this HuCARD support the IFU's ADPCM hardware?
  140                        	
  141               0000     		.if	SUPPORT_ADPCM
  153                        		.endif	SUPPORT_ADPCM
  154                        	
  155    00:E060  40         			rti				; No IRQ2 hardware on HuCARD.
  156                        	
  157    00:E061  6C 00 22   	.hook:		jmp	[irq2_hook]		; 7 cycles.
  158                        		.endif	CDROM
  159                        	
  160                        	
  161                        	
  162                        	; ***************************************************************************
  163                        	; ***************************************************************************
  164                        	;
  165                        	; core_irq1 - Minimal interrupt handler compatible with System Card.
  166                        	;
  167                        	; irq1_handler - Basic "CORE(not TM)" IRQ1 handler to use as the "irq1_hook".
  168                        	;
  169                        	; Doing the IRQ1 handler processing in this hook means that things operate
  170                        	; the same whether the System Card or an Overlay is paged into MPR7.
  171                        	
  172               0000     		.ifndef	HUCC
  181                        		.else
  182                        			; Faster IRQ servicing for HuCC and code that would like to
  183                        			; avoid the 8 cycles used by the "bbs1" instruction that is
  184                        			; taken when the System Card is mapped into MPR7.
  185                        	
  186    00:E064             	core_irq1:	;;;				; 8 (cycles for the INT)
  187               0001     		.if	CDROM || !defined(NO_CORE_IRQ1_HOOK)
  188    00:E064  6C 02 22   			jmp	[irq1_hook]		; 7 cycles.
  189                        	
  190                        		.endif
  191                        		.endif
  192                        	
  193    00:E067  48         	irq1_handler:	pha				; 3 Save all registers.
  194    00:E068  DA         			phx				; 3
  195    00:E069  5A         			phy				; 3
  196                        	
  197               0000     		.ifndef	USING_RCR_MACROS		;   This slows things down
  206                        		.endif	USING_RCR_MACROS
  207                        	
  208    00:E06A  AD 00 02   			lda	VDC_SR			; 6 Acknowledge the VDC's IRQ.
  209    00:E06D  85 F6      			sta	<vdc_sr			; 4 Remember what caused it.
  210                        	
  211               0001     		.if	SUPPORT_SGX
  212    00:E06F  AE 10 02   			ldx	SGX_SR			; 6 Read SGX_SR after VDC_SR in
  213    00:E072  86 06      			stx	<sgx_sr			; 4 case this is not an SGX!
  214                        		.endif
  215                        	
  216                        			; Handle the VDC's RCR interrupt.
  217                        	
  218    00:E074  29 04      	!:		and	#$04			; 2 Is this an HSYNC interrupt?
  219    00:E076  F0 44      			beq	!+			; 2
  220                        	
  221               0001     		.ifdef	USING_RCR_MACROS
  222                        			VDC_RCR_MACRO
                             	
         00:E078  03 06      			st0	#VDC_RCR		; 5
                             	
         00:E07A  AE E5 23   			ldx	vdc_next_region		; 5 X and Y can be greater than
         00:E07D  BC E6 23   			ldy	vdc_regionA_nxt, x	; 5 HUCC_PCE_SPLITS if regionB!
         00:E080  18         			clc				; 2
         00:E081  D0 05      			bne	!set_next_rcr+		; 4 Stop RCR if next line is 0.
                             	
         00:E083  2D 53 E0   			and	const_0000		; 5 A=$00 with the same #cycles
         00:E086  80 05      			bra	!clr_next_rcr+		; 4 as if the branch were taken.
                             	
         00:E088  B9 95 23   	!set_next_rcr:	lda	vdc_regionA_rcr, y	; 5 Set next RCR 1 line before
         00:E08B  69 3F      			adc	#64-1			; 2 the region begins, or 0 to
         00:E08D  8D 02 02   	!clr_next_rcr:	sta	VDC_DL			; 6 disable.
         00:E090  62         			cla				; 2
         00:E091  2A         			rol	a			; 2
         00:E092  8D 03 02   			sta	VDC_DH			; 6
                             	
         00:E095  03 08      			st0	#VDC_BYR		; 5 Do BYR first to mitigate the
         00:E097  BD C5 23   			lda	vdc_regionA_yl, x	; 5 glitch if the IRQ is delayed.
         00:E09A  8D 02 02   			sta	VDC_DL			; 6 = 105 cycles from RCR on SGX
         00:E09D  BD D5 23   			lda	vdc_regionA_yh, x	; 5
         00:E0A0  8D 03 02   			sta	VDC_DH			; 6
                             	
         00:E0A3  03 05      			st0	#VDC_CR			; 5
         00:E0A5  BD 85 23   			lda	vdc_regionA_crl, x	; 5
                             	;		asl	a
         00:E0A8  8D 02 02   			sta	VDC_DL			; 6
                             	
         00:E0AB  03 07      			st0	#VDC_BXR		; 2
         00:E0AD  BD A5 23   			lda	vdc_regionA_xl, x	; 5
         00:E0B0  8D 02 02   			sta	VDC_DL			; 6
         00:E0B3  BD B5 23   			lda	vdc_regionA_xh, x	; 5
         00:E0B6  8D 03 02   			sta	VDC_DH			; 6 = 156 cycles from RCR if DUO
                             	
                             	;		bcc	!+
                             	;		lda	vdc_regionA_yh, x	; 5
                             	;		sta.l	VCE_CTW			; 6
                             	
         00:E0B9  8C E5 23   			sty	vdc_next_region		; 5
                             	
  223                        		.else
  225                        		.endif
  226                        	
  227               0001     		.if	SUPPORT_SGX
  228                        	
  229                        			; Handle the SGX's RCR interrupt.
  230                        	
  231    00:E0BC  2F 06 50   	!:		bbr2	<sgx_sr, !+		; 6 Is this an HSYNC interrupt?
  232                        	
  233               0001     		.ifdef	USING_RCR_MACROS
  234                        			SGX_RCR_MACRO
                             	
         00:E0BF  A9 06      			lda	#VDC_RCR		; 2
         00:E0C1  8D 10 02   			sta	SGX_AR			; 6
                             	
         00:E0C4  AE 66 24   			ldx	sgx_next_region		; 5 X and Y can be greater than
         00:E0C7  BC 67 24   			ldy	sgx_regionA_nxt, x	; 5 HUCC_SGX_SPLITS if regionB!
         00:E0CA  18         			clc				; 2
         00:E0CB  D0 05      			bne	!set_next_rcr+		; 4 Stop RCR if next line is 0.
                             	
         00:E0CD  2D 53 E0   			and	const_0000		; 5 A=$00 with the same #cycles
         00:E0D0  80 05      			bra	!clr_next_rcr+		; 4 as if the branch were taken.
                             	
         00:E0D2  B9 16 24   	!set_next_rcr:	lda	sgx_regionA_rcr, y	; 5 Set next RCR 1 line before
         00:E0D5  69 3F      			adc	#64-1			; 2 the region begins, or 0 to
         00:E0D7  8D 12 02   	!clr_next_rcr:	sta	SGX_DL			; 6 disable.
         00:E0DA  62         			cla				; 2
         00:E0DB  2A         			rol	a			; 2
         00:E0DC  8D 13 02   			sta	SGX_DH			; 6
                             	
         00:E0DF  A9 08      			lda	#VDC_BYR		; 2 Do BYR first to mitigate the
         00:E0E1  8D 10 02   			sta	SGX_AR			; 6 glitch if the IRQ is delayed.
         00:E0E4  BD 46 24   			lda	sgx_regionA_yl, x	; 5
         00:E0E7  8D 12 02   			sta	SGX_DL			; 6
         00:E0EA  BD 56 24   			lda	sgx_regionA_yh, x	; 5
         00:E0ED  8D 13 02   			sta	SGX_DH			; 6
                             	
         00:E0F0  A9 05      			lda	#VDC_CR			; 2
         00:E0F2  8D 10 02   			sta	SGX_AR			; 6
         00:E0F5  BD 06 24   			lda	sgx_regionA_crl, x	; 5
         00:E0F8  8D 12 02   			sta	SGX_DL			; 6
                             	
         00:E0FB  A9 07      			lda	#VDC_BXR		; 2
         00:E0FD  8D 10 02   			sta	SGX_AR			; 6
         00:E100  BD 26 24   			lda	sgx_regionA_xl, x	; 5
         00:E103  8D 12 02   			sta	SGX_DL			; 6
         00:E106  BD 36 24   			lda	sgx_regionA_xh, x	; 5
         00:E109  8D 13 02   			sta	SGX_DH			; 6 = 293 cycles (282 if no YH)
                             	
         00:E10C  8C 66 24   			sty	sgx_next_region		; 5
                             	
  235                        		.else
  237                        		.endif
  238                        	
  239                        		.endif	SUPPORT_SGX
  240                        	
  241                        			; Handle the VDC's VBL interrupt.
  242                        	
  243    00:E10F  5F F6 32   	!:		bbr5	<vdc_sr, .exit_irq1	; 6 Is this a VBLANK interrupt?
  244                        	
  245               0001     		.ifdef	USING_RCR_MACROS		;   If we didn't do it earlier
  246               0000     		.if	CDROM				;   then we need to do it now.
  253                        		.endif	CDROM
  254                        		.endif	USING_RCR_MACROS
  255                        	
  256               0001     		.if	SUPPORT_SGX
  257    00:E112  A9 05      			lda	#VDC_CR			; Update the SGX's Control
  258    00:E114  8D 10 02   			sta	SGX_AR			; Register first, just in
  259    00:E117  8D 00 02   			sta	VDC_AR			; case this is not an SGX!
  260    00:E11A  A5 03      			lda	<sgx_crl		
  261    00:E11C  8D 12 02   			sta	SGX_DL
  262    00:E11F  A5 F3      			lda	<vdc_crl
  263    00:E121  8D 02 02   			sta	VDC_DL
  264                        	
  265                        	;		lda	<sgx_crh		; Do not mess with the SGX's
  266                        	;		sta	SGX_DH			; auto-increment!!!
  267                        	;		lda	<vdc_crh		; Do not mess with the VDC's
  268                        	;		sta	VDC_DH			; auto-increment!!!
  269                        		.else
  277                        		.endif	SUPPORT_SGX
  278                        	
  279    00:E124  EE 41 22   			inc	irq_cnt			; Mark that a VBLANK occurred.
  280                        	
  281    00:E127  4F F5 02   			bbr4	<irq_vec, .skip_hookv	; Is a driver registered?
  282                        	
  283    00:E12A  44 26      			bsr	.user_vsync		; Call game's VBLANK code.
  284                        	
  285    00:E12C  DF F5 15   	.skip_hookv:	bbs5	<irq_vec, .exit_vbl	; Should we skip "BIOS" stuff?
  286                        	
  287    00:E12F  58         			cli				; Allow HSYNC and TIMER IRQ.
  288                        	
  289    00:E130  20 DB FF   			call	read_joypads		; Update joypad state.
  290                        	
  291               0000     		.if	USING_PSGDRIVER
  305                        		.else
  306    00:E133  AD 07 22   			lda	sound_hook + 1		; Is a driver registered?
  307    00:E136  F0 0C      			beq	.exit_vbl
  308                        	
  309    00:E138  A9 80      			lda	#$80			; Acquire sound mutex to avoid
  310    00:E13A  0C E7 22   			tsb	sound_mutex		; conflict with a delayed VBL.
  311    00:E13D  30 05      			bmi	.exit_vbl
  312                        	
  313    00:E13F  44 14      			bsr	.user_sound		; Call the driver hook.
  314                        	
  315    00:E141  9C E7 22   			stz	sound_mutex		; Release sound mutex.
  316                        		.endif	USING_PSGDRIVER
  317                        	
  318    00:E144             	.exit_vbl:
  319                        	
  320               0001     		.ifdef	USING_RCR_MACROS		; If USING_RCR_MACROS then 
  321               0000     		.if	CDROM				; restore after the VBLANK.
  326                        		.endif	CDROM
  327                        		.endif	USING_RCR_MACROS
  328                        	
  329    00:E144             	.exit_irq1:
  330                        	
  331               0000     		.ifndef	USING_RCR_MACROS		; If !USING_RCR_MACROS then
  338                        		.endif	USING_RCR_MACROS
  339                        	
  340               0001     		.if	SUPPORT_SGX
  341    00:E144  A5 07      			lda	<sgx_reg		; Restore SGX_AR first, just
  342    00:E146  8D 10 02   			sta	SGX_AR			; in case this is not an SGX!
  343                        		.endif
  344                        	
  345    00:E149  A5 F7      			lda	<vdc_reg		; Restore VDC_AR in case we
  346    00:E14B  8D 00 02   			sta	VDC_AR			; changed it.
  347                        	
  348    00:E14E  7A         			ply				; Restore all registers.
  349    00:E14F  FA         			plx
  350    00:E150  68         			pla
  351                        	
  352    00:E151  40         			rti				; Return from interrupt.
  353                        	
  354    00:E152  6C 08 22   	.user_vsync:	jmp	[vsync_hook]		; 7
  355    00:E155  6C 06 22   	.user_sound:	jmp	[sound_hook]		; 7
  356                        	
  357               0000     		.ifndef	USING_RCR_MACROS
  362                        		.endif	USING_RCR_MACROS
  363                        	
  364                        	
  365                        	
  366                        	; ***************************************************************************
  367                        	; ***************************************************************************
  368                        	;
  369                        	; core_timer - Minimal interrupt handler compatible with System Card.
  370                        	;
  371                        	; tirq_handler - Basic "CORE(not TM)" TIRQ handler to use as the "timer_hook".
  372                        	;
  373                        	; Doing the TIRQ handler processing in this hook means that things operate
  374                        	; the same whether the System Card or an Overlay is paged into MPR7.
  375                        	
  376               0000     		.ifndef	HUCC
  385                        		.else
  386                        			; Faster IRQ servicing for HuCC and code that would like to
  387                        			; avoid the 8 cycles used by the "bbs2" instruction that is
  388                        			; taken when the System Card is mapped into MPR7.
  389                        	
  390    00:E158             	core_timer:	;;;				; 8 (cycles for the INT)
  391               0001     		.if	CDROM || !defined(NO_CORE_TIRQ_HOOK)
  392    00:E158  6C 04 22   			jmp	[timer_hook]		; 7 cycles.
  393                        		.endif
  394                        		.endif
  395                        	
  396    00:E15B             	tirq_handler:
  397               0000     		.ifdef	USING_TIRQ_MACRO
  399                        		.else
  400    00:E15B  9C 03 14   			stz	IRQ_ACK			; 5 Clear timer interrupt.
  401                        		.endif
  402                        	
  403    00:E15E  40         	core_rti:	rti
  404                        	
  405                        	
  406                        	
  407                        	; ***************************************************************************
  408                        	; ***************************************************************************
  409                        	;
  410                        	; core_clr_hooks - Reset default "CORE(not TM)" interrupt-handling hooks.
  411                        	;
  412                        	
  413    00:E15F  08         	core_clr_hooks:	php				; Preserve interrupt state.
  414    00:E160  78         			sei				; Disable interrupts.
  415                        	
  416               0000     		.if	USING_PSGDRIVER
  419                        		.else
  420    00:E161  9C 07 22   			stz.h	sound_hook		; Disable sound driver calls.
  421                        		.endif
  422                        	
  423    00:E164  A9 88      			lda	#<core_sw_reset		; Set up the soft-reset hook.
  424    00:E166  8D 84 22   			sta.l	reset_hook
  425    00:E169  A9 E1      			lda	#>core_sw_reset
  426    00:E16B  8D 85 22   			sta.h	reset_hook
  427                        	
  428    00:E16E  A9 67      			lda	#<irq1_handler		; Set up the IRQ1 hook.
  429    00:E170  8D 02 22   			sta.l	irq1_hook
  430    00:E173  A9 E0      			lda	#>irq1_handler
  431    00:E175  8D 03 22   			sta.h	irq1_hook
  432                        	
  433    00:E178  A9 5B      			lda	#<tirq_handler		; Set up the TIRQ hook.
  434    00:E17A  8D 04 22   			sta.l	timer_hook
  435    00:E17D  A9 E1      			lda	#>tirq_handler
  436    00:E17F  8D 05 22   			sta.h	timer_hook
  437                        	
  438    00:E182  A9 06      			lda	#%00000110		; Replace the System Card's
  439    00:E184  85 F5      			sta	<irq_vec		; IRQ1 and TIRQ processing.
  440                        	
  441    00:E186  28         			plp				; Restore interrupt state.
  442    00:E187  60         			rts
  443                        	
  444                        	
  445                        	
  446                        	; ***************************************************************************
  447                        	; ***************************************************************************
  448                        	;
  449                        	; Include the joypad library, with configuration from "core-config.inc".
  450                        	;
  451                        	
                             #[6]   "..\..\..\include\hucc\joypad.asm"
  452                        			include "joypad.asm"
    1                        	; ***************************************************************************
    2                        	; ***************************************************************************
    3                        	;
    4                        	; joypad.asm
    5                        	;
    6                        	; Read 2-button & 6-button joypads & PCE mouse, with or without a MultiTap.
    7                        	;
    8                        	; Copyright John Brandwood 2019-2025.
    9                        	;
   10                        	; Distributed under the Boost Software License, Version 1.0.
   11                        	; (See accompanying file LICENSE_1_0.txt or copy at
   12                        	;  http://www.boost.org/LICENSE_1_0.txt)
   13                        	;
   14                        	; ***************************************************************************
   15                        	; ***************************************************************************
   16                        	;
   17                        	; Unlike Lemmings, this code does not interfere with a Memory Base 128! ;-)
   18                        	;
   19                        	; ***************************************************************************
   20                        	; ***************************************************************************
   21                        	;
   22                        	; With SUPPORT_MOUSE ..... 2602 cycles to read 5 ports with 5 mice
   23                        	;
   24                        	; With HuC library code .. 2442 cycles to read 5 ports with 5 pads (2-button)
   25                        	; With HuC library code .. 2442 cycles to read 5 ports with 5 pads (6-button)
   26                        	;
   27                        	; With SUPPORT_MOUSE ....  2016 cycles to read 5 ports with 5 pads (2-button)
   28                        	; With SUPPORT_MOUSE ..... 1976 cycles to read 5 ports with 5 pads (6-button)
   29                        	;
   30                        	; With SUPPORT_MOUSE ....  1618 cycles to read 3 ports with 3 mice
   31                        	; With SUPPORT_MOUSE ..... 1462 cycles to read 3 ports with 2 mice
   32                        	; With SUPPORT_MOUSE ..... 1306 cycles to read 3 ports with 1 mouse
   33                        	;
   34                        	; With SUPPORT_6BUTTON ... 1235 cycles to read 5 ports with 5 pads (2-button)
   35                        	; With SUPPORT_6BUTTON ... 1215 cycles to read 5 ports with 5 pads (6-button)
   36                        	;
   37                        	; With SUPPORT_MOUSE ..... 1126 cycles to read 2 ports with 2 mice
   38                        	; With SUPPORT_MOUSE ...... 970 cycles to read 2 ports with 1 mouse
   39                        	;
   40                        	; Only SUPPORT_2BUTTON .... 971 cycles to read 5 ports with 5 pads (2-button)
   41                        	; Only SUPPORT_2BUTTON .... 861 cycles to read 5 ports with 5 pads (6-button)
   42                        	;
   43                        	; With SUPPORT_MOUSE ...... 634 cycles to read 1 port  with 1 mouse
   44                        	;
   45                        	; ***************************************************************************
   46                        	; ***************************************************************************
   47                        	
  142                        	
  143                        	;
  144                        	; Now choose which version of the code to include.
  145                        	;
  146                        	
  147               0000     		.if	SUPPORT_2BUTTON
  278                        		.endif	SUPPORT_2BUTTON
  279                        	
  280                        	
  281                        	
  282               0000     		.if	SUPPORT_MOUSE
  845                        		.else	SUPPORT_MOUSE
  846                        	
  847                        	
  848                        	
  849               0001     		.if	SUPPORT_6BUTTON			; Without mouse!
  850                        	
  851                        	; ***************************************************************************
  852                        	; ***************************************************************************
  853                        	;
  854                        	; read_joypads - full 6-button pad support, but mouse movement is ignored.
  855                        	;
  856                        	; This code distinguishes between a mouse and a 2-button or 6-button joypad,
  857                        	; so that unsupported devices do not have to be unplugged from the MultiTap.
  858                        	;
  859                        	; The code loops two times to get both sets of buttons on a 6-button joypad.
  860                        	;
  861                        	; N.B. Takes approx 1/3 frame to detect mice the first time it is run.
  862                        	;
  863                        	; bit values for joypad 2-button bytes: (MSB = #7; LSB = #0)
  864                        	; ----------------------------------------------------------
  865                        	; bit 0 (ie $01) = I
  866                        	; bit 1 (ie $02) = II
  867                        	; bit 2 (ie $04) = SELECT
  868                        	; bit 3 (ie $08) = RUN
  869                        	; bit 4 (ie $10) = UP
  870                        	; bit 5 (ie $20) = RIGHT
  871                        	; bit 6 (ie $40) = DOWN
  872                        	; bit 7 (ie $80) = LEFT
  873                        	;
  874                        	; bit values for joypad 6-button bytes: (MSB = #7; LSB = #0)
  875                        	; ----------------------------------------------------------
  876                        	; bit 0 (ie $01) = III
  877                        	; bit 1 (ie $02) = IV
  878                        	; bit 2 (ie $04) = V
  879                        	; bit 3 (ie $08) = VI
  880                        	; bit 4 (ie $10) = zero
  881                        	; bit 5 (ie $20) = zero
  882                        	; bit 6 (ie $40) = zero
  883                        	; bit 7 (ie $80) = zero, but set to one if 6-button pad detected.
  884                        	;
  885                        	
  886               E188     			.code
  887                        	
  888               0001     		.if	(* >= $4000)			; Make this a ".proc" if it
  889    0B:DE90             	read_joypads	.proc                           ; not running in RAM.
  890                        		.else
  892                        		.endif
  893                        	
  894    0B:DE90  A9 80      			lda	#$80			; Acquire port mutex to avoid
  895    0B:DE92  0C D0 22   			tsb	port_mutex		; conflict with a delayed VBL
  896    0B:DE95  30 75      			bmi	.exit			; or access to an MB128.
  897                        	
  898    0B:DE97  73 28 22 32			tii	joynow,joyold,MAX_PADS	; Save the previous values.
         0B:DE9B  22 05 00    
  899    0B:DE9E  73 D3 22 D8			tii	joy6now,joy6old,MAX_PADS
         0B:DEA2  22 05 00    
  900                        	
  901                        			; Reset the 6-btn bits, the user might change the joypad mode!
  902                        	
  903    0B:DEA5  F3 53 E0 D3			tai	const_0000, joy6now, MAX_PADS
         0B:DEA9  22 05 00    
  904                        	
  905                        			; Detect attached mice the first time this routine is called.
  906                        	
  907    0B:DEAC  AD D2 22   			lda	mouse_flg		; Has mouse detection happened?
  908    0B:DEAF  30 28      			bmi	.calc_pressed
  909                        	
  910    0B:DEB1  A9 05      			lda	#MAX_PADS		; Reset number of pads to read.
  911    0B:DEB3  8D D1 22   			sta	num_ports
  912                        	
  913    0B:DEB6  A9 1F      			lda	#%00011111		; Try reading everything as a
  914    0B:DEB8  8D D2 22   			sta	mouse_flg		; mouse.
  915                        	
  916    0B:DEBB  A0 17      			ldy	#23			; Initialize repeat count.
  917    0B:DEBD  A9 80      			lda	#$80			; Initialize mouse detection.
  918    0B:DEBF  5A         	.detect_loop:	phy
  919    0B:DEC0  48         			pha
  920    0B:DEC1  44 53      			bsr	.read_devices		; Read all devices as if mice.
  921    0B:DEC3  68         			pla
  922    0B:DEC4  82         			clx
  923    0B:DEC5  BC E2 22   	.detect_port:	ldy	mouse_x, x		; A movement of zero means
  924    0B:DEC8  D0 03      			bne	.detect_next		; this port is a mouse.
  925    0B:DECA  1D 55 E0   			ora	bit_mask, x
  926    0B:DECD  E8         	.detect_next:	inx				; Get the next pad from the
  927    0B:DECE  E0 05      			cpx	#MAX_PADS		; multitap.
  928    0B:DED0  D0 F3      			bne	.detect_port
  929    0B:DED2  7A         			ply				; Repeat the detection test.
  930    0B:DED3  88         			dey
  931    0B:DED4  D0 E9      			bne	.detect_loop
  932                        	
  933                        	;	.if	DETECT_PHANTOMS
  934                        	;		cmp	#(1 << MAX_PADS) + 127	; If we find a mouse in every
  935                        	;		bne	.detect_done		; port, then assume mirrored!
  936                        	;		lda	#1			; Report a single mouse in a
  937                        	;		sta	num_ports		; single port.
  938                        	;		lda	#$81
  939                        	;	.endif
  940                        	
  941    0B:DED6  8D D2 22   	.detect_done:	sta	mouse_flg		; Report mouse detection.
  942                        	
  943                        			; See what has just been pressed, and check for soft-reset.
  944                        	
  945    0B:DED9  44 3B      	.calc_pressed:	bsr	.read_devices		; Read all devices normally.
  946                        	
  947    0B:DEDB  A2 04      			ldx	#MAX_PADS - 1
  948                        	
  949    0B:DEDD  BD D3 22   	.pressed_loop:	lda	joy6now, x		; Calc which buttons have just
  950    0B:DEE0  5D D8 22   			eor	joy6old, x		; been pressed (6-button).
  951    0B:DEE3  3D D3 22   			and	joy6now, x
  952               0000     		.if	HUC_JOY_EVENTS
  956                        		.else
  957               0000     		.if	ACCUMULATE_JOY
  959                        		.endif
  960    0B:DEE6  9D DD 22   			sta	joy6trg, x
  961                        		.endif
  962                        	
  963    0B:DEE9  BD 28 22   			lda	joynow, x		; Calc which buttons have just
  964    0B:DEEC  A8         			tay                             ; been pressed (2-button).
  965    0B:DEED  5D 32 22   			eor	joyold, x
  966    0B:DEF0  3D 28 22   			and	joynow, x
  967               0000     		.if	HUC_JOY_EVENTS
  971                        		.else
  972               0000     		.if	ACCUMULATE_JOY
  974                        		.endif
  975    0B:DEF3  9D 2D 22   			sta	joytrg, x
  976                        		.endif
  977                        	
  978    0B:DEF6  C9 04      			cmp	#$04			; Detect the soft-reset combo,
  979    0B:DEF8  D0 0C      			bne	.not_reset		; hold RUN then press SELECT.
  980    0B:DEFA  C0 0C      			cpy	#$0C
  981    0B:DEFC  D0 08      			bne	.not_reset
  982    0B:DEFE  BD 55 E0   			lda	bit_mask, x
  983    0B:DF01  2C 27 22   			bit	joyena
  984    0B:DF04  D0 09      			bne	.soft_reset
  985                        	
  986    0B:DF06  CA         	.not_reset:	dex				; Check the next pad from the
  987    0B:DF07  10 D4      			bpl	.pressed_loop		; multitap.
  988                        	
  989    0B:DF09  9C D0 22   			stz	port_mutex		; Release port mutex.
  990                        	
  991               0001     		.if	(* >= $4000)			; This is a ".proc" if it is
  992                        	.exit:		leave                           ; not running in RAM.
         0B:DF0C  4C EF FF   			jmp	leave_proc
  993                        		.else
  995                        		.endif
  996                        	
  997    0B:DF0F  78         	.soft_reset:	sei				; Disable interrupts.
  998    0B:DF10  9C D0 22   			stz	port_mutex		; Release port mutex.
  999    0B:DF13  6C 84 22   			jmp	[reset_hook]		; Jump to the soft-reset hook.
 1000                        	
 1001                        			; Read all of the devices attached to the MultiTap.
 1002                        	
 1003    0B:DF16  A2 02      	.read_devices:	ldx	#2			; Repeat this loop 2 times.
 1004                        	
 1005    0B:DF18  A9 01      	.read_multitap:	lda	#$01			; CLR lo, SEL hi for d-pad.
 1006    0B:DF1A  8D 00 10   			sta	IO_PORT
 1007    0B:DF1D  A9 03      			lda	#$03			; CLR hi, SEL hi, reset tap.
 1008    0B:DF1F  8D 00 10   			sta	IO_PORT
 1009    0B:DF22  C2         			cly				; Start at port 1.
 1010                        	
 1011    0B:DF23  A9 01      	.read_port:	lda	#$01			; CLR lo, SEL hi for d-pad.
 1012    0B:DF25  8D 00 10   			sta	IO_PORT			; Wait 1.25us (9 cycles).
 1013                        	
 1014    0B:DF28  B9 55 E0   			lda	bit_mask, y		; Is there a mouse attached?
 1015    0B:DF2B  2D D2 22   			and	mouse_flg
 1016    0B:DF2E  D0 33      			bne	.read_mouse
 1017                        	
 1018    0B:DF30  AD 00 10   	.read_pad:	lda	IO_PORT			; Read direction-pad bits.
 1019    0B:DF33  9C 00 10   			stz	IO_PORT			; CLR lo, SEL lo for buttons.
 1020    0B:DF36  0A         			asl	a			; Wait 1.25us (9 cycles).
 1021    0B:DF37  0A         			asl	a
 1022    0B:DF38  0A         			asl	a
 1023    0B:DF39  0A         			asl	a
 1024    0B:DF3A  F0 1B      			beq	.read_6button		; 6-btn pad if UDLR all held.
 1025                        	
 1026    0B:DF3C  99 28 22   	.read_2button:	sta	joynow, y		; Get buttons of 2-btn pad.
 1027    0B:DF3F  AD 00 10   			lda	IO_PORT
 1028    0B:DF42  29 0F      			and	#$0F
 1029    0B:DF44  19 28 22   			ora	joynow, y
 1030    0B:DF47  49 FF      			eor	#$FF
 1031    0B:DF49  99 28 22   			sta	joynow, y
 1032                        	
 1033    0B:DF4C  C8         	.next_port:	iny				; Get the next pad from the
 1034    0B:DF4D  CC D1 22   			cpy	num_ports		; multitap.
 1035    0B:DF50  90 D1      			bcc	.read_port
 1036                        	
 1037    0B:DF52  CA         			dex				; Do the next complete pass.
 1038    0B:DF53  CA         			dex
 1039    0B:DF54  10 C2      			bpl	.read_multitap		; Have we finished 2 passes?
 1040    0B:DF56  60         			rts				; Now that everything is read.
 1041                        	
 1042    0B:DF57  AD 00 10   	.read_6button:	lda	IO_PORT			; Get buttons of 6-btn pad.
 1043    0B:DF5A  29 0F      			and	#$0F
 1044    0B:DF5C  49 8F      			eor	#$8F			; Set bit-7 to show that a
 1045    0B:DF5E  99 D3 22   			sta	joy6now, y		; 6-button pad is present.
 1046    0B:DF61  80 E9      			bra	.next_port
 1047                        	
 1048    0B:DF63  7C 94 DF   	.read_mouse:	jmp	[.mouse_vectors, x]	; Which mouse info is next?
 1049                        	
 1050                        			; Mouse processing, normally four passes, here just two.
 1051                        	
 1052    0B:DF66  A9 1C      	.mouse_x_hi:	lda	#28			; 189 cycle delay after CLR lo
 1053    0B:DF68  3A         	.wait_loop:	dec	a			; on port to allow the mouse
 1054    0B:DF69  D0 FD      			bne	.wait_loop		; to buffer and reset counters.
 1055                        	
 1056    0B:DF6B  AD 00 10   			lda	IO_PORT			; Read direction-pad bits.
 1057    0B:DF6E  9C 00 10   			stz	IO_PORT			; CLR lo, SEL lo for buttons.
 1058    0B:DF71  0A         			asl	a			; Wait 1.25us (9 cycles).
 1059    0B:DF72  0A         			asl	a
 1060    0B:DF73  0A         			asl	a
 1061    0B:DF74  0A         			asl	a
 1062    0B:DF75  99 E2 22   			sta	mouse_x, y		; Save port's X-hi nibble.
 1063                        	
 1064    0B:DF78  AD 00 10   			lda	IO_PORT			; Get mouse buttons.
 1065    0B:DF7B  29 0F      			and	#$0F
 1066    0B:DF7D  49 0F      			eor	#$0F
 1067    0B:DF7F  99 28 22   			sta	joynow, y
 1068    0B:DF82  80 C8      			bra	.next_port
 1069                        	
 1070    0B:DF84  AD 00 10   	.mouse_x_lo:	lda	IO_PORT			; Read direction-pad bits.
 1071    0B:DF87  9C 00 10   			stz	IO_PORT			; CLR lo, SEL lo for buttons.
 1072    0B:DF8A  29 0F      			and	#$0F			; Wait 1.25us (9 cycles).
 1073    0B:DF8C  19 E2 22   			ora	mouse_x, y		; Add port's X-hi nibble.
 1074                        	;		eor	#$FF			; Negate so LEFT is -ve.
 1075                        	;		inc	a
 1076    0B:DF8F  99 E2 22   			sta	mouse_x, y
 1077    0B:DF92  80 B8      			bra	.next_port
 1078                        	
 1079    0B:DF94  84 DF      	.mouse_vectors: dw	.mouse_x_lo		; Pass 2
 1080    0B:DF96  66 DF      			dw	.mouse_x_hi		; Pass 1
 1081                        	
 1082               0001     		.if	(* >= $4000)			; This is a ".proc" if it is
 1083                        			.endp                           ; not running in RAM.
 1084               22D0     			.bss				; Put the variables in RAM.
 1085                        		.endif
 1086                        	
 1087    F8:22D0             	port_mutex:	ds	1			; NZ when controller port busy.
 1088    F8:22D1             	num_ports:	ds	1			; Set to 1 if no multitap.
 1089    F8:22D2             	mouse_flg:	ds	1			; Which ports are mice?
 1090               0000     		.if	HUC_JOY_EVENTS
 1093                        		.endif
 1094    F8:22D3             	joy6now:	ds	MAX_PADS
 1095    F8:22D8             	joy6old:	ds	MAX_PADS
 1096    F8:22DD             	joy6trg:	ds	MAX_PADS
 1097    F8:22E2             	mouse_x:	ds	MAX_PADS
 1098                        	
 1099               E188     			.code
 1100                        	
 1101                        		.endif	SUPPORT_6BUTTON			; Without mouse!
 1102                        	
 1103                        		.endif	SUPPORT_MOUSE
                             #[5]   "..\..\..\include\hucc\core-kernel.asm"
  453                        	
  454                        	
  455                        	
  456               0001     		.if	!CDROM
  457                        	
  458                        	; ***************************************************************************
  459                        	; ***************************************************************************
  460                        	;
  461                        	; core_sw_reset - Default HuCARD handler for a joypad "soft-reset".
  462                        	;
  463                        	
  464    00:E188  78         	core_sw_reset:	sei				; Disable interrupts.
  465                        	
  466    00:E189  6C FE FF   			jmp	[$FFFE]			; Jump to the HuCARD reset.
  467                        	
  468                        	
  469                        	
  470                        		.else	!CDROM
  616                        		.endif	!CDROM
  617                        	
  618                        	
  619                        	
  620                        	; ***************************************************************************
  621                        	; ***************************************************************************
  622                        	
  623               0001     		.if	(core_kernel >= $4000)		; If not running in RAM, then
  624               22E7     			.bss				; put these variables in RAM.
  625                        		.endif
  626                        	
  627    F8:22E7             	sound_mutex:	ds	1			; NZ when controller port busy.
  628                        	
  629               0001     		.if	SUPPORT_SGX
  630    F8:22E8             	sgx_detected:	ds	1			; NZ if SuperGrafx detected.
  631    F8:22E9             	hsync_hook_sgx:	ds	2			; SGX version of hsync_hook.
  632                        		.endif
  633                        	
  634               0000     		.if	SUPPORT_ACD
  636                        		.endif
  637                        	
  638               0001     		.if	(core_kernel >= $4000)
  639               E18C     			.code
  640                        		.endif
                             #[4]   "..\..\..\include\hucc\core-startup.asm"
  427                        	
  428                        	
  429                        	
  430                        		.else	!CDROM
  524                        		.endif	!CDROM
  525                        	
  526                        	
  527                        	
  528                        	; ***************************************************************************
  529                        	; ***************************************************************************
  530                        	;
  531                        	; With the availability of so many different configuration options, we've now
  532                        	; built somewhere between a few hundred bytes, and a couple of KB, of code in
  533                        	; the CORE_BANK of the HuCARD / overlay program.
  534                        	;
  535                        	; This is the end of the "CORE(not TM)" library code!
  536                        	;
  537                        	; Remember that the ".proc" trampolines are located at the end of this bank,
  538                        	; so the amount of free space left depends upon the number of ".proc" calls.
  539                        	;
  540                        	
  541                        			; Switch to CORE_PAGE to run the developer's game code.
  542               E18C     			.page	CORE_PAGE
  543                        	
  544                        	
  545                        	
  546                        	; ***************************************************************************
  547                        	; ***************************************************************************
  548                        	;
  549                        	; The DATA_BANK location needs to be set as early as possible so that library
  550                        	; code is able to put data in there before the total overall size of the code
  551                        	; is known.
  552                        	;
  553                        	; By default, DATA_BANK is the next bank after the CORE_BANK.
  554                        	;
  555                        	; RESERVE_BANKS allows developers to reserve some banks between the CORE_BANK
  556                        	; and the DATA_BANK that they can use however they wish.
  557                        	;
  558                        	; One use for RESERVE_BANKS is to create empty space that PCEAS can use when
  559                        	; it relocates procedures. This provides a way for a developer to group code
  560                        	; together at the start of memory, and leave the maximum number of banks for
  561                        	; loading dynamic data from CD-ROM.
  562                        	;
  563                        	; The KickC environment sets RESERVE_BANKS=1 (or higher) so that there is a
  564                        	; a bank for the permanent C code and static constants.
  565                        	;
  566                        	; RESERVE_BANKS is normally defined in each project's "core-config.inc".
  567                        	;
  568                        	
  569                        			.opt	d+			; DATA labels use fixed MPR.
  570                        	
  571               0001     			.rsset	CORE_BANK + 1
  572                        	
  573               0000     		.ifdef	NEED_HOME_BANK
  580                        		.endif
  581                        	
  582               0001     		.ifdef	NEED_SOUND_BANK			; Defined in hucc-sound.inc
  583               0000     		.if	NEED_SOUND_BANK			; if the driver wants a bank.
  585                        		.endif
  586                        		.endif
  587                        	
  588               0001     		.ifdef	RESERVE_BANKS			; For CORE projects.
  589               0001     	RESERVED_BANK	.rs	RESERVE_BANKS
  590                        		.endif
  591                        	
  592               0001     		.ifdef	HUCC
  593               0001     		.ifdef	HUC_RESERVE_BANKS		; For HuCC projects.
  594               0001     	HUC_USER_BANK	.rs	HUC_RESERVE_BANKS
  595                        		.endif
  596                        	
  597               0001     	CONST_BANK	.rs	2
  598               6000     			.rodata
  599               0001     			.bank	CONST_BANK, ".rodata"
  600                        		.endif	HUCC
  601                        	
  602               0003     	DATA_BANK	.rs	0
  603               6000     			.data
  604               0000     		.if	BUILDING_STAGE1
  606                        		.else
  607               0003     			.bank	DATA_BANK, ".data"
  608                        		.endif
  609               6000     			.org	$6000
  610                        	
  611               E18C     			.code
                             #[3]   "..\..\..\include\hucc\core.inc"
                             #[2]   "..\..\..\include\hucc\hucc.asm"
  120                        		.else
  126                        		.endif
  127                        	
  128                        			; Allocate this as early as possible to ensure bank-aligned
  129                        			; so that there is no wasted space for aligning the table.
  130                        	
  131               0000     		.if	FAST_MULTIPLY
  138                        		.endif
  139                        	
  140                        			;
  141                        	
  144                        	
  145                        			; The hardware stack is used for expressions.
  146                        	
  147               00FF     	__tos		=	$F8:2101, 255
  148                        	
  149               2008     			.zp
  150               2008     			.align	2
  151    F8:2008             	__stack:	ds	HUCC_STACK_SZ
  152                        	
  153    F8:2088             	__ptr:		ds	2
  154    F8:208A             	__fptr:		ds	2
  155    F8:208C             	__fbank:	ds	1
  156    F8:208D             	__sp:		ds	1
  157                        	
  158                        			; REGTEMP 6-byte stack for temporaries used by SDCC.
  159                        			; Keep the size in sync with NUM_TEMP_REGS in sdcc/src/mos6502/gen.h!
  160                        	
  161    F8:208E             	REGTEMP:	ds	6
  162                        	
  163                        			; HuCC's non-recursive consecutive varargs for printf().
  164                        	
  165               2008     	__vararg1	=	__stack + 0
  166               200A     	__vararg2	=	__stack + 2
  167               200C     	__vararg3	=	__stack + 4
  168               200E     	__vararg4	=	__stack + 6
  169                        	
  170                        			; Pointer used by poke() because __ptr could be overwritten.
  171                        	
  172               20EE     	__poke		=	__si
  173                        	
  174                        			; Used for indirect calls because __ptr could be overwritten.
  175                        	
  176               20EE     	__func		=	__si
  177                        	
  178                        			; Data pointer used by SDCC for indirect indexed memory access.
  179                        	
  180               2088     	DPTR		=	__ptr
  181                        	
  182                        			; Values returned from SDCC functions that don't fit into XA.
  183                        			; These are also used as workspace for SDCC library functions,
  184                        			; including HuCC's multiplication and division functions.
  185                        	
  186    F8:2094             	___SDCC_m6502_ret0:	ds	1
  187    F8:2095             	___SDCC_m6502_ret1:	ds	1
  188    F8:2096             	___SDCC_m6502_ret2:	ds	1
  189    F8:2097             	___SDCC_m6502_ret3:	ds	1
  190                        	
  191               0000     		.if	0
  196                        		.endif
  197                        	
  198                        			; Permanent pointers for fast table-of-squares multiplication.
  199                        	
  200               0000     		.if	FAST_MULTIPLY
  205                        		.endif
  206                        	
  207                        			; HuCC keeps a realtime clock, updated in hucc_vbl.
  208                        			;
  209                        			; Defining this here means that it will go before any HuCC
  210                        			; variables in "globals.h", and so it won't get cleared in
  211                        			; a CDROM game when loading different overlays.
  212                        	
  213               22EB     			.bss
  214    F8:22EB             	old_cnt:	ds	1			; irq_cnt of previous vsync().
  215    F8:22EC             	clock_hh:	ds	1			; System Clock, hours	(0-11)
  216    F8:22ED             	clock_mm:	ds	1			; System Clock, minutes (0-59)
  217    F8:22EE             	clock_ss:	ds	1			; System Clock, seconds (0-59)
  218    F8:22EF             	clock_tt:	ds	1			; System Clock, ticks	(0-59)
  219               E18C     			.code
  220                        	
  221                        			; Critical HuCC libraries that the compiler depends upon.
  222                        			;
  223                        			; These include various macros that must be defined before
  224                        			; they are encountered in any compiler-generated code.
  225                        	
                             #[3]   "..\..\..\include\hucc\hucc-codegen.asm"
  226                        			include "hucc-codegen.asm"	; HuCC i-code macros and funcs.
    1                        	; ***************************************************************************
    2                        	; ***************************************************************************
    3                        	;
    4                        	; hucc-codegen.asm
    5                        	;
    6                        	; The HuCC compiler translates C code into these macros, it does not directly
    7                        	; generate HuC6280 instructions.
    8                        	;
    9                        	; Based on the original HuC macros created by David Michel and the other HuC
   10                        	; developers, later modified and improved by Ulrich Hecht.
   11                        	;
   12                        	; Modifications copyright John Brandwood 2024.
   13                        	;
   14                        	; Distributed under the Boost Software License, Version 1.0.
   15                        	; (See accompanying file LICENSE_1_0.txt or copy at
   16                        	;  http://www.boost.org/LICENSE_1_0.txt)
   17                        	;
   18                        	; ***************************************************************************
   19                        	; ***************************************************************************
   20                        	;
   21                        	; NAMING SCHEME FOR HuCC MACROS ...
   22                        	;
   23                        	;   __function.parameters
   24                        	;
   25                        	; {parameters} is a list of alphanumeric specifiers, starting with {size} and
   26                        	; followed by {where}, followed by {index} if an array, then optional {value}
   27                        	; and finally ending with optional {suffix}
   28                        	;
   29                        	; {size}
   30                        	;   w : 16-bit signed int (default "int" in HuCC)
   31                        	;   c : 16-bit unsigned int (a "cardinal" in Pascal terms)
   32                        	;   b :  8-bit signed char
   33                        	;   u :  8-bit unsigned char (default "char" in HuCC)
   34                        	;
   35                        	; {where} or {index}
   36                        	;   r : HuCC primary register, made up of the Y:A cpu registers
   37                        	;   t : top of expression stack
   38                        	;   p : indirect pointer, usually [__ptr]
   39                        	;   f : structure field (member) offset value
   40                        	;   i : immediate value, i.e. a decimal number
   41                        	;   m : memory, i.e. C global, static, and "-fno-recursive" variables
   42                        	;   s : stack, i.e. C function parameters and locals (not "-fno-recursive")
   43                        	;   a : array, i.e. C global, static, "-fno-recursive" arrays <= 256 bytes
   44                        	;   x : array index already in the X register
   45                        	;   y : array index already in the Y register
   46                        	;
   47                        	; {value} OPTIONAL
   48                        	;   i : immediate value, i.e. a decimal number
   49                        	;   z : zero value
   50                        	;
   51                        	; {suffix} OPTIONAL
   52                        	;   q : quick, used for optimized math on only 8-bit values, because all math
   53                        	;       is normally promoted to "int" size in C; and when optimized stores do
   54                        	;       not need to preserve the primary register contents
   55                        	;
   56                        	; ***************************************************************************
   57                        	; ***************************************************************************
   58                        	
   59                        	
   60                        	
 8399                        	
 8400                        	; ***************************************************************************
 8401                        	; ***************************************************************************
 8402                        	; subroutines for logical and arithmetic shifts by a constant amount
 8403                        	; ***************************************************************************
 8404                        	; ***************************************************************************
 8405                        	
 8406                        	; **************
 8407                        	; Y:A = Y:A << const
 8408                        	
 8409    00:E1BE  0A         	aslw15:		asl	a
 8410    00:E1BF  0A         	aslw14:		asl	a
 8411    00:E1C0  0A         	aslw13:		asl	a
 8412    00:E1C1  0A         	aslw12:		asl	a
 8413    00:E1C2  0A         	aslw11:		asl	a
 8414    00:E1C3  0A         	aslw10:		asl	a
 8415    00:E1C4  0A         	aslw9:		asl	a
 8416    00:E1C5  A8         	aslw8:		tay
 8417    00:E1C6  62         			cla
 8418    00:E1C7  60         			rts
 8419                        	
 8420               0001     		.if	1
 8421    00:E1C8  66 00      	aslw5:		ror	<__temp
 8422    00:E1CA  6A         			ror	a
 8423    00:E1CB  66 00      	aslw6:		ror	<__temp
 8424    00:E1CD  6A         			ror	a
 8425    00:E1CE  66 00      	aslw7:		ror	<__temp
 8426    00:E1D0  6A         			ror	a
 8427    00:E1D1  A4 00      			ldy	<__temp
 8428    00:E1D3  60         			rts
 8429                        		.else
 8436                        		.endif
 8437    00:E1D4  0A         	aslw4:		asl	a
 8438    00:E1D5  26 00      			rol	<__temp
 8439    00:E1D7  0A         	aslw3:		asl	a
 8440    00:E1D8  26 00      			rol	<__temp
 8441    00:E1DA  0A         	aslw2:		asl	a
 8442    00:E1DB  26 00      			rol	<__temp
 8443    00:E1DD  0A         	aslw1:		asl	a
 8444    00:E1DE  26 00      			rol	<__temp
 8445    00:E1E0  A4 00      	aslw0:		ldy	<__temp
 8446    00:E1E2  60         			rts
 8447                        	
 8448                        	; **************
 8449                        	; Y:A = Y:A >> const
 8450                        	
 8451    00:E1E3  C9 80      	asrw15:		cmp	#$80
 8452    00:E1E5  6A         			ror	a
 8453    00:E1E6  C9 80      	asrw14:		cmp	#$80
 8454    00:E1E8  6A         			ror	a
 8455    00:E1E9  C9 80      	asrw13:		cmp	#$80
 8456    00:E1EB  6A         			ror	a
 8457    00:E1EC  C9 80      	asrw12:		cmp	#$80
 8458    00:E1EE  6A         			ror	a
 8459    00:E1EF  C9 80      	asrw11:		cmp	#$80
 8460    00:E1F1  6A         			ror	a
 8461    00:E1F2  C9 80      	asrw10:		cmp	#$80
 8462    00:E1F4  6A         			ror	a
 8463    00:E1F5  C9 80      	asrw9:		cmp	#$80
 8464    00:E1F7  6A         			ror	a
 8465    00:E1F8  C9 80      	asrw8:		cmp	#$80
 8466    00:E1FA  C2         			cly
 8467    00:E1FB  90 01      			bcc	!+
 8468    00:E1FD  88         			dey
 8469    00:E1FE  60         	!:		rts
 8470                        	
 8471    00:E1FF  C0 80      	asrw7:		cpy	#$80
 8472    00:E201  66 00      			ror	<__temp
 8473    00:E203  6A         			ror	a
 8474    00:E204  C0 80      	asrw6:		cpy	#$80
 8475    00:E206  66 00      			ror	<__temp
 8476    00:E208  6A         			ror	a
 8477    00:E209  C0 80      	asrw5:		cpy	#$80
 8478    00:E20B  66 00      			ror	<__temp
 8479    00:E20D  6A         			ror	a
 8480    00:E20E  C0 80      	asrw4:		cpy	#$80
 8481    00:E210  66 00      			ror	<__temp
 8482    00:E212  6A         			ror	a
 8483    00:E213  C0 80      	asrw3:		cpy	#$80
 8484    00:E215  66 00      			ror	<__temp
 8485    00:E217  6A         			ror	a
 8486    00:E218  C0 80      	asrw2:		cpy	#$80
 8487    00:E21A  66 00      			ror	<__temp
 8488    00:E21C  6A         			ror	a
 8489    00:E21D  C0 80      	asrw1:		cpy	#$80
 8490    00:E21F  66 00      			ror	<__temp
 8491    00:E221  6A         			ror	a
 8492    00:E222  A4 00      	asrw0:		ldy	<__temp
 8493    00:E224  60         			rts
 8494                        	
 8495                        	; **************
 8496                        	; Y:A = Y:A >> const
 8497                        	
 8498    00:E225  4A         	lsrw15:		lsr	a
 8499    00:E226  4A         	lsrw14:		lsr	a
 8500    00:E227  4A         	lsrw13:		lsr	a
 8501    00:E228  4A         	lsrw12:		lsr	a
 8502    00:E229  4A         	lsrw11:		lsr	a
 8503    00:E22A  4A         	lsrw10:		lsr	a
 8504    00:E22B  4A         	lsrw9:		lsr	a
 8505    00:E22C  C2         	lsrw8:		cly
 8506    00:E22D  60         			rts
 8507                        	
 8508    00:E22E  46 00      	lsrw7:		lsr	<__temp
 8509    00:E230  6A         			ror	a
 8510    00:E231  46 00      	lsrw6:		lsr	<__temp
 8511    00:E233  6A         			ror	a
 8512    00:E234  46 00      	lsrw5:		lsr	<__temp
 8513    00:E236  6A         			ror	a
 8514    00:E237  46 00      	lsrw4:		lsr	<__temp
 8515    00:E239  6A         			ror	a
 8516    00:E23A  46 00      	lsrw3:		lsr	<__temp
 8517    00:E23C  6A         			ror	a
 8518    00:E23D  46 00      	lsrw2:		lsr	<__temp
 8519    00:E23F  6A         			ror	a
 8520    00:E240  46 00      	lsrw1:		lsr	<__temp
 8521    00:E242  6A         			ror	a
 8522    00:E243  A4 00      	lsrw0:		ldy	<__temp
 8523    00:E245  60         			rts
 8524                        	
 8525                        	
 8526                        	
 8527                        	; ***************************************************************************
 8528                        	; ***************************************************************************
 8529                        	; subroutines for logical and arithmetic shifts by a variable amount
 8530                        	; ***************************************************************************
 8531                        	; ***************************************************************************
 8532                        	
 8533                        	; **************
 8534                        	; Y:A = Y:A << X
 8535                        	
 8536    00:E246  84 00      	asl.wx:		sty	<__temp
 8537    00:E248  E0 10      			cpx	#16
 8538    00:E24A  B0 37      			bcs	!zero+
 8539    00:E24C  CA         			dex
 8540    00:E24D  30 06      			bmi	.done
 8541    00:E24F  0A         	.loop:		asl	a
 8542    00:E250  26 00      			rol	<__temp
 8543    00:E252  CA         			dex
 8544    00:E253  10 FA      			bpl	.loop
 8545    00:E255  A4 00      	.done:		ldy	<__temp
 8546    00:E257  60         			rts
 8547                        	
 8548                        	; **************
 8549                        	; Y:A = Y:A >> X
 8550                        	
 8551    00:E258  84 00      	asr.wx:		sty	<__temp
 8552    00:E25A  10 17      			bpl	!positive+
 8553    00:E25C  E0 10      	!negative:	cpx	#16
 8554    00:E25E  B0 0D      			bcs	.sign
 8555    00:E260  CA         			dex
 8556    00:E261  30 07      			bmi	.done
 8557    00:E263  38         	.loop:		sec
 8558    00:E264  66 00      			ror	<__temp
 8559    00:E266  6A         			ror	a
 8560    00:E267  CA         			dex
 8561    00:E268  10 F9      			bpl	.loop
 8562    00:E26A  A4 00      	.done:		ldy	<__temp
 8563    00:E26C  60         			rts
 8564                        	
 8565    00:E26D  A9 FF      	.sign:		lda	#$FF
 8566    00:E26F  A8         			tay
 8567    00:E270  60         			rts
 8568                        	
 8569                        	; **************
 8570                        	; Y:A = Y:A >> X
 8571                        	
 8572    00:E271  84 00      	lsr.wx:		sty	<__temp
 8573    00:E273  E0 10      	!positive:	cpx	#16
 8574    00:E275  B0 0C      			bcs	!zero+
 8575    00:E277  CA         			dex
 8576    00:E278  30 06      			bmi	.done
 8577    00:E27A  46 00      	.loop:		lsr	<__temp
 8578    00:E27C  6A         			ror	a
 8579    00:E27D  CA         			dex
 8580    00:E27E  10 FA      			bpl	.loop
 8581    00:E280  A4 00      	.done:		ldy	<__temp
 8582    00:E282  60         			rts
 8583                        	
 8584    00:E283  62         	!zero:		cla
 8585    00:E284  C2         			cly
 8586    00:E285  60         			rts
 8587                        	
 8588                        	
 8589                        	
 8590                        	; ***************************************************************************
 8591                        	; ***************************************************************************
 8592                        	; POTENTIAL OPTIMIZATIONS, NOT YET ADDED
 8593                        	; ***************************************************************************
 8594                        	; ***************************************************************************
                             #[2]   "..\..\..\include\hucc\hucc.asm"
                             #[3]   "..\..\..\include\hucc\hucc-baselib.asm"
  227                        			include	"hucc-baselib.asm"	; HuCC base library macros.
    1                        	; ***************************************************************************
    2                        	; ***************************************************************************
    3                        	;
    4                        	; hucc-baselib.asm
    5                        	;
    6                        	; Basic library functions provided (mostly) as macros.
    7                        	;
    8                        	; Copyright John Brandwood 2024-2025.
    9                        	;
   10                        	; Distributed under the Boost Software License, Version 1.0.
   11                        	; (See accompanying file LICENSE_1_0.txt or copy at
   12                        	;  http://www.boost.org/LICENSE_1_0.txt)
   13                        	;
   14                        	; ***************************************************************************
   15                        	; ***************************************************************************
   16                        	
   17                        	
   18                        	
   19                        	; ***************************************************************************
   20                        	; ***************************************************************************
   21                        	;
   22                        	; Make certain System Card variables accessible to HuCC.
   23                        	
   24    00:E286             	_irq_cnt	.alias	irq_cnt
   25    00:E286             	_joynow		.alias	joynow
   26    00:E286             	_joytrg		.alias	joytrg
   27    00:E286             	_joy6now	.alias	joy6now
   28    00:E286             	_joy6trg	.alias	joy6trg
   29    00:E286             	_bg_x1		.alias	bg_x1
   30    00:E286             	_bg_y1		.alias	bg_y1
   31    00:E286             	_bg_x2		.alias	bg_x2
   32    00:E286             	_bg_y2		.alias	bg_y2
   33                        	
   34                        	
   35                        	
   36                        	; ***************************************************************************
   37                        	; ***************************************************************************
   38                        	;
   39                        	; void __fastcall dump_screen( void );
   40                        	;
   41                        	; THIS IS AN ILLEGAL INSTRUCTION ONLY IMPLEMENTED BY THE TGEMU EMULATOR!
   42                        	
   43    00:E286  33         	_dump_screen:	db	0x33
   44                        	
   45                        	
   46                        	
   47                        	; ***************************************************************************
   48                        	; ***************************************************************************
   49                        	;
   50                        	; void __fastcall abort( void );
   51                        	;
   52                        	; THIS IS AN ILLEGAL INSTRUCTION ONLY IMPLEMENTED BY THE TGEMU EMULATOR!
   53                        	
   54    00:E287  E2         	_abort:		db	0xE2
   55                        	
   56                        	
   57                        	
   58                        	; ***************************************************************************
   59                        	; ***************************************************************************
   60                        	;
   61                        	; void __fastcall exit( int value<acc> );
   62                        	;
   63                        	; THIS IS AN ILLEGAL INSTRUCTION ONLY IMPLEMENTED BY THE TGEMU EMULATOR!
   64                        	
   65    00:E288  AA         	_exit.1:	tax				; Put the return code into X.
   66    00:E289  63         			db	0x63
   67                        	
   68    00:E28A  80 FE      	.hang:		bra	.hang			; Hang if used in normal code.
   69                        	
   70                        	
   71                        	
   72                        	; ***************************************************************************
   73                        	; ***************************************************************************
   74                        	;
   75                        	; unsigned char __fastcall __macro cd_execoverlay( unsigned char ovl_index<acc> );
   76                        	;
   77                        	; Execute program overlay from disc
   78                        	;
   79                        	; N.B. This does not return, even if there's an error.
   80                        	
   81                        			.macro	_cd_execoverlay.1
   82                        			tax
   83                        			jmp	exec_overlay
   84                        			.endm
   85                        	
   86                        	
   87                        	
   88                        	; ***************************************************************************
   89                        	; ***************************************************************************
   90                        	;
   91                        	; void __fastcall __nop set_far_base( unsigned char data_bank<_bp_bank>, unsigned char *data_addr<_bp> );
   92                        	; void __fastcall set_far_offset( unsigned int offset<_bp>, unsigned char data_bank<_bp_bank>, unsigned char *data_addr<acc> );
   93                        	
   94    00:E28C             	_set_far_offset.3:
   95    00:E28C  18         			clc
   96    00:E28D  65 EC      			adc.l	<_bp
   97    00:E28F  85 EC      			sta.l	<_bp
   98    00:E291  98         			tya
   99    00:E292  29 1F      			and	#$1F
  100    00:E294  65 ED      			adc.h	<_bp
  101    00:E296  A8         			tay
  102    00:E297  29 1F      			and	#$1F
  103    00:E299  09 60      			ora	#$60
  104    00:E29B  85 ED      			sta.h	<_bp
  105    00:E29D  98         			tya
  106    00:E29E  6A         			ror	a
  107    00:E29F  4A         			lsr	a
  108    00:E2A0  4A         			lsr	a
  109    00:E2A1  4A         			lsr	a
  110    00:E2A2  4A         			lsr	a
  111    00:E2A3  18         			clc
  112    00:E2A4  65 02      			adc	<_bp_bank
  113    00:E2A6  85 02      			sta	<_bp_bank
  114    00:E2A8  60         			rts
  115                        	
  116                        	
  117                        	; ***************************************************************************
  118                        	; ***************************************************************************
  119                        	;
  120                        	; void __fastcall __macro reset_mpr2( void );
  121                        	; void __fastcall __macro reset_mpr34( void );
  122                        	;
  123                        	; void * __fastcall __macro set_mpr2( void __far *addr<_bp_bank:_bp> );
  124                        	; void * __fastcall __macro set_mpr34( void __far *addr<_bp_bank:_bp> );
  125                        	;
  126                        	; void * __fastcall __macro far_set_mpr2( void );
  127                        	; void * __fastcall __macro far_set_mpr34( void );
  128                        	
  129                        	_reset_mpr2	.macro
  130                        		.if	SUPPORT_SGX
  131                        			lda	#$F9
  132                        		.else
  133                        			lda	#$87
  134                        		.endif
  135                        			tam2
  136                        			.endm
  137                        	
  138                        	_reset_mpr34	.macro
  139                        			lda	#CONST_BANK + _bank_base
  140                        			tam3
  141                        			inc	a
  142                        			tam4
  143                        			.endm
  144                        	
  145                        	_farset_mpr2.1	.macro
  146                        			lda	<_bp_bank
  147                        			tam2
  148                        			lda.l	<_bp
  149                        			ldy.h	<_bp
  150                        			.endm
  151                        	
  152                        	_farset_mpr34.1	.macro
  153                        			lda	<_bp_bank
  154                        			tam3
  155                        			inc	a
  156                        			tam4
  157                        			lda.l	<_bp
  158                        			ldy.h	<_bp
  159                        			.endm
  160                        	
  161                        	_far_set_mpr2	.macro
  162                        			lda	<_bp_bank
  163                        			tam2
  164                        			lda.l	<_bp
  165                        			ldy.h	<_bp
  166                        			.endm
  167                        	
  168                        	_far_set_mpr34	.macro
  169                        			lda	<_bp_bank
  170                        			tam3
  171                        			inc	a
  172                        			tam4
  173                        			lda.l	<_bp
  174                        			ldy.h	<_bp
  175                        			.endm
  176                        	
  177                        	
  178                        	
  179                        	; ***************************************************************************
  180                        	; ***************************************************************************
  181                        	;
  182                        	; unsigned char __fastcall __macro ac_exists( void );
  183                        	
  184                        	_ac_exists	.macro
  185                        			cla
  186                        			ldy	ACD_FLAG
  187                        			cpy	#ACD_ID
  188                        			bne	!+
  189                        			inc	a
  190                        	!:		cly
  191                        			.endm
  192                        	
  193                        	
  194                        	
  195                        	; ***************************************************************************
  196                        	; ***************************************************************************
  197                        	;
  198                        	; unsigned char __fastcall __macro _sgx_detect( void );
  199                        	
  200                        	_sgx_detect	.macro
  201                        			lda	sgx_detected
  202                        			cly
  203                        			.endm
  204                        	
  205                        	
  206                        	
  207                        	; ***************************************************************************
  208                        	; ***************************************************************************
  209                        	;
  210                        	; unsigned int __fastcall __macro peek( unsigned int addr<__ptr> );
  211                        	
  212                        	_peek.1		.macro
  213                        			lda	[__ptr]
  214                        			cly
  215                        			.endm
  216                        	
  217                        	
  218                        	
  219                        	; ***************************************************************************
  220                        	; ***************************************************************************
  221                        	;
  222                        	; unsigned int __fastcall __macro peekw( unsigned int addr<__ptr> );
  223                        	
  224                        	_peekw.1	.macro
  225                        			lda	[__ptr]
  226                        			pha
  227                        			ldy	#1
  228                        			lda	[__ptr], y
  229                        			tay
  230                        			pla
  231                        			.endm
  232                        	
  233                        	
  234                        	
  235                        	; ***************************************************************************
  236                        	; ***************************************************************************
  237                        	;
  238                        	; void __fastcall __macro poke( unsigned int addr<__poke>, unsigned char with<acc> );
  239                        	;
  240                        	; N.B. Because the <acc> value can be a complex C calculation, it isn't safe
  241                        	; to use __ptr as the destination, which can be overwritten in C macros.
  242                        	
  243                        	_poke.2		.macro
  244                        			sta	[__poke]
  245                        			.endm
  246                        	
  247                        	
  248                        	
  249                        	; ***************************************************************************
  250                        	; ***************************************************************************
  251                        	;
  252                        	; void __fastcall __macro pokew( unsigned int addr<__poke>, unsigned int with<acc> );
  253                        	;
  254                        	; N.B. Because the <acc> value can be a complex C calculation, it isn't safe
  255                        	; to use __ptr as the destination, which can be overwritten in C macros.
  256                        	
  257                        	_pokew.2	.macro
  258                        			sta	[__poke]
  259                        			tya
  260                        			ldy	#1
  261                        			sta	[__poke], y
  262                        			.endm
  263                        	
  264                        	
  265                        	
  266                        	; ***************************************************************************
  267                        	; ***************************************************************************
  268                        	;
  269                        	; unsigned char __fastcall __macro clock_hh( void );
  270                        	
  271                        	_clock_hh	.macro
  272                        			lda	clock_hh
  273                        			cly
  274                        			.endm
  275                        	
  276                        	
  277                        	
  278                        	; ***************************************************************************
  279                        	; ***************************************************************************
  280                        	;
  281                        	; unsigned char __fastcall __macro clock_mm( void );
  282                        	
  283                        	_clock_mm	.macro
  284                        			lda	clock_mm
  285                        			cly
  286                        			.endm
  287                        	
  288                        	
  289                        	
  290                        	; ***************************************************************************
  291                        	; ***************************************************************************
  292                        	;
  293                        	; unsigned char __fastcall __macro clock_ss( void );
  294                        	
  295                        	_clock_ss	.macro
  296                        			lda	clock_ss
  297                        			cly
  298                        			.endm
  299                        	
  300                        	
  301                        	
  302                        	; ***************************************************************************
  303                        	; ***************************************************************************
  304                        	;
  305                        	; unsigned char __fastcall __macro clock_tt( void );
  306                        	
  307                        	_clock_tt	.macro
  308                        			lda	clock_tt
  309                        			cly
  310                        			.endm
  311                        	
  312                        	
  313                        	
  314                        	; ***************************************************************************
  315                        	; ***************************************************************************
  316                        	;
  317                        	; void __fastcall __macro clock_reset( void );
  318                        	
  319                        	_clock_reset	.macro
  320                        			stz	clock_hh
  321                        			stz	clock_mm
  322                        			stz	clock_ss
  323                        			stz	clock_tt
  324                        			.endm
  325                        	
  326                        	
  327                        	
  328                        	; ***************************************************************************
  329                        	; ***************************************************************************
  330                        	;
  331                        	; unsigned int __fastcall __macro joy( unsigned char which<acc> );
  332                        	
  333                        	_joy.1		.macro
  334                        			tax
  335                        			lda	joynow, x
  336                        		.if	SUPPORT_6BUTTON
  337                        			ldy	joy6now, x
  338                        		.else
  339                        			cly
  340                        		.endif
  341                        			.endm
  342                        	
  343                        	
  344                        	
  345                        	; ***************************************************************************
  346                        	; ***************************************************************************
  347                        	;
  348                        	; unsigned int __fastcall __macro joytrg( unsigned char which<acc> );
  349                        	
  350                        	_joytrg.1	.macro
  351                        			tax
  352                        			lda	joytrg, x
  353                        		.if	SUPPORT_6BUTTON
  354                        			ldy	joy6trg, x
  355                        		.else
  356                        			cly
  357                        		.endif
  358                        			.endm
  359                        	
  360                        	
  361                        	
  362                        	; ***************************************************************************
  363                        	; ***************************************************************************
  364                        	;
  365                        	; unsigned int __fastcall __macro joybuf( unsigned char which<acc> );
  366                        	
  367                        	_joybuf.1	.macro
  368                        		.if	HUC_JOY_EVENTS
  369                        			tax
  370                        			lda	joybuf, x
  371                        		.if	SUPPORT_6BUTTON
  372                        			ldy	joy6buf, x
  373                        		.else
  374                        			cly
  375                        		.endif
  376                        		.else
  377                        			.fail	You must enable HUC_JOY_EVENTS in your hucc-config.inc!
  378                        		.endif
  379                        			.endm
  380                        	
  381                        	
  382                        	
  383                        	; ***************************************************************************
  384                        	; ***************************************************************************
  385                        	;
  386                        	; unsigned int __fastcall __macro get_joy_events( unsigned char which<acc> );
  387                        	;
  388                        	; N.B. This is just a version of joybuf() that clears the accumulated events.
  389                        	
  390                        			.macro	_get_joy_events.1
  391                        		.if	HUC_JOY_EVENTS
  392                        			tax
  393                        			lda	joybuf, x
  394                        			stz	joybuf, x
  395                        		.if	SUPPORT_6BUTTON
  396                        			ldy	joy6buf, x
  397                        			stz	joy6buf, x
  398                        		.else
  399                        			cly
  400                        		.endif
  401                        		.else
  402                        		.if	ACCUMULATE_JOY
  403                        			tax
  404                        			lda	joytrg, x
  405                        			stz	joytrg, x
  406                        		.if	SUPPORT_6BUTTON
  407                        			ldy	joy6trg, x
  408                        			stz	joy6trg, x
  409                        		.else
  410                        			cly
  411                        		.endif
  412                        		.else
  413                        			.fail	You must enable HUC_JOY_EVENTS or ACCUMULATE_JOY in your hucc-config.inc!
  414                        		.endif
  415                        		.endif
  416                        			.endm
  417                        	
  418                        	
  419                        	
  420                        	; ***************************************************************************
  421                        	; ***************************************************************************
  422                        	;
  423                        	; void __fastcall __macro clear_joy_events( unsigned char mask<acc> );
  424                        	
  425                        			.macro	_clear_joy_events.1
  426                        			php
  427                        			sei
  428                        			and	#(1 << MAX_PADS) - 1
  429                        			ldx	#$FF
  430                        	.loop:		inx
  431                        			lsr	a
  432                        			bcc	.next
  433                        		.if	HUC_JOY_EVENTS
  434                        			stz	joybuf, x
  435                        		.if	SUPPORT_6BUTTON
  436                        			stz	joy6buf, x
  437                        		.endif
  438                        		.else
  439                        		.if	ACCUMULATE_JOY
  440                        			stz	joytrg, x
  441                        		.if	SUPPORT_6BUTTON
  442                        			stz	joy6trg, x
  443                        		.endif
  444                        		.else
  445                        			.fail	You must enable HUC_JOY_EVENTS or ACCUMULATE_JOY in your hucc-config.inc!
  446                        		.endif
  447                        		.endif
  448                        	.next:		bne	.loop
  449                        			plp
  450                        			.endm
  451                        	
  452                        	
  453                        	
  454                        	; ***************************************************************************
  455                        	; ***************************************************************************
  456                        	;
  457                        	; void __fastcall srand( unsigned char seed<acc> );
  458                        	
  459               0001     		.ifndef	HUCC_NO_DEFAULT_RANDOM
  460                        	_srand.1	.macro
  461                        			tay
  462                        			jsr	init_random
  463                        			.endm
  464                        		.endif
  465                        	
  466                        	
  467                        	
  468                        	; ***************************************************************************
  469                        	; ***************************************************************************
  470                        	;
  471                        	; unsigned int __fastcall rand( void );
  472                        	; unsigned char __fastcall rand8( void );
  473                        	
  474               0001     		.ifndef	HUCC_NO_DEFAULT_RANDOM
  475    00:E2A9  20 C3 E5   	_rand:		jsr	get_random		; Random in A, preserve Y.
  476    00:E2AC  A8         			tay
  477    00:E2AD  4C C3 E5   			jmp	get_random		; Random in A, preserve Y.
  478                        		.endif
  479                        	
  480                        	
  481                        	
  482                        	; ***************************************************************************
  483                        	; ***************************************************************************
  484                        	;
  485                        	; unsigned char __fastcall random8( unsigned char limit<acc> );
  486                        	;
  487                        	; IN :	A = range (0..255)
  488                        	; OUT : A = random number interval 0 <= x < A
  489                        	
  490               0001     		.ifndef	HUCC_NO_DEFAULT_RANDOM
  491                        	
  492    00:E2B0  A8         	_random8.1:	tay				; Preserve the limit.
  493    00:E2B1  20 C3 E5   			jsr	get_random		; Random in A, preserve Y.
  494                        	
  495    00:E2B4  20 F0 E4   			jsr	__muluchar
  496    00:E2B7  98         			tya				; Do a 8.0 x 0.8 fixed point
  497    00:E2B8  C2         			cly				; fractional multiply.
  498    00:E2B9  60         			rts
  499                        		.endif
  500                        	
  501                        	
  502                        	
  503                        	; ***************************************************************************
  504                        	; ***************************************************************************
  505                        	;
  506                        	; unsigned char __fastcall random( unsigned char limit<acc> );
  507                        	;
  508                        	; IN :	A = range (0..128), 129..255 is treated as 128
  509                        	; OUT : A = random number interval 0 <= x < A
  510                        	
  511               0001     		.ifndef	HUCC_NO_DEFAULT_RANDOM
  512                        	
  513    00:E2BA  A8         	_random.1:	tay				; Preserve the limit.
  514    00:E2BB  20 C3 E5   			jsr	get_random		; Random in A, preserve Y.
  515                        	
  516    00:E2BE  C0 80      			cpy	#128			; Check the limit.
  517    00:E2C0  90 04      			bcc	!+
  518                        	
  519    00:E2C2  29 7F      			and	#$7F			; Just mask the random if
  520    00:E2C4  C2         			cly				; the limit is >= 128.
  521    00:E2C5  60         			rts
  522                        	
  523    00:E2C6  20 F0 E4   	!:		jsr	__muluchar
  524    00:E2C9  98         			tya				; If the limit is < 128 then
  525    00:E2CA  C2         			cly				; do a 8.0 x 0.8 fixed point
  526    00:E2CB  60         			rts				; fractional multiply.
  527                        		.endif
  528                        	
  529                        	
  530                        	
  531                        	; ***************************************************************************
  532                        	; ***************************************************************************
  533                        	;
  534                        	; unsigned char __fastcall __builtin_ffs( unsigned int value<__temp> );
  535                        	
  536                        			.proc	___builtin_ffs.1
  556                        			.endp
  557                        	
  558                        	
  559                        	
  560                        	; ***************************************************************************
  561                        	; ***************************************************************************
  562                        	;
  563                        	; N.B. Declared in hucc-string.h, but defined here because they're macros!
  564                        	;
  565                        	; int __fastcall __macro memcmp( unsigned char *destination<_di>, unsigned char *source<_bp>, unsigned int count<acc> );
  566                        	
  567                        	_memcmp.3	.macro
  568                        			stz	<_bp_bank		; Map the source string.
  569                        			call	_farmemcmp.3
  570                        			.endm
  571                        	
  572                        	
  573                        	
  574                        	; ***************************************************************************
  575                        	; ***************************************************************************
  576                        	;
  577                        	; N.B. Declared in hucc-gfx.h, but defined here because they're macros!
  578                        	;
  579                        	; void __fastcall __macro get_color( unsigned int index<VCE_CTA> );
  580                        	
  581                        	_get_color.1	.macro
  582                        			lda.l	VCE_CTR
  583                        			ldy.h	VCE_CTR
  584                        			.endm
  585                        	
  586                        	
  587                        	
  588                        	; ***************************************************************************
  589                        	; ***************************************************************************
  590                        	;
  591                        	; N.B. Declared in hucc-gfx.h, but defined here because they're macros!
  592                        	;
  593                        	; void __fastcall __macro fade_to_black( unsigned int __far *from<_bp_bank:_bp>, unsigned int *destination<_di>, unsigned char num_colors<_al>, unsigned char value_to_sub<_ah> );
  594                        	; void __fastcall __macro fade_to_white( unsigned int __far *from<_bp_bank:_bp>, unsigned int *destination<_di>, unsigned char num_colors<_al>, unsigned char value_to_add<_ah> );
  595                        	; void __fastcall __macro cross_fade_to( unsigned int __far *from<_bp_bank:_bp>, unsigned int *destination<_di>, unsigned char num_colors<_al>, unsigned char which_component<_ah );
  596                        	;
  597                        	; void __fastcall __macro far_fade_to_black( unsigned int *destination<_di>, unsigned char num_colors<_al>, unsigned char value_to_sub<_ah> );
  598                        	; void __fastcall __macro far_fade_to_white( unsigned int *destination<_di>, unsigned char num_colors<_al>, unsigned char value_to_add<_ah> );
  599                        	; void __fastcall __macro far_cross_fade_to( unsigned int *destination<_di>, unsigned char num_colors<_al>, unsigned char which_component<_ah );
  600                        	
  601                        			.macro	_fade_to_black.4
  602                        			ldy	<_bp_bank
  603                        			call	fade_to_black
  604                        			.endm
  605                        	
  606                        			.macro	_fade_to_white.4
  607                        			ldy	<_bp_bank
  608                        			call	fade_to_white
  609                        			.endm
  610                        	
  611                        			.macro	_cross_fade_to.4
  612                        			ldy	<_bp_bank
  613                        			call	cross_fade_to
  614                        			.endm
  615                        	
  616                        			.macro	_far_fade_to_black.3
  617                        			ldy	<_bp_bank
  618                        			call	fade_to_black
  619                        			.endm
  620                        	
  621                        			.macro	_far_fade_to_white.3
  622                        			ldy	<_bp_bank
  623                        			call	fade_to_white
  624                        			.endm
  625                        	
  626                        			.macro	_far_cross_fade_to.3
  627                        			ldy	<_bp_bank
  628                        			call	cross_fade_to
  629                        			.endm
  630                        	
  631                        	
  632                        	
  633                        	; ***************************************************************************
  634                        	; ***************************************************************************
  635                        	;
  636                        	; N.B. Declared in hucc-gfx.h, but defined here because they're macros!
  637                        	;
  638                        	; void __fastcall __macro set_xres( unsigned int x_pixels<_ax> );
  639                        	; void __fastcall __macro sgx_set_xres( unsigned int x_pixels<_ax> );
  640                        	;
  641                        	; void __fastcall set_xres( unsigned int x_pixels<_ax>, unsigned char blur_flag<_bl> );
  642                        	; void __fastcall sgx_set_xres( unsigned int x_pixels<_ax>, unsigned char blur_flag<_bl> );
  643                        	
  644                        	_set_xres.1	.macro
  645                        			lda	#XRES_SOFT
  646                        			sta	<_bl
  647                        			call	_set_xres.2
  648                        			.endm
  649                        	
  650               0001     		.if	SUPPORT_SGX
  651                        			.macro	_sgx_set_xres.1
  652                        			lda	#XRES_SOFT
  653                        			sta	<_bl
  654                        			call	_sgx_set_xres.2
  655                        			.endm
  656                        		.endif
  657                        	
  658                        	
  659                        	
  660                        	; ***************************************************************************
  661                        	; ***************************************************************************
  662                        	;
  663                        	; N.B. Declared in hucc-gfx.h, but defined here because they're macros!
  664                        	;
  665                        	; unsigned int __fastcall __macro vram_addr( unsigned char bat_x<_al>, unsigned char bat_y<_ah> );
  666                        	; unsigned int __fastcall __macro sgx_vram_addr( unsigned char bat_x<_al>, unsigned char bat_y<_ah> );
  667                        	
  668                        			.macro	_vram_addr.2
  669                        			cla
  670                        			bit	vdc_bat_width
  671                        			bmi	!w128+
  672                        			bvs	!w64+
  673                        	!w32:		lsr	<_ah
  674                        			ror	a
  675                        	!w64:		lsr	<_ah
  676                        			ror	a
  677                        	!w128:		lsr	<_ah
  678                        			ror	a
  679                        			ora	<_al
  680                        			ldy	<_ah
  681                        			.endm
  682                        	
  683               0001     		.if	SUPPORT_SGX
  684                        			.macro	_sgx_vram_addr.2
  685                        			cla
  686                        			bit	sgx_bat_width
  687                        			bmi	!w128+
  688                        			bvs	!w64+
  689                        	!w32:		lsr	<_ah
  690                        			ror	a
  691                        	!w64:		lsr	<_ah
  692                        			ror	a
  693                        	!w128:		lsr	<_ah
  694                        			ror	a
  695                        			ora	<_al
  696                        			ldy	<_ah
  697                        			.endm
  698                        		.endif
  699                        	
  700                        	
  701                        	
  702                        	; ***************************************************************************
  703                        	; ***************************************************************************
  704                        	;
  705                        	; N.B. Declared in hucc-gfx.h, but defined here because they're macros!
  706                        	;
  707                        	; unsigned int __fastcall __macro get_vram( unsigned int address<_di> );
  708                        	; void __fastcall __macro put_vram( unsigned int address<_di>, unsigned int data<acc> );
  709                        	;
  710                        	; unsigned int __fastcall __macro sgx_get_vram( unsigned int address<_di> );
  711                        	; void __fastcall __macro sgx_put_vram( unsigned int address<_di>, unsigned int data<acc> );
  712                        	
  713                        			.macro	_get_vram.1
  714                        			jsr	vdc_di_to_marr
  715                        			lda	VDC_DL
  716                        			ldy	VDC_DH
  717                        			.endm
  718                        	
  719                        			.macro	_put_vram.2
  720                        			pha
  721                        			jsr	vdc_di_to_mawr
  722                        			pla
  723                        			sta	VDC_DL
  724                        			sty	VDC_DH
  725                        			.endm
  726                        	
  727               0001     		.if	SUPPORT_SGX
  728                        			.macro	_sgx_get_vram.1
  729                        			jsr	sgx_di_to_marr
  730                        			lda	SGX_DL
  731                        			ldy	SGX_DH
  732                        			.endm
  733                        	
  734                        			.macro	_sgx_put_vram.2
  735                        			pha
  736                        			jsr	sgx_di_to_mawr
  737                        			pla
  738                        			sta	SGX_DL
  739                        			sty	SGX_DH
  740                        			.endm
  741                        		.endif
  742                        	
  743                        	
  744                        	
  745                        	; ***************************************************************************
  746                        	; ***************************************************************************
  747                        	;
  748                        	; N.B. Declared in hucc-gfx.h, but defined here because they're macros!
  749                        	;
  750                        	; void __fastcall __macro set_bgpal( unsigned char palette<_al>, unsigned char __far *data<_bp_bank:_bp> );
  751                        	; void __fastcall __macro set_bgpal( unsigned char palette<_al>, unsigned char __far *data<_bp_bank:_bp>, unsigned int num_palettes<_ah> );
  752                        	; void __fastcall __macro set_sprpal( unsigned char palette<_al>, unsigned char __far *data<_bp_bank:_bp> );
  753                        	; void __fastcall __macro set_sprpal( unsigned char palette<_al>, unsigned char __far *data<_bp_bank:_bp>, unsigned int num_palettes<_ah> );
  754                        	
  755                        	_set_bgpal.2	.macro
  756                        			lda	#1
  757                        			sta	<_ah
  758                        			call	_load_palette.3
  759                        			.endm
  760                        	
  761                        	_set_bgpal.3	.macro
  762                        			call	_load_palette.3
  763                        			.endm
  764                        	
  765                        	_set_sprpal.2	.macro
  766                        			lda	#1
  767                        			sta	<_ah
  768                        			smb4	<_al
  769                        			call	_load_palette.3
  770                        			.endm
  771                        	
  772                        	_set_sprpal.3	.macro
  773                        			smb4	<_al
  774                        			call	_load_palette.3
  775                        			.endm
  776                        	
  777                        	
  778                        	
  779                        	; ***************************************************************************
  780                        	; ***************************************************************************
  781                        	;
  782                        	; N.B. Declared in hucc-gfx.h, but defined here because they're macros!
  783                        	;
  784                        	; void __fastcall __macro load_vram( unsigned int vram<_di>, unsigned char __far *data<_bp_bank:_bp>, unsigned int num_words<_ax> );
  785                        	; void __fastcall __macro sgx_load_vram( unsigned int vram<_di>, unsigned char __far *data<_bp_bank:_bp>, unsigned int num_words<_ax> );
  786                        	;
  787                        	; void __fastcall __macro far_load_vram( unsigned int vram<_di>, unsigned int num_words<_ax> );
  788                        	; void __fastcall __macro sgx_far_load_vram( unsigned int vram<_di>, unsigned int num_words<_ax> );
  789                        	;
  790                        	
  791               0001     		.if	SUPPORT_SGX
  792                        			.macro	_sgx_load_vram.3
  793                        			ldx	#SGX_VDC_OFFSET		; Offset to SGX VDC.
  794                        			call	load_vram_x
  795                        			.endm
  796                        	
  797                        			.macro	_sgx_far_load_vram.2
  798                        			ldx	#SGX_VDC_OFFSET		; Offset to SGX VDC.
  799                        			call	load_vram_x
  800                        			.endm
  801                        		.endif
  802                        	
  803                        			.macro	_load_vram.3
  804                        			clx				; Offset to PCE VDC.
  805                        			call	load_vram_x
  806                        			.endm
  807                        	
  808                        			.macro	_far_load_vram.2
  809                        			clx				; Offset to PCE VDC.
  810                        			call	load_vram_x
  811                        			.endm
  812                        	
  813                        	
  814                        	
  815                        	; ***************************************************************************
  816                        	; ***************************************************************************
  817                        	;
  818                        	; N.B. Declared in hucc-gfx.h, but defined here because they're macros!
  819                        	;
  820                        	; void __fastcall __macro load_sprites( unsigned int vram<_di>, unsigned char __far *data<_bp_bank:_bp>, unsigned int num_groups<acc> );
  821                        	; void __fastcall __macro sgx_load_sprites( unsigned int vram<_di>, unsigned char __far *data<_bp_bank:_bp>, unsigned int num_groups<acc> );
  822                        	; void __fastcall __macro far_load_sprites( unsigned int vram<_di>, unsigned int num_groups<acc> );
  823                        	; void __fastcall __macro sgx_far_load_sprites( unsigned int vram<_di>, unsigned int num_groups<acc> );
  824                        	
  825               0001     		.if	SUPPORT_SGX
  826                        			.macro	_sgx_load_sprites.3
  827                        			stz.l	<_ax
  828                        			asl	a
  829                        			sta.h	<_ax
  830                        			ldx	#SGX_VDC_OFFSET		; Offset to SGX VDC.
  831                        			call	load_vram_x
  832                        			.endm
  833                        	
  834                        			.macro	_sgx_far_load_sprites.2
  835                        			stz.l	<_ax
  836                        			asl	a
  837                        			sta.h	<_ax
  838                        			ldx	#SGX_VDC_OFFSET		; Offset to SGX VDC.
  839                        			call	load_vram_x
  840                        			.endm
  841                        		.endif
  842                        	
  843                        			.macro	_load_sprites.3
  844                        			stz.l	<_ax
  845                        			asl	a
  846                        			sta.h	<_ax
  847                        			clx				; Offset to PCE VDC.
  848                        			call	load_vram_x
  849                        			.endm
  850                        	
  851                        			.macro	_far_load_sprites.2
  852                        			stz.l	<_ax
  853                        			asl	a
  854                        			sta.h	<_ax
  855                        			clx				; Offset to PCE VDC.
  856                        			call	load_vram_x
  857                        			.endm
  858                        	
  859                        	
  860                        	
  861                        	; ***************************************************************************
  862                        	; ***************************************************************************
  863                        	;
  864                        	; N.B. Declared in hucc-gfx.h, but defined here because they're macros!
  865                        	;
  866                        	; void __fastcall load_default_font( void );
  867                        	; void __fastcall sgx_load_default_font( void );
  868                        	;
  869                        	
  870               0001     		.if	SUPPORT_SGX
  871                        			.macro	_sgx_load_default_font
  872                        			ldx	#SGX_VDC_OFFSET		; Offset to SGX VDC.
  873                        			call	huc_monofont_x
  874                        			.endm
  875                        		.endif
  876                        	
  877                        			.macro	_load_default_font
  878                        			clx				; Offset to PCE VDC.
  879                        			call	huc_monofont_x
  880                        			.endm
  881                        	
  882                        	
  883                        	
  884                        	; ***************************************************************************
  885                        	; ***************************************************************************
  886                        	
  887               0000     		.if	0
  905                        		.endif
                             #[2]   "..\..\..\include\hucc\hucc.asm"
  228                        	
  229               0000     		.if	CDROM
  231                        		.endif
  232                        	
  233                        			; Definitions for compatibility with old HuC/MagicKit projects.
  234                        	
  235               0001     		.ifndef	HUCC_NO_DEPRECATED
                             #[3]   "..\..\..\include\hucc\hucc-deprecated.inc"
  236                        			include	"hucc-deprecated.inc"
    1                        	; ***************************************************************************
    2                        	; ***************************************************************************
    3                        	;
    4                        	; hucc-deprecated.inc
    5                        	;
    6                        	; Macros and definitions for compatibility with old HuC/MagicKit projects.
    7                        	;
    8                        	; Based on the original HuC and MagicKit definitions by David Michel and the
    9                        	; other original HuC developers.
   10                        	;
   11                        	; ***************************************************************************
   12                        	; ***************************************************************************
   13                        	
   14                        			; For compatibility with HuC projects that use the old name.
   15                        	
   16               0001     	HUC_USER_RESERVED = HUC_USER_BANK
   17                        	
   18                        			; For compatibility with code that expects the HuC naming that
   19                        			; is used in the newer HuC, rather than the original HuC v3.21.
   20                        			;
   21                        			; Code generated by HuCC uses the original single-underscore.
   22                        	
   23               0001     		.if	1				
   24               0002     	__bp		=	$F8:20EC, 2		; base pointer
   25               0002     	__si		=	$F8:20EE, 2		; source address
   26               0002     	__di		=	$F8:20F0, 2		; destination address
   27                        	
   28               0002     	__ax		=	$F8:20F8, 2
   29               0001     	__al		=	$F8:20F8, 1
   30               0001     	__ah		=	$F8:20F9, 1
   31                        	
   32               0002     	__bx		=	$F8:20FA, 2
   33               0001     	__bl		=	$F8:20FA, 1
   34               0001     	__bh		=	$F8:20FB, 1
   35                        	
   36               0002     	__cx		=	$F8:20FC, 2
   37               0001     	__cl		=	$F8:20FC, 1
   38               0001     	__ch		=	$F8:20FD, 1
   39                        	
   40               0002     	__dx		=	$F8:20FE, 2
   41               0001     	__dl		=	$F8:20FE, 1
   42               0001     	__dh		=	$F8:20FF, 1
   43                        		.endif
   44                        	
   45                        			; For compatibility with code that expects the HuC naming that
   46                        			; is used rather than the shorter upper-case #define naming.
   47                        	
   48               0001     		.if	1				
   49               0001     	video_reg	=	$FF:0200, 1		; Address/Status Register
   50               0001     	video_reg_l	=	$FF:0200, 1		; Address/Status Register
   51               0001     	video_reg_h	=	$FF:0201, 1		; Address/Status Register
   52               0002     	video_data	=	$FF:0202, 2		; Data (Read/Write) Low
   53               0001     	video_data_l	=	$FF:0202, 1		; Data (Read/Write) Low
   54               0001     	video_data_h	=	$FF:0203, 1		; Data (Read/Write) High
   55                        	
   56               0002     	color_ctrl	=	$FF:0400, 2		; Control Register
   57               0002     	color_reg	=	$FF:0402, 2		; Color Table Address
   58               0001     	color_reg_l	=	$FF:0402, 1		; Color Table Address
   59               0001     	color_reg_h	=	$FF:0402, 1		; Color Table Address
   60               0002     	color_data	=	$FF:0404, 2		; Color Table Data Read/Write
   61               0001     	color_data_l	=	$FF:0404, 1		; Color Table Data Read/Write
   62               0001     	color_data_h	=	$FF:0405, 1		; Color Table Data Read/Write
   63                        	
   64               0001     	psg_ch		=	$FF:0800, 1		; Channel Select
   65               0001     	psg_mainvol	=	$FF:0801, 1		; Main Amplitude Level
   66               0001     	psg_freqlo	=	$FF:0802, 1		; Frequency Low
   67               0001     	psg_freqhi	=	$FF:0803, 1		; Frequency High
   68               0001     	psg_ctrl	=	$FF:0804, 1		; Control & Channel Amplitude
   69               0001     	psg_pan		=	$FF:0805, 1		; L/R Amplitude Level
   70               0001     	psg_wavebuf	=	$FF:0806, 1		; Waveform
   71               0001     	psg_noise	=	$FF:0807, 1		; Noise
   72               0001     	psg_lfofreq	=	$FF:0808, 1		; LFO Frequency
   73               0001     	psg_lfoctrl	=	$FF:0809, 1		; LFO Control
   74                        	
   75               0001     	irq_m		=	irq_vec, 1		; Old System Card name.
   76               0002     	irq2_jmp	=	irq2_hook, 2		; Old System Card name.
   77               0002     	irq1_jmp	=	irq1_hook, 2		; Old System Card name.
   78               0002     	timer_jmp	=	timer_hook, 2		; Old System Card name.
   79               0002     	nmi_jmp		=	nmi_hook, 2		; Old System Card name.
   80               0002     	sat_adr		=	satb_addr, 2		; Old System Card name.
   81               0005     	joy		=	joynow, 5		; Old System Card name.
   82               0001     	mwr_m		=	vdc_mwr, 1		; Old System Card name.
   83               0001     	dcr_m		=	vdc_dcr, 1		; Old System Card name.
   84                        		.endif
   85                        	
   86                        			; Macros for compatibility with #asm usage in old HuC projects.
   87                        	
   88                        	stw		.macro
   89                        			lda.l	\1
   90                        			sta.l	\2
   91                        			lda.h	\1
   92                        			sta.h	\2
   93                        			.endm
   94                        	
   95                        	stb		.macro
   96                        			lda	\1
   97                        			sta	\2
   98                        			.endm
   99                        	
  100                        	addw		.macro
  101                        		.if	(\# = 3)
  102                        			clc
  103                        			lda.l	\2
  104                        			adc.l	\1
  105                        			sta.l	\3
  106                        			lda.h	\2
  107                        			adc.h	\1
  108                        			sta.h	\3
  109                        		.else
  110                        			clc
  111                        			lda.l	\2
  112                        			adc.l	\1
  113                        			sta.l	\2
  114                        			lda.h	\2
  115                        			adc.h	\1
  116                        			sta.h	\2
  117                        		.endif
  118                        			.endm
  119                        	
  120                        	add		.macro			; add byte-sized value to
  121                        		.if (\# = 2)			; register A (handle carry
  122                        			lda	\2		; flag)
  123                        			clc
  124                        			adc	\1
  125                        			sta	\2
  126                        		.else
  127                        			clc
  128                        			adc	\1
  129                        		.endif
  130                        			.endm
  131                        	
  132                        	subw		.macro
  133                        			sec
  134                        			lda.l	\2
  135                        			sbc.l	\1
  136                        			sta.l	\2
  137                        			lda.h	\2
  138                        			sbc.h	\1
  139                        			sta.h	\2
  140                        			.endm
  141                        	
  142                        	sub		.macro			; subtract byte-sized value
  143                        		.if (\# = 2)			; from register A (handle
  144                        			lda	\2		; carry flag)
  145                        			sec
  146                        			sbc	\1
  147                        			sta	\2
  148                        		.else
  149                        			sec
  150                        			sbc	\1
  151                        		.endif
  152                        			.endm
  153                        	
  154                        	incw		.macro			; increment a word-sized
  155                        			inc.l	\1		; value at stated memory
  156                        			bne	!+		; location
  157                        			inc.h	\1
  158                        	!:
  159                        			.endm
  160                        	
  161                        	decw		.macro			; decrement a word-sized
  162                        			lda	\1		; value at stated memory
  163                        			bne	!+		; location
  164                        			dec.h	\1
  165                        	!:		dec.l	\1
  166                        			.endm
  167                        	
  168                        	lbne		.macro
  169                        			bne	\1
  170                        			.endm
  171                        	
  172                        	lbeq		.macro
  173                        			beq	\1
  174                        			.endm
  175                        	
  176                        	lbpl		.macro
  177                        			bpl	\1
  178                        			.endm
  179                        	
  180                        	lbmi		.macro
  181                        			bmi	\1
  182                        			.endm
  183                        	
  184                        	lbcc		.macro
  185                        			bcc	\1
  186                        			.endm
  187                        	
  188                        	lbcs		.macro
  189                        			bcs	\1
  190                        			.endm
  191                        	
  192                        	lblo		.macro
  193                        			bcc	\1
  194                        			.endm
  195                        	
  196                        	lbhs		.macro
  197                        			bcs	\1
  198                        			.endm
  199                        	
  200                        	__ldwi		.macro
  201                        		__ld.wi		\1
  202                        			.endm
                             #[2]   "..\..\..\include\hucc\hucc.asm"
  237                        		.endif
  238                        	
  239                        			;
  240                        			;
  241                        			;
  242                        	
  243                        	
  244                        	
  245                        	; ***************************************************************************
  246                        	; ***************************************************************************
  247                        	;
  248                        	; core_main - This is executed after "CORE(not TM)" library initialization.
  249                        	;
  250                        	; This is the first code assembled after the library includes, so we're still
  251                        	; in the CORE_BANK, usually ".bank 0"; and because this is assembled with the
  252                        	; default configuration from "include/core-config.inc", which sets the option
  253                        	; "USING_MPR7", then we're running in MPR7 ($E000-$FFFF).
  254                        	
  255    01:C557             	core_main	.proc
  256                        	
  257               0001     		.if	SUPPORT_SGX
  258    01:C557  A9 F9      			lda	#$F9			; Map the 2nd SGX RAM bank.
  259                        		.else
  261                        		.endif
  262    01:C559  53 04      			tam2
  263                        	
  264    01:C55B  A9 01      			lda	#CONST_BANK + _bank_base; Map HuCC's .RODATA bank.
  265    01:C55D  53 08      			tam3
  266    01:C55F  1A         			inc	a
  267    01:C560  53 10      			tam4
  268                        	
  269               0000     		.ifdef	HOME_BANK
  271                        		.else
  272    01:C562  1A         			inc	a
  273                        		.endif
  274    01:C563  53 20      			tam5
  275                        	
  276    01:C565  08         			php				; Disable interrupts while
  277    01:C566  78         			sei				; clearing overlay's BSS.
  278                        	
  279               0000     		.ifndef	USING_RCR_MACROS
  294                        		.endif	USING_RCR_MACROS
  295                        	
  296    01:C567  A9 CC      			lda	#<hucc_vbl		; Setup HuCC's VBL IRQ handler.
  297    01:C569  8D 08 22   			sta.l	vsync_hook
  298    01:C56C  A9 E2      			lda	#>hucc_vbl
  299    01:C56E  8D 09 22   			sta.h	vsync_hook
  300                        	
  301               0000     		.if	CDROM				; Overlays should clear BSS.
  303                        		.else
  304    01:C571  73 BE C5 F0			tii	.rom_tia, ram_tia, 16	; Only needed on HuCARD.
         01:C575  22 10 00    
  305                        		.endif	CDROM
  306                        	
  307               0000     		.if	(__heap_start - __bss_init)	; Copy initialized BSS data.
  309                        		.endif
  310                        	
  311    01:C578  F3 BC C5 08			tai	.stack_fill, __stack, HUCC_STACK_SZ
         01:C57C  20 80 00    
  312                        	
  313               0000     		.if	FAST_MULTIPLY
  322                        		.endif
  323                        	
  324    01:C57F  A9 10      			lda	#$10			; Enable HuCC's vblank IRQ
  325    01:C581  04 F5      			tsb	<irq_vec		; handler.
  326                        	
  327                        			__sound_init			; Initialize a sound driver.
  328                        	
  329    01:C583  AD 00 02   			lda	VDC_SR			; Purge any overdue VBL.
  330    01:C586  9C 41 22   			stz	irq_cnt			; Make it easy to check.
  331                        	
  332    01:C589  28         			plp				; Restore interrupts.
  333                        	
  334               0001     		.ifndef	HUCC_NO_DEFAULT_SCREEN
  335    01:C58A  20 D1 FF   			call	_init_256x224		; HuCC initializes the VDC and
  336    01:C58D  20 16 E4   			jsr	set_dspon		; turns the display on.
  337                        		.endif
  338                        	
  339               0001     		.ifndef	HUCC_NO_DEFAULT_FONT
  340    01:C590  A9 01      			lda	#1			; HuCC loads a default font.
  341    01:C592  8D 73 23   			sta	monofont_fg
  342    01:C595  9C 74 23   			stz	monofont_bg
  343                        			_load_default_font
         01:C598  82         			clx				; Offset to PCE VDC.
         01:C599  20 C7 FF   			call	huc_monofont_x
  344    01:C59C  A9 01      			lda	#$01			; Set the font palette entry to
  345    01:C59E  8D 02 04   			sta.l	VCE_CTA			; cyan which is a) visible, but
  346    01:C5A1  9C 03 04   			stz.h	VCE_CTA			; b) a clear indicator that the
  347    01:C5A4  A0 96      			ldy	#$96			; user hasn't set a palette yet.
  348    01:C5A6  8C 04 04   			sty.l	VCE_CTW
  349    01:C5A9  8D 05 04   			sta.h	VCE_CTW
  350                        		.endif
  351                        	
  352               0001     		.ifndef	HUCC_NO_DEFAULT_RANDOM
  353    01:C5AC  AC 41 22   			ldy	irq_cnt			; Initialize random seed.
  354    01:C5AF  20 BD FF   			call	init_random
  355                        		.endif
  356                        	
  357    01:C5B2  A2 80      			ldx	#HUCC_STACK_SZ		; Initialize the HuCC stack.
  358    01:C5B4  86 8D      			stx	<__sp
  359                        	
  360    01:C5B6  20 B3 FF   			call	_main			; Execute the HuCC program.
  361                        	
  362    01:C5B9  4C 88 E2   			jmp	_exit.1			; Pass the exit code on.
  363                        	
  364    01:C5BC  EA EA      	.stack_fill:	db	$EA,$EA			; To make it easier to see.
  365                        	
  366               0001     		.if	!CDROM
  367                        	
  368    01:C5BE  E3 34 12 02	.rom_tia:	tia	$1234, VDC_DL, 32
         01:C5C2  02 20 00    
  369    01:C5C5  60         			rts
  370                        	
  371    01:C5C6  73 34 12 78	.rom_tii:	tii	$1234, $5678, $9ABC
         01:C5CA  56 BC 9A    
  372    01:C5CD  60         			rts
  373                        	
  374               22F0     			.bss
  375    F8:22F0             	ram_tia:	ds	8
  376    F8:22F8             	ram_tii:	ds	8
  377               C5CE     			.code
  378                        	
  379                        		.endif	!CDROM
  380                        	
  381                        			.endp
  382                        	
  383                        			;
  384                        			; Self-Modifying TIA and TII instruction subroutines.
  385                        			;
  386                        			; These need to be in permanently-accessible memory so that
  387                        			; HuCC code can modify the values as __fastcall parameters.
  388                        			;
  389                        	
  390               0000     		.if	CDROM
  398                        		.endif	CDROM
  399                        	
  400               22F0     			rsset	ram_tia
  401               22F0     	ram_tia_opc	rs	1
  402               22F1     	ram_tia_src	rs	2
  403               22F3     	ram_tia_dst	rs	2
  404               22F5     	ram_tia_len	rs	2
  405               22F7     	ram_tia_rts	rs	1
  406                        	
  407               22F8     			rsset	ram_tii
  408               22F8     	ram_tii_opc	rs	1
  409               22F9     	ram_tii_src	rs	2
  410               22FB     	ram_tii_dst	rs	2
  411               22FD     	ram_tii_len	rs	2
  412               22FF     	ram_tii_rts	rs	1
  413                        	
  414                        	
  415                        	
  416                        	; ***************************************************************************
  417                        	; ***************************************************************************
  418                        	;
  419                        	; hucc_vbl - vblank IRQ handler, called by the "CORE(not TM)" kernel.
  420                        	;
  421                        	; This uses the kernel's hook to process things during vblank. It returns
  422                        	; with a simple RTS, and it can corrupt any register.
  423                        	;
  424                        	; Any slow routines in here should enable interrupts and protect itself from
  425                        	; re-entrancy problems.
  426                        	;
  427                        	
  428    00:E2CC  20 A9 FF   	hucc_vbl:	call	vbl_init_scroll		; Prepare for the next frame.
  429                        	
  430    00:E2CF  F8         			sed				; Update the HuC system clock
  431    00:E2D0  38         			sec				; which is in BCD here rather
  432    00:E2D1  AD EF 22   			lda	clock_tt		; than the binary one in HuC.
  433    00:E2D4  69 00      			adc	#0			; BCD add ...
  434    00:E2D6  C9 60      			cmp	#$60			; ... but binary comparison.
  435    00:E2D8  90 28      			bcc	.ticks
  436    00:E2DA  AD EE 22   			lda	clock_ss
  437    00:E2DD  69 00      			adc	#0			; BCD add ...
  438    00:E2DF  C9 60      			cmp	#$60			; ... but binary comparison.
  439    00:E2E1  90 1B      			bcc	.seconds
  440    00:E2E3  AD ED 22   			lda	clock_mm
  441    00:E2E6  69 00      			adc	#0			; BCD add ...
  442    00:E2E8  C9 60      			cmp	#$60			; ... but binary comparison.
  443    00:E2EA  90 0E      			bcc	.minutes
  444    00:E2EC  AD EC 22   			lda	clock_hh
  445    00:E2EF  69 00      			adc	#0			; BCD add ...
  446    00:E2F1  C9 12      			cmp	#$12			; ... but binary comparison.
  447    00:E2F3  90 01      			bcc	.hours
  448    00:E2F5  62         			cla
  449    00:E2F6  8D EC 22   	.hours:		sta	clock_hh
  450    00:E2F9  62         			cla
  451    00:E2FA  8D ED 22   	.minutes:	sta	clock_mm
  452    00:E2FD  62         			cla
  453    00:E2FE  8D EE 22   	.seconds:	sta	clock_ss
  454    00:E301  62         			cla
  455    00:E302  8D EF 22   	.ticks:		sta	clock_tt
  456    00:E305  D8         			cld
  457                        	
  458    00:E306  4C 96 E3   			jmp	xfer_palettes		; Upload any palette changes.
                             #[1]   "main.s"
   15               6000     			.data
   16               0003     			.bank	DATA_BANK
   17                        	
   18               E309     		.code
   19                        	
   20                        		.dbg	line,	"..\..\..\include\hucc\globals.h", 1; // **************************************************************************
   21                        		.dbg	line,	"..\..\..\include\hucc\globals.h", 2; // **************************************************************************
   22                        		.dbg	line,	"..\..\..\include\hucc\globals.h", 3; //
   23                        		.dbg	line,	"..\..\..\include\hucc\globals.h", 4; // globals.h
   24                        		.dbg	line,	"..\..\..\include\hucc\globals.h", 5; //
   25                        		.dbg	line,	"..\..\..\include\hucc\globals.h", 6; // **************************************************************************
   26                        		.dbg	line,	"..\..\..\include\hucc\globals.h", 7; // **************************************************************************
   27                        		.dbg	line,	"..\..\..\include\hucc\globals.h", 8; //
   28                        		.dbg	line,	"..\..\..\include\hucc\globals.h", 9; // The idea is that you, a PCE developer, copy this file from the ../include/
   29                        		.dbg	line,	"..\..\..\include\hucc\globals.h", 10; // directory and into your project's directory, and then define the variables
   30                        		.dbg	line,	"..\..\..\include\hucc\globals.h", 11; // that you want to have shared access to in all overlay programs on your CD.
   31                        		.dbg	line,	"..\..\..\include\hucc\globals.h", 12; //
   32                        		.dbg	line,	"..\..\..\include\hucc\globals.h", 13; // Because PCEAS searches the current (i.e. project) directory for an include
   33                        		.dbg	line,	"..\..\..\include\hucc\globals.h", 14; // file first, then it will find your customized copy of the file rather than
   34                        		.dbg	line,	"..\..\..\include\hucc\globals.h", 15; // the original copy in the ../include/ directory.
   35                        		.dbg	line,	"..\..\..\include\hucc\globals.h", 16; //
   36                        		.dbg	line,	"..\..\..\include\hucc\globals.h", 17; // **************************************************************************
   37                        		.dbg	line,	"..\..\..\include\hucc\globals.h", 18; // **************************************************************************
   38                        		.dbg	clear
   39               2300     		.bss
   40    F8:2300             	huc_globals:
   41                        	
   42    F8:2300             	huc_globals_end:
   43               E309     		.code
   44                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 1; #ifndef _hucc_legacy_h
   45                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 2; #define _hucc_legacy_h
   46                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 4; /****************************************************************************
   47                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 5; ; ***************************************************************************
   48                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 6; ;
   49                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 7; ; huc.h
   50                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 8; ;
   51                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 9; ; HuCC wrapper file to include a default set of HuC-compatible functions.
   52                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 10; ;
   53                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 11; ; Copyright John Brandwood 2024.
   54                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 12; ;
   55                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 13; ; Distributed under the Boost Software License, Version 1.0.
   56                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 14; ; (See accompanying file LICENSE_1_0.txt or copy at
   57                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 15; ;  http://www.boost.org/LICENSE_1_0.txt)
   58                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 16; ;
   59                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 17; ; ***************************************************************************
   60                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 18; ; ***************************************************************************
   61                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 19; ;
   62                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 20; ; When the HuCC compiler is invoked with the "--legacy" option to compile old
   63                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 21; ; projects, then this "huc.h" file is automatically included.
   64                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 22; ;
   65                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 23; ; This file includes a set of the individual HuCC headers which correspond to
   66                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 24; ; HuC's built-in functions and MagicKit library.
   67                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 25; ;
   68                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 26; ; New HuCC projects should, preferably, include the specific headers that are
   69                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 27; ; needed, which will then allow them to replace parts of the standard library
   70                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 28; ; with newer functions, or they can just manually include this "huc.h" file.
   71                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 29; ;
   72                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 30; ; ***************************************************************************
   73                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 31; ; **************************************************************************/
   74                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 33; #include "hucc-systemcard.h"
   75                        		.dbg	line,	"..\..\..\include\hucc\hucc-systemcard.h", 1; #ifndef _hucc_systemcard_h
   76                        		.dbg	line,	"..\..\..\include\hucc\hucc-systemcard.h", 2; #define _hucc_systemcard_h
   77                        		.dbg	line,	"..\..\..\include\hucc\hucc-systemcard.h", 4; /****************************************************************************
   78                        		.dbg	line,	"..\..\..\include\hucc\hucc-systemcard.h", 5; ; ***************************************************************************
   79                        		.dbg	line,	"..\..\..\include\hucc\hucc-systemcard.h", 6; ;
   80                        		.dbg	line,	"..\..\..\include\hucc\hucc-systemcard.h", 7; ; hucc-systemcard.h
   81                        		.dbg	line,	"..\..\..\include\hucc\hucc-systemcard.h", 8; ;
   82                        		.dbg	line,	"..\..\..\include\hucc\hucc-systemcard.h", 9; ; Macros and library functions for using the System Card.
   83                        		.dbg	line,	"..\..\..\include\hucc\hucc-systemcard.h", 10; ;
   84                        		.dbg	line,	"..\..\..\include\hucc\hucc-systemcard.h", 11; ; Copyright John Brandwood 2024.
   85                        		.dbg	line,	"..\..\..\include\hucc\hucc-systemcard.h", 12; ;
   86                        		.dbg	line,	"..\..\..\include\hucc\hucc-systemcard.h", 13; ; Distributed under the Boost Software License, Version 1.0.
   87                        		.dbg	line,	"..\..\..\include\hucc\hucc-systemcard.h", 14; ; (See accompanying file LICENSE_1_0.txt or copy at
   88                        		.dbg	line,	"..\..\..\include\hucc\hucc-systemcard.h", 15; ;  http://www.boost.org/LICENSE_1_0.txt)
   89                        		.dbg	line,	"..\..\..\include\hucc\hucc-systemcard.h", 16; ;
   90                        		.dbg	line,	"..\..\..\include\hucc\hucc-systemcard.h", 17; ; ***************************************************************************
   91                        		.dbg	line,	"..\..\..\include\hucc\hucc-systemcard.h", 18; ; ***************************************************************************
   92                        		.dbg	line,	"..\..\..\include\hucc\hucc-systemcard.h", 19; ;
   93                        		.dbg	line,	"..\..\..\include\hucc\hucc-systemcard.h", 20; ; Because these are mainly macros, and so must be included before being used
   94                        		.dbg	line,	"..\..\..\include\hucc\hucc-systemcard.h", 21; ; in compiled code, the actual functions here are written to avoid using any
   95                        		.dbg	line,	"..\..\..\include\hucc\hucc-systemcard.h", 22; ; BSS memory so that HuCC's overlay global-shared-variables are not effected.
   96                        		.dbg	line,	"..\..\..\include\hucc\hucc-systemcard.h", 23; ;
   97                        		.dbg	line,	"..\..\..\include\hucc\hucc-systemcard.h", 24; ; ***************************************************************************
   98                        		.dbg	line,	"..\..\..\include\hucc\hucc-systemcard.h", 25; ; **************************************************************************/
   99                        		.dbg	line,	"..\..\..\include\hucc\hucc-systemcard.h", 27; // *************
  100                        		.dbg	line,	"..\..\..\include\hucc\hucc-systemcard.h", 28; // Backup RAM defines ...
  101                        		.dbg	line,	"..\..\..\include\hucc\hucc-systemcard.h", 29; // *************
  102                        		.dbg	line,	"..\..\..\include\hucc\hucc-systemcard.h", 31; #define  BM_OK             0
  103                        		.dbg	line,	"..\..\..\include\hucc\hucc-systemcard.h", 32; #define  BM_NOT_FOUND      1
  104                        		.dbg	line,	"..\..\..\include\hucc\hucc-systemcard.h", 33; #define  BM_BAD_CHECKSUM   2
  105                        		.dbg	line,	"..\..\..\include\hucc\hucc-systemcard.h", 34; #define  BM_DIR_CORRUPTED  3
  106                        		.dbg	line,	"..\..\..\include\hucc\hucc-systemcard.h", 35; #define  BM_FILE_EMPTY     4
  107                        		.dbg	line,	"..\..\..\include\hucc\hucc-systemcard.h", 36; #define  BM_FULL           5
  108                        		.dbg	line,	"..\..\..\include\hucc\hucc-systemcard.h", 37; #define  BM_NOT_FORMATED   0xFF			// HuC incorrect spelling.
  109                        		.dbg	line,	"..\..\..\include\hucc\hucc-systemcard.h", 38; #define  BM_NOT_FORMATTED  0xFF			// HuCC can use a dictionary!
  110                        		.dbg	line,	"..\..\..\include\hucc\hucc-systemcard.h", 40; #define  BRAM_STARTPTR     0x8010
  111                        		.dbg	line,	"..\..\..\include\hucc\hucc-systemcard.h", 42; // *************
  112                        		.dbg	line,	"..\..\..\include\hucc\hucc-systemcard.h", 43; // CD defines ...
  113                        		.dbg	line,	"..\..\..\include\hucc\hucc-systemcard.h", 44; // *************
  114                        		.dbg	line,	"..\..\..\include\hucc\hucc-systemcard.h", 46; #define	CDPLAY_MUTE		0
  115                        		.dbg	line,	"..\..\..\include\hucc\hucc-systemcard.h", 47; #define	CDPLAY_REPEAT		1
  116                        		.dbg	line,	"..\..\..\include\hucc\hucc-systemcard.h", 48; #define	CDPLAY_NORMAL		2
  117                        		.dbg	line,	"..\..\..\include\hucc\hucc-systemcard.h", 49; #define	CDPLAY_ENDOFDISC	0
  118                        		.dbg	line,	"..\..\..\include\hucc\hucc-systemcard.h", 51; #define	CDFADE_CANCEL	0
  119                        		.dbg	line,	"..\..\..\include\hucc\hucc-systemcard.h", 52; #define	CDFADE_PCM6	8
  120                        		.dbg	line,	"..\..\..\include\hucc\hucc-systemcard.h", 53; #define	CDFADE_ADPCM6	10
  121                        		.dbg	line,	"..\..\..\include\hucc\hucc-systemcard.h", 54; #define	CDFADE_PCM2	12
  122                        		.dbg	line,	"..\..\..\include\hucc\hucc-systemcard.h", 55; #define	CDFADE_ADPCM2	14
  123                        		.dbg	line,	"..\..\..\include\hucc\hucc-systemcard.h", 57; #define CDTRK_AUDIO	0
  124                        		.dbg	line,	"..\..\..\include\hucc\hucc-systemcard.h", 58; #define CDTRK_DATA	4
  125                        		.dbg	line,	"..\..\..\include\hucc\hucc-systemcard.h", 60; // *************
  126                        		.dbg	line,	"..\..\..\include\hucc\hucc-systemcard.h", 61; // ADPCM defines ...
  127                        		.dbg	line,	"..\..\..\include\hucc\hucc-systemcard.h", 62; // *************
  128                        		.dbg	line,	"..\..\..\include\hucc\hucc-systemcard.h", 64; #define	ADPLAY_AUTOSTOP		0
  129                        		.dbg	line,	"..\..\..\include\hucc\hucc-systemcard.h", 65; #define	ADPLAY_REPEAT		0x80
  130                        		.dbg	line,	"..\..\..\include\hucc\hucc-systemcard.h", 67; #define ADPLAY_FREQ_16KHZ	0xE
  131                        		.dbg	line,	"..\..\..\include\hucc\hucc-systemcard.h", 68; #define ADPLAY_FREQ_10KHZ	0xD
  132                        		.dbg	line,	"..\..\..\include\hucc\hucc-systemcard.h", 69; #define ADPLAY_FREQ_8KHZ	0xC
  133                        		.dbg	line,	"..\..\..\include\hucc\hucc-systemcard.h", 70; #define ADPLAY_FREQ_6KHZ	0xB
  134                        		.dbg	line,	"..\..\..\include\hucc\hucc-systemcard.h", 71; #define ADPLAY_FREQ_5KHZ	0xA
  135                        		.dbg	line,	"..\..\..\include\hucc\hucc-systemcard.h", 73; #define ADREAD_RAM	0
  136                        		.dbg	line,	"..\..\..\include\hucc\hucc-systemcard.h", 74; #define ADREAD_VRAM	0xFF
  137                        		.dbg	line,	"..\..\..\include\hucc\hucc-systemcard.h", 76; #define ADWRITE_RAM	0
  138                        		.dbg	line,	"..\..\..\include\hucc\hucc-systemcard.h", 77; #define ADWRITE_VRAM	0xFF
  139                        		.dbg	line,	"..\..\..\include\hucc\hucc-systemcard.h", 79; // *************
  140                        		.dbg	line,	"..\..\..\include\hucc\hucc-systemcard.h", 80; // Functions in hucc-systemcard.asm ...
  141                        		.dbg	line,	"..\..\..\include\hucc\hucc-systemcard.h", 81; // *************
  142                        		.dbg	line,	"..\..\..\include\hucc\hucc-systemcard.h", 83; #ifdef __HUCC__
  143                        		.dbg	line,	"..\..\..\include\hucc\hucc-systemcard.h", 85; #asmdef	HUCC_USES_SYSTEMCARD 1
  144               0001     	HUCC_USES_SYSTEMCARD = 1
  145                        		.dbg	line,	"..\..\..\include\hucc\hucc-systemcard.h", 87; extern void __fastcall __macro cd_boot( void );
  146                        		.dbg	line,	"..\..\..\include\hucc\hucc-systemcard.h", 88; extern unsigned int __fastcall __macro cd_getver( void );
  147                        		.dbg	line,	"..\..\..\include\hucc\hucc-systemcard.h", 89; extern void __fastcall __macro cd_reset( void );
  148                        		.dbg	line,	"..\..\..\include\hucc\hucc-systemcard.h", 90; extern unsigned char __fastcall __macro cd_pause( void );
  149                        		.dbg	line,	"..\..\..\include\hucc\hucc-systemcard.h", 91; extern unsigned char __fastcall cd_unpause( void );
  150                        		.dbg	line,	"..\..\..\include\hucc\hucc-systemcard.h", 92; extern void __fastcall __macro cd_fade( unsigned char type<acc> );
  151                        		.dbg	line,	"..\..\..\include\hucc\hucc-systemcard.h", 93; extern unsigned char __fastcall cd_playtrk( unsigned char start_track<_bx>, unsigned char end_track<_cx>, unsigned char mode<_dh> );
  152                        		.dbg	line,	"..\..\..\include\hucc\hucc-systemcard.h", 94; extern unsigned char __fastcall cd_playmsf( unsigned char start_minute<_al>,  unsigned char start_second<_ah>,  unsigned char start_frame<_bl>, unsigned char end_minute<_cl>,  unsigned char end_second<_ch>,  unsigned char end_frame<_dl>,  unsigned char mode<_dh> );
  153                        		.dbg	line,	"..\..\..\include\hucc\hucc-systemcard.h", 95; extern unsigned char __fastcall cd_fastvram( unsigned char ovl_index<_cl>, unsigned int sect_offset<_si>, unsigned int vramaddr<_bx>, unsigned int sectors<_al> );
  154                        		.dbg	line,	"..\..\..\include\hucc\hucc-systemcard.h", 96; extern unsigned char __fastcall cd_loadvram( unsigned char ovl_index<_cl>, unsigned int sect_offset<_si>, unsigned int vramaddr<_bx>, unsigned int bytes<_ax> );
  155                        		.dbg	line,	"..\..\..\include\hucc\hucc-systemcard.h", 97; extern unsigned char __fastcall cd_loaddata( unsigned char ovl_index<_cl>, unsigned int sect_offset<_si>, unsigned char __far *buffer<_bp_bank:_bp>, unsigned int bytes<__ptr> );
  156                        		.dbg	line,	"..\..\..\include\hucc\hucc-systemcard.h", 98; extern unsigned char __fastcall cd_loadbank( unsigned char ovl_index<_cl>, unsigned int sect_offset<_si>, unsigned char bank<_bl>, unsigned int sectors<_al> );
  157                        		.dbg	line,	"..\..\..\include\hucc\hucc-systemcard.h", 99; extern unsigned char __fastcall __macro cd_status( unsigned char mode<acc> );
  158                        		.dbg	line,	"..\..\..\include\hucc\hucc-systemcard.h", 101; extern void __fastcall __macro ad_reset( void );
  159                        		.dbg	line,	"..\..\..\include\hucc\hucc-systemcard.h", 102; extern unsigned char __fastcall __macro ad_trans( unsigned char ovl_index<_cl>, unsigned int sect_offset<_si>, unsigned char nb_sectors<_dh>, unsigned int ad_addr<_bx> );
  160                        		.dbg	line,	"..\..\..\include\hucc\hucc-systemcard.h", 103; extern void __fastcall __macro ad_read( unsigned int ad_addr<_cx>, unsigned char mode<_dh>, unsigned int buf<_bx>, unsigned int bytes<_ax> );
  161                        		.dbg	line,	"..\..\..\include\hucc\hucc-systemcard.h", 104; extern void __fastcall __macro ad_write( unsigned int ad_addr<_cx>, unsigned char mode<_dh>, unsigned int buf<_bx>, unsigned int bytes<_ax> );
  162                        		.dbg	line,	"..\..\..\include\hucc\hucc-systemcard.h", 105; extern unsigned char __fastcall __macro ad_play( unsigned int ad_addr<_bx>, unsigned int bytes<_ax>, unsigned char freq<_dh>, unsigned char mode<_dl> );
  163                        		.dbg	line,	"..\..\..\include\hucc\hucc-systemcard.h", 106; extern unsigned char __fastcall __macro ad_cplay( unsigned char ovl_index<_cl>, unsigned int sect_offset<_si>, unsigned int nb_sectors<_bx>, unsigned char freq<_dh> );
  164                        		.dbg	line,	"..\..\..\include\hucc\hucc-systemcard.h", 107; extern void __fastcall __macro ad_stop( void );
  165                        		.dbg	line,	"..\..\..\include\hucc\hucc-systemcard.h", 108; extern unsigned char __fastcall __macro ad_stat( void );
  166                        		.dbg	line,	"..\..\..\include\hucc\hucc-systemcard.h", 110; extern unsigned char __fastcall bm_check( void );
  167                        		.dbg	line,	"..\..\..\include\hucc\hucc-systemcard.h", 111; extern unsigned char __fastcall bm_format( void );
  168                        		.dbg	line,	"..\..\..\include\hucc\hucc-systemcard.h", 112; extern unsigned int __fastcall __macro bm_free( void );
  169                        		.dbg	line,	"..\..\..\include\hucc\hucc-systemcard.h", 113; extern unsigned char __fastcall __macro bm_read( unsigned char *buffer<_bx>, unsigned char *name<_ax>, unsigned int offset<_dx>, unsigned int length<_cx> );
  170                        		.dbg	line,	"..\..\..\include\hucc\hucc-systemcard.h", 114; extern unsigned char __fastcall __macro bm_write( unsigned char *buffer<_bx>, unsigned char *name<_ax>, unsigned int offset<_dx>, unsigned int length<_cx> );
  171                        		.dbg	line,	"..\..\..\include\hucc\hucc-systemcard.h", 115; extern unsigned char __fastcall __macro bm_delete( unsigned char *name<_ax> );
  172                        		.dbg	line,	"..\..\..\include\hucc\hucc-systemcard.h", 117; // Deprecated functions ...
  173                        		.dbg	line,	"..\..\..\include\hucc\hucc-systemcard.h", 119; extern unsigned char __fastcall __macro bm_exist( unsigned char *name<_ax> );
  174                        		.dbg	line,	"..\..\..\include\hucc\hucc-systemcard.h", 120; extern unsigned char __fastcall __macro bm_create( unsigned char *name<_ax>, unsigned int length<_cx> );
  175                        		.dbg	line,	"..\..\..\include\hucc\hucc-systemcard.h", 122; // void __fastcall _xsafe add_sectors( unsigned int sector_offset<acc> );
  176                        		.dbg	line,	"..\..\..\include\hucc\hucc-systemcard.h", 124; #endif // __HUCC__
  177                        		.dbg	line,	"..\..\..\include\hucc\hucc-systemcard.h", 126; #endif // _hucc_systemcard_h
  178                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 34; #include "hucc-baselib.h"
  179                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 1; #ifndef _hucc_baselib_h
  180                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 2; #define _hucc_baselib_h
  181                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 4; /****************************************************************************
  182                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 5; ; ***************************************************************************
  183                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 6; ;
  184                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 7; ; hucc-baselib.h
  185                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 8; ;
  186                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 9; ; Basic library functions provided as macros.
  187                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 10; ;
  188                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 11; ; Copyright John Brandwood 2024.
  189                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 12; ;
  190                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 13; ; Distributed under the Boost Software License, Version 1.0.
  191                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 14; ; (See accompanying file LICENSE_1_0.txt or copy at
  192                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 15; ;  http://www.boost.org/LICENSE_1_0.txt)
  193                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 16; ;
  194                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 17; ; ***************************************************************************
  195                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 18; ; **************************************************************************/
  196                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 20; // *************
  197                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 21; // Joypad defines ...
  198                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 22; // *************
  199                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 24; #define	JOY_A		0x01
  200                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 25; #define	JOY_I		0x01
  201                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 26; #define	JOY_B		0x02
  202                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 27; #define	JOY_II		0x02
  203                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 28; #define	JOY_SLCT	0x04
  204                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 29; #define	JOY_SEL		0x04
  205                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 30; #define	JOY_STRT	0x08
  206                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 31; #define	JOY_RUN		0x08
  207                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 32; #define	JOY_UP		0x10
  208                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 33; #define	JOY_RGHT	0x20
  209                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 34; #define	JOY_RIGHT	0x20
  210                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 35; #define	JOY_DOWN	0x40
  211                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 36; #define	JOY_LEFT	0x80
  212                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 38; #define	JOY_C		0x0100
  213                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 39; #define	JOY_III		0x0100
  214                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 40; #define	JOY_D		0x0200
  215                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 41; #define	JOY_IV		0x0200
  216                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 42; #define	JOY_E		0x0400
  217                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 43; #define	JOY_V		0x0400
  218                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 44; #define	JOY_F		0x0800
  219                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 45; #define	JOY_VI		0x0800
  220                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 47; #define JOY_SIXBUT	0x8000
  221                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 48; #define JOY_TYPE6	0x8000
  222                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 50; // *************
  223                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 51; // SuperGRAFX VPC settings for set_vpc_ctl() ...
  224                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 52; // *************
  225                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 54; #define VPC_SPR1_BKG1_SPR2_BKG2	0x3000 // same as SGX_PARALLAX=0
  226                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 55; #define VPC_SPR1_SPR2_BKG1_BKG2	0x7000 // same as SGX_PARALLAX=1
  227                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 56; #define VPC_BKG1_BKG2_SPR1_SPR2	0xB000
  228                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 58; // *************
  229                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 59; // System Card variables ...
  230                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 60; // *************
  231                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 62; extern unsigned int si;
  232                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 63; extern unsigned int di;
  233                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 64; extern unsigned int bp;
  234                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 66; extern unsigned int ax;
  235                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 67; extern unsigned int bx;
  236                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 68; extern unsigned int cx;
  237                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 69; extern unsigned int dx;
  238                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 71; extern unsigned char al;
  239                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 72; extern unsigned char ah;
  240                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 73; extern unsigned char bl;
  241                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 74; extern unsigned char bh;
  242                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 75; extern unsigned char cl;
  243                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 76; extern unsigned char ch;
  244                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 77; extern unsigned char dl;
  245                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 78; extern unsigned char dh;
  246                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 80; extern unsigned char irq_cnt;
  247                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 81; extern unsigned char joynow[5];
  248                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 82; extern unsigned char joytrg[5];
  249                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 83; extern unsigned char joy6now[5];
  250                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 84; extern unsigned char joy6trg[5];
  251                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 85; extern unsigned int  bg_x1;
  252                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 86; extern unsigned int  bg_y1;
  253                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 87; extern unsigned int  bg_x2;
  254                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 88; extern unsigned int  bg_y2;
  255                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 90; // *************
  256                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 91; // Special macros to get information from PCEAS ...
  257                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 92; // *************
  258                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 94; #define BANK( datasym ) ((unsigned) (&__bank__ ## datasym))
  259                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 95; #define SIZEOF( datasym ) ((unsigned) (&__sizeof__ ## datasym))
  260                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 96; #define COUNTOF( datasym ) ((unsigned) (&__countof__ ## datasym))
  261                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 97; #define OVERLAY( datasym ) ((unsigned) (&__overlay__ ## datasym))
  262                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 100; // *************
  263                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 101; // Functions in hucc-baselib.asm ...
  264                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 102; // *************
  265                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 104; #ifdef __HUCC__
  266                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 106; #asmdef	HUCC_USES_BASELIB 1
  267               0001     	HUCC_USES_BASELIB = 1
  268                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 108; #define	_OPTIMIZE 1
  269                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 111; // *************
  270                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 112; // Hardware Detection
  271                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 113; // *************
  272                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 115; extern unsigned char __fastcall __macro sgx_detect( void );
  273                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 116; extern unsigned char __fastcall __macro ac_exists( void );
  274                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 119; // *************
  275                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 120; // Memory Access
  276                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 121; // *************
  277                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 123; extern unsigned char __fastcall __macro peek( unsigned int addr<__ptr> );
  278                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 124; extern unsigned int  __fastcall __macro peekw( unsigned int addr<__ptr> );
  279                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 126; extern void __fastcall __macro poke( unsigned int addr<__poke>, unsigned char with<acc> );
  280                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 127; extern void __fastcall __macro pokew( unsigned int addr<__poke>, unsigned int with<acc> );
  281                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 129; extern unsigned char __fastcall farpeek( void __far *addr<_bp_bank:_bp> );
  282                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 130; extern unsigned int  __fastcall farpeekw( void __far *addr<_bp_bank:_bp> );
  283                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 132; extern void __fastcall __nop set_far_base( unsigned char data_bank<_bp_bank>, unsigned char *data_addr<_bp> );
  284                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 133; extern void __fastcall set_far_offset( unsigned int offset<_bp>, unsigned char data_bank<_bp_bank>, unsigned char *data_addr<acc> );
  285                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 135; extern unsigned char __fastcall far_peek( void );
  286                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 136; extern unsigned int  __fastcall far_peekw( void );
  287                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 138; extern void __fastcall __macro reset_mpr2( void );
  288                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 139; extern void __fastcall __macro reset_mpr34( void );
  289                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 141; extern void * __fastcall __macro farset_mpr2( void __far *addr<_bp_bank:_bp> );
  290                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 142; extern void * __fastcall __macro farset_mpr34( void __far *addr<_bp_bank:_bp> );
  291                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 144; extern void * __fastcall __macro far_set_mpr2( void );
  292                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 145; extern void * __fastcall __macro far_set_mpr34( void );
  293                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 148; // *************
  294                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 149; // Clock Functions
  295                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 150; // *************
  296                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 152; extern unsigned char __fastcall __macro clock_hh( void );
  297                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 153; extern unsigned char __fastcall __macro clock_mm( void );
  298                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 154; extern unsigned char __fastcall __macro clock_ss( void );
  299                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 155; extern unsigned char __fastcall __macro clock_tt( void );
  300                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 156; extern void __fastcall __macro clock_reset( void );
  301                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 159; // *************
  302                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 160; // Joypad Functions
  303                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 161; // *************
  304                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 163; extern unsigned int __fastcall __macro joy( unsigned char which<acc> );
  305                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 164; extern unsigned int __fastcall __macro joytrg( unsigned char which<acc> );
  306                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 167; // *************
  307                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 168; // Number Functions
  308                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 169; // *************
  309                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 171; extern int __fastcall abs( int value<acc> );
  310                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 173; extern void __fastcall __macro srand( unsigned char seed<acc> );
  311                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 174; extern unsigned int __fastcall rand( void );
  312                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 175; extern unsigned char __fastcall rand8( void );
  313                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 177; // Note: "limit" is 0..255.
  314                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 178; extern unsigned char __fastcall random8( unsigned char limit<acc> );
  315                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 180; // Note: "limit" is 0..128, 129..255 are treated as 128!
  316                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 181; extern unsigned char __fastcall random( unsigned char limit<acc> );
  317                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 184; // *************
  318                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 185; // Overlay Execution
  319                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 186; // *************
  320                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 188; extern unsigned char __fastcall __macro cd_execoverlay( unsigned char ovl_index<acc> );
  321                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 191; // *************
  322                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 192; // Functions that are only optionally available if configured in your hucc-config.inc
  323                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 193; // *************
  324                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 195; extern unsigned int __fastcall __macro joybuf( unsigned char which<acc> );
  325                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 196; extern unsigned int __fastcall __macro get_joy_events( unsigned char which<acc> );
  326                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 197; extern void __fastcall __macro clear_joy_events( unsigned char mask<acc> );
  327                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 200; // *************
  328                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 201; // Functions that are only implemented in the TGEMU emulator for unit-testing
  329                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 202; // the compiler, and which should never be used in normal HuCC projects ...
  330                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 203; // *************
  331                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 205; extern void __fastcall dump_screen( void );
  332                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 206; extern void __fastcall abort( void );
  333                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 207; extern void __fastcall exit( int value<acc> );
  334                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 209; extern unsigned char __fastcall __builtin_ffs( unsigned int value<__temp> );
  335                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 211; #endif // __HUCC__
  336                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 213; #endif // _hucc_baselib_h
  337                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 35; #include "hucc-gfx.h"
  338                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 1; #ifndef _hucc_gfx_h
  339                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 2; #define _hucc_gfx_h
  340                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 4; /****************************************************************************
  341                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 5; ; ***************************************************************************
  342                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 6; ;
  343                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 7; ; huc-gfx.h
  344                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 8; ;
  345                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 9; ; Based on the original HuC and MagicKit functions by David Michel and the
  346                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 10; ; other original HuC developers.
  347                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 11; ;
  348                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 12; ; Modifications copyright John Brandwood 2024.
  349                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 13; ;
  350                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 14; ; Distributed under the Boost Software License, Version 1.0.
  351                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 15; ; (See accompanying file LICENSE_1_0.txt or copy at
  352                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 16; ;  http://www.boost.org/LICENSE_1_0.txt)
  353                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 17; ;
  354                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 18; ; ***************************************************************************
  355                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 19; ; **************************************************************************/
  356                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 21; // *************
  357                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 22; // Screen defines ...
  358                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 23; // *************
  359                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 25; #define	SCR_SIZE_32x32	0
  360                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 26; #define	SCR_SIZE_64x32	1
  361                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 27; #define	SCR_SIZE_128x32	2
  362                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 28; #define	SCR_SIZE_32x64	4
  363                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 29; #define	SCR_SIZE_64x64	5
  364                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 30; #define	SCR_SIZE_128x64	6
  365                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 32; #define	XRES_SHARP	0
  366                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 33; #define	XRES_SOFT	4
  367                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 34; #define	XRES_KEEP	128
  368                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 36; #define VPC_WIN_A	0x00
  369                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 37; #define VPC_WIN_B	0x01
  370                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 38; #define	VPC_WIN_AB	0x02
  371                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 39; #define	VPC_WIN_NONE	0x03
  372                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 40; #define	VPC_NORM	0x00
  373                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 41; #define	VPC_SPR		0x04
  374                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 42; #define	VPC_INV_SPR	0x08
  375                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 43; #define VDC1_ON		0x01
  376                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 44; #define	VDC1_OFF	0x00
  377                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 45; #define VDC2_ON		0x02
  378                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 46; #define	VDC2_OFF	0x00
  379                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 47; #define VDC_ON		0x03
  380                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 48; #define	VDC_OFF		0x00
  381                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 50; // *************
  382                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 51; // Functions in hucc-gfx.asm ...
  383                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 52; // *************
  384                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 54; #ifdef __HUCC__
  385                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 56; #asmdef	HUCC_USES_GFX 1
  386               0001     	HUCC_USES_GFX = 1
  387                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 58; // *************
  388                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 59; // Color and Palette Functions
  389                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 60; // *************
  390                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 62; extern void __fastcall clear_palette( void );
  391                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 64; extern void __fastcall __nop set_color( unsigned int index<VCE_CTA>, unsigned int value<VCE_CTW> );
  392                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 65; extern void __fastcall set_color_rgb( unsigned int index<VCE_CTA>, unsigned char r<_al>, unsigned char g<_ah>, unsigned char b<acc> );
  393                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 66; extern unsigned int __fastcall __macro get_color( unsigned int index<VCE_CTA> );
  394                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 68; extern void __fastcall load_palette( unsigned char palette<_al>, unsigned char __far *data<_bp_bank:_bp>, unsigned char num_palettes<_ah> );
  395                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 69; extern void __fastcall far_load_palette( unsigned char palette<_al>, unsigned char num_palettes<_ah> );
  396                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 71; extern void __fastcall read_palette( unsigned char palette<_al>, unsigned char num_palettes<_ah>, unsigned int *destination<_di> );
  397                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 73; extern void __fastcall __macro fade_to_black( unsigned int __far *from<_bp_bank:_bp>, unsigned int *destination<_di>, unsigned char num_colors<_al>, unsigned char value_to_sub<_ah> );
  398                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 74; extern void __fastcall __macro fade_to_white( unsigned int __far *from<_bp_bank:_bp>, unsigned int *destination<_di>, unsigned char num_colors<_al>, unsigned char value_to_add<_ah> );
  399                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 75; extern void __fastcall __macro cross_fade_to( unsigned int __far *from<_bp_bank:_bp>, unsigned int *destination<_di>, unsigned char num_colors<_al>, unsigned char which_component<_ah> );
  400                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 77; extern void __fastcall __macro far_fade_to_black( unsigned int *destination<_di>, unsigned char num_colors<_al>, unsigned char value_to_sub<_ah> );
  401                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 78; extern void __fastcall __macro far_fade_to_white( unsigned int *destination<_di>, unsigned char num_colors<_al>, unsigned char value_to_add<_ah> );
  402                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 79; extern void __fastcall __macro far_cross_fade_to( unsigned int *destination<_di>, unsigned char num_colors<_al>, unsigned char which_component<_ah> );
  403                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 83; // *************
  404                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 84; // Video Functions
  405                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 85; // *************
  406                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 87; extern void __fastcall init_240x208( void );
  407                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 88; extern void __fastcall init_256x224( void );
  408                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 90; extern void __fastcall vsync( void );
  409                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 91; extern void __fastcall vsync( unsigned char count<_al> );
  410                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 93; extern void __fastcall disp_on( void );
  411                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 94; extern void __fastcall disp_off( void );
  412                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 96; extern void __fastcall set_screen_size( unsigned char value<_al> );
  413                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 98; extern void __fastcall set_xres( unsigned int x_pixels<_ax>, unsigned char blur_flag<_bl> );
  414                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 100; extern void __fastcall cls( void );
  415                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 101; extern void __fastcall cls( unsigned int tile<acc> );
  416                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 103; extern unsigned int __fastcall __macro vram_addr( unsigned char bat_x<_al>, unsigned char bat_y<_ah> );
  417                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 104; extern unsigned int __fastcall __macro get_vram( unsigned int address<_di> );
  418                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 105; extern void __fastcall __macro put_vram( unsigned int address<_di>, unsigned int data<acc> );
  419                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 107; extern void __fastcall __macro load_vram( unsigned int vram<_di>, unsigned char __far *data<_bp_bank:_bp>, unsigned int num_words<_ax> );
  420                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 108; extern void __fastcall __macro far_load_vram( unsigned int vram<_di>,  unsigned int num_words<_ax> );
  421                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 110; extern void __fastcall load_bat( unsigned int vram<_di>, unsigned char __far *data<_bp_bank:_bp>, unsigned char tiles_w<_al>, unsigned char tiles_h<_ah> );
  422                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 111; extern void __fastcall far_load_bat( unsigned int vram<_di>, unsigned char tiles_w<_al>, unsigned char tiles_h<_ah> );
  423                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 113; extern void __fastcall __macro load_sprites( unsigned int vram<_di>, unsigned char __far *data<_bp_bank:_bp>, unsigned int num_groups<acc> );
  424                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 114; extern void __fastcall __macro far_load_sprites( unsigned int vram<_di>, unsigned int num_groups<acc> );
  425                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 116; extern void __fastcall vram2vram( unsigned int vram_dst<_ax>, unsigned int vram_src<_bx>, unsigned int word_len<_cx> );
  426                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 119; // *************
  427                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 120; // SuperGRAFX Video Functions
  428                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 121; // *************
  429                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 123; extern void __fastcall __nop vpc_set_ctl( unsigned int bits<VPC_CR> );
  430                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 124; extern void __fastcall __nop vpc_set_win1( unsigned int width<VPC_WINDOW1> );
  431                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 125; extern void __fastcall __nop vpc_set_win2( unsigned int width<VPC_WINDOW2> );
  432                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 127; extern void __fastcall sgx_set_screen_size( unsigned char value<_al> );
  433                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 129; extern void __fastcall sgx_set_xres( unsigned int x_pixels<_ax>, unsigned char blur_flag<_bl> );
  434                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 131; extern void __fastcall sgx_cls( void );
  435                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 132; extern void __fastcall sgx_cls( unsigned int tile<acc> );
  436                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 134; extern unsigned int __fastcall __macro sgx_vram_addr( unsigned char bat_x<_al>, unsigned char bat_y<_ah> );
  437                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 135; extern unsigned int __fastcall __macro sgx_get_vram( unsigned int address<_di> );
  438                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 136; extern void __fastcall __macro sgx_put_vram( unsigned int address<_di>, unsigned int data<acc> );
  439                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 138; extern void __fastcall __macro sgx_load_vram( unsigned int vram<_di>, unsigned char __far *data<_bp_bank:_bp>, unsigned int num_words<_ax> );
  440                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 139; extern void __fastcall __macro sgx_far_load_vram( unsigned int vram<_di>, unsigned int num_words<_ax> );
  441                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 141; extern void __fastcall sgx_load_bat( unsigned int vram<_di>, unsigned char __far *data<_bp_bank:_bp>, unsigned char tiles_w<_al>, unsigned char tiles_h<_ah> );
  442                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 142; extern void __fastcall sgx_far_load_bat( unsigned int vram<_di>, unsigned char tiles_w<_al>, unsigned char tiles_h<_ah> );
  443                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 144; extern void __fastcall __macro sgx_load_sprites( unsigned int vram<_di>, unsigned char __far *data<_bp_bank:_bp>, unsigned int num_groups<acc> );
  444                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 145; extern void __fastcall __macro sgx_far_load_sprites( unsigned int vram<_di>, unsigned int num_groups<acc> );
  445                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 147; extern void __fastcall sgx_vram2vram( unsigned int vram_dst<_ax>, unsigned int vram_src<_bx>, unsigned int word_len<_cx> );
  446                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 150; // *************
  447                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 151; // Font Functions
  448                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 152; // *************
  449                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 154; extern void __fastcall set_font_addr( unsigned int vram<acc> );
  450                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 155; extern void __fastcall set_font_pal( unsigned char palette<acc> );
  451                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 157; extern void __fastcall load_font( unsigned char __far *font<_bp_bank:_bp>, unsigned char count<_al>, unsigned int vram<acc> );
  452                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 158; extern void __fastcall far_load_font( unsigned char count<_al>, unsigned int vram<acc> );
  453                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 160; extern void __fastcall __nop set_font_color( unsigned char foreground<monofont_fg>, unsigned char background<monofont_bg> );
  454                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 161; extern void __fastcall __macro load_default_font( void );
  455                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 164; // *************
  456                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 165; // SuperGRAFX Font Functions
  457                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 166; // *************
  458                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 168; extern void __fastcall sgx_set_font_addr( unsigned int vram<acc> );
  459                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 169; extern void __fastcall sgx_set_font_pal( unsigned char palette<acc> );
  460                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 171; extern void __fastcall sgx_load_font( char __far *font<_bp_bank:_bp>, unsigned char count<_al>, unsigned int vram<acc> );
  461                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 172; extern void __fastcall sgx_far_load_font( unsigned char count<_al>, unsigned int vram<acc> );
  462                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 174; extern void __fastcall __macro sgx_load_default_font( void );
  463                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 177; // *************
  464                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 178; // Deprecated functions ...
  465                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 179; // *************
  466                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 181; extern void __fastcall __macro set_xres( unsigned int x_pixels<_ax> );
  467                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 182; extern void __fastcall __macro sgx_set_xres( unsigned int x_pixels<_ax> );
  468                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 184; extern void __fastcall load_background( unsigned char __far *tiles<_bp_bank:_bp>, unsigned char __far *palettes<__fbank:__fptr>, unsigned char __far *bat<_cl:_bx>, unsigned char w<_dl>, unsigned char h<_dh> );
  469                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 186; extern void __fastcall __macro set_bgpal( unsigned char palette<_al>, unsigned char __far *data<_bp_bank:_bp> );
  470                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 187; extern void __fastcall __macro set_bgpal( unsigned char palette<_al>, unsigned char __far *data<_bp_bank:_bp>, unsigned int num_palettes<_ah> );
  471                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 188; extern void __fastcall __macro set_sprpal( unsigned char palette<_al>, unsigned char __far *data<_bp_bank:_bp> );
  472                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 189; extern void __fastcall __macro set_sprpal( unsigned char palette<_al>, unsigned char __far *data<_bp_bank:_bp>, unsigned int num_palettes<_ah> );
  473                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 191; extern void __fastcall load_font( char __far *font<_bp_bank:_bp>, unsigned char count<_al> );
  474                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 193; extern void __fastcall put_string( unsigned char *string<_bp>, unsigned char bat_x<_dil>, unsigned char bat_y<_dih> );
  475                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 195; extern void __fastcall put_char( unsigned char digit<_bl>, unsigned char bat_x<_dil>, unsigned char bat_y<_dih> );
  476                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 196; extern void __fastcall put_digit( unsigned char digit<_bl>, unsigned char bat_x<_dil>, unsigned char bat_y<_dih> );
  477                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 197; extern void __fastcall put_hex( unsigned int number<_bx>, unsigned char length<_cl>, unsigned char bat_x<_dil>, unsigned char bat_y<_dih> );
  478                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 198; extern void __fastcall put_number( unsigned int number<_bx>, unsigned char length<_cl>, unsigned char bat_x<_dil>, unsigned char bat_y<_dih> );
  479                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 199; extern void __fastcall put_raw( unsigned int data<_bx>, unsigned char bat_x<_dil>, unsigned char bat_y<_dih> );
  480                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 201; #endif // __HUCC__
  481                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 203; #endif // _hucc_gfx_h
  482                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 36; #include "hucc-string.h"
  483                        		.dbg	line,	"..\..\..\include\hucc\hucc-string.h", 1; #ifndef _hucc_string_h
  484                        		.dbg	line,	"..\..\..\include\hucc\hucc-string.h", 2; #define _hucc_string_h
  485                        		.dbg	line,	"..\..\..\include\hucc\hucc-string.h", 4; /****************************************************************************
  486                        		.dbg	line,	"..\..\..\include\hucc\hucc-string.h", 5; ; ***************************************************************************
  487                        		.dbg	line,	"..\..\..\include\hucc\hucc-string.h", 6; ;
  488                        		.dbg	line,	"..\..\..\include\hucc\hucc-string.h", 7; ; hucc-string.h
  489                        		.dbg	line,	"..\..\..\include\hucc\hucc-string.h", 8; ;
  490                        		.dbg	line,	"..\..\..\include\hucc\hucc-string.h", 9; ; Not-quite-standard, but fast, replacements for <string.h>.
  491                        		.dbg	line,	"..\..\..\include\hucc\hucc-string.h", 10; ;
  492                        		.dbg	line,	"..\..\..\include\hucc\hucc-string.h", 11; ; Copyright John Brandwood 2024.
  493                        		.dbg	line,	"..\..\..\include\hucc\hucc-string.h", 12; ;
  494                        		.dbg	line,	"..\..\..\include\hucc\hucc-string.h", 13; ; Distributed under the Boost Software License, Version 1.0.
  495                        		.dbg	line,	"..\..\..\include\hucc\hucc-string.h", 14; ; (See accompanying file LICENSE_1_0.txt or copy at
  496                        		.dbg	line,	"..\..\..\include\hucc\hucc-string.h", 15; ;  http://www.boost.org/LICENSE_1_0.txt)
  497                        		.dbg	line,	"..\..\..\include\hucc\hucc-string.h", 16; ;
  498                        		.dbg	line,	"..\..\..\include\hucc\hucc-string.h", 17; ; ***************************************************************************
  499                        		.dbg	line,	"..\..\..\include\hucc\hucc-string.h", 18; ; ***************************************************************************
  500                        		.dbg	line,	"..\..\..\include\hucc\hucc-string.h", 19; ;
  501                        		.dbg	line,	"..\..\..\include\hucc\hucc-string.h", 20; ; !!! WARNING : non-standard return values !!!
  502                        		.dbg	line,	"..\..\..\include\hucc\hucc-string.h", 21; ;
  503                        		.dbg	line,	"..\..\..\include\hucc\hucc-string.h", 22; ; Strings are limited to a maximum of 255 characters (+ the terminator)!
  504                        		.dbg	line,	"..\..\..\include\hucc\hucc-string.h", 23; ;
  505                        		.dbg	line,	"..\..\..\include\hucc\hucc-string.h", 24; ; The memcpy(), strcpy() and strcat() functions do NOT return the destination
  506                        		.dbg	line,	"..\..\..\include\hucc\hucc-string.h", 25; ; address, and they are declared "void" to check that the value is not used.
  507                        		.dbg	line,	"..\..\..\include\hucc\hucc-string.h", 26; ;
  508                        		.dbg	line,	"..\..\..\include\hucc\hucc-string.h", 27; ; mempcpy() is provided which returns the end address instead of the starting
  509                        		.dbg	line,	"..\..\..\include\hucc\hucc-string.h", 28; ; address, because this is typically more useful.
  510                        		.dbg	line,	"..\..\..\include\hucc\hucc-string.h", 29; ;
  511                        		.dbg	line,	"..\..\..\include\hucc\hucc-string.h", 30; ; Please note that both memcpy() and memset() are implemented using a TII for
  512                        		.dbg	line,	"..\..\..\include\hucc\hucc-string.h", 31; ; speed, and so the length should be < 16 bytes if used in time-critical bits
  513                        		.dbg	line,	"..\..\..\include\hucc\hucc-string.h", 32; ; of code (such as when using a split screen) because they delay interrupts.
  514                        		.dbg	line,	"..\..\..\include\hucc\hucc-string.h", 33; ;
  515                        		.dbg	line,	"..\..\..\include\hucc\hucc-string.h", 34; ; strncpy() and strncat() are not provided, because strncpy() was not created
  516                        		.dbg	line,	"..\..\..\include\hucc\hucc-string.h", 35; ; for the purpose of avoiding string overruns, and strncat() is just a poorly
  517                        		.dbg	line,	"..\..\..\include\hucc\hucc-string.h", 36; ; designed function IMHO.
  518                        		.dbg	line,	"..\..\..\include\hucc\hucc-string.h", 37; ;
  519                        		.dbg	line,	"..\..\..\include\hucc\hucc-string.h", 38; ; POSIX strlcpy() and strlcat() are provided instead, but once again they are
  520                        		.dbg	line,	"..\..\..\include\hucc\hucc-string.h", 39; ; slightly non-standard in that the return value when there is an overflow is
  521                        		.dbg	line,	"..\..\..\include\hucc\hucc-string.h", 40; ; the buffer size (so that the overflow can be detected), instead of the full
  522                        		.dbg	line,	"..\..\..\include\hucc\hucc-string.h", 41; ; size of the destination string that was too big to fit in the buffer.
  523                        		.dbg	line,	"..\..\..\include\hucc\hucc-string.h", 42; ;
  524                        		.dbg	line,	"..\..\..\include\hucc\hucc-string.h", 43; ; ***************************************************************************
  525                        		.dbg	line,	"..\..\..\include\hucc\hucc-string.h", 44; ; **************************************************************************/
  526                        		.dbg	line,	"..\..\..\include\hucc\hucc-string.h", 46; // *************
  527                        		.dbg	line,	"..\..\..\include\hucc\hucc-string.h", 47; // Functions in hucc-string.asm ...
  528                        		.dbg	line,	"..\..\..\include\hucc\hucc-string.h", 48; // *************
  529                        		.dbg	line,	"..\..\..\include\hucc\hucc-string.h", 50; #ifdef __HUCC__
  530                        		.dbg	line,	"..\..\..\include\hucc\hucc-string.h", 52; #asmdef	HUCC_USES_STRING 1
  531               0001     	HUCC_USES_STRING = 1
  532                        		.dbg	line,	"..\..\..\include\hucc\hucc-string.h", 54; extern void __fastcall strcpy( char *destination<_di>, char *source<_bp> );
  533                        		.dbg	line,	"..\..\..\include\hucc\hucc-string.h", 55; extern void __fastcall strcat( char *destination<_di>, char *source<_bp> );
  534                        		.dbg	line,	"..\..\..\include\hucc\hucc-string.h", 57; extern unsigned int __fastcall strlen( char *source<_bp> );
  535                        		.dbg	line,	"..\..\..\include\hucc\hucc-string.h", 59; extern unsigned int __fastcall strlcpy( char *destination<_di>, char *source<_bp>, unsigned char size<acc> );
  536                        		.dbg	line,	"..\..\..\include\hucc\hucc-string.h", 60; extern unsigned int __fastcall strlcat( char *destination<_di>, char *source<_bp>, unsigned char size<acc> );
  537                        		.dbg	line,	"..\..\..\include\hucc\hucc-string.h", 62; extern void __fastcall memcpy( unsigned char *destination<ram_tii_dst>, unsigned char *source<ram_tii_src>, unsigned int count<acc> );
  538                        		.dbg	line,	"..\..\..\include\hucc\hucc-string.h", 63; extern void __fastcall farmemcpy( unsigned char *destination<ram_tii_dst>, unsigned char __far *source<_bp_bank:ram_tii_src>, unsigned int count<acc> );
  539                        		.dbg	line,	"..\..\..\include\hucc\hucc-string.h", 64; extern void __fastcall far_memcpy( unsigned char *destination<ram_tii_dst>, unsigned int count<acc> );
  540                        		.dbg	line,	"..\..\..\include\hucc\hucc-string.h", 66; extern unsigned char * __fastcall mempcpy( unsigned char *destination<ram_tii_dst>, unsigned char *source<ram_tii_src>, unsigned int count<acc> );
  541                        		.dbg	line,	"..\..\..\include\hucc\hucc-string.h", 67; extern unsigned char * __fastcall farmempcpy( unsigned char *destination<ram_tii_dst>, unsigned char __far *source<_bp_bank:ram_tii_src>, unsigned int count<acc> );
  542                        		.dbg	line,	"..\..\..\include\hucc\hucc-string.h", 68; extern unsigned char * __fastcall far_mempcpy( unsigned char *destination<ram_tii_dst>, unsigned int count<acc> );
  543                        		.dbg	line,	"..\..\..\include\hucc\hucc-string.h", 70; extern void __fastcall memset( unsigned char *destination<ram_tii_src>, unsigned char value<_al>, unsigned int count<acc> );
  544                        		.dbg	line,	"..\..\..\include\hucc\hucc-string.h", 72; //  0 	if strings are equal
  545                        		.dbg	line,	"..\..\..\include\hucc\hucc-string.h", 73; //  1 	if the first non-matching character in string1 > string2 (in ASCII).
  546                        		.dbg	line,	"..\..\..\include\hucc\hucc-string.h", 74; // -1 	if the first non-matching character in string1 < string2 (in ASCII).
  547                        		.dbg	line,	"..\..\..\include\hucc\hucc-string.h", 76; extern int __fastcall strcmp( char *string1<_di>, char *string2<_bp> );
  548                        		.dbg	line,	"..\..\..\include\hucc\hucc-string.h", 77; extern int __fastcall strncmp( char *string1<_di>, char *string2<_bp>, unsigned int count<_ax> );
  549                        		.dbg	line,	"..\..\..\include\hucc\hucc-string.h", 79; extern int __fastcall __macro memcmp( unsigned char *string1<_di>, unsigned char *string2<_bp>, unsigned int count<acc> );
  550                        		.dbg	line,	"..\..\..\include\hucc\hucc-string.h", 80; extern int __fastcall farmemcmp( unsigned char *string1<_di>, unsigned char __far *string2<_bp_bank:_bp>, unsigned int count<acc> );
  551                        		.dbg	line,	"..\..\..\include\hucc\hucc-string.h", 81; extern int __fastcall far_memcmp( unsigned char *string1<_di>, unsigned int count<acc> );
  552                        		.dbg	line,	"..\..\..\include\hucc\hucc-string.h", 83; #endif // __HUCC__
  553                        		.dbg	line,	"..\..\..\include\hucc\hucc-string.h", 85; #endif // _hucc_string_h
  554                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 37; #include "hucc-old-scroll.h"
  555                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-scroll.h", 1; #ifndef _hucc_old_scroll_h
  556                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-scroll.h", 2; #define _hucc_old_scroll_h
  557                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-scroll.h", 4; /****************************************************************************
  558                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-scroll.h", 5; ; ***************************************************************************
  559                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-scroll.h", 6; ;
  560                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-scroll.h", 7; ; hucc-old-scroll.h
  561                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-scroll.h", 8; ;
  562                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-scroll.h", 9; ; Based on the original HuC and MagicKit functions by David Michel and the
  563                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-scroll.h", 10; ; other original HuC developers.
  564                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-scroll.h", 11; ;
  565                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-scroll.h", 12; ; Modifications copyright John Brandwood 2024.
  566                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-scroll.h", 13; ;
  567                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-scroll.h", 14; ; Distributed under the Boost Software License, Version 1.0.
  568                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-scroll.h", 15; ; (See accompanying file LICENSE_1_0.txt or copy at
  569                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-scroll.h", 16; ;  http://www.boost.org/LICENSE_1_0.txt)
  570                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-scroll.h", 17; ;
  571                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-scroll.h", 18; ; ***************************************************************************
  572                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-scroll.h", 19; ; ***************************************************************************
  573                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-scroll.h", 20; ;
  574                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-scroll.h", 21; ; HuC's old scrolling library is provided for use with existing HuC projects,
  575                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-scroll.h", 22; ; but it should preferably be avoided in new projects because it is slow and
  576                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-scroll.h", 23; ; forever limited by its choice to handle gaps between areas, and sorting.
  577                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-scroll.h", 24; ;
  578                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-scroll.h", 25; ; HuCC's new scrolling library puts the responibility for defining both gaps
  579                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-scroll.h", 26; ; and the display order into the project's hands, but in return it runs much
  580                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-scroll.h", 27; ; faster, using less than 1/6 of the processing time in VBLANK, and far less
  581                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-scroll.h", 28; ; time in the RCR interrputs themselves. It also supports the 2nd SuperGRAFX
  582                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-scroll.h", 29; ; screen layer, which HuC's old scrolling library ignores.
  583                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-scroll.h", 30; ;
  584                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-scroll.h", 31; ; ***************************************************************************
  585                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-scroll.h", 32; ; **************************************************************************/
  586                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-scroll.h", 34; // *************
  587                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-scroll.h", 35; // Functions in hucc-old-scroll.asm ...
  588                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-scroll.h", 36; // *************
  589                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-scroll.h", 38; #ifdef __HUCC__
  590                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-scroll.h", 40; #asmdef	HUCC_USES_OLD_SCROLL 1
  591               0001     	HUCC_USES_OLD_SCROLL = 1
  592                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-scroll.h", 42; extern void __fastcall scroll( unsigned char num<_al>, unsigned int x<_cx>, unsigned int y<_dx>, unsigned char top<_ah>, unsigned char bottom<_bl>, unsigned char disp<acc> );
  593                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-scroll.h", 43; extern void __fastcall scroll_disable( unsigned char num<acc> );
  594                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-scroll.h", 45; #endif // __HUCC__
  595                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-scroll.h", 47; #endif // _hucc_old_scroll_h
  596                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 38; #include "hucc-old-spr.h"
  597                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-spr.h", 1; #ifndef _hucc_old_spr_h
  598                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-spr.h", 2; #define _hucc_old_spr_h
  599                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-spr.h", 4; /****************************************************************************
  600                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-spr.h", 5; ; ***************************************************************************
  601                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-spr.h", 6; ;
  602                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-spr.h", 7; ; hucc-old-spr.h
  603                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-spr.h", 8; ;
  604                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-spr.h", 9; ; Based on the original HuC and MagicKit functions by David Michel and the
  605                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-spr.h", 10; ; other original HuC developers.
  606                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-spr.h", 11; ;
  607                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-spr.h", 12; ; Modifications copyright John Brandwood 2024.
  608                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-spr.h", 13; ;
  609                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-spr.h", 14; ; Distributed under the Boost Software License, Version 1.0.
  610                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-spr.h", 15; ; (See accompanying file LICENSE_1_0.txt or copy at
  611                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-spr.h", 16; ;  http://www.boost.org/LICENSE_1_0.txt)
  612                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-spr.h", 17; ;
  613                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-spr.h", 18; ; ***************************************************************************
  614                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-spr.h", 19; ; **************************************************************************/
  615                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-spr.h", 21; // *************
  616                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-spr.h", 22; // Sprite defines ...
  617                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-spr.h", 23; // *************
  618                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-spr.h", 25; #define FLIP_X_MASK 0x08
  619                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-spr.h", 26; #define FLIP_Y_MASK 0x80
  620                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-spr.h", 27; #define FLIP_MAS    0x88
  621                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-spr.h", 28; #define SIZE_MAS    0x31
  622                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-spr.h", 30; #define NO_FLIP     0x00
  623                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-spr.h", 31; #define NO_FLIP_X   0x00
  624                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-spr.h", 32; #define NO_FLIP_Y   0x00
  625                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-spr.h", 33; #define FLIP_X      0x08
  626                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-spr.h", 34; #define FLIP_Y      0x80
  627                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-spr.h", 35; #define SZ_16x16    0x00
  628                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-spr.h", 36; #define SZ_16x32    0x10
  629                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-spr.h", 37; #define SZ_16x64    0x30
  630                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-spr.h", 38; #define SZ_32x16    0x01
  631                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-spr.h", 39; #define SZ_32x32    0x11
  632                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-spr.h", 40; #define	SZ_32x64    0x31
  633                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-spr.h", 42; // *************
  634                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-spr.h", 43; // Functions in hucc-old-spr.asm ...
  635                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-spr.h", 44; // *************
  636                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-spr.h", 46; #ifdef __HUCC__
  637                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-spr.h", 48; #asmdef	HUCC_USES_OLD_SPR 1
  638               0001     	HUCC_USES_OLD_SPR = 1
  639                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-spr.h", 50; extern void __fastcall init_satb( void );
  640                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-spr.h", 51; extern void __fastcall reset_satb( void );
  641                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-spr.h", 52; extern void __fastcall satb_update( void );
  642                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-spr.h", 53; extern void __fastcall spr_set( unsigned char num<acc> );
  643                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-spr.h", 54; extern void __fastcall spr_hide( void );
  644                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-spr.h", 55; extern void __fastcall spr_show( void );
  645                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-spr.h", 56; extern void __fastcall spr_x( unsigned int value<acc> );
  646                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-spr.h", 57; extern void __fastcall spr_y( unsigned int value<acc> );
  647                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-spr.h", 58; extern void __fastcall spr_pattern( unsigned int vaddr<acc> );
  648                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-spr.h", 59; extern void __fastcall spr_ctrl( unsigned char mask<_al>, unsigned char value<acc> );
  649                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-spr.h", 60; extern void __fastcall spr_pal( unsigned char palette<acc> );
  650                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-spr.h", 61; extern void __fastcall spr_pri( unsigned char priority<acc> );
  651                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-spr.h", 63; extern unsigned int __fastcall spr_get_x( void );
  652                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-spr.h", 64; extern unsigned int __fastcall spr_get_y( void );
  653                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-spr.h", 66; extern void __fastcall sgx_init_satb( void );
  654                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-spr.h", 67; extern void __fastcall sgx_reset_satb( void );
  655                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-spr.h", 68; extern void __fastcall sgx_satb_update( void );
  656                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-spr.h", 69; extern void __fastcall sgx_spr_set( unsigned char num<acc> );
  657                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-spr.h", 70; extern void __fastcall sgx_spr_hide( void );
  658                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-spr.h", 71; extern void __fastcall sgx_spr_show( void );
  659                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-spr.h", 72; extern void __fastcall sgx_spr_x( unsigned int value<acc> );
  660                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-spr.h", 73; extern void __fastcall sgx_spr_y( unsigned int value<acc> );
  661                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-spr.h", 74; extern void __fastcall sgx_spr_pattern( unsigned int vaddr<acc> );
  662                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-spr.h", 75; extern void __fastcall sgx_spr_ctrl( unsigned char mask<_al>, unsigned char value<acc> );
  663                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-spr.h", 76; extern void __fastcall sgx_spr_pal( unsigned char palette<acc> );
  664                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-spr.h", 77; extern void __fastcall sgx_spr_pri( unsigned char priority<acc> );
  665                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-spr.h", 79; extern unsigned int __fastcall sgx_spr_get_x( void );
  666                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-spr.h", 80; extern unsigned int __fastcall sgx_spr_get_y( void );
  667                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-spr.h", 82; #endif // __HUCC__
  668                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-spr.h", 84; #endif // _hucc_old_spr_h
  669                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 39; #include "hucc-old-map.h"
  670                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-map.h", 1; #ifndef _hucc_old_map_h
  671                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-map.h", 2; #define _hucc_old_map_h
  672                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-map.h", 4; /****************************************************************************
  673                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-map.h", 5; ; ***************************************************************************
  674                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-map.h", 6; ;
  675                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-map.h", 7; ; hucc-old-map.h
  676                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-map.h", 8; ;
  677                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-map.h", 9; ; Based on the original HuC and MagicKit functions by David Michel and the
  678                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-map.h", 10; ; other original HuC developers.
  679                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-map.h", 11; ;
  680                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-map.h", 12; ; Modifications copyright John Brandwood 2024.
  681                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-map.h", 13; ;
  682                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-map.h", 14; ; Distributed under the Boost Software License, Version 1.0.
  683                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-map.h", 15; ; (See accompanying file LICENSE_1_0.txt or copy at
  684                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-map.h", 16; ;  http://www.boost.org/LICENSE_1_0.txt)
  685                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-map.h", 17; ;
  686                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-map.h", 18; ; ***************************************************************************
  687                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-map.h", 19; ; **************************************************************************/
  688                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-map.h", 21; // *************
  689                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-map.h", 22; // Functions in hucc-old-map.asm ...
  690                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-map.h", 23; // *************
  691                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-map.h", 25; #ifdef __HUCC__
  692                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-map.h", 27; #asmdef	HUCC_USES_OLD_MAP 1
  693               0001     	HUCC_USES_OLD_MAP = 1
  694                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-map.h", 29; extern void __fastcall set_tile_address( unsigned int vram<_di> );
  695                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-map.h", 30; extern void __fastcall sgx_set_tile_address( unsigned int vram<_di> );
  696                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-map.h", 32; extern void __fastcall __nop set_tile_data( unsigned char __far *tiles<vdc_tile_bank:vdc_tile_addr>, unsigned char num_tiles<vdc_num_tiles>, unsigned char __far *palette_table<vdc_attr_bank:vdc_attr_addr>, unsigned char tile_type<vdc_tile_type> );
  697                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-map.h", 33; extern void __fastcall __nop sgx_set_tile_data( unsigned char __far *tiles<sgx_tile_bank:sgx_tile_addr>, unsigned char num_tiles<sgx_num_tiles>, unsigned char __far *palette_table<sgx_attr_bank:sgx_attr_addr>, unsigned char tile_type<sgx_tile_type> );
  698                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-map.h", 35; extern void __fastcall __nop set_far_tile_data( unsigned char tile_bank<vdc_tile_bank>, unsigned char *tile_addr<vdc_tile_addr>, unsigned char num_tiles<vdc_num_tiles>, unsigned char palette_table_bank<vdc_attr_bank>, unsigned char *palette_table_addr<vdc_attr_addr>, unsigned char tile_type<vdc_tile_type> );
  699                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-map.h", 36; extern void __fastcall __nop sgx_set_far_tile_data( unsigned char tile_bank<sgx_tile_bank>, unsigned char *tile_addr<sgx_tile_addr>, unsigned char num_tiles<sgx_num_tiles>, unsigned char palette_table_bank<sgx_attr_bank>, unsigned char *palette_table_addr<sgx_attr_addr>, unsigned char tile_type<sgx_tile_type> );
  700                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-map.h", 38; extern void __fastcall __nop set_map_data( unsigned char __far *map<vdc_map_bank:vdc_map_addr>, unsigned char w<vdc_map_width>, unsigned char h<vdc_map_height> );
  701                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-map.h", 39; extern void __fastcall __nop sgx_set_map_data( unsigned char __far *map<sgx_map_bank:sgx_map_addr>, unsigned char w<sgx_map_width>, unsigned char h<sgx_map_height> );
  702                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-map.h", 41; extern void __fastcall __nop set_far_map_data( unsigned char map_bank<vdc_map_bank>, unsigned char *map_addr<vdc_map_addr>, unsigned char w<vdc_map_width>, unsigned char h<vdc_map_height> );
  703                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-map.h", 42; extern void __fastcall __nop sgx_set_far_map_data( unsigned char map_bank<vdc_map_bank>, unsigned char *map_addr<vdc_map_addr>, unsigned char w<sgx_map_width>, unsigned char h<sgx_map_height> );
  704                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-map.h", 44; extern void __fastcall load_tile( unsigned int vram<_di> );
  705                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-map.h", 45; extern void __fastcall sgx_load_tile( unsigned int vram<_di> );
  706                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-map.h", 47; extern void __fastcall load_map( unsigned char bat_x<_al>, unsigned char bat_y<_ah>, int map_x<_bx>, int map_y<_dx>, unsigned char tiles_w<_cl>, unsigned char tiles_h<_ch> );
  707                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-map.h", 48; extern void __fastcall sgx_load_map( unsigned char bat_x<_al>, unsigned char bat_y<_ah>, int map_x<_bx>, int map_y<_dx>, unsigned char tiles_w<_cl>, unsigned char tiles_h<_ch> );
  708                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-map.h", 50; extern unsigned char __fastcall map_get_tile( unsigned char map_x<_bl>, unsigned char map_y<_bh> );
  709                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-map.h", 51; extern unsigned char __fastcall sgx_map_get_tile( unsigned char map_x<_bl>, unsigned char map_y<_bh> );
  710                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-map.h", 53; extern void __fastcall map_put_tile( unsigned char map_x<_bl>, unsigned char map_y<_bh>, unsigned char tile<_al> );
  711                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-map.h", 54; extern void __fastcall sgx_map_put_tile( unsigned char map_x<_bl>, unsigned char map_y<_bh>, unsigned char tile<_al> );
  712                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-map.h", 56; extern void __fastcall put_tile( unsigned char tile<_bl>, unsigned char bat_x<_al>, unsigned char bat_y<_ah> );
  713                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-map.h", 57; extern void __fastcall sgx_put_tile( unsigned char tile<_bl>, unsigned char bat_x<_al>, unsigned char bat_y<_ah> );
  714                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-map.h", 59; // Deprecated functions ...
  715                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-map.h", 61; extern void __fastcall set_tile_data( unsigned char *tile_ex<_di> );
  716                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-map.h", 63; extern void __fastcall __nop set_map_pals( unsigned char __far *palette_table<vdc_attr_bank:vdc_attr_addr> );
  717                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-map.h", 64; extern void __fastcall __nop set_map_tile_type( unsigned char tile_type<vdc_tile_type> );
  718                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-map.h", 66; extern void __fastcall __nop sgx_set_map_pals( unsigned char __far *palette_table<sgx_attr_bank:sgx_attr_addr> );
  719                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-map.h", 67; extern void __fastcall __nop sgx_set_map_tile_type( unsigned char tile_type<sgx_tile_type> );
  720                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-map.h", 69; extern void __fastcall set_map_tile_base( unsigned int vram<_di> );
  721                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-map.h", 70; extern void __fastcall sgx_set_map_tile_base( unsigned int vram<_di> );
  722                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-map.h", 72; #endif // __HUCC__
  723                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-map.h", 74; #endif // _hucc_old_map_h
  724                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 40; #include "hucc-old-line.h"
  725                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-line.h", 1; #ifndef _hucc_old_line_h
  726                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-line.h", 2; #define _hucc_old_line_h
  727                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-line.h", 4; /****************************************************************************
  728                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-line.h", 5; ; ***************************************************************************
  729                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-line.h", 6; ;
  730                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-line.h", 7; ; hucc-old-line.h
  731                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-line.h", 8; ;
  732                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-line.h", 9; ; Based on the original HuC and MagicKit functions by David Michel and the
  733                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-line.h", 10; ; other original HuC developers.
  734                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-line.h", 11; ;
  735                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-line.h", 12; ; Modifications copyright John Brandwood 2024.
  736                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-line.h", 13; ;
  737                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-line.h", 14; ; Distributed under the Boost Software License, Version 1.0.
  738                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-line.h", 15; ; (See accompanying file LICENSE_1_0.txt or copy at
  739                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-line.h", 16; ;  http://www.boost.org/LICENSE_1_0.txt)
  740                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-line.h", 17; ;
  741                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-line.h", 18; ; ***************************************************************************
  742                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-line.h", 19; ; **************************************************************************/
  743                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-line.h", 21; // *************
  744                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-line.h", 22; // Functions in hucc-old-line.asm ...
  745                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-line.h", 23; // *************
  746                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-line.h", 25; #ifdef __HUCC__
  747                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-line.h", 27; #asmdef	HUCC_USES_OLD_LINE 1
  748               0001     	HUCC_USES_OLD_LINE = 1
  749                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-line.h", 29; extern void __fastcall gfx_init( unsigned int start_vram_addr<_ax> );
  750                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-line.h", 30; extern void __fastcall gfx_clear( unsigned int start_vram_addr<_di> );
  751                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-line.h", 31; extern void __fastcall gfx_plot( unsigned int x<_gfx_x1>, unsigned int y<_gfx_y1>, char color<_gfx_color> );
  752                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-line.h", 32; extern void __fastcall gfx_line( unsigned int x1<_gfx_x1>, unsigned int y1<_gfx_y1>, unsigned int x2<_gfx_x2>, unsigned int y2<_gfx_y2>, unsigned char color<_gfx_color> );
  753                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-line.h", 34; #endif // __HUCC__
  754                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-line.h", 36; #endif // _hucc_old_line_h
  755                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 42; #endif // _hucc_legacy_h
  756                        		.dbg	line,	"main.c", 1; #include "huc.h"
  757                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 1; #ifndef _hucc_legacy_h
  758                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 2; #define _hucc_legacy_h
  759                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 4; /****************************************************************************
  760                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 5; ; ***************************************************************************
  761                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 6; ;
  762                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 7; ; huc.h
  763                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 8; ;
  764                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 9; ; HuCC wrapper file to include a default set of HuC-compatible functions.
  765                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 10; ;
  766                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 11; ; Copyright John Brandwood 2024.
  767                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 12; ;
  768                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 13; ; Distributed under the Boost Software License, Version 1.0.
  769                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 14; ; (See accompanying file LICENSE_1_0.txt or copy at
  770                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 15; ;  http://www.boost.org/LICENSE_1_0.txt)
  771                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 16; ;
  772                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 17; ; ***************************************************************************
  773                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 18; ; ***************************************************************************
  774                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 19; ;
  775                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 20; ; When the HuCC compiler is invoked with the "--legacy" option to compile old
  776                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 21; ; projects, then this "huc.h" file is automatically included.
  777                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 22; ;
  778                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 23; ; This file includes a set of the individual HuCC headers which correspond to
  779                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 24; ; HuC's built-in functions and MagicKit library.
  780                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 25; ;
  781                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 26; ; New HuCC projects should, preferably, include the specific headers that are
  782                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 27; ; needed, which will then allow them to replace parts of the standard library
  783                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 28; ; with newer functions, or they can just manually include this "huc.h" file.
  784                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 29; ;
  785                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 30; ; ***************************************************************************
  786                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 31; ; **************************************************************************/
  787                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 33; #include "hucc-systemcard.h"
  788                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 34; #include "hucc-baselib.h"
  789                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 35; #include "hucc-gfx.h"
  790                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 36; #include "hucc-string.h"
  791                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 37; #include "hucc-old-scroll.h"
  792                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 38; #include "hucc-old-spr.h"
  793                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 39; #include "hucc-old-map.h"
  794                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 40; #include "hucc-old-line.h"
  795                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 42; #endif // _hucc_legacy_h
  796                        		.dbg	line,	"main.c", 2; #include "hucc-scroll.h"
  797                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 1; #ifndef _hucc_scroll_h
  798                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 2; #define _hucc_scroll_h
  799                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 4; /****************************************************************************
  800                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 5; ; ***************************************************************************
  801                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 6; ;
  802                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 7; ; hucc-scroll.h
  803                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 8; ;
  804                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 9; ; Routines for a fast split-screen scrolling system.
  805                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 10; ;
  806                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 11; ; Copyright John Brandwood 2024.
  807                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 12; ;
  808                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 13; ; Distributed under the Boost Software License, Version 1.0.
  809                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 14; ; (See accompanying file LICENSE_1_0.txt or copy at
  810                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 15; ;  http://www.boost.org/LICENSE_1_0.txt)
  811                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 16; ;
  812                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 17; ; ***************************************************************************
  813                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 18; ; ***************************************************************************
  814                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 19; ;
  815                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 20; ; The maximum number of splits for each screen layer is set in your project's
  816                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 21; ; "hucc-config.inc" file, with the library having a limit of 128-per-layer.
  817                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 22; ;
  818                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 23; ; Your first active split must be defined to start at screen line 0, and then
  819                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 24; ; the rest of the active splits must be in increasing line order to match the
  820                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 25; ; way that the PC Engine displays the output image.
  821                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 26; ;
  822                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 27; ; You can have disabled splits interleaved with your active splits.
  823                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 28; ;
  824                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 29; ; Splits that are normally disabled can be used to create full screen effects
  825                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 30; ; such as bouncing the screen up and down by adding blank areas at the top or
  826                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 31; ; bottom of the screen, and then rapidly changing the height of those areas.
  827                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 32; ;
  828                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 33; ; ***************************************************************************
  829                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 34; ; **************************************************************************/
  830                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 36; // *************
  831                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 37; // VDC bits for display_flags ...
  832                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 38; // *************
  833                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 40; #ifndef BKG_OFF
  834                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 41; #define BKG_OFF 0x00
  835                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 42; #endif
  836                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 44; #ifndef SPR_OFF
  837                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 45; #define SPR_OFF 0x00
  838                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 46; #endif
  839                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 48; #ifndef BKG_ON
  840                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 49; #define BKG_ON 0x80
  841                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 50; #endif
  842                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 52; #ifndef SPR_ON
  843                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 53; #define SPR_ON 0x40
  844                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 54; #endif
  845                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 56; // *************
  846                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 57; // Functions in hucc-scroll.asm ...
  847                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 58; // *************
  848                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 60; #ifdef __HUCC__
  849                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 62; #asmdef	HUCC_USES_NEW_SCROLL 1
  850               0001     	HUCC_USES_NEW_SCROLL = 1
  851                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 64; extern void __fastcall scroll_split( unsigned char index<_al>, unsigned char screen_line<_ah>, unsigned int bat_x<_bx>, unsigned int bat_y<_cx>, unsigned char display_flags<_dl> );
  852                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 65; extern void __fastcall sgx_scroll_split( unsigned char index<_al>, unsigned char screen_line<_ah>, unsigned int bat_x<_bx>, unsigned int bat_y<_cx>, unsigned char display_flags<_dl> );
  853                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 67; extern void __fastcall disable_split( unsigned char index<acc> );
  854                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 68; extern void __fastcall sgx_disable_split( unsigned char index<acc> );
  855                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 70; extern void __fastcall __macro disable_all_splits( void );
  856                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 71; extern void __fastcall __macro sgx_disable_all_splits( void );
  857                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 73; #asm
  858                        		.dbg	clear
  859                        			.macro	_disable_all_splits
  860                        			ldy	#HUCC_PCE_SPLITS - 1
  861                        	!loop:		tya
  862                        			call	_disable_split.1
  863                        			dey
  864                        			bpl	!loop-
  865                        			.endm
  866                        			.macro	_sgx_disable_all_splits
  867                        			ldy	#HUCC_SGX_SPLITS - 1
  868                        	!loop:		tya
  869                        			call	_sgx_disable_split.1
  870                        			dey
  871                        			bpl	!loop-
  872                        			.endm
  873                        	
  874                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 89; #endasm
  875                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 91; #endif // __HUCC__
  876                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 93; #endif // _hucc_scroll_h
  877                        		.dbg	line,	"main.c", 3; #include "hucc-chrmap.h"
  878                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 1; #ifndef _hucc_chrmap_h
  879                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 2; #define _hucc_chrmap_h
  880                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 4; /****************************************************************************
  881                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 5; ; ***************************************************************************
  882                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 6; ;
  883                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 7; ; hucc-chrmap.h
  884                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 8; ;
  885                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 9; ; A simple map system based on 8x8 characters (aka "tiles") in BAT format.
  886                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 10; ;
  887                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 11; ; Copyright John Brandwood 2025.
  888                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 12; ;
  889                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 13; ; Distributed under the Boost Software License, Version 1.0.
  890                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 14; ; (See accompanying file LICENSE_1_0.txt or copy at
  891                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 15; ;  http://www.boost.org/LICENSE_1_0.txt)
  892                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 16; ;
  893                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 17; ; ***************************************************************************
  894                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 18; ; ***************************************************************************
  895                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 19; ;
  896                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 20; ; The maximum X and Y size for chrmaps is 256 characters (2048 pixels).
  897                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 21; ;
  898                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 22; ; The maximum total size for a chrmap is 16KBytes, which allows for maps up
  899                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 23; ; to 256x32 tiles (2048x256 pixels).
  900                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 24; ;
  901                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 25; ; ***************************************************************************
  902                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 26; ; **************************************************************************/
  903                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 28; // *************
  904                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 29; // This code extends the blkmap library ...
  905                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 30; // *************
  906                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 32; #include "hucc-blkmap.h"
  907                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 1; #ifndef _hucc_blkmap_h
  908                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 2; #define _hucc_blkmap_h
  909                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 4; /****************************************************************************
  910                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 5; ; ***************************************************************************
  911                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 6; ;
  912                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 7; ; hucc-blkmap.h
  913                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 8; ;
  914                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 9; ; A map system based on 16x16 meta-tiles (aka "blocks", aka CHR/BLK/MAP).
  915                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 10; ;
  916                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 11; ; Copyright John Brandwood 2025.
  917                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 12; ;
  918                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 13; ; Distributed under the Boost Software License, Version 1.0.
  919                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 14; ; (See accompanying file LICENSE_1_0.txt or copy at
  920                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 15; ;  http://www.boost.org/LICENSE_1_0.txt)
  921                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 16; ;
  922                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 17; ; ***************************************************************************
  923                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 18; ; ***************************************************************************
  924                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 19; ;
  925                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 20; ; The maximum X and Y size for blkmaps is 128 blocks (2048 pixels).
  926                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 21; ;
  927                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 22; ; The maximum total size for a blkmap is 16KBytes, which allows for maps up
  928                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 23; ; to 128x128 blocks (2048x2048 pixels).
  929                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 24; ;
  930                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 25; ; Huge multi-screen blkmaps are also supported (optionally).
  931                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 26; ;
  932                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 27; ; The maximum X and Y for multi-screen maps is 128 screens (32768 pixels).
  933                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 28; ;
  934                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 29; ; The maximum total size for a multi-screen map is 8KBytes, which allows for
  935                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 30; ; a total of 1024 screens.
  936                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 31; ;
  937                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 32; ; ***************************************************************************
  938                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 33; ; **************************************************************************/
  939                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 35; // *************
  940                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 36; // Functions in blkmap.asm ...
  941                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 37; // *************
  942                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 39; #ifdef __HUCC__
  943                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 41; #asmdef	HUCC_USES_BLKMAP 1
  944               0001     	HUCC_USES_BLKMAP = 1
  945                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 43; // Current top-left of drawn map in pixels.
  946                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 44; extern unsigned int   vdc_map_pxl_x;
  947                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 45; extern unsigned int   vdc_map_pxl_y;
  948                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 47; // Width and height to draw/scroll in characters (not tiles).
  949                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 48; extern unsigned char  vdc_map_draw_w;
  950                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 49; extern unsigned char  vdc_map_draw_h;
  951                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 51; // Width of map (or multi-screen BAT) in tiles.
  952                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 52; extern unsigned char  vdc_map_line_w;
  953                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 54; // Width of map in screens (if multi-screen map).
  954                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 55; extern unsigned char  vdc_map_scrn_w;
  955                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 57; // Extra information returned by get_map_block() and sgx_get_map_block(),
  956                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 58; // which are the collision flags and the mask/overlay sprite for the BLK.
  957                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 59; extern unsigned char  map_blk_flag;
  958                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 60; extern unsigned char  map_blk_mask;
  959                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 62; extern unsigned char  vdc_scr_bank;
  960                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 63; extern unsigned char *vdc_scr_addr;
  961                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 65; extern unsigned char  vdc_map_bank;
  962                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 66; extern unsigned char *vdc_map_addr;
  963                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 68; extern unsigned char  vdc_blk_bank;
  964                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 69; extern unsigned char *vdc_blk_addr;
  965                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 71; extern unsigned char  vdc_tbl_bank;
  966                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 72; extern unsigned char *vdc_tbl_addr;
  967                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 74; extern void __fastcall set_blocks( unsigned char __far *blk_def<vdc_blk_bank:vdc_blk_addr>, unsigned char __far *flg_def<vdc_tbl_bank:vdc_tbl_addr>, unsigned char number_of_blocks<_al> );
  968                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 75; extern void __fastcall __macro set_blkmap( unsigned char __far *blk_map<vdc_map_bank:vdc_map_addr>, unsigned char blocks_w<vdc_map_line_w> );
  969                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 76; extern void __fastcall __macro set_multimap( unsigned char __far *multi_map<vdc_scr_bank:vdc_scr_addr>, unsigned char screens_w<vdc_map_scrn_w> );
  970                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 78; extern void __fastcall draw_map( void );
  971                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 79; extern void __fastcall scroll_map( void );
  972                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 81; extern void __fastcall blit_map( unsigned char tile_x<map_bat_x>, unsigned char tile_y<map_bat_y>, unsigned char tile_w<map_draw_x>, unsigned char tile_h<map_draw_y> );
  973                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 83; extern unsigned char __fastcall get_map_block( unsigned int x<map_pxl_x>, unsigned int y<map_pxl_y> );
  974                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 85; #asm
  975                        		.dbg	clear
  976                        			.macro	_set_blkmap.2
  977                        			stz	vdc_scr_bank
  978                        			.endm
  979                        			.macro	_set_multimap.2
  980                        			lda	vdc_bat_width
  981                        			lsr	a
  982                        			sta	vdc_map_line_w
  983                        			.endm
  984                        			.macro	SCREEN
  985                        			db	(((\1) & $1FFF) | $6000) >> 8, bank(\1)
  986                        			db	(((\2) & $1FFF) | $4000) >> 8, bank(\2)
  987                        			db	(((\3) & $1FFF) | $6000) >> 8, bank(\3)
  988                        			dw	(\4)
  989                        			.endm
  990                        	
  991                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 102; #endasm
  992                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 104; #ifdef _SGX
  993                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 106; // Current top-left of drawn map in pixels.
  994                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 107; extern unsigned int   sgx_map_pxl_x;
  995                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 108; extern unsigned int   sgx_map_pxl_y;
  996                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 110; // Width and height to draw/scroll in characters (not tiles).
  997                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 111; extern unsigned char  sgx_map_draw_w;
  998                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 112; extern unsigned char  sgx_map_draw_h;
  999                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 114; // Width of map (or multi-screen BAT) in tiles.
 1000                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 115; extern unsigned char  sgx_map_line_w;
 1001                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 117; // Width of map in screens (if multi-screen map).
 1002                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 118; extern unsigned char  sgx_map_scrn_w;
 1003                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 120; extern unsigned char  sgx_scr_bank;
 1004                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 121; extern unsigned char *sgx_scr_addr;
 1005                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 123; extern unsigned char  sgx_map_bank;
 1006                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 124; extern unsigned char *sgx_map_addr;
 1007                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 126; extern unsigned char  sgx_blk_bank;
 1008                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 127; extern unsigned char *sgx_blk_addr;
 1009                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 129; extern unsigned char  sgx_tbl_bank;
 1010                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 130; extern unsigned char *sgx_tbl_addr;
 1011                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 132; extern void __fastcall sgx_set_blocks( unsigned char __far *blk_def<sgx_blk_bank:sgx_blk_addr>, unsigned char __far *flg_def<sgx_tbl_bank:sgx_tbl_addr>, unsigned char number_of_blocks<_al> );
 1012                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 133; extern void __fastcall __macro sgx_set_blkmap( unsigned char __far *blk_map<sgx_map_bank:sgx_map_addr>, unsigned char blocks_w<sgx_map_line_w> );
 1013                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 134; extern void __fastcall __macro sgx_set_multimap( unsigned char __far *multi_map<sgx_scr_bank:sgx_scr_addr>, unsigned char screens_w<sgx_map_scrn_w> );
 1014                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 136; extern void __fastcall sgx_draw_map( void );
 1015                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 137; extern void __fastcall sgx_scroll_map( void );
 1016                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 139; extern void __fastcall sgx_blit_map( unsigned char tile_x<map_bat_x>, unsigned char tile_y<map_bat_y>, unsigned char tile_w<map_draw_x>, unsigned char tile_h<map_draw_y> );
 1017                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 141; extern unsigned char __fastcall sgx_get_map_block( unsigned int x<map_pxl_x>, unsigned int y<map_pxl_y> );
 1018                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 143; #asm
 1019                        		.dbg	clear
 1020                        			.macro	_sgx_set_blkmap.2
 1021                        			stz	sgx_scr_bank
 1022                        			.endm
 1023                        			.macro	_sgx_set_multimap.2
 1024                        			lda	sgx_bat_width
 1025                        			lsr	a
 1026                        			sta	sgx_map_line_w
 1027                        			.endm
 1028                        	
 1029                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 153; #endasm
 1030                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 155; #endif
 1031                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 157; #endif // __HUCC__
 1032                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 159; #endif // _hucc_blkmap_h
 1033                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 34; // *************
 1034                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 35; // Functions in chrmap.asm ...
 1035                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 36; // *************
 1036                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 38; #ifdef __HUCC__
 1037                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 40; #asmdef	HUCC_USES_CHRMAP 1
 1038               0001     	HUCC_USES_CHRMAP = 1
 1039                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 42; extern void __fastcall __nop set_chrmap( unsigned char __far *chrmap<vdc_map_bank:vdc_map_addr>, unsigned char tiles_w<vdc_map_line_w> );
 1040                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 44; extern void __fastcall draw_bat( void );
 1041                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 45; extern void __fastcall scroll_bat( void );
 1042                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 47; extern void __fastcall blit_bat( unsigned char tile_x<map_bat_x>, unsigned char tile_y<map_bat_y>, unsigned char tile_w<map_draw_x>, unsigned char tile_h<map_draw_y> );
 1043                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 49; #ifdef _SGX
 1044                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 51; extern void __fastcall __nop sgx_set_chrmap( unsigned char __far *chrmap<sgx_map_bank:sgx_map_addr>, unsigned char tiles_w<sgx_map_line_w> );
 1045                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 53; extern void __fastcall sgx_draw_bat( void );
 1046                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 54; extern void __fastcall sgx_scroll_bat( void );
 1047                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 56; extern void __fastcall sgx_blit_bat( unsigned char tile_x<map_bat_x>, unsigned char tile_y<map_bat_y>, unsigned char tile_w<map_draw_x>, unsigned char tile_h<map_draw_y> );
 1048                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 58; #endif
 1049                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 60; #endif // __HUCC__
 1050                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 62; #endif // _hucc_chrmap_h
 1051                        		.dbg	line,	"main.c", 4; #include "hucc-blkmap.h"
 1052                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 1; #ifndef _hucc_blkmap_h
 1053                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 2; #define _hucc_blkmap_h
 1054                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 4; /****************************************************************************
 1055                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 5; ; ***************************************************************************
 1056                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 6; ;
 1057                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 7; ; hucc-blkmap.h
 1058                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 8; ;
 1059                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 9; ; A map system based on 16x16 meta-tiles (aka "blocks", aka CHR/BLK/MAP).
 1060                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 10; ;
 1061                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 11; ; Copyright John Brandwood 2025.
 1062                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 12; ;
 1063                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 13; ; Distributed under the Boost Software License, Version 1.0.
 1064                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 14; ; (See accompanying file LICENSE_1_0.txt or copy at
 1065                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 15; ;  http://www.boost.org/LICENSE_1_0.txt)
 1066                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 16; ;
 1067                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 17; ; ***************************************************************************
 1068                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 18; ; ***************************************************************************
 1069                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 19; ;
 1070                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 20; ; The maximum X and Y size for blkmaps is 128 blocks (2048 pixels).
 1071                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 21; ;
 1072                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 22; ; The maximum total size for a blkmap is 16KBytes, which allows for maps up
 1073                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 23; ; to 128x128 blocks (2048x2048 pixels).
 1074                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 24; ;
 1075                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 25; ; Huge multi-screen blkmaps are also supported (optionally).
 1076                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 26; ;
 1077                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 27; ; The maximum X and Y for multi-screen maps is 128 screens (32768 pixels).
 1078                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 28; ;
 1079                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 29; ; The maximum total size for a multi-screen map is 8KBytes, which allows for
 1080                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 30; ; a total of 1024 screens.
 1081                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 31; ;
 1082                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 32; ; ***************************************************************************
 1083                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 33; ; **************************************************************************/
 1084                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 35; // *************
 1085                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 36; // Functions in blkmap.asm ...
 1086                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 37; // *************
 1087                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 39; #ifdef __HUCC__
 1088                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 41; #asmdef	HUCC_USES_BLKMAP 1
 1089                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 43; // Current top-left of drawn map in pixels.
 1090                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 44; extern unsigned int   vdc_map_pxl_x;
 1091                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 45; extern unsigned int   vdc_map_pxl_y;
 1092                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 47; // Width and height to draw/scroll in characters (not tiles).
 1093                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 48; extern unsigned char  vdc_map_draw_w;
 1094                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 49; extern unsigned char  vdc_map_draw_h;
 1095                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 51; // Width of map (or multi-screen BAT) in tiles.
 1096                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 52; extern unsigned char  vdc_map_line_w;
 1097                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 54; // Width of map in screens (if multi-screen map).
 1098                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 55; extern unsigned char  vdc_map_scrn_w;
 1099                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 57; // Extra information returned by get_map_block() and sgx_get_map_block(),
 1100                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 58; // which are the collision flags and the mask/overlay sprite for the BLK.
 1101                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 59; extern unsigned char  map_blk_flag;
 1102                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 60; extern unsigned char  map_blk_mask;
 1103                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 62; extern unsigned char  vdc_scr_bank;
 1104                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 63; extern unsigned char *vdc_scr_addr;
 1105                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 65; extern unsigned char  vdc_map_bank;
 1106                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 66; extern unsigned char *vdc_map_addr;
 1107                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 68; extern unsigned char  vdc_blk_bank;
 1108                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 69; extern unsigned char *vdc_blk_addr;
 1109                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 71; extern unsigned char  vdc_tbl_bank;
 1110                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 72; extern unsigned char *vdc_tbl_addr;
 1111                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 74; extern void __fastcall set_blocks( unsigned char __far *blk_def<vdc_blk_bank:vdc_blk_addr>, unsigned char __far *flg_def<vdc_tbl_bank:vdc_tbl_addr>, unsigned char number_of_blocks<_al> );
 1112                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 75; extern void __fastcall __macro set_blkmap( unsigned char __far *blk_map<vdc_map_bank:vdc_map_addr>, unsigned char blocks_w<vdc_map_line_w> );
 1113                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 76; extern void __fastcall __macro set_multimap( unsigned char __far *multi_map<vdc_scr_bank:vdc_scr_addr>, unsigned char screens_w<vdc_map_scrn_w> );
 1114                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 78; extern void __fastcall draw_map( void );
 1115                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 79; extern void __fastcall scroll_map( void );
 1116                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 81; extern void __fastcall blit_map( unsigned char tile_x<map_bat_x>, unsigned char tile_y<map_bat_y>, unsigned char tile_w<map_draw_x>, unsigned char tile_h<map_draw_y> );
 1117                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 83; extern unsigned char __fastcall get_map_block( unsigned int x<map_pxl_x>, unsigned int y<map_pxl_y> );
 1118                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 85; #asm
 1119                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 86; .macro	_set_blkmap.2
 1120                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 87; stz	vdc_scr_bank
 1121                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 88; .endm
 1122                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 90; .macro	_set_multimap.2
 1123                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 91; lda	vdc_bat_width
 1124                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 92; lsr	a
 1125                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 93; sta	vdc_map_line_w
 1126                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 94; .endm
 1127                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 96; .macro	SCREEN
 1128                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 97; db	(((\1) & $1FFF) | $6000) >> 8, bank(\1)
 1129                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 98; db	(((\2) & $1FFF) | $4000) >> 8, bank(\2)
 1130                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 99; db	(((\3) & $1FFF) | $6000) >> 8, bank(\3)
 1131                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 100; dw	(\4)
 1132                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 101; .endm
 1133                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 102; #endasm
 1134                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 104; #ifdef _SGX
 1135                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 106; // Current top-left of drawn map in pixels.
 1136                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 107; extern unsigned int   sgx_map_pxl_x;
 1137                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 108; extern unsigned int   sgx_map_pxl_y;
 1138                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 110; // Width and height to draw/scroll in characters (not tiles).
 1139                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 111; extern unsigned char  sgx_map_draw_w;
 1140                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 112; extern unsigned char  sgx_map_draw_h;
 1141                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 114; // Width of map (or multi-screen BAT) in tiles.
 1142                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 115; extern unsigned char  sgx_map_line_w;
 1143                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 117; // Width of map in screens (if multi-screen map).
 1144                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 118; extern unsigned char  sgx_map_scrn_w;
 1145                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 120; extern unsigned char  sgx_scr_bank;
 1146                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 121; extern unsigned char *sgx_scr_addr;
 1147                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 123; extern unsigned char  sgx_map_bank;
 1148                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 124; extern unsigned char *sgx_map_addr;
 1149                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 126; extern unsigned char  sgx_blk_bank;
 1150                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 127; extern unsigned char *sgx_blk_addr;
 1151                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 129; extern unsigned char  sgx_tbl_bank;
 1152                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 130; extern unsigned char *sgx_tbl_addr;
 1153                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 132; extern void __fastcall sgx_set_blocks( unsigned char __far *blk_def<sgx_blk_bank:sgx_blk_addr>, unsigned char __far *flg_def<sgx_tbl_bank:sgx_tbl_addr>, unsigned char number_of_blocks<_al> );
 1154                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 133; extern void __fastcall __macro sgx_set_blkmap( unsigned char __far *blk_map<sgx_map_bank:sgx_map_addr>, unsigned char blocks_w<sgx_map_line_w> );
 1155                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 134; extern void __fastcall __macro sgx_set_multimap( unsigned char __far *multi_map<sgx_scr_bank:sgx_scr_addr>, unsigned char screens_w<sgx_map_scrn_w> );
 1156                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 136; extern void __fastcall sgx_draw_map( void );
 1157                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 137; extern void __fastcall sgx_scroll_map( void );
 1158                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 139; extern void __fastcall sgx_blit_map( unsigned char tile_x<map_bat_x>, unsigned char tile_y<map_bat_y>, unsigned char tile_w<map_draw_x>, unsigned char tile_h<map_draw_y> );
 1159                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 141; extern unsigned char __fastcall sgx_get_map_block( unsigned int x<map_pxl_x>, unsigned int y<map_pxl_y> );
 1160                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 143; #asm
 1161                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 144; .macro	_sgx_set_blkmap.2
 1162                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 145; stz	sgx_scr_bank
 1163                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 146; .endm
 1164                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 148; .macro	_sgx_set_multimap.2
 1165                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 149; lda	sgx_bat_width
 1166                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 150; lsr	a
 1167                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 151; sta	sgx_map_line_w
 1168                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 152; .endm
 1169                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 153; #endasm
 1170                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 155; #endif
 1171                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 157; #endif // __HUCC__
 1172                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 159; #endif // _hucc_blkmap_h
 1173                        		.dbg	line,	"main.c", 9; #include "include/constants.c"
 1174                        		.dbg	line,	"include\constants.c", 1; //*****************************************************************************//
 1175                        		.dbg	line,	"include\constants.c", 2; //                                                                             //
 1176                        		.dbg	line,	"include\constants.c", 3; //                                SYSTEM CONSTANTS                             //
 1177                        		.dbg	line,	"include\constants.c", 4; //                                                                             //
 1178                        		.dbg	line,	"include\constants.c", 5; //*****************************************************************************//
 1179                        		.dbg	line,	"include\constants.c", 7; #define FALSE 0
 1180                        		.dbg	line,	"include\constants.c", 8; #define TRUE  1
 1181                        		.dbg	line,	"include\constants.c", 10; #define YES   1
 1182                        		.dbg	line,	"include\constants.c", 11; #define NO    2
 1183                        		.dbg	line,	"include\constants.c", 13; #define JOYPAD_1 0
 1184                        		.dbg	line,	"include\constants.c", 14; #define JOYPAD_2 1
 1185                        		.dbg	line,	"include\constants.c", 16; #define BAT_SIZE_W 2048 // IN PIXELS
 1186                        		.dbg	line,	"include\constants.c", 17; #define BAT_SIZE_H 256  // IN PIXELS
 1187                        		.dbg	line,	"include\constants.c", 19; #define JOY_DIR_PRESSED (JOY_DOWN | JOY_UP | JOY_RIGHT | JOY_LEFT)
 1188                        		.dbg	line,	"include\constants.c", 22; #define TILES_1   16
 1189                        		.dbg	line,	"include\constants.c", 23; #define TILES_2   32
 1190                        		.dbg	line,	"include\constants.c", 24; #define TILES_3   48
 1191                        		.dbg	line,	"include\constants.c", 25; #define TILES_4   64
 1192                        		.dbg	line,	"include\constants.c", 26; #define TILES_8   128
 1193                        		.dbg	line,	"include\constants.c", 27; #define TILES_16  256
 1194                        		.dbg	line,	"include\constants.c", 28; #define TILES_32  512
 1195                        		.dbg	line,	"include\constants.c", 29; #define TILES_48  768
 1196                        		.dbg	line,	"include\constants.c", 30; #define TILES_64  1024
 1197                        		.dbg	line,	"include\constants.c", 31; #define TILES_80  1280
 1198                        		.dbg	line,	"include\constants.c", 32; #define TILES_96  1536
 1199                        		.dbg	line,	"include\constants.c", 33; #define TILES_112 1792
 1200                        		.dbg	line,	"include\constants.c", 34; #define TILES_128 2048
 1201                        		.dbg	line,	"include\constants.c", 41; #define SEQUENCE_TITLE      0
 1202                        		.dbg	line,	"include\constants.c", 42; #define SEQUENCE_INTRO      1
 1203                        		.dbg	line,	"include\constants.c", 43; #define SEQUENCE_GAME       2
 1204                        		.dbg	line,	"include\constants.c", 48; //-----------------------------------------------------------------------------//
 1205                        		.dbg	line,	"include\constants.c", 49; //                                                                             //
 1206                        		.dbg	line,	"include\constants.c", 50; //                                   PLAYER                                    //
 1207                        		.dbg	line,	"include\constants.c", 51; //                                                                             //
 1208                        		.dbg	line,	"include\constants.c", 52; //-----------------------------------------------------------------------------//
 1209                        		.dbg	line,	"include\constants.c", 54; #define AXIS_RIGHT          0
 1210                        		.dbg	line,	"include\constants.c", 55; #define AXIS_LEFT           1
 1211                        		.dbg	line,	"include\constants.c", 56; #define AXIS_UP             2
 1212                        		.dbg	line,	"include\constants.c", 57; #define AXIS_DOWN           3
 1213                        		.dbg	line,	"include\constants.c", 61; #define STATE_IDLE          0
 1214                        		.dbg	line,	"include\constants.c", 62; #define STATE_WALK          1
 1215                        		.dbg	line,	"include\constants.c", 63; #define STATE_PUNCH         2
 1216                        		.dbg	line,	"include\constants.c", 64; #define STATE_JUMP          4
 1217                        		.dbg	line,	"include\constants.c", 65; #define STATE_JUMP_RIGHT    5
 1218                        		.dbg	line,	"include\constants.c", 66; #define STATE_JUMP_LEFT     6
 1219                        		.dbg	line,	"include\constants.c", 67; #define STATE_CROUCH        7
 1220                        		.dbg	line,	"include\constants.c", 68; #define STATE_CROUCH_PUNCH  8
 1221                        		.dbg	line,	"include\constants.c", 69; #define STATE_FALL          9
 1222                        		.dbg	line,	"include\constants.c", 73; #define PLAYER_VRAM_ADR     0x4800
 1223                        		.dbg	line,	"include\constants.c", 78; //-----------------------------------------------------------------------------//
 1224                        		.dbg	line,	"include\constants.c", 79; //                                                                             //
 1225                        		.dbg	line,	"include\constants.c", 80; //                                  COLLISIONS                                 //
 1226                        		.dbg	line,	"include\constants.c", 81; //                                                                             //
 1227                        		.dbg	line,	"include\constants.c", 82; //-----------------------------------------------------------------------------//
 1228                        		.dbg	line,	"include\constants.c", 84; #define TILE_EMPTY          0
 1229                        		.dbg	line,	"include\constants.c", 85; #define TILE_BG             1
 1230                        		.dbg	line,	"include\constants.c", 90; //-----------------------------------------------------------------------------//
 1231                        		.dbg	line,	"include\constants.c", 91; //                                                                             //
 1232                        		.dbg	line,	"include\constants.c", 92; //                                     HUD                                     //
 1233                        		.dbg	line,	"include\constants.c", 93; //                                                                             //
 1234                        		.dbg	line,	"include\constants.c", 94; //-----------------------------------------------------------------------------//
 1235                        		.dbg	line,	"include\constants.c", 96; #define LIFEBAR_1_VRAM_ADR      0x1000
 1236                        		.dbg	line,	"include\constants.c", 97; #define LIFEBAR_2_VRAM_ADR      LIFEBAR_1_VRAM_ADR+TILES_2
 1237                        		.dbg	line,	"include\constants.c", 98; #define LIFEBAR_3_VRAM_ADR      LIFEBAR_2_VRAM_ADR+TILES_2
 1238                        		.dbg	line,	"include\constants.c", 99; #define LIFEBAR_4_VRAM_ADR      LIFEBAR_3_VRAM_ADR+TILES_2
 1239                        		.dbg	line,	"include\constants.c", 100; #define LIFEBAR_5_VRAM_ADR      LIFEBAR_4_VRAM_ADR+TILES_2
 1240                        		.dbg	line,	"include\constants.c", 102; #define WEAPON_VRAM_ADR         LIFEBAR_5_VRAM_ADR+TILES_2
 1241                        		.dbg	line,	"include\constants.c", 103; #define ARMOR_VRAM_ADR          WEAPON_VRAM_ADR+TILES_4
 1242                        		.dbg	line,	"include\constants.c", 108; //-----------------------------------------------------------------------------//
 1243                        		.dbg	line,	"include\constants.c", 109; //                                                                             //
 1244                        		.dbg	line,	"include\constants.c", 110; //                                    LEVELS                                   //
 1245                        		.dbg	line,	"include\constants.c", 111; //                                                                             //
 1246                        		.dbg	line,	"include\constants.c", 112; //-----------------------------------------------------------------------------//
 1247                        		.dbg	line,	"include\constants.c", 114; #define LV1_WALL_VRAM_ADR       0x1000
 1248                        		.dbg	line,	"include\constants.c", 115; #define LV1_DOOR_VRAM_ADR       LV1_WALL_VRAM_ADR+256
 1249                        		.dbg	line,	"main.c", 10; #include "include/variables.c"
 1250                        		.dbg	line,	"include\variables.c", 1; #include "huc.h"
 1251                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 1; #ifndef _hucc_legacy_h
 1252                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 2; #define _hucc_legacy_h
 1253                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 4; /****************************************************************************
 1254                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 5; ; ***************************************************************************
 1255                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 6; ;
 1256                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 7; ; huc.h
 1257                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 8; ;
 1258                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 9; ; HuCC wrapper file to include a default set of HuC-compatible functions.
 1259                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 10; ;
 1260                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 11; ; Copyright John Brandwood 2024.
 1261                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 12; ;
 1262                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 13; ; Distributed under the Boost Software License, Version 1.0.
 1263                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 14; ; (See accompanying file LICENSE_1_0.txt or copy at
 1264                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 15; ;  http://www.boost.org/LICENSE_1_0.txt)
 1265                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 16; ;
 1266                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 17; ; ***************************************************************************
 1267                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 18; ; ***************************************************************************
 1268                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 19; ;
 1269                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 20; ; When the HuCC compiler is invoked with the "--legacy" option to compile old
 1270                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 21; ; projects, then this "huc.h" file is automatically included.
 1271                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 22; ;
 1272                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 23; ; This file includes a set of the individual HuCC headers which correspond to
 1273                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 24; ; HuC's built-in functions and MagicKit library.
 1274                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 25; ;
 1275                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 26; ; New HuCC projects should, preferably, include the specific headers that are
 1276                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 27; ; needed, which will then allow them to replace parts of the standard library
 1277                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 28; ; with newer functions, or they can just manually include this "huc.h" file.
 1278                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 29; ;
 1279                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 30; ; ***************************************************************************
 1280                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 31; ; **************************************************************************/
 1281                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 33; #include "hucc-systemcard.h"
 1282                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 34; #include "hucc-baselib.h"
 1283                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 35; #include "hucc-gfx.h"
 1284                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 36; #include "hucc-string.h"
 1285                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 37; #include "hucc-old-scroll.h"
 1286                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 38; #include "hucc-old-spr.h"
 1287                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 39; #include "hucc-old-map.h"
 1288                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 40; #include "hucc-old-line.h"
 1289                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 42; #endif // _hucc_legacy_h
 1290                        		.dbg	line,	"include\variables.c", 2; #include "hucc-scroll.h"
 1291                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 1; #ifndef _hucc_scroll_h
 1292                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 2; #define _hucc_scroll_h
 1293                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 4; /****************************************************************************
 1294                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 5; ; ***************************************************************************
 1295                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 6; ;
 1296                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 7; ; hucc-scroll.h
 1297                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 8; ;
 1298                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 9; ; Routines for a fast split-screen scrolling system.
 1299                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 10; ;
 1300                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 11; ; Copyright John Brandwood 2024.
 1301                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 12; ;
 1302                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 13; ; Distributed under the Boost Software License, Version 1.0.
 1303                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 14; ; (See accompanying file LICENSE_1_0.txt or copy at
 1304                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 15; ;  http://www.boost.org/LICENSE_1_0.txt)
 1305                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 16; ;
 1306                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 17; ; ***************************************************************************
 1307                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 18; ; ***************************************************************************
 1308                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 19; ;
 1309                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 20; ; The maximum number of splits for each screen layer is set in your project's
 1310                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 21; ; "hucc-config.inc" file, with the library having a limit of 128-per-layer.
 1311                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 22; ;
 1312                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 23; ; Your first active split must be defined to start at screen line 0, and then
 1313                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 24; ; the rest of the active splits must be in increasing line order to match the
 1314                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 25; ; way that the PC Engine displays the output image.
 1315                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 26; ;
 1316                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 27; ; You can have disabled splits interleaved with your active splits.
 1317                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 28; ;
 1318                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 29; ; Splits that are normally disabled can be used to create full screen effects
 1319                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 30; ; such as bouncing the screen up and down by adding blank areas at the top or
 1320                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 31; ; bottom of the screen, and then rapidly changing the height of those areas.
 1321                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 32; ;
 1322                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 33; ; ***************************************************************************
 1323                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 34; ; **************************************************************************/
 1324                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 36; // *************
 1325                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 37; // VDC bits for display_flags ...
 1326                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 38; // *************
 1327                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 40; #ifndef BKG_OFF
 1328                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 41; #define BKG_OFF 0x00
 1329                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 42; #endif
 1330                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 44; #ifndef SPR_OFF
 1331                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 45; #define SPR_OFF 0x00
 1332                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 46; #endif
 1333                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 48; #ifndef BKG_ON
 1334                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 49; #define BKG_ON 0x80
 1335                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 50; #endif
 1336                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 52; #ifndef SPR_ON
 1337                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 53; #define SPR_ON 0x40
 1338                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 54; #endif
 1339                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 56; // *************
 1340                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 57; // Functions in hucc-scroll.asm ...
 1341                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 58; // *************
 1342                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 60; #ifdef __HUCC__
 1343                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 62; #asmdef	HUCC_USES_NEW_SCROLL 1
 1344                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 64; extern void __fastcall scroll_split( unsigned char index<_al>, unsigned char screen_line<_ah>, unsigned int bat_x<_bx>, unsigned int bat_y<_cx>, unsigned char display_flags<_dl> );
 1345                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 65; extern void __fastcall sgx_scroll_split( unsigned char index<_al>, unsigned char screen_line<_ah>, unsigned int bat_x<_bx>, unsigned int bat_y<_cx>, unsigned char display_flags<_dl> );
 1346                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 67; extern void __fastcall disable_split( unsigned char index<acc> );
 1347                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 68; extern void __fastcall sgx_disable_split( unsigned char index<acc> );
 1348                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 70; extern void __fastcall __macro disable_all_splits( void );
 1349                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 71; extern void __fastcall __macro sgx_disable_all_splits( void );
 1350                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 73; #asm
 1351                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 74; .macro	_disable_all_splits
 1352                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 75; ldy	#HUCC_PCE_SPLITS - 1
 1353                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 76; !loop:		tya
 1354                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 77; call	_disable_split.1
 1355                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 78; dey
 1356                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 79; bpl	!loop-
 1357                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 80; .endm
 1358                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 82; .macro	_sgx_disable_all_splits
 1359                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 83; ldy	#HUCC_SGX_SPLITS - 1
 1360                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 84; !loop:		tya
 1361                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 85; call	_sgx_disable_split.1
 1362                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 86; dey
 1363                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 87; bpl	!loop-
 1364                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 88; .endm
 1365                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 89; #endasm
 1366                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 91; #endif // __HUCC__
 1367                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 93; #endif // _hucc_scroll_h
 1368                        		.dbg	line,	"include\variables.c", 3; #include "hucc-chrmap.h"
 1369                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 1; #ifndef _hucc_chrmap_h
 1370                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 2; #define _hucc_chrmap_h
 1371                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 4; /****************************************************************************
 1372                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 5; ; ***************************************************************************
 1373                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 6; ;
 1374                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 7; ; hucc-chrmap.h
 1375                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 8; ;
 1376                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 9; ; A simple map system based on 8x8 characters (aka "tiles") in BAT format.
 1377                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 10; ;
 1378                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 11; ; Copyright John Brandwood 2025.
 1379                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 12; ;
 1380                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 13; ; Distributed under the Boost Software License, Version 1.0.
 1381                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 14; ; (See accompanying file LICENSE_1_0.txt or copy at
 1382                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 15; ;  http://www.boost.org/LICENSE_1_0.txt)
 1383                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 16; ;
 1384                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 17; ; ***************************************************************************
 1385                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 18; ; ***************************************************************************
 1386                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 19; ;
 1387                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 20; ; The maximum X and Y size for chrmaps is 256 characters (2048 pixels).
 1388                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 21; ;
 1389                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 22; ; The maximum total size for a chrmap is 16KBytes, which allows for maps up
 1390                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 23; ; to 256x32 tiles (2048x256 pixels).
 1391                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 24; ;
 1392                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 25; ; ***************************************************************************
 1393                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 26; ; **************************************************************************/
 1394                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 28; // *************
 1395                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 29; // This code extends the blkmap library ...
 1396                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 30; // *************
 1397                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 32; #include "hucc-blkmap.h"
 1398                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 34; // *************
 1399                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 35; // Functions in chrmap.asm ...
 1400                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 36; // *************
 1401                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 38; #ifdef __HUCC__
 1402                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 40; #asmdef	HUCC_USES_CHRMAP 1
 1403                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 42; extern void __fastcall __nop set_chrmap( unsigned char __far *chrmap<vdc_map_bank:vdc_map_addr>, unsigned char tiles_w<vdc_map_line_w> );
 1404                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 44; extern void __fastcall draw_bat( void );
 1405                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 45; extern void __fastcall scroll_bat( void );
 1406                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 47; extern void __fastcall blit_bat( unsigned char tile_x<map_bat_x>, unsigned char tile_y<map_bat_y>, unsigned char tile_w<map_draw_x>, unsigned char tile_h<map_draw_y> );
 1407                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 49; #ifdef _SGX
 1408                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 51; extern void __fastcall __nop sgx_set_chrmap( unsigned char __far *chrmap<sgx_map_bank:sgx_map_addr>, unsigned char tiles_w<sgx_map_line_w> );
 1409                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 53; extern void __fastcall sgx_draw_bat( void );
 1410                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 54; extern void __fastcall sgx_scroll_bat( void );
 1411                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 56; extern void __fastcall sgx_blit_bat( unsigned char tile_x<map_bat_x>, unsigned char tile_y<map_bat_y>, unsigned char tile_w<map_draw_x>, unsigned char tile_h<map_draw_y> );
 1412                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 58; #endif
 1413                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 60; #endif // __HUCC__
 1414                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 62; #endif // _hucc_chrmap_h
 1415                        		.dbg	line,	"include\variables.c", 4; #include "hucc-blkmap.h"
 1416                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 1; #ifndef _hucc_blkmap_h
 1417                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 2; #define _hucc_blkmap_h
 1418                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 4; /****************************************************************************
 1419                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 5; ; ***************************************************************************
 1420                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 6; ;
 1421                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 7; ; hucc-blkmap.h
 1422                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 8; ;
 1423                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 9; ; A map system based on 16x16 meta-tiles (aka "blocks", aka CHR/BLK/MAP).
 1424                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 10; ;
 1425                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 11; ; Copyright John Brandwood 2025.
 1426                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 12; ;
 1427                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 13; ; Distributed under the Boost Software License, Version 1.0.
 1428                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 14; ; (See accompanying file LICENSE_1_0.txt or copy at
 1429                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 15; ;  http://www.boost.org/LICENSE_1_0.txt)
 1430                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 16; ;
 1431                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 17; ; ***************************************************************************
 1432                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 18; ; ***************************************************************************
 1433                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 19; ;
 1434                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 20; ; The maximum X and Y size for blkmaps is 128 blocks (2048 pixels).
 1435                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 21; ;
 1436                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 22; ; The maximum total size for a blkmap is 16KBytes, which allows for maps up
 1437                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 23; ; to 128x128 blocks (2048x2048 pixels).
 1438                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 24; ;
 1439                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 25; ; Huge multi-screen blkmaps are also supported (optionally).
 1440                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 26; ;
 1441                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 27; ; The maximum X and Y for multi-screen maps is 128 screens (32768 pixels).
 1442                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 28; ;
 1443                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 29; ; The maximum total size for a multi-screen map is 8KBytes, which allows for
 1444                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 30; ; a total of 1024 screens.
 1445                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 31; ;
 1446                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 32; ; ***************************************************************************
 1447                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 33; ; **************************************************************************/
 1448                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 35; // *************
 1449                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 36; // Functions in blkmap.asm ...
 1450                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 37; // *************
 1451                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 39; #ifdef __HUCC__
 1452                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 41; #asmdef	HUCC_USES_BLKMAP 1
 1453                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 43; // Current top-left of drawn map in pixels.
 1454                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 44; extern unsigned int   vdc_map_pxl_x;
 1455                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 45; extern unsigned int   vdc_map_pxl_y;
 1456                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 47; // Width and height to draw/scroll in characters (not tiles).
 1457                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 48; extern unsigned char  vdc_map_draw_w;
 1458                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 49; extern unsigned char  vdc_map_draw_h;
 1459                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 51; // Width of map (or multi-screen BAT) in tiles.
 1460                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 52; extern unsigned char  vdc_map_line_w;
 1461                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 54; // Width of map in screens (if multi-screen map).
 1462                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 55; extern unsigned char  vdc_map_scrn_w;
 1463                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 57; // Extra information returned by get_map_block() and sgx_get_map_block(),
 1464                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 58; // which are the collision flags and the mask/overlay sprite for the BLK.
 1465                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 59; extern unsigned char  map_blk_flag;
 1466                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 60; extern unsigned char  map_blk_mask;
 1467                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 62; extern unsigned char  vdc_scr_bank;
 1468                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 63; extern unsigned char *vdc_scr_addr;
 1469                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 65; extern unsigned char  vdc_map_bank;
 1470                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 66; extern unsigned char *vdc_map_addr;
 1471                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 68; extern unsigned char  vdc_blk_bank;
 1472                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 69; extern unsigned char *vdc_blk_addr;
 1473                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 71; extern unsigned char  vdc_tbl_bank;
 1474                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 72; extern unsigned char *vdc_tbl_addr;
 1475                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 74; extern void __fastcall set_blocks( unsigned char __far *blk_def<vdc_blk_bank:vdc_blk_addr>, unsigned char __far *flg_def<vdc_tbl_bank:vdc_tbl_addr>, unsigned char number_of_blocks<_al> );
 1476                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 75; extern void __fastcall __macro set_blkmap( unsigned char __far *blk_map<vdc_map_bank:vdc_map_addr>, unsigned char blocks_w<vdc_map_line_w> );
 1477                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 76; extern void __fastcall __macro set_multimap( unsigned char __far *multi_map<vdc_scr_bank:vdc_scr_addr>, unsigned char screens_w<vdc_map_scrn_w> );
 1478                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 78; extern void __fastcall draw_map( void );
 1479                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 79; extern void __fastcall scroll_map( void );
 1480                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 81; extern void __fastcall blit_map( unsigned char tile_x<map_bat_x>, unsigned char tile_y<map_bat_y>, unsigned char tile_w<map_draw_x>, unsigned char tile_h<map_draw_y> );
 1481                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 83; extern unsigned char __fastcall get_map_block( unsigned int x<map_pxl_x>, unsigned int y<map_pxl_y> );
 1482                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 85; #asm
 1483                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 86; .macro	_set_blkmap.2
 1484                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 87; stz	vdc_scr_bank
 1485                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 88; .endm
 1486                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 90; .macro	_set_multimap.2
 1487                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 91; lda	vdc_bat_width
 1488                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 92; lsr	a
 1489                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 93; sta	vdc_map_line_w
 1490                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 94; .endm
 1491                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 96; .macro	SCREEN
 1492                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 97; db	(((\1) & $1FFF) | $6000) >> 8, bank(\1)
 1493                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 98; db	(((\2) & $1FFF) | $4000) >> 8, bank(\2)
 1494                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 99; db	(((\3) & $1FFF) | $6000) >> 8, bank(\3)
 1495                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 100; dw	(\4)
 1496                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 101; .endm
 1497                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 102; #endasm
 1498                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 104; #ifdef _SGX
 1499                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 106; // Current top-left of drawn map in pixels.
 1500                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 107; extern unsigned int   sgx_map_pxl_x;
 1501                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 108; extern unsigned int   sgx_map_pxl_y;
 1502                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 110; // Width and height to draw/scroll in characters (not tiles).
 1503                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 111; extern unsigned char  sgx_map_draw_w;
 1504                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 112; extern unsigned char  sgx_map_draw_h;
 1505                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 114; // Width of map (or multi-screen BAT) in tiles.
 1506                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 115; extern unsigned char  sgx_map_line_w;
 1507                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 117; // Width of map in screens (if multi-screen map).
 1508                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 118; extern unsigned char  sgx_map_scrn_w;
 1509                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 120; extern unsigned char  sgx_scr_bank;
 1510                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 121; extern unsigned char *sgx_scr_addr;
 1511                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 123; extern unsigned char  sgx_map_bank;
 1512                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 124; extern unsigned char *sgx_map_addr;
 1513                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 126; extern unsigned char  sgx_blk_bank;
 1514                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 127; extern unsigned char *sgx_blk_addr;
 1515                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 129; extern unsigned char  sgx_tbl_bank;
 1516                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 130; extern unsigned char *sgx_tbl_addr;
 1517                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 132; extern void __fastcall sgx_set_blocks( unsigned char __far *blk_def<sgx_blk_bank:sgx_blk_addr>, unsigned char __far *flg_def<sgx_tbl_bank:sgx_tbl_addr>, unsigned char number_of_blocks<_al> );
 1518                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 133; extern void __fastcall __macro sgx_set_blkmap( unsigned char __far *blk_map<sgx_map_bank:sgx_map_addr>, unsigned char blocks_w<sgx_map_line_w> );
 1519                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 134; extern void __fastcall __macro sgx_set_multimap( unsigned char __far *multi_map<sgx_scr_bank:sgx_scr_addr>, unsigned char screens_w<sgx_map_scrn_w> );
 1520                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 136; extern void __fastcall sgx_draw_map( void );
 1521                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 137; extern void __fastcall sgx_scroll_map( void );
 1522                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 139; extern void __fastcall sgx_blit_map( unsigned char tile_x<map_bat_x>, unsigned char tile_y<map_bat_y>, unsigned char tile_w<map_draw_x>, unsigned char tile_h<map_draw_y> );
 1523                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 141; extern unsigned char __fastcall sgx_get_map_block( unsigned int x<map_pxl_x>, unsigned int y<map_pxl_y> );
 1524                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 143; #asm
 1525                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 144; .macro	_sgx_set_blkmap.2
 1526                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 145; stz	sgx_scr_bank
 1527                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 146; .endm
 1528                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 148; .macro	_sgx_set_multimap.2
 1529                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 149; lda	sgx_bat_width
 1530                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 150; lsr	a
 1531                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 151; sta	sgx_map_line_w
 1532                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 152; .endm
 1533                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 153; #endasm
 1534                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 155; #endif
 1535                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 157; #endif // __HUCC__
 1536                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 159; #endif // _hucc_blkmap_h
 1537                        		.dbg	line,	"include\variables.c", 13; unsigned char   sequence_id,
 1538                        		.dbg	line,	"include\variables.c", 14; sequence_loaded,
 1539                        		.dbg	line,	"include\variables.c", 16; level_id,
 1540                        		.dbg	line,	"include\variables.c", 18; player_id,
 1541                        		.dbg	line,	"include\variables.c", 19; player_state,
 1542                        		.dbg	line,	"include\variables.c", 20; player_axis,
 1543                        		.dbg	line,	"include\variables.c", 21; player_previous_axis,
 1544                        		.dbg	line,	"include\variables.c", 22; player_counter_anim,
 1545                        		.dbg	line,	"include\variables.c", 23; player_index_jump;
 1546                        		.dbg	line,	"include\variables.c", 28; signed int      player_pos_x,
 1547                        		.dbg	line,	"include\variables.c", 29; player_pos_y;
 1548                        		.dbg	line,	"include\variables.c", 34; extern unsigned char tileset_LV1_BG_B[];
 1549                        		.dbg	line,	"include\variables.c", 35; extern unsigned char multimap_LV1_BG_B[];
 1550                        		.dbg	line,	"include\variables.c", 37; extern unsigned char tileset_LV1_BG_A[];
 1551                        		.dbg	line,	"include\variables.c", 38; extern unsigned char multimap_LV1_BG_A[];
 1552                        		.dbg	line,	"main.c", 15; #include "include/gfx_BG.c"
 1553                        		.dbg	line,	"include\gfx_BG.c", 1; #include "huc.h"
 1554                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 1; #ifndef _hucc_legacy_h
 1555                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 2; #define _hucc_legacy_h
 1556                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 4; /****************************************************************************
 1557                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 5; ; ***************************************************************************
 1558                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 6; ;
 1559                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 7; ; huc.h
 1560                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 8; ;
 1561                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 9; ; HuCC wrapper file to include a default set of HuC-compatible functions.
 1562                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 10; ;
 1563                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 11; ; Copyright John Brandwood 2024.
 1564                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 12; ;
 1565                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 13; ; Distributed under the Boost Software License, Version 1.0.
 1566                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 14; ; (See accompanying file LICENSE_1_0.txt or copy at
 1567                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 15; ;  http://www.boost.org/LICENSE_1_0.txt)
 1568                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 16; ;
 1569                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 17; ; ***************************************************************************
 1570                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 18; ; ***************************************************************************
 1571                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 19; ;
 1572                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 20; ; When the HuCC compiler is invoked with the "--legacy" option to compile old
 1573                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 21; ; projects, then this "huc.h" file is automatically included.
 1574                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 22; ;
 1575                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 23; ; This file includes a set of the individual HuCC headers which correspond to
 1576                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 24; ; HuC's built-in functions and MagicKit library.
 1577                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 25; ;
 1578                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 26; ; New HuCC projects should, preferably, include the specific headers that are
 1579                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 27; ; needed, which will then allow them to replace parts of the standard library
 1580                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 28; ; with newer functions, or they can just manually include this "huc.h" file.
 1581                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 29; ;
 1582                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 30; ; ***************************************************************************
 1583                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 31; ; **************************************************************************/
 1584                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 33; #include "hucc-systemcard.h"
 1585                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 34; #include "hucc-baselib.h"
 1586                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 35; #include "hucc-gfx.h"
 1587                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 36; #include "hucc-string.h"
 1588                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 37; #include "hucc-old-scroll.h"
 1589                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 38; #include "hucc-old-spr.h"
 1590                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 39; #include "hucc-old-map.h"
 1591                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 40; #include "hucc-old-line.h"
 1592                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 42; #endif // _hucc_legacy_h
 1593                        		.dbg	line,	"include\gfx_BG.c", 2; #include "hucc-scroll.h"
 1594                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 1; #ifndef _hucc_scroll_h
 1595                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 2; #define _hucc_scroll_h
 1596                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 4; /****************************************************************************
 1597                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 5; ; ***************************************************************************
 1598                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 6; ;
 1599                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 7; ; hucc-scroll.h
 1600                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 8; ;
 1601                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 9; ; Routines for a fast split-screen scrolling system.
 1602                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 10; ;
 1603                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 11; ; Copyright John Brandwood 2024.
 1604                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 12; ;
 1605                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 13; ; Distributed under the Boost Software License, Version 1.0.
 1606                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 14; ; (See accompanying file LICENSE_1_0.txt or copy at
 1607                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 15; ;  http://www.boost.org/LICENSE_1_0.txt)
 1608                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 16; ;
 1609                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 17; ; ***************************************************************************
 1610                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 18; ; ***************************************************************************
 1611                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 19; ;
 1612                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 20; ; The maximum number of splits for each screen layer is set in your project's
 1613                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 21; ; "hucc-config.inc" file, with the library having a limit of 128-per-layer.
 1614                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 22; ;
 1615                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 23; ; Your first active split must be defined to start at screen line 0, and then
 1616                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 24; ; the rest of the active splits must be in increasing line order to match the
 1617                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 25; ; way that the PC Engine displays the output image.
 1618                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 26; ;
 1619                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 27; ; You can have disabled splits interleaved with your active splits.
 1620                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 28; ;
 1621                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 29; ; Splits that are normally disabled can be used to create full screen effects
 1622                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 30; ; such as bouncing the screen up and down by adding blank areas at the top or
 1623                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 31; ; bottom of the screen, and then rapidly changing the height of those areas.
 1624                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 32; ;
 1625                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 33; ; ***************************************************************************
 1626                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 34; ; **************************************************************************/
 1627                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 36; // *************
 1628                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 37; // VDC bits for display_flags ...
 1629                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 38; // *************
 1630                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 40; #ifndef BKG_OFF
 1631                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 41; #define BKG_OFF 0x00
 1632                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 42; #endif
 1633                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 44; #ifndef SPR_OFF
 1634                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 45; #define SPR_OFF 0x00
 1635                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 46; #endif
 1636                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 48; #ifndef BKG_ON
 1637                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 49; #define BKG_ON 0x80
 1638                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 50; #endif
 1639                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 52; #ifndef SPR_ON
 1640                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 53; #define SPR_ON 0x40
 1641                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 54; #endif
 1642                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 56; // *************
 1643                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 57; // Functions in hucc-scroll.asm ...
 1644                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 58; // *************
 1645                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 60; #ifdef __HUCC__
 1646                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 62; #asmdef	HUCC_USES_NEW_SCROLL 1
 1647                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 64; extern void __fastcall scroll_split( unsigned char index<_al>, unsigned char screen_line<_ah>, unsigned int bat_x<_bx>, unsigned int bat_y<_cx>, unsigned char display_flags<_dl> );
 1648                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 65; extern void __fastcall sgx_scroll_split( unsigned char index<_al>, unsigned char screen_line<_ah>, unsigned int bat_x<_bx>, unsigned int bat_y<_cx>, unsigned char display_flags<_dl> );
 1649                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 67; extern void __fastcall disable_split( unsigned char index<acc> );
 1650                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 68; extern void __fastcall sgx_disable_split( unsigned char index<acc> );
 1651                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 70; extern void __fastcall __macro disable_all_splits( void );
 1652                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 71; extern void __fastcall __macro sgx_disable_all_splits( void );
 1653                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 73; #asm
 1654                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 74; .macro	_disable_all_splits
 1655                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 75; ldy	#HUCC_PCE_SPLITS - 1
 1656                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 76; !loop:		tya
 1657                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 77; call	_disable_split.1
 1658                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 78; dey
 1659                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 79; bpl	!loop-
 1660                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 80; .endm
 1661                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 82; .macro	_sgx_disable_all_splits
 1662                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 83; ldy	#HUCC_SGX_SPLITS - 1
 1663                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 84; !loop:		tya
 1664                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 85; call	_sgx_disable_split.1
 1665                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 86; dey
 1666                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 87; bpl	!loop-
 1667                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 88; .endm
 1668                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 89; #endasm
 1669                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 91; #endif // __HUCC__
 1670                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 93; #endif // _hucc_scroll_h
 1671                        		.dbg	line,	"include\gfx_BG.c", 3; #include "hucc-chrmap.h"
 1672                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 1; #ifndef _hucc_chrmap_h
 1673                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 2; #define _hucc_chrmap_h
 1674                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 4; /****************************************************************************
 1675                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 5; ; ***************************************************************************
 1676                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 6; ;
 1677                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 7; ; hucc-chrmap.h
 1678                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 8; ;
 1679                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 9; ; A simple map system based on 8x8 characters (aka "tiles") in BAT format.
 1680                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 10; ;
 1681                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 11; ; Copyright John Brandwood 2025.
 1682                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 12; ;
 1683                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 13; ; Distributed under the Boost Software License, Version 1.0.
 1684                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 14; ; (See accompanying file LICENSE_1_0.txt or copy at
 1685                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 15; ;  http://www.boost.org/LICENSE_1_0.txt)
 1686                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 16; ;
 1687                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 17; ; ***************************************************************************
 1688                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 18; ; ***************************************************************************
 1689                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 19; ;
 1690                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 20; ; The maximum X and Y size for chrmaps is 256 characters (2048 pixels).
 1691                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 21; ;
 1692                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 22; ; The maximum total size for a chrmap is 16KBytes, which allows for maps up
 1693                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 23; ; to 256x32 tiles (2048x256 pixels).
 1694                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 24; ;
 1695                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 25; ; ***************************************************************************
 1696                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 26; ; **************************************************************************/
 1697                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 28; // *************
 1698                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 29; // This code extends the blkmap library ...
 1699                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 30; // *************
 1700                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 32; #include "hucc-blkmap.h"
 1701                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 34; // *************
 1702                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 35; // Functions in chrmap.asm ...
 1703                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 36; // *************
 1704                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 38; #ifdef __HUCC__
 1705                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 40; #asmdef	HUCC_USES_CHRMAP 1
 1706                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 42; extern void __fastcall __nop set_chrmap( unsigned char __far *chrmap<vdc_map_bank:vdc_map_addr>, unsigned char tiles_w<vdc_map_line_w> );
 1707                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 44; extern void __fastcall draw_bat( void );
 1708                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 45; extern void __fastcall scroll_bat( void );
 1709                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 47; extern void __fastcall blit_bat( unsigned char tile_x<map_bat_x>, unsigned char tile_y<map_bat_y>, unsigned char tile_w<map_draw_x>, unsigned char tile_h<map_draw_y> );
 1710                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 49; #ifdef _SGX
 1711                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 51; extern void __fastcall __nop sgx_set_chrmap( unsigned char __far *chrmap<sgx_map_bank:sgx_map_addr>, unsigned char tiles_w<sgx_map_line_w> );
 1712                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 53; extern void __fastcall sgx_draw_bat( void );
 1713                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 54; extern void __fastcall sgx_scroll_bat( void );
 1714                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 56; extern void __fastcall sgx_blit_bat( unsigned char tile_x<map_bat_x>, unsigned char tile_y<map_bat_y>, unsigned char tile_w<map_draw_x>, unsigned char tile_h<map_draw_y> );
 1715                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 58; #endif
 1716                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 60; #endif // __HUCC__
 1717                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 62; #endif // _hucc_chrmap_h
 1718                        		.dbg	line,	"include\gfx_BG.c", 4; #include "hucc-blkmap.h"
 1719                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 1; #ifndef _hucc_blkmap_h
 1720                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 2; #define _hucc_blkmap_h
 1721                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 4; /****************************************************************************
 1722                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 5; ; ***************************************************************************
 1723                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 6; ;
 1724                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 7; ; hucc-blkmap.h
 1725                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 8; ;
 1726                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 9; ; A map system based on 16x16 meta-tiles (aka "blocks", aka CHR/BLK/MAP).
 1727                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 10; ;
 1728                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 11; ; Copyright John Brandwood 2025.
 1729                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 12; ;
 1730                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 13; ; Distributed under the Boost Software License, Version 1.0.
 1731                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 14; ; (See accompanying file LICENSE_1_0.txt or copy at
 1732                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 15; ;  http://www.boost.org/LICENSE_1_0.txt)
 1733                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 16; ;
 1734                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 17; ; ***************************************************************************
 1735                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 18; ; ***************************************************************************
 1736                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 19; ;
 1737                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 20; ; The maximum X and Y size for blkmaps is 128 blocks (2048 pixels).
 1738                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 21; ;
 1739                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 22; ; The maximum total size for a blkmap is 16KBytes, which allows for maps up
 1740                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 23; ; to 128x128 blocks (2048x2048 pixels).
 1741                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 24; ;
 1742                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 25; ; Huge multi-screen blkmaps are also supported (optionally).
 1743                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 26; ;
 1744                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 27; ; The maximum X and Y for multi-screen maps is 128 screens (32768 pixels).
 1745                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 28; ;
 1746                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 29; ; The maximum total size for a multi-screen map is 8KBytes, which allows for
 1747                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 30; ; a total of 1024 screens.
 1748                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 31; ;
 1749                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 32; ; ***************************************************************************
 1750                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 33; ; **************************************************************************/
 1751                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 35; // *************
 1752                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 36; // Functions in blkmap.asm ...
 1753                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 37; // *************
 1754                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 39; #ifdef __HUCC__
 1755                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 41; #asmdef	HUCC_USES_BLKMAP 1
 1756                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 43; // Current top-left of drawn map in pixels.
 1757                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 44; extern unsigned int   vdc_map_pxl_x;
 1758                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 45; extern unsigned int   vdc_map_pxl_y;
 1759                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 47; // Width and height to draw/scroll in characters (not tiles).
 1760                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 48; extern unsigned char  vdc_map_draw_w;
 1761                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 49; extern unsigned char  vdc_map_draw_h;
 1762                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 51; // Width of map (or multi-screen BAT) in tiles.
 1763                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 52; extern unsigned char  vdc_map_line_w;
 1764                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 54; // Width of map in screens (if multi-screen map).
 1765                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 55; extern unsigned char  vdc_map_scrn_w;
 1766                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 57; // Extra information returned by get_map_block() and sgx_get_map_block(),
 1767                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 58; // which are the collision flags and the mask/overlay sprite for the BLK.
 1768                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 59; extern unsigned char  map_blk_flag;
 1769                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 60; extern unsigned char  map_blk_mask;
 1770                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 62; extern unsigned char  vdc_scr_bank;
 1771                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 63; extern unsigned char *vdc_scr_addr;
 1772                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 65; extern unsigned char  vdc_map_bank;
 1773                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 66; extern unsigned char *vdc_map_addr;
 1774                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 68; extern unsigned char  vdc_blk_bank;
 1775                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 69; extern unsigned char *vdc_blk_addr;
 1776                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 71; extern unsigned char  vdc_tbl_bank;
 1777                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 72; extern unsigned char *vdc_tbl_addr;
 1778                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 74; extern void __fastcall set_blocks( unsigned char __far *blk_def<vdc_blk_bank:vdc_blk_addr>, unsigned char __far *flg_def<vdc_tbl_bank:vdc_tbl_addr>, unsigned char number_of_blocks<_al> );
 1779                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 75; extern void __fastcall __macro set_blkmap( unsigned char __far *blk_map<vdc_map_bank:vdc_map_addr>, unsigned char blocks_w<vdc_map_line_w> );
 1780                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 76; extern void __fastcall __macro set_multimap( unsigned char __far *multi_map<vdc_scr_bank:vdc_scr_addr>, unsigned char screens_w<vdc_map_scrn_w> );
 1781                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 78; extern void __fastcall draw_map( void );
 1782                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 79; extern void __fastcall scroll_map( void );
 1783                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 81; extern void __fastcall blit_map( unsigned char tile_x<map_bat_x>, unsigned char tile_y<map_bat_y>, unsigned char tile_w<map_draw_x>, unsigned char tile_h<map_draw_y> );
 1784                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 83; extern unsigned char __fastcall get_map_block( unsigned int x<map_pxl_x>, unsigned int y<map_pxl_y> );
 1785                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 85; #asm
 1786                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 86; .macro	_set_blkmap.2
 1787                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 87; stz	vdc_scr_bank
 1788                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 88; .endm
 1789                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 90; .macro	_set_multimap.2
 1790                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 91; lda	vdc_bat_width
 1791                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 92; lsr	a
 1792                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 93; sta	vdc_map_line_w
 1793                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 94; .endm
 1794                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 96; .macro	SCREEN
 1795                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 97; db	(((\1) & $1FFF) | $6000) >> 8, bank(\1)
 1796                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 98; db	(((\2) & $1FFF) | $4000) >> 8, bank(\2)
 1797                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 99; db	(((\3) & $1FFF) | $6000) >> 8, bank(\3)
 1798                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 100; dw	(\4)
 1799                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 101; .endm
 1800                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 102; #endasm
 1801                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 104; #ifdef _SGX
 1802                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 106; // Current top-left of drawn map in pixels.
 1803                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 107; extern unsigned int   sgx_map_pxl_x;
 1804                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 108; extern unsigned int   sgx_map_pxl_y;
 1805                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 110; // Width and height to draw/scroll in characters (not tiles).
 1806                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 111; extern unsigned char  sgx_map_draw_w;
 1807                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 112; extern unsigned char  sgx_map_draw_h;
 1808                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 114; // Width of map (or multi-screen BAT) in tiles.
 1809                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 115; extern unsigned char  sgx_map_line_w;
 1810                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 117; // Width of map in screens (if multi-screen map).
 1811                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 118; extern unsigned char  sgx_map_scrn_w;
 1812                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 120; extern unsigned char  sgx_scr_bank;
 1813                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 121; extern unsigned char *sgx_scr_addr;
 1814                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 123; extern unsigned char  sgx_map_bank;
 1815                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 124; extern unsigned char *sgx_map_addr;
 1816                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 126; extern unsigned char  sgx_blk_bank;
 1817                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 127; extern unsigned char *sgx_blk_addr;
 1818                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 129; extern unsigned char  sgx_tbl_bank;
 1819                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 130; extern unsigned char *sgx_tbl_addr;
 1820                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 132; extern void __fastcall sgx_set_blocks( unsigned char __far *blk_def<sgx_blk_bank:sgx_blk_addr>, unsigned char __far *flg_def<sgx_tbl_bank:sgx_tbl_addr>, unsigned char number_of_blocks<_al> );
 1821                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 133; extern void __fastcall __macro sgx_set_blkmap( unsigned char __far *blk_map<sgx_map_bank:sgx_map_addr>, unsigned char blocks_w<sgx_map_line_w> );
 1822                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 134; extern void __fastcall __macro sgx_set_multimap( unsigned char __far *multi_map<sgx_scr_bank:sgx_scr_addr>, unsigned char screens_w<sgx_map_scrn_w> );
 1823                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 136; extern void __fastcall sgx_draw_map( void );
 1824                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 137; extern void __fastcall sgx_scroll_map( void );
 1825                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 139; extern void __fastcall sgx_blit_map( unsigned char tile_x<map_bat_x>, unsigned char tile_y<map_bat_y>, unsigned char tile_w<map_draw_x>, unsigned char tile_h<map_draw_y> );
 1826                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 141; extern unsigned char __fastcall sgx_get_map_block( unsigned int x<map_pxl_x>, unsigned int y<map_pxl_y> );
 1827                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 143; #asm
 1828                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 144; .macro	_sgx_set_blkmap.2
 1829                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 145; stz	sgx_scr_bank
 1830                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 146; .endm
 1831                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 148; .macro	_sgx_set_multimap.2
 1832                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 149; lda	sgx_bat_width
 1833                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 150; lsr	a
 1834                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 151; sta	sgx_map_line_w
 1835                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 152; .endm
 1836                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 153; #endasm
 1837                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 155; #endif
 1838                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 157; #endif // __HUCC__
 1839                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 159; #endif // _hucc_blkmap_h
 1840                        		.dbg	line,	"include\gfx_BG.c", 13; //**************************************************************************************//
 1841                        		.dbg	line,	"include\gfx_BG.c", 14; //                                                                                      //
 1842                        		.dbg	line,	"include\gfx_BG.c", 15; //                                       LEVEL 1                                        //
 1843                        		.dbg	line,	"include\gfx_BG.c", 16; //                                                                                      //
 1844                        		.dbg	line,	"include\gfx_BG.c", 17; //**************************************************************************************//
 1845                        		.dbg	line,	"include\gfx_BG.c", 19; #incchr(tileset_LV1_WALL,"res/maps/tiles_LV1_WALL.png", 4 , 4);
 1846               6000     		.data
 1847    03:6000             	_tileset_LV1_WALL: 	.incchr		"res/maps/tiles_LV1_WALL.png", 4, 4
 1848               E309     		.code
 1849                        		.dbg	line,	"include\gfx_BG.c", 20; #incchr(tileset_LV1_DOOR_OPEN,"res/maps/tiles_LV1_DOOR_OPEN.png", 4 , 6);
 1850               6200     		.data
 1851    03:6200             	_tileset_LV1_DOOR_OPEN: 	.incchr		"res/maps/tiles_LV1_DOOR_OPEN.png", 4, 6
 1852               E309     		.code
 1853                        		.dbg	line,	"include\gfx_BG.c", 21; #incchr(tileset_LV1_DOOR_CLOSED,"res/maps/tiles_LV1_DOOR_CLOSED.png", 4 , 6);
 1854               6500     		.data
 1855    03:6500             	_tileset_LV1_DOOR_CLOSED: 	.incchr		"res/maps/tiles_LV1_DOOR_CLOSED.png", 4, 6
 1856               E309     		.code
 1857                        		.dbg	line,	"include\gfx_BG.c", 23; #incchr(tileset_LIFE_RED,"res/maps/tileset_LIFE_RED.png", 2 , 1);
 1858               6800     		.data
 1859    03:6800             	_tileset_LIFE_RED: 	.incchr		"res/maps/tileset_LIFE_RED.png", 2, 1
 1860               E309     		.code
 1861                        		.dbg	line,	"include\gfx_BG.c", 24; #incchr(tileset_LIFE_ORANGE,"res/maps/tileset_LIFE_ORANGE.png", 2 , 1);
 1862               6840     		.data
 1863    03:6840             	_tileset_LIFE_ORANGE: 	.incchr		"res/maps/tileset_LIFE_ORANGE.png", 2, 1
 1864               E309     		.code
 1865                        		.dbg	line,	"include\gfx_BG.c", 25; #incchr(tileset_LIFE_YELLOW,"res/maps/tileset_LIFE_YELLOW.png", 2 , 1);
 1866               6880     		.data
 1867    03:6880             	_tileset_LIFE_YELLOW: 	.incchr		"res/maps/tileset_LIFE_YELLOW.png", 2, 1
 1868               E309     		.code
 1869                        		.dbg	line,	"include\gfx_BG.c", 26; #incchr(tileset_LIFE_EMPTY,"res/maps/tileset_LIFE_EMPTY.png", 2 , 1);
 1870               68C0     		.data
 1871    03:68C0             	_tileset_LIFE_EMPTY: 	.incchr		"res/maps/tileset_LIFE_EMPTY.png", 2, 1
 1872               E309     		.code
 1873                        		.dbg	line,	"include\gfx_BG.c", 28; #incchr(tileset_ARMOR_1,"res/maps/tileset_ARMOR_1.png", 2 , 2);
 1874               6900     		.data
 1875    03:6900             	_tileset_ARMOR_1: 	.incchr		"res/maps/tileset_ARMOR_1.png", 2, 2
 1876               E309     		.code
 1877                        		.dbg	line,	"include\gfx_BG.c", 29; #incchr(tileset_ARMOR_2,"res/maps/tileset_ARMOR_2.png", 2 , 2);
 1878               6980     		.data
 1879    03:6980             	_tileset_ARMOR_2: 	.incchr		"res/maps/tileset_ARMOR_2.png", 2, 2
 1880               E309     		.code
 1881                        		.dbg	line,	"include\gfx_BG.c", 30; #incchr(tileset_ARMOR_4,"res/maps/tileset_ARMOR_4.png", 2 , 2);
 1882               6A00     		.data
 1883    03:6A00             	_tileset_ARMOR_4: 	.incchr		"res/maps/tileset_ARMOR_4.png", 2, 2
 1884               E309     		.code
 1885                        		.dbg	line,	"include\gfx_BG.c", 31; #incchr(tileset_ARMOR_8,"res/maps/tileset_ARMOR_8.png", 2 , 2);
 1886               6A80     		.data
 1887    03:6A80             	_tileset_ARMOR_8: 	.incchr		"res/maps/tileset_ARMOR_8.png", 2, 2
 1888               E309     		.code
 1889                        		.dbg	line,	"include\gfx_BG.c", 33; #incchr(tileset_WEAPON_1,"res/maps/tileset_WEAPON_1.png", 2 , 2);
 1890               6B00     		.data
 1891    03:6B00             	_tileset_WEAPON_1: 	.incchr		"res/maps/tileset_WEAPON_1.png", 2, 2
 1892               E309     		.code
 1893                        		.dbg	line,	"include\gfx_BG.c", 34; #incchr(tileset_WEAPON_2,"res/maps/tileset_WEAPON_2.png", 2 , 2);
 1894               6B80     		.data
 1895    03:6B80             	_tileset_WEAPON_2: 	.incchr		"res/maps/tileset_WEAPON_2.png", 2, 2
 1896               E309     		.code
 1897                        		.dbg	line,	"include\gfx_BG.c", 35; #incchr(tileset_WEAPON_4,"res/maps/tileset_WEAPON_4.png", 2 , 2);
 1898               6C00     		.data
 1899    03:6C00             	_tileset_WEAPON_4: 	.incchr		"res/maps/tileset_WEAPON_4.png", 2, 2
 1900               E309     		.code
 1901                        		.dbg	line,	"include\gfx_BG.c", 36; #incchr(tileset_WEAPON_5,"res/maps/tileset_WEAPON_5.png", 2 , 2);
 1902               6C80     		.data
 1903    03:6C80             	_tileset_WEAPON_5: 	.incchr		"res/maps/tileset_WEAPON_5.png", 2, 2
 1904               E309     		.code
 1905                        		.dbg	line,	"include\gfx_BG.c", 37; #incchr(tileset_WEAPON_8,"res/maps/tileset_WEAPON_8.png", 2 , 2);
 1906               6D00     		.data
 1907    03:6D00             	_tileset_WEAPON_8: 	.incchr		"res/maps/tileset_WEAPON_8.png", 2, 2
 1908               E309     		.code
 1909                        		.dbg	line,	"include\gfx_BG.c", 40; //--------------------------------------------------------------------------------------//
 1910                        		.dbg	line,	"include\gfx_BG.c", 41; //                                        VDC 2                                         //
 1911                        		.dbg	line,	"include\gfx_BG.c", 42; //--------------------------------------------------------------------------------------//
 1912                        		.dbg	line,	"include\gfx_BG.c", 44; #asm
 1913                        		.dbg	clear
 1914               0001     	OPTIMIZE	=	1
 1915               6D80     			.data
 1916                        	; EXTRACT TILESET
 1917                        	;----------------
 1918    03:6D80             	_tileset_LV1_BG_B:  incchr	"res/maps/template_LV1_WALL.png"
 1919    03:6F80             			incchr	"res/maps/template_LV1_DOOR.png"
 1920    03:7280             			incchr	"res/maps/tilemap_LV1_BG_B.png", OPTIMIZE
 1921                        	; EXTRACT BLOCKS
 1922                        	;--------------
 1923    07:6000             	blocks_LV1_BG_B1:	incblk	"res/maps/tilemap_LV1_BG_B.png" , 0x1000 ,    0 ,   0 ,  96 , 32 , _tileset_LV1_BG_B ; // 96x16 = 1536 | 32x16 =  512
 1924    07:6800             	blocks_LV1_BG_B2:	incblk	"res/maps/tilemap_LV1_BG_B.png" , 0x1000 , 1536 ,   0 ,  64 , 32 , _tileset_LV1_BG_B ; // 64x16 = 1024 | 32x16 =  512
 1925    07:7000             	blocks_LV1_BG_B3:	incblk	"res/maps/tilemap_LV1_BG_B.png" , 0x1000 ,    0 , 512 ,  96 , 16 , _tileset_LV1_BG_B ; // 96x16 = 1536 | 16x16 =  256
 1926    07:7800             	blocks_LV1_BG_B4:	incblk	"res/maps/tilemap_LV1_BG_B.png" , 0x1000 , 1536 , 512 ,  64 , 16 , _tileset_LV1_BG_B ; // 64x16 = 1024 | 16x16 =  256
 1927                        	; EXTRACT MAPS
 1928                        	;------------
 1929               6000     			align	256
 1930    08:6000             	MAP_LV1_BG_B1:		incmap	"res/maps/tilemap_LV1_BG_B.png",    0 ,   0 ,  96 , 32 , blocks_LV1_BG_B1 ; // 96x16 = 1536 | 32x16 =  512
 1931               6C00     			align	256
 1932    08:6C00             	MAP_LV1_BG_B2:		incmap	"res/maps/tilemap_LV1_BG_B.png", 1536 ,   0 ,  64 , 32 , blocks_LV1_BG_B2 ; // 64x16 = 1024 | 32x16 =  512
 1933               7400     			align	256
 1934    08:7400             	MAP_LV1_BG_B3:		incmap	"res/maps/tilemap_LV1_BG_B.png",    0 , 512 ,  96 , 16 , blocks_LV1_BG_B3 ; // 96x16 = 1536 | 16x16 =  256
 1935               7A00     			align	256
 1936    08:7A00             	MAP_LV1_BG_B4:		incmap	"res/maps/tilemap_LV1_BG_B.png", 1536 , 512 ,  64 , 16 , blocks_LV1_BG_B4 ; // 64x16 = 1024 | 16x16 =  256
 1937                        	; MASK (EMPTY)
 1938                        	;----------------
 1939    08:7E00  00 00 00 00	dummy_tbl:	ds	256
         08:7E04  00 00 00 00 
         08:7E08  00 00 00 00 
         08:7E0C  00 00 00 00 
         08:7E10  00 00 00 00 
         08:7E14  00 00 00 00 
         08:7E18  00 00 00 00 
         08:7E1C  00 00 00 00 
         08:7E20  00 00 00 00 
         08:7E24  00 00 00 00 
         08:7E28  00 00 00 00 
         08:7E2C  00 00 00 00 
         08:7E30  00 00 00 00 
         08:7E34  00 00 00 00 
         08:7E38  00 00 00 00 
         08:7E3C  00 00 00 00 
         08:7E40  00 00 00 00 
         08:7E44  00 00 00 00 
         08:7E48  00 00 00 00 
         08:7E4C  00 00 00 00 
         08:7E50  00 00 00 00 
         08:7E54  00 00 00 00 
         08:7E58  00 00 00 00 
         08:7E5C  00 00 00 00 
         08:7E60  00 00 00 00 
         08:7E64  00 00 00 00 
         08:7E68  00 00 00 00 
         08:7E6C  00 00 00 00 
         08:7E70  00 00 00 00 
         08:7E74  00 00 00 00 
         08:7E78  00 00 00 00 
         08:7E7C  00 00 00 00 
         08:7E80  00 00 00 00 
         08:7E84  00 00 00 00 
         08:7E88  00 00 00 00 
         08:7E8C  00 00 00 00 
         08:7E90  00 00 00 00 
         08:7E94  00 00 00 00 
         08:7E98  00 00 00 00 
         08:7E9C  00 00 00 00 
         08:7EA0  00 00 00 00 
         08:7EA4  00 00 00 00 
         08:7EA8  00 00 00 00 
         08:7EAC  00 00 00 00 
         08:7EB0  00 00 00 00 
         08:7EB4  00 00 00 00 
         08:7EB8  00 00 00 00 
         08:7EBC  00 00 00 00 
         08:7EC0  00 00 00 00 
         08:7EC4  00 00 00 00 
         08:7EC8  00 00 00 00 
         08:7ECC  00 00 00 00 
         08:7ED0  00 00 00 00 
         08:7ED4  00 00 00 00 
         08:7ED8  00 00 00 00 
         08:7EDC  00 00 00 00 
         08:7EE0  00 00 00 00 
         08:7EE4  00 00 00 00 
         08:7EE8  00 00 00 00 
         08:7EEC  00 00 00 00 
         08:7EF0  00 00 00 00 
         08:7EF4  00 00 00 00 
         08:7EF8  00 00 00 00 
         08:7EFC  00 00 00 00 
 1940                        	; SWIZZLE MAPS
 1941                        	;-------------
 1942    08:7F00             	swizzle	MAP_LV1_BG_B1,  32, 16 ;
 1943    08:7F00             	swizzle	MAP_LV1_BG_B2,  32, 16 ;
 1944    08:7F00             	swizzle	MAP_LV1_BG_B3,  32, 16 ;
 1945    08:7F00             	swizzle	MAP_LV1_BG_B4,  32, 16 ;
 1946                        	; BUILD MULTIMAP
 1947                        	;---------------
 1948    08:7F00             	_multimap_LV1_BG_B:
 1949                        			; 1st line of 5 screens (512x256)
 1950                        			SCREEN MAP_LV1_BG_B1 + 0x0000, blocks_LV1_BG_B1, dummy_tbl, 0
         08:7F00  60 08      			db	(((MAP_LV1_BG_B1 + 0x0000) & $1FFF) | $6000) >> 8, bank(MAP_LV1_BG_B1 + 0x0000)
         08:7F02  40 07      			db	(((blocks_LV1_BG_B1) & $1FFF) | $4000) >> 8, bank(blocks_LV1_BG_B1)
         08:7F04  7E 08      			db	(((dummy_tbl) & $1FFF) | $6000) >> 8, bank(dummy_tbl)
         08:7F06  00 00      			dw	(0)
 1951                        			SCREEN MAP_LV1_BG_B1 + 0x0200, blocks_LV1_BG_B1, dummy_tbl, 0
         08:7F08  62 08      			db	(((MAP_LV1_BG_B1 + 0x0200) & $1FFF) | $6000) >> 8, bank(MAP_LV1_BG_B1 + 0x0200)
         08:7F0A  40 07      			db	(((blocks_LV1_BG_B1) & $1FFF) | $4000) >> 8, bank(blocks_LV1_BG_B1)
         08:7F0C  7E 08      			db	(((dummy_tbl) & $1FFF) | $6000) >> 8, bank(dummy_tbl)
         08:7F0E  00 00      			dw	(0)
 1952                        			SCREEN MAP_LV1_BG_B1 + 0x0400, blocks_LV1_BG_B1, dummy_tbl, 0
         08:7F10  64 08      			db	(((MAP_LV1_BG_B1 + 0x0400) & $1FFF) | $6000) >> 8, bank(MAP_LV1_BG_B1 + 0x0400)
         08:7F12  40 07      			db	(((blocks_LV1_BG_B1) & $1FFF) | $4000) >> 8, bank(blocks_LV1_BG_B1)
         08:7F14  7E 08      			db	(((dummy_tbl) & $1FFF) | $6000) >> 8, bank(dummy_tbl)
         08:7F16  00 00      			dw	(0)
 1953                        			SCREEN MAP_LV1_BG_B2 + 0x0000, blocks_LV1_BG_B2, dummy_tbl, 0
         08:7F18  6C 08      			db	(((MAP_LV1_BG_B2 + 0x0000) & $1FFF) | $6000) >> 8, bank(MAP_LV1_BG_B2 + 0x0000)
         08:7F1A  48 07      			db	(((blocks_LV1_BG_B2) & $1FFF) | $4000) >> 8, bank(blocks_LV1_BG_B2)
         08:7F1C  7E 08      			db	(((dummy_tbl) & $1FFF) | $6000) >> 8, bank(dummy_tbl)
         08:7F1E  00 00      			dw	(0)
 1954                        			SCREEN MAP_LV1_BG_B2 + 0x0200, blocks_LV1_BG_B2, dummy_tbl, 0
         08:7F20  6E 08      			db	(((MAP_LV1_BG_B2 + 0x0200) & $1FFF) | $6000) >> 8, bank(MAP_LV1_BG_B2 + 0x0200)
         08:7F22  48 07      			db	(((blocks_LV1_BG_B2) & $1FFF) | $4000) >> 8, bank(blocks_LV1_BG_B2)
         08:7F24  7E 08      			db	(((dummy_tbl) & $1FFF) | $6000) >> 8, bank(dummy_tbl)
         08:7F26  00 00      			dw	(0)
 1955                        			; 2nd line of 5 screens (512x256)
 1956                        			SCREEN MAP_LV1_BG_B1 + 0x0600, blocks_LV1_BG_B1, dummy_tbl, 0
         08:7F28  66 08      			db	(((MAP_LV1_BG_B1 + 0x0600) & $1FFF) | $6000) >> 8, bank(MAP_LV1_BG_B1 + 0x0600)
         08:7F2A  40 07      			db	(((blocks_LV1_BG_B1) & $1FFF) | $4000) >> 8, bank(blocks_LV1_BG_B1)
         08:7F2C  7E 08      			db	(((dummy_tbl) & $1FFF) | $6000) >> 8, bank(dummy_tbl)
         08:7F2E  00 00      			dw	(0)
 1957                        			SCREEN MAP_LV1_BG_B1 + 0x0800, blocks_LV1_BG_B1, dummy_tbl, 0
         08:7F30  68 08      			db	(((MAP_LV1_BG_B1 + 0x0800) & $1FFF) | $6000) >> 8, bank(MAP_LV1_BG_B1 + 0x0800)
         08:7F32  40 07      			db	(((blocks_LV1_BG_B1) & $1FFF) | $4000) >> 8, bank(blocks_LV1_BG_B1)
         08:7F34  7E 08      			db	(((dummy_tbl) & $1FFF) | $6000) >> 8, bank(dummy_tbl)
         08:7F36  00 00      			dw	(0)
 1958                        			SCREEN MAP_LV1_BG_B1 + 0x0A00, blocks_LV1_BG_B1, dummy_tbl, 0
         08:7F38  6A 08      			db	(((MAP_LV1_BG_B1 + 0x0A00) & $1FFF) | $6000) >> 8, bank(MAP_LV1_BG_B1 + 0x0A00)
         08:7F3A  40 07      			db	(((blocks_LV1_BG_B1) & $1FFF) | $4000) >> 8, bank(blocks_LV1_BG_B1)
         08:7F3C  7E 08      			db	(((dummy_tbl) & $1FFF) | $6000) >> 8, bank(dummy_tbl)
         08:7F3E  00 00      			dw	(0)
 1959                        			SCREEN MAP_LV1_BG_B2 + 0x0400, blocks_LV1_BG_B2, dummy_tbl, 0
         08:7F40  70 08      			db	(((MAP_LV1_BG_B2 + 0x0400) & $1FFF) | $6000) >> 8, bank(MAP_LV1_BG_B2 + 0x0400)
         08:7F42  48 07      			db	(((blocks_LV1_BG_B2) & $1FFF) | $4000) >> 8, bank(blocks_LV1_BG_B2)
         08:7F44  7E 08      			db	(((dummy_tbl) & $1FFF) | $6000) >> 8, bank(dummy_tbl)
         08:7F46  00 00      			dw	(0)
 1960                        			SCREEN MAP_LV1_BG_B2 + 0x0600, blocks_LV1_BG_B2, dummy_tbl, 0
         08:7F48  72 08      			db	(((MAP_LV1_BG_B2 + 0x0600) & $1FFF) | $6000) >> 8, bank(MAP_LV1_BG_B2 + 0x0600)
         08:7F4A  48 07      			db	(((blocks_LV1_BG_B2) & $1FFF) | $4000) >> 8, bank(blocks_LV1_BG_B2)
         08:7F4C  7E 08      			db	(((dummy_tbl) & $1FFF) | $6000) >> 8, bank(dummy_tbl)
         08:7F4E  00 00      			dw	(0)
 1961                        			; 3rd line of 5 screens (512x256)
 1962                        			SCREEN MAP_LV1_BG_B3 + 0x0000, blocks_LV1_BG_B3, dummy_tbl, 0
         08:7F50  74 08      			db	(((MAP_LV1_BG_B3 + 0x0000) & $1FFF) | $6000) >> 8, bank(MAP_LV1_BG_B3 + 0x0000)
         08:7F52  50 07      			db	(((blocks_LV1_BG_B3) & $1FFF) | $4000) >> 8, bank(blocks_LV1_BG_B3)
         08:7F54  7E 08      			db	(((dummy_tbl) & $1FFF) | $6000) >> 8, bank(dummy_tbl)
         08:7F56  00 00      			dw	(0)
 1963                        			SCREEN MAP_LV1_BG_B3 + 0x0200, blocks_LV1_BG_B3, dummy_tbl, 0
         08:7F58  76 08      			db	(((MAP_LV1_BG_B3 + 0x0200) & $1FFF) | $6000) >> 8, bank(MAP_LV1_BG_B3 + 0x0200)
         08:7F5A  50 07      			db	(((blocks_LV1_BG_B3) & $1FFF) | $4000) >> 8, bank(blocks_LV1_BG_B3)
         08:7F5C  7E 08      			db	(((dummy_tbl) & $1FFF) | $6000) >> 8, bank(dummy_tbl)
         08:7F5E  00 00      			dw	(0)
 1964                        			SCREEN MAP_LV1_BG_B3 + 0x0400, blocks_LV1_BG_B3, dummy_tbl, 0
         08:7F60  78 08      			db	(((MAP_LV1_BG_B3 + 0x0400) & $1FFF) | $6000) >> 8, bank(MAP_LV1_BG_B3 + 0x0400)
         08:7F62  50 07      			db	(((blocks_LV1_BG_B3) & $1FFF) | $4000) >> 8, bank(blocks_LV1_BG_B3)
         08:7F64  7E 08      			db	(((dummy_tbl) & $1FFF) | $6000) >> 8, bank(dummy_tbl)
         08:7F66  00 00      			dw	(0)
 1965                        			SCREEN MAP_LV1_BG_B4 + 0x0000, blocks_LV1_BG_B4, dummy_tbl, 0
         08:7F68  7A 08      			db	(((MAP_LV1_BG_B4 + 0x0000) & $1FFF) | $6000) >> 8, bank(MAP_LV1_BG_B4 + 0x0000)
         08:7F6A  58 07      			db	(((blocks_LV1_BG_B4) & $1FFF) | $4000) >> 8, bank(blocks_LV1_BG_B4)
         08:7F6C  7E 08      			db	(((dummy_tbl) & $1FFF) | $6000) >> 8, bank(dummy_tbl)
         08:7F6E  00 00      			dw	(0)
 1966                        			SCREEN MAP_LV1_BG_B4 + 0x0200, blocks_LV1_BG_B4, dummy_tbl, 0
         08:7F70  7C 08      			db	(((MAP_LV1_BG_B4 + 0x0200) & $1FFF) | $6000) >> 8, bank(MAP_LV1_BG_B4 + 0x0200)
         08:7F72  58 07      			db	(((blocks_LV1_BG_B4) & $1FFF) | $4000) >> 8, bank(blocks_LV1_BG_B4)
         08:7F74  7E 08      			db	(((dummy_tbl) & $1FFF) | $6000) >> 8, bank(dummy_tbl)
         08:7F76  00 00      			dw	(0)
 1967                        	;//--------------------------------------------------------------------------------------//
 1968                        	;//                                        VDC 1                                         //
 1969                        	;//--------------------------------------------------------------------------------------//
 1970                        	; EXTRACT TILESET
 1971                        	;----------------
 1972    08:7F78             	_tileset_LV1_BG_A:	incchr	"res/maps/template_LIFEBAR_1.png"
 1973    08:7FB8             			incchr	"res/maps/template_LIFEBAR_2.png"
 1974    08:7FF8             			incchr	"res/maps/template_LIFEBAR_3.png"
 1975    09:6038             			incchr	"res/maps/template_LIFEBAR_4.png"
 1976    09:6078             			incchr	"res/maps/template_LIFEBAR_5.png"
 1977    09:60B8             			incchr	"res/maps/tileset_WEAPON_1.png"
 1978    09:6138             			incchr	"res/maps/tileset_ARMOR_1.png"
 1979    09:61B8             			incchr	"res/maps/tilemap_LV1_BG_A.png", OPTIMIZE
 1980                        	; EXTRACT BLOCKS
 1981                        	;--------------
 1982    09:6800             	blocks_LV1_BG_A1:	incblk	"res/maps/tilemap_LV1_BG_A.png" , 0x1000 ,    0 ,   0 , 128 , 48 , _tileset_LV1_BG_A ; // 128x16 = 2048 | 64x16 = 1024
 1983    09:7000             	blocks_LV1_BG_A2:	incblk	"res/maps/tilemap_LV1_BG_A.png" , 0x1000 , 2048 ,   0 ,  32 , 48 , _tileset_LV1_BG_A ; //  32x16 =  512 | 64x16 = 1024
 1984                        	; EXTRACT MAPS
 1985                        	;------------
 1986               7800     			align	256
 1987    09:7800             	MAP_LV1_BG_A1:		incmap	"res/maps/tilemap_LV1_BG_A.png",    0 ,   0 , 128 , 48 , blocks_LV1_BG_A1 ; // 128x16 = 2048 | 64x16 = 1024
 1988    0A:7000             			flagmap "res/maps/collision_LV1.png",       0 ,   0 , 128 , 48 , MAP_LV1_BG_A1
 1989               7000     			align	256
 1990    0A:7000             	MAP_LV1_BG_A2:		incmap	"res/maps/tilemap_LV1_BG_A.png", 2048 ,   0 ,  32 , 48 , blocks_LV1_BG_A2 ; //  32x16 =  512 | 64x16 = 1024
 1991    0A:7600             			flagmap "res/maps/collision_LV1.png",    2048 ,   0 ,  32 , 48 , MAP_LV1_BG_A2
 1992                        	; SWIZZLE MAPS
 1993                        	;-------------
 1994    0A:7600             	swizzle	MAP_LV1_BG_A1,  32, 16 ;
 1995    0A:7600             	swizzle	MAP_LV1_BG_A2,  32, 16 ;
 1996                        	; BUILD MULTIMAP
 1997                        	;---------------
 1998    0A:7600             	_multimap_LV1_BG_A:
 1999                        			; 1st line of 5 screens (512x256)
 2000                        			SCREEN MAP_LV1_BG_A1 + 0x0000, blocks_LV1_BG_A1, dummy_tbl, 0
         0A:7600  78 09      			db	(((MAP_LV1_BG_A1 + 0x0000) & $1FFF) | $6000) >> 8, bank(MAP_LV1_BG_A1 + 0x0000)
         0A:7602  48 09      			db	(((blocks_LV1_BG_A1) & $1FFF) | $4000) >> 8, bank(blocks_LV1_BG_A1)
         0A:7604  7E 08      			db	(((dummy_tbl) & $1FFF) | $6000) >> 8, bank(dummy_tbl)
         0A:7606  00 00      			dw	(0)
 2001                        			SCREEN MAP_LV1_BG_A1 + 0x0200, blocks_LV1_BG_A1, dummy_tbl, 0
         0A:7608  7A 09      			db	(((MAP_LV1_BG_A1 + 0x0200) & $1FFF) | $6000) >> 8, bank(MAP_LV1_BG_A1 + 0x0200)
         0A:760A  48 09      			db	(((blocks_LV1_BG_A1) & $1FFF) | $4000) >> 8, bank(blocks_LV1_BG_A1)
         0A:760C  7E 08      			db	(((dummy_tbl) & $1FFF) | $6000) >> 8, bank(dummy_tbl)
         0A:760E  00 00      			dw	(0)
 2002                        			SCREEN MAP_LV1_BG_A1 + 0x0400, blocks_LV1_BG_A1, dummy_tbl, 0
         0A:7610  7C 09      			db	(((MAP_LV1_BG_A1 + 0x0400) & $1FFF) | $6000) >> 8, bank(MAP_LV1_BG_A1 + 0x0400)
         0A:7612  48 09      			db	(((blocks_LV1_BG_A1) & $1FFF) | $4000) >> 8, bank(blocks_LV1_BG_A1)
         0A:7614  7E 08      			db	(((dummy_tbl) & $1FFF) | $6000) >> 8, bank(dummy_tbl)
         0A:7616  00 00      			dw	(0)
 2003                        			SCREEN MAP_LV1_BG_A1 + 0x0600, blocks_LV1_BG_A1, dummy_tbl, 0
         0A:7618  7E 09      			db	(((MAP_LV1_BG_A1 + 0x0600) & $1FFF) | $6000) >> 8, bank(MAP_LV1_BG_A1 + 0x0600)
         0A:761A  48 09      			db	(((blocks_LV1_BG_A1) & $1FFF) | $4000) >> 8, bank(blocks_LV1_BG_A1)
         0A:761C  7E 08      			db	(((dummy_tbl) & $1FFF) | $6000) >> 8, bank(dummy_tbl)
         0A:761E  00 00      			dw	(0)
 2004                        			SCREEN MAP_LV1_BG_A2 + 0x0000, blocks_LV1_BG_A2, dummy_tbl, 0
         0A:7620  70 0A      			db	(((MAP_LV1_BG_A2 + 0x0000) & $1FFF) | $6000) >> 8, bank(MAP_LV1_BG_A2 + 0x0000)
         0A:7622  50 09      			db	(((blocks_LV1_BG_A2) & $1FFF) | $4000) >> 8, bank(blocks_LV1_BG_A2)
         0A:7624  7E 08      			db	(((dummy_tbl) & $1FFF) | $6000) >> 8, bank(dummy_tbl)
         0A:7626  00 00      			dw	(0)
 2005                        			; 2nd line of 5 screens (512x256)
 2006                        			SCREEN MAP_LV1_BG_A1 + 0x0800, blocks_LV1_BG_A1, dummy_tbl, 0
         0A:7628  60 0A      			db	(((MAP_LV1_BG_A1 + 0x0800) & $1FFF) | $6000) >> 8, bank(MAP_LV1_BG_A1 + 0x0800)
         0A:762A  48 09      			db	(((blocks_LV1_BG_A1) & $1FFF) | $4000) >> 8, bank(blocks_LV1_BG_A1)
         0A:762C  7E 08      			db	(((dummy_tbl) & $1FFF) | $6000) >> 8, bank(dummy_tbl)
         0A:762E  00 00      			dw	(0)
 2007                        			SCREEN MAP_LV1_BG_A1 + 0x0A00, blocks_LV1_BG_A1, dummy_tbl, 0
         0A:7630  62 0A      			db	(((MAP_LV1_BG_A1 + 0x0A00) & $1FFF) | $6000) >> 8, bank(MAP_LV1_BG_A1 + 0x0A00)
         0A:7632  48 09      			db	(((blocks_LV1_BG_A1) & $1FFF) | $4000) >> 8, bank(blocks_LV1_BG_A1)
         0A:7634  7E 08      			db	(((dummy_tbl) & $1FFF) | $6000) >> 8, bank(dummy_tbl)
         0A:7636  00 00      			dw	(0)
 2008                        			SCREEN MAP_LV1_BG_A1 + 0x0C00, blocks_LV1_BG_A1, dummy_tbl, 0
         0A:7638  64 0A      			db	(((MAP_LV1_BG_A1 + 0x0C00) & $1FFF) | $6000) >> 8, bank(MAP_LV1_BG_A1 + 0x0C00)
         0A:763A  48 09      			db	(((blocks_LV1_BG_A1) & $1FFF) | $4000) >> 8, bank(blocks_LV1_BG_A1)
         0A:763C  7E 08      			db	(((dummy_tbl) & $1FFF) | $6000) >> 8, bank(dummy_tbl)
         0A:763E  00 00      			dw	(0)
 2009                        			SCREEN MAP_LV1_BG_A1 + 0x0E00, blocks_LV1_BG_A1, dummy_tbl, 0
         0A:7640  66 0A      			db	(((MAP_LV1_BG_A1 + 0x0E00) & $1FFF) | $6000) >> 8, bank(MAP_LV1_BG_A1 + 0x0E00)
         0A:7642  48 09      			db	(((blocks_LV1_BG_A1) & $1FFF) | $4000) >> 8, bank(blocks_LV1_BG_A1)
         0A:7644  7E 08      			db	(((dummy_tbl) & $1FFF) | $6000) >> 8, bank(dummy_tbl)
         0A:7646  00 00      			dw	(0)
 2010                        			SCREEN MAP_LV1_BG_A2 + 0x0200, blocks_LV1_BG_A2, dummy_tbl, 0
         0A:7648  72 0A      			db	(((MAP_LV1_BG_A2 + 0x0200) & $1FFF) | $6000) >> 8, bank(MAP_LV1_BG_A2 + 0x0200)
         0A:764A  50 09      			db	(((blocks_LV1_BG_A2) & $1FFF) | $4000) >> 8, bank(blocks_LV1_BG_A2)
         0A:764C  7E 08      			db	(((dummy_tbl) & $1FFF) | $6000) >> 8, bank(dummy_tbl)
         0A:764E  00 00      			dw	(0)
 2011                        			; 3rd line of 5 screens (512x256)
 2012                        			SCREEN MAP_LV1_BG_A1 + 0x1000, blocks_LV1_BG_A1, dummy_tbl, 0
         0A:7650  68 0A      			db	(((MAP_LV1_BG_A1 + 0x1000) & $1FFF) | $6000) >> 8, bank(MAP_LV1_BG_A1 + 0x1000)
         0A:7652  48 09      			db	(((blocks_LV1_BG_A1) & $1FFF) | $4000) >> 8, bank(blocks_LV1_BG_A1)
         0A:7654  7E 08      			db	(((dummy_tbl) & $1FFF) | $6000) >> 8, bank(dummy_tbl)
         0A:7656  00 00      			dw	(0)
 2013                        			SCREEN MAP_LV1_BG_A1 + 0x1200, blocks_LV1_BG_A1, dummy_tbl, 0
         0A:7658  6A 0A      			db	(((MAP_LV1_BG_A1 + 0x1200) & $1FFF) | $6000) >> 8, bank(MAP_LV1_BG_A1 + 0x1200)
         0A:765A  48 09      			db	(((blocks_LV1_BG_A1) & $1FFF) | $4000) >> 8, bank(blocks_LV1_BG_A1)
         0A:765C  7E 08      			db	(((dummy_tbl) & $1FFF) | $6000) >> 8, bank(dummy_tbl)
         0A:765E  00 00      			dw	(0)
 2014                        			SCREEN MAP_LV1_BG_A1 + 0x1400, blocks_LV1_BG_A1, dummy_tbl, 0
         0A:7660  6C 0A      			db	(((MAP_LV1_BG_A1 + 0x1400) & $1FFF) | $6000) >> 8, bank(MAP_LV1_BG_A1 + 0x1400)
         0A:7662  48 09      			db	(((blocks_LV1_BG_A1) & $1FFF) | $4000) >> 8, bank(blocks_LV1_BG_A1)
         0A:7664  7E 08      			db	(((dummy_tbl) & $1FFF) | $6000) >> 8, bank(dummy_tbl)
         0A:7666  00 00      			dw	(0)
 2015                        			SCREEN MAP_LV1_BG_A1 + 0x1600, blocks_LV1_BG_A1, dummy_tbl, 0
         0A:7668  6E 0A      			db	(((MAP_LV1_BG_A1 + 0x1600) & $1FFF) | $6000) >> 8, bank(MAP_LV1_BG_A1 + 0x1600)
         0A:766A  48 09      			db	(((blocks_LV1_BG_A1) & $1FFF) | $4000) >> 8, bank(blocks_LV1_BG_A1)
         0A:766C  7E 08      			db	(((dummy_tbl) & $1FFF) | $6000) >> 8, bank(dummy_tbl)
         0A:766E  00 00      			dw	(0)
 2016                        			SCREEN MAP_LV1_BG_A2 + 0x0400, blocks_LV1_BG_A2, dummy_tbl, 0
         0A:7670  74 0A      			db	(((MAP_LV1_BG_A2 + 0x0400) & $1FFF) | $6000) >> 8, bank(MAP_LV1_BG_A2 + 0x0400)
         0A:7672  50 09      			db	(((blocks_LV1_BG_A2) & $1FFF) | $4000) >> 8, bank(blocks_LV1_BG_A2)
         0A:7674  7E 08      			db	(((dummy_tbl) & $1FFF) | $6000) >> 8, bank(dummy_tbl)
         0A:7676  00 00      			dw	(0)
 2017               E309     			.code
 2018                        	
 2019                        		.dbg	line,	"include\gfx_BG.c", 188; #endasm
 2020                        		.dbg	line,	"include\gfx_BG.c", 192; //--------------------------------------------------------------------------------------//
 2021                        		.dbg	line,	"include\gfx_BG.c", 193; //                                   EXTRACT PALETTES                                   //
 2022                        		.dbg	line,	"include\gfx_BG.c", 194; //--------------------------------------------------------------------------------------//
 2023                        		.dbg	line,	"include\gfx_BG.c", 196; // EXTRACT PALETTE //
 2024                        		.dbg	line,	"include\gfx_BG.c", 197; #incpal(palette_LV1,"res/maps/tilemap_LV1_BG_B.png");
 2025               7678     		.data
 2026    0A:7678             	_palette_LV1:	.incpal		"res/maps/tilemap_LV1_BG_B.png"
 2027               E309     		.code
 2028                        		.dbg	line,	"main.c", 16; #include "include/gfx_SPRITES.c"
 2029                        		.dbg	line,	"include\gfx_SPRITES.c", 1; #include "huc.h"
 2030                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 1; #ifndef _hucc_legacy_h
 2031                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 2; #define _hucc_legacy_h
 2032                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 4; /****************************************************************************
 2033                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 5; ; ***************************************************************************
 2034                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 6; ;
 2035                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 7; ; huc.h
 2036                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 8; ;
 2037                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 9; ; HuCC wrapper file to include a default set of HuC-compatible functions.
 2038                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 10; ;
 2039                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 11; ; Copyright John Brandwood 2024.
 2040                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 12; ;
 2041                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 13; ; Distributed under the Boost Software License, Version 1.0.
 2042                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 14; ; (See accompanying file LICENSE_1_0.txt or copy at
 2043                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 15; ;  http://www.boost.org/LICENSE_1_0.txt)
 2044                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 16; ;
 2045                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 17; ; ***************************************************************************
 2046                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 18; ; ***************************************************************************
 2047                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 19; ;
 2048                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 20; ; When the HuCC compiler is invoked with the "--legacy" option to compile old
 2049                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 21; ; projects, then this "huc.h" file is automatically included.
 2050                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 22; ;
 2051                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 23; ; This file includes a set of the individual HuCC headers which correspond to
 2052                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 24; ; HuC's built-in functions and MagicKit library.
 2053                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 25; ;
 2054                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 26; ; New HuCC projects should, preferably, include the specific headers that are
 2055                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 27; ; needed, which will then allow them to replace parts of the standard library
 2056                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 28; ; with newer functions, or they can just manually include this "huc.h" file.
 2057                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 29; ;
 2058                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 30; ; ***************************************************************************
 2059                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 31; ; **************************************************************************/
 2060                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 33; #include "hucc-systemcard.h"
 2061                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 34; #include "hucc-baselib.h"
 2062                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 35; #include "hucc-gfx.h"
 2063                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 36; #include "hucc-string.h"
 2064                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 37; #include "hucc-old-scroll.h"
 2065                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 38; #include "hucc-old-spr.h"
 2066                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 39; #include "hucc-old-map.h"
 2067                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 40; #include "hucc-old-line.h"
 2068                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 42; #endif // _hucc_legacy_h
 2069                        		.dbg	line,	"include\gfx_SPRITES.c", 10; // EXTRACT PLAYER TILES //
 2070                        		.dbg	line,	"include\gfx_SPRITES.c", 11; #incspr(tiles_SPR_PLAYER,"res/sprites/tiles_SPR_PLAYER.png")
 2071               7878     		.data
 2072    0A:7878             	_tiles_SPR_PLAYER:	.incspr		"res/sprites/tiles_SPR_PLAYER.png"
 2073               E309     		.code
 2074                        		.dbg	line,	"include\gfx_SPRITES.c", 13; // EXTRACT PLAYER PALETTE //
 2075                        		.dbg	line,	"main.c", 16; #incpal(palette_PLAYER,"res/palettes/palette_PLAYER.png");
 2076               6A78     		.data
 2077    0B:6A78             	_palette_PLAYER:	.incpal		"res/palettes/palette_PLAYER.png"
 2078               E309     		.code
 2079                        		.dbg	line,	"main.c", 20; #include "include/tables_player.c"
 2080                        		.dbg	line,	"include\tables_player.c", 3; const signed char       TABLE_PLAYER_JUMP_V[35]     =   {
 2081                        		.dbg	line,	"include\tables_player.c", 4; // UPWARD
 2082                        		.dbg	line,	"include\tables_player.c", 5; -4,
 2083                        		.dbg	line,	"include\tables_player.c", 6; -5,
 2084                        		.dbg	line,	"include\tables_player.c", 7; -10,
 2085                        		.dbg	line,	"include\tables_player.c", 8; -4,
 2086                        		.dbg	line,	"include\tables_player.c", 9; -4,
 2087                        		.dbg	line,	"include\tables_player.c", 10; -7,
 2088                        		.dbg	line,	"include\tables_player.c", 11; -6,
 2089                        		.dbg	line,	"include\tables_player.c", 12; -3,
 2090                        		.dbg	line,	"include\tables_player.c", 13; -5,
 2091                        		.dbg	line,	"include\tables_player.c", 14; -2,
 2092                        		.dbg	line,	"include\tables_player.c", 15; -4,
 2093                        		.dbg	line,	"include\tables_player.c", 16; -1,
 2094                        		.dbg	line,	"include\tables_player.c", 17; -1,
 2095                        		.dbg	line,	"include\tables_player.c", 18; -1,
 2096                        		.dbg	line,	"include\tables_player.c", 19; -1,
 2097                        		.dbg	line,	"include\tables_player.c", 20; 0,
 2098                        		.dbg	line,	"include\tables_player.c", 21; 0,
 2099                        		.dbg	line,	"include\tables_player.c", 22; 0,
 2100                        		.dbg	line,	"include\tables_player.c", 23; 0,
 2101                        		.dbg	line,	"include\tables_player.c", 24; // DOWNWARD
 2102                        		.dbg	line,	"include\tables_player.c", 25; 1,
 2103                        		.dbg	line,	"include\tables_player.c", 26; 1,
 2104                        		.dbg	line,	"include\tables_player.c", 27; 1,
 2105                        		.dbg	line,	"include\tables_player.c", 28; 1,
 2106                        		.dbg	line,	"include\tables_player.c", 29; 4,
 2107                        		.dbg	line,	"include\tables_player.c", 30; 2,
 2108                        		.dbg	line,	"include\tables_player.c", 31; 5,
 2109                        		.dbg	line,	"include\tables_player.c", 32; 3,
 2110                        		.dbg	line,	"include\tables_player.c", 33; 6,
 2111                        		.dbg	line,	"include\tables_player.c", 34; 7,
 2112                        		.dbg	line,	"include\tables_player.c", 35; 4,
 2113                        		.dbg	line,	"include\tables_player.c", 36; 4,
 2114                        		.dbg	line,	"include\tables_player.c", 37; 10,
 2115                        		.dbg	line,	"include\tables_player.c", 38; 4,
 2116                        		.dbg	line,	"include\tables_player.c", 39; 4,
 2117                        		.dbg	line,	"include\tables_player.c", 40; 5
 2118                        		.dbg	line,	"main.c", 20; };
 2119                        		.dbg	line,	"main.c", 21; #include "include/routines_LEVELS.c"
 2120                        		.dbg	line,	"include\routines_LEVELS.c", 1; #include "huc.h"
 2121                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 1; #ifndef _hucc_legacy_h
 2122                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 2; #define _hucc_legacy_h
 2123                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 4; /****************************************************************************
 2124                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 5; ; ***************************************************************************
 2125                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 6; ;
 2126                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 7; ; huc.h
 2127                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 8; ;
 2128                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 9; ; HuCC wrapper file to include a default set of HuC-compatible functions.
 2129                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 10; ;
 2130                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 11; ; Copyright John Brandwood 2024.
 2131                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 12; ;
 2132                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 13; ; Distributed under the Boost Software License, Version 1.0.
 2133                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 14; ; (See accompanying file LICENSE_1_0.txt or copy at
 2134                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 15; ;  http://www.boost.org/LICENSE_1_0.txt)
 2135                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 16; ;
 2136                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 17; ; ***************************************************************************
 2137                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 18; ; ***************************************************************************
 2138                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 19; ;
 2139                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 20; ; When the HuCC compiler is invoked with the "--legacy" option to compile old
 2140                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 21; ; projects, then this "huc.h" file is automatically included.
 2141                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 22; ;
 2142                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 23; ; This file includes a set of the individual HuCC headers which correspond to
 2143                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 24; ; HuC's built-in functions and MagicKit library.
 2144                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 25; ;
 2145                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 26; ; New HuCC projects should, preferably, include the specific headers that are
 2146                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 27; ; needed, which will then allow them to replace parts of the standard library
 2147                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 28; ; with newer functions, or they can just manually include this "huc.h" file.
 2148                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 29; ;
 2149                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 30; ; ***************************************************************************
 2150                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 31; ; **************************************************************************/
 2151                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 33; #include "hucc-systemcard.h"
 2152                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 34; #include "hucc-baselib.h"
 2153                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 35; #include "hucc-gfx.h"
 2154                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 36; #include "hucc-string.h"
 2155                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 37; #include "hucc-old-scroll.h"
 2156                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 38; #include "hucc-old-spr.h"
 2157                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 39; #include "hucc-old-map.h"
 2158                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 40; #include "hucc-old-line.h"
 2159                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 42; #endif // _hucc_legacy_h
 2160                        		.dbg	line,	"include\routines_LEVELS.c", 2; #include "hucc-scroll.h"
 2161                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 1; #ifndef _hucc_scroll_h
 2162                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 2; #define _hucc_scroll_h
 2163                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 4; /****************************************************************************
 2164                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 5; ; ***************************************************************************
 2165                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 6; ;
 2166                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 7; ; hucc-scroll.h
 2167                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 8; ;
 2168                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 9; ; Routines for a fast split-screen scrolling system.
 2169                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 10; ;
 2170                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 11; ; Copyright John Brandwood 2024.
 2171                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 12; ;
 2172                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 13; ; Distributed under the Boost Software License, Version 1.0.
 2173                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 14; ; (See accompanying file LICENSE_1_0.txt or copy at
 2174                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 15; ;  http://www.boost.org/LICENSE_1_0.txt)
 2175                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 16; ;
 2176                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 17; ; ***************************************************************************
 2177                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 18; ; ***************************************************************************
 2178                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 19; ;
 2179                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 20; ; The maximum number of splits for each screen layer is set in your project's
 2180                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 21; ; "hucc-config.inc" file, with the library having a limit of 128-per-layer.
 2181                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 22; ;
 2182                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 23; ; Your first active split must be defined to start at screen line 0, and then
 2183                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 24; ; the rest of the active splits must be in increasing line order to match the
 2184                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 25; ; way that the PC Engine displays the output image.
 2185                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 26; ;
 2186                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 27; ; You can have disabled splits interleaved with your active splits.
 2187                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 28; ;
 2188                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 29; ; Splits that are normally disabled can be used to create full screen effects
 2189                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 30; ; such as bouncing the screen up and down by adding blank areas at the top or
 2190                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 31; ; bottom of the screen, and then rapidly changing the height of those areas.
 2191                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 32; ;
 2192                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 33; ; ***************************************************************************
 2193                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 34; ; **************************************************************************/
 2194                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 36; // *************
 2195                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 37; // VDC bits for display_flags ...
 2196                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 38; // *************
 2197                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 40; #ifndef BKG_OFF
 2198                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 41; #define BKG_OFF 0x00
 2199                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 42; #endif
 2200                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 44; #ifndef SPR_OFF
 2201                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 45; #define SPR_OFF 0x00
 2202                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 46; #endif
 2203                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 48; #ifndef BKG_ON
 2204                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 49; #define BKG_ON 0x80
 2205                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 50; #endif
 2206                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 52; #ifndef SPR_ON
 2207                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 53; #define SPR_ON 0x40
 2208                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 54; #endif
 2209                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 56; // *************
 2210                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 57; // Functions in hucc-scroll.asm ...
 2211                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 58; // *************
 2212                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 60; #ifdef __HUCC__
 2213                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 62; #asmdef	HUCC_USES_NEW_SCROLL 1
 2214                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 64; extern void __fastcall scroll_split( unsigned char index<_al>, unsigned char screen_line<_ah>, unsigned int bat_x<_bx>, unsigned int bat_y<_cx>, unsigned char display_flags<_dl> );
 2215                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 65; extern void __fastcall sgx_scroll_split( unsigned char index<_al>, unsigned char screen_line<_ah>, unsigned int bat_x<_bx>, unsigned int bat_y<_cx>, unsigned char display_flags<_dl> );
 2216                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 67; extern void __fastcall disable_split( unsigned char index<acc> );
 2217                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 68; extern void __fastcall sgx_disable_split( unsigned char index<acc> );
 2218                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 70; extern void __fastcall __macro disable_all_splits( void );
 2219                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 71; extern void __fastcall __macro sgx_disable_all_splits( void );
 2220                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 73; #asm
 2221                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 74; .macro	_disable_all_splits
 2222                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 75; ldy	#HUCC_PCE_SPLITS - 1
 2223                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 76; !loop:		tya
 2224                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 77; call	_disable_split.1
 2225                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 78; dey
 2226                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 79; bpl	!loop-
 2227                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 80; .endm
 2228                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 82; .macro	_sgx_disable_all_splits
 2229                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 83; ldy	#HUCC_SGX_SPLITS - 1
 2230                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 84; !loop:		tya
 2231                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 85; call	_sgx_disable_split.1
 2232                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 86; dey
 2233                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 87; bpl	!loop-
 2234                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 88; .endm
 2235                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 89; #endasm
 2236                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 91; #endif // __HUCC__
 2237                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 93; #endif // _hucc_scroll_h
 2238                        		.dbg	line,	"include\routines_LEVELS.c", 3; #include "hucc-chrmap.h"
 2239                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 1; #ifndef _hucc_chrmap_h
 2240                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 2; #define _hucc_chrmap_h
 2241                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 4; /****************************************************************************
 2242                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 5; ; ***************************************************************************
 2243                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 6; ;
 2244                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 7; ; hucc-chrmap.h
 2245                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 8; ;
 2246                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 9; ; A simple map system based on 8x8 characters (aka "tiles") in BAT format.
 2247                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 10; ;
 2248                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 11; ; Copyright John Brandwood 2025.
 2249                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 12; ;
 2250                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 13; ; Distributed under the Boost Software License, Version 1.0.
 2251                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 14; ; (See accompanying file LICENSE_1_0.txt or copy at
 2252                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 15; ;  http://www.boost.org/LICENSE_1_0.txt)
 2253                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 16; ;
 2254                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 17; ; ***************************************************************************
 2255                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 18; ; ***************************************************************************
 2256                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 19; ;
 2257                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 20; ; The maximum X and Y size for chrmaps is 256 characters (2048 pixels).
 2258                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 21; ;
 2259                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 22; ; The maximum total size for a chrmap is 16KBytes, which allows for maps up
 2260                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 23; ; to 256x32 tiles (2048x256 pixels).
 2261                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 24; ;
 2262                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 25; ; ***************************************************************************
 2263                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 26; ; **************************************************************************/
 2264                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 28; // *************
 2265                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 29; // This code extends the blkmap library ...
 2266                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 30; // *************
 2267                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 32; #include "hucc-blkmap.h"
 2268                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 34; // *************
 2269                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 35; // Functions in chrmap.asm ...
 2270                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 36; // *************
 2271                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 38; #ifdef __HUCC__
 2272                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 40; #asmdef	HUCC_USES_CHRMAP 1
 2273                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 42; extern void __fastcall __nop set_chrmap( unsigned char __far *chrmap<vdc_map_bank:vdc_map_addr>, unsigned char tiles_w<vdc_map_line_w> );
 2274                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 44; extern void __fastcall draw_bat( void );
 2275                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 45; extern void __fastcall scroll_bat( void );
 2276                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 47; extern void __fastcall blit_bat( unsigned char tile_x<map_bat_x>, unsigned char tile_y<map_bat_y>, unsigned char tile_w<map_draw_x>, unsigned char tile_h<map_draw_y> );
 2277                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 49; #ifdef _SGX
 2278                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 51; extern void __fastcall __nop sgx_set_chrmap( unsigned char __far *chrmap<sgx_map_bank:sgx_map_addr>, unsigned char tiles_w<sgx_map_line_w> );
 2279                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 53; extern void __fastcall sgx_draw_bat( void );
 2280                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 54; extern void __fastcall sgx_scroll_bat( void );
 2281                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 56; extern void __fastcall sgx_blit_bat( unsigned char tile_x<map_bat_x>, unsigned char tile_y<map_bat_y>, unsigned char tile_w<map_draw_x>, unsigned char tile_h<map_draw_y> );
 2282                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 58; #endif
 2283                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 60; #endif // __HUCC__
 2284                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 62; #endif // _hucc_chrmap_h
 2285                        		.dbg	line,	"include\routines_LEVELS.c", 4; #include "hucc-blkmap.h"
 2286                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 1; #ifndef _hucc_blkmap_h
 2287                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 2; #define _hucc_blkmap_h
 2288                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 4; /****************************************************************************
 2289                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 5; ; ***************************************************************************
 2290                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 6; ;
 2291                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 7; ; hucc-blkmap.h
 2292                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 8; ;
 2293                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 9; ; A map system based on 16x16 meta-tiles (aka "blocks", aka CHR/BLK/MAP).
 2294                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 10; ;
 2295                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 11; ; Copyright John Brandwood 2025.
 2296                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 12; ;
 2297                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 13; ; Distributed under the Boost Software License, Version 1.0.
 2298                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 14; ; (See accompanying file LICENSE_1_0.txt or copy at
 2299                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 15; ;  http://www.boost.org/LICENSE_1_0.txt)
 2300                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 16; ;
 2301                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 17; ; ***************************************************************************
 2302                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 18; ; ***************************************************************************
 2303                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 19; ;
 2304                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 20; ; The maximum X and Y size for blkmaps is 128 blocks (2048 pixels).
 2305                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 21; ;
 2306                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 22; ; The maximum total size for a blkmap is 16KBytes, which allows for maps up
 2307                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 23; ; to 128x128 blocks (2048x2048 pixels).
 2308                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 24; ;
 2309                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 25; ; Huge multi-screen blkmaps are also supported (optionally).
 2310                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 26; ;
 2311                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 27; ; The maximum X and Y for multi-screen maps is 128 screens (32768 pixels).
 2312                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 28; ;
 2313                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 29; ; The maximum total size for a multi-screen map is 8KBytes, which allows for
 2314                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 30; ; a total of 1024 screens.
 2315                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 31; ;
 2316                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 32; ; ***************************************************************************
 2317                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 33; ; **************************************************************************/
 2318                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 35; // *************
 2319                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 36; // Functions in blkmap.asm ...
 2320                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 37; // *************
 2321                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 39; #ifdef __HUCC__
 2322                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 41; #asmdef	HUCC_USES_BLKMAP 1
 2323                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 43; // Current top-left of drawn map in pixels.
 2324                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 44; extern unsigned int   vdc_map_pxl_x;
 2325                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 45; extern unsigned int   vdc_map_pxl_y;
 2326                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 47; // Width and height to draw/scroll in characters (not tiles).
 2327                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 48; extern unsigned char  vdc_map_draw_w;
 2328                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 49; extern unsigned char  vdc_map_draw_h;
 2329                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 51; // Width of map (or multi-screen BAT) in tiles.
 2330                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 52; extern unsigned char  vdc_map_line_w;
 2331                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 54; // Width of map in screens (if multi-screen map).
 2332                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 55; extern unsigned char  vdc_map_scrn_w;
 2333                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 57; // Extra information returned by get_map_block() and sgx_get_map_block(),
 2334                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 58; // which are the collision flags and the mask/overlay sprite for the BLK.
 2335                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 59; extern unsigned char  map_blk_flag;
 2336                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 60; extern unsigned char  map_blk_mask;
 2337                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 62; extern unsigned char  vdc_scr_bank;
 2338                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 63; extern unsigned char *vdc_scr_addr;
 2339                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 65; extern unsigned char  vdc_map_bank;
 2340                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 66; extern unsigned char *vdc_map_addr;
 2341                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 68; extern unsigned char  vdc_blk_bank;
 2342                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 69; extern unsigned char *vdc_blk_addr;
 2343                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 71; extern unsigned char  vdc_tbl_bank;
 2344                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 72; extern unsigned char *vdc_tbl_addr;
 2345                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 74; extern void __fastcall set_blocks( unsigned char __far *blk_def<vdc_blk_bank:vdc_blk_addr>, unsigned char __far *flg_def<vdc_tbl_bank:vdc_tbl_addr>, unsigned char number_of_blocks<_al> );
 2346                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 75; extern void __fastcall __macro set_blkmap( unsigned char __far *blk_map<vdc_map_bank:vdc_map_addr>, unsigned char blocks_w<vdc_map_line_w> );
 2347                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 76; extern void __fastcall __macro set_multimap( unsigned char __far *multi_map<vdc_scr_bank:vdc_scr_addr>, unsigned char screens_w<vdc_map_scrn_w> );
 2348                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 78; extern void __fastcall draw_map( void );
 2349                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 79; extern void __fastcall scroll_map( void );
 2350                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 81; extern void __fastcall blit_map( unsigned char tile_x<map_bat_x>, unsigned char tile_y<map_bat_y>, unsigned char tile_w<map_draw_x>, unsigned char tile_h<map_draw_y> );
 2351                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 83; extern unsigned char __fastcall get_map_block( unsigned int x<map_pxl_x>, unsigned int y<map_pxl_y> );
 2352                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 85; #asm
 2353                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 86; .macro	_set_blkmap.2
 2354                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 87; stz	vdc_scr_bank
 2355                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 88; .endm
 2356                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 90; .macro	_set_multimap.2
 2357                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 91; lda	vdc_bat_width
 2358                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 92; lsr	a
 2359                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 93; sta	vdc_map_line_w
 2360                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 94; .endm
 2361                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 96; .macro	SCREEN
 2362                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 97; db	(((\1) & $1FFF) | $6000) >> 8, bank(\1)
 2363                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 98; db	(((\2) & $1FFF) | $4000) >> 8, bank(\2)
 2364                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 99; db	(((\3) & $1FFF) | $6000) >> 8, bank(\3)
 2365                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 100; dw	(\4)
 2366                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 101; .endm
 2367                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 102; #endasm
 2368                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 104; #ifdef _SGX
 2369                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 106; // Current top-left of drawn map in pixels.
 2370                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 107; extern unsigned int   sgx_map_pxl_x;
 2371                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 108; extern unsigned int   sgx_map_pxl_y;
 2372                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 110; // Width and height to draw/scroll in characters (not tiles).
 2373                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 111; extern unsigned char  sgx_map_draw_w;
 2374                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 112; extern unsigned char  sgx_map_draw_h;
 2375                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 114; // Width of map (or multi-screen BAT) in tiles.
 2376                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 115; extern unsigned char  sgx_map_line_w;
 2377                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 117; // Width of map in screens (if multi-screen map).
 2378                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 118; extern unsigned char  sgx_map_scrn_w;
 2379                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 120; extern unsigned char  sgx_scr_bank;
 2380                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 121; extern unsigned char *sgx_scr_addr;
 2381                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 123; extern unsigned char  sgx_map_bank;
 2382                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 124; extern unsigned char *sgx_map_addr;
 2383                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 126; extern unsigned char  sgx_blk_bank;
 2384                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 127; extern unsigned char *sgx_blk_addr;
 2385                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 129; extern unsigned char  sgx_tbl_bank;
 2386                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 130; extern unsigned char *sgx_tbl_addr;
 2387                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 132; extern void __fastcall sgx_set_blocks( unsigned char __far *blk_def<sgx_blk_bank:sgx_blk_addr>, unsigned char __far *flg_def<sgx_tbl_bank:sgx_tbl_addr>, unsigned char number_of_blocks<_al> );
 2388                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 133; extern void __fastcall __macro sgx_set_blkmap( unsigned char __far *blk_map<sgx_map_bank:sgx_map_addr>, unsigned char blocks_w<sgx_map_line_w> );
 2389                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 134; extern void __fastcall __macro sgx_set_multimap( unsigned char __far *multi_map<sgx_scr_bank:sgx_scr_addr>, unsigned char screens_w<sgx_map_scrn_w> );
 2390                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 136; extern void __fastcall sgx_draw_map( void );
 2391                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 137; extern void __fastcall sgx_scroll_map( void );
 2392                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 139; extern void __fastcall sgx_blit_map( unsigned char tile_x<map_bat_x>, unsigned char tile_y<map_bat_y>, unsigned char tile_w<map_draw_x>, unsigned char tile_h<map_draw_y> );
 2393                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 141; extern unsigned char __fastcall sgx_get_map_block( unsigned int x<map_pxl_x>, unsigned int y<map_pxl_y> );
 2394                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 143; #asm
 2395                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 144; .macro	_sgx_set_blkmap.2
 2396                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 145; stz	sgx_scr_bank
 2397                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 146; .endm
 2398                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 148; .macro	_sgx_set_multimap.2
 2399                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 149; lda	sgx_bat_width
 2400                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 150; lsr	a
 2401                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 151; sta	sgx_map_line_w
 2402                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 152; .endm
 2403                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 153; #endasm
 2404                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 155; #endif
 2405                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 157; #endif // __HUCC__
 2406                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 159; #endif // _hucc_blkmap_h
 2407                        		.dbg	line,	"include\routines_LEVELS.c", 13; int calculate_COLLISION_DEEP(unsigned char x , unsigned char y)
 2408                        		.dbg	line,	"include\routines_LEVELS.c", 14; {
 2409                        	;***********************
 2410                        	;***********************
 2411                        	
 2412                        		.hucc
 2413    0B:DF98             		.proc		_calculate_COLLISION_DEEP
 2414                        		__enter		_calculate_COLLISION_DEEP
 2415                        	
 2416                        		.dbg	line,	"include\routines_LEVELS.c", 15; int player_COLL_X;
 2417                        	
 2418                        		.dbg	line,	"include\routines_LEVELS.c", 16; int player_COLL_Y;
 2419                        	
 2420                        		.dbg	line,	"include\routines_LEVELS.c", 19; player_COLL_X = player_pos_x + x;
 2421                        		__ld.wm		_player_pos_x
         0B:DF98  AD 0A 23   			lda.l	_player_pos_x
         0B:DF9B  AC 0B 23   			ldy.h	_player_pos_x
 2422                        		__add.us	2  /* x */
         0B:DF9E  A6 8D      			ldx	<__sp
         0B:DFA0  18         			clc
         0B:DFA1  75 0A      			adc	<__stack + 2, x
         0B:DFA3  90 01      			bcc	!+
         0B:DFA5  C8         			iny
         0B:DFA6             	!:
 2423                        		__st.wmq	__calculate_COLLISION_DEEP_end - 2  /* player_COLL_X */
         0B:DFA6  8D 10 23   			sta.l	__calculate_COLLISION_DEEP_end - 2
         0B:DFA9  8C 11 23   			sty.h	__calculate_COLLISION_DEEP_end - 2
 2424                        	
 2425                        		.dbg	line,	"include\routines_LEVELS.c", 20; player_COLL_Y = player_pos_y + 32 - y;
 2426                        		__ld.wm		_player_pos_y
         0B:DFAC  AD 0C 23   			lda.l	_player_pos_y
         0B:DFAF  AC 0D 23   			ldy.h	_player_pos_y
 2427                        		__add.wi	32
         0B:DFB2  18         			clc
         0B:DFB3  69 20      			adc.l	#32
         0B:DFB5  90 01      			bcc	!+
         0B:DFB7  C8         			iny
         0B:DFB8             	!:
 2428                        		__sub.us	0  /* y */
         0B:DFB8  A6 8D      			ldx	<__sp
         0B:DFBA  38         			sec
         0B:DFBB  F5 08      			sbc	<__stack + 0, x
         0B:DFBD  B0 01      			bcs	!+
         0B:DFBF  88         			dey
         0B:DFC0             	!:
 2429                        		__st.wmq	__calculate_COLLISION_DEEP_end - 4  /* player_COLL_Y */
         0B:DFC0  8D 0E 23   			sta.l	__calculate_COLLISION_DEEP_end - 4
         0B:DFC3  8C 0F 23   			sty.h	__calculate_COLLISION_DEEP_end - 4
 2430                        	
 2431                        		.dbg	line,	"include\routines_LEVELS.c", 23; get_map_block(player_COLL_X + sgx_map_pxl_y, player_COLL_Y + sgx_map_pxl_y);
 2432                        		__ld.wm		__calculate_COLLISION_DEEP_end - 2  /* player_COLL_X */
         0B:DFC6  AD 10 23   			lda.l	__calculate_COLLISION_DEEP_end - 2
         0B:DFC9  AC 11 23   			ldy.h	__calculate_COLLISION_DEEP_end - 2
 2433                        		__add.wm	_sgx_map_pxl_y
         0B:DFCC  18         			clc
         0B:DFCD  6D 58 23   			adc.l	_sgx_map_pxl_y
         0B:DFD0  42         			say
         0B:DFD1  6D 59 23   			adc.h	_sgx_map_pxl_y
         0B:DFD4  42         			say
 2434                        		__st.wmq	map_pxl_x
         0B:DFD5  85 FC      			sta.l	map_pxl_x
         0B:DFD7  84 FD      			sty.h	map_pxl_x
 2435                        		__ld.wm		__calculate_COLLISION_DEEP_end - 4  /* player_COLL_Y */
         0B:DFD9  AD 0E 23   			lda.l	__calculate_COLLISION_DEEP_end - 4
         0B:DFDC  AC 0F 23   			ldy.h	__calculate_COLLISION_DEEP_end - 4
 2436                        		__add.wm	_sgx_map_pxl_y
         0B:DFDF  18         			clc
         0B:DFE0  6D 58 23   			adc.l	_sgx_map_pxl_y
         0B:DFE3  42         			say
         0B:DFE4  6D 59 23   			adc.h	_sgx_map_pxl_y
         0B:DFE7  42         			say
 2437                        		__st.wmq	map_pxl_y
         0B:DFE8  85 FE      			sta.l	map_pxl_y
         0B:DFEA  84 FF      			sty.h	map_pxl_y
 2438                        		__call		_get_map_block.2
         0B:DFEC  20 9F FF   			call	_get_map_block.2
 2439                        	
 2440                        		.dbg	line,	"include\routines_LEVELS.c", 24; }
 2441    0B:DFEF             	.LL2:
 2442                        		__modsp		4
         0B:DFEF  AA         			tax
         0B:DFF0  A5 8D      			lda	<__sp
         0B:DFF2  18         			clc
         0B:DFF3  69 04      			adc	#4
         0B:DFF5  85 8D      			sta	<__sp
         0B:DFF7  8A         			txa
 2443                        		__return	1
         0B:DFF8  AA         			tax
         0B:DFF9  4C EF FF   			jmp	leave_proc
 2444                        		.dbg	clear
 2445                        		.endp
 2446                        		.pceas
 2447                        	
 2448                        		.dbg	line,	"include\routines_LEVELS.c", 27; int check_WALL_R()
 2449                        		.dbg	line,	"include\routines_LEVELS.c", 28; {
 2450                        	;***********************
 2451                        	;***********************
 2452                        	
 2453                        		.hucc
 2454    01:C703             		.proc		_check_WALL_R
 2455                        		__enter		_check_WALL_R
 2456                        	
 2457                        		.dbg	line,	"include\routines_LEVELS.c", 29; int player_COLL_X;
 2458                        	
 2459                        		.dbg	line,	"include\routines_LEVELS.c", 30; int player_COLL_Y;
 2460                        	
 2461                        		.dbg	line,	"include\routines_LEVELS.c", 33; player_COLL_X = player_pos_x + 23;
 2462                        		__ld.wm		_player_pos_x
         01:C703  AD 0A 23   			lda.l	_player_pos_x
         01:C706  AC 0B 23   			ldy.h	_player_pos_x
 2463                        		__add.wi	23
         01:C709  18         			clc
         01:C70A  69 17      			adc.l	#23
         01:C70C  90 01      			bcc	!+
         01:C70E  C8         			iny
         01:C70F             	!:
 2464                        		__st.wmq	__check_WALL_R_end - 2  /* player_COLL_X */
         01:C70F  8D 10 23   			sta.l	__check_WALL_R_end - 2
         01:C712  8C 11 23   			sty.h	__check_WALL_R_end - 2
 2465                        	
 2466                        		.dbg	line,	"include\routines_LEVELS.c", 34; player_COLL_Y = player_pos_y + 31;
 2467                        		__ld.wm		_player_pos_y
         01:C715  AD 0C 23   			lda.l	_player_pos_y
         01:C718  AC 0D 23   			ldy.h	_player_pos_y
 2468                        		__add.wi	31
         01:C71B  18         			clc
         01:C71C  69 1F      			adc.l	#31
         01:C71E  90 01      			bcc	!+
         01:C720  C8         			iny
         01:C721             	!:
 2469                        		__st.wmq	__check_WALL_R_end - 4  /* player_COLL_Y */
         01:C721  8D 0E 23   			sta.l	__check_WALL_R_end - 4
         01:C724  8C 0F 23   			sty.h	__check_WALL_R_end - 4
 2470                        	
 2471                        		.dbg	line,	"include\routines_LEVELS.c", 37; get_map_block(player_COLL_X + sgx_map_pxl_x, player_COLL_Y + sgx_map_pxl_y);
 2472                        		__ld.wm		__check_WALL_R_end - 2  /* player_COLL_X */
         01:C727  AD 10 23   			lda.l	__check_WALL_R_end - 2
         01:C72A  AC 11 23   			ldy.h	__check_WALL_R_end - 2
 2473                        		__add.wm	_sgx_map_pxl_x
         01:C72D  18         			clc
         01:C72E  6D 56 23   			adc.l	_sgx_map_pxl_x
         01:C731  42         			say
         01:C732  6D 57 23   			adc.h	_sgx_map_pxl_x
         01:C735  42         			say
 2474                        		__st.wmq	map_pxl_x
         01:C736  85 FC      			sta.l	map_pxl_x
         01:C738  84 FD      			sty.h	map_pxl_x
 2475                        		__ld.wm		__check_WALL_R_end - 4  /* player_COLL_Y */
         01:C73A  AD 0E 23   			lda.l	__check_WALL_R_end - 4
         01:C73D  AC 0F 23   			ldy.h	__check_WALL_R_end - 4
 2476                        		__add.wm	_sgx_map_pxl_y
         01:C740  18         			clc
         01:C741  6D 58 23   			adc.l	_sgx_map_pxl_y
         01:C744  42         			say
         01:C745  6D 59 23   			adc.h	_sgx_map_pxl_y
         01:C748  42         			say
 2477                        		__st.wmq	map_pxl_y
         01:C749  85 FE      			sta.l	map_pxl_y
         01:C74B  84 FF      			sty.h	map_pxl_y
 2478                        		__call		_get_map_block.2
         01:C74D  20 9F FF   			call	_get_map_block.2
 2479                        	
 2480                        		.dbg	line,	"include\routines_LEVELS.c", 38; }
 2481    01:C750             	.LL3:
 2482                        		__return	1
         01:C750  AA         			tax
         01:C751  4C EF FF   			jmp	leave_proc
 2483                        		.dbg	clear
 2484                        		.endp
 2485                        		.pceas
 2486                        	
 2487                        		.dbg	line,	"include\routines_LEVELS.c", 41; int check_WALL_L()
 2488                        		.dbg	line,	"include\routines_LEVELS.c", 42; {
 2489                        	;***********************
 2490                        	;***********************
 2491                        	
 2492                        		.hucc
 2493    01:C754             		.proc		_check_WALL_L
 2494                        		__enter		_check_WALL_L
 2495                        	
 2496                        		.dbg	line,	"include\routines_LEVELS.c", 43; int player_COLL_X;
 2497                        	
 2498                        		.dbg	line,	"include\routines_LEVELS.c", 44; int player_COLL_Y;
 2499                        	
 2500                        		.dbg	line,	"include\routines_LEVELS.c", 47; player_COLL_X = player_pos_x + 8;
 2501                        		__ld.wm		_player_pos_x
         01:C754  AD 0A 23   			lda.l	_player_pos_x
         01:C757  AC 0B 23   			ldy.h	_player_pos_x
 2502                        		__add.wi	8
         01:C75A  18         			clc
         01:C75B  69 08      			adc.l	#8
         01:C75D  90 01      			bcc	!+
         01:C75F  C8         			iny
         01:C760             	!:
 2503                        		__st.wmq	__check_WALL_L_end - 2  /* player_COLL_X */
         01:C760  8D 10 23   			sta.l	__check_WALL_L_end - 2
         01:C763  8C 11 23   			sty.h	__check_WALL_L_end - 2
 2504                        	
 2505                        		.dbg	line,	"include\routines_LEVELS.c", 48; player_COLL_Y = player_pos_y + 31;
 2506                        		__ld.wm		_player_pos_y
         01:C766  AD 0C 23   			lda.l	_player_pos_y
         01:C769  AC 0D 23   			ldy.h	_player_pos_y
 2507                        		__add.wi	31
         01:C76C  18         			clc
         01:C76D  69 1F      			adc.l	#31
         01:C76F  90 01      			bcc	!+
         01:C771  C8         			iny
         01:C772             	!:
 2508                        		__st.wmq	__check_WALL_L_end - 4  /* player_COLL_Y */
         01:C772  8D 0E 23   			sta.l	__check_WALL_L_end - 4
         01:C775  8C 0F 23   			sty.h	__check_WALL_L_end - 4
 2509                        	
 2510                        		.dbg	line,	"include\routines_LEVELS.c", 51; get_map_block(player_COLL_X + sgx_map_pxl_x, player_COLL_Y + sgx_map_pxl_y);
 2511                        		__ld.wm		__check_WALL_L_end - 2  /* player_COLL_X */
         01:C778  AD 10 23   			lda.l	__check_WALL_L_end - 2
         01:C77B  AC 11 23   			ldy.h	__check_WALL_L_end - 2
 2512                        		__add.wm	_sgx_map_pxl_x
         01:C77E  18         			clc
         01:C77F  6D 56 23   			adc.l	_sgx_map_pxl_x
         01:C782  42         			say
         01:C783  6D 57 23   			adc.h	_sgx_map_pxl_x
         01:C786  42         			say
 2513                        		__st.wmq	map_pxl_x
         01:C787  85 FC      			sta.l	map_pxl_x
         01:C789  84 FD      			sty.h	map_pxl_x
 2514                        		__ld.wm		__check_WALL_L_end - 4  /* player_COLL_Y */
         01:C78B  AD 0E 23   			lda.l	__check_WALL_L_end - 4
         01:C78E  AC 0F 23   			ldy.h	__check_WALL_L_end - 4
 2515                        		__add.wm	_sgx_map_pxl_y
         01:C791  18         			clc
         01:C792  6D 58 23   			adc.l	_sgx_map_pxl_y
         01:C795  42         			say
         01:C796  6D 59 23   			adc.h	_sgx_map_pxl_y
         01:C799  42         			say
 2516                        		__st.wmq	map_pxl_y
         01:C79A  85 FE      			sta.l	map_pxl_y
         01:C79C  84 FF      			sty.h	map_pxl_y
 2517                        		__call		_get_map_block.2
         01:C79E  20 9F FF   			call	_get_map_block.2
 2518                        	
 2519                        		.dbg	line,	"include\routines_LEVELS.c", 52; }
 2520    01:C7A1             	.LL4:
 2521                        		__return	1
         01:C7A1  AA         			tax
         01:C7A2  4C EF FF   			jmp	leave_proc
 2522                        		.dbg	clear
 2523                        		.endp
 2524                        		.pceas
 2525                        	
 2526                        		.dbg	line,	"include\routines_LEVELS.c", 55; int check_FLOOR_R()
 2527                        		.dbg	line,	"include\routines_LEVELS.c", 56; {
 2528                        	;***********************
 2529                        	;***********************
 2530                        	
 2531                        		.hucc
 2532    01:C7A5             		.proc		_check_FLOOR_R
 2533                        		__enter		_check_FLOOR_R
 2534                        	
 2535                        		.dbg	line,	"include\routines_LEVELS.c", 57; int player_COLL_X;
 2536                        	
 2537                        		.dbg	line,	"include\routines_LEVELS.c", 58; int player_COLL_Y;
 2538                        	
 2539                        		.dbg	line,	"include\routines_LEVELS.c", 61; player_COLL_X = player_pos_x + 11;
 2540                        		__ld.wm		_player_pos_x
         01:C7A5  AD 0A 23   			lda.l	_player_pos_x
         01:C7A8  AC 0B 23   			ldy.h	_player_pos_x
 2541                        		__add.wi	11
         01:C7AB  18         			clc
         01:C7AC  69 0B      			adc.l	#11
         01:C7AE  90 01      			bcc	!+
         01:C7B0  C8         			iny
         01:C7B1             	!:
 2542                        		__st.wmq	__check_FLOOR_R_end - 2  /* player_COLL_X */
         01:C7B1  8D 10 23   			sta.l	__check_FLOOR_R_end - 2
         01:C7B4  8C 11 23   			sty.h	__check_FLOOR_R_end - 2
 2543                        	
 2544                        		.dbg	line,	"include\routines_LEVELS.c", 62; player_COLL_Y = player_pos_y + 32;
 2545                        		__ld.wm		_player_pos_y
         01:C7B7  AD 0C 23   			lda.l	_player_pos_y
         01:C7BA  AC 0D 23   			ldy.h	_player_pos_y
 2546                        		__add.wi	32
         01:C7BD  18         			clc
         01:C7BE  69 20      			adc.l	#32
         01:C7C0  90 01      			bcc	!+
         01:C7C2  C8         			iny
         01:C7C3             	!:
 2547                        		__st.wmq	__check_FLOOR_R_end - 4  /* player_COLL_Y */
         01:C7C3  8D 0E 23   			sta.l	__check_FLOOR_R_end - 4
         01:C7C6  8C 0F 23   			sty.h	__check_FLOOR_R_end - 4
 2548                        	
 2549                        		.dbg	line,	"include\routines_LEVELS.c", 65; get_map_block(player_COLL_X + sgx_map_pxl_x, player_COLL_Y + sgx_map_pxl_y);
 2550                        		__ld.wm		__check_FLOOR_R_end - 2  /* player_COLL_X */
         01:C7C9  AD 10 23   			lda.l	__check_FLOOR_R_end - 2
         01:C7CC  AC 11 23   			ldy.h	__check_FLOOR_R_end - 2
 2551                        		__add.wm	_sgx_map_pxl_x
         01:C7CF  18         			clc
         01:C7D0  6D 56 23   			adc.l	_sgx_map_pxl_x
         01:C7D3  42         			say
         01:C7D4  6D 57 23   			adc.h	_sgx_map_pxl_x
         01:C7D7  42         			say
 2552                        		__st.wmq	map_pxl_x
         01:C7D8  85 FC      			sta.l	map_pxl_x
         01:C7DA  84 FD      			sty.h	map_pxl_x
 2553                        		__ld.wm		__check_FLOOR_R_end - 4  /* player_COLL_Y */
         01:C7DC  AD 0E 23   			lda.l	__check_FLOOR_R_end - 4
         01:C7DF  AC 0F 23   			ldy.h	__check_FLOOR_R_end - 4
 2554                        		__add.wm	_sgx_map_pxl_y
         01:C7E2  18         			clc
         01:C7E3  6D 58 23   			adc.l	_sgx_map_pxl_y
         01:C7E6  42         			say
         01:C7E7  6D 59 23   			adc.h	_sgx_map_pxl_y
         01:C7EA  42         			say
 2555                        		__st.wmq	map_pxl_y
         01:C7EB  85 FE      			sta.l	map_pxl_y
         01:C7ED  84 FF      			sty.h	map_pxl_y
 2556                        		__call		_get_map_block.2
         01:C7EF  20 9F FF   			call	_get_map_block.2
 2557                        	
 2558                        		.dbg	line,	"include\routines_LEVELS.c", 66; }
 2559    01:C7F2             	.LL5:
 2560                        		__return	1
         01:C7F2  AA         			tax
         01:C7F3  4C EF FF   			jmp	leave_proc
 2561                        		.dbg	clear
 2562                        		.endp
 2563                        		.pceas
 2564                        	
 2565                        		.dbg	line,	"include\routines_LEVELS.c", 69; int check_FLOOR_L()
 2566                        		.dbg	line,	"include\routines_LEVELS.c", 70; {
 2567                        	;***********************
 2568                        	;***********************
 2569                        	
 2570                        		.hucc
 2571    01:C7F6             		.proc		_check_FLOOR_L
 2572                        		__enter		_check_FLOOR_L
 2573                        	
 2574                        		.dbg	line,	"include\routines_LEVELS.c", 71; int player_COLL_X;
 2575                        	
 2576                        		.dbg	line,	"include\routines_LEVELS.c", 72; int player_COLL_Y;
 2577                        	
 2578                        		.dbg	line,	"include\routines_LEVELS.c", 75; player_COLL_X = player_pos_x + 10;
 2579                        		__ld.wm		_player_pos_x
         01:C7F6  AD 0A 23   			lda.l	_player_pos_x
         01:C7F9  AC 0B 23   			ldy.h	_player_pos_x
 2580                        		__add.wi	10
         01:C7FC  18         			clc
         01:C7FD  69 0A      			adc.l	#10
         01:C7FF  90 01      			bcc	!+
         01:C801  C8         			iny
         01:C802             	!:
 2581                        		__st.wmq	__check_FLOOR_L_end - 2  /* player_COLL_X */
         01:C802  8D 10 23   			sta.l	__check_FLOOR_L_end - 2
         01:C805  8C 11 23   			sty.h	__check_FLOOR_L_end - 2
 2582                        	
 2583                        		.dbg	line,	"include\routines_LEVELS.c", 76; player_COLL_Y = player_pos_y + 32;
 2584                        		__ld.wm		_player_pos_y
         01:C808  AD 0C 23   			lda.l	_player_pos_y
         01:C80B  AC 0D 23   			ldy.h	_player_pos_y
 2585                        		__add.wi	32
         01:C80E  18         			clc
         01:C80F  69 20      			adc.l	#32
         01:C811  90 01      			bcc	!+
         01:C813  C8         			iny
         01:C814             	!:
 2586                        		__st.wmq	__check_FLOOR_L_end - 4  /* player_COLL_Y */
         01:C814  8D 0E 23   			sta.l	__check_FLOOR_L_end - 4
         01:C817  8C 0F 23   			sty.h	__check_FLOOR_L_end - 4
 2587                        	
 2588                        		.dbg	line,	"include\routines_LEVELS.c", 79; get_map_block(player_COLL_X + sgx_map_pxl_x, player_COLL_Y + sgx_map_pxl_y);
 2589                        		__ld.wm		__check_FLOOR_L_end - 2  /* player_COLL_X */
         01:C81A  AD 10 23   			lda.l	__check_FLOOR_L_end - 2
         01:C81D  AC 11 23   			ldy.h	__check_FLOOR_L_end - 2
 2590                        		__add.wm	_sgx_map_pxl_x
         01:C820  18         			clc
         01:C821  6D 56 23   			adc.l	_sgx_map_pxl_x
         01:C824  42         			say
         01:C825  6D 57 23   			adc.h	_sgx_map_pxl_x
         01:C828  42         			say
 2591                        		__st.wmq	map_pxl_x
         01:C829  85 FC      			sta.l	map_pxl_x
         01:C82B  84 FD      			sty.h	map_pxl_x
 2592                        		__ld.wm		__check_FLOOR_L_end - 4  /* player_COLL_Y */
         01:C82D  AD 0E 23   			lda.l	__check_FLOOR_L_end - 4
         01:C830  AC 0F 23   			ldy.h	__check_FLOOR_L_end - 4
 2593                        		__add.wm	_sgx_map_pxl_y
         01:C833  18         			clc
         01:C834  6D 58 23   			adc.l	_sgx_map_pxl_y
         01:C837  42         			say
         01:C838  6D 59 23   			adc.h	_sgx_map_pxl_y
         01:C83B  42         			say
 2594                        		__st.wmq	map_pxl_y
         01:C83C  85 FE      			sta.l	map_pxl_y
         01:C83E  84 FF      			sty.h	map_pxl_y
 2595                        		__call		_get_map_block.2
         01:C840  20 9F FF   			call	_get_map_block.2
 2596                        	
 2597                        		.dbg	line,	"include\routines_LEVELS.c", 80; }
 2598    01:C843             	.LL6:
 2599                        		__return	1
         01:C843  AA         			tax
         01:C844  4C EF FF   			jmp	leave_proc
 2600                        		.dbg	clear
 2601                        		.endp
 2602                        		.pceas
 2603                        	
 2604                        		.dbg	line,	"include\routines_LEVELS.c", 89; void scroll_BG()
 2605                        		.dbg	line,	"include\routines_LEVELS.c", 90; {
 2606                        	;***********************
 2607                        	;***********************
 2608                        	
 2609                        		.hucc
 2610    01:CA5E             		.proc		_scroll_BG
 2611                        		__enter		_scroll_BG
 2612                        	
 2613                        		.dbg	line,	"include\routines_LEVELS.c", 91; // UPDATE VDC2 BG //
 2614                        	
 2615                        		.dbg	line,	"include\routines_LEVELS.c", 92; sgx_scroll_map();
 2616                        		__call		_sgx_scroll_map
         01:CA5E  20 95 FF   			call	_sgx_scroll_map
 2617                        	
 2618                        		.dbg	line,	"include\routines_LEVELS.c", 94; //--------------------------------------------------------------------------------------//
 2619                        	
 2620                        		.dbg	line,	"include\routines_LEVELS.c", 95; //                                        VDC 2                                         //
 2621                        	
 2622                        		.dbg	line,	"include\routines_LEVELS.c", 96; //--------------------------------------------------------------------------------------//
 2623                        	
 2624                        		.dbg	line,	"include\routines_LEVELS.c", 98; sgx_scroll_split(0,   0, sgx_map_pxl_x & (BAT_SIZE_W - 1), sgx_map_pxl_y & (BAT_SIZE_H - 1), BKG_ON | SPR_ON);
 2625                        		__st.umiq	0, _al
         01:CA61  64 F8      			stz	_al
 2626                        		__st.umiq	0, _ah
         01:CA63  64 F9      			stz	_ah
 2627                        		__ld.wm		_sgx_map_pxl_x
         01:CA65  AD 56 23   			lda.l	_sgx_map_pxl_x
         01:CA68  AC 57 23   			ldy.h	_sgx_map_pxl_x
 2628                        		__and.wi	2047
         01:CA6B  29 FF      			and.l	#2047
         01:CA6D  42         			say
         01:CA6E  29 07      			and.h	#2047
         01:CA70  42         			say
 2629                        		__st.wmq	_bx
         01:CA71  85 FA      			sta.l	_bx
         01:CA73  84 FB      			sty.h	_bx
 2630                        		__ld.wm		_sgx_map_pxl_y
         01:CA75  AD 58 23   			lda.l	_sgx_map_pxl_y
         01:CA78  AC 59 23   			ldy.h	_sgx_map_pxl_y
 2631                        		__and.wi	255
         01:CA7B  29 FF      			and	#255
         01:CA7D  C2         			cly
 2632                        		__st.wmq	_cx
         01:CA7E  85 FC      			sta.l	_cx
         01:CA80  84 FD      			sty.h	_cx
 2633                        		__st.umiq	192, _dl
         01:CA82  A9 C0      			lda.l	#192
         01:CA84  85 FE      			sta	_dl
 2634                        		__call		_sgx_scroll_split.5
         01:CA86  20 8B FF   			call	_sgx_scroll_split.5
 2635                        	
 2636                        		.dbg	line,	"include\routines_LEVELS.c", 99; }
 2637    01:CA89             	.LL7:
 2638                        		__return	0
         01:CA89  4C EF FF   			jmp	leave_proc
 2639                        		.dbg	clear
 2640                        		.endp
 2641                        		.pceas
 2642                        	
 2643                        		.dbg	line,	"include\routines_LEVELS.c", 108; void joypad_BUTTONS()
 2644                        		.dbg	line,	"include\routines_LEVELS.c", 109; {
 2645                        	;***********************
 2646                        	;***********************
 2647                        	
 2648                        		.hucc
 2649    01:C8DD             		.proc		_joypad_BUTTONS
 2650                        		__enter		_joypad_BUTTONS
 2651                        	
 2652                        		.dbg	line,	"include\routines_LEVELS.c", 110; if(joytrg(JOYPAD_1) == JOY_I)
 2653                        		__ld.uiq	0
         01:C8DD  62         			cla
 2654                        		 _joytrg.1
         01:C8DE  AA         			tax
         01:C8DF  BD 2D 22   			lda	joytrg, x
         01:C8E2  BC DD 22   			ldy	joy6trg, x
 2655                        		__equ_w.wi	1
         01:C8E5  C9 01      			cmp.l	#1
         01:C8E7  D0 04      			bne	!false+
         01:C8E9  C0 00      			cpy.h	#1
         01:C8EB  F0 01      			beq	!+
         01:C8ED  18         	!false:		clc
         01:C8EE             	!:
 2656                        		__bfalse	.LL9
         01:C8EE  90 2D      			bcc	.LL9
 2657                        	
 2658                        		.dbg	line,	"include\routines_LEVELS.c", 111; {
 2659                        	
 2660                        		.dbg	line,	"include\routines_LEVELS.c", 112; if(player_state == STATE_IDLE)
 2661                        		__not.um	_player_state
         01:C8F0  AD 05 23   			lda	_player_state
         01:C8F3  18         			clc
         01:C8F4  D0 01      			bne	!+
         01:C8F6  38         			sec
         01:C8F7             	!:
 2662                        		__bfalse	.LL10
         01:C8F7  90 24      			bcc	.LL10
 2663                        	
 2664                        		.dbg	line,	"include\routines_LEVELS.c", 113; {
 2665                        	
 2666                        		.dbg	line,	"include\routines_LEVELS.c", 114; load_vram(PLAYER_VRAM_ADR, tiles_SPR_PLAYER + TILES_112 , TILES_16);
 2667                        		__st.wmiq	18432, _di
         01:C8F9  64 F0      			stz.l	_di
         01:C8FB  A9 48      			lda.h	#18432
         01:C8FD  85 F1      			sta.h	_di
 2668                        		__farptr	_tiles_SPR_PLAYER + 3584, _bp_bank, _bp
         01:C8FF  A9 78      			lda.l	#$6000 + ($1FFF & (_tiles_SPR_PLAYER + 3584))
         01:C901  85 EC      			sta.l	_bp
         01:C903  A9 66      			lda.h	#$6000 + ($1FFF & (_tiles_SPR_PLAYER + 3584))
         01:C905  85 ED      			sta.h	_bp
         01:C907  A9 0B      			lda	#bank(_tiles_SPR_PLAYER + 3584)
         01:C909  85 02      			sta	_bp_bank
 2669                        		__st.wmiq	256, _ax
         01:C90B  64 F8      			stz.l	_ax
         01:C90D  A9 01      			lda.h	#256
         01:C90F  85 F9      			sta.h	_ax
 2670                        		 _load_vram.3
         01:C911  82         			clx				; Offset to PCE VDC.
         01:C912  20 81 FF   			call	load_vram_x
 2671                        	
 2672                        		.dbg	line,	"include\routines_LEVELS.c", 116; player_counter_anim = 0;
 2673                        		__st.umiq	0, _player_counter_anim
         01:C915  9C 08 23   			stz	_player_counter_anim
 2674                        	
 2675                        		.dbg	line,	"include\routines_LEVELS.c", 118; player_state = STATE_JUMP;
 2676                        		__st.umiq	4, _player_state
         01:C918  A9 04      			lda.l	#4
         01:C91A  8D 05 23   			sta	_player_state
 2677                        	
 2678                        		.dbg	line,	"include\routines_LEVELS.c", 119; }
 2679                        	
 2680                        		.dbg	line,	"include\routines_LEVELS.c", 120; }
 2681    01:C91D             	.LL10:
 2682                        	
 2683                        		.dbg	line,	"include\routines_LEVELS.c", 121; }
 2684    01:C91D             	.LL9:
 2685    01:C91D             	.LL8:
 2686                        		__return	0
         01:C91D  4C EF FF   			jmp	leave_proc
 2687                        		.dbg	clear
 2688                        		.endp
 2689                        		.pceas
 2690                        	
 2691                        		.dbg	line,	"include\routines_LEVELS.c", 124; void joypad_DIR()
 2692                        		.dbg	line,	"include\routines_LEVELS.c", 125; {
 2693                        	;***********************
 2694                        	;***********************
 2695                        	
 2696                        		.hucc
 2697    06:DDE0             		.proc		_joypad_DIR
 2698                        		__enter		_joypad_DIR
 2699                        	
 2700                        		.dbg	line,	"include\routines_LEVELS.c", 126; //--------------------------------------------------------------------------------------//
 2701                        	
 2702                        		.dbg	line,	"include\routines_LEVELS.c", 127; //                                        NO DIR                                        //
 2703                        	
 2704                        		.dbg	line,	"include\routines_LEVELS.c", 128; //--------------------------------------------------------------------------------------//
 2705                        	
 2706                        		.dbg	line,	"include\routines_LEVELS.c", 130; if(! (joy(JOYPAD_1) & JOY_DIR_PRESSED) )
 2707                        		__ld.uiq	0
         06:DDE0  62         			cla
 2708                        		 _joy.1
         06:DDE1  AA         			tax
         06:DDE2  BD 28 22   			lda	joynow, x
         06:DDE5  BC D3 22   			ldy	joy6now, x
 2709                        		__nand.wi	240
         06:DDE8  18         			clc
         06:DDE9  29 F0      			and	#240
         06:DDEB  D0 01      			bne	!+
         06:DDED  38         			sec
         06:DDEE             	!:
 2710                        		__bfalse	.LL12
         06:DDEE  90 39      			bcc	.LL12
 2711                        	
 2712                        		.dbg	line,	"include\routines_LEVELS.c", 131; {
 2713                        	
 2714                        		.dbg	line,	"include\routines_LEVELS.c", 132; if(player_state == STATE_WALK || player_state == STATE_CROUCH)
 2715                        		__ld.umq	_player_state
         06:DDF0  AD 05 23   			lda	_player_state
 2716                        		__equ_b.uiq	1
         06:DDF3  C9 01      			cmp	#1
         06:DDF5  F0 01      			beq	!+
         06:DDF7  18         			clc
         06:DDF8             	!:
 2717                        		__btrue		.LL14
         06:DDF8  B0 08      			bcs	.LL14
 2718                        		__ld.umq	_player_state
         06:DDFA  AD 05 23   			lda	_player_state
 2719                        		__equ_b.uiq	7
         06:DDFD  C9 07      			cmp	#7
         06:DDFF  F0 01      			beq	!+
         06:DE01  18         			clc
         06:DE02             	!:
 2720    06:DE02             	.LL14:
 2721                        		__bfalse	.LL13
         06:DE02  90 25      			bcc	.LL13
 2722                        	
 2723                        		.dbg	line,	"include\routines_LEVELS.c", 133; {
 2724                        	
 2725                        		.dbg	line,	"include\routines_LEVELS.c", 134; // A OPTIMISER G_PREVIOUS_STATE //
 2726                        	
 2727                        		.dbg	line,	"include\routines_LEVELS.c", 135; load_vram(PLAYER_VRAM_ADR, tiles_SPR_PLAYER , TILES_16);
 2728                        		__st.wmiq	18432, _di
         06:DE04  64 F0      			stz.l	_di
         06:DE06  A9 48      			lda.h	#18432
         06:DE08  85 F1      			sta.h	_di
 2729                        		__farptr	_tiles_SPR_PLAYER, _bp_bank, _bp
         06:DE0A  A9 78      			lda.l	#$6000 + ($1FFF & (_tiles_SPR_PLAYER))
         06:DE0C  85 EC      			sta.l	_bp
         06:DE0E  A9 78      			lda.h	#$6000 + ($1FFF & (_tiles_SPR_PLAYER))
         06:DE10  85 ED      			sta.h	_bp
         06:DE12  A9 0A      			lda	#bank(_tiles_SPR_PLAYER)
         06:DE14  85 02      			sta	_bp_bank
 2730                        		__st.wmiq	256, _ax
         06:DE16  64 F8      			stz.l	_ax
         06:DE18  A9 01      			lda.h	#256
         06:DE1A  85 F9      			sta.h	_ax
 2731                        		 _load_vram.3
         06:DE1C  82         			clx				; Offset to PCE VDC.
         06:DE1D  20 81 FF   			call	load_vram_x
 2732                        	
 2733                        		.dbg	line,	"include\routines_LEVELS.c", 137; player_counter_anim = 0;
 2734                        		__st.umiq	0, _player_counter_anim
         06:DE20  9C 08 23   			stz	_player_counter_anim
 2735                        	
 2736                        		.dbg	line,	"include\routines_LEVELS.c", 139; player_state = STATE_IDLE;
 2737                        		__st.umiq	0, _player_state
         06:DE23  9C 05 23   			stz	_player_state
 2738                        	
 2739                        		.dbg	line,	"include\routines_LEVELS.c", 141; return;
 2740                        		__bra		.LL11
         06:DE26  4C EF DF   			bra	.LL11
 2741                        	
 2742                        		.dbg	line,	"include\routines_LEVELS.c", 142; }
 2743                        	
 2744                        		.dbg	line,	"include\routines_LEVELS.c", 143; }
 2745    06:DE29             	.LL13:
 2746                        	
 2747                        		.dbg	line,	"include\routines_LEVELS.c", 146; //--------------------------------------------------------------------------------------//
 2748                        	
 2749                        		.dbg	line,	"include\routines_LEVELS.c", 147; //                                     RIGHT BUTTON                                     //
 2750                        	
 2751                        		.dbg	line,	"include\routines_LEVELS.c", 148; //--------------------------------------------------------------------------------------//
 2752                        	
 2753                        		.dbg	line,	"include\routines_LEVELS.c", 150; if(joy(JOYPAD_1) & JOY_RIGHT)
 2754    06:DE29             	.LL12:
 2755                        		__ld.uiq	0
         06:DE29  62         			cla
 2756                        		 _joy.1
         06:DE2A  AA         			tax
         06:DE2B  BD 28 22   			lda	joynow, x
         06:DE2E  BC D3 22   			ldy	joy6now, x
 2757                        		__tand.wi	32
         06:DE31  29 20      			and	#32
         06:DE33  C9 01      	!:		cmp	#1
 2758                        		__bfalse	.LL15
         06:DE35  B0 03 4C E3			bcc	.LL15
         06:DE39  DE          
 2759                        	
 2760                        		.dbg	line,	"include\routines_LEVELS.c", 151; {
 2761                        	
 2762                        		.dbg	line,	"include\routines_LEVELS.c", 152; if(player_state == STATE_IDLE || player_state == STATE_WALK)
 2763                        		__not.um	_player_state
         06:DE3A  AD 05 23   			lda	_player_state
         06:DE3D  18         			clc
         06:DE3E  D0 01      			bne	!+
         06:DE40  38         			sec
         06:DE41             	!:
 2764                        		__btrue		.LL17
         06:DE41  B0 08      			bcs	.LL17
 2765                        		__ld.umq	_player_state
         06:DE43  AD 05 23   			lda	_player_state
 2766                        		__equ_b.uiq	1
         06:DE46  C9 01      			cmp	#1
         06:DE48  F0 01      			beq	!+
         06:DE4A  18         			clc
         06:DE4B             	!:
 2767    06:DE4B             	.LL17:
 2768                        		__bfalse	.LL16
         06:DE4B  90 2F      			bcc	.LL16
 2769                        	
 2770                        		.dbg	line,	"include\routines_LEVELS.c", 153; {
 2771                        	
 2772                        		.dbg	line,	"include\routines_LEVELS.c", 154; player_state = STATE_WALK;
 2773                        		__st.umiq	1, _player_state
         06:DE4D  A9 01      			lda.l	#1
         06:DE4F  8D 05 23   			sta	_player_state
 2774                        	
 2775                        		.dbg	line,	"include\routines_LEVELS.c", 155; player_axis = AXIS_RIGHT;
 2776                        		__st.umiq	0, _player_axis
         06:DE52  9C 06 23   			stz	_player_axis
 2777                        	
 2778                        		.dbg	line,	"include\routines_LEVELS.c", 157; if(player_previous_axis != player_axis)
 2779                        		__ld.umq	_player_previous_axis
         06:DE55  AD 07 23   			lda	_player_previous_axis
 2780                        		__neq_b.umq	_player_axis
         06:DE58  38         			sec
         06:DE59  4D 06 23   			eor	_player_axis
         06:DE5C  D0 01      			bne	!+
         06:DE5E  18         			clc
         06:DE5F             	!:
 2781                        		__bfalse	.LL18
         06:DE5F  B0 03 4C EF			bcc	.LL18
         06:DE63  DF          
 2782                        	
 2783                        		.dbg	line,	"include\routines_LEVELS.c", 158; {
 2784                        	
 2785                        		.dbg	line,	"include\routines_LEVELS.c", 159; player_previous_axis = player_axis;
 2786                        		__ld.um		_player_axis
         06:DE64  AD 06 23   			lda	_player_axis
         06:DE67  C2         			cly
 2787                        		__st.umq	_player_previous_axis
         06:DE68  8D 07 23   			sta	_player_previous_axis
 2788                        	
 2789                        		.dbg	line,	"include\routines_LEVELS.c", 161; spr_set(player_id);
 2790                        		__ld.umq	_player_id
         06:DE6B  AD 04 23   			lda	_player_id
 2791                        		__call		_spr_set.1
         06:DE6E  20 DD E7   			call	_spr_set.1
 2792                        	
 2793                        		.dbg	line,	"include\routines_LEVELS.c", 162; spr_ctrl(FLIP_MAS, NO_FLIP_X);
 2794                        		__st.umiq	136, _al
         06:DE71  A9 88      			lda.l	#136
         06:DE73  85 F8      			sta	_al
 2795                        		__ld.uiq	0
         06:DE75  62         			cla
 2796                        		__call		_spr_ctrl.2
         06:DE76  20 3C E8   			call	_spr_ctrl.2
 2797                        	
 2798                        		.dbg	line,	"include\routines_LEVELS.c", 163; }
 2799                        	
 2800                        		.dbg	line,	"include\routines_LEVELS.c", 164; }
 2801    06:DE79             	.LL18	.alias		.LL19
 2802                        	
 2803                        		.dbg	line,	"include\routines_LEVELS.c", 167; else if(player_state == STATE_JUMP)
 2804                        		__bra		.LL19
         06:DE79  4C EF DF   			bra	.LL19
 2805    06:DE7C             	.LL16:
 2806                        		__ld.umq	_player_state
         06:DE7C  AD 05 23   			lda	_player_state
 2807                        		__equ_b.uiq	4
         06:DE7F  C9 04      			cmp	#4
         06:DE81  F0 01      			beq	!+
         06:DE83  18         			clc
         06:DE84             	!:
 2808                        		__bfalse	.LL20
         06:DE84  90 28      			bcc	.LL20
 2809                        	
 2810                        		.dbg	line,	"include\routines_LEVELS.c", 168; {
 2811                        	
 2812                        		.dbg	line,	"include\routines_LEVELS.c", 169; if(player_axis == AXIS_LEFT)
 2813                        		__ld.umq	_player_axis
         06:DE86  AD 06 23   			lda	_player_axis
 2814                        		__equ_b.uiq	1
         06:DE89  C9 01      			cmp	#1
         06:DE8B  F0 01      			beq	!+
         06:DE8D  18         			clc
         06:DE8E             	!:
 2815                        		__bfalse	.LL21
         06:DE8E  B0 03 4C EF			bcc	.LL21
         06:DE92  DF          
 2816                        	
 2817                        		.dbg	line,	"include\routines_LEVELS.c", 170; {
 2818                        	
 2819                        		.dbg	line,	"include\routines_LEVELS.c", 171; player_axis = AXIS_RIGHT;
 2820                        		__st.umiq	0, _player_axis
         06:DE93  9C 06 23   			stz	_player_axis
 2821                        	
 2822                        		.dbg	line,	"include\routines_LEVELS.c", 172; player_previous_axis = player_axis;
 2823                        		__ld.um		_player_axis
         06:DE96  AD 06 23   			lda	_player_axis
         06:DE99  C2         			cly
 2824                        		__st.umq	_player_previous_axis
         06:DE9A  8D 07 23   			sta	_player_previous_axis
 2825                        	
 2826                        		.dbg	line,	"include\routines_LEVELS.c", 174; spr_set(player_id);
 2827                        		__ld.umq	_player_id
         06:DE9D  AD 04 23   			lda	_player_id
 2828                        		__call		_spr_set.1
         06:DEA0  20 DD E7   			call	_spr_set.1
 2829                        	
 2830                        		.dbg	line,	"include\routines_LEVELS.c", 175; spr_ctrl(FLIP_MAS, NO_FLIP_X);
 2831                        		__st.umiq	136, _al
         06:DEA3  A9 88      			lda.l	#136
         06:DEA5  85 F8      			sta	_al
 2832                        		__ld.uiq	0
         06:DEA7  62         			cla
 2833                        		__call		_spr_ctrl.2
         06:DEA8  20 3C E8   			call	_spr_ctrl.2
 2834                        	
 2835                        		.dbg	line,	"include\routines_LEVELS.c", 176; }
 2836                        	
 2837                        		.dbg	line,	"include\routines_LEVELS.c", 177; }
 2838    06:DEAB             	.LL21	.alias		.LL22
 2839                        	
 2840                        		.dbg	line,	"include\routines_LEVELS.c", 180; else if(player_state == STATE_CROUCH)
 2841                        		__bra		.LL22
         06:DEAB  4C EF DF   			bra	.LL22
 2842    06:DEAE             	.LL20:
 2843                        		__ld.umq	_player_state
         06:DEAE  AD 05 23   			lda	_player_state
 2844                        		__equ_b.uiq	7
         06:DEB1  C9 07      			cmp	#7
         06:DEB3  F0 01      			beq	!+
         06:DEB5  18         			clc
         06:DEB6             	!:
 2845                        		__bfalse	.LL23
         06:DEB6  B0 03 4C EF			bcc	.LL23
         06:DEBA  DF          
 2846                        	
 2847                        		.dbg	line,	"include\routines_LEVELS.c", 181; {
 2848                        	
 2849                        		.dbg	line,	"include\routines_LEVELS.c", 182; if(player_axis == AXIS_LEFT)
 2850                        		__ld.umq	_player_axis
         06:DEBB  AD 06 23   			lda	_player_axis
 2851                        		__equ_b.uiq	1
         06:DEBE  C9 01      			cmp	#1
         06:DEC0  F0 01      			beq	!+
         06:DEC2  18         			clc
         06:DEC3             	!:
 2852                        		__bfalse	.LL24
         06:DEC3  B0 03 4C EF			bcc	.LL24
         06:DEC7  DF          
 2853                        	
 2854                        		.dbg	line,	"include\routines_LEVELS.c", 183; {
 2855                        	
 2856                        		.dbg	line,	"include\routines_LEVELS.c", 184; player_axis = AXIS_RIGHT;
 2857                        		__st.umiq	0, _player_axis
         06:DEC8  9C 06 23   			stz	_player_axis
 2858                        	
 2859                        		.dbg	line,	"include\routines_LEVELS.c", 185; player_previous_axis = player_axis;
 2860                        		__ld.um		_player_axis
         06:DECB  AD 06 23   			lda	_player_axis
         06:DECE  C2         			cly
 2861                        		__st.umq	_player_previous_axis
         06:DECF  8D 07 23   			sta	_player_previous_axis
 2862                        	
 2863                        		.dbg	line,	"include\routines_LEVELS.c", 187; spr_set(player_id);
 2864                        		__ld.umq	_player_id
         06:DED2  AD 04 23   			lda	_player_id
 2865                        		__call		_spr_set.1
         06:DED5  20 DD E7   			call	_spr_set.1
 2866                        	
 2867                        		.dbg	line,	"include\routines_LEVELS.c", 188; spr_ctrl(FLIP_MAS, NO_FLIP_X);
 2868                        		__st.umiq	136, _al
         06:DED8  A9 88      			lda.l	#136
         06:DEDA  85 F8      			sta	_al
 2869                        		__ld.uiq	0
         06:DEDC  62         			cla
 2870                        		__call		_spr_ctrl.2
         06:DEDD  20 3C E8   			call	_spr_ctrl.2
 2871                        	
 2872                        		.dbg	line,	"include\routines_LEVELS.c", 189; }
 2873                        	
 2874                        		.dbg	line,	"include\routines_LEVELS.c", 190; }
 2875    06:DEE0             	.LL24	.alias		.LL25
 2876                        	
 2877                        		.dbg	line,	"include\routines_LEVELS.c", 191; }
 2878    06:DEE0             	.LL23	.alias		.LL25
 2879    06:DEE0             	.LL22	.alias		.LL25
 2880    06:DEE0             	.LL19	.alias		.LL25
 2881                        	
 2882                        		.dbg	line,	"include\routines_LEVELS.c", 194; //--------------------------------------------------------------------------------------//
 2883                        	
 2884                        		.dbg	line,	"include\routines_LEVELS.c", 195; //                                     LEFT BUTTON                                      //
 2885                        	
 2886                        		.dbg	line,	"include\routines_LEVELS.c", 196; //--------------------------------------------------------------------------------------//
 2887                        	
 2888                        		.dbg	line,	"include\routines_LEVELS.c", 198; else if(joy(JOYPAD_1) & JOY_LEFT)
 2889                        		__bra		.LL25
         06:DEE0  4C EF DF   			bra	.LL25
 2890    06:DEE3             	.LL15:
 2891                        		__ld.uiq	0
         06:DEE3  62         			cla
 2892                        		 _joy.1
         06:DEE4  AA         			tax
         06:DEE5  BD 28 22   			lda	joynow, x
         06:DEE8  BC D3 22   			ldy	joy6now, x
 2893                        		__tand.wi	128
         06:DEEB  29 80      			and	#128
         06:DEED  C9 01      	!:		cmp	#1
 2894                        		__bfalse	.LL26
         06:DEEF  B0 03 4C 9D			bcc	.LL26
         06:DEF3  DF          
 2895                        	
 2896                        		.dbg	line,	"include\routines_LEVELS.c", 199; {
 2897                        	
 2898                        		.dbg	line,	"include\routines_LEVELS.c", 200; if(player_state == STATE_IDLE || player_state == STATE_WALK)
 2899                        		__not.um	_player_state
         06:DEF4  AD 05 23   			lda	_player_state
         06:DEF7  18         			clc
         06:DEF8  D0 01      			bne	!+
         06:DEFA  38         			sec
         06:DEFB             	!:
 2900                        		__btrue		.LL28
         06:DEFB  B0 08      			bcs	.LL28
 2901                        		__ld.umq	_player_state
         06:DEFD  AD 05 23   			lda	_player_state
 2902                        		__equ_b.uiq	1
         06:DF00  C9 01      			cmp	#1
         06:DF02  F0 01      			beq	!+
         06:DF04  18         			clc
         06:DF05             	!:
 2903    06:DF05             	.LL28:
 2904                        		__bfalse	.LL27
         06:DF05  90 32      			bcc	.LL27
 2905                        	
 2906                        		.dbg	line,	"include\routines_LEVELS.c", 201; {
 2907                        	
 2908                        		.dbg	line,	"include\routines_LEVELS.c", 202; player_state = STATE_WALK;
 2909                        		__st.umiq	1, _player_state
         06:DF07  A9 01      			lda.l	#1
         06:DF09  8D 05 23   			sta	_player_state
 2910                        	
 2911                        		.dbg	line,	"include\routines_LEVELS.c", 203; player_axis = AXIS_LEFT;
 2912                        		__st.umiq	1, _player_axis
         06:DF0C  A9 01      			lda.l	#1
         06:DF0E  8D 06 23   			sta	_player_axis
 2913                        	
 2914                        		.dbg	line,	"include\routines_LEVELS.c", 205; if(player_previous_axis != player_axis)
 2915                        		__ld.umq	_player_previous_axis
         06:DF11  AD 07 23   			lda	_player_previous_axis
 2916                        		__neq_b.umq	_player_axis
         06:DF14  38         			sec
         06:DF15  4D 06 23   			eor	_player_axis
         06:DF18  D0 01      			bne	!+
         06:DF1A  18         			clc
         06:DF1B             	!:
 2917                        		__bfalse	.LL29
         06:DF1B  B0 03 4C EF			bcc	.LL29
         06:DF1F  DF          
 2918                        	
 2919                        		.dbg	line,	"include\routines_LEVELS.c", 206; {
 2920                        	
 2921                        		.dbg	line,	"include\routines_LEVELS.c", 207; player_previous_axis = player_axis;
 2922                        		__ld.um		_player_axis
         06:DF20  AD 06 23   			lda	_player_axis
         06:DF23  C2         			cly
 2923                        		__st.umq	_player_previous_axis
         06:DF24  8D 07 23   			sta	_player_previous_axis
 2924                        	
 2925                        		.dbg	line,	"include\routines_LEVELS.c", 209; spr_set(player_id);
 2926                        		__ld.umq	_player_id
         06:DF27  AD 04 23   			lda	_player_id
 2927                        		__call		_spr_set.1
         06:DF2A  20 DD E7   			call	_spr_set.1
 2928                        	
 2929                        		.dbg	line,	"include\routines_LEVELS.c", 210; spr_ctrl(FLIP_MAS, FLIP_X);
 2930                        		__st.umiq	136, _al
         06:DF2D  A9 88      			lda.l	#136
         06:DF2F  85 F8      			sta	_al
 2931                        		__ld.uiq	8
         06:DF31  A9 08      			lda	#8
 2932                        		__call		_spr_ctrl.2
         06:DF33  20 3C E8   			call	_spr_ctrl.2
 2933                        	
 2934                        		.dbg	line,	"include\routines_LEVELS.c", 211; }
 2935                        	
 2936                        		.dbg	line,	"include\routines_LEVELS.c", 212; }
 2937    06:DF36             	.LL29	.alias		.LL30
 2938                        	
 2939                        		.dbg	line,	"include\routines_LEVELS.c", 215; else if(player_state == STATE_JUMP)
 2940                        		__bra		.LL30
         06:DF36  4C EF DF   			bra	.LL30
 2941    06:DF39             	.LL27:
 2942                        		__ld.umq	_player_state
         06:DF39  AD 05 23   			lda	_player_state
 2943                        		__equ_b.uiq	4
         06:DF3C  C9 04      			cmp	#4
         06:DF3E  F0 01      			beq	!+
         06:DF40  18         			clc
         06:DF41             	!:
 2944                        		__bfalse	.LL31
         06:DF41  90 2A      			bcc	.LL31
 2945                        	
 2946                        		.dbg	line,	"include\routines_LEVELS.c", 216; {
 2947                        	
 2948                        		.dbg	line,	"include\routines_LEVELS.c", 217; if(player_axis == AXIS_RIGHT)
 2949                        		__not.um	_player_axis
         06:DF43  AD 06 23   			lda	_player_axis
         06:DF46  18         			clc
         06:DF47  D0 01      			bne	!+
         06:DF49  38         			sec
         06:DF4A             	!:
 2950                        		__bfalse	.LL32
         06:DF4A  B0 03 4C EF			bcc	.LL32
         06:DF4E  DF          
 2951                        	
 2952                        		.dbg	line,	"include\routines_LEVELS.c", 218; {
 2953                        	
 2954                        		.dbg	line,	"include\routines_LEVELS.c", 219; player_axis = AXIS_LEFT;
 2955                        		__st.umiq	1, _player_axis
         06:DF4F  A9 01      			lda.l	#1
         06:DF51  8D 06 23   			sta	_player_axis
 2956                        	
 2957                        		.dbg	line,	"include\routines_LEVELS.c", 220; player_previous_axis = player_axis;
 2958                        		__ld.um		_player_axis
         06:DF54  AD 06 23   			lda	_player_axis
         06:DF57  C2         			cly
 2959                        		__st.umq	_player_previous_axis
         06:DF58  8D 07 23   			sta	_player_previous_axis
 2960                        	
 2961                        		.dbg	line,	"include\routines_LEVELS.c", 222; spr_set(player_id);
 2962                        		__ld.umq	_player_id
         06:DF5B  AD 04 23   			lda	_player_id
 2963                        		__call		_spr_set.1
         06:DF5E  20 DD E7   			call	_spr_set.1
 2964                        	
 2965                        		.dbg	line,	"include\routines_LEVELS.c", 223; spr_ctrl(FLIP_MAS, FLIP_X);
 2966                        		__st.umiq	136, _al
         06:DF61  A9 88      			lda.l	#136
         06:DF63  85 F8      			sta	_al
 2967                        		__ld.uiq	8
         06:DF65  A9 08      			lda	#8
 2968                        		__call		_spr_ctrl.2
         06:DF67  20 3C E8   			call	_spr_ctrl.2
 2969                        	
 2970                        		.dbg	line,	"include\routines_LEVELS.c", 224; }
 2971                        	
 2972                        		.dbg	line,	"include\routines_LEVELS.c", 225; }
 2973    06:DF6A             	.LL32	.alias		.LL33
 2974                        	
 2975                        		.dbg	line,	"include\routines_LEVELS.c", 228; else if(player_state == STATE_CROUCH)
 2976                        		__bra		.LL33
         06:DF6A  4C EF DF   			bra	.LL33
 2977    06:DF6D             	.LL31:
 2978                        		__ld.umq	_player_state
         06:DF6D  AD 05 23   			lda	_player_state
 2979                        		__equ_b.uiq	7
         06:DF70  C9 07      			cmp	#7
         06:DF72  F0 01      			beq	!+
         06:DF74  18         			clc
         06:DF75             	!:
 2980                        		__bfalse	.LL34
         06:DF75  90 78      			bcc	.LL34
 2981                        	
 2982                        		.dbg	line,	"include\routines_LEVELS.c", 229; {
 2983                        	
 2984                        		.dbg	line,	"include\routines_LEVELS.c", 230; if(player_axis == AXIS_RIGHT)
 2985                        		__not.um	_player_axis
         06:DF77  AD 06 23   			lda	_player_axis
         06:DF7A  18         			clc
         06:DF7B  D0 01      			bne	!+
         06:DF7D  38         			sec
         06:DF7E             	!:
 2986                        		__bfalse	.LL35
         06:DF7E  90 6F      			bcc	.LL35
 2987                        	
 2988                        		.dbg	line,	"include\routines_LEVELS.c", 231; {
 2989                        	
 2990                        		.dbg	line,	"include\routines_LEVELS.c", 232; player_axis = AXIS_LEFT;
 2991                        		__st.umiq	1, _player_axis
         06:DF80  A9 01      			lda.l	#1
         06:DF82  8D 06 23   			sta	_player_axis
 2992                        	
 2993                        		.dbg	line,	"include\routines_LEVELS.c", 233; player_previous_axis = player_axis;
 2994                        		__ld.um		_player_axis
         06:DF85  AD 06 23   			lda	_player_axis
         06:DF88  C2         			cly
 2995                        		__st.umq	_player_previous_axis
         06:DF89  8D 07 23   			sta	_player_previous_axis
 2996                        	
 2997                        		.dbg	line,	"include\routines_LEVELS.c", 235; spr_set(player_id);
 2998                        		__ld.umq	_player_id
         06:DF8C  AD 04 23   			lda	_player_id
 2999                        		__call		_spr_set.1
         06:DF8F  20 DD E7   			call	_spr_set.1
 3000                        	
 3001                        		.dbg	line,	"include\routines_LEVELS.c", 236; spr_ctrl(FLIP_MAS, FLIP_X);
 3002                        		__st.umiq	136, _al
         06:DF92  A9 88      			lda.l	#136
         06:DF94  85 F8      			sta	_al
 3003                        		__ld.uiq	8
         06:DF96  A9 08      			lda	#8
 3004                        		__call		_spr_ctrl.2
         06:DF98  20 3C E8   			call	_spr_ctrl.2
 3005                        	
 3006                        		.dbg	line,	"include\routines_LEVELS.c", 237; }
 3007                        	
 3008                        		.dbg	line,	"include\routines_LEVELS.c", 238; }
 3009    06:DF9B             	.LL35	.alias		.LL36
 3010                        	
 3011                        		.dbg	line,	"include\routines_LEVELS.c", 239; }
 3012    06:DF9B             	.LL34	.alias		.LL36
 3013    06:DF9B             	.LL33	.alias		.LL36
 3014    06:DF9B             	.LL30	.alias		.LL36
 3015                        	
 3016                        		.dbg	line,	"include\routines_LEVELS.c", 242; //--------------------------------------------------------------------------------------//
 3017                        	
 3018                        		.dbg	line,	"include\routines_LEVELS.c", 243; //                                      UP BUTTON                                       //
 3019                        	
 3020                        		.dbg	line,	"include\routines_LEVELS.c", 244; //--------------------------------------------------------------------------------------//
 3021                        	
 3022                        		.dbg	line,	"include\routines_LEVELS.c", 246; else if(joy(JOYPAD_1) & JOY_UP)
 3023                        		__bra		.LL36
         06:DF9B  80 52      			bra	.LL36
 3024    06:DF9D             	.LL26:
 3025                        		__ld.uiq	0
         06:DF9D  62         			cla
 3026                        		 _joy.1
         06:DF9E  AA         			tax
         06:DF9F  BD 28 22   			lda	joynow, x
         06:DFA2  BC D3 22   			ldy	joy6now, x
 3027                        		__tand.wi	16
         06:DFA5  29 10      			and	#16
         06:DFA7  C9 01      	!:		cmp	#1
 3028                        		__bfalse	.LL37
         06:DFA9  90 02      			bcc	.LL37
 3029                        	
 3030                        		.dbg	line,	"include\routines_LEVELS.c", 247; {
 3031                        	
 3032                        		.dbg	line,	"include\routines_LEVELS.c", 248; //
 3033                        	
 3034                        		.dbg	line,	"include\routines_LEVELS.c", 249; }
 3035                        	
 3036                        		.dbg	line,	"include\routines_LEVELS.c", 252; //--------------------------------------------------------------------------------------//
 3037                        	
 3038                        		.dbg	line,	"include\routines_LEVELS.c", 253; //                                     DOWN BUTTON                                      //
 3039                        	
 3040                        		.dbg	line,	"include\routines_LEVELS.c", 254; //--------------------------------------------------------------------------------------//
 3041                        	
 3042                        		.dbg	line,	"include\routines_LEVELS.c", 256; else if(joy(JOYPAD_1) & JOY_DOWN)
 3043                        		__bra		.LL38
         06:DFAB  80 42      			bra	.LL38
 3044    06:DFAD             	.LL37:
 3045                        		__ld.uiq	0
         06:DFAD  62         			cla
 3046                        		 _joy.1
         06:DFAE  AA         			tax
         06:DFAF  BD 28 22   			lda	joynow, x
         06:DFB2  BC D3 22   			ldy	joy6now, x
 3047                        		__tand.wi	64
         06:DFB5  29 40      			and	#64
         06:DFB7  C9 01      	!:		cmp	#1
 3048                        		__bfalse	.LL39
         06:DFB9  90 34      			bcc	.LL39
 3049                        	
 3050                        		.dbg	line,	"include\routines_LEVELS.c", 257; {
 3051                        	
 3052                        		.dbg	line,	"include\routines_LEVELS.c", 258; if(player_state == STATE_IDLE || player_state == STATE_WALK)
 3053                        		__not.um	_player_state
         06:DFBB  AD 05 23   			lda	_player_state
         06:DFBE  18         			clc
         06:DFBF  D0 01      			bne	!+
         06:DFC1  38         			sec
         06:DFC2             	!:
 3054                        		__btrue		.LL41
         06:DFC2  B0 08      			bcs	.LL41
 3055                        		__ld.umq	_player_state
         06:DFC4  AD 05 23   			lda	_player_state
 3056                        		__equ_b.uiq	1
         06:DFC7  C9 01      			cmp	#1
         06:DFC9  F0 01      			beq	!+
         06:DFCB  18         			clc
         06:DFCC             	!:
 3057    06:DFCC             	.LL41:
 3058                        		__bfalse	.LL40
         06:DFCC  90 21      			bcc	.LL40
 3059                        	
 3060                        		.dbg	line,	"include\routines_LEVELS.c", 259; {
 3061                        	
 3062                        		.dbg	line,	"include\routines_LEVELS.c", 260; player_state = STATE_CROUCH;
 3063                        		__st.umiq	7, _player_state
         06:DFCE  A9 07      			lda.l	#7
         06:DFD0  8D 05 23   			sta	_player_state
 3064                        	
 3065                        		.dbg	line,	"include\routines_LEVELS.c", 262; load_vram(PLAYER_VRAM_ADR, tiles_SPR_PLAYER + TILES_128 , TILES_16);
 3066                        		__st.wmiq	18432, _di
         06:DFD3  64 F0      			stz.l	_di
         06:DFD5  A9 48      			lda.h	#18432
         06:DFD7  85 F1      			sta.h	_di
 3067                        		__farptr	_tiles_SPR_PLAYER + 4096, _bp_bank, _bp
         06:DFD9  A9 78      			lda.l	#$6000 + ($1FFF & (_tiles_SPR_PLAYER + 4096))
         06:DFDB  85 EC      			sta.l	_bp
         06:DFDD  A9 68      			lda.h	#$6000 + ($1FFF & (_tiles_SPR_PLAYER + 4096))
         06:DFDF  85 ED      			sta.h	_bp
         06:DFE1  A9 0B      			lda	#bank(_tiles_SPR_PLAYER + 4096)
         06:DFE3  85 02      			sta	_bp_bank
 3068                        		__st.wmiq	256, _ax
         06:DFE5  64 F8      			stz.l	_ax
         06:DFE7  A9 01      			lda.h	#256
         06:DFE9  85 F9      			sta.h	_ax
 3069                        		 _load_vram.3
         06:DFEB  82         			clx				; Offset to PCE VDC.
         06:DFEC  20 81 FF   			call	load_vram_x
 3070                        	
 3071                        		.dbg	line,	"include\routines_LEVELS.c", 263; }
 3072                        	
 3073                        		.dbg	line,	"include\routines_LEVELS.c", 264; }
 3074    06:DFEF             	.LL40:
 3075                        	
 3076                        		.dbg	line,	"include\routines_LEVELS.c", 265; }
 3077    06:DFEF             	.LL39:
 3078    06:DFEF             	.LL38:
 3079    06:DFEF             	.LL36:
 3080    06:DFEF             	.LL25:
 3081    06:DFEF             	.LL11:
 3082                        		__return	0
         06:DFEF  4C EF FF   			jmp	leave_proc
 3083                        		.dbg	clear
 3084                        		.endp
 3085                        		.pceas
 3086                        	
 3087                        		.dbg	line,	"include\routines_LEVELS.c", 270; void update_PLAYER()
 3088                        		.dbg	line,	"include\routines_LEVELS.c", 271; {
 3089                        	;***********************
 3090                        	;***********************
 3091                        	
 3092                        		.hucc
 3093    0B:D872             		.proc		_update_PLAYER
 3094                        		__enter		_update_PLAYER
 3095                        	
 3096                        		.dbg	line,	"include\routines_LEVELS.c", 272; if(player_state == STATE_WALK)
 3097                        		__ld.umq	_player_state
         0B:D872  AD 05 23   			lda	_player_state
 3098                        		__equ_b.uiq	1
         0B:D875  C9 01      			cmp	#1
         0B:D877  F0 01      			beq	!+
         0B:D879  18         			clc
         0B:D87A             	!:
 3099                        		__bfalse	.LL43
         0B:D87A  B0 03 4C 74			bcc	.LL43
         0B:D87E  DA          
 3100                        	
 3101                        		.dbg	line,	"include\routines_LEVELS.c", 273; {
 3102                        	
 3103                        		.dbg	line,	"include\routines_LEVELS.c", 274; if(player_axis == AXIS_RIGHT)
 3104                        		__not.um	_player_axis
         0B:D87F  AD 06 23   			lda	_player_axis
         0B:D882  18         			clc
         0B:D883  D0 01      			bne	!+
         0B:D885  38         			sec
         0B:D886             	!:
 3105                        		__bfalse	.LL44
         0B:D886  90 42      			bcc	.LL44
 3106                        	
 3107                        		.dbg	line,	"include\routines_LEVELS.c", 275; {
 3108                        	
 3109                        		.dbg	line,	"include\routines_LEVELS.c", 276; // CHECK COLLISION WITH FLOOR //
 3110                        	
 3111                        		.dbg	line,	"include\routines_LEVELS.c", 277; check_FLOOR_R();
 3112                        		__call		_check_FLOOR_R
         0B:D888  20 77 FF   			call	_check_FLOOR_R
 3113                        	
 3114                        		.dbg	line,	"include\routines_LEVELS.c", 279; if(map_blk_flag == TILE_EMPTY)
 3115                        		__not.um	_map_blk_flag
         0B:D88B  AD 77 28   			lda	_map_blk_flag
         0B:D88E  18         			clc
         0B:D88F  D0 01      			bne	!+
         0B:D891  38         			sec
         0B:D892             	!:
 3116                        		__bfalse	.LL45
         0B:D892  90 0B      			bcc	.LL45
 3117                        	
 3118                        		.dbg	line,	"include\routines_LEVELS.c", 280; {
 3119                        	
 3120                        		.dbg	line,	"include\routines_LEVELS.c", 281; player_counter_anim = 0;
 3121                        		__st.umiq	0, _player_counter_anim
         0B:D894  9C 08 23   			stz	_player_counter_anim
 3122                        	
 3123                        		.dbg	line,	"include\routines_LEVELS.c", 283; player_state = STATE_FALL;
 3124                        		__st.umiq	9, _player_state
         0B:D897  A9 09      			lda.l	#9
         0B:D899  8D 05 23   			sta	_player_state
 3125                        	
 3126                        		.dbg	line,	"include\routines_LEVELS.c", 285; return;
 3127                        		__bra		.LL42
         0B:D89C  4C B8 DB   			bra	.LL42
 3128                        	
 3129                        		.dbg	line,	"include\routines_LEVELS.c", 286; }
 3130                        	
 3131                        		.dbg	line,	"include\routines_LEVELS.c", 290; // CHECK COLLISION WITH WALLS //
 3132                        	
 3133                        		.dbg	line,	"include\routines_LEVELS.c", 291; check_WALL_R();
 3134    0B:D89F             	.LL45:
 3135                        		__call		_check_WALL_R
         0B:D89F  20 6D FF   			call	_check_WALL_R
 3136                        	
 3137                        		.dbg	line,	"include\routines_LEVELS.c", 293; if(map_blk_flag == TILE_EMPTY)
 3138                        		__not.um	_map_blk_flag
         0B:D8A2  AD 77 28   			lda	_map_blk_flag
         0B:D8A5  18         			clc
         0B:D8A6  D0 01      			bne	!+
         0B:D8A8  38         			sec
         0B:D8A9             	!:
 3139                        		__bfalse	.LL46
         0B:D8A9  90 69      			bcc	.LL46
 3140                        	
 3141                        		.dbg	line,	"include\routines_LEVELS.c", 294; {
 3142                        	
 3143                        		.dbg	line,	"include\routines_LEVELS.c", 295; sgx_map_pxl_x += 2;
 3144                        		__add_st.wmiq	2, _sgx_map_pxl_x
         0B:D8AB  18         			clc
         0B:D8AC  AD 56 23   			lda.l	_sgx_map_pxl_x
         0B:D8AF  69 02      			adc.l	#2
         0B:D8B1  8D 56 23   			sta.l	_sgx_map_pxl_x
         0B:D8B4  90 03      			bcc	!+
         0B:D8B6  EE 57 23   			inc.h	_sgx_map_pxl_x
         0B:D8B9             	!:
 3145                        	
 3146                        		.dbg	line,	"include\routines_LEVELS.c", 297; vdc_map_pxl_x = sgx_map_pxl_x;
 3147                        		__ld.wm		_sgx_map_pxl_x
         0B:D8B9  AD 56 23   			lda.l	_sgx_map_pxl_x
         0B:D8BC  AC 57 23   			ldy.h	_sgx_map_pxl_x
 3148                        		__st.wmq	_vdc_map_pxl_x
         0B:D8BF  8D 46 23   			sta.l	_vdc_map_pxl_x
         0B:D8C2  8C 47 23   			sty.h	_vdc_map_pxl_x
 3149                        	
 3150                        		.dbg	line,	"include\routines_LEVELS.c", 299; scroll_BG();
 3151                        		__call		_scroll_BG
         0B:D8C5  20 63 FF   			call	_scroll_BG
 3152                        	
 3153                        		.dbg	line,	"include\routines_LEVELS.c", 300; }
 3154                        	
 3155                        		.dbg	line,	"include\routines_LEVELS.c", 301; }
 3156    0B:D8C8             	.LL46	.alias		.LL47
 3157                        	
 3158                        		.dbg	line,	"include\routines_LEVELS.c", 304; else if(player_axis == AXIS_LEFT)
 3159                        		__bra		.LL47
         0B:D8C8  80 4A      			bra	.LL47
 3160    0B:D8CA             	.LL44:
 3161                        		__ld.umq	_player_axis
         0B:D8CA  AD 06 23   			lda	_player_axis
 3162                        		__equ_b.uiq	1
         0B:D8CD  C9 01      			cmp	#1
         0B:D8CF  F0 01      			beq	!+
         0B:D8D1  18         			clc
         0B:D8D2             	!:
 3163                        		__bfalse	.LL48
         0B:D8D2  90 40      			bcc	.LL48
 3164                        	
 3165                        		.dbg	line,	"include\routines_LEVELS.c", 305; {
 3166                        	
 3167                        		.dbg	line,	"include\routines_LEVELS.c", 306; // CHECK COLLISION WITH FLOOR //
 3168                        	
 3169                        		.dbg	line,	"include\routines_LEVELS.c", 307; check_FLOOR_L();
 3170                        		__call		_check_FLOOR_L
         0B:D8D4  20 59 FF   			call	_check_FLOOR_L
 3171                        	
 3172                        		.dbg	line,	"include\routines_LEVELS.c", 309; if(map_blk_flag == TILE_EMPTY)
 3173                        		__not.um	_map_blk_flag
         0B:D8D7  AD 77 28   			lda	_map_blk_flag
         0B:D8DA  18         			clc
         0B:D8DB  D0 01      			bne	!+
         0B:D8DD  38         			sec
         0B:D8DE             	!:
 3174                        		__bfalse	.LL49
         0B:D8DE  90 0B      			bcc	.LL49
 3175                        	
 3176                        		.dbg	line,	"include\routines_LEVELS.c", 310; {
 3177                        	
 3178                        		.dbg	line,	"include\routines_LEVELS.c", 311; player_counter_anim = 0;
 3179                        		__st.umiq	0, _player_counter_anim
         0B:D8E0  9C 08 23   			stz	_player_counter_anim
 3180                        	
 3181                        		.dbg	line,	"include\routines_LEVELS.c", 313; player_state = STATE_FALL;
 3182                        		__st.umiq	9, _player_state
         0B:D8E3  A9 09      			lda.l	#9
         0B:D8E5  8D 05 23   			sta	_player_state
 3183                        	
 3184                        		.dbg	line,	"include\routines_LEVELS.c", 315; return;
 3185                        		__bra		.LL42
         0B:D8E8  4C B8 DB   			bra	.LL42
 3186                        	
 3187                        		.dbg	line,	"include\routines_LEVELS.c", 316; }
 3188                        	
 3189                        		.dbg	line,	"include\routines_LEVELS.c", 319; // CHECK COLLISION WITH BG //
 3190                        	
 3191                        		.dbg	line,	"include\routines_LEVELS.c", 320; check_WALL_L();
 3192    0B:D8EB             	.LL49:
 3193                        		__call		_check_WALL_L
         0B:D8EB  20 4F FF   			call	_check_WALL_L
 3194                        	
 3195                        		.dbg	line,	"include\routines_LEVELS.c", 322; if(map_blk_flag == TILE_EMPTY)
 3196                        		__not.um	_map_blk_flag
         0B:D8EE  AD 77 28   			lda	_map_blk_flag
         0B:D8F1  18         			clc
         0B:D8F2  D0 01      			bne	!+
         0B:D8F4  38         			sec
         0B:D8F5             	!:
 3197                        		__bfalse	.LL50
         0B:D8F5  90 1D      			bcc	.LL50
 3198                        	
 3199                        		.dbg	line,	"include\routines_LEVELS.c", 323; {
 3200                        	
 3201                        		.dbg	line,	"include\routines_LEVELS.c", 324; sgx_map_pxl_x -= 2;
 3202                        		__sub_st.wmiq	2, _sgx_map_pxl_x
         0B:D8F7  38         			sec
         0B:D8F8  AD 56 23   			lda.l	_sgx_map_pxl_x
         0B:D8FB  E9 02      			sbc.l	#2
         0B:D8FD  8D 56 23   			sta.l	_sgx_map_pxl_x
         0B:D900  B0 03      			bcs	!+
         0B:D902  CE 57 23   			dec.h	_sgx_map_pxl_x
         0B:D905             	!:
 3203                        	
 3204                        		.dbg	line,	"include\routines_LEVELS.c", 326; vdc_map_pxl_x = sgx_map_pxl_x;
 3205                        		__ld.wm		_sgx_map_pxl_x
         0B:D905  AD 56 23   			lda.l	_sgx_map_pxl_x
         0B:D908  AC 57 23   			ldy.h	_sgx_map_pxl_x
 3206                        		__st.wmq	_vdc_map_pxl_x
         0B:D90B  8D 46 23   			sta.l	_vdc_map_pxl_x
         0B:D90E  8C 47 23   			sty.h	_vdc_map_pxl_x
 3207                        	
 3208                        		.dbg	line,	"include\routines_LEVELS.c", 328; scroll_BG();
 3209                        		__call		_scroll_BG
         0B:D911  20 63 FF   			call	_scroll_BG
 3210                        	
 3211                        		.dbg	line,	"include\routines_LEVELS.c", 329; }
 3212                        	
 3213                        		.dbg	line,	"include\routines_LEVELS.c", 330; }
 3214    0B:D914             	.LL50:
 3215                        	
 3216                        		.dbg	line,	"include\routines_LEVELS.c", 335; spr_set(player_id);
 3217    0B:D914             	.LL48:
 3218    0B:D914             	.LL47:
 3219                        		__ld.umq	_player_id
         0B:D914  AD 04 23   			lda	_player_id
 3220                        		__call		_spr_set.1
         0B:D917  20 DD E7   			call	_spr_set.1
 3221                        	
 3222                        		.dbg	line,	"include\routines_LEVELS.c", 338; // UPDATE PLAYER TILES //
 3223                        	
 3224                        		.dbg	line,	"include\routines_LEVELS.c", 339; if(player_counter_anim == 0)
 3225                        		__not.um	_player_counter_anim
         0B:D91A  AD 08 23   			lda	_player_counter_anim
         0B:D91D  18         			clc
         0B:D91E  D0 01      			bne	!+
         0B:D920  38         			sec
         0B:D921             	!:
 3226                        		__bfalse	.LL51
         0B:D921  90 1F      			bcc	.LL51
 3227                        	
 3228                        		.dbg	line,	"include\routines_LEVELS.c", 340; {
 3229                        	
 3230                        		.dbg	line,	"include\routines_LEVELS.c", 341; load_vram(PLAYER_VRAM_ADR, tiles_SPR_PLAYER , TILES_16);
 3231                        		__st.wmiq	18432, _di
         0B:D923  64 F0      			stz.l	_di
         0B:D925  A9 48      			lda.h	#18432
         0B:D927  85 F1      			sta.h	_di
 3232                        		__farptr	_tiles_SPR_PLAYER, _bp_bank, _bp
         0B:D929  A9 78      			lda.l	#$6000 + ($1FFF & (_tiles_SPR_PLAYER))
         0B:D92B  85 EC      			sta.l	_bp
         0B:D92D  A9 78      			lda.h	#$6000 + ($1FFF & (_tiles_SPR_PLAYER))
         0B:D92F  85 ED      			sta.h	_bp
         0B:D931  A9 0A      			lda	#bank(_tiles_SPR_PLAYER)
         0B:D933  85 02      			sta	_bp_bank
 3233                        		__st.wmiq	256, _ax
         0B:D935  64 F8      			stz.l	_ax
         0B:D937  A9 01      			lda.h	#256
         0B:D939  85 F9      			sta.h	_ax
 3234                        		 _load_vram.3
         0B:D93B  82         			clx				; Offset to PCE VDC.
         0B:D93C  20 81 FF   			call	load_vram_x
 3235                        	
 3236                        		.dbg	line,	"include\routines_LEVELS.c", 342; }
 3237                        	
 3238                        		.dbg	line,	"include\routines_LEVELS.c", 345; else if(player_counter_anim == 2)
 3239                        		__bra		.LL52
         0B:D93F  4C 6E DA   			bra	.LL52
 3240    0B:D942             	.LL51:
 3241                        		__ld.umq	_player_counter_anim
         0B:D942  AD 08 23   			lda	_player_counter_anim
 3242                        		__equ_b.uiq	2
         0B:D945  C9 02      			cmp	#2
         0B:D947  F0 01      			beq	!+
         0B:D949  18         			clc
         0B:D94A             	!:
 3243                        		__bfalse	.LL53
         0B:D94A  90 1F      			bcc	.LL53
 3244                        	
 3245                        		.dbg	line,	"include\routines_LEVELS.c", 346; {
 3246                        	
 3247                        		.dbg	line,	"include\routines_LEVELS.c", 347; load_vram(PLAYER_VRAM_ADR, tiles_SPR_PLAYER + TILES_16 , TILES_16);
 3248                        		__st.wmiq	18432, _di
         0B:D94C  64 F0      			stz.l	_di
         0B:D94E  A9 48      			lda.h	#18432
         0B:D950  85 F1      			sta.h	_di
 3249                        		__farptr	_tiles_SPR_PLAYER + 512, _bp_bank, _bp
         0B:D952  A9 78      			lda.l	#$6000 + ($1FFF & (_tiles_SPR_PLAYER + 512))
         0B:D954  85 EC      			sta.l	_bp
         0B:D956  A9 7A      			lda.h	#$6000 + ($1FFF & (_tiles_SPR_PLAYER + 512))
         0B:D958  85 ED      			sta.h	_bp
         0B:D95A  A9 0A      			lda	#bank(_tiles_SPR_PLAYER + 512)
         0B:D95C  85 02      			sta	_bp_bank
 3250                        		__st.wmiq	256, _ax
         0B:D95E  64 F8      			stz.l	_ax
         0B:D960  A9 01      			lda.h	#256
         0B:D962  85 F9      			sta.h	_ax
 3251                        		 _load_vram.3
         0B:D964  82         			clx				; Offset to PCE VDC.
         0B:D965  20 81 FF   			call	load_vram_x
 3252                        	
 3253                        		.dbg	line,	"include\routines_LEVELS.c", 348; }
 3254                        	
 3255                        		.dbg	line,	"include\routines_LEVELS.c", 351; else if(player_counter_anim == 5)
 3256                        		__bra		.LL54
         0B:D968  4C 6E DA   			bra	.LL54
 3257    0B:D96B             	.LL53:
 3258                        		__ld.umq	_player_counter_anim
         0B:D96B  AD 08 23   			lda	_player_counter_anim
 3259                        		__equ_b.uiq	5
         0B:D96E  C9 05      			cmp	#5
         0B:D970  F0 01      			beq	!+
         0B:D972  18         			clc
         0B:D973             	!:
 3260                        		__bfalse	.LL55
         0B:D973  90 1F      			bcc	.LL55
 3261                        	
 3262                        		.dbg	line,	"include\routines_LEVELS.c", 352; {
 3263                        	
 3264                        		.dbg	line,	"include\routines_LEVELS.c", 353; load_vram(PLAYER_VRAM_ADR, tiles_SPR_PLAYER + TILES_32 , TILES_16);
 3265                        		__st.wmiq	18432, _di
         0B:D975  64 F0      			stz.l	_di
         0B:D977  A9 48      			lda.h	#18432
         0B:D979  85 F1      			sta.h	_di
 3266                        		__farptr	_tiles_SPR_PLAYER + 1024, _bp_bank, _bp
         0B:D97B  A9 78      			lda.l	#$6000 + ($1FFF & (_tiles_SPR_PLAYER + 1024))
         0B:D97D  85 EC      			sta.l	_bp
         0B:D97F  A9 7C      			lda.h	#$6000 + ($1FFF & (_tiles_SPR_PLAYER + 1024))
         0B:D981  85 ED      			sta.h	_bp
         0B:D983  A9 0A      			lda	#bank(_tiles_SPR_PLAYER + 1024)
         0B:D985  85 02      			sta	_bp_bank
 3267                        		__st.wmiq	256, _ax
         0B:D987  64 F8      			stz.l	_ax
         0B:D989  A9 01      			lda.h	#256
         0B:D98B  85 F9      			sta.h	_ax
 3268                        		 _load_vram.3
         0B:D98D  82         			clx				; Offset to PCE VDC.
         0B:D98E  20 81 FF   			call	load_vram_x
 3269                        	
 3270                        		.dbg	line,	"include\routines_LEVELS.c", 354; }
 3271                        	
 3272                        		.dbg	line,	"include\routines_LEVELS.c", 357; else if(player_counter_anim == 8)
 3273                        		__bra		.LL56
         0B:D991  4C 6E DA   			bra	.LL56
 3274    0B:D994             	.LL55:
 3275                        		__ld.umq	_player_counter_anim
         0B:D994  AD 08 23   			lda	_player_counter_anim
 3276                        		__equ_b.uiq	8
         0B:D997  C9 08      			cmp	#8
         0B:D999  F0 01      			beq	!+
         0B:D99B  18         			clc
         0B:D99C             	!:
 3277                        		__bfalse	.LL57
         0B:D99C  90 1F      			bcc	.LL57
 3278                        	
 3279                        		.dbg	line,	"include\routines_LEVELS.c", 358; {
 3280                        	
 3281                        		.dbg	line,	"include\routines_LEVELS.c", 359; load_vram(PLAYER_VRAM_ADR, tiles_SPR_PLAYER + TILES_48 , TILES_16);
 3282                        		__st.wmiq	18432, _di
         0B:D99E  64 F0      			stz.l	_di
         0B:D9A0  A9 48      			lda.h	#18432
         0B:D9A2  85 F1      			sta.h	_di
 3283                        		__farptr	_tiles_SPR_PLAYER + 1536, _bp_bank, _bp
         0B:D9A4  A9 78      			lda.l	#$6000 + ($1FFF & (_tiles_SPR_PLAYER + 1536))
         0B:D9A6  85 EC      			sta.l	_bp
         0B:D9A8  A9 7E      			lda.h	#$6000 + ($1FFF & (_tiles_SPR_PLAYER + 1536))
         0B:D9AA  85 ED      			sta.h	_bp
         0B:D9AC  A9 0A      			lda	#bank(_tiles_SPR_PLAYER + 1536)
         0B:D9AE  85 02      			sta	_bp_bank
 3284                        		__st.wmiq	256, _ax
         0B:D9B0  64 F8      			stz.l	_ax
         0B:D9B2  A9 01      			lda.h	#256
         0B:D9B4  85 F9      			sta.h	_ax
 3285                        		 _load_vram.3
         0B:D9B6  82         			clx				; Offset to PCE VDC.
         0B:D9B7  20 81 FF   			call	load_vram_x
 3286                        	
 3287                        		.dbg	line,	"include\routines_LEVELS.c", 360; }
 3288                        	
 3289                        		.dbg	line,	"include\routines_LEVELS.c", 363; else if(player_counter_anim == 11)
 3290                        		__bra		.LL58
         0B:D9BA  4C 6E DA   			bra	.LL58
 3291    0B:D9BD             	.LL57:
 3292                        		__ld.umq	_player_counter_anim
         0B:D9BD  AD 08 23   			lda	_player_counter_anim
 3293                        		__equ_b.uiq	11
         0B:D9C0  C9 0B      			cmp	#11
         0B:D9C2  F0 01      			beq	!+
         0B:D9C4  18         			clc
         0B:D9C5             	!:
 3294                        		__bfalse	.LL59
         0B:D9C5  90 1F      			bcc	.LL59
 3295                        	
 3296                        		.dbg	line,	"include\routines_LEVELS.c", 364; {
 3297                        	
 3298                        		.dbg	line,	"include\routines_LEVELS.c", 365; load_vram(PLAYER_VRAM_ADR, tiles_SPR_PLAYER , TILES_16);
 3299                        		__st.wmiq	18432, _di
         0B:D9C7  64 F0      			stz.l	_di
         0B:D9C9  A9 48      			lda.h	#18432
         0B:D9CB  85 F1      			sta.h	_di
 3300                        		__farptr	_tiles_SPR_PLAYER, _bp_bank, _bp
         0B:D9CD  A9 78      			lda.l	#$6000 + ($1FFF & (_tiles_SPR_PLAYER))
         0B:D9CF  85 EC      			sta.l	_bp
         0B:D9D1  A9 78      			lda.h	#$6000 + ($1FFF & (_tiles_SPR_PLAYER))
         0B:D9D3  85 ED      			sta.h	_bp
         0B:D9D5  A9 0A      			lda	#bank(_tiles_SPR_PLAYER)
         0B:D9D7  85 02      			sta	_bp_bank
 3301                        		__st.wmiq	256, _ax
         0B:D9D9  64 F8      			stz.l	_ax
         0B:D9DB  A9 01      			lda.h	#256
         0B:D9DD  85 F9      			sta.h	_ax
 3302                        		 _load_vram.3
         0B:D9DF  82         			clx				; Offset to PCE VDC.
         0B:D9E0  20 81 FF   			call	load_vram_x
 3303                        	
 3304                        		.dbg	line,	"include\routines_LEVELS.c", 366; }
 3305                        	
 3306                        		.dbg	line,	"include\routines_LEVELS.c", 369; else if(player_counter_anim == 14)
 3307                        		__bra		.LL60
         0B:D9E3  4C 6E DA   			bra	.LL60
 3308    0B:D9E6             	.LL59:
 3309                        		__ld.umq	_player_counter_anim
         0B:D9E6  AD 08 23   			lda	_player_counter_anim
 3310                        		__equ_b.uiq	14
         0B:D9E9  C9 0E      			cmp	#14
         0B:D9EB  F0 01      			beq	!+
         0B:D9ED  18         			clc
         0B:D9EE             	!:
 3311                        		__bfalse	.LL61
         0B:D9EE  90 1E      			bcc	.LL61
 3312                        	
 3313                        		.dbg	line,	"include\routines_LEVELS.c", 370; {
 3314                        	
 3315                        		.dbg	line,	"include\routines_LEVELS.c", 371; load_vram(PLAYER_VRAM_ADR, tiles_SPR_PLAYER + TILES_64 , TILES_16);
 3316                        		__st.wmiq	18432, _di
         0B:D9F0  64 F0      			stz.l	_di
         0B:D9F2  A9 48      			lda.h	#18432
         0B:D9F4  85 F1      			sta.h	_di
 3317                        		__farptr	_tiles_SPR_PLAYER + 2048, _bp_bank, _bp
         0B:D9F6  A9 78      			lda.l	#$6000 + ($1FFF & (_tiles_SPR_PLAYER + 2048))
         0B:D9F8  85 EC      			sta.l	_bp
         0B:D9FA  A9 60      			lda.h	#$6000 + ($1FFF & (_tiles_SPR_PLAYER + 2048))
         0B:D9FC  85 ED      			sta.h	_bp
         0B:D9FE  A9 0B      			lda	#bank(_tiles_SPR_PLAYER + 2048)
         0B:DA00  85 02      			sta	_bp_bank
 3318                        		__st.wmiq	256, _ax
         0B:DA02  64 F8      			stz.l	_ax
         0B:DA04  A9 01      			lda.h	#256
         0B:DA06  85 F9      			sta.h	_ax
 3319                        		 _load_vram.3
         0B:DA08  82         			clx				; Offset to PCE VDC.
         0B:DA09  20 81 FF   			call	load_vram_x
 3320                        	
 3321                        		.dbg	line,	"include\routines_LEVELS.c", 372; }
 3322                        	
 3323                        		.dbg	line,	"include\routines_LEVELS.c", 375; else if(player_counter_anim == 17)
 3324                        		__bra		.LL62
         0B:DA0C  80 60      			bra	.LL62
 3325    0B:DA0E             	.LL61:
 3326                        		__ld.umq	_player_counter_anim
         0B:DA0E  AD 08 23   			lda	_player_counter_anim
 3327                        		__equ_b.uiq	17
         0B:DA11  C9 11      			cmp	#17
         0B:DA13  F0 01      			beq	!+
         0B:DA15  18         			clc
         0B:DA16             	!:
 3328                        		__bfalse	.LL63
         0B:DA16  90 1E      			bcc	.LL63
 3329                        	
 3330                        		.dbg	line,	"include\routines_LEVELS.c", 376; {
 3331                        	
 3332                        		.dbg	line,	"include\routines_LEVELS.c", 377; load_vram(PLAYER_VRAM_ADR, tiles_SPR_PLAYER + TILES_80 , TILES_16);
 3333                        		__st.wmiq	18432, _di
         0B:DA18  64 F0      			stz.l	_di
         0B:DA1A  A9 48      			lda.h	#18432
         0B:DA1C  85 F1      			sta.h	_di
 3334                        		__farptr	_tiles_SPR_PLAYER + 2560, _bp_bank, _bp
         0B:DA1E  A9 78      			lda.l	#$6000 + ($1FFF & (_tiles_SPR_PLAYER + 2560))
         0B:DA20  85 EC      			sta.l	_bp
         0B:DA22  A9 62      			lda.h	#$6000 + ($1FFF & (_tiles_SPR_PLAYER + 2560))
         0B:DA24  85 ED      			sta.h	_bp
         0B:DA26  A9 0B      			lda	#bank(_tiles_SPR_PLAYER + 2560)
         0B:DA28  85 02      			sta	_bp_bank
 3335                        		__st.wmiq	256, _ax
         0B:DA2A  64 F8      			stz.l	_ax
         0B:DA2C  A9 01      			lda.h	#256
         0B:DA2E  85 F9      			sta.h	_ax
 3336                        		 _load_vram.3
         0B:DA30  82         			clx				; Offset to PCE VDC.
         0B:DA31  20 81 FF   			call	load_vram_x
 3337                        	
 3338                        		.dbg	line,	"include\routines_LEVELS.c", 378; }
 3339                        	
 3340                        		.dbg	line,	"include\routines_LEVELS.c", 381; else if(player_counter_anim == 20)
 3341                        		__bra		.LL64
         0B:DA34  80 38      			bra	.LL64
 3342    0B:DA36             	.LL63:
 3343                        		__ld.umq	_player_counter_anim
         0B:DA36  AD 08 23   			lda	_player_counter_anim
 3344                        		__equ_b.uiq	20
         0B:DA39  C9 14      			cmp	#20
         0B:DA3B  F0 01      			beq	!+
         0B:DA3D  18         			clc
         0B:DA3E             	!:
 3345                        		__bfalse	.LL65
         0B:DA3E  90 1E      			bcc	.LL65
 3346                        	
 3347                        		.dbg	line,	"include\routines_LEVELS.c", 382; {
 3348                        	
 3349                        		.dbg	line,	"include\routines_LEVELS.c", 383; load_vram(PLAYER_VRAM_ADR, tiles_SPR_PLAYER + TILES_96 , TILES_16);
 3350                        		__st.wmiq	18432, _di
         0B:DA40  64 F0      			stz.l	_di
         0B:DA42  A9 48      			lda.h	#18432
         0B:DA44  85 F1      			sta.h	_di
 3351                        		__farptr	_tiles_SPR_PLAYER + 3072, _bp_bank, _bp
         0B:DA46  A9 78      			lda.l	#$6000 + ($1FFF & (_tiles_SPR_PLAYER + 3072))
         0B:DA48  85 EC      			sta.l	_bp
         0B:DA4A  A9 64      			lda.h	#$6000 + ($1FFF & (_tiles_SPR_PLAYER + 3072))
         0B:DA4C  85 ED      			sta.h	_bp
         0B:DA4E  A9 0B      			lda	#bank(_tiles_SPR_PLAYER + 3072)
         0B:DA50  85 02      			sta	_bp_bank
 3352                        		__st.wmiq	256, _ax
         0B:DA52  64 F8      			stz.l	_ax
         0B:DA54  A9 01      			lda.h	#256
         0B:DA56  85 F9      			sta.h	_ax
 3353                        		 _load_vram.3
         0B:DA58  82         			clx				; Offset to PCE VDC.
         0B:DA59  20 81 FF   			call	load_vram_x
 3354                        	
 3355                        		.dbg	line,	"include\routines_LEVELS.c", 384; }
 3356                        	
 3357                        		.dbg	line,	"include\routines_LEVELS.c", 387; else if(player_counter_anim == 22)
 3358                        		__bra		.LL66
         0B:DA5C  80 10      			bra	.LL66
 3359    0B:DA5E             	.LL65:
 3360                        		__ld.umq	_player_counter_anim
         0B:DA5E  AD 08 23   			lda	_player_counter_anim
 3361                        		__equ_b.uiq	22
         0B:DA61  C9 16      			cmp	#22
         0B:DA63  F0 01      			beq	!+
         0B:DA65  18         			clc
         0B:DA66             	!:
 3362                        		__bfalse	.LL67
         0B:DA66  90 06      			bcc	.LL67
 3363                        	
 3364                        		.dbg	line,	"include\routines_LEVELS.c", 388; {
 3365                        	
 3366                        		.dbg	line,	"include\routines_LEVELS.c", 389; player_counter_anim = 0;
 3367                        		__st.umiq	0, _player_counter_anim
         0B:DA68  9C 08 23   			stz	_player_counter_anim
 3368                        	
 3369                        		.dbg	line,	"include\routines_LEVELS.c", 391; return;
 3370                        		__bra		.LL42
         0B:DA6B  4C B8 DB   			bra	.LL42
 3371                        	
 3372                        		.dbg	line,	"include\routines_LEVELS.c", 392; }
 3373                        	
 3374                        		.dbg	line,	"include\routines_LEVELS.c", 395; player_counter_anim += 1;
 3375    0B:DA6E             	.LL67:
 3376    0B:DA6E             	.LL66:
 3377    0B:DA6E             	.LL64:
 3378    0B:DA6E             	.LL62:
 3379    0B:DA6E             	.LL60:
 3380    0B:DA6E             	.LL58:
 3381    0B:DA6E             	.LL56:
 3382    0B:DA6E             	.LL54:
 3383    0B:DA6E             	.LL52:
 3384                        		__add_st.umiq	1, _player_counter_anim
         0B:DA6E  EE 08 23   			inc	_player_counter_anim
 3385                        	
 3386                        		.dbg	line,	"include\routines_LEVELS.c", 397; }
 3387                        	
 3388                        		.dbg	line,	"include\routines_LEVELS.c", 400; else if(player_state == STATE_JUMP)
 3389                        		__bra		.LL68
         0B:DA71  4C B8 DB   			bra	.LL68
 3390    0B:DA74             	.LL43:
 3391                        		__ld.umq	_player_state
         0B:DA74  AD 05 23   			lda	_player_state
 3392                        		__equ_b.uiq	4
         0B:DA77  C9 04      			cmp	#4
         0B:DA79  F0 01      			beq	!+
         0B:DA7B  18         			clc
         0B:DA7C             	!:
 3393                        		__bfalse	.LL69
         0B:DA7C  B0 03 4C AE			bcc	.LL69
         0B:DA80  DB          
 3394                        	
 3395                        		.dbg	line,	"include\routines_LEVELS.c", 401; {
 3396                        	
 3397                        		.dbg	line,	"include\routines_LEVELS.c", 402; unsigned char i;
 3398                        	
 3399                        		.dbg	line,	"include\routines_LEVELS.c", 403; i = 0;
 3400                        		__st.umiq	0, __update_PLAYER_end - 1  /* i */
         0B:DA81  9C 00 23   			stz	__update_PLAYER_end - 1
 3401                        	
 3402                        		.dbg	line,	"include\routines_LEVELS.c", 406; spr_set(player_id);
 3403                        		__ld.umq	_player_id
         0B:DA84  AD 04 23   			lda	_player_id
 3404                        		__call		_spr_set.1
         0B:DA87  20 DD E7   			call	_spr_set.1
 3405                        	
 3406                        		.dbg	line,	"include\routines_LEVELS.c", 407; player_pos_y += TABLE_PLAYER_JUMP_V[player_index_jump];
 3407                        		__ldx.umq	_player_index_jump
         0B:DA8A  AE 09 23   			ldx	_player_index_jump
 3408                        		__ld.bax	_TABLE_PLAYER_JUMP_V
         0B:DA8D  BD 1D 60   			lda	_TABLE_PLAYER_JUMP_V, x
         0B:DA90  C2         			cly
         0B:DA91  10 01      			bpl	!+
         0B:DA93  88         			dey
         0B:DA94             	!:
 3409                        		__add_st.wmq	_player_pos_y
         0B:DA94  18         			clc
         0B:DA95  6D 0C 23   			adc.l	_player_pos_y
         0B:DA98  8D 0C 23   			sta.l	_player_pos_y
         0B:DA9B  98         			tya
         0B:DA9C  6D 0D 23   			adc.h	_player_pos_y
         0B:DA9F  8D 0D 23   			sta.h	_player_pos_y
 3410                        	
 3411                        		.dbg	line,	"include\routines_LEVELS.c", 408; spr_y(player_pos_y);
 3412                        		__ld.wm		_player_pos_y
         0B:DAA2  AD 0C 23   			lda.l	_player_pos_y
         0B:DAA5  AC 0D 23   			ldy.h	_player_pos_y
 3413                        		__call		_spr_y.1
         0B:DAA8  20 19 E8   			call	_spr_y.1
 3414                        	
 3415                        		.dbg	line,	"include\routines_LEVELS.c", 412; if(player_index_jump < 34)
 3416                        		__ld.umq	_player_index_jump
         0B:DAAB  AD 09 23   			lda	_player_index_jump
 3417                        		__ult_b.uiq	34
         0B:DAAE  C9 22      			cmp	#34		; Subtract integer from A.
         0B:DAB0  6A         			ror	a		; CC if A < integer.
         0B:DAB1  49 80      			eor	#$80
         0B:DAB3  2A         			rol	a
 3418                        		__bfalse	.LL70
         0B:DAB4  90 03      			bcc	.LL70
 3419                        	
 3420                        		.dbg	line,	"include\routines_LEVELS.c", 413; {
 3421                        	
 3422                        		.dbg	line,	"include\routines_LEVELS.c", 414; player_index_jump += 1;
 3423                        		__add_st.umiq	1, _player_index_jump
         0B:DAB6  EE 09 23   			inc	_player_index_jump
 3424                        	
 3425                        		.dbg	line,	"include\routines_LEVELS.c", 415; }
 3426                        	
 3427                        		.dbg	line,	"include\routines_LEVELS.c", 418; // CHECK COLLISION WITH FLOOR //
 3428                        	
 3429                        		.dbg	line,	"include\routines_LEVELS.c", 419; if(player_axis == AXIS_RIGHT)
 3430    0B:DAB9             	.LL70:
 3431                        		__not.um	_player_axis
         0B:DAB9  AD 06 23   			lda	_player_axis
         0B:DABC  18         			clc
         0B:DABD  D0 01      			bne	!+
         0B:DABF  38         			sec
         0B:DAC0             	!:
 3432                        		__bfalse	.LL71
         0B:DAC0  90 05      			bcc	.LL71
 3433                        	
 3434                        		.dbg	line,	"include\routines_LEVELS.c", 420; {
 3435                        	
 3436                        		.dbg	line,	"include\routines_LEVELS.c", 421; check_FLOOR_R();
 3437                        		__call		_check_FLOOR_R
         0B:DAC2  20 77 FF   			call	_check_FLOOR_R
 3438                        	
 3439                        		.dbg	line,	"include\routines_LEVELS.c", 422; }
 3440                        	
 3441                        		.dbg	line,	"include\routines_LEVELS.c", 424; else
 3442                        		__bra		.LL72
         0B:DAC5  80 03      			bra	.LL72
 3443    0B:DAC7             	.LL71:
 3444                        	
 3445                        		.dbg	line,	"include\routines_LEVELS.c", 425; {
 3446                        	
 3447                        		.dbg	line,	"include\routines_LEVELS.c", 426; check_FLOOR_L();
 3448                        		__call		_check_FLOOR_L
         0B:DAC7  20 59 FF   			call	_check_FLOOR_L
 3449                        	
 3450                        		.dbg	line,	"include\routines_LEVELS.c", 427; }
 3451    0B:DACA             	.LL72:
 3452                        	
 3453                        		.dbg	line,	"include\routines_LEVELS.c", 430; if(map_blk_flag == TILE_BG)
 3454                        		__ld.umq	_map_blk_flag
         0B:DACA  AD 77 28   			lda	_map_blk_flag
 3455                        		__equ_b.uiq	1
         0B:DACD  C9 01      			cmp	#1
         0B:DACF  F0 01      			beq	!+
         0B:DAD1  18         			clc
         0B:DAD2             	!:
 3456                        		__bfalse	.LL73
         0B:DAD2  B0 03 4C B8			bcc	.LL73
         0B:DAD6  DB          
 3457                        	
 3458                        		.dbg	line,	"include\routines_LEVELS.c", 431; {
 3459                        	
 3460                        		.dbg	line,	"include\routines_LEVELS.c", 432; // CALCULATE HOW MANY PIXELS THE PLAYER MOVED INTO THE GROUND //
 3461                        	
 3462                        		.dbg	line,	"include\routines_LEVELS.c", 433; for(i=1; i<11 ; i++ )
 3463                        		__st.umiq	1, __update_PLAYER_end - 1  /* i */
         0B:DAD7  A9 01      			lda.l	#1
         0B:DAD9  8D 00 23   			sta	__update_PLAYER_end - 1
 3464    0B:DADC             	.LL74:
 3465                        		__ld.umq	__update_PLAYER_end - 1  /* i */
         0B:DADC  AD 00 23   			lda	__update_PLAYER_end - 1
 3466                        		__ult_b.uiq	11
         0B:DADF  C9 0B      			cmp	#11		; Subtract integer from A.
         0B:DAE1  6A         			ror	a		; CC if A < integer.
         0B:DAE2  49 80      			eor	#$80
         0B:DAE4  2A         			rol	a
 3467                        		__btrue		.LL76
         0B:DAE5  B0 08      			bcs	.LL76
 3468                        		__bra		.LL77
         0B:DAE7  4C 85 DB   			bra	.LL77
 3469    0B:DAEA             	.LL75:
 3470                        		__inc.umq	__update_PLAYER_end - 1  /* i */
         0B:DAEA  EE 00 23   			inc	__update_PLAYER_end - 1
 3471                        		__bra		.LL74
         0B:DAED  80 ED      			bra	.LL74
 3472    0B:DAEF             	.LL76:
 3473                        	
 3474                        		.dbg	line,	"include\routines_LEVELS.c", 434; {
 3475                        	
 3476                        		.dbg	line,	"include\routines_LEVELS.c", 435; if(player_axis == AXIS_RIGHT)
 3477                        		__not.um	_player_axis
         0B:DAEF  AD 06 23   			lda	_player_axis
         0B:DAF2  18         			clc
         0B:DAF3  D0 01      			bne	!+
         0B:DAF5  38         			sec
         0B:DAF6             	!:
 3478                        		__bfalse	.LL78
         0B:DAF6  90 20      			bcc	.LL78
 3479                        	
 3480                        		.dbg	line,	"include\routines_LEVELS.c", 436; {
 3481                        	
 3482                        		.dbg	line,	"include\routines_LEVELS.c", 437; calculate_COLLISION_DEEP( 11 , i);
 3483                        		__ld.wi		11
         0B:DAF8  A9 0B      			lda.l	#11
         0B:DAFA  C2         			cly
 3484                        		__pusharg.wr
         0B:DAFB  A6 8D      			ldx	<__sp
         0B:DAFD  CA         			dex
         0B:DAFE  CA         			dex
         0B:DAFF  95 08      			sta.l	<__stack, x
         0B:DB01  94 09      			sty.h	<__stack, x
         0B:DB03  86 8D      			stx	<__sp
 3485                        		__ld.um		__update_PLAYER_end - 1  /* i */
         0B:DB05  AD 00 23   			lda	__update_PLAYER_end - 1
         0B:DB08  C2         			cly
 3486                        		__pusharg.wr
         0B:DB09  A6 8D      			ldx	<__sp
         0B:DB0B  CA         			dex
         0B:DB0C  CA         			dex
         0B:DB0D  95 08      			sta.l	<__stack, x
         0B:DB0F  94 09      			sty.h	<__stack, x
         0B:DB11  86 8D      			stx	<__sp
 3487                        		__call		_calculate_COLLISION_DEEP
         0B:DB13  20 45 FF   			call	_calculate_COLLISION_DEEP
 3488                        	
 3489                        		.dbg	line,	"include\routines_LEVELS.c", 438; }
 3490                        	
 3491                        		.dbg	line,	"include\routines_LEVELS.c", 440; else
 3492                        		__bra		.LL79
         0B:DB16  80 1E      			bra	.LL79
 3493    0B:DB18             	.LL78:
 3494                        	
 3495                        		.dbg	line,	"include\routines_LEVELS.c", 441; {
 3496                        	
 3497                        		.dbg	line,	"include\routines_LEVELS.c", 442; calculate_COLLISION_DEEP( 10 , i);
 3498                        		__ld.wi		10
         0B:DB18  A9 0A      			lda.l	#10
         0B:DB1A  C2         			cly
 3499                        		__pusharg.wr
         0B:DB1B  A6 8D      			ldx	<__sp
         0B:DB1D  CA         			dex
         0B:DB1E  CA         			dex
         0B:DB1F  95 08      			sta.l	<__stack, x
         0B:DB21  94 09      			sty.h	<__stack, x
         0B:DB23  86 8D      			stx	<__sp
 3500                        		__ld.um		__update_PLAYER_end - 1  /* i */
         0B:DB25  AD 00 23   			lda	__update_PLAYER_end - 1
         0B:DB28  C2         			cly
 3501                        		__pusharg.wr
         0B:DB29  A6 8D      			ldx	<__sp
         0B:DB2B  CA         			dex
         0B:DB2C  CA         			dex
         0B:DB2D  95 08      			sta.l	<__stack, x
         0B:DB2F  94 09      			sty.h	<__stack, x
         0B:DB31  86 8D      			stx	<__sp
 3502                        		__call		_calculate_COLLISION_DEEP
         0B:DB33  20 45 FF   			call	_calculate_COLLISION_DEEP
 3503                        	
 3504                        		.dbg	line,	"include\routines_LEVELS.c", 443; }
 3505    0B:DB36             	.LL79:
 3506                        	
 3507                        		.dbg	line,	"include\routines_LEVELS.c", 446; if(map_blk_flag == TILE_EMPTY)
 3508                        		__not.um	_map_blk_flag
         0B:DB36  AD 77 28   			lda	_map_blk_flag
         0B:DB39  18         			clc
         0B:DB3A  D0 01      			bne	!+
         0B:DB3C  38         			sec
         0B:DB3D             	!:
 3509                        		__bfalse	.LL80
         0B:DB3D  90 AB      			bcc	.LL80
 3510                        	
 3511                        		.dbg	line,	"include\routines_LEVELS.c", 447; {
 3512                        	
 3513                        		.dbg	line,	"include\routines_LEVELS.c", 448; load_vram(PLAYER_VRAM_ADR, tiles_SPR_PLAYER , TILES_16);
 3514                        		__st.wmiq	18432, _di
         0B:DB3F  64 F0      			stz.l	_di
         0B:DB41  A9 48      			lda.h	#18432
         0B:DB43  85 F1      			sta.h	_di
 3515                        		__farptr	_tiles_SPR_PLAYER, _bp_bank, _bp
         0B:DB45  A9 78      			lda.l	#$6000 + ($1FFF & (_tiles_SPR_PLAYER))
         0B:DB47  85 EC      			sta.l	_bp
         0B:DB49  A9 78      			lda.h	#$6000 + ($1FFF & (_tiles_SPR_PLAYER))
         0B:DB4B  85 ED      			sta.h	_bp
         0B:DB4D  A9 0A      			lda	#bank(_tiles_SPR_PLAYER)
         0B:DB4F  85 02      			sta	_bp_bank
 3516                        		__st.wmiq	256, _ax
         0B:DB51  64 F8      			stz.l	_ax
         0B:DB53  A9 01      			lda.h	#256
         0B:DB55  85 F9      			sta.h	_ax
 3517                        		 _load_vram.3
         0B:DB57  82         			clx				; Offset to PCE VDC.
         0B:DB58  20 81 FF   			call	load_vram_x
 3518                        	
 3519                        		.dbg	line,	"include\routines_LEVELS.c", 450; player_pos_y -= (i - 1);
 3520                        		__ld.um		__update_PLAYER_end - 1  /* i */
         0B:DB5B  AD 00 23   			lda	__update_PLAYER_end - 1
         0B:DB5E  C2         			cly
 3521                        		__sub.wi	1
         0B:DB5F  38         			sec
         0B:DB60  E9 01      			sbc.l	#1
         0B:DB62  B0 01      			bcs	!+
         0B:DB64  88         			dey
         0B:DB65             	!:
 3522                        		__isub_st.wmq	_player_pos_y
         0B:DB65  38         			sec
         0B:DB66  49 FF      			eor	#$FF
         0B:DB68  6D 0C 23   			adc.l	_player_pos_y
         0B:DB6B  8D 0C 23   			sta.l	_player_pos_y
         0B:DB6E  98         			tya
         0B:DB6F  49 FF      			eor	#$FF
         0B:DB71  6D 0D 23   			adc.h	_player_pos_y
         0B:DB74  8D 0D 23   			sta.h	_player_pos_y
 3523                        	
 3524                        		.dbg	line,	"include\routines_LEVELS.c", 451; spr_y(player_pos_y);
 3525                        		__ld.wm		_player_pos_y
         0B:DB77  AD 0C 23   			lda.l	_player_pos_y
         0B:DB7A  AC 0D 23   			ldy.h	_player_pos_y
 3526                        		__call		_spr_y.1
         0B:DB7D  20 19 E8   			call	_spr_y.1
 3527                        	
 3528                        		.dbg	line,	"include\routines_LEVELS.c", 453; break;
 3529                        		__bra		.LL77
         0B:DB80  80 03      			bra	.LL77
 3530                        	
 3531                        		.dbg	line,	"include\routines_LEVELS.c", 454; }
 3532                        	
 3533                        		.dbg	line,	"include\routines_LEVELS.c", 456; }
 3534    0B:DB82             	.LL80	.alias		.LL75
 3535                        		__bra		.LL75
         0B:DB82  4C EA DA   			bra	.LL75
 3536    0B:DB85             	.LL77:
 3537                        	
 3538                        		.dbg	line,	"include\routines_LEVELS.c", 459; load_vram(PLAYER_VRAM_ADR, tiles_SPR_PLAYER , TILES_16);
 3539                        		__st.wmiq	18432, _di
         0B:DB85  64 F0      			stz.l	_di
         0B:DB87  A9 48      			lda.h	#18432
         0B:DB89  85 F1      			sta.h	_di
 3540                        		__farptr	_tiles_SPR_PLAYER, _bp_bank, _bp
         0B:DB8B  A9 78      			lda.l	#$6000 + ($1FFF & (_tiles_SPR_PLAYER))
         0B:DB8D  85 EC      			sta.l	_bp
         0B:DB8F  A9 78      			lda.h	#$6000 + ($1FFF & (_tiles_SPR_PLAYER))
         0B:DB91  85 ED      			sta.h	_bp
         0B:DB93  A9 0A      			lda	#bank(_tiles_SPR_PLAYER)
         0B:DB95  85 02      			sta	_bp_bank
 3541                        		__st.wmiq	256, _ax
         0B:DB97  64 F8      			stz.l	_ax
         0B:DB99  A9 01      			lda.h	#256
         0B:DB9B  85 F9      			sta.h	_ax
 3542                        		 _load_vram.3
         0B:DB9D  82         			clx				; Offset to PCE VDC.
         0B:DB9E  20 81 FF   			call	load_vram_x
 3543                        	
 3544                        		.dbg	line,	"include\routines_LEVELS.c", 461; player_counter_anim = 0;
 3545                        		__st.umiq	0, _player_counter_anim
         0B:DBA1  9C 08 23   			stz	_player_counter_anim
 3546                        	
 3547                        		.dbg	line,	"include\routines_LEVELS.c", 462; player_index_jump = 0;
 3548                        		__st.umiq	0, _player_index_jump
         0B:DBA4  9C 09 23   			stz	_player_index_jump
 3549                        	
 3550                        		.dbg	line,	"include\routines_LEVELS.c", 464; player_state = STATE_IDLE;
 3551                        		__st.umiq	0, _player_state
         0B:DBA7  9C 05 23   			stz	_player_state
 3552                        	
 3553                        		.dbg	line,	"include\routines_LEVELS.c", 466; return;
 3554                        		__bra		.LL42
         0B:DBAA  80 0C      			bra	.LL42
 3555                        	
 3556                        		.dbg	line,	"include\routines_LEVELS.c", 467; }
 3557                        	
 3558                        		.dbg	line,	"include\routines_LEVELS.c", 468; }
 3559    0B:DBAC             	.LL73	.alias		.LL81
 3560                        	
 3561                        		.dbg	line,	"include\routines_LEVELS.c", 471; else if(player_state == STATE_FALL)
 3562                        		__bra		.LL81
         0B:DBAC  80 0A      			bra	.LL81
 3563    0B:DBAE             	.LL69:
 3564                        		__ld.umq	_player_state
         0B:DBAE  AD 05 23   			lda	_player_state
 3565                        		__equ_b.uiq	9
         0B:DBB1  C9 09      			cmp	#9
         0B:DBB3  F0 01      			beq	!+
         0B:DBB5  18         			clc
         0B:DBB6             	!:
 3566                        		__bfalse	.LL82
         0B:DBB6  90 00      			bcc	.LL82
 3567                        	
 3568                        		.dbg	line,	"include\routines_LEVELS.c", 472; {
 3569                        	
 3570                        		.dbg	line,	"include\routines_LEVELS.c", 473; //
 3571                        	
 3572                        		.dbg	line,	"include\routines_LEVELS.c", 474; }
 3573                        	
 3574                        		.dbg	line,	"include\routines_LEVELS.c", 475; }
 3575    0B:DBB8             	.LL82:
 3576    0B:DBB8             	.LL81:
 3577    0B:DBB8             	.LL68:
 3578    0B:DBB8             	.LL42:
 3579                        		__return	0
         0B:DBB8  4C EF FF   			jmp	leave_proc
 3580                        		.dbg	clear
 3581                        		.endp
 3582               6C78     		.data
 3583               2300     		.bss
 3584    F8:2300             	__update_PLAYER_loc:
 3585    F8:2300             			ds	1
 3586    F8:2301             	__update_PLAYER_end:
 3587               E309     		.code
 3588                        		.pceas
 3589                        	
 3590                        		.dbg	line,	"main.c", 22; #include "include/init.c"
 3591                        		.dbg	line,	"include\init.c", 1; #include "huc.h"
 3592                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 1; #ifndef _hucc_legacy_h
 3593                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 2; #define _hucc_legacy_h
 3594                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 4; /****************************************************************************
 3595                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 5; ; ***************************************************************************
 3596                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 6; ;
 3597                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 7; ; huc.h
 3598                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 8; ;
 3599                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 9; ; HuCC wrapper file to include a default set of HuC-compatible functions.
 3600                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 10; ;
 3601                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 11; ; Copyright John Brandwood 2024.
 3602                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 12; ;
 3603                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 13; ; Distributed under the Boost Software License, Version 1.0.
 3604                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 14; ; (See accompanying file LICENSE_1_0.txt or copy at
 3605                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 15; ;  http://www.boost.org/LICENSE_1_0.txt)
 3606                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 16; ;
 3607                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 17; ; ***************************************************************************
 3608                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 18; ; ***************************************************************************
 3609                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 19; ;
 3610                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 20; ; When the HuCC compiler is invoked with the "--legacy" option to compile old
 3611                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 21; ; projects, then this "huc.h" file is automatically included.
 3612                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 22; ;
 3613                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 23; ; This file includes a set of the individual HuCC headers which correspond to
 3614                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 24; ; HuC's built-in functions and MagicKit library.
 3615                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 25; ;
 3616                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 26; ; New HuCC projects should, preferably, include the specific headers that are
 3617                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 27; ; needed, which will then allow them to replace parts of the standard library
 3618                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 28; ; with newer functions, or they can just manually include this "huc.h" file.
 3619                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 29; ;
 3620                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 30; ; ***************************************************************************
 3621                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 31; ; **************************************************************************/
 3622                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 33; #include "hucc-systemcard.h"
 3623                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 34; #include "hucc-baselib.h"
 3624                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 35; #include "hucc-gfx.h"
 3625                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 36; #include "hucc-string.h"
 3626                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 37; #include "hucc-old-scroll.h"
 3627                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 38; #include "hucc-old-spr.h"
 3628                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 39; #include "hucc-old-map.h"
 3629                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 40; #include "hucc-old-line.h"
 3630                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 42; #endif // _hucc_legacy_h
 3631                        		.dbg	line,	"include\init.c", 2; #include "hucc-scroll.h"
 3632                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 1; #ifndef _hucc_scroll_h
 3633                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 2; #define _hucc_scroll_h
 3634                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 4; /****************************************************************************
 3635                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 5; ; ***************************************************************************
 3636                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 6; ;
 3637                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 7; ; hucc-scroll.h
 3638                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 8; ;
 3639                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 9; ; Routines for a fast split-screen scrolling system.
 3640                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 10; ;
 3641                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 11; ; Copyright John Brandwood 2024.
 3642                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 12; ;
 3643                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 13; ; Distributed under the Boost Software License, Version 1.0.
 3644                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 14; ; (See accompanying file LICENSE_1_0.txt or copy at
 3645                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 15; ;  http://www.boost.org/LICENSE_1_0.txt)
 3646                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 16; ;
 3647                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 17; ; ***************************************************************************
 3648                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 18; ; ***************************************************************************
 3649                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 19; ;
 3650                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 20; ; The maximum number of splits for each screen layer is set in your project's
 3651                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 21; ; "hucc-config.inc" file, with the library having a limit of 128-per-layer.
 3652                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 22; ;
 3653                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 23; ; Your first active split must be defined to start at screen line 0, and then
 3654                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 24; ; the rest of the active splits must be in increasing line order to match the
 3655                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 25; ; way that the PC Engine displays the output image.
 3656                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 26; ;
 3657                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 27; ; You can have disabled splits interleaved with your active splits.
 3658                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 28; ;
 3659                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 29; ; Splits that are normally disabled can be used to create full screen effects
 3660                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 30; ; such as bouncing the screen up and down by adding blank areas at the top or
 3661                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 31; ; bottom of the screen, and then rapidly changing the height of those areas.
 3662                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 32; ;
 3663                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 33; ; ***************************************************************************
 3664                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 34; ; **************************************************************************/
 3665                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 36; // *************
 3666                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 37; // VDC bits for display_flags ...
 3667                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 38; // *************
 3668                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 40; #ifndef BKG_OFF
 3669                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 41; #define BKG_OFF 0x00
 3670                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 42; #endif
 3671                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 44; #ifndef SPR_OFF
 3672                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 45; #define SPR_OFF 0x00
 3673                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 46; #endif
 3674                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 48; #ifndef BKG_ON
 3675                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 49; #define BKG_ON 0x80
 3676                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 50; #endif
 3677                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 52; #ifndef SPR_ON
 3678                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 53; #define SPR_ON 0x40
 3679                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 54; #endif
 3680                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 56; // *************
 3681                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 57; // Functions in hucc-scroll.asm ...
 3682                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 58; // *************
 3683                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 60; #ifdef __HUCC__
 3684                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 62; #asmdef	HUCC_USES_NEW_SCROLL 1
 3685                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 64; extern void __fastcall scroll_split( unsigned char index<_al>, unsigned char screen_line<_ah>, unsigned int bat_x<_bx>, unsigned int bat_y<_cx>, unsigned char display_flags<_dl> );
 3686                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 65; extern void __fastcall sgx_scroll_split( unsigned char index<_al>, unsigned char screen_line<_ah>, unsigned int bat_x<_bx>, unsigned int bat_y<_cx>, unsigned char display_flags<_dl> );
 3687                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 67; extern void __fastcall disable_split( unsigned char index<acc> );
 3688                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 68; extern void __fastcall sgx_disable_split( unsigned char index<acc> );
 3689                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 70; extern void __fastcall __macro disable_all_splits( void );
 3690                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 71; extern void __fastcall __macro sgx_disable_all_splits( void );
 3691                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 73; #asm
 3692                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 74; .macro	_disable_all_splits
 3693                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 75; ldy	#HUCC_PCE_SPLITS - 1
 3694                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 76; !loop:		tya
 3695                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 77; call	_disable_split.1
 3696                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 78; dey
 3697                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 79; bpl	!loop-
 3698                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 80; .endm
 3699                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 82; .macro	_sgx_disable_all_splits
 3700                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 83; ldy	#HUCC_SGX_SPLITS - 1
 3701                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 84; !loop:		tya
 3702                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 85; call	_sgx_disable_split.1
 3703                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 86; dey
 3704                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 87; bpl	!loop-
 3705                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 88; .endm
 3706                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 89; #endasm
 3707                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 91; #endif // __HUCC__
 3708                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 93; #endif // _hucc_scroll_h
 3709                        		.dbg	line,	"include\init.c", 3; #include "hucc-chrmap.h"
 3710                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 1; #ifndef _hucc_chrmap_h
 3711                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 2; #define _hucc_chrmap_h
 3712                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 4; /****************************************************************************
 3713                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 5; ; ***************************************************************************
 3714                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 6; ;
 3715                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 7; ; hucc-chrmap.h
 3716                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 8; ;
 3717                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 9; ; A simple map system based on 8x8 characters (aka "tiles") in BAT format.
 3718                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 10; ;
 3719                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 11; ; Copyright John Brandwood 2025.
 3720                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 12; ;
 3721                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 13; ; Distributed under the Boost Software License, Version 1.0.
 3722                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 14; ; (See accompanying file LICENSE_1_0.txt or copy at
 3723                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 15; ;  http://www.boost.org/LICENSE_1_0.txt)
 3724                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 16; ;
 3725                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 17; ; ***************************************************************************
 3726                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 18; ; ***************************************************************************
 3727                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 19; ;
 3728                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 20; ; The maximum X and Y size for chrmaps is 256 characters (2048 pixels).
 3729                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 21; ;
 3730                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 22; ; The maximum total size for a chrmap is 16KBytes, which allows for maps up
 3731                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 23; ; to 256x32 tiles (2048x256 pixels).
 3732                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 24; ;
 3733                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 25; ; ***************************************************************************
 3734                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 26; ; **************************************************************************/
 3735                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 28; // *************
 3736                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 29; // This code extends the blkmap library ...
 3737                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 30; // *************
 3738                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 32; #include "hucc-blkmap.h"
 3739                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 34; // *************
 3740                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 35; // Functions in chrmap.asm ...
 3741                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 36; // *************
 3742                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 38; #ifdef __HUCC__
 3743                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 40; #asmdef	HUCC_USES_CHRMAP 1
 3744                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 42; extern void __fastcall __nop set_chrmap( unsigned char __far *chrmap<vdc_map_bank:vdc_map_addr>, unsigned char tiles_w<vdc_map_line_w> );
 3745                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 44; extern void __fastcall draw_bat( void );
 3746                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 45; extern void __fastcall scroll_bat( void );
 3747                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 47; extern void __fastcall blit_bat( unsigned char tile_x<map_bat_x>, unsigned char tile_y<map_bat_y>, unsigned char tile_w<map_draw_x>, unsigned char tile_h<map_draw_y> );
 3748                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 49; #ifdef _SGX
 3749                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 51; extern void __fastcall __nop sgx_set_chrmap( unsigned char __far *chrmap<sgx_map_bank:sgx_map_addr>, unsigned char tiles_w<sgx_map_line_w> );
 3750                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 53; extern void __fastcall sgx_draw_bat( void );
 3751                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 54; extern void __fastcall sgx_scroll_bat( void );
 3752                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 56; extern void __fastcall sgx_blit_bat( unsigned char tile_x<map_bat_x>, unsigned char tile_y<map_bat_y>, unsigned char tile_w<map_draw_x>, unsigned char tile_h<map_draw_y> );
 3753                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 58; #endif
 3754                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 60; #endif // __HUCC__
 3755                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 62; #endif // _hucc_chrmap_h
 3756                        		.dbg	line,	"include\init.c", 4; #include "hucc-blkmap.h"
 3757                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 1; #ifndef _hucc_blkmap_h
 3758                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 2; #define _hucc_blkmap_h
 3759                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 4; /****************************************************************************
 3760                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 5; ; ***************************************************************************
 3761                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 6; ;
 3762                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 7; ; hucc-blkmap.h
 3763                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 8; ;
 3764                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 9; ; A map system based on 16x16 meta-tiles (aka "blocks", aka CHR/BLK/MAP).
 3765                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 10; ;
 3766                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 11; ; Copyright John Brandwood 2025.
 3767                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 12; ;
 3768                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 13; ; Distributed under the Boost Software License, Version 1.0.
 3769                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 14; ; (See accompanying file LICENSE_1_0.txt or copy at
 3770                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 15; ;  http://www.boost.org/LICENSE_1_0.txt)
 3771                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 16; ;
 3772                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 17; ; ***************************************************************************
 3773                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 18; ; ***************************************************************************
 3774                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 19; ;
 3775                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 20; ; The maximum X and Y size for blkmaps is 128 blocks (2048 pixels).
 3776                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 21; ;
 3777                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 22; ; The maximum total size for a blkmap is 16KBytes, which allows for maps up
 3778                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 23; ; to 128x128 blocks (2048x2048 pixels).
 3779                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 24; ;
 3780                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 25; ; Huge multi-screen blkmaps are also supported (optionally).
 3781                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 26; ;
 3782                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 27; ; The maximum X and Y for multi-screen maps is 128 screens (32768 pixels).
 3783                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 28; ;
 3784                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 29; ; The maximum total size for a multi-screen map is 8KBytes, which allows for
 3785                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 30; ; a total of 1024 screens.
 3786                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 31; ;
 3787                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 32; ; ***************************************************************************
 3788                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 33; ; **************************************************************************/
 3789                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 35; // *************
 3790                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 36; // Functions in blkmap.asm ...
 3791                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 37; // *************
 3792                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 39; #ifdef __HUCC__
 3793                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 41; #asmdef	HUCC_USES_BLKMAP 1
 3794                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 43; // Current top-left of drawn map in pixels.
 3795                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 44; extern unsigned int   vdc_map_pxl_x;
 3796                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 45; extern unsigned int   vdc_map_pxl_y;
 3797                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 47; // Width and height to draw/scroll in characters (not tiles).
 3798                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 48; extern unsigned char  vdc_map_draw_w;
 3799                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 49; extern unsigned char  vdc_map_draw_h;
 3800                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 51; // Width of map (or multi-screen BAT) in tiles.
 3801                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 52; extern unsigned char  vdc_map_line_w;
 3802                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 54; // Width of map in screens (if multi-screen map).
 3803                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 55; extern unsigned char  vdc_map_scrn_w;
 3804                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 57; // Extra information returned by get_map_block() and sgx_get_map_block(),
 3805                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 58; // which are the collision flags and the mask/overlay sprite for the BLK.
 3806                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 59; extern unsigned char  map_blk_flag;
 3807                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 60; extern unsigned char  map_blk_mask;
 3808                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 62; extern unsigned char  vdc_scr_bank;
 3809                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 63; extern unsigned char *vdc_scr_addr;
 3810                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 65; extern unsigned char  vdc_map_bank;
 3811                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 66; extern unsigned char *vdc_map_addr;
 3812                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 68; extern unsigned char  vdc_blk_bank;
 3813                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 69; extern unsigned char *vdc_blk_addr;
 3814                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 71; extern unsigned char  vdc_tbl_bank;
 3815                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 72; extern unsigned char *vdc_tbl_addr;
 3816                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 74; extern void __fastcall set_blocks( unsigned char __far *blk_def<vdc_blk_bank:vdc_blk_addr>, unsigned char __far *flg_def<vdc_tbl_bank:vdc_tbl_addr>, unsigned char number_of_blocks<_al> );
 3817                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 75; extern void __fastcall __macro set_blkmap( unsigned char __far *blk_map<vdc_map_bank:vdc_map_addr>, unsigned char blocks_w<vdc_map_line_w> );
 3818                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 76; extern void __fastcall __macro set_multimap( unsigned char __far *multi_map<vdc_scr_bank:vdc_scr_addr>, unsigned char screens_w<vdc_map_scrn_w> );
 3819                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 78; extern void __fastcall draw_map( void );
 3820                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 79; extern void __fastcall scroll_map( void );
 3821                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 81; extern void __fastcall blit_map( unsigned char tile_x<map_bat_x>, unsigned char tile_y<map_bat_y>, unsigned char tile_w<map_draw_x>, unsigned char tile_h<map_draw_y> );
 3822                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 83; extern unsigned char __fastcall get_map_block( unsigned int x<map_pxl_x>, unsigned int y<map_pxl_y> );
 3823                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 85; #asm
 3824                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 86; .macro	_set_blkmap.2
 3825                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 87; stz	vdc_scr_bank
 3826                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 88; .endm
 3827                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 90; .macro	_set_multimap.2
 3828                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 91; lda	vdc_bat_width
 3829                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 92; lsr	a
 3830                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 93; sta	vdc_map_line_w
 3831                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 94; .endm
 3832                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 96; .macro	SCREEN
 3833                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 97; db	(((\1) & $1FFF) | $6000) >> 8, bank(\1)
 3834                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 98; db	(((\2) & $1FFF) | $4000) >> 8, bank(\2)
 3835                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 99; db	(((\3) & $1FFF) | $6000) >> 8, bank(\3)
 3836                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 100; dw	(\4)
 3837                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 101; .endm
 3838                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 102; #endasm
 3839                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 104; #ifdef _SGX
 3840                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 106; // Current top-left of drawn map in pixels.
 3841                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 107; extern unsigned int   sgx_map_pxl_x;
 3842                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 108; extern unsigned int   sgx_map_pxl_y;
 3843                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 110; // Width and height to draw/scroll in characters (not tiles).
 3844                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 111; extern unsigned char  sgx_map_draw_w;
 3845                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 112; extern unsigned char  sgx_map_draw_h;
 3846                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 114; // Width of map (or multi-screen BAT) in tiles.
 3847                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 115; extern unsigned char  sgx_map_line_w;
 3848                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 117; // Width of map in screens (if multi-screen map).
 3849                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 118; extern unsigned char  sgx_map_scrn_w;
 3850                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 120; extern unsigned char  sgx_scr_bank;
 3851                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 121; extern unsigned char *sgx_scr_addr;
 3852                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 123; extern unsigned char  sgx_map_bank;
 3853                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 124; extern unsigned char *sgx_map_addr;
 3854                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 126; extern unsigned char  sgx_blk_bank;
 3855                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 127; extern unsigned char *sgx_blk_addr;
 3856                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 129; extern unsigned char  sgx_tbl_bank;
 3857                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 130; extern unsigned char *sgx_tbl_addr;
 3858                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 132; extern void __fastcall sgx_set_blocks( unsigned char __far *blk_def<sgx_blk_bank:sgx_blk_addr>, unsigned char __far *flg_def<sgx_tbl_bank:sgx_tbl_addr>, unsigned char number_of_blocks<_al> );
 3859                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 133; extern void __fastcall __macro sgx_set_blkmap( unsigned char __far *blk_map<sgx_map_bank:sgx_map_addr>, unsigned char blocks_w<sgx_map_line_w> );
 3860                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 134; extern void __fastcall __macro sgx_set_multimap( unsigned char __far *multi_map<sgx_scr_bank:sgx_scr_addr>, unsigned char screens_w<sgx_map_scrn_w> );
 3861                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 136; extern void __fastcall sgx_draw_map( void );
 3862                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 137; extern void __fastcall sgx_scroll_map( void );
 3863                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 139; extern void __fastcall sgx_blit_map( unsigned char tile_x<map_bat_x>, unsigned char tile_y<map_bat_y>, unsigned char tile_w<map_draw_x>, unsigned char tile_h<map_draw_y> );
 3864                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 141; extern unsigned char __fastcall sgx_get_map_block( unsigned int x<map_pxl_x>, unsigned int y<map_pxl_y> );
 3865                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 143; #asm
 3866                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 144; .macro	_sgx_set_blkmap.2
 3867                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 145; stz	sgx_scr_bank
 3868                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 146; .endm
 3869                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 148; .macro	_sgx_set_multimap.2
 3870                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 149; lda	sgx_bat_width
 3871                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 150; lsr	a
 3872                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 151; sta	sgx_map_line_w
 3873                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 152; .endm
 3874                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 153; #endasm
 3875                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 155; #endif
 3876                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 157; #endif // __HUCC__
 3877                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 159; #endif // _hucc_blkmap_h
 3878                        		.dbg	line,	"include\init.c", 13; void init_VARIABLES()
 3879                        		.dbg	line,	"include\init.c", 14; {
 3880                        	;***********************
 3881                        	;***********************
 3882                        	
 3883                        		.hucc
 3884    01:CAED             		.proc		_init_VARIABLES
 3885                        		__enter		_init_VARIABLES
 3886                        	
 3887                        		.dbg	line,	"include\init.c", 15; sequence_id = SEQUENCE_GAME;
 3888                        		__st.umiq	2, _sequence_id
         01:CAED  A9 02      			lda.l	#2
         01:CAEF  8D 01 23   			sta	_sequence_id
 3889                        	
 3890                        		.dbg	line,	"include\init.c", 17; level_id = 1;
 3891                        		__st.umiq	1, _level_id
         01:CAF2  A9 01      			lda.l	#1
         01:CAF4  8D 03 23   			sta	_level_id
 3892                        	
 3893                        		.dbg	line,	"include\init.c", 19; sequence_loaded = FALSE;
 3894                        		__st.umiq	0, _sequence_loaded
         01:CAF7  9C 02 23   			stz	_sequence_loaded
 3895                        	
 3896                        		.dbg	line,	"include\init.c", 20; }
 3897    01:CAFA             	.LL83:
 3898                        		__return	0
         01:CAFA  4C EF FF   			jmp	leave_proc
 3899                        		.dbg	clear
 3900                        		.endp
 3901                        		.pceas
 3902                        	
 3903                        		.dbg	line,	"include\init.c", 23; init_PLAYER()
 3904                        		.dbg	line,	"include\init.c", 24; {
 3905                        	;***********************
 3906                        	;***********************
 3907                        	
 3908                        		.hucc
 3909    01:CAD3             		.proc		_init_PLAYER
 3910                        		__enter		_init_PLAYER
 3911                        	
 3912                        		.dbg	line,	"include\init.c", 25; player_id = 0;
 3913                        		__st.umiq	0, _player_id
         01:CAD3  9C 04 23   			stz	_player_id
 3914                        	
 3915                        		.dbg	line,	"include\init.c", 26; player_axis = AXIS_RIGHT;
 3916                        		__st.umiq	0, _player_axis
         01:CAD6  9C 06 23   			stz	_player_axis
 3917                        	
 3918                        		.dbg	line,	"include\init.c", 27; player_previous_axis = player_axis;
 3919                        		__ld.um		_player_axis
         01:CAD9  AD 06 23   			lda	_player_axis
         01:CADC  C2         			cly
 3920                        		__st.umq	_player_previous_axis
         01:CADD  8D 07 23   			sta	_player_previous_axis
 3921                        	
 3922                        		.dbg	line,	"include\init.c", 28; player_counter_anim = 0;
 3923                        		__st.umiq	0, _player_counter_anim
         01:CAE0  9C 08 23   			stz	_player_counter_anim
 3924                        	
 3925                        		.dbg	line,	"include\init.c", 29; player_index_jump = 0;
 3926                        		__st.umiq	0, _player_index_jump
         01:CAE3  9C 09 23   			stz	_player_index_jump
 3927                        	
 3928                        		.dbg	line,	"include\init.c", 30; player_state = STATE_IDLE;
 3929                        		__st.umiq	0, _player_state
         01:CAE6  9C 05 23   			stz	_player_state
 3930                        	
 3931                        		.dbg	line,	"include\init.c", 31; }
 3932    01:CAE9             	.LL84:
 3933                        		__return	1
         01:CAE9  AA         			tax
         01:CAEA  4C EF FF   			jmp	leave_proc
 3934                        		.dbg	clear
 3935                        		.endp
 3936                        		.pceas
 3937                        	
 3938                        		.dbg	line,	"include\init.c", 35; void init_LEVEL()
 3939                        		.dbg	line,	"include\init.c", 36; {
 3940                        	;***********************
 3941                        	;***********************
 3942                        	
 3943                        		.hucc
 3944    0B:DBBB             		.proc		_init_LEVEL
 3945                        		__enter		_init_LEVEL
 3946                        	
 3947                        		.dbg	line,	"include\init.c", 37; if(level_id == 1)
 3948                        		__ld.umq	_level_id
         0B:DBBB  AD 03 23   			lda	_level_id
 3949                        		__equ_b.uiq	1
         0B:DBBE  C9 01      			cmp	#1
         0B:DBC0  F0 01      			beq	!+
         0B:DBC2  18         			clc
         0B:DBC3             	!:
 3950                        		__bfalse	.LL86
         0B:DBC3  B0 03 4C 8D			bcc	.LL86
         0B:DBC7  DE          
 3951                        	
 3952                        		.dbg	line,	"include\init.c", 38; {
 3953                        	
 3954                        		.dbg	line,	"include\init.c", 39; // VSYNC //
 3955                        	
 3956                        		.dbg	line,	"include\init.c", 40; vsync();
 3957                        		__call		_vsync
         0B:DBC8  20 09 E3   			call	_vsync
 3958                        	
 3959                        		.dbg	line,	"include\init.c", 42; // LOAD DEFAULT FONT //
 3960                        	
 3961                        		.dbg	line,	"include\init.c", 43; load_default_font();
 3962                        		 _load_default_font
         0B:DBCB  82         			clx				; Offset to PCE VDC.
         0B:DBCC  20 C7 FF   			call	huc_monofont_x
 3963                        	
 3964                        		.dbg	line,	"include\init.c", 48; // SET VDC 1 SCREEN SIZE (IN TILES) - 64x32 = 512x256 PIXELS
 3965                        	
 3966                        		.dbg	line,	"include\init.c", 49; set_screen_size(SCR_SIZE_64x32);
 3967                        		__st.umiq	1, _al
         0B:DBCF  A9 01      			lda.l	#1
         0B:DBD1  85 F8      			sta	_al
 3968                        		__call		_set_screen_size.1
         0B:DBD3  20 3B FF   			call	_set_screen_size.1
 3969                        	
 3970                        		.dbg	line,	"include\init.c", 52; // SET VDC 2 SCREEN SIZE (IN TILES) - 64x32 = 512x256 PIXELS
 3971                        	
 3972                        		.dbg	line,	"include\init.c", 53; sgx_set_screen_size(SCR_SIZE_64x32);
 3973                        		__st.umiq	1, _al
         0B:DBD6  A9 01      			lda.l	#1
         0B:DBD8  85 F8      			sta	_al
 3974                        		__call		_sgx_set_screen_size.1
         0B:DBDA  20 31 FF   			call	_sgx_set_screen_size.1
 3975                        	
 3976                        		.dbg	line,	"include\init.c", 56; // INIT SPRITE ATTRIBUTE TABLE //
 3977                        	
 3978                        		.dbg	line,	"include\init.c", 57; init_satb();
 3979                        		__call		_init_satb
         0B:DBDD  20 B7 E7   			call	_init_satb
 3980                        	
 3981                        		.dbg	line,	"include\init.c", 62; //**************************************************************************************//
 3982                        	
 3983                        		.dbg	line,	"include\init.c", 63; //                                                                                      //
 3984                        	
 3985                        		.dbg	line,	"include\init.c", 64; //                                        VDC 2                                         //
 3986                        	
 3987                        		.dbg	line,	"include\init.c", 65; //                                                                                      //
 3988                        	
 3989                        		.dbg	line,	"include\init.c", 66; //**************************************************************************************//
 3990                        	
 3991                        		.dbg	line,	"include\init.c", 68; //--------------------------------------------------------------------------------------//
 3992                        	
 3993                        		.dbg	line,	"include\init.c", 69; //                                    LOAD TILESET                                      //
 3994                        	
 3995                        		.dbg	line,	"include\init.c", 70; //--------------------------------------------------------------------------------------//
 3996                        	
 3997                        		.dbg	line,	"include\init.c", 72; sgx_load_vram( 0x1000, tileset_LV1_BG_B, SIZEOF(tileset_LV1_BG_B) >> 1 );
 3998                        		__st.wmiq	4096, _di
         0B:DBE0  64 F0      			stz.l	_di
         0B:DBE2  A9 10      			lda.h	#4096
         0B:DBE4  85 F1      			sta.h	_di
 3999                        		__farptr	_tileset_LV1_BG_B, _bp_bank, _bp
         0B:DBE6  A9 80      			lda.l	#$6000 + ($1FFF & (_tileset_LV1_BG_B))
         0B:DBE8  85 EC      			sta.l	_bp
         0B:DBEA  A9 6D      			lda.h	#$6000 + ($1FFF & (_tileset_LV1_BG_B))
         0B:DBEC  85 ED      			sta.h	_bp
         0B:DBEE  A9 03      			lda	#bank(_tileset_LV1_BG_B)
         0B:DBF0  85 02      			sta	_bp_bank
 4000                        		__ld.wi		___sizeof__tileset_LV1_BG_B
         0B:DBF2  A9 60      			lda.l	#___sizeof__tileset_LV1_BG_B
         0B:DBF4  A0 70      			ldy.h	#___sizeof__tileset_LV1_BG_B
 4001                        		__lsr.wi	1
         0B:DBF6  42         			say
         0B:DBF7  4A         			lsr	a
         0B:DBF8  42         			say
         0B:DBF9  6A         			ror	a
 4002                        		__st.wmq	_ax
         0B:DBFA  85 F8      			sta.l	_ax
         0B:DBFC  84 F9      			sty.h	_ax
 4003                        		 _sgx_load_vram.3
         0B:DBFE  A2 10      			ldx	#SGX_VDC_OFFSET		; Offset to SGX VDC.
         0B:DC00  20 81 FF   			call	load_vram_x
 4004                        	
 4005                        		.dbg	line,	"include\init.c", 75; //--------------------------------------------------------------------------------------//
 4006                        	
 4007                        		.dbg	line,	"include\init.c", 76; //                               LOAD WALL & DOOR TILES                                 //
 4008                        	
 4009                        		.dbg	line,	"include\init.c", 77; //--------------------------------------------------------------------------------------//
 4010                        	
 4011                        		.dbg	line,	"include\init.c", 79; sgx_load_vram( LV1_WALL_VRAM_ADR, tileset_LV1_WALL, SIZEOF(tileset_LV1_WALL) >> 1 );
 4012                        		__st.wmiq	4096, _di
         0B:DC03  64 F0      			stz.l	_di
         0B:DC05  A9 10      			lda.h	#4096
         0B:DC07  85 F1      			sta.h	_di
 4013                        		__farptr	_tileset_LV1_WALL, _bp_bank, _bp
         0B:DC09  A9 00      			lda.l	#$6000 + ($1FFF & (_tileset_LV1_WALL))
         0B:DC0B  85 EC      			sta.l	_bp
         0B:DC0D  A9 60      			lda.h	#$6000 + ($1FFF & (_tileset_LV1_WALL))
         0B:DC0F  85 ED      			sta.h	_bp
         0B:DC11  A9 03      			lda	#bank(_tileset_LV1_WALL)
         0B:DC13  85 02      			sta	_bp_bank
 4014                        		__ld.wi		___sizeof__tileset_LV1_WALL
         0B:DC15  A9 00      			lda.l	#___sizeof__tileset_LV1_WALL
         0B:DC17  A0 02      			ldy.h	#___sizeof__tileset_LV1_WALL
 4015                        		__lsr.wi	1
         0B:DC19  42         			say
         0B:DC1A  4A         			lsr	a
         0B:DC1B  42         			say
         0B:DC1C  6A         			ror	a
 4016                        		__st.wmq	_ax
         0B:DC1D  85 F8      			sta.l	_ax
         0B:DC1F  84 F9      			sty.h	_ax
 4017                        		 _sgx_load_vram.3
         0B:DC21  A2 10      			ldx	#SGX_VDC_OFFSET		; Offset to SGX VDC.
         0B:DC23  20 81 FF   			call	load_vram_x
 4018                        	
 4019                        		.dbg	line,	"include\init.c", 80; sgx_load_vram( LV1_DOOR_VRAM_ADR, tileset_LV1_DOOR_OPEN, SIZEOF(tileset_LV1_DOOR_OPEN) >> 1 );
 4020                        		__st.wmiq	4352, _di
         0B:DC26  64 F0      			stz.l	_di
         0B:DC28  A9 11      			lda.h	#4352
         0B:DC2A  85 F1      			sta.h	_di
 4021                        		__farptr	_tileset_LV1_DOOR_OPEN, _bp_bank, _bp
         0B:DC2C  A9 00      			lda.l	#$6000 + ($1FFF & (_tileset_LV1_DOOR_OPEN))
         0B:DC2E  85 EC      			sta.l	_bp
         0B:DC30  A9 62      			lda.h	#$6000 + ($1FFF & (_tileset_LV1_DOOR_OPEN))
         0B:DC32  85 ED      			sta.h	_bp
         0B:DC34  A9 03      			lda	#bank(_tileset_LV1_DOOR_OPEN)
         0B:DC36  85 02      			sta	_bp_bank
 4022                        		__ld.wi		___sizeof__tileset_LV1_DOOR_OPEN
         0B:DC38  A9 00      			lda.l	#___sizeof__tileset_LV1_DOOR_OPEN
         0B:DC3A  A0 03      			ldy.h	#___sizeof__tileset_LV1_DOOR_OPEN
 4023                        		__lsr.wi	1
         0B:DC3C  42         			say
         0B:DC3D  4A         			lsr	a
         0B:DC3E  42         			say
         0B:DC3F  6A         			ror	a
 4024                        		__st.wmq	_ax
         0B:DC40  85 F8      			sta.l	_ax
         0B:DC42  84 F9      			sty.h	_ax
 4025                        		 _sgx_load_vram.3
         0B:DC44  A2 10      			ldx	#SGX_VDC_OFFSET		; Offset to SGX VDC.
         0B:DC46  20 81 FF   			call	load_vram_x
 4026                        	
 4027                        		.dbg	line,	"include\init.c", 83; //--------------------------------------------------------------------------------------//
 4028                        	
 4029                        		.dbg	line,	"include\init.c", 84; //                                     SET MULTIMAP                                     //
 4030                        	
 4031                        		.dbg	line,	"include\init.c", 85; //--------------------------------------------------------------------------------------//
 4032                        	
 4033                        		.dbg	line,	"include\init.c", 87; // multimap is 2 screens wide //
 4034                        	
 4035                        		.dbg	line,	"include\init.c", 88; sgx_set_multimap( multimap_LV1_BG_B , 5 );
 4036                        		__farptr	_multimap_LV1_BG_B, sgx_scr_bank, sgx_scr_addr
         0B:DC49  A9 00      			lda.l	#$6000 + ($1FFF & (_multimap_LV1_BG_B))
         0B:DC4B  8D 94 28   			sta.l	sgx_scr_addr
         0B:DC4E  A9 7F      			lda.h	#$6000 + ($1FFF & (_multimap_LV1_BG_B))
         0B:DC50  8D 95 28   			sta.h	sgx_scr_addr
         0B:DC53  A9 08      			lda	#bank(_multimap_LV1_BG_B)
         0B:DC55  8D 96 28   			sta	sgx_scr_bank
 4037                        		__st.umiq	5, sgx_map_scrn_w
         0B:DC58  A9 05      			lda.l	#5
         0B:DC5A  8D 55 23   			sta	sgx_map_scrn_w
 4038                        		 _sgx_set_multimap.2
         0B:DC5D  AD 4D 23   			lda	sgx_bat_width
         0B:DC60  4A         			lsr	a
         0B:DC61  8D 54 23   			sta	sgx_map_line_w
 4039                        	
 4040                        		.dbg	line,	"include\init.c", 91; //--------------------------------------------------------------------------------------//
 4041                        	
 4042                        		.dbg	line,	"include\init.c", 92; //                                    DRAW TILEMAP                                      //
 4043                        	
 4044                        		.dbg	line,	"include\init.c", 93; //--------------------------------------------------------------------------------------//
 4045                        	
 4046                        		.dbg	line,	"include\init.c", 95; // The blkmap is drawn using global variables for the top-left coordinate
 4047                        	
 4048                        		.dbg	line,	"include\init.c", 96; // in pixels, and the draw width and height in terms of 8x8 characters.
 4049                        	
 4050                        		.dbg	line,	"include\init.c", 98; sgx_map_pxl_x = 96;
 4051                        		__st.wmiq	96, _sgx_map_pxl_x
         0B:DC64  A9 60      			lda.l	#96
         0B:DC66  8D 56 23   			sta.l	_sgx_map_pxl_x
         0B:DC69  9C 57 23   			stz.h	_sgx_map_pxl_x
 4052                        	
 4053                        		.dbg	line,	"include\init.c", 99; sgx_map_pxl_y = 512;
 4054                        		__st.wmiq	512, _sgx_map_pxl_y
         0B:DC6C  9C 58 23   			stz.l	_sgx_map_pxl_y
         0B:DC6F  A9 02      			lda.h	#512
         0B:DC71  8D 59 23   			sta.h	_sgx_map_pxl_y
 4055                        	
 4056                        		.dbg	line,	"include\init.c", 101; sgx_map_draw_w = 63;
 4057                        		__st.umiq	63, _sgx_map_draw_w
         0B:DC74  A9 3F      			lda.l	#63
         0B:DC76  8D 52 23   			sta	_sgx_map_draw_w
 4058                        	
 4059                        		.dbg	line,	"include\init.c", 102; sgx_map_draw_h = 29;
 4060                        		__st.umiq	29, _sgx_map_draw_h
         0B:DC79  A9 1D      			lda.l	#29
         0B:DC7B  8D 53 23   			sta	_sgx_map_draw_h
 4061                        	
 4062                        		.dbg	line,	"include\init.c", 104; sgx_draw_map();
 4063                        		__call		_sgx_draw_map
         0B:DC7E  20 27 FF   			call	_sgx_draw_map
 4064                        	
 4065                        		.dbg	line,	"include\init.c", 109; //**************************************************************************************//
 4066                        	
 4067                        		.dbg	line,	"include\init.c", 110; //                                                                                      //
 4068                        	
 4069                        		.dbg	line,	"include\init.c", 111; //                                        VDC 1                                         //
 4070                        	
 4071                        		.dbg	line,	"include\init.c", 112; //                                                                                      //
 4072                        	
 4073                        		.dbg	line,	"include\init.c", 113; //**************************************************************************************//
 4074                        	
 4075                        		.dbg	line,	"include\init.c", 115; //--------------------------------------------------------------------------------------//
 4076                        	
 4077                        		.dbg	line,	"include\init.c", 116; //                                    LOAD TILESET                                      //
 4078                        	
 4079                        		.dbg	line,	"include\init.c", 117; //--------------------------------------------------------------------------------------//
 4080                        	
 4081                        		.dbg	line,	"include\init.c", 119; load_vram( 0x1000, tileset_LV1_BG_A, SIZEOF(tileset_LV1_BG_A) >> 1 );
 4082                        		__st.wmiq	4096, _di
         0B:DC81  64 F0      			stz.l	_di
         0B:DC83  A9 10      			lda.h	#4096
         0B:DC85  85 F1      			sta.h	_di
 4083                        		__farptr	_tileset_LV1_BG_A, _bp_bank, _bp
         0B:DC87  A9 78      			lda.l	#$6000 + ($1FFF & (_tileset_LV1_BG_A))
         0B:DC89  85 EC      			sta.l	_bp
         0B:DC8B  A9 7F      			lda.h	#$6000 + ($1FFF & (_tileset_LV1_BG_A))
         0B:DC8D  85 ED      			sta.h	_bp
         0B:DC8F  A9 08      			lda	#bank(_tileset_LV1_BG_A)
         0B:DC91  85 02      			sta	_bp_bank
 4084                        		__ld.wi		___sizeof__tileset_LV1_BG_A
         0B:DC93  A9 C0      			lda.l	#___sizeof__tileset_LV1_BG_A
         0B:DC95  A0 06      			ldy.h	#___sizeof__tileset_LV1_BG_A
 4085                        		__lsr.wi	1
         0B:DC97  42         			say
         0B:DC98  4A         			lsr	a
         0B:DC99  42         			say
         0B:DC9A  6A         			ror	a
 4086                        		__st.wmq	_ax
         0B:DC9B  85 F8      			sta.l	_ax
         0B:DC9D  84 F9      			sty.h	_ax
 4087                        		 _load_vram.3
         0B:DC9F  82         			clx				; Offset to PCE VDC.
         0B:DCA0  20 81 FF   			call	load_vram_x
 4088                        	
 4089                        		.dbg	line,	"include\init.c", 122; //--------------------------------------------------------------------------------------//
 4090                        	
 4091                        		.dbg	line,	"include\init.c", 123; //                                 LOAD LIFABAR TILES                                   //
 4092                        	
 4093                        		.dbg	line,	"include\init.c", 124; //--------------------------------------------------------------------------------------//
 4094                        	
 4095                        		.dbg	line,	"include\init.c", 126; load_vram( LIFEBAR_1_VRAM_ADR, tileset_LIFE_RED, SIZEOF(tileset_LIFE_RED) >> 1 );
 4096                        		__st.wmiq	4096, _di
         0B:DCA3  64 F0      			stz.l	_di
         0B:DCA5  A9 10      			lda.h	#4096
         0B:DCA7  85 F1      			sta.h	_di
 4097                        		__farptr	_tileset_LIFE_RED, _bp_bank, _bp
         0B:DCA9  A9 00      			lda.l	#$6000 + ($1FFF & (_tileset_LIFE_RED))
         0B:DCAB  85 EC      			sta.l	_bp
         0B:DCAD  A9 68      			lda.h	#$6000 + ($1FFF & (_tileset_LIFE_RED))
         0B:DCAF  85 ED      			sta.h	_bp
         0B:DCB1  A9 03      			lda	#bank(_tileset_LIFE_RED)
         0B:DCB3  85 02      			sta	_bp_bank
 4098                        		__ld.wi		___sizeof__tileset_LIFE_RED
         0B:DCB5  A9 40      			lda.l	#___sizeof__tileset_LIFE_RED
         0B:DCB7  A0 00      			ldy.h	#___sizeof__tileset_LIFE_RED
 4099                        		__lsr.wi	1
         0B:DCB9  42         			say
         0B:DCBA  4A         			lsr	a
         0B:DCBB  42         			say
         0B:DCBC  6A         			ror	a
 4100                        		__st.wmq	_ax
         0B:DCBD  85 F8      			sta.l	_ax
         0B:DCBF  84 F9      			sty.h	_ax
 4101                        		 _load_vram.3
         0B:DCC1  82         			clx				; Offset to PCE VDC.
         0B:DCC2  20 81 FF   			call	load_vram_x
 4102                        	
 4103                        		.dbg	line,	"include\init.c", 127; load_vram( LIFEBAR_2_VRAM_ADR, tileset_LIFE_ORANGE, SIZEOF(tileset_LIFE_ORANGE) >> 1 );
 4104                        		__st.wmiq	4128, _di
         0B:DCC5  A9 20      			lda.l	#4128
         0B:DCC7  85 F0      			sta.l	_di
         0B:DCC9  A9 10      			lda.h	#4128
         0B:DCCB  85 F1      			sta.h	_di
 4105                        		__farptr	_tileset_LIFE_ORANGE, _bp_bank, _bp
         0B:DCCD  A9 40      			lda.l	#$6000 + ($1FFF & (_tileset_LIFE_ORANGE))
         0B:DCCF  85 EC      			sta.l	_bp
         0B:DCD1  A9 68      			lda.h	#$6000 + ($1FFF & (_tileset_LIFE_ORANGE))
         0B:DCD3  85 ED      			sta.h	_bp
         0B:DCD5  A9 03      			lda	#bank(_tileset_LIFE_ORANGE)
         0B:DCD7  85 02      			sta	_bp_bank
 4106                        		__ld.wi		___sizeof__tileset_LIFE_ORANGE
         0B:DCD9  A9 40      			lda.l	#___sizeof__tileset_LIFE_ORANGE
         0B:DCDB  A0 00      			ldy.h	#___sizeof__tileset_LIFE_ORANGE
 4107                        		__lsr.wi	1
         0B:DCDD  42         			say
         0B:DCDE  4A         			lsr	a
         0B:DCDF  42         			say
         0B:DCE0  6A         			ror	a
 4108                        		__st.wmq	_ax
         0B:DCE1  85 F8      			sta.l	_ax
         0B:DCE3  84 F9      			sty.h	_ax
 4109                        		 _load_vram.3
         0B:DCE5  82         			clx				; Offset to PCE VDC.
         0B:DCE6  20 81 FF   			call	load_vram_x
 4110                        	
 4111                        		.dbg	line,	"include\init.c", 128; load_vram( LIFEBAR_3_VRAM_ADR, tileset_LIFE_YELLOW, SIZEOF(tileset_LIFE_YELLOW) >> 1 );
 4112                        		__st.wmiq	4160, _di
         0B:DCE9  A9 40      			lda.l	#4160
         0B:DCEB  85 F0      			sta.l	_di
         0B:DCED  A9 10      			lda.h	#4160
         0B:DCEF  85 F1      			sta.h	_di
 4113                        		__farptr	_tileset_LIFE_YELLOW, _bp_bank, _bp
         0B:DCF1  A9 80      			lda.l	#$6000 + ($1FFF & (_tileset_LIFE_YELLOW))
         0B:DCF3  85 EC      			sta.l	_bp
         0B:DCF5  A9 68      			lda.h	#$6000 + ($1FFF & (_tileset_LIFE_YELLOW))
         0B:DCF7  85 ED      			sta.h	_bp
         0B:DCF9  A9 03      			lda	#bank(_tileset_LIFE_YELLOW)
         0B:DCFB  85 02      			sta	_bp_bank
 4114                        		__ld.wi		___sizeof__tileset_LIFE_YELLOW
         0B:DCFD  A9 40      			lda.l	#___sizeof__tileset_LIFE_YELLOW
         0B:DCFF  A0 00      			ldy.h	#___sizeof__tileset_LIFE_YELLOW
 4115                        		__lsr.wi	1
         0B:DD01  42         			say
         0B:DD02  4A         			lsr	a
         0B:DD03  42         			say
         0B:DD04  6A         			ror	a
 4116                        		__st.wmq	_ax
         0B:DD05  85 F8      			sta.l	_ax
         0B:DD07  84 F9      			sty.h	_ax
 4117                        		 _load_vram.3
         0B:DD09  82         			clx				; Offset to PCE VDC.
         0B:DD0A  20 81 FF   			call	load_vram_x
 4118                        	
 4119                        		.dbg	line,	"include\init.c", 129; load_vram( LIFEBAR_4_VRAM_ADR, tileset_LIFE_YELLOW, SIZEOF(tileset_LIFE_YELLOW) >> 1 );
 4120                        		__st.wmiq	4192, _di
         0B:DD0D  A9 60      			lda.l	#4192
         0B:DD0F  85 F0      			sta.l	_di
         0B:DD11  A9 10      			lda.h	#4192
         0B:DD13  85 F1      			sta.h	_di
 4121                        		__farptr	_tileset_LIFE_YELLOW, _bp_bank, _bp
         0B:DD15  A9 80      			lda.l	#$6000 + ($1FFF & (_tileset_LIFE_YELLOW))
         0B:DD17  85 EC      			sta.l	_bp
         0B:DD19  A9 68      			lda.h	#$6000 + ($1FFF & (_tileset_LIFE_YELLOW))
         0B:DD1B  85 ED      			sta.h	_bp
         0B:DD1D  A9 03      			lda	#bank(_tileset_LIFE_YELLOW)
         0B:DD1F  85 02      			sta	_bp_bank
 4122                        		__ld.wi		___sizeof__tileset_LIFE_YELLOW
         0B:DD21  A9 40      			lda.l	#___sizeof__tileset_LIFE_YELLOW
         0B:DD23  A0 00      			ldy.h	#___sizeof__tileset_LIFE_YELLOW
 4123                        		__lsr.wi	1
         0B:DD25  42         			say
         0B:DD26  4A         			lsr	a
         0B:DD27  42         			say
         0B:DD28  6A         			ror	a
 4124                        		__st.wmq	_ax
         0B:DD29  85 F8      			sta.l	_ax
         0B:DD2B  84 F9      			sty.h	_ax
 4125                        		 _load_vram.3
         0B:DD2D  82         			clx				; Offset to PCE VDC.
         0B:DD2E  20 81 FF   			call	load_vram_x
 4126                        	
 4127                        		.dbg	line,	"include\init.c", 130; load_vram( LIFEBAR_5_VRAM_ADR, tileset_LIFE_EMPTY, SIZEOF(tileset_LIFE_EMPTY) >> 1 );
 4128                        		__st.wmiq	4224, _di
         0B:DD31  A9 80      			lda.l	#4224
         0B:DD33  85 F0      			sta.l	_di
         0B:DD35  A9 10      			lda.h	#4224
         0B:DD37  85 F1      			sta.h	_di
 4129                        		__farptr	_tileset_LIFE_EMPTY, _bp_bank, _bp
         0B:DD39  A9 C0      			lda.l	#$6000 + ($1FFF & (_tileset_LIFE_EMPTY))
         0B:DD3B  85 EC      			sta.l	_bp
         0B:DD3D  A9 68      			lda.h	#$6000 + ($1FFF & (_tileset_LIFE_EMPTY))
         0B:DD3F  85 ED      			sta.h	_bp
         0B:DD41  A9 03      			lda	#bank(_tileset_LIFE_EMPTY)
         0B:DD43  85 02      			sta	_bp_bank
 4130                        		__ld.wi		___sizeof__tileset_LIFE_EMPTY
         0B:DD45  A9 40      			lda.l	#___sizeof__tileset_LIFE_EMPTY
         0B:DD47  A0 00      			ldy.h	#___sizeof__tileset_LIFE_EMPTY
 4131                        		__lsr.wi	1
         0B:DD49  42         			say
         0B:DD4A  4A         			lsr	a
         0B:DD4B  42         			say
         0B:DD4C  6A         			ror	a
 4132                        		__st.wmq	_ax
         0B:DD4D  85 F8      			sta.l	_ax
         0B:DD4F  84 F9      			sty.h	_ax
 4133                        		 _load_vram.3
         0B:DD51  82         			clx				; Offset to PCE VDC.
         0B:DD52  20 81 FF   			call	load_vram_x
 4134                        	
 4135                        		.dbg	line,	"include\init.c", 133; //--------------------------------------------------------------------------------------//
 4136                        	
 4137                        		.dbg	line,	"include\init.c", 134; //                               LOAD WEAPON + ARMOR TILES                              //
 4138                        	
 4139                        		.dbg	line,	"include\init.c", 135; //--------------------------------------------------------------------------------------//
 4140                        	
 4141                        		.dbg	line,	"include\init.c", 137; load_vram( WEAPON_VRAM_ADR, tileset_WEAPON_1, SIZEOF(tileset_WEAPON_1) >> 1 );
 4142                        		__st.wmiq	4256, _di
         0B:DD55  A9 A0      			lda.l	#4256
         0B:DD57  85 F0      			sta.l	_di
         0B:DD59  A9 10      			lda.h	#4256
         0B:DD5B  85 F1      			sta.h	_di
 4143                        		__farptr	_tileset_WEAPON_1, _bp_bank, _bp
         0B:DD5D  A9 00      			lda.l	#$6000 + ($1FFF & (_tileset_WEAPON_1))
         0B:DD5F  85 EC      			sta.l	_bp
         0B:DD61  A9 6B      			lda.h	#$6000 + ($1FFF & (_tileset_WEAPON_1))
         0B:DD63  85 ED      			sta.h	_bp
         0B:DD65  A9 03      			lda	#bank(_tileset_WEAPON_1)
         0B:DD67  85 02      			sta	_bp_bank
 4144                        		__ld.wi		___sizeof__tileset_WEAPON_1
         0B:DD69  A9 80      			lda.l	#___sizeof__tileset_WEAPON_1
         0B:DD6B  A0 00      			ldy.h	#___sizeof__tileset_WEAPON_1
 4145                        		__lsr.wi	1
         0B:DD6D  42         			say
         0B:DD6E  4A         			lsr	a
         0B:DD6F  42         			say
         0B:DD70  6A         			ror	a
 4146                        		__st.wmq	_ax
         0B:DD71  85 F8      			sta.l	_ax
         0B:DD73  84 F9      			sty.h	_ax
 4147                        		 _load_vram.3
         0B:DD75  82         			clx				; Offset to PCE VDC.
         0B:DD76  20 81 FF   			call	load_vram_x
 4148                        	
 4149                        		.dbg	line,	"include\init.c", 138; load_vram( ARMOR_VRAM_ADR, tileset_ARMOR_2, SIZEOF(tileset_ARMOR_2) >> 1 );
 4150                        		__st.wmiq	4320, _di
         0B:DD79  A9 E0      			lda.l	#4320
         0B:DD7B  85 F0      			sta.l	_di
         0B:DD7D  A9 10      			lda.h	#4320
         0B:DD7F  85 F1      			sta.h	_di
 4151                        		__farptr	_tileset_ARMOR_2, _bp_bank, _bp
         0B:DD81  A9 80      			lda.l	#$6000 + ($1FFF & (_tileset_ARMOR_2))
         0B:DD83  85 EC      			sta.l	_bp
         0B:DD85  A9 69      			lda.h	#$6000 + ($1FFF & (_tileset_ARMOR_2))
         0B:DD87  85 ED      			sta.h	_bp
         0B:DD89  A9 03      			lda	#bank(_tileset_ARMOR_2)
         0B:DD8B  85 02      			sta	_bp_bank
 4152                        		__ld.wi		___sizeof__tileset_ARMOR_2
         0B:DD8D  A9 80      			lda.l	#___sizeof__tileset_ARMOR_2
         0B:DD8F  A0 00      			ldy.h	#___sizeof__tileset_ARMOR_2
 4153                        		__lsr.wi	1
         0B:DD91  42         			say
         0B:DD92  4A         			lsr	a
         0B:DD93  42         			say
         0B:DD94  6A         			ror	a
 4154                        		__st.wmq	_ax
         0B:DD95  85 F8      			sta.l	_ax
         0B:DD97  84 F9      			sty.h	_ax
 4155                        		 _load_vram.3
         0B:DD99  82         			clx				; Offset to PCE VDC.
         0B:DD9A  20 81 FF   			call	load_vram_x
 4156                        	
 4157                        		.dbg	line,	"include\init.c", 141; //--------------------------------------------------------------------------------------//
 4158                        	
 4159                        		.dbg	line,	"include\init.c", 142; //                                     SET MULTIMAP                                     //
 4160                        	
 4161                        		.dbg	line,	"include\init.c", 143; //--------------------------------------------------------------------------------------//
 4162                        	
 4163                        		.dbg	line,	"include\init.c", 145; // multimap is 2 screens wide //
 4164                        	
 4165                        		.dbg	line,	"include\init.c", 146; set_multimap( multimap_LV1_BG_A , 5 );
 4166                        		__farptr	_multimap_LV1_BG_A, vdc_scr_bank, vdc_scr_addr
         0B:DD9D  A9 00      			lda.l	#$6000 + ($1FFF & (_multimap_LV1_BG_A))
         0B:DD9F  8D 84 28   			sta.l	vdc_scr_addr
         0B:DDA2  A9 76      			lda.h	#$6000 + ($1FFF & (_multimap_LV1_BG_A))
         0B:DDA4  8D 85 28   			sta.h	vdc_scr_addr
         0B:DDA7  A9 0A      			lda	#bank(_multimap_LV1_BG_A)
         0B:DDA9  8D 86 28   			sta	vdc_scr_bank
 4167                        		__st.umiq	5, vdc_map_scrn_w
         0B:DDAC  A9 05      			lda.l	#5
         0B:DDAE  8D 45 23   			sta	vdc_map_scrn_w
 4168                        		 _set_multimap.2
         0B:DDB1  AD 3D 23   			lda	vdc_bat_width
         0B:DDB4  4A         			lsr	a
         0B:DDB5  8D 44 23   			sta	vdc_map_line_w
 4169                        	
 4170                        		.dbg	line,	"include\init.c", 149; //--------------------------------------------------------------------------------------//
 4171                        	
 4172                        		.dbg	line,	"include\init.c", 150; //                                    DRAW TILEMAP                                      //
 4173                        	
 4174                        		.dbg	line,	"include\init.c", 151; //--------------------------------------------------------------------------------------//
 4175                        	
 4176                        		.dbg	line,	"include\init.c", 153; // The blkmap is drawn using global variables for the top-left coordinate
 4177                        	
 4178                        		.dbg	line,	"include\init.c", 154; // in pixels, and the draw width and height in terms of 8x8 characters.
 4179                        	
 4180                        		.dbg	line,	"include\init.c", 156; vdc_map_pxl_x = 0;
 4181                        		__st.wmiq	0, _vdc_map_pxl_x
         0B:DDB8  9C 46 23   			stz.l	_vdc_map_pxl_x
         0B:DDBB  9C 47 23   			stz.h	_vdc_map_pxl_x
 4182                        	
 4183                        		.dbg	line,	"include\init.c", 157; vdc_map_pxl_y = 0;
 4184                        		__st.wmiq	0, _vdc_map_pxl_y
         0B:DDBE  9C 48 23   			stz.l	_vdc_map_pxl_y
         0B:DDC1  9C 49 23   			stz.h	_vdc_map_pxl_y
 4185                        	
 4186                        		.dbg	line,	"include\init.c", 159; vdc_map_draw_w = 32;
 4187                        		__st.umiq	32, _vdc_map_draw_w
         0B:DDC4  A9 20      			lda.l	#32
         0B:DDC6  8D 42 23   			sta	_vdc_map_draw_w
 4188                        	
 4189                        		.dbg	line,	"include\init.c", 160; vdc_map_draw_h = 28;
 4190                        		__st.umiq	28, _vdc_map_draw_h
         0B:DDC9  A9 1C      			lda.l	#28
         0B:DDCB  8D 43 23   			sta	_vdc_map_draw_h
 4191                        	
 4192                        		.dbg	line,	"include\init.c", 162; draw_map();
 4193                        		__call		_draw_map
         0B:DDCE  20 1D FF   			call	_draw_map
 4194                        	
 4195                        		.dbg	line,	"include\init.c", 167; //**************************************************************************************//
 4196                        	
 4197                        		.dbg	line,	"include\init.c", 168; //                                                                                      //
 4198                        	
 4199                        		.dbg	line,	"include\init.c", 169; //                                  SETUP SCROLL_SPLIT                                  //
 4200                        	
 4201                        		.dbg	line,	"include\init.c", 170; //                                                                                      //
 4202                        	
 4203                        		.dbg	line,	"include\init.c", 171; //**************************************************************************************//
 4204                        	
 4205                        		.dbg	line,	"include\init.c", 173; //--------------------------------------------------------------------------------------//
 4206                        	
 4207                        		.dbg	line,	"include\init.c", 174; //                                        VDC 2                                         //
 4208                        	
 4209                        		.dbg	line,	"include\init.c", 175; //--------------------------------------------------------------------------------------//
 4210                        	
 4211                        		.dbg	line,	"include\init.c", 177; sgx_scroll_map();
 4212                        		__call		_sgx_scroll_map
         0B:DDD1  20 95 FF   			call	_sgx_scroll_map
 4213                        	
 4214                        		.dbg	line,	"include\init.c", 179; sgx_scroll_split(0,   0, sgx_map_pxl_x & (BAT_SIZE_W - 1), sgx_map_pxl_y & (BAT_SIZE_H - 1), BKG_ON | SPR_ON);
 4215                        		__st.umiq	0, _al
         0B:DDD4  64 F8      			stz	_al
 4216                        		__st.umiq	0, _ah
         0B:DDD6  64 F9      			stz	_ah
 4217                        		__ld.wm		_sgx_map_pxl_x
         0B:DDD8  AD 56 23   			lda.l	_sgx_map_pxl_x
         0B:DDDB  AC 57 23   			ldy.h	_sgx_map_pxl_x
 4218                        		__and.wi	2047
         0B:DDDE  29 FF      			and.l	#2047
         0B:DDE0  42         			say
         0B:DDE1  29 07      			and.h	#2047
         0B:DDE3  42         			say
 4219                        		__st.wmq	_bx
         0B:DDE4  85 FA      			sta.l	_bx
         0B:DDE6  84 FB      			sty.h	_bx
 4220                        		__ld.wm		_sgx_map_pxl_y
         0B:DDE8  AD 58 23   			lda.l	_sgx_map_pxl_y
         0B:DDEB  AC 59 23   			ldy.h	_sgx_map_pxl_y
 4221                        		__and.wi	255
         0B:DDEE  29 FF      			and	#255
         0B:DDF0  C2         			cly
 4222                        		__st.wmq	_cx
         0B:DDF1  85 FC      			sta.l	_cx
         0B:DDF3  84 FD      			sty.h	_cx
 4223                        		__st.umiq	192, _dl
         0B:DDF5  A9 C0      			lda.l	#192
         0B:DDF7  85 FE      			sta	_dl
 4224                        		__call		_sgx_scroll_split.5
         0B:DDF9  20 8B FF   			call	_sgx_scroll_split.5
 4225                        	
 4226                        		.dbg	line,	"include\init.c", 184; //--------------------------------------------------------------------------------------//
 4227                        	
 4228                        		.dbg	line,	"include\init.c", 185; //                                   LOAD BG PALETTES                                   //
 4229                        	
 4230                        		.dbg	line,	"include\init.c", 186; //--------------------------------------------------------------------------------------//
 4231                        	
 4232                        		.dbg	line,	"include\init.c", 188; // LOAD ALL PALETTES AT BG PALETTE 0 //
 4233                        	
 4234                        		.dbg	line,	"include\init.c", 189; load_palette( 0, palette_LV1, 16 );
 4235                        		__st.umiq	0, _al
         0B:DDFC  64 F8      			stz	_al
 4236                        		__farptr	_palette_LV1, _bp_bank, _bp
         0B:DDFE  A9 78      			lda.l	#$6000 + ($1FFF & (_palette_LV1))
         0B:DE00  85 EC      			sta.l	_bp
         0B:DE02  A9 76      			lda.h	#$6000 + ($1FFF & (_palette_LV1))
         0B:DE04  85 ED      			sta.h	_bp
         0B:DE06  A9 0A      			lda	#bank(_palette_LV1)
         0B:DE08  85 02      			sta	_bp_bank
 4237                        		__st.umiq	16, _ah
         0B:DE0A  A9 10      			lda.l	#16
         0B:DE0C  85 F9      			sta	_ah
 4238                        		__call		_load_palette.3
         0B:DE0E  20 13 FF   			call	_load_palette.3
 4239                        	
 4240                        		.dbg	line,	"include\init.c", 194; //**************************************************************************************//
 4241                        	
 4242                        		.dbg	line,	"include\init.c", 195; //                                                                                      //
 4243                        	
 4244                        		.dbg	line,	"include\init.c", 196; //                                       SPRITES                                        //
 4245                        	
 4246                        		.dbg	line,	"include\init.c", 197; //                                                                                      //
 4247                        	
 4248                        		.dbg	line,	"include\init.c", 198; //**************************************************************************************//
 4249                        	
 4250                        		.dbg	line,	"include\init.c", 200; //--------------------------------------------------------------------------------------//
 4251                        	
 4252                        		.dbg	line,	"include\init.c", 201; //                                        PLAYER                                        //
 4253                        	
 4254                        		.dbg	line,	"include\init.c", 202; //--------------------------------------------------------------------------------------//
 4255                        	
 4256                        		.dbg	line,	"include\init.c", 204; // LOAD PLAYER TILES //
 4257                        	
 4258                        		.dbg	line,	"include\init.c", 205; // 0x2000
 4259                        	
 4260                        		.dbg	line,	"include\init.c", 206; // 32 TILES = 512 //
 4261                        	
 4262                        		.dbg	line,	"include\init.c", 207; // LOAD PLAYER FIRST FRAME OF ANIMATION (IDLE)
 4263                        	
 4264                        		.dbg	line,	"include\init.c", 208; load_vram(PLAYER_VRAM_ADR, tiles_SPR_PLAYER , TILES_16);
 4265                        		__st.wmiq	18432, _di
         0B:DE11  64 F0      			stz.l	_di
         0B:DE13  A9 48      			lda.h	#18432
         0B:DE15  85 F1      			sta.h	_di
 4266                        		__farptr	_tiles_SPR_PLAYER, _bp_bank, _bp
         0B:DE17  A9 78      			lda.l	#$6000 + ($1FFF & (_tiles_SPR_PLAYER))
         0B:DE19  85 EC      			sta.l	_bp
         0B:DE1B  A9 78      			lda.h	#$6000 + ($1FFF & (_tiles_SPR_PLAYER))
         0B:DE1D  85 ED      			sta.h	_bp
         0B:DE1F  A9 0A      			lda	#bank(_tiles_SPR_PLAYER)
         0B:DE21  85 02      			sta	_bp_bank
 4267                        		__st.wmiq	256, _ax
         0B:DE23  64 F8      			stz.l	_ax
         0B:DE25  A9 01      			lda.h	#256
         0B:DE27  85 F9      			sta.h	_ax
 4268                        		 _load_vram.3
         0B:DE29  82         			clx				; Offset to PCE VDC.
         0B:DE2A  20 81 FF   			call	load_vram_x
 4269                        	
 4270                        		.dbg	line,	"include\init.c", 211; // SELECT PLAYER CORE SPRITE //
 4271                        	
 4272                        		.dbg	line,	"include\init.c", 212; spr_set(player_id);
 4273                        		__ld.umq	_player_id
         0B:DE2D  AD 04 23   			lda	_player_id
 4274                        		__call		_spr_set.1
         0B:DE30  20 DD E7   			call	_spr_set.1
 4275                        	
 4276                        		.dbg	line,	"include\init.c", 215; player_pos_x = 112;
 4277                        		__st.wmiq	112, _player_pos_x
         0B:DE33  A9 70      			lda.l	#112
         0B:DE35  8D 0A 23   			sta.l	_player_pos_x
         0B:DE38  9C 0B 23   			stz.h	_player_pos_x
 4278                        	
 4279                        		.dbg	line,	"include\init.c", 216; player_pos_y = 128;
 4280                        		__st.wmiq	128, _player_pos_y
         0B:DE3B  A9 80      			lda.l	#128
         0B:DE3D  8D 0C 23   			sta.l	_player_pos_y
         0B:DE40  9C 0D 23   			stz.h	_player_pos_y
 4281                        	
 4282                        		.dbg	line,	"include\init.c", 219; spr_x(player_pos_x);
 4283                        		__ld.wm		_player_pos_x
         0B:DE43  AD 0A 23   			lda.l	_player_pos_x
         0B:DE46  AC 0B 23   			ldy.h	_player_pos_x
 4284                        		__call		_spr_x.1
         0B:DE49  20 0A E8   			call	_spr_x.1
 4285                        	
 4286                        		.dbg	line,	"include\init.c", 220; spr_y(player_pos_y);
 4287                        		__ld.wm		_player_pos_y
         0B:DE4C  AD 0C 23   			lda.l	_player_pos_y
         0B:DE4F  AC 0D 23   			ldy.h	_player_pos_y
 4288                        		__call		_spr_y.1
         0B:DE52  20 19 E8   			call	_spr_y.1
 4289                        	
 4290                        		.dbg	line,	"include\init.c", 222; // SET TILES DATA FOR THE PLAYER //
 4291                        	
 4292                        		.dbg	line,	"include\init.c", 223; spr_pattern(PLAYER_VRAM_ADR);
 4293                        		__ld.wi		18432
         0B:DE55  62         			cla
         0B:DE56  A0 48      			ldy.h	#18432
 4294                        		__call		_spr_pattern.1
         0B:DE58  20 26 E8   			call	_spr_pattern.1
 4295                        	
 4296                        		.dbg	line,	"include\init.c", 226; spr_ctrl(FLIP_MAS|SIZE_MAS, NO_FLIP|SZ_32x32);
 4297                        		__st.umiq	185, _al
         0B:DE5B  A9 B9      			lda.l	#185
         0B:DE5D  85 F8      			sta	_al
 4298                        		__ld.uiq	17
         0B:DE5F  A9 11      			lda	#17
 4299                        		__call		_spr_ctrl.2
         0B:DE61  20 3C E8   			call	_spr_ctrl.2
 4300                        	
 4301                        		.dbg	line,	"include\init.c", 229; spr_pal(0);
 4302                        		__ld.uiq	0
         0B:DE64  62         			cla
 4303                        		__call		_spr_pal.1
         0B:DE65  20 4D E8   			call	_spr_pal.1
 4304                        	
 4305                        		.dbg	line,	"include\init.c", 230; spr_pri(TRUE);
 4306                        		__ld.uiq	1
         0B:DE68  A9 01      			lda	#1
 4307                        		__call		_spr_pri.1
         0B:DE6A  20 5C E8   			call	_spr_pri.1
 4308                        	
 4309                        		.dbg	line,	"include\init.c", 233; // UPDATE PCE SAT //
 4310                        	
 4311                        		.dbg	line,	"include\init.c", 234; satb_update();
 4312                        		__call		_satb_update
         0B:DE6D  20 09 FF   			call	_satb_update
 4313                        	
 4314                        		.dbg	line,	"include\init.c", 239; //--------------------------------------------------------------------------------------//
 4315                        	
 4316                        		.dbg	line,	"include\init.c", 240; //                                LOAD SPRITES PALETTES                                 //
 4317                        	
 4318                        		.dbg	line,	"include\init.c", 241; //--------------------------------------------------------------------------------------//
 4319                        	
 4320                        		.dbg	line,	"include\init.c", 243; load_palette( 16, palette_PLAYER, 1 );
 4321                        		__st.umiq	16, _al
         0B:DE70  A9 10      			lda.l	#16
         0B:DE72  85 F8      			sta	_al
 4322                        		__farptr	_palette_PLAYER, _bp_bank, _bp
         0B:DE74  A9 78      			lda.l	#$6000 + ($1FFF & (_palette_PLAYER))
         0B:DE76  85 EC      			sta.l	_bp
         0B:DE78  A9 6A      			lda.h	#$6000 + ($1FFF & (_palette_PLAYER))
         0B:DE7A  85 ED      			sta.h	_bp
         0B:DE7C  A9 0B      			lda	#bank(_palette_PLAYER)
         0B:DE7E  85 02      			sta	_bp_bank
 4323                        		__st.umiq	1, _ah
         0B:DE80  A9 01      			lda.l	#1
         0B:DE82  85 F9      			sta	_ah
 4324                        		__call		_load_palette.3
         0B:DE84  20 13 FF   			call	_load_palette.3
 4325                        	
 4326                        		.dbg	line,	"include\init.c", 248; //**************************************************************************************//
 4327                        	
 4328                        		.dbg	line,	"include\init.c", 249; //                                                                                      //
 4329                        	
 4330                        		.dbg	line,	"include\init.c", 250; //                                      VARIABLES                                       //
 4331                        	
 4332                        		.dbg	line,	"include\init.c", 251; //                                                                                      //
 4333                        	
 4334                        		.dbg	line,	"include\init.c", 252; //**************************************************************************************//
 4335                        	
 4336                        		.dbg	line,	"include\init.c", 254; //
 4337                        	
 4338                        		.dbg	line,	"include\init.c", 257; // VSYNC //
 4339                        	
 4340                        		.dbg	line,	"include\init.c", 258; vsync();
 4341                        		__call		_vsync
         0B:DE87  20 09 E3   			call	_vsync
 4342                        	
 4343                        		.dbg	line,	"include\init.c", 260; // ENABLE DISPLAY //
 4344                        	
 4345                        		.dbg	line,	"include\init.c", 261; disp_on();
 4346                        		__call		_disp_on
         0B:DE8A  20 16 E4   			call	_disp_on
 4347                        	
 4348                        		.dbg	line,	"include\init.c", 262; }
 4349                        	
 4350                        		.dbg	line,	"include\init.c", 263; }
 4351    0B:DE8D             	.LL86:
 4352    0B:DE8D             	.LL85:
 4353                        		__return	0
         0B:DE8D  4C EF FF   			jmp	leave_proc
 4354                        		.dbg	clear
 4355                        		.endp
 4356                        		.pceas
 4357                        	
 4358                        		.dbg	line,	"main.c", 29; main()
 4359                        		.dbg	line,	"main.c", 30; {
 4360                        	;***********************
 4361                        	;***********************
 4362                        	
 4363                        		.hucc
 4364    01:C3B1             		.proc		_main
 4365                        		__enter		_main
 4366                        	
 4367                        		.dbg	line,	"main.c", 31; if(!sgx_detect())
 4368                        		 _sgx_detect
         01:C3B1  AD E8 22   			lda	sgx_detected
         01:C3B4  C2         			cly
 4369                        		__not.wr
         01:C3B5  84 00      			sty	__temp
         01:C3B7  05 00      			ora	__temp
         01:C3B9  18         			clc
         01:C3BA  D0 01      			bne	!+
         01:C3BC  38         			sec
         01:C3BD             	!:
 4370                        		__bfalse	.LL88
         01:C3BD  90 14      			bcc	.LL88
 4371                        	
 4372                        		.dbg	line,	"main.c", 32; {
 4373                        	
 4374                        		.dbg	line,	"main.c", 33; put_string("Halt: SGX hardware not found", 2, 13);
 4375                        		__ld.wi		__const1+0
         01:C3BF  62         			cla
         01:C3C0  A0 60      			ldy.h	#__const1+0
 4376                        		__st.wmq	_bp
         01:C3C2  85 EC      			sta.l	_bp
         01:C3C4  84 ED      			sty.h	_bp
 4377                        		__st.umiq	2, _dil
         01:C3C6  A9 02      			lda.l	#2
         01:C3C8  85 F0      			sta	_dil
 4378                        		__st.umiq	13, _dih
         01:C3CA  A9 0D      			lda.l	#13
         01:C3CC  85 F1      			sta	_dih
 4379                        		__call		_put_string.3
         01:C3CE  20 68 E6   			call	_put_string.3
 4380                        	
 4381                        		.dbg	line,	"main.c", 35; for(;;)
 4382    01:C3D1             	.LL89	.alias		.LL91
 4383    01:C3D1             	.LL90	.alias		.LL91
 4384    01:C3D1             	.LL91:
 4385                        	
 4386                        		.dbg	line,	"main.c", 36; {
 4387                        	
 4388                        		.dbg	line,	"main.c", 37; // INFINITE LOOP //
 4389                        	
 4390                        		.dbg	line,	"main.c", 38; }
 4391                        		__bra		.LL91
         01:C3D1  80 FE      			bra	.LL91
 4392    01:C3D3             	.LL92:
 4393                        	
 4394                        		.dbg	line,	"main.c", 39; }
 4395                        	
 4396                        		.dbg	line,	"main.c", 44; init_VARIABLES();
 4397    01:C3D3             	.LL88:
 4398                        		__call		_init_VARIABLES
         01:C3D3  20 FF FE   			call	_init_VARIABLES
 4399                        	
 4400                        		.dbg	line,	"main.c", 47; init_PLAYER();
 4401                        		__call		_init_PLAYER
         01:C3D6  20 F5 FE   			call	_init_PLAYER
 4402                        	
 4403                        		.dbg	line,	"main.c", 52; //**************************************************************************************//
 4404                        	
 4405                        		.dbg	line,	"main.c", 53; //                                                                                      //
 4406                        	
 4407                        		.dbg	line,	"main.c", 54; //                                      TITLE                                           //
 4408                        	
 4409                        		.dbg	line,	"main.c", 55; //                                                                                      //
 4410                        	
 4411                        		.dbg	line,	"main.c", 56; //**************************************************************************************//
 4412                        	
 4413                        		.dbg	line,	"main.c", 57; for(;;)
 4414    01:C3D9             	.LL93:
 4415    01:C3D9             	.LL94:
 4416    01:C3D9             	.LL95:
 4417                        	
 4418                        		.dbg	line,	"main.c", 58; {
 4419                        	
 4420                        		.dbg	line,	"main.c", 60; if(sequence_id == SEQUENCE_TITLE)
 4421                        		__not.um	_sequence_id
         01:C3D9  AD 01 23   			lda	_sequence_id
         01:C3DC  18         			clc
         01:C3DD  D0 01      			bne	!+
         01:C3DF  38         			sec
         01:C3E0             	!:
 4422                        		__bfalse	.LL97
         01:C3E0  90 02      			bcc	.LL97
 4423                        	
 4424                        		.dbg	line,	"main.c", 61; {
 4425                        	
 4426                        		.dbg	line,	"main.c", 63; }
 4427                        	
 4428                        		.dbg	line,	"main.c", 66; else if(sequence_id == SEQUENCE_GAME)
 4429                        		__bra		.LL98
         01:C3E2  80 F5      			bra	.LL98
 4430    01:C3E4             	.LL97:
 4431                        		__ld.umq	_sequence_id
         01:C3E4  AD 01 23   			lda	_sequence_id
 4432                        		__equ_b.uiq	2
         01:C3E7  C9 02      			cmp	#2
         01:C3E9  F0 01      			beq	!+
         01:C3EB  18         			clc
         01:C3EC             	!:
 4433                        		__bfalse	.LL99
         01:C3EC  90 EB      			bcc	.LL99
 4434                        	
 4435                        		.dbg	line,	"main.c", 67; {
 4436                        	
 4437                        		.dbg	line,	"main.c", 68; // LOADING LOGO SCREEN //
 4438                        	
 4439                        		.dbg	line,	"main.c", 69; if(sequence_loaded == FALSE)
 4440                        		__not.um	_sequence_loaded
         01:C3EE  AD 02 23   			lda	_sequence_loaded
         01:C3F1  18         			clc
         01:C3F2  D0 01      			bne	!+
         01:C3F4  38         			sec
         01:C3F5             	!:
 4441                        		__bfalse	.LL100
         01:C3F5  90 0A      			bcc	.LL100
 4442                        	
 4443                        		.dbg	line,	"main.c", 70; {
 4444                        	
 4445                        		.dbg	line,	"main.c", 71; init_LEVEL();
 4446                        		__call		_init_LEVEL
         01:C3F7  20 EB FE   			call	_init_LEVEL
 4447                        	
 4448                        		.dbg	line,	"main.c", 73; sequence_loaded = TRUE;
 4449                        		__st.umiq	1, _sequence_loaded
         01:C3FA  A9 01      			lda.l	#1
         01:C3FC  8D 02 23   			sta	_sequence_loaded
 4450                        	
 4451                        		.dbg	line,	"main.c", 74; }
 4452                        	
 4453                        		.dbg	line,	"main.c", 77; else
 4454                        		__bra		.LL101
         01:C3FF  80 D8      			bra	.LL101
 4455    01:C401             	.LL100:
 4456                        	
 4457                        		.dbg	line,	"main.c", 78; {
 4458                        	
 4459                        		.dbg	line,	"main.c", 79; if(level_id == 1)
 4460                        		__ld.umq	_level_id
         01:C401  AD 03 23   			lda	_level_id
 4461                        		__equ_b.uiq	1
         01:C404  C9 01      			cmp	#1
         01:C406  F0 01      			beq	!+
         01:C408  18         			clc
         01:C409             	!:
 4462                        		__bfalse	.LL102
         01:C409  90 11      			bcc	.LL102
 4463                        	
 4464                        		.dbg	line,	"main.c", 80; {
 4465                        	
 4466                        		.dbg	line,	"main.c", 81; vsync();
 4467                        		__call		_vsync
         01:C40B  20 09 E3   			call	_vsync
 4468                        	
 4469                        		.dbg	line,	"main.c", 83; joypad_BUTTONS();
 4470                        		__call		_joypad_BUTTONS
         01:C40E  20 E1 FE   			call	_joypad_BUTTONS
 4471                        	
 4472                        		.dbg	line,	"main.c", 84; joypad_DIR();
 4473                        		__call		_joypad_DIR
         01:C411  20 D7 FE   			call	_joypad_DIR
 4474                        	
 4475                        		.dbg	line,	"main.c", 85; update_PLAYER();
 4476                        		__call		_update_PLAYER
         01:C414  20 CD FE   			call	_update_PLAYER
 4477                        	
 4478                        		.dbg	line,	"main.c", 87; // UPDATE PCE SAT //
 4479                        	
 4480                        		.dbg	line,	"main.c", 88; satb_update();
 4481                        		__call		_satb_update
         01:C417  20 09 FF   			call	_satb_update
 4482                        	
 4483                        		.dbg	line,	"main.c", 90; //put_number(map_blk_flag,1,32,0);
 4484                        	
 4485                        		.dbg	line,	"main.c", 91; //put_number(player_previous_axis,1,15,1);
 4486                        	
 4487                        		.dbg	line,	"main.c", 92; }
 4488                        	
 4489                        		.dbg	line,	"main.c", 94; else if(level_id == 2)
 4490                        		__bra		.LL103
         01:C41A  80 BD      			bra	.LL103
 4491    01:C41C             	.LL102:
 4492                        		__ld.umq	_level_id
         01:C41C  AD 03 23   			lda	_level_id
 4493                        		__equ_b.uiq	2
         01:C41F  C9 02      			cmp	#2
         01:C421  F0 01      			beq	!+
         01:C423  18         			clc
         01:C424             	!:
 4494                        		__bfalse	.LL104
         01:C424  90 02      			bcc	.LL104
 4495                        	
 4496                        		.dbg	line,	"main.c", 95; {
 4497                        	
 4498                        		.dbg	line,	"main.c", 96; //sequence_LV2();
 4499                        	
 4500                        		.dbg	line,	"main.c", 97; }
 4501                        	
 4502                        		.dbg	line,	"main.c", 99; else if(level_id == 3)
 4503                        		__bra		.LL105
         01:C426  80 B1      			bra	.LL105
 4504    01:C428             	.LL104:
 4505                        		__ld.umq	_level_id
         01:C428  AD 03 23   			lda	_level_id
 4506                        		__equ_b.uiq	3
         01:C42B  C9 03      			cmp	#3
         01:C42D  F0 01      			beq	!+
         01:C42F  18         			clc
         01:C430             	!:
 4507                        		__bfalse	.LL106
         01:C430  90 02      			bcc	.LL106
 4508                        	
 4509                        		.dbg	line,	"main.c", 100; {
 4510                        	
 4511                        		.dbg	line,	"main.c", 101; //sequence_LV3();
 4512                        	
 4513                        		.dbg	line,	"main.c", 102; }
 4514                        	
 4515                        		.dbg	line,	"main.c", 104; else if(level_id == 4)
 4516                        		__bra		.LL107
         01:C432  80 A5      			bra	.LL107
 4517    01:C434             	.LL106:
 4518                        		__ld.umq	_level_id
         01:C434  AD 03 23   			lda	_level_id
 4519                        		__equ_b.uiq	4
         01:C437  C9 04      			cmp	#4
         01:C439  F0 01      			beq	!+
         01:C43B  18         			clc
         01:C43C             	!:
 4520                        		__bfalse	.LL108
         01:C43C  90 02      			bcc	.LL108
 4521                        	
 4522                        		.dbg	line,	"main.c", 105; {
 4523                        	
 4524                        		.dbg	line,	"main.c", 106; //sequence_LV4();
 4525                        	
 4526                        		.dbg	line,	"main.c", 107; }
 4527                        	
 4528                        		.dbg	line,	"main.c", 109; else if(level_id == 5)
 4529                        		__bra		.LL109
         01:C43E  80 99      			bra	.LL109
 4530    01:C440             	.LL108:
 4531                        		__ld.umq	_level_id
         01:C440  AD 03 23   			lda	_level_id
 4532                        		__equ_b.uiq	5
         01:C443  C9 05      			cmp	#5
         01:C445  F0 01      			beq	!+
         01:C447  18         			clc
         01:C448             	!:
 4533                        		__bfalse	.LL110
         01:C448  90 8F      			bcc	.LL110
 4534                        	
 4535                        		.dbg	line,	"main.c", 110; {
 4536                        	
 4537                        		.dbg	line,	"main.c", 111; //sequence_LV5();
 4538                        	
 4539                        		.dbg	line,	"main.c", 112; }
 4540                        	
 4541                        		.dbg	line,	"main.c", 113; }
 4542    01:C44A             	.LL110	.alias		.LL95
 4543    01:C44A             	.LL109	.alias		.LL95
 4544    01:C44A             	.LL107	.alias		.LL95
 4545    01:C44A             	.LL105	.alias		.LL95
 4546    01:C44A             	.LL103	.alias		.LL95
 4547    01:C44A             	.LL101	.alias		.LL95
 4548                        	
 4549                        		.dbg	line,	"main.c", 114; }
 4550                        	
 4551                        		.dbg	line,	"main.c", 115; }
 4552    01:C44A             	.LL99	.alias		.LL95
 4553    01:C44A             	.LL98	.alias		.LL95
 4554                        		__bra		.LL95
         01:C44A  80 8D      			bra	.LL95
 4555    01:C44C             	.LL96:
 4556                        	
 4557                        		.dbg	line,	"main.c", 118; }
 4558    01:C44C             	.LL87:
 4559                        		__return	1
         01:C44C  AA         			tax
         01:C44D  4C EF FF   			jmp	leave_proc
 4560                        		.dbg	clear
 4561                        		.endp
 4562                        		.pceas
 4563                        	
 4564                        		.dbg	clear
 4565               6000     		.rodata
 4566    01:6000             	__const1:
 4567    01:6000  48 61 6C 74			db	'H','a','l','t',':',' ','S','G'
         01:6004  3A 20 53 47 
 4568    01:6008  58 20 68 61			db	'X',' ','h','a','r','d','w','a'
         01:600C  72 64 77 61 
 4569    01:6010  72 65 20 6E			db	'r','e',' ','n','o','t',' ','f'
         01:6014  6F 74 20 66 
 4570    01:6018  6F 75 6E 64			db	'o','u','n','d',$00
         01:601C  00          
 4571    01:601D             	_TABLE_PLAYER_JUMP_V:
 4572    01:601D  FC         			db	-4
 4573    01:601E  FB         			db	-5
 4574    01:601F  F6         			db	-10
 4575    01:6020  FC         			db	-4
 4576    01:6021  FC         			db	-4
 4577    01:6022  F9         			db	-7
 4578    01:6023  FA         			db	-6
 4579    01:6024  FD         			db	-3
 4580    01:6025  FB         			db	-5
 4581    01:6026  FE         			db	-2
 4582    01:6027  FC         			db	-4
 4583    01:6028  FF         			db	-1
 4584    01:6029  FF         			db	-1
 4585    01:602A  FF         			db	-1
 4586    01:602B  FF         			db	-1
 4587    01:602C  00         			db	0
 4588    01:602D  00         			db	0
 4589    01:602E  00         			db	0
 4590    01:602F  00         			db	0
 4591    01:6030  01         			db	1
 4592    01:6031  01         			db	1
 4593    01:6032  01         			db	1
 4594    01:6033  01         			db	1
 4595    01:6034  04         			db	4
 4596    01:6035  02         			db	2
 4597    01:6036  05         			db	5
 4598    01:6037  03         			db	3
 4599    01:6038  06         			db	6
 4600    01:6039  07         			db	7
 4601    01:603A  04         			db	4
 4602    01:603B  04         			db	4
 4603    01:603C  0A         			db	10
 4604    01:603D  04         			db	4
 4605    01:603E  04         			db	4
 4606    01:603F  05         			db	5
 4607                        	
 4608               2301     		.bss
 4609    F8:2301             	_sequence_id:
 4610    F8:2301             			ds	1
 4611    F8:2302             	_sequence_loaded:
 4612    F8:2302             			ds	1
 4613    F8:2303             	_level_id:
 4614    F8:2303             			ds	1
 4615    F8:2304             	_player_id:
 4616    F8:2304             			ds	1
 4617    F8:2305             	_player_state:
 4618    F8:2305             			ds	1
 4619    F8:2306             	_player_axis:
 4620    F8:2306             			ds	1
 4621    F8:2307             	_player_previous_axis:
 4622    F8:2307             			ds	1
 4623    F8:2308             	_player_counter_anim:
 4624    F8:2308             			ds	1
 4625    F8:2309             	_player_index_jump:
 4626    F8:2309             			ds	1
 4627    F8:230A             	_player_pos_x:
 4628    F8:230A             			ds	2
 4629    F8:230C             	_player_pos_y:
 4630    F8:230C             			ds	2
 4631                        	
 4632                        	
 4633                        	;0 error(s) in compilation
 4634                        	;	literal pool:29
 4635                        	;	constant pool:35
 4636                        	;	global pool:354
 4637                        	;	Macro pool:172
 4638    F8:230E             	leaf_loc:
 4639    F8:230E             			ds	4
 4640    F8:2312             	__calculate_COLLISION_DEEP_end:
 4641    F8:2312             	__check_WALL_R_end:
 4642    F8:2312             	__check_WALL_L_end:
 4643    F8:2312             	__check_FLOOR_R_end:
 4644    F8:2312             	__check_FLOOR_L_end:
 4645                        	
 4646    F8:2312             	__bss_init:
 4647                        	
 4648    F8:2312             	__heap_start:
                             #[2]   "..\..\..\include\hucc\hucc-final.asm"
    1                        	; ***************************************************************************
    2                        	; ***************************************************************************
    3                        	;
    4                        	; hucc-final.asm
    5                        	;
    6                        	; PCEAS auto-includes this file at the end of every pass in HuCC or SDCC.
    7                        	;
    8                        	; Copyright John Brandwood 2024.
    9                        	;
   10                        	; Distributed under the Boost Software License, Version 1.0.
   11                        	; (See accompanying file LICENSE_1_0.txt or copy at
   12                        	;  http://www.boost.org/LICENSE_1_0.txt)
   13                        	;
   14                        	; ***************************************************************************
   15                        	; ***************************************************************************
   16                        	;
   17                        	; This is used to select which assembly-language library files to include in
   18                        	; a HuCC project, using labels defined in the compiler's header files.
   19                        	;
   20                        	; ***************************************************************************
   21                        	; ***************************************************************************
   22                        	
   23                        			; Allow projects to customize what is included at the end
   24                        			; of a pass without replacing the entire "hucc-final.asm".
   25                        	
   26               E309     			.code
   27               0000     			.bank	CORE_BANK
   28               E309     			.page	CORE_PAGE
   29                        	
                             #[3]   "..\..\..\include\hucc\hucc-final-extra.asm"
   30                        			include	"hucc-final-extra.asm"
    1                        	; ***************************************************************************
    2                        	; ***************************************************************************
    3                        	;
    4                        	; hucc-final-extra.asm
    5                        	;
    6                        	; hucc-final.asm includes this file at the end of every pass in HuCC or SDCC.
    7                        	;
    8                        	; Copyright John Brandwood 2024.
    9                        	;
   10                        	; Distributed under the Boost Software License, Version 1.0.
   11                        	; (See accompanying file LICENSE_1_0.txt or copy at
   12                        	;  http://www.boost.org/LICENSE_1_0.txt)
   13                        	;
   14                        	; ***************************************************************************
   15                        	; ***************************************************************************
   16                        	;
   17                        	; This is used to select which assembly-language library files to include in
   18                        	; a HuCC project, using labels defined in the compiler's header files.
   19                        	;
   20                        	; ***************************************************************************
   21                        	; ***************************************************************************
                             #[2]   "..\..\..\include\hucc\hucc-final.asm"
   31                        	
   32                        			; Libraries required for basic functionality.
   33                        	
   34               E309     			.code
   35               0000     			.bank	CORE_BANK
   36               E309     			.page	CORE_PAGE
   37                        	
                             #[3]   "..\..\..\include\hucc\common.asm"
   38                        			include	"common.asm"		; Common helpers.
    1                        	; ***************************************************************************
    2                        	; ***************************************************************************
    3                        	;
    4                        	; common.asm
    5                        	;
    6                        	; Small, generic, PCE subroutines that are commonly useful when developing.
    7                        	;
    8                        	; These should be located in permanently-accessible memory!
    9                        	;
   10                        	; Copyright John Brandwood 2021-2024.
   11                        	;
   12                        	; Distributed under the Boost Software License, Version 1.0.
   13                        	; (See accompanying file LICENSE_1_0.txt or copy at
   14                        	;  http://www.boost.org/LICENSE_1_0.txt)
   15                        	;
   16                        	; ***************************************************************************
   17                        	; ***************************************************************************
   18                        	
   19                        	
   20                        	
   21                        	; ***************************************************************************
   22                        	; ***************************************************************************
   23                        	;
   24                        	; Wait for the next VBLANK IRQ.
   25                        	;
   26                        	
   27    00:E309  AD 41 22   	wait_vsync:	lda	irq_cnt			; System Card variable, changed
   28    00:E30C  CD 41 22   	.loop:		cmp	irq_cnt			; every VBLANK interrupt.
   29    00:E30F  F0 FB      			beq	.loop
   30               0001     		.ifdef	HUCC
   31    00:E311  8D EB 22   			sta	old_cnt			; Remember the frame count.
   32                        		.endif
   33    00:E314  60         			rts
   34                        	
   35                        	
   36                        	
   37                        	; ***************************************************************************
   38                        	; ***************************************************************************
   39                        	;
   40                        	; Delay for the next Y VBLANK IRQs.
   41                        	;
   42                        	
   43               0001     		.ifdef	HUCC
   44    00:E315             	_vsync		.alias	wait_vsync
   45                        	
   46    00:E315  AD 41 22   	_vsync.1:	lda	irq_cnt			; HuCC's vsync(n) was defined
   47    00:E318  38         			sec				; as frames from the previous
   48    00:E319  ED EB 22   			sbc	old_cnt			; vsync() call, 1 to 255.
   49    00:E31C  38         			sec
   50    00:E31D  E5 F8      			sbc	<_al
   51    00:E31F  90 02      			bcc	!+
   52    00:E321  A9 FF      			lda	#$FF
   53    00:E323  49 FF      	!:		eor	#$FF
   54    00:E325  1A         			inc	a
   55    00:E326  A8         			tay
   56                        		.endif
   57                        	
   58    00:E327  44 E0      	wait_nvsync:	bsr	wait_vsync		; # of VBLANK IRQs to wait in
   59    00:E329  88         			dey				; the Y register.
   60    00:E32A  D0 FB      			bne	wait_nvsync
   61    00:E32C  60         			rts
   62                        	
   63                        	
   64                        	
   65               0000     		.ifndef	HUCC
  101                        		.endif
  102                        	
  103                        	
  104                        	
  105                        	; ***************************************************************************
  106                        	; ***************************************************************************
  107                        	;
  108                        	; Map the _bp data far-pointer into MPR3 (& MPR4).
  109                        	;
  110                        	; Because the 16KB RAM region at $2000-$5FFF is composed of two separate
  111                        	; banks, with the 2nd bank having no specific relation to the 1st, there
  112                        	; is no way to deal with a bank-increment, so do not map that region.
  113                        	;
  114                        	; N.B. Library code relies on this preserving X and V!
  115                        	;
  116                        	
  117    00:E32D  98         	map_bp_to_mpr3:	tya				; Put bank into MPR3.
  118    00:E32E  F0 0A      			beq	!+
  119    00:E330  53 08      			tam3
  120    00:E332  A5 ED      			lda.h	<_bp			; Do not remap a ptr to RAM,
  121    00:E334  29 1F      			and	#$1F			; Remap ptr to MPR3.
  122    00:E336  09 60      			ora	#$60
  123    00:E338  85 ED      			sta.h	<_bp
  124    00:E33A  60         	!:		rts
  125                        	
  126    00:E33B  98         	map_bp_to_mpr34:tya				; Put bank into MPR3.
  127    00:E33C  F0 0D      			beq	!+
  128    00:E33E  53 08      			tam3
  129    00:E340  1A         			inc	a			; Put next into MPR4.
  130    00:E341  53 10      			tam4
  131    00:E343  A5 ED      			lda.h	<_bp			; Do not remap a ptr to RAM,
  132    00:E345  29 1F      			and	#$1F			; Remap ptr to MPR3.
  133    00:E347  09 60      			ora	#$60
  134    00:E349  85 ED      			sta.h	<_bp
  135    00:E34B  60         	!:		rts
  136                        	
  137                        	
  138                        	
  139                        	; ***************************************************************************
  140                        	; ***************************************************************************
  141                        	;
  142                        	; Increment the hi-byte of _bp and change TMA3 if necessary.
  143                        	;
  144                        	; N.B. Library code relies on this preserving A,X,Y and V!
  145                        	;
  146                        	
  147    00:E34C  E6 ED      	inc.h_bp_mpr3:	inc.h	<_bp			; Increment hi-byte of _bp.
  148    00:E34E  10 0B      			bpl	!+			; OK if within MPR0-MPR3.
  149    00:E350  48         			pha				; Increment the bank in MPR3,
  150    00:E351  43 08      			tma3				; usually when pointer moves
  151    00:E353  1A         			inc	a			; from $7FFF -> $8000.
  152    00:E354  53 08      			tam3
  153    00:E356  A9 60      			lda	#$60
  154    00:E358  85 ED      			sta.h	<_bp
  155    00:E35A  68         			pla
  156    00:E35B  60         	!:		rts
  157                        	
  158                        	
  159                        	
  160                        	; ***************************************************************************
  161                        	; ***************************************************************************
  162                        	;
  163                        	; Increment the hi-byte of _bp and change TMA3 and TMA4 if necessary.
  164                        	;
  165                        	; N.B. Library code relies on this preserving A,X,Y and V!
  166                        	;
  167                        	
  168    00:E35C  E6 ED      	inc.h_bp_mpr34:	inc.h	<_bp			; Increment hi-byte of _bp.
  169    00:E35E  10 0D      			bpl	!+			; OK if within MPR0-MPR3.
  170    00:E360  48         			pha				; Increment the bank in MPR3,
  171    00:E361  43 10      			tma4				; usually when pointer moves
  172    00:E363  53 08      			tam3				; from $7FFF -> $8000.
  173    00:E365  1A         			inc	a
  174    00:E366  53 10      			tam4
  175    00:E368  A9 60      			lda	#$60
  176    00:E36A  85 ED      			sta.h	<_bp
  177    00:E36C  68         			pla
  178    00:E36D  60         	!:		rts
  179                        	
  180                        	
  181                        	
  182                        	; ***************************************************************************
  183                        	; ***************************************************************************
  184                        	;
  185                        	; Put the _di data pointer into the VDC's MARR or MAWR register.
  186                        	;
  187                        	; N.B. Library code relies on this preserving Y!
  188                        	;
  189                        	
  190               0001     		.if	SUPPORT_SGX
  191    00:E36E  A2 10      	sgx_di_to_marr:	ldx	#SGX_VDC_OFFSET		; Offset to SGX VDC.
  192    00:E370  F0         			db	$F0			; Turn "clx" into a "beq".
  193                        		.endif
  194                        	
  195    00:E371  82         	vdc_di_to_marr:	clx				; Offset to PCE VDC.
  196                        	
  197    00:E372  A9 01      	set_di_to_marr	lda	#VDC_MARR		; Set VDC or SGX destination
  198    00:E374  95 F7      			sta	<vdc_reg, x		; address.
  199    00:E376  9D 00 02   			sta	VDC_AR, x
  200    00:E379  80 09      			bra	!+
  201                        	
  202               0001     		.if	SUPPORT_SGX
  203    00:E37B  A2 10      	sgx_di_to_mawr:	ldx	#SGX_VDC_OFFSET		; Offset to SGX VDC.
  204    00:E37D  F0         			db	$F0			; Turn "clx" into a "beq".
  205                        		.endif
  206                        	
  207    00:E37E  82         	vdc_di_to_mawr:	clx				; Offset to PCE VDC.
  208                        	
  209    00:E37F             	set_di_to_mawr;	lda	#VDC_MAWR		; Set VDC or SGX destination
  210    00:E37F  74 F7      			stz	<vdc_reg, x		; address.
  211    00:E381  9E 00 02   			stz	VDC_AR, x
  212                        	
  213    00:E384  A5 F0      	!:		lda	<_di + 0
  214    00:E386  9D 02 02   			sta	VDC_DL, x
  215    00:E389  A5 F1      			lda	<_di + 1
  216    00:E38B  9D 03 02   			sta	VDC_DH, x
  217                        	
  218    00:E38E  A9 02      			lda	#VDC_VWR		; Select the VRR/VWR data
  219    00:E390  95 F7      			sta	<vdc_reg, x		; register.
  220    00:E392  9D 00 02   			sta	VDC_AR, x
  221    00:E395  60         			rts
  222                        	
  223                        	
  224                        	
  225                        	; ***************************************************************************
  226                        	; ***************************************************************************
  227                        	;
  228                        	; Increment the hi-byte of _di and change TMA4 if necessary.
  229                        	;
  230                        	
  231               0000     		.if	0				; Save memory, for now.
  250                        		.endif
  251                        	
  252                        	
  253                        	
  254                        	; ***************************************************************************
  255                        	; ***************************************************************************
  256                        	;
  257                        	; Far-call a function in another bank.
  258                        	;
  259                        	; This is a potential alternative procedure call trampoline that uses only 10
  260                        	; bytes of common memory per bank of procedures, instead of 10 bytes for each
  261                        	; individual procedure call, BUT it uses the X register as a procedure-index,
  262                        	; and it needs a table of addresses at the end of every procedure bank.
  263                        	;
  264                        	; To use this ...
  265                        	;
  266                        	;  ldx #procedure-index
  267                        	;  jsr far_call_nn
  268                        	;
  269                        	; The called .PROC routine must exit with "jmp leave_proc" and not "rts".
  270                        	;
  271                        	; leave_proc:	pla
  272                        	;		tam6
  273                        	;		tya
  274                        	;		rts
  275                        	;
  276                        	; N.B. This costs 21 cycles vs 18 for the .newproc trampoline code (when you
  277                        	;      exclude preserving YA in zero-page).
  278                        	;
  279                        	; N.B. This was written as an excerise, and definitely not for HuC!
  280                        	;
  281                        	
  282               0000     		.if	0
  295                        		.endif					; 21
                             #[2]   "..\..\..\include\hucc\hucc-final.asm"
                             #[3]   "..\..\..\include\hucc\vce.asm"
   39                        			include	"vce.asm"		; Useful VCE routines.
    1                        	; ***************************************************************************
    2                        	; ***************************************************************************
    3                        	;
    4                        	; vce.asm
    5                        	;
    6                        	; Useful routines for operating the HuC6260 Video Color Encoder
    7                        	;
    8                        	; These should be located in permanently-accessible memory!
    9                        	;
   10                        	; Copyright John Brandwood 2021-2025.
   11                        	;
   12                        	; Distributed under the Boost Software License, Version 1.0.
   13                        	; (See accompanying file LICENSE_1_0.txt or copy at
   14                        	;  http://www.boost.org/LICENSE_1_0.txt)
   15                        	;
   16                        	; ***************************************************************************
   17                        	; ***************************************************************************
   18                        	
   19                        	;
   20                        	; Configure Library ...
   21                        	;
   22                        	
   23               0000     		.ifndef VCE_SPLIT_CROSS
   25                        		.endif
   26                        	
   27                        	
   28                        	
   29                        	; ***************************************************************************
   30                        	; ***************************************************************************
   31                        	;
   32                        	; xfer_palettes - Update the VCE with the queued palettes changes.
   33                        	;
   34                        	; This is normally called in a developer's vsync_hook handler, but it can
   35                        	; be called manually as long as it will not also be called in an interrupt.
   36                        	;
   37                        	; The queued transfers are split into 32-byte chunks so that an HSYNC and/or
   38                        	; TIMER IRQ is not delayed for too long during the VBLANK.
   39                        	;
   40                        	
   41    00:E396  A9 80      	xfer_palettes:	lda	#$80			; Acquire color mutex to avoid
   42    00:E398  0C 12 23   			tsb	color_mutex		; conflict with a delayed VBL.
   43    00:E39B  30 5F      			bmi	.busy
   44                        	
   45    00:E39D  AC 13 23   			ldy	color_queue_r		; Are there any palette xfers
   46    00:E3A0  CC 14 23   			cpy	color_queue_w		; queued up?
   47    00:E3A3  F0 54      			beq	.exit
   48                        	
   49    00:E3A5  08         			php				; Enable interrupts so that an
   50    00:E3A6  58         			cli				; HSYNC or TIMER IRQ can occur.
   51                        	
   52    00:E3A7  43 08      			tma3				; Preserve MPR3 & MPR4 because
   53    00:E3A9  48         			pha				; this normally runs in the
   54    00:E3AA  43 10      			tma4				; VBLANK IRQ.
   55    00:E3AC  48         			pha
   56                        	
   57               0001     		.if	!CDROM
   58    00:E3AD  73 02 E4 86			tii	.tia_func, color_tia, 8 ; Copy TIA to RAM.
         00:E3B1  22 08 00    
   59                        		.endif
   60                        	
   61    00:E3B4  B9 15 23   	.next_item:	lda	color_index, y		; Get the next set of palettes
   62    00:E3B7  0A         			asl	a			; from the queue.
   63    00:E3B8  0A         			asl	a
   64    00:E3B9  0A         			asl	a
   65    00:E3BA  0A         			asl	a
   66    00:E3BB  8D 02 04   			sta	VCE_CTA + 0
   67    00:E3BE  62         			cla
   68    00:E3BF  2A         			rol	a
   69    00:E3C0  8D 03 04   			sta	VCE_CTA + 1
   70                        	
   71    00:E3C3  BE 1D 23   			ldx	color_count,y		; How many palettes to xfer?
   72                        	
   73    00:E3C6  B9 35 23   			lda	color_bank, y		; Map data into MPR3 & MPR4.
   74    00:E3C9  53 08      			tam3
   75    00:E3CB  1A         			inc	a
   76    00:E3CC  53 10      			tam4
   77    00:E3CE  B9 2D 23   			lda	color_addr_h, y
   78    00:E3D1  8D 88 22   			sta	.ram_tia + 2
   79    00:E3D4  B9 25 23   			lda	color_addr_l, y
   80    00:E3D7  8D 87 22   	.palette_loop:	sta	.ram_tia + 1
   81                        	
   82               0000     		.if	CDROM
   84                        		.else
   85    00:E3DA  20 86 22   			jsr	.ram_tia		; Copy 32-bytes to the VCE.
   86                        		.endif
   87                        	
   88    00:E3DD  18         			clc				; Increment the data ptr to
   89    00:E3DE  69 20      			adc	#32			; the next 32-byte palette.
   90    00:E3E0  B0 1B      			bcs	.next_page
   91                        	
   92    00:E3E2  CA         	.next_palette:	dex				; Any palettes left to xfer?
   93    00:E3E3  D0 F2      			bne	.palette_loop
   94                        	
   95    00:E3E5  C8         			iny				; Increment the queue index.
   96    00:E3E6  98         			tya
   97    00:E3E7  29 07      			and	#7
   98    00:E3E9  A8         			tay
   99                        	
  100    00:E3EA  CC 14 23   			cpy	color_queue_w		; Any more items in the queue?
  101    00:E3ED  D0 C5      			bne	.next_item
  102    00:E3EF  8C 13 23   			sty	color_queue_r		; Signal the queue is empty.
  103                        	
  104    00:E3F2  68         			pla				; Restore MPR3 & MPR4.
  105    00:E3F3  53 10      			tam4
  106    00:E3F5  68         			pla
  107    00:E3F6  53 08      			tam3
  108                        	
  109    00:E3F8  28         			plp				; Restore interrupt state.
  110                        	
  111    00:E3F9  9C 12 23   	.exit:		stz	color_mutex		; Release color mutex.
  112                        	
  113    00:E3FC  60         	.busy:		rts
  114                        	
  115    00:E3FD  EE 88 22   	.next_page:	inc	.ram_tia + 2
  116    00:E400  80 E0      			bra	.next_palette
  117                        	
  118               0001     		.if	!CDROM
  119               2286     	.ram_tia	=	color_tia		; Use a TIA in RAM.
  120                        	
  121    00:E402  E3 00 00 04	.tia_func:	tia	0, VCE_CTW, 32
         00:E406  04 20 00    
  122    00:E409  60         			rts
  123                        		.endif	!CDROM
  124                        	
  125               2312     			.bss
  126                        	
  127    F8:2312             	color_mutex:	ds	1			; Mutex for VCE changes.
  128    F8:2313             	color_queue_r:	ds	1			; Ring buffer read index.
  129    F8:2314             	color_queue_w:	ds	1			; Ring buffer write index.
  130    F8:2315             	color_index:	ds	8			; Ring buffer - Palette index.
  131    F8:231D             	color_count:	ds	8			; Ring buffer - Palette count.
  132    F8:2325             	color_addr_l:	ds	8			; Ring buffer - Data Ptr (lo).
  133    F8:232D             	color_addr_h:	ds	8			; Ring buffer - Data Ptr (hi).
  134    F8:2335             	color_bank:	ds	8			; Ring buffer - Data Ptr (bank).
  135                        	
  136               E40A     			.code
  137                        	
  138                        	
  139                        	
  140                        	; ***************************************************************************
  141                        	; ***************************************************************************
  142                        	;
  143                        	; load_palettes - Queue a set of palettes to upload to the VCE next VBLANK.
  144                        	;
  145                        	; Args: _al = Palette index (0..15 for BG, 16..31 for SPR).
  146                        	; Args: _ah = Palette count (1..32).
  147                        	; Args: _bp = Pointer to palette data.
  148                        	; Args:   Y = Bank to map into MPR3 & MPR4, or zero to leave unchanged.
  149                        	;
  150                        	; N.B. Y==0 is only useful if the palette data is permanently mapped!
  151                        	;
  152                        	
  153                        	load_palettes	.proc
  179                        			.endp
  180                        	
  181                        	
  182                        	
  183                        	; ***************************************************************************
  184                        	; ***************************************************************************
  185                        	;
  186                        	; clear_vce - Clear all 512 of the VCE's palette entries.
  187                        	;
  188                        	
  189    01:CAB7             	clear_vce	.proc
  190                        	
  191    01:CAB7  08         			php				; Disable interrupts to avoid
  192    01:CAB8  78         			sei				; VBLANK palette upload.
  193    01:CAB9  C2         			cly
  194    01:CABA  9C 02 04   			stz	VCE_CTA+0		; Set VCE write address.
  195    01:CABD  9C 03 04   			stz	VCE_CTA+1
  196    01:CAC0  9C 04 04   	.loop:		stz	VCE_CTW+0		; Set lo-byte of color.
  197    01:CAC3  9C 05 04   			stz	VCE_CTW+1		; Write 1 color value.
  198    01:CAC6  9C 04 04   			stz	VCE_CTW+0		; Set lo-byte of color.
  199    01:CAC9  9C 05 04   			stz	VCE_CTW+1		; Write 1 color value.
  200    01:CACC  88         			dey
  201    01:CACD  D0 F1      			bne	.loop
  202    01:CACF  28         			plp
  203                        	
  204                        			leave				; All done, phew!
         01:CAD0  4C EF FF   			jmp	leave_proc
  205                        	
  206                        			.endp
  207                        	
  208               0001     		.ifdef	HUCC
  209    00:E40A             			.alias	_clear_palette		= clear_vce
  210                        		.endif
  211                        	
  212                        	
  213                        	
  214                        	; ***************************************************************************
  215                        	; ***************************************************************************
  216                        	;
  217                        	; read_palettes - Read palettes from the VCE into a buffer in RAM.
  218                        	;
  219                        	; Args: _al = Palette index (0..15 for BG, 16..31 for SPR).
  220                        	; Args: _ah = Palette count (1..32).
  221                        	; Args: _di = Pointer to palette data destination in RAM.
  222                        	;
  223                        	; The transfer is split into 32-byte chunks so that an HSYNC and/or TIMER
  224                        	; IRQ is not delayed for too long while executing.
  225                        	;
  226                        	
  227                        	read_palettes	.proc
  281                        			.endp
  282                        	
  283               0001     		.ifdef	HUCC
  284    00:E40A             			.alias	_read_palette.3		= read_palettes
  285                        		.endif
  286                        	
  287                        	
  288                        	
  289                        	vce_fade_funcs	.procgroup
  516                        			.endprocgroup
  517                        	
  518                        	
  519                        	
  520                        	; ***************************************************************************
  521                        	; ***************************************************************************
  522                        	;
  523                        	; cross_fade_to - Cross fade a palette in RAM towards a reference palette.
  524                        	;
  525                        	; Args: _al = Number of colors (1..256).
  526                        	; Args: _di = Pointer to faded palette destination in RAM.
  527                        	; Args: _bp = Pointer to reference palette data.
  528                        	; Args:   Y = Bank to map into MPR3 & MPR4, or zero to leave unchanged.
  529                        	;
  530                        	; N.B. Y==0 is only useful if the reference palette data is already mapped!
  531                        	;
  532                        	; N.B. This only updates the palette in RAM by 1 RGB step, so it will need
  533                        	;      to be called 7 times to guarantee that you've reached the target.
  534                        	;
  535                        	
  536                        	cross_fade_to	.proc
  658                        			.endp
                             #[2]   "..\..\..\include\hucc\hucc-final.asm"
                             #[3]   "..\..\..\include\hucc\vdc.asm"
   40                        			include	"vdc.asm"		; Useful VDC routines.
    1                        	; ***************************************************************************
    2                        	; ***************************************************************************
    3                        	;
    4                        	; vdc.asm
    5                        	;
    6                        	; Useful routines for operating the HuC6270 Video Display Controller.
    7                        	;
    8                        	; These should be located in permanently-accessible memory!
    9                        	;
   10                        	; Copyright John Brandwood 2021-2025.
   11                        	;
   12                        	; Distributed under the Boost Software License, Version 1.0.
   13                        	; (See accompanying file LICENSE_1_0.txt or copy at
   14                        	;  http://www.boost.org/LICENSE_1_0.txt)
   15                        	;
   16                        	; ***************************************************************************
   17                        	; ***************************************************************************
   18                        	
   19                        	;
   20                        	; Include dependancies ...
   21                        	;
   22                        	
   23                        			include "common.asm"		; Common helpers.
   24                        			include "vce.asm"		; Useful VCE routines.
   25                        	
   26                        	;
   27                        	; Choose how much to transfer to VRAM in a single chunk, normally 16-bytes.
   28                        	;
   29                        	; The cycle timings for a TIA-to-VRAM depend upon how the VDC's MWR CPU slots
   30                        	; line up to the CPU's writes, and how long the VDC has to halt the CPU while
   31                        	; it fetches the next scanline's sprite data.
   32                        	;
   33                        	; These cycle timings are for 0 sprites (best) and 16 sprites (worst) ...
   34                        	;
   35                        	; 32-byte TIA takes 270..364 cycles in 5MHz, 242..312 cycles in 7MHz. (8.44 cycles-per-byte best-case at 5MHz.)
   36                        	; 24-byte TIA takes 210..298 cycles in 5MHz, 186..256 cycles in 7MHz. (8.75 cycles-per-byte best-case at 5MHz.)
   37                        	; 16-byte TIA takes 142..234 cycles in 5MHz, 128..200 cycles in 7MHz. (8.88 cycles-per-byte best-case at 5MHz.)
   38                        	;
   39                        	; If a user wishes to be able to put RCR interrupts one-line-after-another,
   40                        	; then it is only safe to use 32-byte chunks if there are no TIMER or IRQ2
   41                        	; interrupts ... which is almost-impossible to rely on in library code!
   42                        	;
   43                        	
   44               0000     		.ifndef	VRAM_XFER_SIZE
   46                        		.endif
   47                        	
   48                        	;
   49                        	; Enable BG & SPR layers, and RCR interrupt.
   50                        	;
   51                        	
   52    00:E40A  A9 04      	set_rcron:	lda	#$04			; Enable RCR interrupt.
   53    00:E40C  80 0A      			bra	!+
   54                        	
   55    00:E40E  A9 80      	set_bgon:	lda	#$80			; Enable BG layer.
   56    00:E410  80 06      			bra	!+
   57                        	
   58    00:E412  A9 40      	set_spron:	lda	#$40			; Enable SPR layer.
   59    00:E414  80 02      			bra	!+
   60                        	
   61    00:E416  A9 C0      	set_dspon:	lda	#$C0			; Enable BG & SPR layers.
   62                        	
   63    00:E418  04 F3      	!:		tsb	<vdc_crl		; These take effect when
   64               0001     		.if	SUPPORT_SGX			; the next VBLANK occurs.
   65    00:E41A  04 03      			tsb	<sgx_crl
   66                        		.endif
   67    00:E41C  60         			rts
   68                        	
   69                        	;
   70                        	; Disable BG & SPR layers, and RCR interrupt.
   71                        	;
   72                        	
   73    00:E41D  A9 04      	set_rcroff:	lda	#$04			; Disable RCR interrupt.
   74    00:E41F  80 0A      			bra	!+
   75                        	
   76    00:E421  A9 80      	set_bgoff:	lda	#$80			; Disable BG layer.
   77    00:E423  80 06      			bra	!+
   78                        	
   79    00:E425  A9 40      	set_sproff:	lda	#$40			; Disable SPR layer.
   80    00:E427  80 02      			bra	!+
   81                        	
   82    00:E429  A9 C0      	set_dspoff:	lda	#$C0			; Disable BG & SPR layers.
   83                        	
   84    00:E42B  14 F3      	!:		trb	<vdc_crl		; These take effect when
   85               0001     		.if	SUPPORT_SGX			; the next VBLANK occurs.
   86    00:E42D  14 03      			trb	<sgx_crl
   87                        		.endif
   88    00:E42F  60         			rts
   89                        	
   90                        	
   91                        	
   92                        	; ***************************************************************************
   93                        	; ***************************************************************************
   94                        	;
   95                        	; Put the _di data pointer into the VDC's MARR or MAWR register.
   96                        	;
   97                        	; N.B. Library code relies on this preserving Y!
   98                        	;
   99                        	; Args: _di + 0 = BAT X coordinate.
  100                        	; Args: _di + 1 = BAT Y coordinate.
  101                        	;
  102                        	; Here because it relies on the "vdc_bat_width" that is defined in this file.
  103                        	;
  104                        	
  105               0001     		.if	SUPPORT_SGX
  106    00:E430  A2 10      	sgx_di_xy_marr:	ldx	#SGX_VDC_OFFSET		; Offset to SGX VDC.
  107    00:E432  F0         			db	$F0			; Turn "clx" into a "beq".
  108                        		.endif
  109                        	
  110    00:E433  82         	vdc_di_xy_marr:	clx				; Offset to PCE VDC.
  111                        	
  112    00:E434  62         	set_di_xy_mawr:	cla
  113    00:E435  3C 3D 23   			bit	vdc_bat_width, x	; Set by set_bat_size().
  114    00:E438  30 08      			bmi	.w128
  115    00:E43A  70 03      			bvs	.w64
  116    00:E43C  46 F1      	.w32:		lsr.h	<_di
  117    00:E43E  6A         			ror	a
  118    00:E43F  46 F1      	.w64:		lsr.h	<_di
  119    00:E441  6A         			ror	a
  120    00:E442  46 F1      	.w128:		lsr.h	<_di
  121    00:E444  6A         			ror	a
  122    00:E445  05 F0      			ora.l	<_di
  123    00:E447  85 F0      			sta.l	<_di
  124    00:E449  4C 7F E3   			jmp	set_di_to_mawr		; In "common.asm".
  125                        	
  126                        	
  127                        	
  128    01:C920             	vdc_clear_vram	.procgroup			; These routines share code!
  129                        	
  130                        	; ***************************************************************************
  131                        	; ***************************************************************************
  132                        	;
  133                        	; clear_vram_sgx - Clear all of VRAM in the SGX VDC.
  134                        	; clear_vram_vdc - Clear all of VRAM in the PCE VDC.
  135                        	;
  136                        	; Args: _ax = word value to write to the BAT.
  137                        	; Args: _bl = hi-byte of size of BAT (# of words).
  138                        	;
  139                        	
  140               0001     		.if	SUPPORT_SGX
  141    01:C920             	clear_vram_sgx	.proc
  142                        	
  143    01:C920  A2 10      			ldx	#SGX_VDC_OFFSET		; Offset to SGX VDC.
  144    01:C922  F0         			db	$F0			; Turn "clx" into a "beq".
  145                        	
  146    01:C923             			.ref	clear_vram_vdc		; Need clear_vram_vdc
  147                        			.endp
  148                        		.endif
  149                        	
  150    01:C923             	clear_vram_vdc	.proc
  151                        	
  152    01:C923  82         			clx				; Offset to PCE VDC.
  153                        	
  154    01:C924  20 B9 FE   	clear_vram_x:	call	clear_bat_x		; Clear the BAT.
  155                        	
  156    01:C927  A9 80      			lda	#$80			; Xvert hi-byte of # words
  157    01:C929  38         			sec				; in screen to loop count.
  158    01:C92A  E5 FA      			sbc	<_bl
  159    01:C92C  4A         			lsr	a
  160                        	
  161                        	;		cly				; Clear the rest of VRAM.
  162    01:C92D  9E 02 02   			stz	VDC_DL, x
  163    01:C930  9E 03 02   	.clr_loop:	stz	VDC_DH, x		; Seperate writes to minimize
  164    01:C933  88         			dey				; VDC MWR penalty.
  165    01:C934  9E 03 02   			stz	VDC_DH, x
  166    01:C937  D0 F7      			bne	.clr_loop
  167    01:C939  3A         			dec	a
  168    01:C93A  D0 F4      			bne	.clr_loop
  169                        	
  170                        			leave				; All done, phew!
         01:C93C  4C EF FF   			jmp	leave_proc
  171                        	
  172                        			.endp
  173                        	
  174                        	
  175                        	
  176                        	; ***************************************************************************
  177                        	; ***************************************************************************
  178                        	;
  179                        	; clear_bat_sgx - Clear the BAT in the SGX VDC.
  180                        	; clear_bat_vdc - Clear the BAT in the PCE VDC.
  181                        	;
  182                        	; Args: _ax = word value to write to the BAT.
  183                        	; Args: _bl = hi-byte of size of BAT (# of words).
  184                        	;
  185                        	
  186               0001     		.if	SUPPORT_SGX
  187                        	clear_bat_sgx	.proc
  193                        			.endp
  194                        		.endif
  195                        	
  196    01:C93F             	clear_bat_vdc	.proc
  197                        	
  198    01:C93F  82         			clx				; Offset to PCE VDC.
  199                        	
  200    01:C940             			.ref	clear_bat_x		; Need clear_bat_x
  201                        			.endp
  202                        	
  203    01:C940             	clear_bat_x	.proc				; HuCC uses this entry point.
  204                        	
  205    01:C940  64 F0      			stz	<_di + 0		; Set VDC or SGX destination
  206    01:C942  64 F1      			stz	<_di + 1		; address.
  207    01:C944  20 7F E3   			jsr	set_di_to_mawr
  208                        	
  209    01:C947  A5 FA      			lda	<_bl			; Xvert hi-byte of # words
  210    01:C949  4A         			lsr	a			; in screen to loop count.
  211                        	
  212    01:C94A  C2         			cly
  213    01:C94B  48         	.bat_loop:	pha
  214    01:C94C  A5 F8      			lda	<_ax + 0
  215    01:C94E  9D 02 02   			sta	VDC_DL, x
  216    01:C951  A5 F9      			lda	<_ax + 1
  217    01:C953  9D 03 02   	.bat_pair:	sta	VDC_DH, x		; Seperate writes to minimize
  218    01:C956  88         			dey				; VDC MWR penalty.
  219    01:C957  9D 03 02   			sta	VDC_DH, x
  220    01:C95A  D0 F7      			bne	.bat_pair
  221                        	
  222    01:C95C  68         			pla
  223    01:C95D  3A         			dec	a
  224    01:C95E  D0 EB      			bne	.bat_loop
  225                        	
  226                        			leave
         01:C960  4C EF FF   			jmp	leave_proc
  227                        	
  228                        			.endp
  229                        	
  230                        			.endprocgroup
  231                        	
  232                        	;
  233                        	;
  234                        	;
  235                        	
  236    01:C2D2             	vdc_set_mode	.procgroup			; These routines share code!
  237                        	
  238                        	; ***************************************************************************
  239                        	; ***************************************************************************
  240                        	;
  241                        	; set_mode_sgx - Set video hardware registers from a data table.
  242                        	; set_mode_vdc - Set video hardware registers from a data table.
  243                        	;
  244                        	; Args: _bp, Y = _farptr to data table mapped into MPR3 & MPR4.
  245                        	;
  246                        	
  247               0001     		.if	SUPPORT_SGX
  248    01:C2D2             	set_mode_sgx	.proc
  249                        	
  250    01:C2D2  A2 10      			ldx	#SGX_VDC_OFFSET		; Offset to SGX VDC.
  251    01:C2D4  F0         			db	$F0			; Turn "clx" into a "beq".
  252                        	
  253                        			.endp
  254                        		.endif
  255                        	
  256    01:C2D5             	set_mode_vdc	.proc
  257                        	
  258    01:C2D5  82         			clx				; Offset to PCE VDC.
  259                        	
  260    01:C2D6  F7 F8      			smb7	<_al			; Signal no set_bat_size() yet.
  261                        	
  262    01:C2D8  43 08      			tma3				; Preserve MPR3.
  263    01:C2DA  48         			pha
  264    01:C2DB  43 10      			tma4				; Preserve MPR4.
  265    01:C2DD  48         			pha
  266                        	
  267    01:C2DE  20 3B E3   			jsr	map_bp_to_mpr34		; Map data to MPR3 & MPR4.
  268                        	
  269    01:C2E1  08         			php				; Disable interrupts.
  270    01:C2E2  78         			sei
  271                        	
  272    01:C2E3  C2         			cly				; Table size is < 256 bytes.
  273                        	
  274    01:C2E4  B1 EC      	.loop:		lda	[_bp], y		; Get the register #, +ve for
  275    01:C2E6  F0 46      			beq	.done			; VDC, -128 for VCE_CR.
  276    01:C2E8  10 0C      			bpl	.set_vdc_reg
  277                        	
  278                        			; Set the VCE_CR register.
  279                        	
  280    01:C2EA  C8         	.set_vce_cr:	iny
  281                        	
  282    01:C2EB  B1 EC      			lda	[_bp], y		; Get lo-byte of register.
  283    01:C2ED  C8         			iny
  284    01:C2EE  8D 44 22   			sta	vce_cr			; No SGX shadow for this!
  285    01:C2F1  8D 00 04   			sta	VCE_CR			; Set the VCE clock speed.
  286    01:C2F4  80 EE      			bra	.loop			; Do not set VDC_MWR reg bits!
  287                        	
  288                        			; Set a VDC register.
  289                        	
  290    01:C2F6  C8         	.set_vdc_reg:	iny
  291    01:C2F7  9D 00 02   			sta	VDC_AR, x		; Set which VDC register.
  292                        	
  293    01:C2FA  C9 05      			cmp	#VDC_CR			; CS if VDC_CR or higher.
  294    01:C2FC  F0 14      			beq	.skip_cc
  295    01:C2FE  18         			clc				; CC if not VDC_CR.
  296                        	
  297    01:C2FF  49 09      			eor	#VDC_MWR		; Check if this the VDC_MWR
  298    01:C301  D0 0F      			bne	.skip_cc		; without changing CC.
  299                        	
  300    01:C303  B1 EC      			lda	[_bp], y		; Remember the BAT size so that
  301    01:C305  8D 42 22   			sta	vdc_mwr			; set_bat_size() can be called.
  302    01:C308  4A         			lsr	a
  303    01:C309  4A         			lsr	a
  304    01:C30A  4A         			lsr	a
  305    01:C30B  4A         			lsr	a
  306    01:C30C  85 F8      			sta	<_al
  307    01:C30E  C8         			iny
  308    01:C30F  C8         			iny
  309    01:C310  80 D2      			bra	.loop
  310                        	
  311    01:C312  B1 EC      	.skip_cc:	lda	[_bp], y		; Get lo-byte of register.
  312    01:C314  C8         			iny
  313    01:C315  90 08      			bcc	.not_vdc_cr
  314                        	
  315               0001     		.if	SUPPORT_SGX
  316    01:C317  E0 00      			cpx	#0			; Writing to the VDC or SGX?
  317    01:C319  F0 02      			beq	.save_crl
  318    01:C31B  29 F7      			and	#$F7			; We only need 1 vblank IRQ!
  319                        		.endif
  320                        	
  321    01:C31D  95 F3      	.save_crl:	sta	<vdc_crl, x		; Save VDC_CR shadow register.
  322                        	
  323    01:C31F  9D 02 02   	.not_vdc_cr:	sta	VDC_DL, x		; Write to VDC.
  324                        	
  325    01:C322  B1 EC      			lda	[_bp], y		; Get hi-byte of register.
  326    01:C324  C8         			iny
  327    01:C325  9D 03 02   			sta	VDC_DH, x
  328    01:C328  90 BA      			bcc	.loop			; Next register, please!
  329                        	
  330    01:C32A  95 F4      			sta	<vdc_crh, x		; Save VDC_CR shadow register.
  331                        	
  332    01:C32C  80 B6      			bra	.loop			; Next register, please!
  333                        	
  334                        			; All registers set!
  335                        	
  336    01:C32E  A9 02      	.done:		lda	#VDC_VWR		; Leave with VDC_VWR set.
  337    01:C330  95 F7      			sta	<vdc_reg, x
  338                        	;		lda	<vdc_reg, x		; Restore previous VDC_AR from
  339    01:C332  9D 00 02   			sta	VDC_AR, x		; the shadow variable.
  340                        	
  341    01:C335  28         			plp				; Restore interrupts.
  342                        	
  343    01:C336  68         			pla				; Restore MPR4.
  344    01:C337  53 10      			tam4
  345    01:C339  68         			pla				; Restore MPR3.
  346    01:C33A  53 08      			tam3
  347                        	
  348    01:C33C  7F F8 07   			bbr7	<_al, set_bat_size	; Update if BAT size changed.
  349                        	
  350                        			leave				; All done, phew!
         01:C33F  4C EF FF   			jmp	leave_proc
  351                        	
  352    01:C342             			.ref	set_bat_vdc
  353                        			.endp
  354                        	
  355                        	
  356                        	
  357                        	; ***************************************************************************
  358                        	; ***************************************************************************
  359                        	;
  360                        	; set_bat_sgx - Change the SGX BAT size and initialize variables based on it.
  361                        	; set_bat_vdc - Change the PCE BAT size and initialize variables based on it.
  362                        	;
  363                        	; Args: _al = new size (0-7).
  364                        	;
  365                        	; (VDC_MWR_32x32  >> 4) or in HuCC, SCR_SIZE_32x32.
  366                        	; (VDC_MWR_32x64  >> 4) or in HuCC, SCR_SIZE_32x64.
  367                        	; (VDC_MWR_64x32  >> 4) or in HuCC, SCR_SIZE_64x32.
  368                        	; (VDC_MWR_64x64  >> 4) or in HuCC, SCR_SIZE_64x64.
  369                        	; (VDC_MWR_128x32 >> 4) or in HuCC, SCR_SIZE_128x32.
  370                        	; (VDC_MWR_128x64 >> 4) or in HuCC, SCR_SIZE_128x64.
  371                        	;
  372                        	
  373               0001     		.if	SUPPORT_SGX
  374    01:C342             	set_bat_sgx	.proc
  375                        	
  376    01:C342  A2 10      			ldx	#SGX_VDC_OFFSET		; Offset to SGX VDC.
  377    01:C344  F0         			db	$F0			; Turn "clx" into a "beq".
  378                        	
  379    01:C345             			.ref	set_bat_vdc
  380                        			.endp
  381                        		.endif
  382                        	
  383    01:C345             	set_bat_vdc	.proc
  384                        	
  385    01:C345  82         			clx				; Offset to PCE VDC.
  386                        	
  387    01:C346  A5 F8      	set_bat_size:	lda	<_al			; Get BAT size value.
  388    01:C348  29 07      			and	#7			; Sanitize screen size value.
  389    01:C34A  A8         			tay
  390    01:C34B  0A         			asl	a			; Put it in bits 4..6.
  391    01:C34C  0A         			asl	a
  392    01:C34D  0A         			asl	a
  393    01:C34E  0A         			asl	a
  394    01:C34F  85 00      			sta	<__temp
  395                        	
  396    01:C351  B9 91 C3   			lda	.width, y
  397    01:C354  9D 3D 23   			sta	vdc_bat_width, x
  398    01:C357  3A         			dec	a
  399    01:C358  9D 3F 23   			sta	vdc_bat_x_mask, x
  400                        	
  401    01:C35B  B9 99 C3   			lda	.height, y
  402    01:C35E  9D 3E 23   			sta	vdc_bat_height, x
  403    01:C361  3A         			dec	a
  404    01:C362  9D 40 23   			sta	vdc_bat_y_mask, x
  405                        	
  406    01:C365  B9 A1 C3   			lda	.limit, y
  407    01:C368  9D 41 23   			sta	vdc_bat_limit, x
  408                        	
  409    01:C36B  B9 A9 C3   			lda	.increment, y		; Put the VRAM increment for a
  410    01:C36E  95 F4      			sta	<vdc_crh, x		; line into vdc_crh for later.
  411                        	
  412    01:C370  08         			php
  413    01:C371  78         			sei
  414                        	
  415    01:C372  A9 09      			lda	#VDC_MWR
  416    01:C374  9D 00 02   			sta	VDC_AR, x
  417                        	
  418    01:C377  AD 42 22   			lda	vdc_mwr			; Get the MWR access width bits.
  419    01:C37A  29 8F      			and	#%10001111
  420    01:C37C  05 00      			ora	<__temp
  421               0001     		.if	SUPPORT_SGX
  422    01:C37E  E0 00      			cpx	#PCE_VDC_OFFSET		; This has no SGX shadow!
  423    01:C380  D0 03      			bne	!+
  424                        		.endif
  425    01:C382  8D 42 22   			sta	vdc_mwr
  426    01:C385  9D 02 02   	!:		sta	VDC_DL, x
  427                        	
  428    01:C388  B5 F7      			lda	<vdc_reg, x		; Restore previous VDC_AR from
  429    01:C38A  9D 00 02   			sta	VDC_AR, x		; the shadow variable.
  430                        	
  431    01:C38D  28         			plp
  432                        	
  433                        			leave
         01:C38E  4C EF FF   			jmp	leave_proc
  434                        	
  435    01:C391  20 40 80 80	.width:		db	$20,$40,$80,$80,$20,$40,$80,$80
         01:C395  20 40 80 80 
  436    01:C399  20 20 20 20	.height:	db	$20,$20,$20,$20,$40,$40,$40,$40
         01:C39D  40 40 40 40 
  437    01:C3A1  03 07 0F 0F	.limit:		db	$03,$07,$0F,$0F,$07,$0F,$1F,$1F
         01:C3A5  07 0F 1F 1F 
  438    01:C3A9  08 10 18 18	.increment	db	$08,$10,$18,$18,$08,$10,$18,$18
         01:C3AD  08 10 18 18 
  439                        	
  440               233D     			.bss
  441                        	
  442                        	; **************
  443                        	; 16-bytes of VDC BAT information.
  444                        	;
  445                        	; N.B. MUST be 16-bytes before the SGX versions to use PCE_VDC_OFFSET.
  446                        	;
  447                        	; N.B. Declared inside this .proc so that they can be stripped if unused.
  448                        	
  449                        	; Initialized by set_bat_vdc.
  450    F8:233D             	vdc_bat_width:	ds	1	; $20, $40, $80
  451    F8:233E             	vdc_bat_height:	ds	1	; $20, $40
  452    F8:233F             	vdc_bat_x_mask:	ds	1	; $1F, $3F, $7F
  453    F8:2340             	vdc_bat_y_mask:	ds	1	; $1F, $3F
  454    F8:2341             	vdc_bat_limit:	ds	1	; (>$03FF), (>$07FF), (>$0FFF), (>$1FFF)
  455                        	
  456                        	; From blkmap.asm just to avoid wasting .bss space with padding.
  457    F8:2342             	vdc_map_draw_w:	ds	1	; (SCR_WIDTH / 8) + 1
  458    F8:2343             	vdc_map_draw_h:	ds	1	; (SCR_HEIGHT / 8) + 1
  459    F8:2344             	vdc_map_line_w:	ds	1	; Line width of map data in tiles.
  460    F8:2345             	vdc_map_scrn_w:	ds	1	; Line width of map data in screens.
  461    F8:2346             	vdc_map_pxl_x:	ds	2	; Current top-left X in pixels.
  462    F8:2348             	vdc_map_pxl_y:	ds	2	; Current top-left Y in pixels.
  463    F8:234A             	vdc_map_option:	ds	1	; Flags to disable BAT alignment.
  464                        	
  465                        	; From hucc-old-spr.asm just to avoid wasting .bss space with padding.
  466    F8:234B             	spr_max:	ds	1
  467    F8:234C             	spr_clr:	ds	1
  468                        	
  469               0001     		.if	SUPPORT_SGX
  470                        	
  471                        	; **************
  472                        	; 16-bytes of SGX BAT information.
  473                        	;
  474                        	; N.B. MUST be 16-bytes after the VDC versions to use SGX_VDC_OFFSET.
  475                        	;
  476                        	; N.B. Declared inside this .proc so that they can be stripped if unused.
  477                        	
  478                        	; Initialized by set_bat_sgx.
  479    F8:234D             	sgx_bat_width:	ds	1	; $20, $40, $80
  480    F8:234E             	sgx_bat_height:	ds	1	; $20, $40
  481    F8:234F             	sgx_bat_x_mask:	ds	1	; $1F, $3F, $7F
  482    F8:2350             	sgx_bat_y_mask:	ds	1	; $1F, $3F
  483    F8:2351             	sgx_bat_limit:	ds	1	; (>$03FF), (>$07FF), (>$0FFF), (>$1FFF)
  484                        	
  485                        	; From blkmap.asm just to avoid wasting .bss space with padding.
  486    F8:2352             	sgx_map_draw_w:	ds	1	; (SCR_WIDTH / 8) + 1
  487    F8:2353             	sgx_map_draw_h:	ds	1	; (SCR_HEIGHT / 8) + 1
  488    F8:2354             	sgx_map_line_w:	ds	1	; Line width of map data in tiles.
  489    F8:2355             	sgx_map_scrn_w:	ds	1	; Line width of map data in screens.
  490    F8:2356             	sgx_map_pxl_x:	ds	2	; Current top-left X in pixels.
  491    F8:2358             	sgx_map_pxl_y:	ds	2	; Current top-left Y in pixels.
  492    F8:235A             	sgx_map_option:	ds	1	; Flags to disable BAT alignment.
  493                        	
  494                        	; From hucc-old-spr.asm just to avoid wasting .bss space with padding.
  495    F8:235B             	sgx_spr_max:	ds	1
  496    F8:235C             	sgx_spr_clr:	ds	1
  497                        	
  498                        		.endif
  499                        	
  500               C3B1     			.code
  501                        	
  502                        			.endp
  503                        	
  504                        			.endprocgroup
  505                        	
  506                        	
  507                        	
  508                        	; ***************************************************************************
  509                        	; ***************************************************************************
  510                        	;
  511                        	; sgx_detect - Detect whether we're running on a SuperGrafx (and init VPC).
  512                        	;
  513                        	; Returns: X,C-flag, and "sgx_detected" = NZ, CS if detected.
  514                        	;
  515                        	; ***************************************************************************
  516                        	;
  517                        	; https://web.archive.org/web/20161129055659/http://cgfm2.emuviews.com/txt/sgxtech.txt
  518                        	;
  519                        	; ***************************************************************************
  520                        	;
  521                        	; HuC6202 VIDEO PRIORITY CONTROLLER (huge thanks to Charles MacDonald!)
  522                        	;
  523                        	; The VPC has no access to sprite priority data, it can only sort pixels
  524                        	; based upon which VDC and whether they are "sprite" or "background".
  525                        	;
  526                        	; This can sometimes lead to unexpected results with low-priority sprites.
  527                        	;
  528                        	; VPC registers $0008 and $0009 make up four 4-bit values that define the
  529                        	; enabled layers and priority setting for the four possible window areas.
  530                        	;
  531                        	; Bits 3-0 of $0008 are for the region where Window 1 and 2 overlap
  532                        	; Bits 7-4 of $0008 are for the region occupied by only Window 2
  533                        	; Bits 3-0 of $0009 are for the region occupied by only Window 1
  534                        	; Bits 7-4 of $0009 are for the region where no Window is present
  535                        	;
  536                        	;  Each 4-bit value has the same format:
  537                        	;
  538                        	;  Bit 0: VDC #1 graphics are 0=disabled, 1=enabled
  539                        	;  Bit 1: VDC #2 graphics are 0=disabled, 1=enabled
  540                        	;  Bit 2: Bit 0 of priority setting
  541                        	;  Bit 3: Bit 1 of priority setting
  542                        	;
  543                        	;   Priority Setting 0b00xx: (useful when VDC #1 is a fullscreen HUD)
  544                        	;
  545                        	;    FRONT
  546                        	;     SP1 = VDC #1 (pce) sprite pixels
  547                        	;     BG1 = VDC #1 (pce) background pixels
  548                        	;     SP2 = VDC #2 (sgx) sprite pixels
  549                        	;     BG2 = VDC #2 (sgx) background pixels
  550                        	;    BACK
  551                        	;
  552                        	;   Priority Setting 0b01xx: (useful for parallax backgrounds)
  553                        	;
  554                        	;    FRONT
  555                        	;     SP1 = VDC #1 (pce) sprite pixels
  556                        	;     SP2 = VDC #2 (sgx) sprite pixels
  557                        	;     BG1 = VDC #1 (pce) background pixels
  558                        	;     BG2 = VDC #2 (sgx) background pixels
  559                        	;    BACK
  560                        	;
  561                        	;   Priority Setting 0b10xx: (only useful for special effects)
  562                        	;
  563                        	;    FRONT
  564                        	;     BG1 = VDC #1 (pce) background pixels (transparent where sprites)
  565                        	;     BG2 = VDC #2 (sgx) background pixels
  566                        	;     SP1 = VDC #1 (pce) sprite pixels
  567                        	;     SP2 = VDC #2 (sgx) sprite pixels
  568                        	;    BACK
  569                        	
  570               0001     		.if	SUPPORT_SGX
  571               0001     		.if	1
  572    01:C963             	sgx_detect	.proc
  573                        	
  574    01:C963  A0 7F      			ldy	#$7F			; Use VRAM address $7F7F
  575    01:C965  84 F0      			sty.l	<_di			; because it won't cause
  576    01:C967  84 F1      			sty.h	<_di			; a screen glitch.
  577                        	
  578    01:C969  20 7B E3   			jsr	sgx_di_to_mawr		; Write $0001 to SGX VRAM.
  579    01:C96C  A0 01      			ldy	#$01
  580    01:C96E  8C 12 02   			sty	SGX_DL
  581    01:C971  9C 13 02   			stz	SGX_DH
  582                        	
  583    01:C974  20 7E E3   			jsr	vdc_di_to_mawr		; Write $0000 to VDC VRAM.
  584    01:C977  9C 02 02   			stz	VDC_DL
  585    01:C97A  9C 03 02   			stz	VDC_DH
  586                        	
  587    01:C97D  20 6E E3   			jsr	sgx_di_to_marr		; Check value in SGX VRAM.
  588    01:C980  AC 12 02   			ldy	SGX_DL			; $01 if found, $00 if not.
  589    01:C983  8C E8 22   			sty	sgx_detected
  590    01:C986  F0 10      			beq	!+			; Skip the rest if not SGX.
  591                        	
  592    01:C988  20 7B E3   			jsr	sgx_di_to_mawr		; Write $0000 to SGX VRAM
  593    01:C98B  9C 12 02   			stz	SGX_DL			; to clean VRAM contents.
  594    01:C98E  9C 13 02   			stz	SGX_DH
  595                        	
  596    01:C991  73 9E C9 08			tii	.vpc_mode, VPC_CR, 8	; Initialize the HuC6202 VPC.
         01:C995  02 08 00    
  597                        	
  598    01:C998  98         	!:		tya
  599    01:C999  AA         			tax				; "leave" copies X back to A.
  600    01:C99A  4A         			lsr	a			; Also CC if PCE, CS if SGX.
  601                        	
  602                        			leave				; All done, phew!
         01:C99B  4C EF FF   			jmp	leave_proc
  603                        		.else
  618                        		.endif
  619                        	
  620               0000     		.ifndef	SGX_PARALLAX
  622                        		.endif
  623                        	
  624               0001     		.if	SGX_PARALLAX
  625    01:C99E  00 70      	.vpc_mode:	dw	$7000			; Use SGX as a parallax layer
  626    01:C9A0  00 00      			dw	$0000			; behind a VDC background.
  627    01:C9A2  00 00      			dw	$0000
  628    01:C9A4  00 00      			dw	$0000
  629                        		.else
  634                        		.endif	SGX_PARALLAX
  635                        	
  636                        			.endp
  637                        	
  638               0000     		.ifndef	CORE_VERSION			; CORE has this in the kernel.
  642                        		.endif	CORE_VERSION
  643                        	
  644                        		.endif	SUPPORT_SGX
  645                        	
  646                        	
  647                        	
  648                        	
  649                        	vdc_copy_to	.procgroup			; These routines share code!
  799                        			.endprocgroup
  800                        	
  801                        	
  802                        	
  803                        	; ***************************************************************************
  804                        	; ***************************************************************************
  805                        	;
  806                        	; init_240x208 - An example of initializing screen and VRAM.
  807                        	;
  808                        	; This can be used as-is, or copied to your own program and modified.
  809                        	;
  810                        	
  811                        	init_240x208	.proc
  892                        			.endp
  893                        	
  894                        	
  895                        	
  896                        	; ***************************************************************************
  897                        	; ***************************************************************************
  898                        	;
  899                        	; init_256x224 - An example of initializing screen and VRAM.
  900                        	;
  901                        	; This can be used as-is, or copied to your own program and modified.
  902                        	;
  903                        	
  904                        	init_256x224	.proc
  985                        			.endp
  986                        	
  987                        	
  988                        	
  989                        	; ***************************************************************************
  990                        	; ***************************************************************************
  991                        	;
  992                        	; init_352x224 - An example of initializing screen and VRAM.
  993                        	;
  994                        	; This can be used as-is, or copied to your own program and modified.
  995                        	;
  996                        	
  997                        	init_352x224	.proc
 1078                        			.endp
 1079                        	
 1080                        	
 1081                        	
 1082                        	; ***************************************************************************
 1083                        	; ***************************************************************************
 1084                        	;
 1085                        	; init_512x224 - An example of initializing screen and VRAM.
 1086                        	;
 1087                        	; This can be used as-is, or copied to your own program and modified.
 1088                        	;
 1089                        	
 1090                        	init_512x224	.proc
 1171                        			.endp
 1172                        	
 1173                        	
 1174                        	
 1175                        	; ***************************************************************************
 1176                        	; ***************************************************************************
 1177                        	;
 1178                        	; init_320x208 - An example of initializing screen and VRAM.
 1179                        	;
 1180                        	; This can be used as-is, or copied to your own program and modified.
 1181                        	;
 1182                        	; This resolution is rarely-seen, but it has no overscan, so it has a use.
 1183                        	;
 1184                        	
 1185                        	init_320x208	.proc
 1266                        			.endp
                             #[2]   "..\..\..\include\hucc\hucc-final.asm"
   41                        	
                             #[3]   "..\..\..\include\hucc\hucc-math.asm"
   42                        			include	"hucc-math.asm"		; HuCC multiply and divide.
    1                        	; ***************************************************************************
    2                        	; ***************************************************************************
    3                        	;
    4                        	; hucc-math.asm
    5                        	;
    6                        	; Basic (i.e. very slow) 8-bit and 16-bit multiply and divide routines.
    7                        	;
    8                        	; Copyright John Brandwood 2021-2024.
    9                        	;
   10                        	; Distributed under the Boost Software License, Version 1.0.
   11                        	; (See accompanying file LICENSE_1_0.txt or copy at
   12                        	;  http://www.boost.org/LICENSE_1_0.txt)
   13                        	;
   14                        	; ***************************************************************************
   15                        	; ***************************************************************************
   16                        	;
   17                        	; This is basically a set of SDCC-compatible routines, but using Y:A for the
   18                        	; primary register instead of X:A.
   19                        	;
   20                        	; Using Y:A makes the routines instantly usable with HuCC, and it also makes
   21                        	; them usable with SDCC with just an "sxy" before and after the call.
   22                        	;
   23                        	; ***************************************************************************
   24                        	; ***************************************************************************
   25                        	
   26               E44C     			.code
   27                        	
   28               2000     	multiplier	=	__temp
   29               2094     	multiplicand	=	___SDCC_m6502_ret0
   30               2094     	product		=	multiplicand
   31                        	
   32               2000     	__mulint_PARM_2	=	multiplier
   33                        	
   34               2000     	divisor		=	__temp
   35               2094     	dividend	=	___SDCC_m6502_ret0
   36               2094     	quotient	=	dividend
   37               2096     	remainder	=	___SDCC_m6502_ret2
   38                        	
   39               2000     	__moduint_PARM_2 =	divisor
   40               2000     	__modsint_PARM_2 =	divisor
   41               2000     	__divuint_PARM_2 =	divisor
   42               2000     	__divsint_PARM_2 =	divisor
   43                        	
   44                        	
   45                        	
   46                        	; ***************************************************************************
   47                        	; int
   48                        	; _mulint (int a, int b)
   49                        	;
   50                        	; 1st parameter in Y:A (multiplicand)
   51                        	; 2nd parameter in __mulint_PARM_2 (multiplier)
   52                        	; result in Y:A
   53                        	;
   54                        	; N.B. signed and unsigned multiply only differ in the top 16 of the 32bits!
   55                        	
   56    00:E44C  85 94      	__mulint:	sta	<multiplicand + 0
   57    00:E44E  84 95      			sty	<multiplicand + 1
   58                        	
   59    00:E450  A2 10      			ldx	#16			; Loop 16 times.
   60                        	
   61    00:E452  46 95      			lsr	<multiplicand + 1	; Divide multiplicand by 2
   62    00:E454  66 94      			ror	<multiplicand + 0	; and clear the 16th bit.
   63                        	
   64    00:E456  62         			cla				; Clear top word of product.
   65    00:E457  85 96      			sta.l	<multiplicand + 2
   66    00:E459  90 0B      			bcc	.rotate
   67                        	
   68    00:E45B  A8         	.add:		tay				; Add the 16-bit multiplier to
   69    00:E45C  18         			clc				; top 16-bits of the product.
   70    00:E45D  A5 96      			lda	<multiplicand + 2
   71    00:E45F  65 00      			adc.l	<multiplier
   72    00:E461  85 96      			sta	<multiplicand + 2
   73    00:E463  98         			tya
   74    00:E464  65 01      			adc.h	<multiplier
   75                        	
   76    00:E466  6A         	.rotate:	ror	a			; Rotate product into the top
   77    00:E467  66 96      			ror	<multiplicand + 2	; bits of the multiplicand ...
   78    00:E469  66 95      			ror	<multiplicand + 1	; and divide multiplicand by 2.
   79    00:E46B  66 94      			ror	<multiplicand + 0
   80                        	
   81    00:E46D  CA         			dex
   82    00:E46E  B0 EB      			bcs	.add			; Add multiplier to top word?
   83    00:E470  D0 F4      			bne	.rotate			; Completed 16 bits?
   84                        	
   85    00:E472  85 97      			sta	<multiplicand + 3	; Save top byte of product.
   86                        	
   87    00:E474  A5 94      			lda.l	<multiplicand		; Return the bottom 16-bits of
   88    00:E476  A4 95      			ldy.h	<multiplicand		; the 32-bit product.
   89                        	
   90    00:E478  60         			rts
   91                        	
   92                        	
   93                        	
   94                        	; ***************************************************************************
   95                        	; unsigned int
   96                        	; _divuint (unsigned int x, unsigned int y)
   97                        	;
   98                        	; 1st parameter in Y:A (unsigned dividend)
   99                        	; 2nd parameter in __divuint_PARM_2 (unsigned divisor)
  100                        	; result in Y:A
  101                        	
  102    00:E479  20 81 E4   	__divuint:	jsr	__moduint		; Call the basic uint division.
  103                        	
  104    00:E47C  A5 94      			lda.l	<quotient		; Then get the result from where
  105    00:E47E  A4 95      			ldy.h	<quotient		; it was calculated.
  106    00:E480  60         			rts
  107                        	
  108                        	
  109                        	
  110                        	; ***************************************************************************
  111                        	; unsigned int
  112                        	; _moduint (unsigned int x, unsigned int y)
  113                        	;
  114                        	; 1st parameter in Y:A (unsigned dividend)
  115                        	; 2nd parameter in __moduint_PARM_2 (unsigned divisor)
  116                        	; result in Y:A
  117                        	;
  118                        	; If the dividend has more bits than the divisor, then we need to check the
  119                        	; 17th bit of the remainder!
  120                        	
  121               0000     		.if	0
  176                        		.else
  177                        	
  178    00:E481  85 94      	__moduint:	sta.l	<dividend		; 1st SDCC parameter in Y:A.
  179    00:E483  84 95      			sty.h	<dividend
  180                        	
  181    00:E485  A5 00      	divmoduint:	lda.l	<divisor		; Check for a divide-by-zero.
  182    00:E487  05 01      			ora.h	<divisor
  183    00:E489  F0 FE      	.zero:		beq	.zero
  184                        	
  185    00:E48B  A2 11      			ldx	#16 + 1
  186                        	
  187    00:E48D  C2         			cly				; Clear remainder.
  188    00:E48E  84 97      			sty.h	<remainder
  189                        	
  190    00:E490  98         	.skip:		tya				; Restore remainder lo-byte.
  191                        	
  192    00:E491  26 94      	.loop:		rol.l	<dividend		; Quotient bit -> dividend LSB.
  193    00:E493  26 95      			rol.h	<dividend		; Rotate dividend, MSB -> C.
  194                        	
  195    00:E495  CA         			dex
  196    00:E496  F0 14      			beq	.finished
  197                        	
  198    00:E498  2A         			rol	a			; Rotate C into remainder.
  199    00:E499  26 97      			rol.h	<remainder
  200                        	;		php				; Preserve remainder 17th bit.
  201                        	
  202    00:E49B  A8         			tay				; Preserve remainder lo-byte.
  203                        	
  204    00:E49C  C5 00      			cmp.l	<divisor		; Test divisor.
  205    00:E49E  A5 97      			lda.h	<remainder
  206    00:E4A0  E5 01      			sbc.h	<divisor
  207    00:E4A2  90 EC      			bcc	.skip			; CC if divisor > remainder.
  208                        	
  209                        	;		cmp.l	<divisor		; If the dividend has more bits
  210                        	;		lda.h	<remainder		; than the divisor then we need
  211                        	;		sbc.h	<divisor		; to check the remainder hi-bit.
  212                        	;		bcs	.subtract		; CS if divisor <= remainder.
  213                        	;		plp				; Restore remainder 17th bit.
  214                        	;		bcc	.skip			; CC if divisor > remainder.
  215                        	;		db	$90			; Turn "plp" into "bcc" to skip.
  216                        	;.subtract:	plp				; Discard remainder 17th bit.
  217                        	;		sec
  218                        	
  219    00:E4A4  85 97      			sta.h	<remainder		; Subtract divisor.
  220    00:E4A6  98         			tya
  221    00:E4A7  E5 00      			sbc.l	<divisor
  222    00:E4A9  38         			sec				
  223    00:E4AA  80 E5      			bra	.loop
  224                        	
  225    00:E4AC  A4 97      	.finished:	ldy.h	<remainder		; Get the remainder hi-byte.
  226                        	
  227    00:E4AE  60         			rts
  228                        	
  229                        		.endif
  230                        	
  231                        	
  232                        	
  233                        	; ***************************************************************************
  234                        	; int
  235                        	; _divsint (int x, int y)
  236                        	;
  237                        	; 1st parameter in Y:A (signed dividend)
  238                        	; 2nd parameter in __divsint_PARM_2 (signed divisor)
  239                        	; result in Y:A
  240                        	
  241    00:E4AF  20 B7 E4   	__divsint:	jsr	__modsint		; Call the basic sint division.
  242                        	
  243    00:E4B2  A5 94      			lda.l	<quotient		; Then get the result from where
  244    00:E4B4  A4 95      			ldy.h	<quotient		; it was calculated.
  245    00:E4B6  60         			rts
  246                        	
  247                        	
  248                        	
  249                        	; ***************************************************************************
  250                        	; int
  251                        	; _modsint (int x, int y)
  252                        	;
  253                        	; 1st parameter in Y:A (signed dividend)
  254                        	; 2nd parameter in __modsint_PARM_2 (signed divisor)
  255                        	; result in Y:A
  256                        	
  257    00:E4B7  84 95      	__modsint:	sty.h	<dividend
  258                        	
  259    00:E4B9  C0 80      			cpy	#$80			; Remainder -ve if dividend
  260    00:E4BB  08         			php				; was -ve.
  261    00:E4BC  90 03      			bcc	!+
  262    00:E4BE  20 0E E5   			jsr	neg_yacs		; Negate the dividend.
  263                        	
  264    00:E4C1  85 94      	!:		sta.l	<dividend		; Store the dividend.
  265    00:E4C3  A5 95      			lda.h	<dividend
  266    00:E4C5  84 95      			sty.h	<dividend
  267                        	
  268    00:E4C7  45 01      			eor.h	<divisor		; Quotient is -ve if divisor
  269    00:E4C9  08         			php				; and dividend signs differ.
  270                        	
  271    00:E4CA  A5 01      			lda.h	<divisor		; Is the divisor -ve?
  272    00:E4CC  10 0B      			bpl	!+
  273                        	
  274    00:E4CE  38         			sec				; Negate the divisor.
  275    00:E4CF  62         			cla
  276    00:E4D0  E5 00      			sbc.l	<divisor
  277    00:E4D2  85 00      			sta.l	<divisor
  278    00:E4D4  62         			cla
  279    00:E4D5  E5 01      			sbc.h	<divisor
  280    00:E4D7  85 01      			sta.h	<divisor
  281                        	
  282    00:E4D9  20 85 E4   	!:		jsr	divmoduint		; Do the unsigned division.
  283                        	
  284    00:E4DC  28         	.result:	plp				; Should the quotient be -ve?
  285    00:E4DD  10 0D      			bpl	.remainder
  286                        	
  287    00:E4DF  AA         			tax				; Preserve remainder lo-byte.
  288                        	
  289    00:E4E0  38         			sec				; Then negate the quotient.
  290    00:E4E1  62         			cla
  291    00:E4E2  E5 94      			sbc.l	<dividend
  292    00:E4E4  85 94      			sta.l	<dividend
  293    00:E4E6  62         			cla
  294    00:E4E7  E5 95      			sbc.h	<dividend
  295    00:E4E9  85 95      			sta.h	<dividend
  296                        	
  297    00:E4EB  8A         			txa				; Restore remainder lo-byte.
  298                        	
  299    00:E4EC  28         	.remainder:	plp				; Was the dividend -ve?
  300    00:E4ED  B0 1F      			bcs	neg_yacs		; Then negate the remainder.
  301    00:E4EF  60         			rts
  302                        	
  303                        	
  304                        	
  305                        	; ***************************************************************************
  306                        	; unsigned int
  307                        	; _muluchar (unsigned char x, unsigned char y)
  308                        	;
  309                        	; 1st parameter in A (unsigned multiplicand)
  310                        	; 2nd parameter in Y (unsigned multiplier)
  311                        	; result in Y:A
  312                        	
  313    00:E4F0  84 00      	__muluchar:	sty	<multiplier
  314                        	
  315    00:E4F2  A0 08      	muluchar_a:	ldy	#8			; Loop 8 times.
  316                        	
  317    00:E4F4  4A         			lsr	a			; Divide multiplicand by 2
  318    00:E4F5  85 94      			sta	<multiplicand		; and clear the 8th bit.
  319                        	
  320    00:E4F7  62         			cla				; Clear top byte of product.
  321    00:E4F8  90 03      			bcc	.rotate
  322                        	
  323    00:E4FA  18         	.add:		clc				; Add the 8-bit multiplier to
  324    00:E4FB  65 00      			adc	<multiplier		; top 8-bits of the product.
  325                        	
  326    00:E4FD  6A         	.rotate:	ror	a			; Rotate product into the top
  327    00:E4FE  66 94      			ror	<multiplicand		; bits of the multiplicand.
  328                        	
  329    00:E500  88         			dey
  330    00:E501  B0 F7      			bcs	.add			; Add multiplier to top byte?
  331    00:E503  D0 F8      			bne	.rotate			; Completed 8 bits?
  332                        	
  333    00:E505  A8         			tay				; Return the 16-bit product.
  334    00:E506  A5 94      			lda	<multiplicand
  335                        	
  336    00:E508  60         			rts
  337                        	
  338                        	
  339                        	
  340                        	; ***************************************************************************
  341                        	; signed int
  342                        	; abs (signed int x)
  343                        	;
  344                        	; 1st parameter in Y:A (signed)
  345                        	; result in Y:A
  346                        	
  347    00:E509  C0 80      	_abs:		cpy	#$80			; Is the hi-byte -ve?
  348    00:E50B  90 0B      			bcc	!+
  349                        	
  350    00:E50D  38         	neg_ya:		sec
  351    00:E50E  49 FF      	neg_yacs:	eor	#$FF
  352    00:E510  69 00      			adc	#0
  353    00:E512  42         			say
  354    00:E513  49 FF      			eor	#$FF
  355    00:E515  69 00      			adc	#0
  356    00:E517  42         			say
  357    00:E518  60         	!:		rts
  358                        	
  359    00:E519             	_abs.1		.alias	_abs
  360                        	
  361                        	
  362                        	
  363                        	; ***************************************************************************
  364                        	; signed int
  365                        	; _mulschar (signed char x, signed char y)
  366                        	;
  367                        	; 1st parameter in A (signed multiplicand)
  368                        	; 2nd parameter in Y (signed multiplier)
  369                        	; result in Y:A
  370                        	;
  371                        	; N.B. Y and A get swapped to make the code shorter.
  372                        	
  373    00:E519  85 94      	__mulschar:	sta	<multiplicand		; Remember multiplicand sign.
  374                        	
  375    00:E51B  C9 80      			cmp	#$80			; Is the multiplicand -ve?
  376    00:E51D  90 03      			bcc	!+
  377    00:E51F  49 FF      			eor	#$FF			; Negate the multiplicand.
  378    00:E521  1A         			inc	a
  379    00:E522  85 00      	!:		sta	<multiplier		; Then save it as multiplier.
  380                        	
  381    00:E524  98         			tya				; Product -ve if multiplicand
  382    00:E525  45 94      			eor	<multiplicand		; and multiplier signs differ.
  383    00:E527  08         			php				; Remember product sign.
  384                        	
  385    00:E528  98         			tya				; Is the multiplicand -ve?
  386    00:E529  10 03      			bpl	!+
  387    00:E52B  49 FF      			eor	#$FF			; Negate the multiplicand.
  388    00:E52D  1A         			inc	a
  389                        	
  390    00:E52E  20 F2 E4   	!:		jsr	muluchar_a		; Multiplier already saved.
  391                        	
  392    00:E531  28         			plp				; Is the product -ve?
  393    00:E532  30 D9      			bmi	neg_ya
  394    00:E534  60         			rts
  395                        	
  396                        	
  397                        	
  398                        	; ***************************************************************************
  399                        	; unsigned int
  400                        	; _mulsuchar (signed char x, signed char y)
  401                        	;
  402                        	; 1st parameter in A (unsigned multiplicand)
  403                        	; 2nd parameter in Y (signed multiplier)
  404                        	; result in Y:A
  405                        	;
  406                        	; N.B. Y and A get swapped to make the code shorter.
  407                        	
  408    00:E535  42         	__mulsuchar:	say				; Put the signed param in A.
  409                        			; drop through to __muluschar
  410                        	
  411                        	
  412                        	
  413                        	; ***************************************************************************
  414                        	; signed int
  415                        	; _muluschar (unsigned char x, unsigned char y)
  416                        	;
  417                        	; 1st parameter in A (signed multiplicand)
  418                        	; 2nd parameter in Y (unsigned multiplier)
  419                        	; result in Y:A
  420                        	
  421    00:E536  C9 80      	__muluschar:	cmp	#$80			; Is multiplicand -ve?
  422    00:E538  08         			php				; Remember the sign.
  423    00:E539  90 03      			bcc	!+
  424    00:E53B  49 FF      			eor	#$FF			; Negate multiplicand.
  425    00:E53D  1A         			inc	a
  426                        	
  427    00:E53E  20 F0 E4   	!:		jsr	__muluchar		; Do the unsigned multiply.
  428                        	
  429    00:E541  28         			plp				; Was multiplicand -ve?
  430    00:E542  B0 CA      			bcs	neg_yacs		; Then negate the product.
  431    00:E544  60         			rts
  432                        	
  433                        	
  434                        	
  435                        	; ***************************************************************************
  436                        	; unsigned int
  437                        	; _moduchar (unsigned char x, unsigned char y)
  438                        	;
  439                        	; 1st parameter in A (unsigned dividend)
  440                        	; 2nd parameter in Y (unsigned divisor)
  441                        	; result in Y:A
  442                        	
  443    00:E545  84 00      	__moduchar:	sty.l	<divisor
  444                        	
  445    00:E547  0A         	divmodu8_a:	asl	a			; Rotate dividend, MSB -> C.
  446    00:E548  85 94      			sta.l	<dividend
  447    00:E54A  64 95      			stz.h	<dividend		; Clear quotient hi-byte.
  448                        	
  449    00:E54C  A0 08      			ldy	#8
  450    00:E54E  62         			cla				; Clear remainder.
  451    00:E54F  2A         	.loop:		rol	a			; Rotate C into remainder.
  452    00:E550  C5 00      			cmp	<divisor		; Test divisor.
  453    00:E552  90 02      			bcc	.skip			; CC if divisor > remainder.
  454    00:E554  E5 00      			sbc	<divisor		; Subtract divisor.
  455    00:E556  26 94      	.skip:		rol	<dividend		; Quotient bit -> dividend LSB.
  456    00:E558  88         			dey
  457    00:E559  D0 F4      			bne	.loop
  458                        	
  459    00:E55B  C2         			cly				; Clear hi-byte of return.
  460    00:E55C  60         			rts				; Return the 16-bit remainder.
  461                        	
  462                        	
  463                        	
  464                        	; ***************************************************************************
  465                        	; unsigned int
  466                        	; _divuchar (unsigned char x, unsigned char y)
  467                        	;
  468                        	; 1st parameter in A (unsigned dividend)
  469                        	; 2nd parameter in Y (unsigned divisor)
  470                        	; result in Y:A
  471                        	
  472    00:E55D  20 45 E5   	__divuchar:	jsr	__moduchar
  473                        	
  474    00:E560  A5 94      			lda	<dividend		; Get the dividend lo-byte.
  475    00:E562  60         			rts				; Return the 16-bit dividend.
  476                        	
  477                        	
  478                        	
  479                        	; ***************************************************************************
  480                        	; signed int
  481                        	; _modschar (signed char x, signed char y)
  482                        	;
  483                        	; 1st parameter in A (signed dividend)
  484                        	; 2nd parameter in Y (signed divisor)
  485                        	; result in Y:A
  486                        	
  487    00:E563  AA         	__modschar:	tax				; Preserve the dividend.
  488    00:E564  08         			php				; Remember remainder sign.
  489                        	
  490    00:E565  84 00      			sty	<divisor		; Quotient negative if divisor
  491    00:E567  45 00      			eor	<divisor		; and dividend signs differ.
  492    00:E569  08         			php				; Remember the quotient sign.
  493                        	
  494    00:E56A  98         			tya				; Is the divisor -ve?
  495    00:E56B  10 05      			bpl	!+
  496    00:E56D  49 FF      			eor	#$FF			; Negate the divisor.
  497    00:E56F  1A         			inc	a
  498    00:E570  85 00      			sta	<divisor
  499                        	
  500    00:E572  8A         	!:		txa				; Is the dividend -ve?
  501    00:E573  10 03      			bpl	divmods8_a
  502                        	
  503    00:E575  49 FF      	divmods8_neg:	eor	#$FF			; Negate the dividend.
  504    00:E577  1A         			inc	a
  505                        	
  506    00:E578  20 47 E5   	divmods8_a:	jsr	divmodu8_a		; Do the unsigned division.
  507                        	
  508    00:E57B  28         			plp				; Should the quotient be -ve?
  509    00:E57C  10 0C      			bpl	!+
  510                        	
  511    00:E57E  AA         			tax				; Preserve remainder lo-byte.
  512                        	
  513    00:E57F  38         			sec				; Negate the quotient.
  514    00:E580  62         			cla
  515    00:E581  E5 94      			sbc.l	<dividend
  516    00:E583  85 94      			sta.l	<dividend
  517    00:E585  A9 FF      			lda	#$FF
  518    00:E587  85 95      			sta.h	<dividend
  519                        	
  520    00:E589  8A         			txa				; Restore remainder lo-byte.
  521                        	
  522    00:E58A  28         	!:		plp				; Was the dividend -ve?
  523    00:E58B  10 05      			bpl	!+
  524                        	
  525    00:E58D  49 FF      			eor	#$FF			; Then negate the remainder.
  526    00:E58F  1A         			inc	a
  527    00:E590  A0 FF      			ldy	#$FF
  528                        	
  529    00:E592  60         	!:		rts
  530                        	
  531                        	
  532                        	
  533                        	; ***************************************************************************
  534                        	; signed int
  535                        	; _moduschar (unsigned char x, unsigned char y)
  536                        	;
  537                        	; 1st parameter in A (signed dividend)
  538                        	; 2nd parameter in Y (unsigned divisor)
  539                        	; result in Y:A
  540                        	
  541    00:E593  84 00      	__moduschar:	sty.l	<divisor
  542                        	
  543    00:E595  A8         			tay				; Is the dividend -ve?
  544    00:E596  08         			php				; Remember remainder sign.
  545    00:E597  08         			php				; Remember quotient sign.
  546    00:E598  30 DB      			bmi	divmods8_neg
  547    00:E59A  80 DC      			bra	divmods8_a
  548                        	
  549                        	
  550                        	
  551                        	; ***************************************************************************
  552                        	; unsigned int
  553                        	; _modsuchar (signed char x, signed char y)
  554                        	;
  555                        	; 1st parameter in A (unsigned dividend)
  556                        	; 2nd parameter in Y (signed divisor)
  557                        	; result in Y:A
  558                        	
  559    00:E59C  AA         	__modsuchar:	tax				; Preserve the dividend.
  560    00:E59D  08         			php				; Remember remainder sign.
  561                        	
  562    00:E59E  98         			tya				; Check the divisor sign.
  563    00:E59F  08         			php				; Remember quotient sign.
  564    00:E5A0  10 03      			bpl	!+
  565    00:E5A2  49 FF      			eor	#$FF			; Negate the divisor.
  566    00:E5A4  1A         			inc	a
  567    00:E5A5  85 00      	!:		sta.l	<divisor
  568                        	
  569    00:E5A7  8A         			txa				; Restore the dividend.
  570    00:E5A8  80 CE      			bra	divmods8_a
  571                        	
  572                        	
  573                        	
  574                        	; ***************************************************************************
  575                        	; signed int
  576                        	; _divschar (signed char x, signed char y)
  577                        	;
  578                        	; 1st parameter in A (signed dividend)
  579                        	; 2nd parameter in Y (signed divisor)
  580                        	; result in Y:A
  581                        	
  582    00:E5AA  20 63 E5   	__divschar:	jsr	__modschar
  583                        	
  584    00:E5AD  A5 94      			lda.l	<dividend
  585    00:E5AF  A4 95      			ldy.h	<dividend
  586    00:E5B1  60         			rts
  587                        	
  588                        	
  589                        	
  590                        	; ***************************************************************************
  591                        	; signed int
  592                        	; _divuschar (unsigned char x, unsigned char y)
  593                        	;
  594                        	; 1st parameter in A (signed dividend)
  595                        	; 2nd parameter in Y (unsigned divisor)
  596                        	; result in Y:A
  597                        	
  598    00:E5B2  20 93 E5   	__divuschar:	jsr	__moduschar
  599                        	
  600    00:E5B5  A5 94      			lda.l	<dividend
  601    00:E5B7  A4 95      			ldy.h	<dividend
  602    00:E5B9  60         			rts
  603                        	
  604                        	
  605                        	
  606                        	; ***************************************************************************
  607                        	; unsigned int
  608                        	; _divsuchar (signed char x, signed char y)
  609                        	;
  610                        	; 1st parameter in A (unsigned dividend)
  611                        	; 2nd parameter in Y (signed divisor)
  612                        	; result in Y:A
  613                        	
  614    00:E5BA  20 9C E5   	__divsuchar:	jsr	__modsuchar
  615                        	
  616    00:E5BD  A5 94      			lda.l	<dividend
  617    00:E5BF  A4 95      			ldy.h	<dividend
  618    00:E5C1  60         			rts
                             #[2]   "..\..\..\include\hucc\hucc-final.asm"
   43                        	
   44                        			; Define in hucc-config.inc to remove this.
   45                        	
   46               0001     		.ifndef	HUCC_NO_DEFAULT_RANDOM
                             #[3]   "..\..\..\include\hucc\random.asm"
   47                        			include	"random.asm"		; Random number generator.
    1                        	; ***************************************************************************
    2                        	; ***************************************************************************
    3                        	;
    4                        	; random.asm
    5                        	;
    6                        	; Pseudo-random number generator (https://github.com/bbbradsmith/prng_6502)
    7                        	;
    8                        	; Copyright Brad Smith 2019.
    9                        	;
   10                        	; License:
   11                        	;
   12                        	; This code and may be used, reused, and modified for any purpose, commercial
   13                        	; or non-commercial.
   14                        	;
   15                        	; Attribution in released binaries or documentation is appreciated but not
   16                        	; required.
   17                        	;
   18                        	; ***************************************************************************
   19                        	; ***************************************************************************
   20                        	;
   21                        	; This is a linear feedback shift register (LFSR) in Galois form, which is
   22                        	; iterated 8 times to produce an 8-bit pseudo-random number.
   23                        	;
   24                        	; Two widths of LFSR are provided:
   25                        	;
   26                        	;  24-bit requires 3 bytes, and repeats after 16777215 calls.
   27                        	;  32-bit requires 4 bytes, and repeats after 4294967295 calls.
   28                        	;
   29                        	; Usage:
   30                        	;
   31                        	;  Initialize the zero-page "random" variable to any value other than 0.
   32                        	;  The size of "random" is 3 or 4 bytes, depending on the width of LFSR
   33                        	;  chosen.
   34                        	;
   35                        	;  Call one of the RNG functions and an 8-bit result will be returned in the
   36                        	;  A-register (with flags), and the Y-register will be clobbered.
   37                        	;
   38                        	;  Do not mix RNGs of different width in the same program, unless you can
   39                        	;  give them each separate "random" state storage.
   40                        	;
   41                        	; ***************************************************************************
   42                        	; ***************************************************************************
   43                        	
   44                        	
   45               0001     		.ifndef	_KICKC				; Variables defined in C?
   46               2098     			.zp
   47    F8:2098             	random:		.ds	4			; Seed is 3 or 4 bytes.
   48               E5C2     			.code
   49                        		.endif	_KICKC
   50                        	
   51                        	
   52                        	
   53                        	; ***************************************************************************
   54                        	; ***************************************************************************
   55                        	;
   56                        	; init_random - Initialize a 32-bit LFSR using an 8-bit seed value in Y.
   57                        	;
   58                        	; The LFSR is initialized to n'th entry of a standard CRC-32 lookup-table,
   59                        	; which gives it a decent distribution of bits.
   60                        	;
   61                        	; Since seed is an 8-bit value, there are 255 (256-1) possible starting
   62                        	; states for the LFSR, because 0 would generate a 0 state.
   63                        	;
   64                        	; CRC-32 code by Paul Guertin. See http://6502.org/source/integers/crc.htm
   65                        	;
   66                        	
   67    01:CA23             	init_random	.proc
   68                        	
   69    01:CA23  A9 01      			lda	#1			; Init CRC-32 table value.
   70    01:CA25  85 98      			sta	<random + 0
   71    01:CA27  98         			tya				; Get and check the seed value.
   72    01:CA28  D0 01      			bne	.reverse_seed
   73    01:CA2A  3A         			dec	a			; Which must be non-zero!
   74    01:CA2B  4A         	.reverse_seed:	lsr	a			; Reverse the bits so that small changes
   75    01:CA2C  26 98      			rol	<random + 0		; in the seed make larger differences in
   76    01:CA2E  90 FB      			bcc	.reverse_seed		; the initial state.
   77                        	
   78    01:CA30  64 99      			stz	<random + 1		; A contains the high byte of the CRC-32.
   79    01:CA32  64 9A      			stz	<random + 2		; The other three bytes are in memory.
   80    01:CA34  62         			cla
   81                        	
   82    01:CA35  A0 08      			ldy	#8			; Y counts bits in a byte.
   83    01:CA37  4A         	.bit_loop:	lsr	a			; The CRC-32 algorithm is similar to CRC-16
   84    01:CA38  66 9A      			ror	<random + 2		; except that it is reversed (originally for
   85    01:CA3A  66 99      			ror	<random + 1		; hardware reasons). This is why we shift
   86    01:CA3C  66 98      			ror	<random + 0		; right instead of left here.
   87    01:CA3E  90 16      			bcc	.no_add			; Do nothing if no overflow,
   88    01:CA40  49 ED      			eor	#$ED			; else add CRC-32 polynomial $EDB88320.
   89                        	
   90    01:CA42  48         			pha				; Save high byte while we do others.
   91    01:CA43  A5 9A      			lda	<random + 2
   92    01:CA45  49 B8      			eor	#$B8			; Most reference books give the CRC-32 poly
   93    01:CA47  85 9A      			sta	<random + 2		; as $04C11DB7. This is actually the same if
   94    01:CA49  A5 99      			lda	<random + 1		; you write it in binary and read it right-
   95    01:CA4B  49 83      			eor	#$83			; to-left instead of left-to-right. Doing it
   96    01:CA4D  85 99      			sta	<random + 1		; this way means we won't have to explicitly
   97    01:CA4F  A5 98      			lda	<random + 0		; reverse things afterwards.
   98    01:CA51  49 20      			eor	#$20
   99    01:CA53  85 98      			sta	<random + 0
  100    01:CA55  68         			pla				; Restore high byte.
  101                        	
  102    01:CA56  88         	.no_add:	dey				; Do next bit.
  103    01:CA57  D0 DE      			bne	.bit_loop
  104                        	
  105    01:CA59  85 9B      			sta	<random + 3		; Save CRC-32 high-byte.
  106                        	
  107                        			leave				; All done!
         01:CA5B  4C EF FF   			jmp	leave_proc
  108                        	
  109                        			.endp
  110                        	
  111                        	
  112                        	
  113                        	; ***************************************************************************
  114                        	; ***************************************************************************
  115                        	;
  116                        	; get_random - 8-bit LFSR pseudo-random number with a 24-bit cycle.
  117                        	;
  118                        	; The pseudo-random sequence repeats after (2^24)-1 calls.
  119                        	;
  120                        	; Written by Wim Couwenberg, see ...
  121                        	;
  122                        	; "https://wimcouwenberg.wordpress.com/2020/11/15/ ...
  123                        	;  a-fast-24-bit-prng-algorithm-for-the-6502-processor/"
  124                        	;
  125                        	; Takes 68 cycles on the HuC6280, incl JSR & RTS.
  126                        	;
  127                        	; N.B. HuCC library code relies on this preserving X and Y!
  128                        	;
  129                        	
  130    00:E5C2  C2         	_rand8:		cly				; Entry point for HuCC.
  131                        	
  132    00:E5C3  A5 98      	get_random:	lda	<random + 0		; Operation 7 (with carry clear).
  133    00:E5C5  0A         			asl	a
  134    00:E5C6  45 99      			eor	<random + 1
  135    00:E5C8  85 99      			sta	<random + 1
  136    00:E5CA  2A         			rol	a             		; Operation 9.
  137    00:E5CB  45 9A      			eor	<random + 2
  138    00:E5CD  85 9A      			sta	<random + 2
  139    00:E5CF  45 98      			eor	<random + 0		; Operation 5.
  140    00:E5D1  85 98      			sta	<random + 0
  141    00:E5D3  A5 99      			lda	<random + 1		; Operation 15.
  142    00:E5D5  6A         			ror	a
  143    00:E5D6  45 9A      			eor	<random + 2
  144    00:E5D8  85 9A      			sta	<random + 2
  145    00:E5DA  45 99      			eor	<random + 1		; Operation 6.
  146    00:E5DC  85 99      			sta	<random + 1
  147    00:E5DE  60         			rts
  148                        	
  149                        	
  150                        	
  151               0000     		.if	0
  316                        		.endif
                             #[2]   "..\..\..\include\hucc\hucc-final.asm"
   48                        		.endif
   49                        	
   50                        			; Optional libraries that get used when their header files
   51                        			; are included in a HuCC project.
   52                        			;
   53                        			; When the HuCC compiler is invoked with the "--legacy"
   54                        			; option to compile old projects, then the "huc.h" file
   55                        			; is automatically included, which then includes a list
   56                        			; of specific headers corresponding to HuC's library.
   57                        	
   58               0001     		.ifdef	HUCC_USES_GFX
                             #[3]   "..\..\..\include\hucc\hucc-gfx.asm"
   59                        			include	"hucc-gfx.asm"		; Set in hucc_gfx.h
    1                        	; ***************************************************************************
    2                        	; ***************************************************************************
    3                        	;
    4                        	; huc-gfx.asm
    5                        	;
    6                        	; Based on the original HuC and MagicKit functions by David Michel and the
    7                        	; other original HuC developers.
    8                        	;
    9                        	; Modifications copyright John Brandwood 2024-2025.
   10                        	;
   11                        	; Distributed under the Boost Software License, Version 1.0.
   12                        	; (See accompanying file LICENSE_1_0.txt or copy at
   13                        	;  http://www.boost.org/LICENSE_1_0.txt)
   14                        	;
   15                        	; ***************************************************************************
   16                        	; ***************************************************************************
   17                        	
   18                        	;
   19                        	; Include dependancies ...
   20                        	;
   21                        	
   22                        			include "common.asm"		; Common helpers.
   23                        			include "vce.asm"		; Useful VCE routines.
   24                        			include "vdc.asm"		; Useful VCE routines.
   25                        	
   26                        	
   27                        	
   28                        	; ***************************************************************************
   29                        	; ***************************************************************************
   30                        	;
   31                        	; void __fastcall disp_on( void );
   32                        	; void __fastcall disp_off( void );
   33                        	
   34    00:E5DF             			.alias	_disp_on		= set_dspon
   35    00:E5DF             			.alias	_disp_off		= set_dspoff
   36                        	
   37                        	
   38                        	
   39                        	; ***************************************************************************
   40                        	; ***************************************************************************
   41                        	;
   42                        	; void __fastcall set_screen_size( unsigned char value<_al> );
   43                        	; void __fastcall sgx_set_screen_size( unsigned char value<_al> );
   44                        	;
   45                        	
   46    00:E5DF             			.alias	_set_screen_size.1	= set_bat_vdc
   47    00:E5DF             			.alias	_sgx_set_screen_size.1	= set_bat_sgx
   48                        	
   49                        	
   50                        	
   51                        	; ***************************************************************************
   52                        	; ***************************************************************************
   53                        	;
   54                        	; void __fastcall init_256x224( void );
   55                        	
   56    01:C6A1             	_init_256x224	.proc
   57                        	
   58               0800     	.BAT_SIZE	=	64 * 32
   59               0080     	.CHR_0x20	=	.BAT_SIZE / 16		; 1st tile # after the BAT.
   60               7F00     	.SAT_ADDR	=	$7F00			; SAT takes 16 tiles of VRAM.
   61                        	
   62    01:C6A1  08         			php				; Disable interrupts.
   63    01:C6A2  78         			sei
   64                        	
   65    01:C6A3  20 AF FE   			call	clear_vce		; Clear all palettes.
   66                        	
   67    01:C6A6  A9 80      			lda.l	#.CHR_0x20		; CHR # of ASCII ' '.
   68    01:C6A8  85 F8      			sta.l	<_ax
   69    01:C6AA  A9 00      			lda.h	#.CHR_0x20
   70    01:C6AC  85 F9      			sta.h	<_ax
   71                        	
   72    01:C6AE  A9 08      			lda	#>.BAT_SIZE		; Size of BAT in words.
   73    01:C6B0  85 FA      			sta	<_bl
   74                        	
   75    01:C6B2  20 C3 FE   			call	clear_vram_vdc		; Clear VRAM.
   76               0001     		.if	SUPPORT_SGX
   77    01:C6B5  20 A5 FE   			call	clear_vram_sgx
   78                        		.endif
   79                        	
   80    01:C6B8  A9 DC      			lda	#<.mode_256x224		; Disable BKG & SPR layers but
   81    01:C6BA  85 EC      			sta.l	<_bp			; enable RCR & VBLANK IRQ.
   82    01:C6BC  A9 C6      			lda	#>.mode_256x224
   83    01:C6BE  85 ED      			sta.h	<_bp
   84                        	
   85               0001     		.if	SUPPORT_SGX
   86    01:C6C0  20 9B FE   			call	sgx_detect		; Are we really on an SGX?
   87    01:C6C3  90 05      			bcc	!+
   88    01:C6C5  A0 01      			ldy	#^.mode_256x224		; Set SGX 1st, with no VBL.
   89    01:C6C7  20 91 FE   			call	set_mode_sgx
   90                        		.endif
   91    01:C6CA  A0 01      	!:		ldy	#^.mode_256x224		; Set VDC 2nd, VBL allowed.
   92    01:C6CC  20 87 FE   			call	set_mode_vdc
   93                        	
   94               0001     		.if	SUPPORT_SGX
   95    01:C6CF  2C 10 02   			bit	SGX_SR			; Purge any overdue RCR.
   96                        		.endif
   97    01:C6D2  2C 00 02   			bit	VDC_SR			; Purge any overdue VBL.
   98    01:C6D5  28         			plp				; Restore interrupts.
   99                        	
  100    01:C6D6  20 09 E3   			call	wait_vsync		; Wait for the next VBLANK.
  101                        	
  102                        			leave				; All done, phew!
         01:C6D9  4C EF FF   			jmp	leave_proc
  103                        	
  104                        			; A standard 256x224 screen with overscan.
  105                        	
  106    01:C6DC  80         	.mode_256x224:	db	$80			; VCE Control Register.
  107    01:C6DD  04         			db	VCE_CR_5MHz + XRES_SOFT	;   Video Clock + Artifact Reduction
  108                        	
  109    01:C6DE  09         			db	VDC_MWR			; Memory-access Width Register
  110    01:C6DF  10 00      			dw	VDC_MWR_64x32 + VDC_MWR_1CYCLE
  111    01:C6E1  0A         			db	VDC_HSR			; Horizontal Sync Register
  112    01:C6E2  02 02      			dw	VDC_HSR_256
  113    01:C6E4  0B         			db	VDC_HDR			; Horizontal Display Register
  114    01:C6E5  1F 04      			dw	VDC_HDR_256
  115    01:C6E7  0C         			db	VDC_VPR			; Vertical Sync Register
  116    01:C6E8  02 17      			dw	VDC_VPR_224
  117    01:C6EA  0D         			db	VDC_VDW			; Vertical Display Register
  118    01:C6EB  DF 00      			dw	VDC_VDW_224
  119    01:C6ED  0E         			db	VDC_VCR			; Vertical Display END position Register
  120    01:C6EE  FF 00      			dw	VDC_VCR_224
  121    01:C6F0  0F         			db	VDC_DCR			; DMA Control Register
  122    01:C6F1  10 00      			dw	$0010			;   Enable automatic VRAM->SATB
  123    01:C6F3  13         			db	VDC_DVSSR		; VRAM->SATB address $7F00
  124    01:C6F4  00 7F      			dw	.SAT_ADDR
  125    01:C6F6  07         			db	VDC_BXR			; Background X-Scroll Register
  126    01:C6F7  00 00      			dw	$0000
  127    01:C6F9  08         			db	VDC_BYR			; Background Y-Scroll Register
  128    01:C6FA  00 00      			dw	$0000
  129    01:C6FC  06         			db	VDC_RCR			; Raster Counter Register
  130    01:C6FD  00 00      			dw	$0000			;   Never occurs!
  131    01:C6FF  05         			db	VDC_CR			; Control Register
  132    01:C700  0C 00      			dw	$000C			;   Enable VSYNC & RCR IRQ
  133    01:C702  00         			db	0
  134                        	
  135                        			.endp
  136                        	
  137                        	
  138                        	
  139                        	; ***************************************************************************
  140                        	; ***************************************************************************
  141                        	;
  142                        	; void __fastcall init_240x208( void );
  143                        	
  144                        	_init_240x208	.proc
  223                        			.endp
  224                        	
  225                        	
  226                        	
  227                        	; ***************************************************************************
  228                        	; ***************************************************************************
  229                        	;
  230                        	; void __fastcall _macro set_xres( unsigned int x_pixels<_ax> );
  231                        	; void __fastcall _macro sgx_set_xres( unsigned int x_pixels<_ax> );
  232                        	;
  233                        	; void __fastcall set_xres( unsigned int x_pixels<_ax>, unsigned char blur_flag<_bl> );
  234                        	; void __fastcall sgx_set_xres( unsigned int x_pixels<_ax>, unsigned char blur_flag<_bl> );
  235                        	;
  236                        	; blur_flag = XRES_SOFT (default if not specified), XRES_SHARP or XRES_KEEP
  237                        	
  238                        	set_xres_group	.procgroup			; These routines share code!
  337                        			.endprocgroup	; set_xres_group
  338                        	
  339                        	
  340                        	
  341                        	; ***************************************************************************
  342                        	; ***************************************************************************
  343                        	;
  344                        	; HuC VRAM Functions
  345                        	;
  346                        	; ***************************************************************************
  347                        	; ***************************************************************************
  348                        	
  349                        	
  350    01:C5CE             	load_vram_group	.procgroup			; These routines share code!
  351                        	
  352                        	; ***************************************************************************
  353                        	; ***************************************************************************
  354                        	;
  355                        	; void __fastcall load_vram( unsigned int vram<_di>, unsigned char __far *data<_bp_bank:_bp>, unsigned int num_words<_ax> );
  356                        	; void __fastcall sgx_load_vram( unsigned int vram<_di>, unsigned char __far *data<_bp_bank:_bp>, unsigned int num_words<_ax> );
  357                        	;
  358                        	; void __fastcall far_load_vram( unsigned int vram<_di>, unsigned int num_words<_ax> );
  359                        	; void __fastcall sgx_far_load_vram( unsigned int vram<_di>, unsigned int num_words<_ax> );
  360                        	;
  361                        	; load_vram_sgx -  copy a block of memory to VRAM
  362                        	; load_vram_vdc -  copy a block of memory to VRAM
  363                        	;
  364                        	; _bp		= BAT memory location
  365                        	; _bp_bank	= BAT bank
  366                        	; _di		= VRAM base address
  367                        	; _ax		= nb of words to copy
  368                        	; ----
  369                        	; N.B. BAT data *must* be word-aligned!
  370                        	
  371               0000     		.ifndef	VRAM_XFER_SIZE
  373                        		.endif
  374                        	
  375    01:C5CE             	load_vram_x	.proc
  376                        	
  377    01:C5CE  43 08      			tma3
  378    01:C5D0  48         			pha
  379    01:C5D1  43 10      			tma4
  380    01:C5D3  48         			pha
  381                        	
  382    01:C5D4  A4 02      			ldy	<_bp_bank
  383    01:C5D6  20 3B E3   			jsr	map_bp_to_mpr34		; Map data to MPR3 & MPR4.
  384                        	
  385    01:C5D9  20 7F E3   			jsr	set_di_to_mawr
  386                        	
  387                        	;		tii	.vdc_tai, ram_tia, 8
  388                        	
  389               0001     		.if	SUPPORT_SGX
  390    01:C5DC  8A         			txa				; Select which VDC to write
  391    01:C5DD  1A         			inc	a			; to.
  392    01:C5DE  1A         			inc	a
  393    01:C5DF  8D F3 22   			sta.l	ram_tia_dst
  394                        		.endif
  395                        	
  396    01:C5E2  A9 10      			lda	#VRAM_XFER_SIZE		; Split into 16-byte chunks
  397    01:C5E4  8D F5 22   			sta.l	ram_tia_len		; for stable IRQ response.
  398                        	
  399    01:C5E7  A6 EC      			ldx.l	<_bp
  400    01:C5E9  8E F1 22   			stx.l	ram_tia_src
  401    01:C5EC  A4 ED      			ldy.h	<_bp
  402    01:C5EE  8C F2 22   			sty.h	ram_tia_src
  403                        	
  404    01:C5F1  A5 F8      			lda.l	<_ax			; Length in words.
  405    01:C5F3  48         			pha				; Preserve length.l
  406                        	
  407    01:C5F4  46 F9      			lsr.h	<_ax
  408    01:C5F6  6A         			ror	a
  409    01:C5F7  46 F9      			lsr.h	<_ax
  410    01:C5F9  6A         			ror	a
  411    01:C5FA  46 F9      			lsr.h	<_ax
  412    01:C5FC  6A         			ror	a
  413               0000     		.if	VRAM_XFER_SIZE == 32
  416                        		.endif
  417                        	
  418    01:C5FD  22         			sax				; x=chunks-lo
  419    01:C5FE  F0 1F      			beq	.next_block		; a=source-lo, y=source-hi
  420                        	
  421    01:C600  20 F0 22   	.chunk_loop:	jsr	ram_tia			; transfer 16-bytes
  422                        	
  423    01:C603  18         			clc				; increment source
  424    01:C604  69 10      			adc	#VRAM_XFER_SIZE
  425    01:C606  8D F1 22   			sta.l	ram_tia_src
  426    01:C609  90 11      			bcc	.same_page
  427    01:C60B  C8         			iny
  428    01:C60C  10 0B      			bpl	.same_bank		; remap_data
  429                        	
  430    01:C60E  42         			say
  431    01:C60F  43 10      			tma4
  432    01:C611  53 08      			tam3
  433    01:C613  1A         			inc	a
  434    01:C614  53 10      			tam4
  435    01:C616  A9 60      			lda	#$60
  436    01:C618  42         			say
  437                        	
  438    01:C619  8C F2 22   	.same_bank:	sty.h	ram_tia_src
  439                        	
  440    01:C61C  CA         	.same_page:	dex
  441    01:C61D  D0 E1      			bne	.chunk_loop
  442                        	
  443    01:C61F  C6 F9      	.next_block:	dec.h	<_ax
  444    01:C621  10 DD      			bpl	.chunk_loop
  445                        	
  446    01:C623  68         			pla				; Restore length.l
  447    01:C624  29 07      			and	#VRAM_XFER_SIZE / 2 - 1
  448    01:C626  F0 07      			beq	.done
  449                        	
  450    01:C628  0A         			asl	a			; Convert words to bytes.
  451    01:C629  8D F5 22   			sta.l	ram_tia_len
  452                        	
  453    01:C62C  20 F0 22   			jsr	ram_tia			; transfer remainder
  454                        	
  455    01:C62F  68         	.done:		pla
  456    01:C630  53 10      			tam4
  457    01:C632  68         			pla
  458    01:C633  53 08      			tam3
  459                        	
  460                        			leave
         01:C635  4C EF FF   			jmp	leave_proc
  461                        	
  462                        			.endp
  463                        	
  464                        			.endprocgroup	; load_vram_group
  465                        	
  466                        	
  467                        	
  468                        	; ***************************************************************************
  469                        	; ***************************************************************************
  470                        	;
  471                        	; void __fastcall load_bat( unsigned int vram<_di>, unsigned char __far *data<_bp_bank:_bp>, unsigned char tiles_w<_al>, unsigned char tiles_h<_ah> );
  472                        	; void __fastcall sgx_load_bat( unsigned int vram<_di>, unsigned char __far *data<_bp_bank:_bp>, unsigned char tiles_w<_al>, unsigned char tiles_h<_ah> );
  473                        	;
  474                        	; void __fastcall far_load_bat( unsigned int vram<_di>, unsigned char tiles_w<_al>, unsigned char tiles_h<_ah> );
  475                        	; void __fastcall sgx_far_load_bat( unsigned int vram<_di>, unsigned char tiles_w<_al>, unsigned char tiles_h<_ah> );
  476                        	;
  477                        	; load_bat_sgx - transfer a BAT to VRAM
  478                        	; load_bat_vdc - transfer a BAT to VRAM
  479                        	;
  480                        	; transfer a BAT to VRAM
  481                        	; ----
  482                        	; _bp		= BAT memory location
  483                        	; _bp_bank	= BAT bank
  484                        	; _di		= VRAM base address
  485                        	; _al		= nb of column to copy
  486                        	; _ah		= nb of row
  487                        	; ----
  488                        	; N.B. BAT data *must* be word-aligned!
  489                        	
  490               20EC     	_gfx_load_bat_PARM_2	=	_bp
  491               20F0     	_gfx_load_bat_PARM_3	=	_di
  492               20F8     	_gfx_load_bat_PARM_4	=	_al
  493               20F9     	_gfx_load_bat_PARM_5	=	_ah
  494                        	
  495    01:C9A6             	load_bat_group	.procgroup			; These routines share code!
  496                        	
  497               0001     		.if	SUPPORT_SGX
  498                        			.proc	_sgx_load_bat.4
  505                        			.endp
  506                        		.endif
  507                        	
  508    01:C9A6             			.proc	_load_bat.4
  509    01:C9A6             			.alias	_far_load_bat.3		= _load_bat.4
  510                        	
  511    01:C9A6  82         			clx				; Offset to PCE VDC.
  512                        	
  513    01:C9A7  43 08      			tma3
  514    01:C9A9  48         			pha
  515                        	
  516    01:C9AA  A4 02      			ldy	<_bp_bank
  517    01:C9AC  20 2D E3   			jsr	map_bp_to_mpr3		; Map data to MPR3.
  518                        	
  519    01:C9AF  A4 EC      			ldy.l	<_bp
  520    01:C9B1  64 EC      			stz.l	<_bp
  521                        	
  522    01:C9B3  20 7F E3   	.line_loop:	jsr	set_di_to_mawr
  523                        	
  524    01:C9B6  A5 F8      			lda	<_al
  525    01:C9B8  85 00      			sta	<__temp
  526    01:C9BA  B1 EC      	.tile_loop:	lda	[_bp], y
  527    01:C9BC  9D 02 02   			sta	VDC_DL, x
  528    01:C9BF  C8         			iny
  529    01:C9C0  B1 EC      			lda	[_bp], y
  530    01:C9C2  9D 03 02   			sta	VDC_DH, x
  531    01:C9C5  C8         			iny
  532    01:C9C6  D0 03      			bne	!+
  533    01:C9C8  20 4C E3   			jsr	inc.h_bp_mpr3
  534    01:C9CB  C6 00      	!:		dec	<__temp
  535    01:C9CD  D0 EB      			bne	.tile_loop
  536                        	
  537    01:C9CF  BD 3D 23   			lda	vdc_bat_width, x
  538    01:C9D2  18         			clc
  539    01:C9D3  65 F0      			adc.l	<_di
  540    01:C9D5  85 F0      			sta.l	<_di
  541    01:C9D7  90 02      			bcc	!+
  542    01:C9D9  E6 F1      			inc.h	<_di
  543                        	
  544    01:C9DB  C6 F9      	!:		dec	<_ah
  545    01:C9DD  D0 D4      			bne	.line_loop
  546                        	
  547    01:C9DF  68         			pla
  548    01:C9E0  53 08      			tam3
  549                        	
  550                        			leave
         01:C9E2  4C EF FF   			jmp	leave_proc
  551                        	
  552                        			.endp
  553                        	
  554                        			.endprocgroup	; load_bat_group
  555                        	
  556                        	
  557                        	
  558                        	; ***************************************************************************
  559                        	; ***************************************************************************
  560                        	;
  561                        	; void __fastcall load_palette( unsigned char palette<_al>, unsigned char __far *data<_bp_bank:_bp>, unsigned char num_palettes<_ah> );
  562                        	;
  563                        	; void __fastcall far_load_palette( unsigned char palette<_al>, unsigned char num_palettes<_ah> );
  564                        	
  565    01:CA8C             			.proc	_load_palette.3
  566    01:CA8C             			.alias	_far_load_palette.2	= _load_palette.3
  567                        	
  568    01:CA8C  AC 14 23   			ldy	color_queue_w		; Get the queue's write index.
  569                        	
  570    01:CA8F  A5 EC      			lda.l	<_bp			; Add this set of palettes to
  571    01:CA91  99 25 23   			sta	color_addr_l, y		; the queue.
  572    01:CA94  A5 ED      			lda.h	<_bp
  573    01:CA96  99 2D 23   			sta	color_addr_h, y
  574    01:CA99  A5 02      			lda	<_bp_bank
  575    01:CA9B  99 35 23   			sta	color_bank, y
  576    01:CA9E  A5 F8      			lda	<_al
  577    01:CAA0  99 15 23   			sta	color_index, y
  578    01:CAA3  A5 F9      			lda	<_ah
  579    01:CAA5  99 1D 23   			sta	color_count, y
  580                        	
  581    01:CAA8  C8         			iny				; Increment the queue index.
  582    01:CAA9  98         			tya
  583    01:CAAA  29 07      			and	#7
  584                        	
  585    01:CAAC  CD 13 23   	.wait:		cmp	color_queue_r		; If the queue is full, wait
  586    01:CAAF  F0 FB      			beq	.wait			; for the next VBLANK.
  587                        	
  588    01:CAB1  8D 14 23   			sta	color_queue_w		; Signal item is in the queue.
  589                        	
  590                        			leave				; All done, phew!
         01:CAB4  4C EF FF   			jmp	leave_proc
  591                        	
  592                        			.endp
  593                        	
  594                        	
  595                        	
  596               0000     		.if	0
  620                        		.endif
  621                        	
  622                        	
  623                        	
  624                        	; ***************************************************************************
  625                        	; ***************************************************************************
  626                        	;
  627                        	; void __fastcall load_background( unsigned char __far *tiles<_bp_bank:_bp>, unsigned char __far *palettes<__fbank:__fptr>, unsigned char __far *bat<_cl:_bx>, unsigned char w<_dl>, unsigned char w<_dh> );
  628                        	
  629                        			.proc	_load_background.5
  667                        			.endp
  668                        	
  669                        	
  670                        	
  671                        	; ***************************************************************************
  672                        	; ***************************************************************************
  673                        	;
  674                        	; void __fastcall vram2vram( unsigned int vram_dst<_ax>, unsigned int vram_src<_bx>, unsigned int word_len<_cx> );
  675                        	; void __fastcall sgx_vram2vram( unsigned int vram_dst<_ax>, unsigned int vram_src<_bx>, unsigned int word_len<_cx> );
  676                        	;
  677                        	
  678               0001     		.if	SUPPORT_SGX
  679                        			.proc	_sgx_vram2vram.3
  685                        			.endp
  686                        		.endif
  687                        	
  688    01:C9E5             			.proc	_vram2vram.3
  689                        	
  690    01:C9E5  82         			clx				; Offset to PCE VDC.
  691                        	
  692    01:C9E6  08         			php
  693    01:C9E7  78         			sei
  694    01:C9E8  A9 11      			lda	#VDC_DESR
  695    01:C9EA  9D 00 02   			sta	VDC_AR, x
  696    01:C9ED  A5 F8      			lda.l	<_ax
  697    01:C9EF  9D 02 02   			sta	VDC_DL, x
  698    01:C9F2  A5 F9      			lda.h	<_ax
  699    01:C9F4  9D 03 02   			sta	VDC_DH, x
  700                        	
  701    01:C9F7  A9 10      			lda	#VDC_SOUR
  702    01:C9F9  9D 00 02   			sta	VDC_AR, x
  703    01:C9FC  A5 FA      			lda.l	<_bx
  704    01:C9FE  9D 02 02   			sta	VDC_DL, x
  705    01:CA01  A5 FB      			lda.h	<_bx
  706    01:CA03  9D 03 02   			sta	VDC_DH, x
  707                        	
  708    01:CA06  A9 12      			lda	#VDC_LENR
  709    01:CA08  9D 00 02   			sta	VDC_AR, x
  710    01:CA0B  18         			clc
  711    01:CA0C  A5 FC      			lda.l	<_cx
  712    01:CA0E  69 FF      			adc	#$FF
  713    01:CA10  9D 02 02   			sta	VDC_DL, x
  714    01:CA13  A5 FD      			lda.h	<_cx
  715    01:CA15  69 FF      			adc	#$FF
  716    01:CA17  9D 03 02   			sta	VDC_DH, x
  717                        	
  718    01:CA1A  B5 F7      			lda	<vdc_reg, x
  719    01:CA1C  8D 00 02   			sta	VDC_AR
  720    01:CA1F  28         			plp
  721                        	
  722                        			leave
         01:CA20  4C EF FF   			jmp	leave_proc
  723                        	
  724                        			.endp
  725                        	
  726                        	
  727                        	
  728                        	; ***************************************************************************
  729                        	; ***************************************************************************
  730                        	;
  731                        	; HuC Font Functions
  732                        	;
  733                        	; ***************************************************************************
  734                        	; ***************************************************************************
  735                        	
  736                        	
  737                        	
  738               235D     			.bss
  739                        	
  740                        	; **************
  741                        	; 16-bytes of VDC BAT information.
  742                        	;
  743                        	; N.B. MUST be 16-bytes before the SGX versions to use PCE_VDC_OFFSET.
  744                        	
  745    F8:235D             	_vdc_font_base:	ds	2	; Tile number of ASCII '\0'.
  746                        	
  747                        	; From hucc-printf.asm just to avoid wasting .bss space with padding.
  748    F8:235F             	_vdc_tty_x_lhs:	ds	1	; TTY minimum X position.
  749    F8:2360             	_vdc_tty_y_top:	ds	1	; TTY minimum Y position.
  750    F8:2361             	_vdc_tty_x:	ds	1	; TTY current X position.
  751    F8:2362             	_vdc_tty_y:	ds	1	; TTY current Y position.
  752                        	
  753               0001     		.if	SUPPORT_SGX
  754                        	
  755                        	; **************
  756                        	; 16-bytes of SGX BAT information.
  757                        	;
  758                        	; N.B. MUST be 16-bytes after the VDC versions to use SGX_VDC_OFFSET.
  759                        	
  760    F8:2363             			ds	10	; Padding to ensure the 16-byte delta.
  761                        	
  762    F8:236D             	_sgx_font_base:	ds	2	; Tile number of ASCII '\0'.
  763                        	
  764                        	; From hucc-printf.asm just to avoid wasting .bss space with padding.
  765    F8:236F             	_sgx_tty_x_lhs:	ds	1	; TTY minimum X position.
  766    F8:2370             	_sgx_tty_y_top:	ds	1	; TTY minimum Y position.
  767    F8:2371             	_sgx_tty_x:	ds	1	; TTY current X position.
  768    F8:2372             	_sgx_tty_y:	ds	1	; TTY current Y position.
  769                        	
  770                        		.endif
  771                        	
  772                        	;_font_base	.alias	vdc_font_base
  773                        	
  774               E5DF     			.code
  775                        	
  776                        	
  777                        	
  778                        	; ***************************************************************************
  779                        	; ***************************************************************************
  780                        	;
  781                        	; void __fastcall set_font_addr( unsigned int vram<acc> );
  782                        	; void __fastcall sgx_set_font_addr( unsigned int vram<acc> );
  783                        	
  784               0001     		.if	SUPPORT_SGX
  785    00:E5DF             	_sgx_set_font_addr.1:
  786    00:E5DF  A2 10      			ldx	#SGX_VDC_OFFSET		; Offset to SGX VDC.
  787    00:E5E1  F0         			db	$F0			; Turn "clx" into a "beq".
  788                        		.endif
  789                        	
  790    00:E5E2             	_set_font_addr.1:
  791    00:E5E2  82         			clx				; Offset to PCE VDC.
  792                        	
  793    00:E5E3  84 00      	set_font_addr:	sty	<__temp
  794    00:E5E5  46 00      			lsr	<__temp
  795    00:E5E7  6A         			ror	a
  796    00:E5E8  46 00      			lsr	<__temp
  797    00:E5EA  6A         			ror	a
  798    00:E5EB  46 00      			lsr	<__temp
  799    00:E5ED  6A         			ror	a
  800    00:E5EE  46 00      			lsr	<__temp
  801    00:E5F0  6A         			ror	a
  802    00:E5F1  38         			sec
  803    00:E5F2  E9 20      			sbc	#$20
  804    00:E5F4  9D 5D 23   			sta.l	_vdc_font_base,x
  805    00:E5F7  B0 02      			bcs	!+
  806    00:E5F9  C6 00      			dec	<__temp
  807                        	
  808    00:E5FB  BD 5E 23   	!:		lda.h	_vdc_font_base, x
  809    00:E5FE  29 F0      			and	#$F0
  810    00:E600  05 00      			ora	<__temp
  811    00:E602  9D 5E 23   			sta.h	_vdc_font_base, x
  812    00:E605  60         			rts
  813                        	
  814                        	
  815                        	
  816                        	; ***************************************************************************
  817                        	; ***************************************************************************
  818                        	;
  819                        	; void __fastcall set_font_pal( unsigned char palette<acc> );
  820                        	; void __fastcall sgx_set_font_pal( unsigned char palette<acc> );
  821                        	
  822               0001     		.if	SUPPORT_SGX
  823    00:E606             	_sgx_set_font_pal.1:
  824    00:E606  A2 10      			ldx	#SGX_VDC_OFFSET		; Offset to SGX VDC.
  825    00:E608  F0         			db	$F0			; Turn "clx" into a "beq".
  826                        		.endif
  827                        	
  828    00:E609             	_set_font_pal:					; For compatibility with HuC.
  829    00:E609             	_set_font_pal.1:
  830    00:E609  82         			clx				; Offset to PCE VDC.
  831    00:E60A  0A         			asl	a
  832    00:E60B  0A         			asl	a
  833    00:E60C  0A         			asl	a
  834    00:E60D  0A         			asl	a
  835    00:E60E  85 00      			sta	<__temp
  836                        	
  837    00:E610  BD 5E 23   			lda.h	_vdc_font_base, x
  838    00:E613  29 0F      			and	#$0F
  839    00:E615  05 00      			ora	<__temp
  840    00:E617  9D 5E 23   			sta.h	_vdc_font_base, x
  841    00:E61A  60         			rts
  842                        	
  843                        	
  844                        	
  845                        	; ***************************************************************************
  846                        	; ***************************************************************************
  847                        	;
  848                        	; void __fastcall load_font( char far *font<_bp_bank:_bp>, unsigned char count<_al> );
  849                        	;
  850                        	; void __fastcall load_font( char far *font<_bp_bank:_bp>, unsigned char count<_al>, unsigned int vram<acc> );
  851                        	; void __fastcall sgx_load_font( char far *font<_bp_bank:_bp>, unsigned char count<_al>, unsigned int vram<acc> );
  852                        	;
  853                        	; void __fastcall far_load_font( unsigned char count<_al>, unsigned int vram<acc> );
  854                        	; void __fastcall sgx_far_load_font( unsigned char count<_al>, unsigned int vram<acc> );
  855                        	
  856    00:E61B  AC 41 23   	_load_font.2:	ldy	vdc_bat_limit		; Load the font directly
  857    00:E61E  C8         			iny				; after the BAT (stupid!).
  858    00:E61F  62         			cla
  859    00:E620  80 03      			bra	_load_font.3
  860                        	
  861               0001     		.if	SUPPORT_SGX
  862    00:E622             	_sgx_load_font.3:
  863    00:E622  A2 10      			ldx	#SGX_VDC_OFFSET		; Offset to SGX VDC.
  864    00:E624  F0         			db	$F0			; Turn "clx" into a "beq".
  865                        		.endif
  866                        	
  867    00:E625  82         	_load_font.3:	clx				; Offset to PCE VDC.
  868                        	
  869    00:E626  85 F0      			sta.l	<_di			; Load the font directly
  870    00:E628  84 F1      			sty.h	<_di			; after the BAT (stupid!).
  871                        	
  872    00:E62A  20 E3 E5   			jsr	set_font_addr		; Set xxx_font_base from addr.
  873                        	
  874    00:E62D  A5 F8      			lda	<__al			; Convert #tiles into #words.
  875    00:E62F  64 F9      			stz	<__ah
  876    00:E631  0A         			asl	a
  877    00:E632  26 F9      			rol	<__ah
  878    00:E634  0A         			asl	a
  879    00:E635  26 F9      			rol	<__ah
  880    00:E637  0A         			asl	a
  881    00:E638  26 F9      			rol	<__ah
  882    00:E63A  0A         			asl	a
  883    00:E63B  26 F9      			rol	<__ah
  884    00:E63D  85 F8      			sta	<__al
  885    00:E63F  4C 81 FF   			jmp	load_vram_x
  886                        	
  887    00:E642             			.alias	_far_load_font.2	= _load_font.3
  888    00:E642             			.alias	_sgx_far_load_font.2	= _sgx_load_font.3
  889                        	
  890                        	
  891                        	
  892                        	; ***************************************************************************
  893                        	; ***************************************************************************
  894                        	;
  895                        	; void __fastcall cls();
  896                        	; void __fastcall sgx_cls();
  897                        	;
  898                        	; void __fastcall cls( int tile<acc> );
  899                        	; void __fastcall sgx_cls( int tile<acc> );
  900                        	
  901               0001     		.if	SUPPORT_SGX
  902    00:E642  A2 10      	_sgx_cls:	ldx	#SGX_VDC_OFFSET		; Offset to SGX VDC.
  903    00:E644  F0         			db	$F0			; Turn "clx" into a "beq".
  904                        		.endif
  905                        	
  906    00:E645  82         	_cls:		clx				; Offset to PCE VDC.
  907                        	
  908    00:E646  BD 5D 23   	clear_tty_x:	lda.l	_vdc_font_base, x
  909    00:E649  BC 5E 23   			ldy.h	_vdc_font_base, x
  910    00:E64C  18         			clc
  911    00:E64D  69 20      			adc	#' '
  912    00:E64F  90 07      			bcc	!+
  913    00:E651  C8         			iny
  914    00:E652  80 04      			bra	!+
  915                        	
  916               0001     		.if	SUPPORT_SGX
  917    00:E654  A2 10      	_sgx_cls.1:	ldx	#SGX_VDC_OFFSET		; Offset to SGX VDC.
  918    00:E656  F0         			db	$F0			; Turn "clx" into a "beq".
  919                        		.endif
  920                        	
  921    00:E657  82         	_cls.1:		clx
  922                        	
  923    00:E658  85 F8      	!:		sta.l	<_ax			; VRAM word to write.
  924    00:E65A  84 F9      			sty.h	<_ax
  925    00:E65C  BD 41 23   			lda	vdc_bat_limit, x	; BAT size hi-byte.
  926    00:E65F  1A         			inc	a
  927    00:E660  85 FA      			sta	<_bl
  928    00:E662  4C B9 FE   			jmp	clear_bat_x
  929                        	
  930                        	
  931                        	
  932                        	; ***************************************************************************
  933                        	; ***************************************************************************
  934                        	;
  935                        	; void __fastcall __macro load_default_font( void );
  936                        	; void __fastcall __macro sgx_load_default_font( void );
  937                        	;
  938                        	; Args: _bp, _bp_bank = _farptr to font data mapped into MPR3 & MPR4.
  939                        	; Args: _di = VRAM destination address.
  940                        	; Args: monofont_fg = font color (0..15)
  941                        	; Args: monofont_bg = background color (0..15)
  942                        	; Args: _al = number of tiles (aka characters) 0==256
  943                        	
  944    0B:D4E2             	huc_monofont_x	.proc
  945                        	
  946               2373     			.bss
  947    F8:2373             	monofont_fg:	.ds	1
  948    F8:2374             	monofont_bg:	.ds	1
  949               D4E2     			.code
  950                        	
  951    0B:D4E2  BC 41 23   			ldy	vdc_bat_limit, x	; BAT limit mask hi-byte.
  952    0B:D4E5  C8         			iny
  953    0B:D4E6  62         			cla
  954    0B:D4E7  85 F0      			sta.l	<_di			; Load the font directly
  955    0B:D4E9  84 F1      			sty.h	<_di			; after the BAT (stupid!).
  956                        	
  957    0B:D4EB  20 E3 E5   			jsr	set_font_addr		; Set xxx_font_base from addr.
  958                        	
  959    0B:D4EE  A9 72      			lda.l	#.font
  960    0B:D4F0  85 EC      			sta.l	<_bp
  961    0B:D4F2  A9 D5      			lda.h	#.font
  962    0B:D4F4  85 ED      			sta.h	<_bp
  963                        	
  964    0B:D4F6  A9 60      			lda	#$60			; #characters.
  965    0B:D4F8  85 F8      			sta	<_al
  966                        	
  967    0B:D4FA  20 7F E3   			jsr	set_di_to_mawr
  968                        	
  969    0B:D4FD  AD 73 23   			lda	monofont_fg		; Foreground pixel color.
  970    0B:D500  85 00      			sta	<__temp
  971    0B:D502  AD 74 23   			lda	monofont_bg		; Background pixel color.
  972    0B:D505  DA         			phx
  973    0B:D506  A2 FC      			ldx.l	#_cx			; Create a bit mask for each
  974    0B:D508  9E 00 20   	.bg_loop:	stz	$2000, x		; plane of the background.
  975    0B:D50B  4A         			lsr	a
  976    0B:D50C  90 03      			bcc	.bg_plane
  977    0B:D50E  DE 00 20   			dec	$2000, x
  978    0B:D511  E8         	.bg_plane:	inx
  979    0B:D512  D0 F4      			bne	.bg_loop
  980    0B:D514  FA         			plx
  981                        	
  982    0B:D515  C2         	.tile_loop:	cly
  983                        	
  984    0B:D516  B1 EC      	.plane01:	lda	[_bp], y		; Get font byte.
  985    0B:D518  8F 00 06   			bbs0	<__temp, .set_plane0
  986    0B:D51B  49 FF      	.clr_plane0:	eor	#$FF			; Clr font bits in background.
  987    0B:D51D  25 FC      			and	<_cx + 0
  988    0B:D51F  80 02      			bra	.put_plane0
  989    0B:D521  05 FC      	.set_plane0:	ora	<_cx + 0		; Set font bits in background.
  990    0B:D523  9D 02 02   	.put_plane0:	sta	VDC_DL, x
  991                        	
  992    0B:D526  B1 EC      			lda	[_bp], y		; Get font byte.
  993    0B:D528  9F 00 06   			bbs1	<__temp, .set_plane1
  994    0B:D52B  49 FF      	.clr_plane1:	eor	#$FF			; Clr font bits in background.
  995    0B:D52D  25 FD      			and	<_cx + 1
  996    0B:D52F  80 02      			bra	.put_plane1
  997    0B:D531  05 FD      	.set_plane1:	ora	<_cx + 1		; Set font bits in background.
  998    0B:D533  9D 03 02   	.put_plane1:	sta	VDC_DH, x
  999                        	
 1000    0B:D536  C8         			iny
 1001    0B:D537  C0 08      			cpy	#8
 1002    0B:D539  90 DB      			bcc	.plane01
 1003                        	
 1004    0B:D53B  C2         			cly
 1005                        	
 1006    0B:D53C  B1 EC      	.plane23:	lda	[_bp], y		; Get font byte.
 1007    0B:D53E  AF 00 06   			bbs2	<__temp, .set_plane2
 1008    0B:D541  49 FF      	.clr_plane2:	eor	#$FF			; Clr font bits in background.
 1009    0B:D543  25 FE      			and	<_cx + 2
 1010    0B:D545  80 02      			bra	.put_plane2
 1011    0B:D547  05 FE      	.set_plane2:	ora	<_cx + 2		; Set font bits in background.
 1012    0B:D549  9D 02 02   	.put_plane2:	sta	VDC_DL, x
 1013                        	
 1014    0B:D54C  B1 EC      			lda	[_bp], y		; Get font byte.
 1015    0B:D54E  BF 00 06   			bbs3	<__temp, .set_plane3
 1016    0B:D551  49 FF      	.clr_plane3:	eor	#$FF			; Clr font bits in background.
 1017    0B:D553  25 FF      			and	<_cx + 3
 1018    0B:D555  80 02      			bra	.put_plane3
 1019    0B:D557  05 FF      	.set_plane3:	ora	<_cx + 3		; Set font bits in background.
 1020    0B:D559  9D 03 02   	.put_plane3:	sta	VDC_DH, x
 1021                        	
 1022    0B:D55C  C8         			iny
 1023    0B:D55D  C0 08      			cpy	#8
 1024    0B:D55F  90 DB      			bcc	.plane23
 1025                        	
 1026    0B:D561  A5 EC      			lda.l	<_bp
 1027    0B:D563  69 07      			adc	#8-1
 1028    0B:D565  85 EC      			sta.l	<_bp
 1029    0B:D567  90 02      			bcc	!+
 1030    0B:D569  E6 ED      			inc.h	<_bp
 1031                        	
 1032    0B:D56B  C6 F8      	!:		dec	<_al
 1033    0B:D56D  D0 A6      			bne	.tile_loop
 1034                        	
 1035                        			leave				; All done, phew!
         0B:D56F  4C EF FF   			jmp	leave_proc
 1036                        	
 1037    0B:D572             	.font:		incbin	"data/font8x8-bold-short-iso646-fr.dat", 128
 1038                        	
 1039                        			.endp
 1040                        	
 1041                        	
 1042                        	
 1043                        	; ***************************************************************************
 1044                        	; ***************************************************************************
 1045                        	;
 1046                        	; HuC Text Output
 1047                        	;
 1048                        	; ***************************************************************************
 1049                        	; ***************************************************************************
 1050                        	
 1051                        	
 1052                        	
 1053    01:C638             	vdc_tty_out	.procgroup			; These routines share code!
 1054                        	
 1055                        	; ***************************************************************************
 1056                        	; ***************************************************************************
 1057                        	;
 1058                        	; void __fastcall put_char( unsigned char digit<_bl>, unsigned char bat_x<_dil>, unsigned char bat_y<_dih> );
 1059                        	
 1060               0001     		.if	SUPPORT_SGX
 1061                        	put_char_sgx	.proc
 1067                        			.endp
 1068                        		.endif
 1069                        	
 1070    01:C638             	put_char_vdc	.proc
 1071                        	
 1072    01:C638  82         			clx				; Offset to PCE VDC.
 1073                        	
 1074    01:C639  20 34 E4   			jsr	set_di_xy_mawr
 1075                        	
 1076    01:C63C  62         			cla				; Push EOL marker.
 1077    01:C63D  48         			pha
 1078                        	
 1079    01:C63E  A5 FA      			lda	<_bl
 1080    01:C640  48         			pha				; Push character to output.
 1081    01:C641  80 58      			bra	!output+
 1082                        	
 1083    01:C643             			.ref	put_hex_vdc		; Need put_number_vdc
 1084                        			.endp
 1085                        	
 1086    01:C643             			.alias	_put_char.3		= put_char_vdc
 1087                        	
 1088                        	
 1089                        	
 1090                        	; ***************************************************************************
 1091                        	; ***************************************************************************
 1092                        	;
 1093                        	; void __fastcall put_digit( unsigned char digit<_bl>, unsigned char bat_x<_dil>, unsigned char bat_y<_dih> );
 1094                        	
 1095               0001     		.if	SUPPORT_SGX
 1096                        	put_digit_sgx	.proc
 1102                        			.endp
 1103                        		.endif
 1104                        	
 1105    01:C643             	put_digit_vdc	.proc
 1106                        	
 1107    01:C643  82         			clx				; Offset to PCE VDC.
 1108                        	
 1109    01:C644  20 34 E4   			jsr	set_di_xy_mawr
 1110                        	
 1111    01:C647  62         			cla				; Push EOL marker.
 1112    01:C648  48         			pha
 1113                        	
 1114    01:C649  A5 FA      			lda	<_bl			; Convert hex digit to ASCII.
 1115    01:C64B  29 0F      			and	#$0F
 1116    01:C64D  C9 0A      			cmp	#10
 1117    01:C64F  90 02      			bcc	!+
 1118    01:C651  69 06      			adc	#6
 1119    01:C653  69 30      	!:		adc	#'0'
 1120    01:C655  48         			pha				; Push character to output.
 1121    01:C656  80 43      			bra	!output+
 1122                        	
 1123    01:C658             			.ref	put_hex_vdc		; Need put_number_vdc
 1124                        			.endp
 1125                        	
 1126    01:C658             			.alias	_put_digit.3		= put_digit_vdc
 1127                        	
 1128                        	
 1129                        	
 1130                        	; ***************************************************************************
 1131                        	; ***************************************************************************
 1132                        	;
 1133                        	; void __fastcall put_hex( unsigned int number<_bx>, unsigned char length<_cl>, unsigned char bat_x<_dil>, unsigned char bat_y<_dih> );
 1134                        	
 1135               0001     		.if	SUPPORT_SGX
 1136                        	put_hex_sgx	.proc
 1141                        			.endp
 1142                        		.endif
 1143                        	
 1144    01:C658             	put_hex_vdc	.proc
 1145                        	
 1146    01:C658  82         			clx				; Offset to PCE VDC.
 1147                        	
 1148    01:C659  20 34 E4   			jsr	set_di_xy_mawr
 1149                        	
 1150    01:C65C  A4 FC      			ldy	<_cl			; Total #characters to print,
 1151    01:C65E  F0 3E      			beq	!exit+			; NOT minimum #characters!
 1152                        	
 1153    01:C660  86 00      			stx	<__temp			; Preserve which VDC.
 1154                        	
 1155    01:C662  82         			clx				; Push EOL marker.
 1156    01:C663  DA         			phx
 1157                        	
 1158    01:C664  B5 FA      	.hex_byte:	lda.l	<_bx, x			; Convert hex digit to ASCII.
 1159    01:C666  29 0F      			and	#$0F
 1160    01:C668  C9 0A      			cmp	#10
 1161    01:C66A  90 02      			bcc	!+
 1162    01:C66C  69 06      			adc	#6
 1163    01:C66E  69 30      	!:		adc	#'0'
 1164    01:C670  48         			pha				; Push character to output.
 1165    01:C671  88         			dey
 1166    01:C672  F0 15      			beq	.hex_done
 1167                        	
 1168    01:C674  B5 FA      			lda.l	<_bx, x			; Convert hex digit to ASCII.
 1169    01:C676  4A         			lsr	a
 1170    01:C677  4A         			lsr	a
 1171    01:C678  4A         			lsr	a
 1172    01:C679  4A         			lsr	a
 1173    01:C67A  C9 0A      			cmp	#10
 1174    01:C67C  90 02      			bcc	!+
 1175    01:C67E  69 06      			adc	#6
 1176    01:C680  69 30      	!:		adc	#'0'
 1177    01:C682  48         			pha				; Push character to output.
 1178    01:C683  88         			dey
 1179    01:C684  F0 03      			beq	.hex_done
 1180                        	
 1181    01:C686  E8         			inx
 1182    01:C687  80 DB      			bra	.hex_byte
 1183                        	
 1184    01:C689  A6 00      	.hex_done:	ldx	<__temp			; Restore which VDC.
 1185    01:C68B  80 0E      			bra	!output+
 1186                        	
 1187    01:C68D  18         	.write:		clc
 1188    01:C68E  7D 5D 23   			adc.l	_vdc_font_base, x
 1189    01:C691  9D 02 02   			sta	VDC_DL, x
 1190    01:C694  62         			cla
 1191    01:C695  7D 5E 23   			adc.h	_vdc_font_base, x
 1192    01:C698  9D 03 02   			sta	VDC_DH, x
 1193                        	
 1194    01:C69B  68         	!output:	pla				; Pop the digits and output.
 1195    01:C69C  D0 EF      			bne	.write
 1196                        	
 1197                        	!exit:		leave				; All done!
         01:C69E  4C EF FF   			jmp	leave_proc
 1198                        	
 1199                        			.endp
 1200                        	
 1201    01:C6A1             			.alias	_put_hex.4 = put_hex_vdc
 1202                        	
 1203                        	
 1204                        	
 1205                        	; ***************************************************************************
 1206                        	; ***************************************************************************
 1207                        	;
 1208                        	; void __fastcall put_number( unsigned int number<_bx>, unsigned char length<_cl>, unsigned char bat_x<_dil>, unsigned char bat_y<_dih> );
 1209                        	
 1210               0001     		.if	SUPPORT_SGX
 1211                        	put_number_sgx	.proc
 1216                        			.endp
 1217                        		.endif
 1218                        	
 1219                        	put_number_vdc	.proc
 1285                        			.endp
 1286                        	
 1287    01:C6A1             			.alias	_put_number.4 = put_number_vdc
 1288                        	
 1289                        	
 1290                        	
 1291                        	; ***************************************************************************
 1292                        	; ***************************************************************************
 1293                        	;
 1294                        	; void __fastcall put_raw( unsigned int data<_bx>, unsigned char bat_x<_dil>, unsigned char bat_y<_dih> );
 1295                        	
 1296               0001     		.if	SUPPORT_SGX
 1297                        	put_raw_sgx	.proc
 1302                        			.endp
 1303                        		.endif
 1304                        	
 1305                        	put_raw_vdc	.proc
 1318                        			.endp
 1319                        	
 1320    01:C6A1             			.alias	_put_raw.3		= put_raw_vdc
 1321                        	
 1322                        			.endprocgroup			; vdc_tty_out
 1323                        	
 1324                        	
 1325                        	
 1326                        	; ***************************************************************************
 1327                        	; ***************************************************************************
 1328                        	;
 1329                        	; void __fastcall put_string( unsigned char *string<_bp>, unsigned char bat_x<_dil>, unsigned char bat_y<_dih> );
 1330                        	;
 1331                        	; N.B. This is not a .proc right now because it is called from procedures
 1332                        	; that contain embedded strings, and the string aren't banked in before
 1333                        	; printing (yet).
 1334                        	
 1335               0001     		.if	SUPPORT_SGX
 1336    00:E665             	_sgx_put_string.3:
 1337    00:E665  A2 10      			ldx	#SGX_VDC_OFFSET		; Offset to SGX VDC.
 1338    00:E667  F0         			db	$F0			; Turn "clx" into a "beq".
 1339                        		.endif
 1340                        	
 1341    00:E668  82         	_put_string.3:	clx				; Offset to PCE VDC.
 1342                        	
 1343    00:E669  20 34 E4   			jsr	set_di_xy_mawr
 1344                        	
 1345    00:E66C  C2         			cly
 1346    00:E66D  B1 EC      	.chr_loop:	lda	[_bp], y
 1347    00:E66F  F0 15      			beq	.done
 1348                        	
 1349    00:E671  18         			clc
 1350    00:E672  7D 5D 23   			adc.l	_vdc_font_base, x
 1351    00:E675  9D 02 02   			sta	VDC_DL, x
 1352    00:E678  62         			cla
 1353    00:E679  7D 5E 23   			adc.h	_vdc_font_base, x
 1354    00:E67C  9D 03 02   			sta	VDC_DH, x
 1355                        	
 1356    00:E67F  C8         			iny
 1357    00:E680  D0 EB      			bne	.chr_loop
 1358    00:E682  E6 ED      			inc.h	<_bp
 1359    00:E684  80 E7      			bra	.chr_loop
 1360                        	
 1361    00:E686  60         	.done:		rts
 1362                        	
 1363                        	
 1364                        	
 1365                        	; ***************************************************************************
 1366                        	; ***************************************************************************
 1367                        	;
 1368                        	; void __fastcall set_color_rgb( unsigned int index<VCE_CTA>, unsigned char r<_al>, unsigned char g<_ah>, unsigned char b<acc> );
 1369                        	;
 1370                        	; r:	red	RED:	bit 3-5
 1371                        	; g:	green	GREEN:	bit 6-8
 1372                        	; b:	blue	BLUE:	bit 0-2
 1373                        	
 1374    00:E687             	_set_color_rgb.4:
 1375                        	;		and	#7
 1376    00:E687  85 00      			sta	<__temp
 1377    00:E689  A5 F8      			lda	<_al
 1378                        	;		and	#7
 1379    00:E68B  0A         			asl	a
 1380    00:E68C  0A         			asl	a
 1381    00:E68D  0A         			asl	a
 1382    00:E68E  05 00      			ora	<__temp
 1383    00:E690  0A         			asl	a
 1384    00:E691  0A         			asl	a
 1385    00:E692  85 00      			sta	<__temp
 1386    00:E694  A5 F9      			lda	<_ah
 1387                        	;		and	#7
 1388    00:E696  4A         			lsr	a
 1389    00:E697  66 00      			ror	<__temp
 1390    00:E699  4A         			lsr	a
 1391    00:E69A  66 00      			ror	<__temp
 1392    00:E69C  A8         			tay
 1393    00:E69D  A5 00      			lda	<__temp
 1394    00:E69F  8D 04 04   			sta.l	VCE_CTW
 1395    00:E6A2  8C 05 04   			sty.h	VCE_CTW
 1396    00:E6A5  60         			rts
                             #[2]   "..\..\..\include\hucc\hucc-final.asm"
   60                        		.endif
   61                        	
   62               0001     		.ifdef	HUCC_USES_STRING		; Set in hucc_string.h
                             #[3]   "..\..\..\include\hucc\hucc-string.asm"
   63                        			include	"hucc-string.asm"
    1                        	; ***************************************************************************
    2                        	; ***************************************************************************
    3                        	;
    4                        	; hucc-string.asm
    5                        	;
    6                        	; Not-quite-standard, but fast, replacements for <string.h>.
    7                        	;
    8                        	; Copyright John Brandwood 2024.
    9                        	;
   10                        	; Distributed under the Boost Software License, Version 1.0.
   11                        	; (See accompanying file LICENSE_1_0.txt or copy at
   12                        	;  http://www.boost.org/LICENSE_1_0.txt)
   13                        	;
   14                        	; ***************************************************************************
   15                        	; ***************************************************************************
   16                        	;
   17                        	; !!! WARNING : non-standard return values !!!
   18                        	;
   19                        	; Strings are limited to a maximum of 255 characters (+ the terminator)!
   20                        	;
   21                        	; The memcpy(), strcpy() and strcat() functions do NOT return the destination
   22                        	; address, and they are declared "void" to check that the value is not used.
   23                        	;
   24                        	; mempcpy() is provided which returns the end address instead of the starting
   25                        	; address, because this is typically more useful.
   26                        	;
   27                        	; Please note that both memcpy() and memset() are implemented using a TII for
   28                        	; speed, and so the length should be < 16 bytes if used in time-critical bits
   29                        	; of code (such as when using a split screen) because they delay interrupts.
   30                        	;
   31                        	; strncpy() and strncat() are not provided, because strncpy() was not created
   32                        	; for the purpose of avoiding string overruns, and strncat() is just a poorly
   33                        	; designed function.
   34                        	;
   35                        	; POSIX strlcpy() and strlcat() are provided instead, but once again they are
   36                        	; slightly non-standard in that the return value when there is an overflow is
   37                        	; the buffer size (so that the overflow can be detected), instead of the full
   38                        	; size of the destination string that was too big to fit in the buffer.
   39                        	;
   40                        	; ***************************************************************************
   41                        	; ***************************************************************************
   42                        	
   43                        	
   44                        	
   45                        	; ***************************************************************************
   46                        	; ***************************************************************************
   47                        	;
   48                        	; void __fastcall strcpy( char *destination<_di>, char *source<_bp> );
   49                        	; void __fastcall strcat( char *destination<_di>, char *source<_bp> );
   50                        	;
   51                        	; unsigned int __fastcall strlcpy( char *destination<_di>, char *source<_bp>, unsigned char size<acc> );
   52                        	; unsigned int __fastcall strlcat( char *destination<_di>, char *source<_bp>, unsigned char size<acc> );
   53                        	; unsigned int __fastcall strlen( char *source<_bp> );
   54                        	;
   55                        	; NOT WORKING YET (needs compiler changes) ...
   56                        	;
   57                        	; void __fastcall strcpy( char *destination<_di>, char __far *source<_bp_bank:_bp> );
   58                        	; void __fastcall strcat( char *destination<_di>, char __far *source<_bp_bank:_bp> );
   59                        	;
   60                        	; unsigned int __fastcall strlcpy( char *destination<_di>, char __far *source<_bp_bank:_bp>, unsigned char size<acc> );
   61                        	; unsigned int __fastcall strlcat( char *destination<_di>, char __far *source<_bp_bank:_bp>, unsigned char size<acc> );
   62                        	; unsigned int __fastcall strlen( char __far *source<_bp_bank:_bp> );
   63                        	
   64    00:E6A6  62         	_strcat:	cla				; Max string length == 256!
   65    00:E6A7  A0 01      			ldy.h	#256
   66                        	
   67    00:E6A9  AA         	_strlcat:	tax				; X = buffer length (1..256).
   68                        	
   69               0000     		.ifdef	_DEBUG
   74                        		.endif
   75                        	
   76    00:E6AA  43 08      			tma3				; Preserve MPR3 and MPR4.
   77    00:E6AC  48         			pha
   78    00:E6AD  43 10      			tma4
   79    00:E6AF  48         			pha
   80                        	
   81                        	;		ldy	<_bp_bank		; Map the source string.
   82                        	;		beq	.no_bank
   83                        	;		jsr	map_bp_to_mpr34
   84                        	
   85    00:E6B0  C2         	.no_bank:	cly
   86                        	
   87    00:E6B1  B1 F0      	.find:		lda	[_di], y		; Find the end of the string.
   88    00:E6B3  F0 08      			beq	.adjust
   89    00:E6B5  C8         			iny
   90    00:E6B6  CA         			dex
   91    00:E6B7  D0 F8      			bne	.find
   92    00:E6B9  98         			tya				; A:Y = buffer length.
   93    00:E6BA  62         			cla
   94    00:E6BB  80 28      			bra	str_overflow
   95                        	
   96    00:E6BD  98         	.adjust:	tya				; Subtract Y from _bp so that
   97    00:E6BE  49 FF      			eor	#$FF			; _bp and _di use the same Y.
   98    00:E6C0  38         			sec
   99    00:E6C1  65 EC      			adc.l	<_bp
  100    00:E6C3  85 EC      			sta.l	<_bp
  101    00:E6C5  B0 0F      			bcs	str_copy
  102    00:E6C7  C6 ED      			dec.h	<_bp
  103    00:E6C9  80 0B      			bra	str_copy
  104                        	
  105                        			;
  106                        	
  107    00:E6CB  62         	_strcpy:	cla				; Max string length == 256!
  108    00:E6CC  A0 01      			ldy.h	#256
  109                        	
  110    00:E6CE  AA         	_strlcpy:	tax				; X = buffer length (1..256).
  111                        	
  112               0000     		.ifdef	_DEBUG
  117                        		.endif
  118                        	
  119    00:E6CF  43 08      			tma3				; Preserve MPR3 and MPR4.
  120    00:E6D1  48         			pha
  121    00:E6D2  43 10      			tma4
  122    00:E6D4  48         			pha
  123                        	
  124                        	;		ldy	<_bp_bank		; Map the source string.
  125                        	;		beq	.no_bank
  126                        	;		jsr	map_bp_to_mpr34
  127                        	
  128    00:E6D5  C2         	.no_bank:	cly
  129                        	
  130    00:E6D6  B1 EC      	str_copy:	lda	[_bp], y
  131    00:E6D8  91 F0      			sta	[_di], y
  132    00:E6DA  F0 1E      			beq	str_exit		; A:Y = string length.
  133    00:E6DC  C8         			iny
  134    00:E6DD  CA         			dex
  135    00:E6DE  D0 F6      			bne	str_copy
  136                        	
  137    00:E6E0  88         			dey
  138    00:E6E1  62         			cla
  139    00:E6E2  91 F0      			sta	[_di], y
  140    00:E6E4  C8         			iny				; A:Y = buffer length.
  141    00:E6E5  D0 13      	str_overflow:	bne	str_exit
  142    00:E6E7  1A         			inc	a			; A:Y = buffer length = 256.
  143    00:E6E8  80 10      			bra	str_exit
  144                        	
  145                        			;
  146                        	
  147    00:E6EA  43 08      	_strlen:	tma3
  148    00:E6EC  48         			pha
  149    00:E6ED  43 10      			tma4
  150    00:E6EF  48         			pha
  151                        	
  152                        	;		ldy	<_bp_bank
  153                        	;		beq	.no_bank
  154                        	;		jsr	map_bp_to_mpr34
  155                        	
  156    00:E6F0  C2         	.no_bank:	cly
  157                        	
  158    00:E6F1  B1 EC      	.find:		lda	[_bp], y
  159    00:E6F3  F0 05      			beq	str_exit
  160    00:E6F5  C8         			iny
  161    00:E6F6  D0 F9      			bne	.find
  162    00:E6F8  A9 01      			lda.h	#256			; A:Y = overflow length = 256.
  163                        	
  164    00:E6FA  AA         	str_exit:	tax				; X:Y = string or buffer length.
  165                        	
  166    00:E6FB  68         			pla				; Restore MPR3 and MPR4.
  167    00:E6FC  53 10      			tam4
  168    00:E6FE  68         			pla
  169    00:E6FF  53 08      			tam3
  170                        	
  171    00:E701  8A         			txa				; A:Y = string or buffer length.
  172    00:E702  42         			say				; Y:A = string or buffer length.
  173                        	
  174    00:E703  60         			rts
  175                        	
  176    00:E704             			.alias	_strlen.1		= _strlen
  177    00:E704             			.alias	_strcpy.2		= _strcpy
  178    00:E704             			.alias	_strcat.2		= _strcat
  179    00:E704             			.alias	_strlcpy.3		= _strlcpy
  180    00:E704             			.alias	_strlcat.3		= _strlcat
  181                        	
  182                        	
  183                        	
  184                        	; ***************************************************************************
  185                        	; ***************************************************************************
  186                        	;
  187                        	; void __fastcall memcpy( unsigned char *destination<ram_tii_dst>, unsigned char  *source<ram_tii_src>, unsigned int count<acc> );
  188                        	; unsigned char * __fastcall mempcpy( unsigned char *destination<ram_tii_dst>, unsigned char  *source<ram_tii_src>, unsigned int count<acc> );
  189                        	;
  190                        	; void __fastcall farmemcpy( unsigned char *destination<ram_tii_dst>, unsigned char __far *source<_bp_bank:ram_tii_src>, unsigned int count<acc> );
  191                        	; unsigned char * __fastcall farmempcpy( unsigned char *destination<ram_tii_dst>, unsigned char __far *source<_bp_bank:ram_tii_src>, unsigned int count<acc> );
  192                        	;
  193                        	; void __fastcall far_memcpy( unsigned char *destination<ram_tii_dst>, unsigned int count<acc> );
  194                        	; unsigned char * __fastcall far_mempcpy( unsigned char *destination<ram_tii_dst>, unsigned int count<acc> );
  195                        	;
  196                        	
  197    00:E704             	_memcpy.3:
  198    00:E704  64 02      	_mempcpy.3:	stz	<_bp_bank		; Map the source memory.
  199                        	
  200    00:E706             	_farmemcpy.3:
  201    00:E706  8C FE 22   	_farmempcpy.3:	sty.h	ram_tii_len		; Check for zero length.
  202    00:E709  8D FD 22   			sta.l	ram_tii_len
  203    00:E70C  0D FE 22   			ora.h	ram_tii_len
  204    00:E70F  F0 18      			beq	.zero_length
  205                        	
  206    00:E711  43 08      			tma3				; Preserve MPR3 and MPR4.
  207    00:E713  48         			pha
  208    00:E714  43 10      			tma4
  209    00:E716  48         			pha
  210                        	
  211    00:E717  A5 02      			lda	<_bp_bank		; Map the source memory.
  212    00:E719  F0 05      			beq	.no_bank
  213                        	
  214    00:E71B  53 08      			tam3				; Put bank into MPR3.
  215    00:E71D  1A         			inc	a
  216    00:E71E  53 10      			tam4				; Put next into MPR4.
  217                        	
  218                        	;		lda.h	ram_tii_src		; Remap ptr to MPR3.
  219                        	;		and	#$1F
  220                        	;		ora	#$60
  221                        	;		sta.h	ram_tii_src
  222                        	
  223    00:E720  20 F8 22   	.no_bank:	jsr	ram_tii			; Copy the memory.
  224                        	
  225    00:E723  68         			pla				; Restore MPR3 and MPR4.
  226    00:E724  53 10      			tam4
  227    00:E726  68         			pla
  228    00:E727  53 08      			tam3
  229                        	
  230    00:E729  18         	.zero_length:	clc				; Return the end address
  231    00:E72A  AD FB 22   			lda.l	ram_tii_dst		; like mempcpy().
  232    00:E72D  6D FD 22   			adc.l	ram_tii_len
  233    00:E730  A8         			tay
  234    00:E731  AD FC 22   			lda.h	ram_tii_dst
  235    00:E734  6D FE 22   			adc.h	ram_tii_len
  236    00:E737  42         			say
  237                        	
  238    00:E738  60         			rts
  239                        	
  240    00:E739             			.alias	_far_memcpy.2		= _farmemcpy.3
  241    00:E739             			.alias	_far_mempcpy.2		= _farmempcpy.3
  242                        	
  243                        	
  244                        	
  245                        	; ***************************************************************************
  246                        	; ***************************************************************************
  247                        	;
  248                        	; void __fastcall memset( unsigned char *destination<ram_tii_src>, unsigned char value<_al>, unsigned int count<acc> );
  249                        	
  250    00:E739  C9 00      	_memset:	cmp	#0			; Decrement the length, check
  251    00:E73B  D0 05      			bne	!+			; for zero and set C. 
  252    00:E73D  C0 00      			cpy	#0
  253    00:E73F  F0 23      			beq	.zero_length
  254    00:E741  88         			dey
  255    00:E742  3A         	!:		dec	a
  256    00:E743  8D FD 22   			sta.l	ram_tii_len
  257    00:E746  8C FE 22   			sty.h	ram_tii_len
  258                        	
  259    00:E749  AD F9 22   			lda.l	ram_tii_src		; ram_tii_dst = ram_tii_src + 1
  260    00:E74C  85 88      			sta.l	<__ptr
  261    00:E74E  69 00      			adc	#0
  262    00:E750  8D FB 22   			sta.l	ram_tii_dst
  263    00:E753  AD FA 22   			lda.h	ram_tii_src
  264    00:E756  85 89      			sta.h	<__ptr
  265    00:E758  69 00      			adc	#0
  266    00:E75A  8D FC 22   			sta.h	ram_tii_dst
  267                        	
  268    00:E75D  A5 F8      			lda	<_al			; Set the fill value.
  269    00:E75F  92 88      			sta	[__ptr]
  270                        	
  271    00:E761  4C F8 22   			jmp	ram_tii			; Copy the memory.
  272                        	
  273    00:E764  60         	.zero_length:	rts
  274                        	
  275    00:E765             			.alias	_memset.3		= _memset
  276                        	
  277                        	
  278                        	
  279                        	; ***************************************************************************
  280                        	; ***************************************************************************
  281                        	;
  282                        	; int __fastcall strcmp( char *string1<_di>, char *string2<_bp> );
  283                        	; int __fastcall strncmp( char *string1<_di>, char *string2<_bp>, unsigned int count<_ax> );
  284                        	;
  285                        	; int __fastcall __macro memcmp( unsigned char *string1<_di>, unsigned char *string2<_bp>, unsigned int count<_ax> );
  286                        	; int __fastcall farmemcmp( unsigned char *string1<_di>, unsigned char __far *string2<_bp_bank:_bp>, unsigned int count<_ax> );
  287                        	; int __fastcall far_memcmp( unsigned char *string1<_di>, unsigned int count<_ax> );
  288                        	;
  289                        	;  0 	if strings are equal
  290                        	;  1 	if the first non-matching character in string1 > string2 (in ASCII).
  291                        	; -1 	if the first non-matching character in string1 < string2 (in ASCII).
  292                        	
  293    01:C847             	hucc_memcmp	.procgroup
  294                        	
  295                        	_strcmp.2	.proc
  300                        			.endp				; Fall through.
  301                        	
  302    01:C847             	_strncmp.3	.proc
  303    01:C847  64 02      			stz	<_bp_bank		; Assume strings are mapped.
  304    01:C849  89 40      			bit	#$40			; Set the V bit for strcmp.
  305    01:C84B  50         			db	$50			; Turn "clv" into "bvc".
  306    01:C84C             			.ref	_farmemcmp.3		; Don't strip _farmemcmp.3!
  307                        			.endp				; Fall through.
  308                        	
  309    01:C84C             	_farmemcmp.3	.proc
  310    01:C84C  B8         			clv				; Clr the V bit for memcmp.
  311                        	
  312    01:C84D  43 08      			tma3				; Preserve MPR3 and MPR4.
  313    01:C84F  48         			pha
  314    01:C850  43 10      			tma4
  315    01:C852  48         			pha
  316                        	
  317    01:C853  A4 02      			ldy	<_bp_bank		; Map string2.
  318    01:C855  F0 03      			beq	.no_bank
  319                        	
  320    01:C857  20 3B E3   			jsr	map_bp_to_mpr34
  321                        	
  322    01:C85A  C2         	.no_bank:	cly
  323                        	
  324    01:C85B  A6 F8      			ldx.l	<_ax			; Increment length.l
  325    01:C85D  E8         			inx
  326    01:C85E  CA         	.loop:		dex				; Decrement length.l
  327    01:C85F  F0 17      			beq	.page
  328    01:C861  B1 F0      	.test:		lda	[_di], y		; string1 - string2
  329    01:C863  D1 EC      			cmp	[_bp], y
  330    01:C865  90 1E      			bcc	.return_neg		; string1 < string2 
  331    01:C867  D0 17      			bne	.return_pos		; string1 > string2
  332    01:C869  50 04      			bvc	!+			; Only check for end-of-string
  333    01:C86B  C9 00      			cmp	#0			; if the V flag is set.
  334    01:C86D  F0 0D      			beq	.return_same
  335    01:C86F  C8         	!:		iny
  336    01:C870  D0 EC      			bne	.loop
  337    01:C872  E6 F1      			inc.h	<_di
  338    01:C874  E6 ED      			inc.h	<_bp			; Limited to 8KB maximum!
  339                        	;		jsr	inc.h_bp_mpr34
  340    01:C876  80 E6      			bra	.loop
  341                        	
  342    01:C878  C6 F9      	.page:		dec.h	<_ax			; Decrement length.h 
  343    01:C87A  10 E5      			bpl	.test			; Limit comparison to 32KB.
  344                        	;		bra	cmp_same
  345                        	
  346    01:C87C  82         	.return_same:	clx				; Return code in Y:X, X -> A.
  347    01:C87D  C2         			cly
  348    01:C87E  80 09      			bra	!+
  349                        	
  350    01:C880  A2 01      	.return_pos:	ldx	#$01			; Return code in Y:X, X -> A.
  351    01:C882  C2         			cly
  352    01:C883  80 04      			bra	!+
  353                        	
  354    01:C885  A2 FF      	.return_neg:	ldx	#$FF			; Return code in Y:X, X -> A.
  355    01:C887  A0 FF      			ldy	#$FF
  356                        	
  357    01:C889  68         	!:		pla				; Restore MPR3 and MPR4.
  358    01:C88A  53 10      			tam4
  359    01:C88C  68         			pla
  360    01:C88D  53 08      			tam3
  361                        	
  362                        			leave				; Return and copy X -> A.
         01:C88F  4C EF FF   			jmp	leave_proc
  363                        	
  364                        			.endp
  365                        	
  366                        			.endprocgroup			; hucc_memcmp
  367                        	
  368    00:E765             			.alias	_far_memcmp.2		= _farmemcmp.3
                             #[2]   "..\..\..\include\hucc\hucc-final.asm"
   64                        		.endif
   65                        	
   66               0001     		.ifdef	HUCC_USES_NEW_SCROLL		; Set in hucc_scroll.h
                             #[3]   "..\..\..\include\hucc\hucc-scroll.asm"
   67                        			include	"hucc-scroll.asm"
    1                        	; ***************************************************************************
    2                        	; ***************************************************************************
    3                        	;
    4                        	; hucc-scroll.asm
    5                        	;
    6                        	; Routines for a fast split-screen scrolling system.
    7                        	;
    8                        	; Copyright John Brandwood 2024.
    9                        	;
   10                        	; Distributed under the Boost Software License, Version 1.0.
   11                        	; (See accompanying file LICENSE_1_0.txt or copy at
   12                        	;  http://www.boost.org/LICENSE_1_0.txt)
   13                        	;
   14                        	; ***************************************************************************
   15                        	; ***************************************************************************
   16                        	;
   17                        	; The maximum number of splits for each screen layer is set in your project's
   18                        	; "hucc-config.inc" file, with the library having a limit of 128-per-layer.
   19                        	;
   20                        	; Your first active split must be defined to start at screen line 0, and then
   21                        	; the rest of the active splits must be in increasing line order to match the
   22                        	; way that the PC Engine displays the output image.
   23                        	;
   24                        	; You can have disabled splits interleaved with your active splits.
   25                        	;
   26                        	; Splits that are normally disabled can be used to create full screen effects
   27                        	; such as bouncing the screen up and down by adding blank areas at the top or
   28                        	; bottom of the screen, and then rapidly changing the height of those areas.
   29                        	;
   30                        	; ***************************************************************************
   31                        	; ***************************************************************************
   32                        	
   33                        	
   34                        	
   35               0000     		.ifndef	HUCC_PCE_SPLITS
   37                        		.endif
   38                        	
   39               0000     		.ifndef	HUCC_SGX_SPLITS
   41                        		.endif
   42                        	
   43               0000     		.if	(HUCC_PCE_SPLITS < 2) || (HUCC_PCE_SPLITS > 128)
   45                        		.endif
   46                        	
   47               0000     		.if	(HUCC_SGX_SPLITS < 2) || (HUCC_SGX_SPLITS > 128)
   49                        		.endif
   50                        	
   51               0144     	HUCC_1ST_RCR	=	$144
   52               00E0     	HUCC_SCR_HEIGHT	=	224
   53                        	
   54               E765     			.code
   55                        	
   56                        	
   57                        	
   58                        	; ***************************************************************************
   59                        	; ***************************************************************************
   60                        	;
   61                        	; void __fastcall scroll_split( unsigned char index<_al>, unsigned char screen_line<_ah>, unsigned int bat_x<_bx>, unsigned int bat_y<_cx>, unsigned char display_flags<_dl> );
   62                        	; void __fastcall sgx_scroll_split( unsigned char index<_al>, unsigned char screen_line<_ah>, unsigned int bat_x<_bx>, unsigned int bat_y<_cx>, unsigned char display_flags<_dl> );
   63                        	;
   64                        	; set screen scrolling
   65                        	
   66                        			.proc	_scroll_split.5
  143                        			.endp
  144                        	
  145               0001     		.if	SUPPORT_SGX
  146                        	
  147    01:C450             			.proc	_sgx_scroll_split.5
  148                        	
  149    01:C450  08         			php				; Disable interrupts while
  150    01:C451  78         			sei				; updating this structure.
  151                        	
  152    01:C452  A6 F8      			ldx	<_al			; Region number.
  153    01:C454  E0 08      			cpx	#HUCC_SGX_SPLITS
  154    01:C456  B0 FE      	.hang:		bcs	.hang			; Better a hang than a crash!
  155                        	
  156    01:C458  BD F6 23   			lda	sgx_region_sel, x	; Update the parameter copy
  157    01:C45B  5D FE 23   			eor	sgx_region_new, x	; that is not displayed now.
  158    01:C45E  D0 3B      			bne	.regionA
  159                        	
  160    01:C460  A5 F9      	.regionB:	lda	<_ah			; Scanline (i.e. top).
  161    01:C462  C9 E0      			cmp	#HUCC_SCR_HEIGHT	; Skip if offscreen.
  162    01:C464  B0 31      			bcs	!done+
  163    01:C466  9D 1E 24   			sta	sgx_regionB_rcr, x
  164                        	
  165    01:C469  C9 00      			cmp	#0			; Either Y at top of the frame
  166    01:C46B  F0 01      			beq	!+			; or Y-1 because the RCR code
  167    01:C46D  18         			clc				; sets it on the line before.
  168    01:C46E  A5 FC      	!:		lda.l	<_cx
  169    01:C470  E9 00      			sbc	#0
  170    01:C472  9D 4E 24   			sta	sgx_regionB_yl, x
  171    01:C475  A5 FD      			lda.h	<_cx
  172    01:C477  E9 00      			sbc	#0
  173    01:C479  9D 5E 24   			sta	sgx_regionB_yh, x
  174                        	
  175    01:C47C  A5 FA      			lda.l	<_bx
  176    01:C47E  9D 2E 24   			sta	sgx_regionB_xl, x
  177    01:C481  A5 FB      			lda.h	<_bx
  178    01:C483  9D 3E 24   			sta	sgx_regionB_xh, x
  179                        	
  180    01:C486  A5 FE      			lda	<_dl
  181    01:C488  29 C0      			and	#$C0			; Flags (mark it as enabled).
  182    01:C48A  09 0C      			ora	#$0C
  183    01:C48C  9D 0E 24   			sta	sgx_regionB_crl, x
  184                        	
  185    01:C48F  A9 01      			lda	#1			; Mark that we've changed the
  186    01:C491  9D FE 23   			sta	sgx_region_new, x	; selected region.
  187    01:C494  9D F6 23   			sta	sgx_region_sel, x
  188                        	
  189    01:C497  28         	!done:		plp				; Restore interrupts.
  190                        			leave				; All done!
         01:C498  4C EF FF   			jmp	leave_proc
  191                        	
  192    01:C49B  A5 F9      	.regionA:	lda	<_ah			; Scanline (i.e. top).
  193    01:C49D  C9 E0      			cmp	#HUCC_SCR_HEIGHT	; Skip if offscreen.
  194    01:C49F  B0 31      			bcs	!done+
  195    01:C4A1  9D 16 24   			sta	sgx_regionA_rcr, x
  196                        	
  197    01:C4A4  C9 00      			cmp	#0			; Either Y at top of the frame
  198    01:C4A6  F0 01      			beq	!+			; or Y-1 because the RCR code
  199    01:C4A8  18         			clc				; sets it on the line before.
  200    01:C4A9  A5 FC      	!:		lda.l	<_cx
  201    01:C4AB  E9 00      			sbc	#0
  202    01:C4AD  9D 46 24   			sta	sgx_regionA_yl, x
  203    01:C4B0  A5 FD      			lda.h	<_cx
  204    01:C4B2  E9 00      			sbc	#0
  205    01:C4B4  9D 56 24   			sta	sgx_regionA_yh, x
  206                        	
  207    01:C4B7  A5 FA      			lda.l	<_bx
  208    01:C4B9  9D 26 24   			sta	sgx_regionA_xl, x
  209    01:C4BC  A5 FB      			lda.h	<_bx
  210    01:C4BE  9D 36 24   			sta	sgx_regionA_xh, x
  211                        	
  212    01:C4C1  A5 FE      			lda	<_dl
  213    01:C4C3  29 C0      			and	#$C0			; Flags (mark it as enabled).
  214    01:C4C5  09 0C      			ora	#$0C
  215    01:C4C7  9D 06 24   			sta	sgx_regionA_crl, x
  216                        	
  217    01:C4CA  A9 01      			lda	#1			; Mark that we've changed the
  218    01:C4CC  9D FE 23   			sta	sgx_region_new, x	; selected region.
  219    01:C4CF  9E F6 23   			stz	sgx_region_sel, x
  220                        	
  221    01:C4D2  28         	!done:		plp				; Restore interrupts.
  222                        			leave				; All done!
         01:C4D3  4C EF FF   			jmp	leave_proc
  223                        	
  224                        			.endp
  225                        	
  226                        		.endif	SUPPORT_SGX
  227                        	
  228                        	
  229                        	
  230                        	; ***************************************************************************
  231                        	; ***************************************************************************
  232                        	;
  233                        	; void __fastcall disable_split( unsigned char index<acc> );
  234                        	; void __fastcall sgx_disable_split( unsigned char index<acc> );
  235                        	;
  236                        	; disable screen scrolling for a scroll region
  237                        	
  238    00:E765             	_disable_split.1:
  239    00:E765  08         			php				; Disable interrupts while
  240    00:E766  78         			sei				; updating this structure.
  241                        	
  242    00:E767  C9 08      			cmp	#HUCC_PCE_SPLITS	; Better a hang than a crash!
  243    00:E769  B0 FE      	.hang:		bcs	.hang
  244    00:E76B  AA         			tax
  245                        	
  246    00:E76C  BD 75 23   			lda	vdc_region_sel, x	; Update the parameter copy
  247    00:E76F  5D 7D 23   			eor	vdc_region_new, x	; that is not displayed now.
  248    00:E772  D0 0D      			bne	.regionA
  249                        	
  250    00:E774  9E 8D 23   	.regionB:	stz	vdc_regionB_crl, x	; Region disabled if $00.
  251                        	
  252    00:E777  A9 01      			lda	#1			; Mark that we've changed the
  253    00:E779  9D 7D 23   			sta	vdc_region_new, x	; selected region.
  254    00:E77C  9D 75 23   			sta	vdc_region_sel, x
  255                        	
  256    00:E77F  28         			plp				; Restore interrupts.
  257    00:E780  60         			rts
  258                        	
  259    00:E781  9E 85 23   	.regionA:	stz	vdc_regionA_crl, x	; Region disabled if $00.
  260                        	
  261    00:E784  A9 01      			lda	#1			; Mark that we've changed the
  262    00:E786  9D 7D 23   			sta	vdc_region_new, x	; selected region.
  263    00:E789  9E 75 23   			stz	vdc_region_sel, x
  264                        	
  265    00:E78C  28         			plp				; Restore interrupts.
  266    00:E78D  60         			rts
  267                        	
  268               0001     		.if	SUPPORT_SGX
  269                        	
  270    00:E78E             	_sgx_disable_split.1:
  271    00:E78E  08         			php				; Disable interrupts while
  272    00:E78F  78         			sei				; updating this structure.
  273                        	
  274    00:E790  C9 08      			cmp	#HUCC_SGX_SPLITS	; Better a hang than a crash!
  275    00:E792  B0 FE      	.hang:		bcs	.hang
  276    00:E794  AA         			tax
  277                        	
  278    00:E795  BD F6 23   			lda	sgx_region_sel, x	; Update the parameter copy
  279    00:E798  5D FE 23   			eor	sgx_region_new, x	; that is not displayed now.
  280    00:E79B  D0 0D      			bne	.regionA
  281                        	
  282    00:E79D  9E 0E 24   	.regionB:	stz	sgx_regionB_crl, x	; Region disabled if $00.
  283                        	
  284    00:E7A0  A9 01      			lda	#1			; Mark that we've changed the
  285    00:E7A2  9D FE 23   			sta	sgx_region_new, x	; selected region.
  286    00:E7A5  9D F6 23   			sta	sgx_region_sel, x
  287                        	
  288    00:E7A8  28         			plp				; Restore interrupts.
  289    00:E7A9  60         			rts
  290                        	
  291    00:E7AA  9E 06 24   	.regionA:	stz	sgx_regionA_crl, x	; Region disabled if $00.
  292                        	
  293    00:E7AD  A9 01      			lda	#1			; Mark that we've changed the
  294    00:E7AF  9D FE 23   			sta	sgx_region_new, x	; selected region.
  295    00:E7B2  9E F6 23   			stz	sgx_region_sel, x
  296                        	
  297    00:E7B5  28         			plp				; Restore interrupts.
  298    00:E7B6  60         			rts
  299                        	
  300                        		.endif	SUPPORT_SGX
  301                        	
  302                        	
  303                        	
  304                        	; ***************************************************************************
  305                        	; ***************************************************************************
  306                        	;
  307                        	; vbl_init_scroll
  308                        	;
  309                        	; From Charles MacDonald's pcetech.txt ...
  310                        	;
  311                        	;  Raster Compare Register (RCR):
  312                        	;
  313                        	;  The range of the RCR is 263 lines, relative to the start of the active
  314                        	;  display period. (defined by VSW, VDS, and VCR) The VDC treats the first
  315                        	;  scanline of the active display period as $0040, so the valid ranges for
  316                        	;  the RCR register are $0040 to $0146.
  317                        	;
  318                        	;  For example, assume VSW=$02, VDS=$17. This positions the first line of
  319                        	;  the active display period at line 25 of the frame. An RCR value of $0040
  320                        	;  (zero) causes an interrupt at line 25, and a value of $0146 (262) causes an
  321                        	;  interrupt at line 24 of the next frame.
  322                        	;
  323                        	;  Any other RCR values that are out of range ($00-$3F, $147-$3FF) will never
  324                        	;  result in a successful line compare.
  325                        	;
  326                        	; Processing time:
  327                        	;
  328                        	; Old HuC rcr_init: 2148 cycles if all 8 regions pre-sorted
  329                        	; Old HuC rcr_init: 4346 cycles if all 8 regions need sorting
  330                        	;
  331                        	; New HuCC vbl_init_scroll:   8 disabled splits:  290 cycles
  332                        	; New HuCC vbl_init_scroll:   8  enabled splits:  384 cycles
  333                        	;
  334                        	; New HuCC vbl_init_scroll:  16 disabled splits:  506 cycles
  335                        	; New HuCC vbl_init_scroll:  16  enabled splits:  672 cycles
  336                        	;
  337                        	; New HuCC vbl_init_scroll:  32 disabled splits:  953 cycles
  338                        	; New HuCC vbl_init_scroll:  32  enabled splits: 1263 cycles
  339                        	;
  340                        	; New HuCC vbl_init_scroll:  64 disabled splits: 1802 cycles
  341                        	; New HuCC vbl_init_scroll:  64  enabled splits: 2400 cycles
  342                        	;
  343                        	; New HuCC vbl_init_scroll: 128 disabled splits: 3530 cycles
  344                        	; New HuCC vbl_init_scroll: 128  enabled splits: 4704 cycles
  345                        	;
  346                        	; Memory used is 16 bytes per scroll per VDC!
  347                        	
  348               2375     			.bss
  349                        	
  350    F8:2375             	vdc_region_sel:	.ds	HUCC_PCE_SPLITS		; Use A or B region next frame?
  351    F8:237D             	vdc_region_new:	.ds	HUCC_PCE_SPLITS		; 1 if vdc_region_sel modified.
  352                        	
  353    F8:2385             	vdc_regionA_crl:.ds	HUCC_PCE_SPLITS		; Two copies of each setting
  354    F8:238D             	vdc_regionB_crl:.ds	HUCC_PCE_SPLITS		; HUCC_PCE_SPLITS bytes apart,
  355    F8:2395             	vdc_regionA_rcr:.ds	HUCC_PCE_SPLITS		; one setting for the current
  356    F8:239D             	vdc_regionB_rcr:.ds	HUCC_PCE_SPLITS		; frame, and one setting that
  357    F8:23A5             	vdc_regionA_xl:	.ds	HUCC_PCE_SPLITS		; gets modified and then used
  358    F8:23AD             	vdc_regionB_xl:	.ds	HUCC_PCE_SPLITS		; on the next frame after the
  359    F8:23B5             	vdc_regionA_xh:	.ds	HUCC_PCE_SPLITS		; change is made.
  360    F8:23BD             	vdc_regionB_xh:	.ds	HUCC_PCE_SPLITS		; Regions will have different
  361    F8:23C5             	vdc_regionA_yl:	.ds	HUCC_PCE_SPLITS		; A or B currently active!
  362    F8:23CD             	vdc_regionB_yl:	.ds	HUCC_PCE_SPLITS
  363    F8:23D5             	vdc_regionA_yh:	.ds	HUCC_PCE_SPLITS
  364    F8:23DD             	vdc_regionB_yh:	.ds	HUCC_PCE_SPLITS
  365                        	
  366    F8:23E5             	vdc_next_region:.ds	1			; Linked list of region indexes
  367    F8:23E6             	vdc_regionA_nxt:.ds	HUCC_PCE_SPLITS		; for the current frame.
  368    F8:23EE             	vdc_regionB_nxt:.ds	HUCC_PCE_SPLITS
  369                        	
  370               0001     		.if	SUPPORT_SGX
  371                        	
  372    F8:23F6             	sgx_region_sel:	.ds	HUCC_SGX_SPLITS		; Use A or B region next frame?
  373    F8:23FE             	sgx_region_new:	.ds	HUCC_SGX_SPLITS		; 1 if sgx_region_sel modified.
  374                        	
  375    F8:2406             	sgx_regionA_crl:.ds	HUCC_SGX_SPLITS		; Two copies of each setting
  376    F8:240E             	sgx_regionB_crl:.ds	HUCC_SGX_SPLITS		; HUCC_SGX_SPLITS bytes apart,
  377    F8:2416             	sgx_regionA_rcr:.ds	HUCC_SGX_SPLITS		; one setting for the current
  378    F8:241E             	sgx_regionB_rcr:.ds	HUCC_SGX_SPLITS		; frame, and one setting that
  379    F8:2426             	sgx_regionA_xl:	.ds	HUCC_SGX_SPLITS		; gets modified and then used
  380    F8:242E             	sgx_regionB_xl:	.ds	HUCC_SGX_SPLITS		; on the next frame after the
  381    F8:2436             	sgx_regionA_xh:	.ds	HUCC_SGX_SPLITS		; change is made.
  382    F8:243E             	sgx_regionB_xh:	.ds	HUCC_SGX_SPLITS		; Regions will have different
  383    F8:2446             	sgx_regionA_yl:	.ds	HUCC_SGX_SPLITS		; A or B currently active!
  384    F8:244E             	sgx_regionB_yl:	.ds	HUCC_SGX_SPLITS
  385    F8:2456             	sgx_regionA_yh:	.ds	HUCC_SGX_SPLITS
  386    F8:245E             	sgx_regionB_yh:	.ds	HUCC_SGX_SPLITS
  387                        	
  388    F8:2466             	sgx_next_region:.ds	1			; Linked list of region indexes
  389    F8:2467             	sgx_regionA_nxt:.ds	HUCC_SGX_SPLITS		; for the current frame.
  390    F8:246F             	sgx_regionB_nxt:.ds	HUCC_SGX_SPLITS
  391                        	
  392                        		.endif
  393                        	
  394               E7B7     			.code
  395                        	
  396    01:C4D6             	vbl_init_scroll	.proc
  397                        	
  398    01:C4D6  62         			cla				; A = previous active index
  399    01:C4D7  A2 08      			ldx	#HUCC_PCE_SPLITS	; so $00 for end-of-screen.
  400                        	
  401    01:C4D9  18         			clc				; For regionB indexes.
  402                        	
  403    01:C4DA  CA         	!next_region:	dex				; All regions updated?
  404    01:C4DB  30 20      			bmi	!save_first+
  405                        	
  406    01:C4DD  9E 7D 23   			stz	vdc_region_new, x	; Clear region modified flag.
  407                        	
  408    01:C4E0  BC 75 23   			ldy	vdc_region_sel, x	; 0=regionA or 1=regionB.
  409    01:C4E3  F0 0D      			beq	!use_regionA+
  410                        	
  411    01:C4E5  BC 8D 23   	!use_regionB:	ldy	vdc_regionB_crl, x	; Region disabled if $00.
  412    01:C4E8  F0 F0      			beq	!next_region-
  413    01:C4EA  9D EE 23   			sta	vdc_regionB_nxt, x	; Save index of next region.
  414    01:C4ED  8A         			txa				; A = current region index.
  415    01:C4EE  69 08      			adc	#HUCC_PCE_SPLITS	; Always leaves CC!
  416    01:C4F0  80 E8      			bra	!next_region-
  417                        	
  418    01:C4F2  BC 85 23   	!use_regionA:	ldy	vdc_regionA_crl, x	; Region disabled if $00.
  419    01:C4F5  F0 E3      			beq	!next_region-
  420    01:C4F7  9D E6 23   			sta	vdc_regionA_nxt, x	; Save index of next region.
  421    01:C4FA  8A         			txa				; A = current region index.
  422    01:C4FB  80 DD      			bra	!next_region-
  423                        	
  424    01:C4FD  8D E5 23   	!save_first:	sta	vdc_next_region		; Save index of 1st region.
  425                        	
  426    01:C500  AA         			tax				; NZ if first active region
  427    01:C501  D0 03      			bne	!init_first+		; is not region 0.
  428    01:C503  98         			tya				; NZ if region 0 is active.
  429    01:C504  F0 0F      			beq	!+			; If no active leave RCR=0.
  430                        	
  431    01:C506  A9 06      	!init_first:	lda	#VDC_RCR		; 1st RCR always happens just
  432    01:C508  8D 00 02   			sta	VDC_AR			; before the display starts.
  433    01:C50B  A9 44      			lda.l	#HUCC_1ST_RCR
  434    01:C50D  8D 02 02   			sta	VDC_DL
  435    01:C510  A9 01      			lda.h	#HUCC_1ST_RCR
  436    01:C512  8D 03 02   			sta	VDC_DH
  437                        	
  438               0001     		.if	SUPPORT_SGX
  439                        	
  440    01:C515  62         	!:		cla				; A = previous active index
  441    01:C516  A2 08      			ldx	#HUCC_SGX_SPLITS	; so $00 for end-of-screen.
  442                        	
  443    01:C518  18         			clc				; For regionB indexes.
  444                        	
  445    01:C519  CA         	!next_region:	dex				; All regions updated?
  446    01:C51A  30 20      			bmi	!save_first+
  447                        	
  448    01:C51C  9E FE 23   			stz	sgx_region_new, x	; Clear region modified flag.
  449                        	
  450    01:C51F  BC F6 23   			ldy	sgx_region_sel, x	; 0=regionA or 1=regionB.
  451    01:C522  F0 0D      			beq	!use_regionA+
  452                        	
  453    01:C524  BC 0E 24   	!use_regionB:	ldy	sgx_regionB_crl, x	; Region disabled if $00.
  454    01:C527  F0 F0      			beq	!next_region-
  455    01:C529  9D 6F 24   			sta	sgx_regionB_nxt, x	; Save index of next region.
  456    01:C52C  8A         			txa				; A = current region index.
  457    01:C52D  69 08      			adc	#HUCC_SGX_SPLITS	; Always leaves CC!
  458    01:C52F  80 E8      			bra	!next_region-
  459                        	
  460    01:C531  BC 06 24   	!use_regionA:	ldy	sgx_regionA_crl, x	; Region disabled if $00.
  461    01:C534  F0 E3      			beq	!next_region-
  462    01:C536  9D 67 24   			sta	sgx_regionA_nxt, x	; Save index of next region.
  463    01:C539  8A         			txa				; A = current region index.
  464    01:C53A  80 DD      			bra	!next_region-
  465                        	
  466    01:C53C  8D 66 24   	!save_first:	sta	sgx_next_region		; Save index of 1st region.
  467                        	
  468    01:C53F  AA         			tax				; NZ if first active region
  469    01:C540  D0 03      			bne	!init_first+		; is not region 0.
  470    01:C542  98         			tya				; NZ if region 0 is active.
  471    01:C543  F0 0F      			beq	!+			; If no active leave RCR=0.
  472                        	
  473    01:C545  A9 06      	!init_first:	lda	#VDC_RCR		; 1st RCR always happens just
  474    01:C547  8D 10 02   			sta	SGX_AR			; before the display starts.
  475    01:C54A  A9 44      			lda.l	#HUCC_1ST_RCR
  476    01:C54C  8D 12 02   			sta	SGX_DL
  477    01:C54F  A9 01      			lda.h	#HUCC_1ST_RCR
  478    01:C551  8D 13 02   			sta	SGX_DH
  479                        	
  480                        		.endif	SUPPORT_SGX
  481                        	
  482                        	!:		leave				; All done!
         01:C554  4C EF FF   			jmp	leave_proc
  483                        	
  484                        			.endp
  485                        	
  486                        	
  487                        	
  488               0001     		.if	SUPPORT_SGX
  489                        	
  490                        	; ***************************************************************************
  491                        	; ***************************************************************************
  492                        	;
  493                        	; VDC_RCR_MACRO and SGX_RCR_MACRO
  494                        	;
  495                        	; A 16-byte TIA takes 142..234 cycles in 5MHz, 128..200 cycles in 7MHz.
  496                        	; A 32-byte TIA takes 270..364 cycles in 5MHz, 242..312 cycles in 7MHz. (527 DUO)
  497                        	;
  498                        	; You need to write the last RCR setting within 540 cycles in order to catch
  499                        	; the next line (at 256/336/512 resolution).
  500                        	;
  501                        	; That gives 305 cycles from the RCR to write the last setting, or there
  502                        	; will be a visible glitch on the screen.
  503                        	
  504               0000     		.ifndef	USING_RCR_MACROS
  506                        		.endif
  507                        	
  508                        	;		;;;				; 8 (cycles for the INT)
  509                        	;		bbs1	<irq_vec, .hook		; 8
  510                        	;		jmp	[irq1_hook]		; 7
  511                        	
  512                        	;		;;;				; 8 (cycles for the INT)
  513                        	;		jmp	irq1_handler		; 4
  514                        	
  515                        	;irq1_handler:	pha				; 3 Save all registers.
  516                        	;		phx				; 3
  517                        	;		phy				; 3
  518                        	;
  519                        	;		lda	VDC_SR			; 6 Acknowledge the VDC's IRQ.
  520                        	;		sta	<vdc_sr			; 4 Remember what caused it.
  521                        	;
  522                        	;		ldx	SGX_SR			; 6 Read SGX_SR after VDC_SR in
  523                        	;		stx	<sgx_sr			; 4 case this is not an SGX!
  524                        	;
  525                        	;!:		and	#$04			; 2 Is this an HSYNC interrupt?
  526                        	;		beq	!+			; 2
  527                        	
  528                        			.macro	VDC_RCR_MACRO
  529                        	
  530                        			st0	#VDC_RCR		; 5
  531                        	
  532                        			ldx	vdc_next_region		; 5 X and Y can be greater than
  533                        			ldy	vdc_regionA_nxt, x	; 5 HUCC_PCE_SPLITS if regionB!
  534                        			clc				; 2
  535                        			bne	!set_next_rcr+		; 4 Stop RCR if next line is 0.
  536                        	
  537                        			and	const_0000		; 5 A=$00 with the same #cycles
  538                        			bra	!clr_next_rcr+		; 4 as if the branch were taken.
  539                        	
  540                        	!set_next_rcr:	lda	vdc_regionA_rcr, y	; 5 Set next RCR 1 line before
  541                        			adc	#64-1			; 2 the region begins, or 0 to
  542                        	!clr_next_rcr:	sta	VDC_DL			; 6 disable.
  543                        			cla				; 2
  544                        			rol	a			; 2
  545                        			sta	VDC_DH			; 6
  546                        	
  547                        			st0	#VDC_BYR		; 5 Do BYR first to mitigate the
  548                        			lda	vdc_regionA_yl, x	; 5 glitch if the IRQ is delayed.
  549                        			sta	VDC_DL			; 6 = 105 cycles from RCR on SGX
  550                        			lda	vdc_regionA_yh, x	; 5
  551                        			sta	VDC_DH			; 6
  552                        	
  553                        			st0	#VDC_CR			; 5
  554                        			lda	vdc_regionA_crl, x	; 5
  555                        	;		asl	a
  556                        			sta	VDC_DL			; 6
  557                        	
  558                        			st0	#VDC_BXR		; 2
  559                        			lda	vdc_regionA_xl, x	; 5
  560                        			sta	VDC_DL			; 6
  561                        			lda	vdc_regionA_xh, x	; 5
  562                        			sta	VDC_DH			; 6 = 156 cycles from RCR if DUO
  563                        	
  564                        	;		bcc	!+
  565                        	;		lda	vdc_regionA_yh, x	; 5
  566                        	;		sta.l	VCE_CTW			; 6
  567                        	
  568                        			sty	vdc_next_region		; 5
  569                        	
  570                        			.endm
  571                        	
  572                        	;!:		bbr2	<sgx_sr, !+		; 6 Is this an HSYNC interrupt?
  573                        	
  574                        			.macro	SGX_RCR_MACRO
  575                        	
  576                        			lda	#VDC_RCR		; 2
  577                        			sta	SGX_AR			; 6
  578                        	
  579                        			ldx	sgx_next_region		; 5 X and Y can be greater than
  580                        			ldy	sgx_regionA_nxt, x	; 5 HUCC_SGX_SPLITS if regionB!
  581                        			clc				; 2
  582                        			bne	!set_next_rcr+		; 4 Stop RCR if next line is 0.
  583                        	
  584                        			and	const_0000		; 5 A=$00 with the same #cycles
  585                        			bra	!clr_next_rcr+		; 4 as if the branch were taken.
  586                        	
  587                        	!set_next_rcr:	lda	sgx_regionA_rcr, y	; 5 Set next RCR 1 line before
  588                        			adc	#64-1			; 2 the region begins, or 0 to
  589                        	!clr_next_rcr:	sta	SGX_DL			; 6 disable.
  590                        			cla				; 2
  591                        			rol	a			; 2
  592                        			sta	SGX_DH			; 6
  593                        	
  594                        			lda	#VDC_BYR		; 2 Do BYR first to mitigate the
  595                        			sta	SGX_AR			; 6 glitch if the IRQ is delayed.
  596                        			lda	sgx_regionA_yl, x	; 5
  597                        			sta	SGX_DL			; 6
  598                        			lda	sgx_regionA_yh, x	; 5
  599                        			sta	SGX_DH			; 6
  600                        	
  601                        			lda	#VDC_CR			; 2
  602                        			sta	SGX_AR			; 6
  603                        			lda	sgx_regionA_crl, x	; 5
  604                        			sta	SGX_DL			; 6
  605                        	
  606                        			lda	#VDC_BXR		; 2
  607                        			sta	SGX_AR			; 6
  608                        			lda	sgx_regionA_xl, x	; 5
  609                        			sta	SGX_DL			; 6
  610                        			lda	sgx_regionA_xh, x	; 5
  611                        			sta	SGX_DH			; 6 = 293 cycles (282 if no YH)
  612                        	
  613                        			sty	sgx_next_region		; 5
  614                        	
  615                        			.endm
  616                        	
  617                        		.else	SUPPORT_SGX
  697                        		.endif	SUPPORT_SGX
                             #[2]   "..\..\..\include\hucc\hucc-final.asm"
   68                        		.else
   72                        		.endif	HUCC_USES_NEW_SCROLL
   73                        	
   74               0001     		.ifdef	HUCC_USES_OLD_SPR		; Set in hucc_old_spr.h
                             #[3]   "..\..\..\include\hucc\hucc-old-spr.asm"
   75                        			include	"hucc-old-spr.asm"
    1                        	; ***************************************************************************
    2                        	; ***************************************************************************
    3                        	;
    4                        	; hucc-old-spr.asm
    5                        	;
    6                        	; Based on the original HuC and MagicKit functions by David Michel and the
    7                        	; other original HuC developers.
    8                        	;
    9                        	; Modifications copyright John Brandwood 2024.
   10                        	;
   11                        	; Distributed under the Boost Software License, Version 1.0.
   12                        	; (See accompanying file LICENSE_1_0.txt or copy at
   13                        	;  http://www.boost.org/LICENSE_1_0.txt)
   14                        	;
   15                        	; ***************************************************************************
   16                        	; ***************************************************************************
   17                        	
   18                        	;
   19                        	; Include dependancies ...
   20                        	;
   21                        	
   22                        			include "common.asm"		; Common helpers.
   23                        			include "vce.asm"		; Useful VCE routines.
   24                        			include "vdc.asm"		; Useful VCE routines.
   25                        	
   26                        	
   27                        	
   28                        	; ***************************************************************************
   29                        	; ***************************************************************************
   30                        	;
   31                        	; HuC Sprite Functions
   32                        	;
   33                        	; ***************************************************************************
   34                        	; ***************************************************************************
   35                        	
   36               209C     			.zp
   37    F8:209C             	spr_ptr:	ds	2
   38               2477     			.bss
   39    F8:2477             	spr_sat:	ds	512
   40               E7B7     			.code
   41                        	
   42               0001     		.if	SUPPORT_SGX
   43               209E     			.zp
   44    F8:209E             	sgx_spr_ptr:	ds	2
   45               2677     			.bss
   46    F8:2677             	sgx_spr_sat:	ds	512	; N.B. Directly after spr_sat!
   47               E7B7     			.code
   48                        		.endif
   49                        	
   50                        	; Moved to hucc-old-map.asm just to save space. This NEEDS to be changed!
   51                        	;
   52                        	;		.bss
   53                        	;spr_max:	ds	1
   54                        	;spr_clr:	ds	1
   55                        	;	.if	SUPPORT_SGX
   56                        	;sgx_spr_max:	ds	1
   57                        	;sgx_spr_clr:	ds	1
   58                        	;	.endif
   59                        	;		.code
   60                        	
   61                        	
   62                        	
   63                        	; ***************************************************************************
   64                        	; ***************************************************************************
   65                        	;
   66                        	; void __fastcall init_satb( void );
   67                        	; void __fastcall reset_satb( void );
   68                        	;
   69                        	; void __fastcall sgx_init_satb( void );
   70                        	; void __fastcall sgx_reset_satb( void );
   71                        	
   72    00:E7B7             	_reset_satb:
   73    00:E7B7  C2         	_init_satb:	cly
   74    00:E7B8  62         			cla
   75    00:E7B9  99 77 24   	!:		sta	spr_sat + $0000, y
   76    00:E7BC  99 77 25   			sta	spr_sat + $0100, y
   77    00:E7BF  C8         			iny
   78    00:E7C0  D0 F7      			bne	!-
   79    00:E7C2  8C 4B 23   			sty	spr_max
   80    00:E7C5  C8         			iny
   81    00:E7C6  8C 4C 23   			sty	spr_clr
   82    00:E7C9  60         			rts
   83                        	
   84               0001     		.if	SUPPORT_SGX
   85    00:E7CA             	_sgx_reset_satb:
   86    00:E7CA  C2         	_sgx_init_satb:	cly
   87    00:E7CB  62         			cla
   88    00:E7CC  99 77 26   	!:		sta	sgx_spr_sat + $0000, y
   89    00:E7CF  99 77 27   			sta	sgx_spr_sat + $0100, y
   90    00:E7D2  C8         			iny
   91    00:E7D3  D0 F7      			bne	!-
   92    00:E7D5  8C 5B 23   			sty	sgx_spr_max
   93    00:E7D8  C8         			iny
   94    00:E7D9  8C 5C 23   			sty	sgx_spr_clr
   95    00:E7DC  60         			rts
   96                        		.endif
   97                        	
   98                        	
   99                        	
  100                        	; ***************************************************************************
  101                        	; ***************************************************************************
  102                        	;
  103                        	; void __fastcall satb_update( void );
  104                        	; void __fastcall sgx_satb_update( void );
  105                        	
  106    01:C892             	old_satb_group	.procgroup
  107                        	
  108               0001     		.if	SUPPORT_SGX
  109                        			.proc	_sgx_satb_update
  115                        			.endp
  116                        		.endif
  117                        	
  118    01:C892             			.proc	_satb_update
  119                        	
  120    01:C892  82         			clx				; Offset to PCE VDC.
  121                        	
  122    01:C893  A9 7F      			lda.h	#$7F00			; HuC puts the SAT here in VRAM
  123                        	;		lda.h	#$0800			; but we put it here instead
  124    01:C895  64 F0      			stz.l	<_di
  125    01:C897  85 F1      			sta.h	<_di
  126    01:C899  20 7F E3   			jsr	set_di_to_mawr
  127                        	
  128               0001     		.if	SUPPORT_SGX
  129    01:C89C  8A         			txa				; Select which VDC to write
  130    01:C89D  1A         			inc	a			; to.
  131    01:C89E  1A         			inc	a
  132    01:C89F  8D F3 22   			sta.l	ram_tia_dst
  133                        		.endif
  134                        	
  135    01:C8A2  A9 10      			lda	#VRAM_XFER_SIZE		; Split into 16-byte chunks
  136    01:C8A4  8D F5 22   			sta.l	ram_tia_len		; for stable IRQ response.
  137                        	
  138    01:C8A7  BC 4B 23   			ldy	spr_max, x		; Highest sprite that was set.
  139    01:C8AA  C8         			iny
  140                        	
  141    01:C8AB  BD 4C 23   			lda	spr_clr, x
  142    01:C8AE  F0 05      			beq	!+
  143    01:C8B0  9E 4C 23   			stz	spr_clr, x
  144    01:C8B3  A0 40      			ldy	#64
  145                        	
  146    01:C8B5  98         	!:		tya
  147    01:C8B6  F0 22      			beq	.exit
  148                        	
  149    01:C8B8  3A         			dec	a			; round up to the next group of 2 sprites
  150    01:C8B9  4A         			lsr	a
  151               0000     		.if	VRAM_XFER_SIZE == 32
  153                        		.endif
  154    01:C8BA  1A         			inc	a
  155    01:C8BB  A8         			tay
  156                        	
  157    01:C8BC  A9 24      			lda.h	#spr_sat
  158                        	
  159               0001     		.if	SUPPORT_SGX
  160    01:C8BE  E0 00      			cpx	#0
  161    01:C8C0  F0 02      			beq	!+
  162                        	
  163    01:C8C2  A9 26      			lda.h	#sgx_spr_sat
  164                        		.endif
  165                        	
  166    01:C8C4  8D F2 22   	!:		sta.h	ram_tia_src
  167                        	
  168    01:C8C7  A9 77      			lda.l	#spr_sat		; Same for SGX and PCE!
  169    01:C8C9  8D F1 22   	.chunk_loop:	sta.l	ram_tia_src
  170                        	
  171    01:C8CC  20 F0 22   			jsr	ram_tia			; transfer 16-bytes
  172                        	
  173    01:C8CF  18         			clc				; increment source
  174    01:C8D0  69 10      			adc	#VRAM_XFER_SIZE
  175    01:C8D2  90 03      			bcc	.same_page
  176    01:C8D4  EE F2 22   			inc.h	ram_tia_src
  177                        	
  178    01:C8D7  88         	.same_page:	dey
  179    01:C8D8  D0 EF      			bne	.chunk_loop
  180                        	
  181                        	.exit:		leave
         01:C8DA  4C EF FF   			jmp	leave_proc
  182                        	
  183                        			.endp
  184                        	
  185                        			.endprocgroup	; old_satb_group
  186                        	
  187                        	
  188                        	
  189                        	; ***************************************************************************
  190                        	; ***************************************************************************
  191                        	;
  192                        	; void __fastcall spr_set( unsigned char num<acc> );
  193                        	
  194    00:E7DD  CD 4B 23   	_spr_set.1:	cmp	spr_max
  195    00:E7E0  90 03      			bcc	!+
  196    00:E7E2  8D 4B 23   			sta	spr_max
  197    00:E7E5  A0 24      	!:		ldy.h	#spr_sat
  198    00:E7E7  0A         			asl	a
  199    00:E7E8  0A         			asl	a
  200    00:E7E9  0A         			asl	a
  201    00:E7EA  90 02      			bcc	!+
  202    00:E7EC  C8         			iny
  203    00:E7ED  18         			clc
  204    00:E7EE  69 77      	!:		adc.l	#spr_sat
  205    00:E7F0  85 9C      			sta.l	<spr_ptr
  206    00:E7F2  90 01      			bcc	!+
  207    00:E7F4  C8         			iny
  208    00:E7F5  84 9D      	!:		sty.h	<spr_ptr
  209    00:E7F7  60         			rts
  210                        	
  211                        	
  212                        	
  213                        	; ***************************************************************************
  214                        	; ***************************************************************************
  215                        	;
  216                        	; void __fastcall spr_hide( void );
  217                        	
  218    00:E7F8  A0 01      	_spr_hide:	ldy	#1
  219    00:E7FA  B1 9C      			lda	[spr_ptr], y
  220    00:E7FC  09 02      			ora	#2
  221    00:E7FE  91 9C      			sta	[spr_ptr], y
  222    00:E800  60         			rts
  223                        	
  224                        	
  225                        	
  226                        	; ***************************************************************************
  227                        	; ***************************************************************************
  228                        	;
  229                        	; void __fastcall spr_show( void );
  230                        	
  231    00:E801  A0 01      	_spr_show:	ldy	#1
  232    00:E803  B1 9C      			lda	[spr_ptr], y
  233    00:E805  29 01      			and	#1
  234    00:E807  91 9C      			sta	[spr_ptr], y
  235    00:E809  60         			rts
  236                        	
  237                        	
  238                        	
  239                        	; ***************************************************************************
  240                        	; ***************************************************************************
  241                        	;
  242                        	; void __fastcall spr_x( unsigned int value<acc> );
  243                        	
  244    00:E80A  02         	_spr_x.1:	sxy
  245    00:E80B  18         			clc
  246    00:E80C  69 20      			adc	#32
  247    00:E80E  A0 02      			ldy	#2
  248    00:E810  91 9C      			sta	[spr_ptr], y
  249    00:E812  8A         			txa
  250    00:E813  69 00      			adc	#0
  251    00:E815  C8         			iny
  252    00:E816  91 9C      			sta	[spr_ptr], y
  253    00:E818  60         			rts
  254                        	
  255                        	
  256                        	
  257                        	; ***************************************************************************
  258                        	; ***************************************************************************
  259                        	;
  260                        	; void __fastcall spr_y( unsigned int value<acc> );
  261                        	
  262    00:E819  18         	_spr_y.1:	clc
  263    00:E81A  69 40      			adc	#64
  264    00:E81C  92 9C      			sta	[spr_ptr]
  265    00:E81E  98         			tya
  266    00:E81F  69 00      			adc	#0
  267    00:E821  A0 01      			ldy	#1
  268    00:E823  91 9C      			sta	[spr_ptr], y
  269    00:E825  60         			rts
  270                        			
  271                        	
  272                        	
  273                        	; ***************************************************************************
  274                        	; ***************************************************************************
  275                        	;
  276                        	; void __fastcall spr_pattern( unsigned int vaddr<acc> );
  277                        	
  278    00:E826  84 00      	_spr_pattern.1:	sty	<__temp		;     zp=fedcba98 a=76543210
  279    00:E828  0A         			asl	a		; c=f zp=edcba987 a=6543210_
  280    00:E829  26 00      			rol	<__temp
  281    00:E82B  2A         			rol	a		; c=e zp=dcba9876 a=543210_f
  282    00:E82C  26 00      			rol	<__temp
  283    00:E82E  2A         			rol	a		; c=d zp=cba98765 a=43210_fe
  284    00:E82F  26 00      			rol	<__temp
  285    00:E831  2A         			rol	a		; c=4 zp=cba98765 a=3210_fed
  286    00:E832  A0 05      			ldy	#5
  287    00:E834  91 9C      			sta	[spr_ptr], y
  288    00:E836  A5 00      			lda	<__temp
  289    00:E838  88         			dey
  290    00:E839  91 9C      			sta	[spr_ptr], y
  291    00:E83B  60         			rts
  292                        	
  293                        	
  294                        	
  295                        	; ***************************************************************************
  296                        	; ***************************************************************************
  297                        	;
  298                        	; void __fastcall spr_ctrl( unsigned char mask<_al>, unsigned char value<acc> );
  299                        	
  300    00:E83C  25 F8      	_spr_ctrl.2:	and	<_al
  301    00:E83E  85 00      			sta	<__temp
  302    00:E840  A5 F8      			lda	<_al
  303    00:E842  49 FF      			eor	#$FF
  304    00:E844  A0 07      			ldy	#7
  305    00:E846  31 9C      			and	[spr_ptr], y
  306    00:E848  05 00      			ora	<__temp
  307    00:E84A  91 9C      			sta	[spr_ptr], y
  308    00:E84C  60         			rts
  309                        	
  310                        	
  311                        	
  312                        	; ***************************************************************************
  313                        	; ***************************************************************************
  314                        	;
  315                        	; void __fastcall spr_pal( unsigned char palette<acc> )
  316                        	
  317    00:E84D  29 0F      	_spr_pal.1:	and	#$0F
  318    00:E84F  85 00      			sta	<__temp
  319    00:E851  A0 06      			ldy	#6
  320    00:E853  B1 9C      			lda	[spr_ptr], y
  321    00:E855  29 F0      			and	#$F0
  322    00:E857  05 00      			ora	<__temp
  323    00:E859  91 9C      			sta	[spr_ptr], y
  324    00:E85B  60         			rts
  325                        	
  326                        	
  327                        	
  328                        	; ***************************************************************************
  329                        	; ***************************************************************************
  330                        	;
  331                        	; void __fastcall spr_pri( unsigned char priority<acc> )
  332                        	
  333    00:E85C  C9 01      	_spr_pri.1:	cmp	#1
  334    00:E85E  A0 06      			ldy	#6
  335    00:E860  B1 9C      			lda	[spr_ptr], y
  336    00:E862  29 7F      			and	#$7F
  337    00:E864  90 02      			bcc	!+
  338    00:E866  09 80      			ora	#$80
  339    00:E868  91 9C      	!:		sta	[spr_ptr], y
  340    00:E86A  60         			rts
  341                        	
  342                        	
  343                        	
  344                        	; ***************************************************************************
  345                        	; ***************************************************************************
  346                        	;
  347                        	; unsigned int __fastcall spr_get_x( void );
  348                        	
  349    00:E86B  38         	_spr_get_x:	sec
  350    00:E86C  A0 02      			ldy	#2
  351    00:E86E  B1 9C      			lda	[spr_ptr], y
  352    00:E870  E9 20      			sbc	#32
  353    00:E872  AA         			tax
  354    00:E873  C8         			iny
  355    00:E874  B1 9C      			lda	[spr_ptr], y
  356    00:E876  E9 00      			sbc	#0
  357    00:E878  A8         			tay
  358    00:E879  8A         			txa
  359    00:E87A  60         			rts
  360                        	
  361                        	
  362                        	
  363                        	; ***************************************************************************
  364                        	; ***************************************************************************
  365                        	;
  366                        	; unsigned int __fastcall spr_get_y( void );
  367                        	
  368    00:E87B  38         	_spr_get_y:	sec
  369    00:E87C  B2 9C      			lda	[spr_ptr]
  370    00:E87E  E9 40      			sbc	#64
  371    00:E880  AA         			tax
  372    00:E881  A0 01      			ldy	#1
  373    00:E883  B1 9C      			lda	[spr_ptr], y
  374    00:E885  E9 00      			sbc	#0
  375    00:E887  A8         			tay
  376    00:E888  8A         			txa
  377    00:E889  60         			rts
  378                        	
  379                        	
  380                        	
  381               0001     		.if	SUPPORT_SGX
  382                        	
  383                        	; ***************************************************************************
  384                        	; ***************************************************************************
  385                        	;
  386                        	; void __fastcall sgx_spr_set( unsigned char num<acc> );
  387                        	
  388    00:E88A  CD 5B 23   	_sgx_spr_set.1:	cmp	sgx_spr_max
  389    00:E88D  90 03      			bcc	!+
  390    00:E88F  8D 5B 23   			sta	sgx_spr_max
  391    00:E892  A0 26      	!:		ldy.h	#sgx_spr_sat
  392    00:E894  0A         			asl	a
  393    00:E895  0A         			asl	a
  394    00:E896  0A         			asl	a
  395    00:E897  90 02      			bcc	!+
  396    00:E899  C8         			iny
  397    00:E89A  18         			clc
  398    00:E89B  69 77      	!:		adc.l	#sgx_spr_sat
  399    00:E89D  85 9E      			sta.l	<sgx_spr_ptr
  400    00:E89F  90 01      			bcc	!+
  401    00:E8A1  C8         			iny
  402    00:E8A2  84 9F      	!:		sty.h	<sgx_spr_ptr
  403    00:E8A4  60         			rts
  404                        	
  405                        	
  406                        	
  407                        	; ***************************************************************************
  408                        	; ***************************************************************************
  409                        	;
  410                        	; void __fastcall sgx_spr_hide( void );
  411                        	
  412    00:E8A5  A0 01      	_sgx_spr_hide:	ldy	#1
  413    00:E8A7  B1 9E      			lda	[sgx_spr_ptr], y
  414    00:E8A9  09 02      			ora	#2
  415    00:E8AB  91 9E      			sta	[sgx_spr_ptr], y
  416    00:E8AD  60         			rts
  417                        	
  418                        	
  419                        	
  420                        	; ***************************************************************************
  421                        	; ***************************************************************************
  422                        	;
  423                        	; void __fastcall sgx_spr_show( void );
  424                        	
  425    00:E8AE  A0 01      	_sgx_spr_show:	ldy	#1
  426    00:E8B0  B1 9E      			lda	[sgx_spr_ptr], y
  427    00:E8B2  29 01      			and	#1
  428    00:E8B4  91 9E      			sta	[sgx_spr_ptr], y
  429    00:E8B6  60         			rts
  430                        	
  431                        	
  432                        	
  433                        	; ***************************************************************************
  434                        	; ***************************************************************************
  435                        	;
  436                        	; void __fastcall sgx_spr_x( unsigned int value<acc> );
  437                        	
  438    00:E8B7  02         	_sgx_spr_x.1:	sxy
  439    00:E8B8  18         			clc
  440    00:E8B9  69 20      			adc	#32
  441    00:E8BB  A0 02      			ldy	#2
  442    00:E8BD  91 9E      			sta	[sgx_spr_ptr], y
  443    00:E8BF  8A         			txa
  444    00:E8C0  69 00      			adc	#0
  445    00:E8C2  C8         			iny
  446    00:E8C3  91 9E      			sta	[sgx_spr_ptr], y
  447    00:E8C5  60         			rts
  448                        	
  449                        	
  450                        	
  451                        	; ***************************************************************************
  452                        	; ***************************************************************************
  453                        	;
  454                        	; void __fastcall sgx_spr_y( unsigned int value<acc> );
  455                        	
  456    00:E8C6  18         	_sgx_spr_y.1:	clc
  457    00:E8C7  69 40      			adc	#64
  458    00:E8C9  92 9E      			sta	[sgx_spr_ptr]
  459    00:E8CB  98         			tya
  460    00:E8CC  69 00      			adc	#0
  461    00:E8CE  A0 01      			ldy	#1
  462    00:E8D0  91 9E      			sta	[sgx_spr_ptr], y
  463    00:E8D2  60         			rts
  464                        			
  465                        	
  466                        	
  467                        	; ***************************************************************************
  468                        	; ***************************************************************************
  469                        	;
  470                        	; void __fastcall sgx_spr_pattern( unsigned int vaddr<acc> );
  471                        	
  472    00:E8D3             	_sgx_spr_pattern.1:
  473    00:E8D3  84 00      			sty	<__temp		;     zp=fedcba98 a=76543210
  474    00:E8D5  0A         			asl	a		; c=f zp=edcba987 a=6543210_
  475    00:E8D6  26 00      			rol	<__temp
  476    00:E8D8  2A         			rol	a		; c=e zp=dcba9876 a=543210_f
  477    00:E8D9  26 00      			rol	<__temp
  478    00:E8DB  2A         			rol	a		; c=d zp=cba98765 a=43210_fe
  479    00:E8DC  26 00      			rol	<__temp
  480    00:E8DE  2A         			rol	a		; c=4 zp=cba98765 a=3210_fed
  481    00:E8DF  A0 05      			ldy	#5
  482    00:E8E1  91 9E      			sta	[sgx_spr_ptr], y
  483    00:E8E3  A5 00      			lda	<__temp
  484    00:E8E5  88         			dey
  485    00:E8E6  91 9E      			sta	[sgx_spr_ptr], y
  486    00:E8E8  60         			rts
  487                        	
  488                        	
  489                        	
  490                        	; ***************************************************************************
  491                        	; ***************************************************************************
  492                        	;
  493                        	; void __fastcall sgx_spr_ctrl( unsigned char mask<_al>, unsigned char value<acc> );
  494                        	
  495    00:E8E9  25 F8      	_sgx_spr_ctrl.2:and	<_al
  496    00:E8EB  85 00      			sta	<__temp
  497    00:E8ED  A5 F8      			lda	<_al
  498    00:E8EF  49 FF      			eor	#$FF
  499    00:E8F1  A0 07      			ldy	#7
  500    00:E8F3  31 9E      			and	[sgx_spr_ptr], y
  501    00:E8F5  05 00      			ora	<__temp
  502    00:E8F7  91 9E      			sta	[sgx_spr_ptr], y
  503    00:E8F9  60         			rts
  504                        	
  505                        	
  506                        	
  507                        	; ***************************************************************************
  508                        	; ***************************************************************************
  509                        	;
  510                        	; void __fastcall sgx_spr_pal( unsigned char palette<acc> )
  511                        	
  512    00:E8FA  29 0F      	_sgx_spr_pal.1:	and	#$0F
  513    00:E8FC  85 00      			sta	<__temp
  514    00:E8FE  A0 06      			ldy	#6
  515    00:E900  B1 9E      			lda	[sgx_spr_ptr], y
  516    00:E902  29 F0      			and	#$F0
  517    00:E904  05 00      			ora	<__temp
  518    00:E906  91 9E      			sta	[sgx_spr_ptr], y
  519    00:E908  60         			rts
  520                        	
  521                        	
  522                        	
  523                        	; ***************************************************************************
  524                        	; ***************************************************************************
  525                        	;
  526                        	; void __fastcall sgx_spr_pri( unsigned char priority<acc> )
  527                        	
  528    00:E909  C9 01      	_sgx_spr_pri.1:	cmp	#1
  529    00:E90B  A0 06      			ldy	#6
  530    00:E90D  B1 9E      			lda	[sgx_spr_ptr], y
  531    00:E90F  29 7F      			and	#$7F
  532    00:E911  90 02      			bcc	!+
  533    00:E913  09 80      			ora	#$80
  534    00:E915  91 9E      	!:		sta	[sgx_spr_ptr], y
  535    00:E917  60         			rts
  536                        	
  537                        	
  538                        	
  539                        	; ***************************************************************************
  540                        	; ***************************************************************************
  541                        	;
  542                        	; unsigned int __fastcall sgx_spr_get_x( void );
  543                        	
  544    00:E918  38         	_sgx_spr_get_x:	sec
  545    00:E919  A0 02      			ldy	#2
  546    00:E91B  B1 9E      			lda	[sgx_spr_ptr], y
  547    00:E91D  E9 20      			sbc	#32
  548    00:E91F  AA         			tax
  549    00:E920  C8         			iny
  550    00:E921  B1 9E      			lda	[sgx_spr_ptr], y
  551    00:E923  E9 00      			sbc	#0
  552    00:E925  A8         			tay
  553    00:E926  8A         			txa
  554    00:E927  60         			rts
  555                        	
  556                        	
  557                        	
  558                        	; ***************************************************************************
  559                        	; ***************************************************************************
  560                        	;
  561                        	; unsigned int __fastcall sgx_spr_get_y( void );
  562                        	
  563    00:E928  38         	_sgx_spr_get_y:	sec
  564    00:E929  B2 9E      			lda	[sgx_spr_ptr]
  565    00:E92B  E9 40      			sbc	#64
  566    00:E92D  AA         			tax
  567    00:E92E  A0 01      			ldy	#1
  568    00:E930  B1 9E      			lda	[sgx_spr_ptr], y
  569    00:E932  E9 00      			sbc	#0
  570    00:E934  A8         			tay
  571    00:E935  8A         			txa
  572    00:E936  60         			rts
  573                        	
  574                        		.endif	SUPPORT_SGX
                             #[2]   "..\..\..\include\hucc\hucc-final.asm"
   76                        		.endif
   77                        	
   78               0001     		.ifdef	HUCC_USES_BLKMAP		; Set in hucc_blkmap.h
                             #[3]   "..\..\..\include\hucc\blkmap.asm"
   79                        			include	"blkmap.asm"
    1                        	; ***************************************************************************
    2                        	; ***************************************************************************
    3                        	;
    4                        	; blkmap.asm
    5                        	;
    6                        	; A map system based on 16x16 meta-tiles (aka "blocks", aka CHR/BLK/MAP).
    7                        	;
    8                        	; Copyright John Brandwood 2025.
    9                        	;
   10                        	; Distributed under the Boost Software License, Version 1.0.
   11                        	; (See accompanying file LICENSE_1_0.txt or copy at
   12                        	;  http://www.boost.org/LICENSE_1_0.txt)
   13                        	;
   14                        	; ***************************************************************************
   15                        	; ***************************************************************************
   16                        	;
   17                        	; The maximum X and Y size for blkmaps is 128 blocks (2048 pixels).
   18                        	;
   19                        	; The maximum total size for a blkmap is 16KBytes, which allows for maps up
   20                        	; to 128x128 blocks (2048x2048 pixels).
   21                        	;
   22                        	; Huge multi-screen blkmaps are also supported (optionally).
   23                        	;
   24                        	; The maximum X and Y for multi-screen maps is 128 screens (32768 pixels).
   25                        	;
   26                        	; The maximum total size for a multi-screen map is 8KBytes, which allows for
   27                        	; a total of 1024 screens.
   28                        	;
   29                        	; ***************************************************************************
   30                        	; ***************************************************************************
   31                        	
   32                        	;
   33                        	; Include dependancies ...
   34                        	;
   35                        	
   36                        			include "common.asm"		; Common helpers.
   37                        			include "vce.asm"		; Useful VCE routines.
   38                        			include "vdc.asm"		; Useful VCE routines.
   39                        	
   40                        	;
   41                        	; Support large blkmaps up to 16KBytes instead of the regular 8KBytes?
   42                        	;
   43                        	; The maximum X and Y size for regular blkmaps is 128 tiles (2048 pixels).
   44                        	;
   45                        	; This allows for individual maps up to 128x128 tiles (2048x2048 pixels) vs
   46                        	; default limit of 128x64 or 64x128.
   47                        	;
   48                        	
   49               0000     		.ifndef	BLKMAP_LARGEMAP
   51                        		.endif
   52                        	
   53                        	;
   54                        	; Support huge multi-screen maps, up to 32768 pixels wide/high?
   55                        	;
   56                        	; These are sectorized maps split into individual BAT-sized "screens", with
   57                        	; a maximum of 1024 screens per map.
   58                        	;
   59                        	; The BAT size that is used when drawing *must* be the same as the BAT size
   60                        	; that was chosen when creating the multi-screen map.
   61                        	;
   62                        	; Each screen can use a unique set of block definitions, or it might choose
   63                        	; to share the same block definitions that are used on another screen.
   64                        	;
   65                        	; Each screen may choose which 8KByte banks of character data to select for
   66                        	; the 4 banks (32KBytes) of VRAM that its block definitions use, with a max
   67                        	; of 16 banks of characters per multi-screen map.
   68                        	;
   69                        	; Loading those character banks dynamically is an exercise for the user!
   70                        	;
   71                        	; Enabling support adds extra library code, and slightly slows down the use
   72                        	; of regular blkmaps.
   73                        	;
   74                        	
   75               0000     		.ifndef	BLKMAP_MULTISCR
   77                        		.endif
   78                        	
   79                        	;
   80                        	; Block definitions can either use character data from VRAM $1000..$7FFF or
   81                        	; they can be limited to use the 32KByte of characters in VRAM $1000..$4FFF
   82                        	; which then frees up 2-bits for flag information for each character in the
   83                        	; block.
   84                        	;
   85                        	; These 2-bits are perfect for using as collision information in game maps,
   86                        	; allowing storage of states like transparent, solid, up-slope, down-slope.
   87                        	;
   88                        	; Typically this flag information is set by the map conversion tools from a
   89                        	; seperate "collision" map layer.
   90                        	;
   91                        	
   92               0000     		.ifndef	BLKDEF_CHR_FLAG
   94                        		.endif
   95                        	
   96                        	;
   97                        	; Block definitions are accessed in MPR2 ($4000..$5FFF), and must not cross
   98                        	; the bank boundary.
   99                        	;
  100                        	; When working this way, 8 pointers in ZP are used to access the individual
  101                        	; bytes in the block definition. This is fine when using a regular map on a
  102                        	; PC Engine, but it is awfully slow when using multi-screen maps or drawing
  103                        	; maps on both VDC chips in a SuperGRAFX because the pointer values must be
  104                        	; constantly changed.
  105                        	;
  106                        	; When using multi-screen maps, or when developing a SuperGRAFX game, or if
  107                        	; developing a CDROM game, then it is usually preferable to store the block
  108                        	; definitions with 2KByte alignment, especially if they are normally stored
  109                        	; compressed and then decompressed into a 2KByte buffer in RAM when needed.
  110                        	;
  111                        	; This option controls whether the definitions are stored 2KByte aligned or
  112                        	; if pointers should be used instead.
  113                        	;
  114                        	
  115               0000     		.ifndef	BLKDEF_POINTERS
  117                        		.endif
  118                        	
  119                        	;
  120                        	; Add a timing bar to the scroll_map() to see how long the drawing takes?
  121                        	;
  122                        	
  123               0000     		.ifndef	BLKMAP_TIMETEST
  125                        		.endif
  126                        	
  127                        	;
  128                        	;
  129                        	;
  130                        	
  131               0000     		.if	BLKDEF_POINTERS
  144                        		.else
  145                        	
  146                        		; If the block definititions are 2KByte aligned.
  147                        	
  148               4000     	BLK_4000_TL_L	=	$4000
  149               4100     	BLK_4000_TR_L	=	$4100
  150               4200     	BLK_4000_BL_L	=	$4200
  151               4300     	BLK_4000_BR_L	=	$4300
  152               4400     	BLK_4000_TL_H	=	$4400
  153               4500     	BLK_4000_TR_H	=	$4500
  154               4600     	BLK_4000_BL_H	=	$4600
  155               4700     	BLK_4000_BR_H	=	$4700
  156                        	
  157               4800     	BLK_4800_TL_L	=	$4800
  158               4900     	BLK_4800_TR_L	=	$4900
  159               4A00     	BLK_4800_BL_L	=	$4A00
  160               4B00     	BLK_4800_BR_L	=	$4B00
  161               4C00     	BLK_4800_TL_H	=	$4C00
  162               4D00     	BLK_4800_TR_H	=	$4D00
  163               4E00     	BLK_4800_BL_H	=	$4E00
  164               4F00     	BLK_4800_BR_H	=	$4F00
  165                        	
  166               5000     	BLK_5000_TL_L	=	$5000
  167               5100     	BLK_5000_TR_L	=	$5100
  168               5200     	BLK_5000_BL_L	=	$5200
  169               5300     	BLK_5000_BR_L	=	$5300
  170               5400     	BLK_5000_TL_H	=	$5400
  171               5500     	BLK_5000_TR_H	=	$5500
  172               5600     	BLK_5000_BL_H	=	$5600
  173               5700     	BLK_5000_BR_H	=	$5700
  174                        	
  175               5800     	BLK_5800_TL_L	=	$5800
  176               5900     	BLK_5800_TR_L	=	$5900
  177               5A00     	BLK_5800_BL_L	=	$5A00
  178               5B00     	BLK_5800_BR_L	=	$5B00
  179               5C00     	BLK_5800_TL_H	=	$5C00
  180               5D00     	BLK_5800_TR_H	=	$5D00
  181               5E00     	BLK_5800_BL_H	=	$5E00
  182               5F00     	BLK_5800_BR_H	=	$5F00
  183                        	
  184                        		.endif
  185                        	
  186               0080     	MAP_UNALIGNED_X	=	$80
  187               0040     	MAP_UNALIGNED_Y	=	$40
  188                        	
  189                        	;
  190                        	;
  191                        	;
  192                        	
  193               2877     			.bss
  194                        	
  195                        	; **************
  196                        	; 8-byte (or 2-byte) entry for each SCREEN in the MULTI_MAP.
  197                        	
  198               0000     			.rsset	0
  199               0000     		.if	BLKDEF_POINTERS
  202                        		.else
  203               0000     	SCR_MAP_PAGE	.rs	1	; 256-byte aligned.
  204               0001     	SCR_MAP_BANK	.rs	1
  205               0002     	SCR_BLK_PAGE	.rs	1	; >$4000, >$4800, >$5000, or >$5800.
  206               0003     	SCR_BLK_BANK	.rs	1
  207               0004     	SCR_TBL_PAGE	.rs	1	; 256-byte aligned.
  208               0005     	SCR_TBL_BANK	.rs	1
  209               0006     	SCR_CHR_12	.rs	1	; Which CHR banks are used by the BLK, with
  210               0007     	SCR_CHR_34	.rs	1	; a max of 16 CHR banks per MULTI_MAP.
  211                        		.endif
  212                        	
  213                        			; A simple macro to help build a multi-screen map.
  214                        	
  215               0000     		.ifndef	SCREEN
  224                        		.endif
  225                        	
  226    F8:2877             	map_blk_flag:	ds	1	; Returned from _get_map_block().
  227    F8:2878             	map_blk_mask:	ds	1	; Returned from _get_map_block().
  228                        	
  229                        	; **************
  230                        	; 16-bytes of VDC blkmap info.
  231                        	;
  232                        	; N.B. MUST be 16-bytes before the SGX versions to use PCE_VDC_OFFSET.
  233                        	
  234    F8:2879             	vdc_old_chr_x:	ds	1	; Previous top-left X in CHR (lo-byte only).
  235    F8:287A             	vdc_old_chr_y:	ds	1	; Previous top-left Y in CHR (lo-byte only).
  236                        	
  237    F8:287B             	vdc_tbl_addr:	ds	2	; 256-byte aligned.
  238    F8:287D             	vdc_tbl_bank:	ds	1
  239                        	
  240    F8:287E             	vdc_blk_addr:	ds	2	; 2KBytes of data, 256-byte aligned.
  241    F8:2880             	vdc_blk_bank:	ds	1
  242                        	
  243    F8:2881             	vdc_map_addr:	ds	2	; Mapped into MPR3..MPR5, max 16KBytes.
  244    F8:2883             	vdc_map_bank:	ds	1
  245                        	
  246    F8:2884             	vdc_scr_addr:	ds	2	; 8KByte maximum size.
  247    F8:2886             	vdc_scr_bank:	ds	1
  248    F8:2887             	vdc_scr_chr12:	ds	1	; Which CHR banks are used by the BLK, with
  249    F8:2888             	vdc_scr_chr34:	ds	1	; a max of 16 banks per multi-screen map.
  250                        	
  251               0001     		.if	SUPPORT_SGX
  252                        	
  253                        	; **************
  254                        	; 16-bytes of SGX blkmap info.
  255                        	;
  256                        	; N.B. MUST be 16-bytes after the VDC versions to use SGX_VDC_OFFSET.
  257                        	
  258    F8:2889             	sgx_old_chr_x:	ds	1	; Previous top-left X in CHR (lo-byte only).
  259    F8:288A             	sgx_old_chr_y:	ds	1	; Previous top-left Y in CHR (lo-byte only).
  260                        	
  261    F8:288B             	sgx_tbl_addr:	ds	2	; 256-byte aligned.
  262    F8:288D             	sgx_tbl_bank:	ds	1
  263                        	
  264    F8:288E             	sgx_blk_addr:	ds	2	; 2KBytes of data, 256-byte aligned.
  265    F8:2890             	sgx_blk_bank:	ds	1
  266                        	
  267    F8:2891             	sgx_map_addr:	ds	2	; Mapped into MPR3..MPR4, max 8KBytes.
  268    F8:2893             	sgx_map_bank:	ds	1
  269                        	
  270    F8:2894             	sgx_scr_addr:	ds	2	; 8KByte maximum size.
  271    F8:2896             	sgx_scr_bank:	ds	1
  272    F8:2897             	sgx_scr_chr12:	ds	1	; Which CHR banks are used by the BLK, with
  273    F8:2898             	sgx_scr_chr34:	ds	1	; a max of 16 banks per multi-screen map.
  274                        	
  275                        		.endif	SUPPORT_SGX
  276                        	
  277               0000     		.if	0
  310                        		.endif	0
  311                        	
  312                        	; **************
  313                        	; Aliases for the asm variable names in HuCC.
  314                        	;
  315                        	
  316               0001     		.ifdef	HUCC
  317                        	
  318    F8:2899             	_map_blk_flag	.alias	map_blk_flag
  319    F8:2899             	_map_blk_mask	.alias	map_blk_mask
  320                        	
  321    F8:2899             	_vdc_map_draw_w	.alias	vdc_map_draw_w
  322    F8:2899             	_vdc_map_draw_h	.alias	vdc_map_draw_h
  323    F8:2899             	_vdc_map_pxl_x	.alias	vdc_map_pxl_x
  324    F8:2899             	_vdc_map_pxl_y	.alias	vdc_map_pxl_y
  325    F8:2899             	_vdc_old_chr_x	.alias	vdc_old_chr_x
  326    F8:2899             	_vdc_old_chr_y	.alias	vdc_old_chr_y
  327    F8:2899             	_vdc_tbl_addr	.alias	vdc_tbl_addr
  328    F8:2899             	_vdc_tbl_bank	.alias	vdc_tbl_bank
  329    F8:2899             	_vdc_blk_addr	.alias	vdc_blk_addr
  330    F8:2899             	_vdc_blk_bank	.alias	vdc_blk_bank
  331    F8:2899             	_vdc_map_line_w	.alias	vdc_map_line_w
  332    F8:2899             	_vdc_map_scrn_w	.alias	vdc_map_scrn_w
  333    F8:2899             	_vdc_map_addr	.alias	vdc_map_addr
  334    F8:2899             	_vdc_map_bank	.alias	vdc_map_bank
  335    F8:2899             	_vdc_scr_addr	.alias	vdc_scr_addr
  336    F8:2899             	_vdc_scr_bank	.alias	vdc_scr_bank
  337    F8:2899             	_vdc_scr_chr12	.alias	vdc_scr_chr12
  338    F8:2899             	_vdc_scr_chr34	.alias	vdc_scr_chr34
  339                        	
  340               0001     		.if	SUPPORT_SGX
  341    F8:2899             	_sgx_map_draw_w	.alias	sgx_map_draw_w
  342    F8:2899             	_sgx_map_draw_h	.alias	sgx_map_draw_h
  343    F8:2899             	_sgx_map_pxl_x	.alias	sgx_map_pxl_x
  344    F8:2899             	_sgx_map_pxl_y	.alias	sgx_map_pxl_y
  345    F8:2899             	_sgx_old_chr_x	.alias	sgx_old_chr_x
  346    F8:2899             	_sgx_old_chr_y	.alias	sgx_old_chr_y
  347    F8:2899             	_sgx_tbl_addr	.alias	sgx_tbl_addr
  348    F8:2899             	_sgx_tbl_bank	.alias	sgx_tbl_bank
  349    F8:2899             	_sgx_blk_addr	.alias	sgx_blk_addr
  350    F8:2899             	_sgx_blk_bank	.alias	sgx_blk_bank
  351    F8:2899             	_sgx_map_line_w	.alias	sgx_map_line_w
  352    F8:2899             	_sgx_map_scrn_w	.alias	sgx_map_scrn_w
  353    F8:2899             	_sgx_map_addr	.alias	sgx_map_addr
  354    F8:2899             	_sgx_map_bank	.alias	sgx_map_bank
  355    F8:2899             	_sgx_scr_addr	.alias	sgx_scr_addr
  356    F8:2899             	_sgx_scr_bank	.alias	sgx_scr_bank
  357    F8:2899             	_sgx_scr_chr12	.alias	sgx_scr_chr12
  358    F8:2899             	_sgx_scr_chr34	.alias	sgx_scr_chr34
  359                        		.endif	SUPPORT_SGX
  360                        	
  361                        		.endif	HUCC
  362                        	
  363                        	; **************
  364                        	; Temporary variables for drawing, using common zero-page locations.
  365                        	;
  366                        	
  367               20F8     	map_bat_x	=	_al	; Set by draw_map(), scroll_map() if drawing
  368               20F9     	map_bat_y	=	_ah	; aligned, or as parameters to blit_map().
  369                        	
  370               20FA     	map_draw_w	=	_bl	; Set by draw_map(), scroll_map(), but given
  371               20FB     	map_draw_h	=	_bh	; as parameters to blit_map().
  372                        	
  373               20FC     	map_pxl_x	=	_cx	; Set by draw_map(), scroll_map() and also by
  374               20FC     	map_chr_x	=	_cl	; blit__map(), from current vdc_map_pxl_x.
  375               20FD     	map_scrn_x	=	_ch
  376                        	
  377               20FE     	map_pxl_y	=	_dx	; Set by draw_map(), scroll_map() and also by
  378               20FE     	map_chr_y	=	_dl	; blit__map(), from current vdc_map_pxl_y.
  379               20FF     	map_scrn_y	=	_dh
  380                        	
  381               20EE     	map_line	=	_si	; Start of map data line being drawn.
  382                        	
  383               2000     	map_count	=	__temp + 0
  384               2001     	map_drawn	=	__temp + 1
  385                        	
  386               E937     			.code
  387                        	
  388                        	
  389                        	
  390    0B:CC78             	blkmap_group	.procgroup
  391                        	
  392                        	; ***************************************************************************
  393                        	; ***************************************************************************
  394                        	;
  395                        	; _set_blocks - Initialize the block definition pointers.
  396                        	; _sgx_set_blocks - Initialize the block definition pointers.
  397                        	;
  398                        	; void __fastcall set_blocks( unsigned char __far *blk_def<vdc_blk_bank:vdc_blk_addr>, unsigned char __far *flg_def<vdc_tbl_bank:vdc_tbl_addr>, unsigned char number_of_blk<_al> );
  399                        	; void __fastcall sgx_set_blocks( unsigned char __far *blk_def<sgx_blk_bank:sgx_blk_addr>, unsigned char __far *flg_def<sgx_tbl_bank:sgx_tbl_addr>, unsigned char number_of_blk<_al> );
  400                        	;
  401                        	
  402               0001     		.if	SUPPORT_SGX
  403                        	
  404                        			.proc	_sgx_set_blocks.3
  410                        			.endp
  411                        		.endif
  412                        	
  413    0B:CC78             			.proc	_set_blocks.3
  414                        	
  415    0B:CC78  82         			clx				; Offset to PCE VDC.
  416                        	
  417    0B:CC79  BD 7C 28   			lda.h	vdc_tbl_addr, x		; Remap the address to MPR2.
  418    0B:CC7C  29 1F      			and	#$1F
  419    0B:CC7E  09 40      			ora	#$40
  420    0B:CC80  9D 7C 28   			sta.h	vdc_tbl_addr, x
  421                        	
  422    0B:CC83  BD 7F 28   			lda.h	vdc_blk_addr, x		; Remap the address to MPR2.
  423    0B:CC86  29 1F      			and	#$1F
  424    0B:CC88  09 40      			ora	#$40
  425    0B:CC8A  9D 7F 28   			sta.h	vdc_blk_addr, x
  426                        	
  427               0000     		.if	BLKDEF_POINTERS
  479                        		.endif	BLKDEF_POINTERS
  480                        	
  481                        			leave
         0B:CC8D  4C EF FF   			jmp	leave_proc
  482                        	
  483                        			.endp
  484                        	
  485                        	
  486                        	
  487                        	; ***************************************************************************
  488                        	; ***************************************************************************
  489                        	;
  490                        	; _draw_map - Draw the entire screen at the current coordinates.
  491                        	; _sgx_draw_map - Draw the entire screen at the current coordinates.
  492                        	;
  493                        	; void __fastcall draw_map( void );
  494                        	; void __fastcall sgx_draw_map( void );
  495                        	;
  496                        	
  497               0001     		.if	SUPPORT_SGX
  498                        	
  499    0B:CC90             	_sgx_draw_map	.proc
  500                        	
  501    0B:CC90  A2 10      			ldx	#SGX_VDC_OFFSET		; Offset to SGX VDC.
  502    0B:CC92  F0         			db	$F0			; Turn "clx" into a "beq".
  503                        	
  504    0B:CC93             			.ref	_draw_map
  505                        			.endp
  506                        		.endif
  507                        	
  508    0B:CC93             	_draw_map	.proc
  509                        	
  510    0B:CC93  82         			clx				; Offset to PCE VDC.
  511                        	
  512    0B:CC94  43 04      			tma2				; Preserve MPR2..MPR4.
  513    0B:CC96  48         			pha
  514    0B:CC97  43 08      			tma3
  515    0B:CC99  48         			pha
  516    0B:CC9A  43 10      			tma4
  517    0B:CC9C  48         			pha
  518               0000     		.if	BLKMAP_LARGEMAP
  521                        		.endif
  522                        	
  523    0B:CC9D  20 9F CD   			jsr	map_pxl_2_chr		; Set up the draw coordinates.
  524                        	
  525    0B:CCA0  A5 FC      			lda	<map_chr_x		; Reset previous X position.
  526    0B:CCA2  9D 79 28   			sta	vdc_old_chr_x, x
  527                        	
  528    0B:CCA5  A5 FE      			lda	<map_chr_y		; Reset previous Y position,
  529    0B:CCA7  1A         			inc	a			; ready to draw multiple rows.
  530    0B:CCA8  9D 7A 28   			sta	vdc_old_chr_y, x
  531                        	
  532    0B:CCAB  BD 42 23   			lda	vdc_map_draw_w, x	; Draw the whole screen.
  533    0B:CCAE  85 FA      			sta	<map_draw_w
  534    0B:CCB0  BD 43 23   			lda	vdc_map_draw_h, x
  535    0B:CCB3  85 FB      			sta	<map_draw_h
  536                        	
  537    0B:CCB5  20 F5 CF   			jsr	map_scroll_y		; Draw N row of CHR to the BAT.
  538                        	
  539               0000     		.if	BLKMAP_LARGEMAP
  542                        		.endif
  543    0B:CCB8  68         			pla				; Restore MPR2..MPR4.
  544    0B:CCB9  53 10      			tam4
  545    0B:CCBB  68         			pla
  546    0B:CCBC  53 08      			tam3
  547    0B:CCBE  68         			pla
  548    0B:CCBF  53 04      			tam2
  549                        	
  550                        			leave
         0B:CCC1  4C EF FF   			jmp	leave_proc
  551                        	
  552                        			.endp
  553                        	
  554                        	
  555                        	
  556                        	; ***************************************************************************
  557                        	; ***************************************************************************
  558                        	;
  559                        	; _scroll_map - Draw a single row of CHR into the BAT to update the edge.
  560                        	; _sgx_scroll_map - Draw a single row of CHR into the BAT to update the edge.
  561                        	;
  562                        	; void __fastcall scroll_map( void );
  563                        	; void __fastcall sgx_scroll_map( void );
  564                        	;
  565                        	
  566               0001     		.if	SUPPORT_SGX
  567                        	
  568    0B:CCC4             	_sgx_scroll_map	.proc
  569                        	
  570    0B:CCC4  A2 10      			ldx	#SGX_VDC_OFFSET		; Offset to SGX VDC.
  571    0B:CCC6  F0         			db	$F0			; Turn "clx" into a "beq".
  572                        	
  573    0B:CCC7             			.ref	_scroll_map
  574                        			.endp
  575                        		.endif
  576                        	
  577    0B:CCC7             	_scroll_map	.proc
  578                        	
  579    0B:CCC7  82         			clx				; Offset to PCE VDC.
  580                        	
  581               0000     		.if	BLKMAP_TIMETEST
  587                        		.endif
  588                        	
  589    0B:CCC8  43 04      			tma2				; Preserve MPR2..MPR4.
  590    0B:CCCA  48         			pha
  591    0B:CCCB  43 08      			tma3
  592    0B:CCCD  48         			pha
  593    0B:CCCE  43 10      			tma4
  594    0B:CCD0  48         			pha
  595               0000     		.if	BLKMAP_LARGEMAP
  598                        		.endif
  599                        	
  600    0B:CCD1  20 9F CD   			jsr	map_pxl_2_chr		; Set up the draw coordinates.
  601                        	
  602               0001     		.if	BLKMAP_MULTISCR
  603    0B:CCD4  A5 FD      			lda	<map_scrn_x		; map_scroll_x can change this!
  604    0B:CCD6  48         			pha
  605                        		.endif
  606                        	
  607    0B:CCD7  BD 43 23   			lda	vdc_map_draw_h, x	; Draw new LHS or RHS if needed.
  608    0B:CCDA  85 FB      			sta	<map_draw_h
  609                        	;		lda	#1			; map_scroll_x only ever draws a
  610                        	;		sta	<map_draw_w		; single column.
  611    0B:CCDC  20 D6 CE   			jsr	map_scroll_x
  612                        	
  613    0B:CCDF  BD 79 28   			lda	vdc_old_chr_x, x	; Restore map_chr_x which could
  614    0B:CCE2  85 FC      			sta	<map_chr_x		; be changed by map_scroll_x.
  615                        	
  616               0001     		.if	BLKMAP_MULTISCR
  617    0B:CCE4  68         			pla				; Restore before map_scroll_y.
  618    0B:CCE5  85 FD      			sta	<map_scrn_x
  619                        		.endif
  620                        	
  621    0B:CCE7  BD 42 23   			lda	vdc_map_draw_w, x	; Draw new TOP or BTM if needed.
  622    0B:CCEA  85 FA      			sta	<map_draw_w
  623    0B:CCEC  A9 01      			lda	#1
  624    0B:CCEE  85 FB      			sta	<map_draw_h
  625    0B:CCF0  20 F5 CF   			jsr	map_scroll_y
  626                        	
  627               0000     		.if	BLKMAP_LARGEMAP
  630                        		.endif
  631    0B:CCF3  68         			pla				; Restore MPR2..MPR4.
  632    0B:CCF4  53 10      			tam4
  633    0B:CCF6  68         			pla
  634    0B:CCF7  53 08      			tam3
  635    0B:CCF9  68         			pla
  636    0B:CCFA  53 04      			tam2
  637                        	
  638               0000     		.if	BLKMAP_TIMETEST
  640                        		.endif
  641                        	
  642                        			leave
         0B:CCFC  4C EF FF   			jmp	leave_proc
  643                        	
  644                        			.endp
  645                        	
  646                        	
  647                        	
  648                        	; ***************************************************************************
  649                        	; ***************************************************************************
  650                        	;
  651                        	; _blit_map - Draw a map rectangle to specific BAT coordinates.
  652                        	; _sgx_blit_map - Draw a map rectangle to specific BAT coordinates.
  653                        	;
  654                        	; void __fastcall blit_map( unsigned char tile_x<map_bat_x>, unsigned char tile_y<map_bat_y>, unsigned char tile_w<map_draw_x>, unsigned char tile_h<map_draw_y> );
  655                        	; void __fastcall sgx_blit_map( unsigned char tile_x<map_bat_x>, unsigned char tile_y<map_bat_y>, unsigned char tile_w<map_draw_x>, unsigned char tile_h<map_draw_y> );
  656                        	;
  657                        	; Normally you'd just use _draw_map() and _scroll_map(), but for those folks
  658                        	; who really wish to take manual control, you can use this.
  659                        	;
  660                        	
  661               0001     		.if	SUPPORT_SGX
  662                        	
  663                        	_sgx_blit_map	.proc
  669                        			.endp
  670                        		.endif
  671                        	
  672    0B:CCFF             	_blit_map	.proc
  673                        	
  674    0B:CCFF  82         			clx				; Offset to PCE VDC.
  675                        	
  676    0B:CD00  BD 86 28   			lda	vdc_scr_bank, x		; Skip this if a multi-screen
  677    0B:CD03  D0 36      			bne	.exit			; blkmap.
  678                        	
  679    0B:CD05  43 04      			tma2				; Preserve MPR2..MPR4.
  680    0B:CD07  48         			pha
  681    0B:CD08  43 08      			tma3
  682    0B:CD0A  48         			pha
  683    0B:CD0B  43 10      			tma4
  684    0B:CD0D  48         			pha
  685               0000     		.if	BLKMAP_LARGEMAP
  688                        		.endif
  689                        	
  690    0B:CD0E  BD 4A 23   			lda	vdc_map_option, x	; Preserve current map options.
  691    0B:CD11  48         			pha
  692    0B:CD12  09 C0      			ora	#MAP_UNALIGNED_X | MAP_UNALIGNED_Y
  693    0B:CD14  9D 4A 23   			sta	vdc_map_option, x
  694                        	
  695    0B:CD17  20 9F CD   			jsr	map_pxl_2_chr		; Set up the draw coordinates.
  696                        	
  697    0B:CD1A  A5 FA      			lda	<map_draw_w		; Are we drawing just 1 column?
  698    0B:CD1C  C9 01      			cmp	#1
  699    0B:CD1E  F0 1E      			beq	.draw_column
  700                        	
  701                        			; Draw N rows.
  702                        	
  703    0B:CD20  A5 FC      	.draw_rows:	lda	<map_chr_x		; Reset previous X position.
  704    0B:CD22  9D 79 28   			sta	vdc_old_chr_x, x
  705                        	
  706    0B:CD25  A5 FE      			lda	<map_chr_y		; Reset previous Y position,
  707    0B:CD27  1A         			inc	a			; ready to draw rows upwards.
  708    0B:CD28  9D 7A 28   			sta	vdc_old_chr_y, x
  709                        	
  710    0B:CD2B  20 F5 CF   			jsr	map_scroll_y		; Draw a row of CHR to the BAT.
  711                        	
  712                        			; Drawing completed.
  713                        	
  714    0B:CD2E  68         	.finished:	pla				; Restore previous map options.
  715    0B:CD2F  9D 4A 23   			sta	vdc_map_option, x
  716                        	
  717               0000     		.if	BLKMAP_LARGEMAP
  720                        		.endif
  721    0B:CD32  68         			pla				; Restore MPR2..MPR4.
  722    0B:CD33  53 10      			tam4
  723    0B:CD35  68         			pla
  724    0B:CD36  53 08      			tam3
  725    0B:CD38  68         			pla
  726    0B:CD39  53 04      			tam2
  727                        	
  728                        	.exit:		leave
         0B:CD3B  4C EF FF   			jmp	leave_proc
  729                        	
  730                        			; Draw 1 column.
  731                        	
  732    0B:CD3E  A5 FC      	.draw_column:	lda	<map_chr_x		; Reset previous X position.
  733    0B:CD40  1A         			inc	a			; ready to draw 1 column.
  734    0B:CD41  9D 79 28   			sta	vdc_old_chr_x, x
  735                        	
  736    0B:CD44  A5 FE      			lda	<map_chr_y		; Reset previous Y position.
  737    0B:CD46  9D 7A 28   			sta	vdc_old_chr_y, x
  738                        	
  739    0B:CD49  20 D6 CE   			jsr	map_scroll_x		; Draw a single column of CHR.
  740                        	
  741    0B:CD4C  80 E0      			bra	.finished
  742                        	
  743                        			.endp
  744                        	
  745                        	
  746                        	
  747                        	; ***************************************************************************
  748                        	; ***************************************************************************
  749                        	;
  750                        	; _get_map_block - Get the block number used at a map pixel coordinate.
  751                        	; _sgx_get_map_block - Get the block number used at a map pixel coordinate.
  752                        	;
  753                        	; unsigned char __fastcall _get_map_block( unsigned int x<map_pxl_x>, unsigned int y<map_pxl_y> );
  754                        	; unsigned char __fastcall _sgx_get_map_block( unsigned int x<map_pxl_x>, unsigned int y<map_pxl_y> );
  755                        	;
  756                        	
  757               0001     		.if	SUPPORT_SGX
  758                        	
  759                        			.proc	_sgx_get_map_block.2
  765                        			.endp
  766                        		.endif
  767                        	
  768    0B:CD4E             			.proc	_get_map_block.2
  769                        	
  770    0B:CD4E  82         			clx				; Offset to PCE VDC.
  771                        	
  772    0B:CD4F  43 04      			tma2				; Preserve MPR2..MPR4.
  773    0B:CD51  48         			pha
  774    0B:CD52  43 08      			tma3
  775    0B:CD54  48         			pha
  776    0B:CD55  43 10      			tma4
  777    0B:CD57  48         			pha
  778               0000     		.if	BLKMAP_LARGEMAP
  781                        		.endif
  782                        	
  783    0B:CD58  20 B3 CD   			jsr	xvt_pxl_2_chr		; Set up the query coordinates.
  784                        	
  785    0B:CD5B  20 E1 CD   			jsr	map_chr_2_data		; Page in the map address.
  786                        	
  787    0B:CD5E  B2 EC      			lda	[_bp]			; Read the BLK from the map.
  788    0B:CD60  A8         			tay
  789                        	
  790    0B:CD61  A5 FC      			lda	<map_chr_x		; Calc the BLK address offset
  791    0B:CD63  4A         			lsr	a			; use depending upon even/odd
  792    0B:CD64  A5 FE      			lda	<map_chr_y		; CHR coordinates (not BAT to
  793    0B:CD66  29 01      			and	#1			; support unaligned drawing).
  794    0B:CD68  2A         			rol	a
  795    0B:CD69  09 04      			ora	#4			; Offset to BLK table top byte.
  796    0B:CD6B  7D 7F 28   			adc.h	vdc_blk_addr, x		; What is the BLK data address?
  797    0B:CD6E  85 ED      			sta.h	<_bp			; $4000, $4800, $5000 or $5800.
  798    0B:CD70  64 EC      			stz.l	<_bp
  799    0B:CD72  B1 EC      			lda	[_bp], y		; Read the collision flags from
  800    0B:CD74  29 0C      			and	#%00001100		; the top byte of the CHR.
  801    0B:CD76  4A         			lsr	a
  802    0B:CD77  4A         			lsr	a
  803    0B:CD78  4A         			lsr	a			; Swizzle the bottom bit to get
  804    0B:CD79  90 02      			bcc	!+			; the same bit order as used in
  805    0B:CD7B  09 02      			ora	#2			; .HALTMAP layer.
  806    0B:CD7D  8D 77 28   	!:		sta	map_blk_flag
  807                        	
  808    0B:CD80  BD 7D 28   			lda	vdc_tbl_bank, x		; Is there a table of flags?
  809    0B:CD83  F0 09      			beq	!+
  810    0B:CD85  53 08      			tam3
  811                        	;		inc	a
  812                        	;		tam4
  813                        	;		lda.l	vdc_tbl_addr, x
  814                        	;		sta.l	<_bp
  815    0B:CD87  BD 7C 28   			lda.h	vdc_tbl_addr, x		; If so, it must be aligned!
  816    0B:CD8A  85 ED      			sta.h	<_bp
  817    0B:CD8C  B1 EC      			lda	[_bp], y		; Read the .MASKMAP/.OVERMAP
  818    0B:CD8E  8D 78 28   	!:		sta	map_blk_mask		; flag value for this BLK.
  819                        	
  820               0000     		.if	BLKMAP_LARGEMAP
  823                        		.endif
  824    0B:CD91  68         			pla				; Restore MPR2..MPR4.
  825    0B:CD92  53 10      			tam4
  826    0B:CD94  68         			pla
  827    0B:CD95  53 08      			tam3
  828    0B:CD97  68         			pla
  829    0B:CD98  53 04      			tam2
  830                        	
  831    0B:CD9A  02         			sxy				; Put the BLK number in X.
  832    0B:CD9B  C2         			cly
  833                        	
  834                        			leave				; All done!
         0B:CD9C  4C EF FF   			jmp	leave_proc
  835                        	
  836                        			.endp
  837                        	
  838                        	
  839                        	
  840                        	; ***************************************************************************
  841                        	; ***************************************************************************
  842                        	;
  843                        	; map_pxl_2_chr - Convert PXL to CHR, BLK and SCR coordinates.
  844                        	;
  845                        	
  846    0B:CD9F  BD 48 23   	map_pxl_2_chr:	lda.l	vdc_map_pxl_y, x	; Get current map Y coordinate.
  847    0B:CDA2  85 FE      			sta.l	<map_pxl_y
  848    0B:CDA4  BD 49 23   			lda.h	vdc_map_pxl_y, x
  849    0B:CDA7  85 FF      			sta.h	<map_pxl_y
  850                        	
  851    0B:CDA9  BD 46 23   			lda.l	vdc_map_pxl_x, x	; Get current map X coordinate.
  852    0B:CDAC  85 FC      			sta.l	<map_pxl_x
  853    0B:CDAE  BD 47 23   			lda.h	vdc_map_pxl_x, x
  854    0B:CDB1  85 FD      			sta.h	<map_pxl_x
  855                        	
  856    0B:CDB3  A5 FD      	xvt_pxl_2_chr:	lda.h	<map_pxl_x		; Xvert map_pxl_x to map_chr_x.
  857               0001     		.if	BLKMAP_MULTISCR
  858    0B:CDB5  A8         			tay				; Xvert map_pxl_x to map_scrn_x.
  859    0B:CDB6  3C 3D 23   			bit	vdc_bat_width, x
  860    0B:CDB9  70 03      			bvs	.w64
  861    0B:CDBB  10 02      			bpl	.w32
  862    0B:CDBD  4A         	.w128:		lsr	a
  863    0B:CDBE  4A         	.w64:		lsr	a
  864    0B:CDBF  85 FD      	.w32:		sta	<map_scrn_x
  865    0B:CDC1  98         			tya
  866                        		.endif
  867    0B:CDC2  4A         			lsr	a
  868    0B:CDC3  66 FC      			ror.l	<map_pxl_x
  869    0B:CDC5  4A         			lsr	a
  870    0B:CDC6  66 FC      			ror.l	<map_pxl_x
  871    0B:CDC8  4A         			lsr	a
  872    0B:CDC9  66 FC      			ror.l	<map_pxl_x		; Max map width is 256 CHR.
  873                        	
  874    0B:CDCB  A5 FF      			lda.h	<map_pxl_y		; Xvert map_pxl_y to map_chr_y.
  875               0001     		.if	BLKMAP_MULTISCR
  876    0B:CDCD  A8         			tay				; Xvert map_pxl_y to map_scrn_y.
  877    0B:CDCE  3C 3E 23   			bit	vdc_bat_height, x
  878    0B:CDD1  50 01      			bvc	.h32
  879    0B:CDD3  4A         	.h64:		lsr	a
  880    0B:CDD4  85 FF      	.h32:		sta	<map_scrn_y
  881    0B:CDD6  98         			tya
  882                        		.endif
  883    0B:CDD7  4A         			lsr	a
  884    0B:CDD8  66 FE      			ror.l	<map_pxl_y
  885    0B:CDDA  4A         			lsr	a
  886    0B:CDDB  66 FE      			ror.l	<map_pxl_y
  887    0B:CDDD  4A         			lsr	a
  888    0B:CDDE  66 FE      			ror.l	<map_pxl_y		; Max map width is 256 CHR.
  889                        	
  890    0B:CDE0  60         			rts
  891                        	
  892                        	
  893                        	
  894                        	; ***************************************************************************
  895                        	; ***************************************************************************
  896                        	;
  897                        	; map_chr_2_data - Page in the MAP address for the CHR coordinates.
  898                        	;
  899                        	
  900    0B:CDE1             	map_chr_2_data:
  901                        	
  902               0001     		.if	BLKMAP_MULTISCR
  903                        	
  904                        			; Initialization for a multi-screen map.
  905                        	
  906    0B:CDE1  BD 86 28   			lda	vdc_scr_bank, x		; Skip this if regular blkmap.
  907    0B:CDE4  F0 3A      			beq	.regular
  908                        	
  909    0B:CDE6  A5 FC      	.multiscreen:	lda	<map_chr_x		; Compare old_x with cur_x.
  910    0B:CDE8  3D 3F 23   			and	vdc_bat_x_mask, x
  911    0B:CDEB  85 F8      			sta	<map_bat_x		; Save BAT X chr coordinate.
  912                        	
  913    0B:CDED  A5 FE      			lda	<map_chr_y		; Save BAT Y chr coordinate.
  914    0B:CDEF  3D 40 23   			and	vdc_bat_y_mask, x
  915    0B:CDF2  85 F9      			sta	<map_bat_y
  916    0B:CDF4  4A         			lsr	a			; Map BLK Y coordinate.
  917    0B:CDF5  85 EF      			sta.h	<map_line
  918    0B:CDF7  62         			cla
  919    0B:CDF8  3C 3D 23   			bit	vdc_bat_width, x
  920    0B:CDFB  30 08      			bmi	.w128
  921    0B:CDFD  70 03      			bvs	.w64
  922    0B:CDFF  46 EF      	.w32:		lsr.h	<map_line
  923    0B:CE01  6A         			ror	a
  924    0B:CE02  46 EF      	.w64:		lsr.h	<map_line
  925    0B:CE04  6A         			ror	a
  926    0B:CE05  46 EF      	.w128:		lsr.h	<map_line
  927    0B:CE07  6A         			ror	a
  928    0B:CE08  46 EF      			lsr.h	<map_line		; Hi-byte of (BLK Y * width).
  929    0B:CE0A  6A         			ror	a
  930    0B:CE0B  85 EE      			sta.l	<map_line		; Lo-byte of (BLK Y * width).
  931                        	
  932    0B:CE0D  20 61 CE   			jsr	map_set_screen		; Put BLK & MAP in MPR2-MPR5.
  933                        	
  934    0B:CE10  A5 F8      			lda	<map_bat_x		; Calc map data pointer.
  935    0B:CE12  4A         			lsr	a			; Map BLK X coordinate.
  936    0B:CE13  05 EE      			ora.l	<map_line
  937    0B:CE15  85 EC      			sta.l	<_bp
  938    0B:CE17  A5 EF      			lda.h	<map_line
  939    0B:CE19  18         			clc
  940    0B:CE1A  7D 82 28   			adc.h	vdc_map_addr, x		; N.B. 256-byte aligned!
  941    0B:CE1D  85 ED      			sta.h	<_bp
  942                        	
  943    0B:CE1F  60         			rts
  944                        	
  945                        		.endif	BLKMAP_MULTISCR
  946                        	
  947                        			; Initialization for a regular map.
  948                        	
  949    0B:CE20  A5 FC      	.regular:	lda	<map_chr_x		; Compare old_x with cur_x.
  950                        	;		bit	vdc_map_option, x	; Set bit7 to disable aligning
  951                        	;		bmi	!+			; BAT X with the map X.
  952    0B:CE22  3D 3F 23   			and	vdc_bat_x_mask, x
  953    0B:CE25  85 F8      			sta	<map_bat_x		; Save BAT X chr coordinate.
  954                        	
  955    0B:CE27  A5 FE      	!:		lda	<map_chr_y		; A = map CHR Y coordinate.
  956    0B:CE29  A8         			tay
  957    0B:CE2A  4A         			lsr	a
  958    0B:CE2B  42         			say				; Y = map BLK Y coordinate.
  959                        	
  960                        	;		bit	vdc_map_option, x	; Set bit6 to disable aligning
  961                        	;		bvs	!+			; BAT Y with the map Y.
  962    0B:CE2C  3D 40 23   			and	vdc_bat_y_mask, x
  963    0B:CE2F  85 F9      			sta	<map_bat_y		; Save BAT Y chr coordinate.
  964                        	
  965               0000     		.if	BLKMAP_LARGEMAP
  970                        		.endif
  971                        	
  972    0B:CE31  BD 44 23   	!:		lda	vdc_map_line_w, x	; Map width in BLK.
  973               0000     		.if	FAST_MULTIPLY
  986                        		.else
  987    0B:CE34  84 EF      			sty.h	<map_line		; Takes 144..176 cycles.
  988    0B:CE36  A0 08      			ldy	#8
  989    0B:CE38  4A         			lsr	a
  990    0B:CE39  85 EE      			sta.l	<map_line
  991    0B:CE3B  62         			cla
  992    0B:CE3C  90 03      			bcc	.rotate
  993    0B:CE3E  18         	.add:		clc
  994    0B:CE3F  65 EF      			adc.h	<map_line
  995    0B:CE41  6A         	.rotate:	ror	a
  996    0B:CE42  66 EE      			ror.l	<map_line		; Lo-byte of (BLK Y * width).
  997    0B:CE44  88         			dey
  998    0B:CE45  B0 F7      			bcs	.add
  999    0B:CE47  D0 F8      			bne	.rotate
 1000    0B:CE49  A8         			tay				; Hi-byte of (BLK Y * width).
 1001                        		.endif
 1002                        	
 1003    0B:CE4A  A5 FC      	!:		lda	<map_chr_x		; Map CHR X coordinate.
 1004    0B:CE4C  4A         			lsr	a			; Map BLK X coordinate.
 1005    0B:CE4D  18         			clc
 1006    0B:CE4E  65 EE      			adc.l	<map_line		; Lo-byte of (BLK Y * width).
 1007    0B:CE50  90 01      			bcc	!+
 1008    0B:CE52  C8         			iny				; Hi-byte of (BLK Y * width).
 1009                        	
 1010    0B:CE53  18         	!:		clc				; Calc map data pointer.
 1011    0B:CE54  7D 81 28   			adc.l	vdc_map_addr, x
 1012    0B:CE57  85 EC      			sta.l	<_bp			; Maximum map size is 16KBytes
 1013    0B:CE59  98         			tya				; so we don't need to consider
 1014    0B:CE5A  7D 82 28   			adc.h	vdc_map_addr, x		; bank overflow.
 1015    0B:CE5D  85 ED      			sta.h	<_bp
 1016                        	
 1017    0B:CE5F  80 66      			bra	map_set_banks		; Put BLK & MAP in MPR2-MPR5.
 1018                        	
 1019                        	
 1020                        	
 1021               0001     		.if	BLKMAP_MULTISCR
 1022                        	
 1023                        	; ***************************************************************************
 1024                        	; ***************************************************************************
 1025                        	;
 1026                        	; map_set_screen -
 1027                        	;
 1028                        	; Maximum X and Y dimension of 128 screens (32768 pixels).
 1029                        	; Maximum 8KByte total size of screen data (1024 screens).
 1030                        	;
 1031                        	
 1032    0B:CE61  A4 FF      	map_set_screen:	ldy	<map_scrn_y		; Map SCR Y coordinate.
 1033    0B:CE63  BD 45 23   			lda	vdc_map_scrn_w, x	; Map width in SCREENS.
 1034                        	
 1035               0000     		.if	FAST_MULTIPLY
 1048                        		.else
 1049    0B:CE66  84 ED      			sty.h	<_bp			; Takes 144..176 cycles.
 1050    0B:CE68  A0 08      			ldy	#8
 1051    0B:CE6A  4A         			lsr	a
 1052    0B:CE6B  85 EC      			sta.l	<_bp
 1053    0B:CE6D  62         			cla
 1054    0B:CE6E  90 03      			bcc	.rotate
 1055    0B:CE70  18         	.add:		clc
 1056    0B:CE71  65 ED      			adc.h	<_bp
 1057    0B:CE73  6A         	.rotate:	ror	a
 1058    0B:CE74  66 EC      			ror.l	<_bp			; Lo-byte of (SCR Y * width).
 1059    0B:CE76  88         			dey
 1060    0B:CE77  B0 F7      			bcs	.add
 1061    0B:CE79  D0 F8      			bne	.rotate
 1062    0B:CE7B  A8         			tay				; Hi-byte of (SCR Y * width).
 1063                        		.endif
 1064                        	
 1065    0B:CE7C  A5 FD      			lda	<map_scrn_x		; Map SCR X coordinate.
 1066    0B:CE7E  18         			clc
 1067    0B:CE7F  65 EC      			adc.l	<_bp
 1068    0B:CE81  90 01      			bcc	!+
 1069    0B:CE83  C8         			iny
 1070                        	
 1071    0B:CE84  84 ED      	!:		sty.h	<_bp			; 2 bytes per screen entry, max
 1072    0B:CE86  0A         			asl	a			; 8KByte screen table.
 1073    0B:CE87  26 ED      			rol.h	<_bp
 1074               0001     		.if	BLKDEF_POINTERS == 0
 1075    0B:CE89  0A         			asl	a			; 8 bytes per screen entry when
 1076    0B:CE8A  26 ED      			rol.h	<_bp			; not using BLK pointers.
 1077    0B:CE8C  0A         			asl	a
 1078    0B:CE8D  26 ED      			rol.h	<_bp
 1079                        		.endif
 1080                        	
 1081    0B:CE8F  7D 84 28   			adc.l	vdc_scr_addr, x		; Calc screen data pointer.
 1082    0B:CE92  85 EC      			sta.l	<_bp			; Maximum data size is 8KBytes
 1083    0B:CE94  A5 ED      			lda.h	<_bp			; so we don't need to consider
 1084    0B:CE96  7D 85 28   			adc.h	vdc_scr_addr, x		; bank overflow.
 1085    0B:CE99  85 ED      			sta.h	<_bp
 1086                        	
 1087    0B:CE9B  BD 86 28   			lda	vdc_scr_bank, x		; Map the SCR data in MPR3..MPR4.
 1088    0B:CE9E  53 08      			tam3
 1089    0B:CEA0  1A         			inc	a
 1090    0B:CEA1  53 10      			tam4
 1091                        	
 1092    0B:CEA3  C2         			cly
 1093    0B:CEA4  B1 EC      			lda	[_bp], y		; Get SCR_MAP_PAGE.
 1094    0B:CEA6  9D 82 28   			sta.h	vdc_map_addr, x
 1095    0B:CEA9  C8         			iny
 1096    0B:CEAA  B1 EC      			lda	[_bp], y		; Get SCR_MAP_BANK.
 1097    0B:CEAC  9D 83 28   			sta	vdc_map_bank, x
 1098                        	
 1099               0001     		.if	BLKDEF_POINTERS == 0
 1100    0B:CEAF  C8         			iny
 1101    0B:CEB0  B1 EC      			lda	[_bp], y		; Get SCR_BLK_PAGE.
 1102    0B:CEB2  9D 7F 28   			sta.h	vdc_blk_addr, x
 1103    0B:CEB5  C8         			iny
 1104    0B:CEB6  B1 EC      			lda	[_bp], y		; Get SCR_BLK_BANK.
 1105    0B:CEB8  9D 80 28   			sta	vdc_blk_bank, x
 1106    0B:CEBB  C8         			iny
 1107    0B:CEBC  B1 EC      			lda	[_bp], y		; Get SCR_TBL_PAGE.
 1108    0B:CEBE  9D 7C 28   			sta.h	vdc_tbl_addr, x
 1109    0B:CEC1  C8         			iny
 1110    0B:CEC2  B1 EC      			lda	[_bp], y		; Get SCR_TBL_BANK.
 1111    0B:CEC4  9D 7D 28   			sta	vdc_tbl_bank, x
 1112               0000     		.if	0				; These are not currently used.
 1119                        		.endif
 1120                        		.endif
 1121                        	
 1122                        	;		lda	vdc_bat_width, x	; Set up the map width.
 1123                        	;		lsr	a			; This should have been set
 1124                        	;		sta	vdc_map_line_w, x	; with the multi-screen map.
 1125                        	
 1126                        	;		jmp	map_set_banks		; Put BLK & MAP in MPR2-MPR5.
 1127                        	
 1128                        			; Fall through to map_set_banks.
 1129                        	
 1130                        		.endif	BLKMAP_MULTISCR
 1131                        	
 1132                        	
 1133                        	
 1134                        	; ***************************************************************************
 1135                        	; ***************************************************************************
 1136                        	;
 1137                        	; map_set_banks - Put BLK & MAP in MPR2-MPR5.
 1138                        	;
 1139                        	
 1140    0B:CEC7  BD 80 28   	map_set_banks:	lda	vdc_blk_bank, x		; Put the BLK into MPR2.
 1141    0B:CECA  53 04      			tam2
 1142                        	
 1143    0B:CECC  BD 83 28   			lda	vdc_map_bank, x		; Put the MAP into MPR3-MPR5.
 1144    0B:CECF  53 08      			tam3
 1145    0B:CED1  1A         			inc	a
 1146    0B:CED2  53 10      			tam4
 1147               0000     		.if	BLKMAP_LARGEMAP
 1156                        		.endif
 1157                        	
 1158    0B:CED4  60         	!:		rts
 1159                        	
 1160                        	
 1161                        	
 1162                        	; ***************************************************************************
 1163                        	; ***************************************************************************
 1164                        	;
 1165                        	; map_scroll_x - Update the BAT when X coordinate changes.
 1166                        	;
 1167                        	; N.B. This will alter map_chr_x and map_scrn_x if moved in +ve direction!
 1168                        	;
 1169                        	; N.B. This only ever draws a single column!
 1170                        	;
 1171                        	
 1172    0B:CED5  60         	!no_change:	rts
 1173                        	
 1174    0B:CED6             	map_scroll_x:
 1175                        	
 1176               0001     		.if	BLKMAP_MULTISCR
 1177                        	
 1178                        			; Initialization for a multi-screen map.
 1179                        	
 1180    0B:CED6  BD 86 28   			lda	vdc_scr_bank, x		; Skip this if regular blkmap.
 1181    0B:CED9  F0 56      			beq	.regular
 1182                        	
 1183    0B:CEDB  A5 FC      	.multiscreen:	lda	<map_chr_x		; Compare old_x with cur_x.
 1184    0B:CEDD  DD 79 28   			cmp	vdc_old_chr_x, x
 1185               0001     		.if	BLKMAP_TIMETEST == 0
 1186    0B:CEE0  F0 F3      			beq	!no_change-		; Do nothing if no change.
 1187                        		.endif
 1188    0B:CEE2  9D 79 28   			sta	vdc_old_chr_x, x
 1189    0B:CEE5  30 11      			bmi	!+			; Test the sign of the change.
 1190                        	
 1191    0B:CEE7  18         			clc				; Draw RHS if chr_x >= old_x.
 1192    0B:CEE8  3D 3F 23   			and	vdc_bat_x_mask, x
 1193    0B:CEEB  7D 42 23   			adc	vdc_map_draw_w, x	; Usually (SCR_WIDTH / 8) + 1.
 1194    0B:CEEE  3A         			dec	a
 1195    0B:CEEF  85 FC      			sta	<map_chr_x		; Update CHR X chr coordinate.
 1196    0B:CEF1  3C 3D 23   			bit	vdc_bat_width, x
 1197    0B:CEF4  F0 02      			beq	!+
 1198    0B:CEF6  E6 FD      			inc	<map_scrn_x		; Wrapped to the next screen.
 1199                        	
 1200    0B:CEF8  3D 3F 23   	!:		and	vdc_bat_x_mask, x
 1201    0B:CEFB  85 F8      			sta	<map_bat_x		; Save BAT X chr coordinate.
 1202                        	
 1203    0B:CEFD  A5 FE      			lda	<map_chr_y		; Save BAT Y chr coordinate.
 1204    0B:CEFF  3D 40 23   			and	vdc_bat_y_mask, x
 1205    0B:CF02  85 F9      			sta	<map_bat_y
 1206    0B:CF04  4A         			lsr	a			; Map BLK Y coordinate.
 1207    0B:CF05  85 EF      			sta.h	<map_line
 1208    0B:CF07  62         			cla
 1209    0B:CF08  3C 3D 23   			bit	vdc_bat_width, x
 1210    0B:CF0B  30 08      			bmi	.w128
 1211    0B:CF0D  70 03      			bvs	.w64
 1212    0B:CF0F  46 EF      	.w32:		lsr.h	<map_line
 1213    0B:CF11  6A         			ror	a
 1214    0B:CF12  46 EF      	.w64:		lsr.h	<map_line
 1215    0B:CF14  6A         			ror	a
 1216    0B:CF15  46 EF      	.w128:		lsr.h	<map_line
 1217    0B:CF17  6A         			ror	a
 1218    0B:CF18  46 EF      			lsr.h	<map_line		; Hi-byte of (BLK Y * width).
 1219    0B:CF1A  6A         			ror	a
 1220    0B:CF1B  85 EE      			sta.l	<map_line		; Lo-byte of (BLK Y * width).
 1221                        	
 1222    0B:CF1D  20 61 CE   			jsr	map_set_screen		; Put BLK & MAP in MPR2-MPR5.
 1223                        	
 1224    0B:CF20  A5 F8      			lda	<map_bat_x		; Calc map data pointer.
 1225    0B:CF22  4A         			lsr	a			; Map BLK X coordinate.
 1226    0B:CF23  05 EE      			ora.l	<map_line
 1227    0B:CF25  85 EC      			sta.l	<_bp
 1228    0B:CF27  A5 EF      			lda.h	<map_line
 1229    0B:CF29  18         			clc
 1230    0B:CF2A  7D 82 28   			adc.h	vdc_map_addr, x		; N.B. 256-byte aligned!
 1231    0B:CF2D  85 ED      			sta.h	<_bp
 1232                        	
 1233    0B:CF2F  80 5D      			bra	.draw_col		; Now draw it.
 1234                        	
 1235                        		.endif	BLKMAP_MULTISCR
 1236                        	
 1237                        			; Initialization for a regular map.
 1238                        	
 1239    0B:CF31  A5 FC      	.regular:	lda	<map_chr_x		; Compare old_x with cur_x.
 1240    0B:CF33  DD 79 28   			cmp	vdc_old_chr_x, x
 1241               0001     		.if	BLKMAP_TIMETEST == 0
 1242    0B:CF36  F0 9D      			beq	!no_change-		; Do nothing if no change.
 1243                        		.endif
 1244    0B:CF38  9D 79 28   			sta	vdc_old_chr_x, x
 1245    0B:CF3B  30 07      			bmi	!+			; Test the sign of the change.
 1246                        	
 1247    0B:CF3D  18         			clc				; Draw RHS if chr_x >= old_x.
 1248    0B:CF3E  7D 42 23   			adc	vdc_map_draw_w, x	; Usually (SCR_WIDTH / 8) + 1.
 1249    0B:CF41  3A         			dec	a
 1250    0B:CF42  85 FC      			sta	<map_chr_x		; Update CHR X chr coordinate.
 1251                        	
 1252    0B:CF44  3C 4A 23   	!:		bit	vdc_map_option, x	; Set bit7 to disable aligning
 1253    0B:CF47  30 05      			bmi	!+			; BAT X with the map X.
 1254    0B:CF49  3D 3F 23   			and	vdc_bat_x_mask, x
 1255    0B:CF4C  85 F8      			sta	<map_bat_x		; Save BAT X chr coordinate.
 1256                        	
 1257    0B:CF4E  A5 FE      	!:		lda	<map_chr_y		; A = map CHR Y coordinate.
 1258    0B:CF50  A8         			tay
 1259    0B:CF51  4A         			lsr	a
 1260    0B:CF52  42         			say				; Y = map BLK Y coordinate.
 1261                        	
 1262    0B:CF53  3C 4A 23   			bit	vdc_map_option, x	; Set bit6 to disable aligning
 1263    0B:CF56  70 05      			bvs	!+			; BAT Y with the map Y.
 1264    0B:CF58  3D 40 23   			and	vdc_bat_y_mask, x
 1265    0B:CF5B  85 F9      			sta	<map_bat_y		; Save BAT Y chr coordinate.
 1266                        	
 1267               0000     		.if	BLKMAP_LARGEMAP
 1272                        		.endif
 1273                        	
 1274    0B:CF5D  BD 44 23   	!:		lda	vdc_map_line_w, x	; Map width in BLK.
 1275               0000     		.if	FAST_MULTIPLY
 1288                        		.else
 1289    0B:CF60  84 EF      			sty.h	<map_line		; Takes 144..176 cycles.
 1290    0B:CF62  A0 08      			ldy	#8
 1291    0B:CF64  4A         			lsr	a
 1292    0B:CF65  85 EE      			sta.l	<map_line
 1293    0B:CF67  62         			cla
 1294    0B:CF68  90 03      			bcc	.rotate
 1295    0B:CF6A  18         	.add:		clc
 1296    0B:CF6B  65 EF      			adc.h	<map_line
 1297    0B:CF6D  6A         	.rotate:	ror	a
 1298    0B:CF6E  66 EE      			ror.l	<map_line		; Lo-byte of (BLK Y * width).
 1299    0B:CF70  88         			dey
 1300    0B:CF71  B0 F7      			bcs	.add
 1301    0B:CF73  D0 F8      			bne	.rotate
 1302    0B:CF75  A8         			tay				; Hi-byte of (BLK Y * width).
 1303                        		.endif
 1304                        	
 1305    0B:CF76  A5 FC      	!:		lda	<map_chr_x		; Map CHR X coordinate.
 1306    0B:CF78  4A         			lsr	a			; Map BLK X coordinate.
 1307    0B:CF79  18         			clc
 1308    0B:CF7A  65 EE      			adc.l	<map_line		; Lo-byte of (BLK Y * width).
 1309    0B:CF7C  90 01      			bcc	!+
 1310    0B:CF7E  C8         			iny				; Hi-byte of (BLK Y * width).
 1311                        	
 1312    0B:CF7F  18         	!:		clc				; Calc map data pointer.
 1313    0B:CF80  7D 81 28   			adc.l	vdc_map_addr, x
 1314    0B:CF83  85 EC      			sta.l	<_bp			; Maximum map size is 16KBytes
 1315    0B:CF85  98         			tya				; so we don't need to consider
 1316    0B:CF86  7D 82 28   			adc.h	vdc_map_addr, x		; bank overflow.
 1317    0B:CF89  85 ED      			sta.h	<_bp
 1318                        	
 1319    0B:CF8B  20 C7 CE   			jsr	map_set_banks		; Put BLK & MAP in MPR2-MPR5.
 1320                        	
 1321                        			; Draw the first part of the column.
 1322                        	
 1323    0B:CF8E  A5 F8      	.draw_col:	lda	<map_bat_x		; Set the BAT VRAM destination
 1324    0B:CF90  85 F0      			sta.l	<_di			; coordinates.
 1325    0B:CF92  A5 F9      			lda	<map_bat_y
 1326    0B:CF94  85 F1      			sta.h	<_di
 1327                        	
 1328    0B:CF96  5D 40 23   			eor	vdc_bat_y_mask, x	; Calc CHR before wrap.
 1329    0B:CF99  1A         			inc	a
 1330    0B:CF9A  DD 43 23   			cmp	vdc_map_draw_h, x	; Usually (SCR_HEIGHT / 8) + 1.
 1331    0B:CF9D  90 03      			bcc	!+
 1332    0B:CF9F  BD 43 23   			lda	vdc_map_draw_h, x	; Maximum CHR to draw.
 1333    0B:CFA2  85 00      	!:		sta	<map_count		; Set number of CHR to draw.
 1334    0B:CFA4  85 01      			sta	<map_drawn		; Preserve number of CHR drawn.
 1335                        	
 1336    0B:CFA6  A9 05      			lda	#VDC_CR			; Set VDC auto-increment from
 1337    0B:CFA8  95 F7      			sta	<vdc_reg, x		; the BAT width, which is set
 1338    0B:CFAA  9D 00 02   			sta	VDC_AR, x		; up by set_screen_size().
 1339    0B:CFAD  B5 F4      			lda	<vdc_crh, x
 1340    0B:CFAF  9D 03 02   			sta	VDC_DH, x
 1341                        	
 1342    0B:CFB2  20 F4 D2   			jsr	blk_col_strip		; Draw top of vertical strip.
 1343                        	
 1344                        			; Wrap around and draw the rest of the column (if needed).
 1345                        	
 1346    0B:CFB5  38         			sec				; Are there any more CHR that
 1347    0B:CFB6  BD 43 23   			lda	vdc_map_draw_h, x	; need to be drawn?
 1348    0B:CFB9  E5 01      			sbc	<map_drawn
 1349    0B:CFBB  F0 2C      			beq	.done
 1350                        	
 1351    0B:CFBD  85 00      			sta	<map_count		; Set number of CHR to draw.
 1352                        	
 1353    0B:CFBF  A5 FE      			lda	<map_chr_y		; Update CHR Y coordinate for
 1354    0B:CFC1  48         			pha				; drawing unaligned tiles.
 1355    0B:CFC2  18         			clc
 1356    0B:CFC3  65 01      			adc	<map_drawn
 1357    0B:CFC5  85 FE      			sta	<map_chr_y
 1358                        	
 1359               0001     		.if	BLKMAP_MULTISCR
 1360    0B:CFC7  BD 86 28   			lda	vdc_scr_bank, x		; Skip this if regular blkmap.
 1361    0B:CFCA  F0 0F      			beq	!+
 1362                        	
 1363    0B:CFCC  E6 FF      			inc	<map_scrn_y		; Wrapped to the next screen.
 1364                        	
 1365    0B:CFCE  20 61 CE   			jsr	map_set_screen		; Put BLK & MAP in MPR2-MPR5.
 1366                        	
 1367    0B:CFD1  A5 F8      			lda	<map_bat_x		; Calc map data pointer.
 1368    0B:CFD3  4A         			lsr	a			; Map BLK X coordinate.
 1369    0B:CFD4  85 EC      			sta.l	<_bp
 1370    0B:CFD6  BD 82 28   			lda.h	vdc_map_addr, x		; N.B. 256-byte aligned!
 1371    0B:CFD9  85 ED      			sta.h	<_bp
 1372                        		.endif
 1373                        	
 1374    0B:CFDB  A5 F8      	!:		lda	<map_bat_x		; Set the BAT VRAM destination
 1375    0B:CFDD  85 F0      			sta.l	<_di			; coordinates.
 1376    0B:CFDF  64 F1      			stz.h	<_di			; Reset 1st row to draw.
 1377                        	
 1378    0B:CFE1  20 F4 D2   			jsr	blk_col_strip		; Draw btm of vertical strip.
 1379                        	
 1380               0001     		.if	BLKMAP_MULTISCR
 1381    0B:CFE4  C6 FF      			dec	<map_scrn_y		; Restore, no check if should.
 1382                        		.endif
 1383                        	
 1384    0B:CFE6  68         			pla				; Restore CHR Y coordinate, we
 1385    0B:CFE7  85 FE      			sta	<map_chr_y		; might draw another column!
 1386                        	
 1387    0B:CFE9  A9 05      	.done:		lda	#VDC_CR			; Set VDC auto-increment to 1.
 1388    0B:CFEB  95 F7      			sta	<vdc_reg, x
 1389    0B:CFED  9D 00 02   			sta	VDC_AR, x
 1390    0B:CFF0  9E 03 02   			stz	VDC_DH, x
 1391                        	
 1392    0B:CFF3  60         			rts
 1393                        	
 1394                        	
 1395                        	
 1396                        	; ***************************************************************************
 1397                        	; ***************************************************************************
 1398                        	;
 1399                        	; map_scroll_y - Update the BAT when Y coordinate changes.
 1400                        	;
 1401                        	; N.B. This will alter map_chr_y and map_scrn_y if moved in +ve direction!
 1402                        	;
 1403                        	; N.B. This draws multiple rows when called from _draw_map or _blit_map.
 1404                        	;
 1405                        	
 1406    0B:CFF4  60         	!no_change:	rts
 1407                        	
 1408    0B:CFF5             	map_scroll_y:
 1409                        	
 1410               0001     		.if	BLKMAP_MULTISCR
 1411                        	
 1412                        			; Initialization for a multi-screen map.
 1413                        	
 1414    0B:CFF5  BD 86 28   			lda	vdc_scr_bank, x		; Skip this if regular blkmap.
 1415    0B:CFF8  F0 56      			beq	.regular
 1416                        	
 1417    0B:CFFA  A5 FE      	.multiscr:	lda	<map_chr_y		; Compare old_y with cur_y.
 1418    0B:CFFC  DD 7A 28   			cmp	vdc_old_chr_y, x
 1419               0001     		.if	BLKMAP_TIMETEST == 0
 1420    0B:CFFF  F0 F3      			beq	!no_change-		; Do nothing if no change.
 1421                        		.endif
 1422    0B:D001  9D 7A 28   			sta	vdc_old_chr_y, x
 1423    0B:D004  30 11      			bmi	!+			; Test the sign of the change.
 1424                        	
 1425    0B:D006  18         			clc				; Draw bottom if chr_y >= old_y.
 1426    0B:D007  3D 40 23   			and	vdc_bat_y_mask, x
 1427    0B:D00A  7D 43 23   			adc	vdc_map_draw_h, x	; Usually (SCR_HEIGHT / 8) + 1.
 1428    0B:D00D  3A         			dec	a
 1429    0B:D00E  85 FE      			sta	<map_chr_y		; Update CHR Y chr coordinate.
 1430    0B:D010  3C 3E 23   			bit	vdc_bat_height, x
 1431    0B:D013  F0 02      			beq	!+
 1432    0B:D015  E6 FF      			inc	<map_scrn_y		; Wrapped to the next screen.
 1433                        	
 1434    0B:D017  3D 40 23   	!:		and	vdc_bat_y_mask, x
 1435    0B:D01A  85 F9      			sta	<map_bat_y		; Save BAT Y chr coordinate.
 1436                        	
 1437    0B:D01C  4A         			lsr	a			; Map BLK Y coordinate.
 1438    0B:D01D  85 EF      			sta.h	<map_line
 1439    0B:D01F  62         			cla
 1440    0B:D020  3C 3D 23   			bit	vdc_bat_width, x
 1441    0B:D023  30 08      			bmi	.w128
 1442    0B:D025  70 03      			bvs	.w64
 1443    0B:D027  46 EF      	.w32:		lsr.h	<map_line
 1444    0B:D029  6A         			ror	a
 1445    0B:D02A  46 EF      	.w64:		lsr.h	<map_line
 1446    0B:D02C  6A         			ror	a
 1447    0B:D02D  46 EF      	.w128:		lsr.h	<map_line
 1448    0B:D02F  6A         			ror	a
 1449    0B:D030  46 EF      			lsr.h	<map_line		; Hi-byte of (BLK Y * width).
 1450    0B:D032  6A         			ror	a
 1451    0B:D033  85 EE      			sta.l	<map_line		; Lo-byte of (BLK Y * width).
 1452                        	
 1453    0B:D035  A5 FC      			lda	<map_chr_x
 1454    0B:D037  3D 3F 23   			and	vdc_bat_x_mask, x
 1455    0B:D03A  85 F8      			sta	<map_bat_x		; Save BAT X chr coordinate.
 1456                        	
 1457                        			; Loop to here if drawing multiple multi-screen rows.
 1458                        	
 1459    0B:D03C  20 61 CE   	.multiscr_row:	jsr	map_set_screen		; Put BLK & MAP in MPR2-MPR5.
 1460                        	
 1461    0B:D03F  A5 F8      			lda	<map_bat_x		; Calc map data pointer.
 1462    0B:D041  4A         			lsr	a			; Map BLK X coordinate.
 1463    0B:D042  05 EE      			ora.l	<map_line
 1464    0B:D044  85 EC      			sta.l	<_bp
 1465    0B:D046  A5 EF      			lda.h	<map_line
 1466    0B:D048  18         			clc
 1467    0B:D049  7D 82 28   			adc.h	vdc_map_addr, x		; N.B. 256-byte aligned!
 1468    0B:D04C  85 ED      			sta.h	<_bp
 1469                        	
 1470    0B:D04E  80 60      			bra	.draw_row		; Now draw it.
 1471                        	
 1472                        		.endif	BLKMAP_MULTISCR
 1473                        	
 1474                        			; Initialization for a regular blkmap.
 1475                        	
 1476    0B:D050  A5 FE      	.regular:	lda	<map_chr_y		; Compare old_y with cur_y.
 1477    0B:D052  DD 7A 28   			cmp	vdc_old_chr_y, x
 1478               0001     		.if	BLKMAP_TIMETEST == 0
 1479    0B:D055  F0 9D      			beq	!no_change-		; Do nothing if no change.
 1480                        		.endif
 1481    0B:D057  9D 7A 28   			sta	vdc_old_chr_y, x
 1482    0B:D05A  30 07      			bmi	!+			; Test the sign of the change.
 1483                        	
 1484    0B:D05C  18         			clc				; Draw bottom if chr_y >= old_y.
 1485    0B:D05D  7D 43 23   			adc	vdc_map_draw_h, x	; Usually (SCR_HEIGHT / 8) + 1.
 1486    0B:D060  3A         			dec	a
 1487    0B:D061  85 FE      			sta	<map_chr_y		; Update CHR Y chr coordinate.
 1488                        	
 1489    0B:D063  A8         	!:		tay				; A = map CHR Y coordinate.
 1490    0B:D064  4A         			lsr	a
 1491    0B:D065  42         			say				; Y = map BLK Y coordinate.
 1492                        	
 1493    0B:D066  3C 4A 23   			bit	vdc_map_option, x	; Set bit6 to disable aligning
 1494    0B:D069  70 05      			bvs	!+			; BAT Y with the map Y.
 1495    0B:D06B  3D 40 23   			and	vdc_bat_y_mask, x
 1496    0B:D06E  85 F9      			sta	<map_bat_y		; Save BAT Y chr coordinate.
 1497                        	
 1498    0B:D070  3C 4A 23   	!:		bit	vdc_map_option, x	; Set bit7 to disable aligning
 1499    0B:D073  30 07      			bmi	!+			; BAT X with the map X.
 1500    0B:D075  A5 FC      			lda	<map_chr_x
 1501    0B:D077  3D 3F 23   			and	vdc_bat_x_mask, x
 1502    0B:D07A  85 F8      			sta	<map_bat_x		; Save BAT X chr coordinate.
 1503    0B:D07C             	!:
 1504                        	
 1505               0000     		.if	BLKMAP_LARGEMAP
 1510                        		.endif
 1511                        	
 1512    0B:D07C  BD 44 23   			lda	vdc_map_line_w, x	; Map width in BLK.
 1513               0000     		.if	FAST_MULTIPLY
 1526                        		.else
 1527    0B:D07F  84 EF      			sty.h	<map_line		; Takes 144..176 cycles.
 1528    0B:D081  A0 08      			ldy	#8
 1529    0B:D083  4A         			lsr	a
 1530    0B:D084  85 EE      			sta.l	<map_line
 1531    0B:D086  62         			cla
 1532    0B:D087  90 03      			bcc	.rotate
 1533    0B:D089  18         	.add:		clc
 1534    0B:D08A  65 EF      			adc.h	<map_line
 1535    0B:D08C  6A         	.rotate:	ror	a
 1536    0B:D08D  66 EE      			ror.l	<map_line		; Lo-byte of (BLK Y * width).
 1537    0B:D08F  88         			dey
 1538    0B:D090  B0 F7      			bcs	.add
 1539    0B:D092  D0 F8      			bne	.rotate
 1540    0B:D094  85 EF      			sta.h	<map_line		; Hi-byte of (BLK Y * width).
 1541                        		.endif
 1542                        	
 1543    0B:D096  20 C7 CE   			jsr	map_set_banks		; Put BLK & MAP in MPR2-MPR5.
 1544                        	
 1545                        			; Loop to here if drawing multiple regular blkmap rows.
 1546                        	
 1547    0B:D099  A4 EF      	.regular_row:	ldy.h	<map_line		; Hi-byte of (BLK Y * width).
 1548    0B:D09B  A5 FC      			lda	<map_chr_x		; Map CHR X coordinate.
 1549    0B:D09D  4A         			lsr	a			; Map BLK X coordinate.
 1550    0B:D09E  18         			clc
 1551    0B:D09F  65 EE      			adc.l	<map_line		; Lo-byte of (BLK Y * width).
 1552    0B:D0A1  90 01      			bcc	!+
 1553    0B:D0A3  C8         			iny
 1554    0B:D0A4  18         	!:		clc				; Calc map data pointer.
 1555    0B:D0A5  7D 81 28   			adc.l	vdc_map_addr, x
 1556    0B:D0A8  85 EC      			sta.l	<_bp			; Maximum map size is 16KBytes
 1557    0B:D0AA  98         			tya				; so we don't need to consider
 1558    0B:D0AB  7D 82 28   			adc.h	vdc_map_addr, x		; bank overflow.
 1559    0B:D0AE  85 ED      			sta.h	<_bp
 1560                        	
 1561                        			; Draw the first part of the row.
 1562                        	
 1563    0B:D0B0  A5 F9      	.draw_row:	lda	<map_bat_y		; Set the BAT VRAM destination
 1564    0B:D0B2  85 F1      			sta.h	<_di			; coordinates.
 1565    0B:D0B4  A5 F8      			lda	<map_bat_x
 1566    0B:D0B6  85 F0      			sta.l	<_di
 1567                        	
 1568    0B:D0B8  5D 3F 23   			eor	vdc_bat_x_mask, x	; Calc CHR before wrap.
 1569    0B:D0BB  1A         			inc	a
 1570    0B:D0BC  C5 FA      			cmp	<map_draw_w		; Usually (SCR_WIDTH / 8) + 1.
 1571    0B:D0BE  90 02      			bcc	!+
 1572    0B:D0C0  A5 FA      			lda	<map_draw_w		; Maximum CHR to draw.
 1573    0B:D0C2  85 00      	!:		sta	<map_count		; Set number of CHR to draw.
 1574    0B:D0C4  85 01      			sta	<map_drawn		; Preserve number of CHR drawn.
 1575                        	
 1576    0B:D0C6  20 36 D1   			jsr	blk_row_strip		; Draw lhs of horizontal strip.
 1577                        	
 1578                        			; Wrap around and draw the rest of the row (if needed).
 1579                        	
 1580    0B:D0C9  38         			sec				; Are there any more CHR that
 1581    0B:D0CA  A5 FA      			lda	<map_draw_w		; need to be drawn?
 1582    0B:D0CC  E5 01      			sbc	<map_drawn
 1583    0B:D0CE  F0 2E      			beq	.done_row
 1584                        	
 1585    0B:D0D0  85 00      			sta	<map_count		; Set number of CHR to draw.
 1586                        	
 1587    0B:D0D2  A5 FC      			lda	<map_chr_x		; Update CHR X coordinate for
 1588    0B:D0D4  48         			pha				; drawing unaligned tiles.
 1589    0B:D0D5  18         			clc
 1590    0B:D0D6  65 01      			adc	<map_drawn
 1591    0B:D0D8  85 FC      			sta	<map_chr_x
 1592                        	
 1593               0001     		.if	BLKMAP_MULTISCR
 1594    0B:D0DA  BD 86 28   			lda	vdc_scr_bank, x		; Skip this if regular blkmap.
 1595    0B:D0DD  F0 11      			beq	!+
 1596                        	
 1597    0B:D0DF  E6 FD      			inc	<map_scrn_x		; Wrapped to the next screen.
 1598                        	
 1599    0B:D0E1  20 61 CE   			jsr	map_set_screen		; Locate screen's BLK and MAP.
 1600                        	
 1601    0B:D0E4  18         			clc				; Calc map data pointer.
 1602    0B:D0E5  A5 EE      			lda.l	<map_line
 1603    0B:D0E7  85 EC      			sta.l	<_bp
 1604    0B:D0E9  A5 EF      			lda.h	<map_line
 1605    0B:D0EB  7D 82 28   			adc.h	vdc_map_addr, x		; N.B. 256-byte aligned!
 1606    0B:D0EE  85 ED      			sta.h	<_bp
 1607                        		.endif
 1608                        	
 1609    0B:D0F0  A5 F9      	!:		lda	<map_bat_y		; Set the BAT VRAM destination
 1610    0B:D0F2  85 F1      			sta.h	<_di			; coordinates.
 1611    0B:D0F4  64 F0      			stz.l	<_di			; Reset 1st column to draw.
 1612                        	
 1613    0B:D0F6  20 36 D1   			jsr	blk_row_strip		; Draw rhs of horizontal strip.
 1614                        	
 1615               0001     		.if	BLKMAP_MULTISCR
 1616    0B:D0F9  C6 FD      			dec	<map_scrn_x		; Restore, no check if should.
 1617                        		.endif	BLKMAP_MULTISCR
 1618                        	
 1619    0B:D0FB  68         			pla				; Restore CHR X coordinate, we
 1620    0B:D0FC  85 FC      			sta	<map_chr_x		; might draw another row!
 1621                        	
 1622    0B:D0FE  C6 FB      	.done_row:	dec	<map_draw_h		; Are all desired rows drawn?
 1623    0B:D100  F0 33      			beq	.finished
 1624                        	
 1625    0B:D102  E6 FE      			inc	<map_chr_y		; Move CHR Y down by 1.
 1626                        	
 1627    0B:D104  A5 FE      			lda	<map_chr_y		; If new BLK then ...
 1628    0B:D106  4A         			lsr	a
 1629    0B:D107  B0 0B      			bcs	!+
 1630    0B:D109  BD 44 23   			lda	vdc_map_line_w, x	; Move the map line pointer to
 1631    0B:D10C  65 EE      			adc.l	<map_line		; the next line.
 1632    0B:D10E  85 EE      			sta.l	<map_line
 1633    0B:D110  90 02      			bcc	!+
 1634    0B:D112  E6 EF      			inc.h	<map_line
 1635                        	
 1636    0B:D114  A5 F9      	!:		lda	<map_bat_y		; Move BAT Y down by 1.
 1637    0B:D116  1A         			inc	a
 1638    0B:D117  3D 40 23   			and	vdc_bat_y_mask, x
 1639    0B:D11A  85 F9      			sta	<map_bat_y
 1640                        	
 1641               0001     		.if	BLKMAP_MULTISCR
 1642    0B:D11C  BC 86 28   			ldy	vdc_scr_bank, x		; Skip this if regular blkmap.
 1643    0B:D11F  D0 03 4C 99			beq	.regular_row
         0B:D123  D0          
 1644                        	
 1645    0B:D124  A8         			tay				; If wrapped to the top line of
 1646    0B:D125  D0 0B      			bne	!+			; of the BAT then increment the
 1647    0B:D127  E6 FF      			inc	<map_scrn_y		; screen.
 1648                        	
 1649    0B:D129  BD 41 23   			lda	vdc_bat_limit, x	; The map line must wrap around
 1650    0B:D12C  4A         			lsr	a			; too. This is simple since its
 1651    0B:D12D  4A         			lsr	a			; size (in bytes) is 1/4 of the
 1652    0B:D12E  25 EF      			and.h	<map_line		; BAT size (in words) and it is
 1653    0B:D130  85 EF      			sta.h	<map_line		; a power-of-2.
 1654                        	
 1655    0B:D132  4C 3C D0   	!:		jmp	.multiscr_row		; Draw next row.
 1656                        		.else
 1658                        		.endif	BLKMAP_MULTISCR
 1659                        	
 1660    0B:D135  60         	.finished:	rts
 1661                        	
 1662                        	
 1663                        	
 1664               0000     		.if	BLKDEF_POINTERS
 1858                        		.else	BLKDEF_POINTERS
 1859                        	
 1860                        	
 1861                        	
 1862                        	; ***************************************************************************
 1863                        	; ***************************************************************************
 1864                        	;
 1865                        	; blk_row_strip - Draw a single row of CHR into the BAT.
 1866                        	;
 1867                        	
 1868    0B:D136  20 34 E4   	blk_row_strip:	jsr	set_di_xy_mawr		; Set the BAT VRAM destination.
 1869                        	
 1870    0B:D139  A5 FC      			lda	<map_chr_x		; Select what drawing code to
 1871    0B:D13B  4A         			lsr	a			; use depending upon even/odd
 1872    0B:D13C  A5 FE      			lda	<map_chr_y		; CHR coordinates (not BAT to
 1873    0B:D13E  29 01      			and	#1			; support unaligned drawing).
 1874    0B:D140  2A         			rol	a
 1875    0B:D141  0A         			asl	a
 1876    0B:D142  1D 7F 28   			ora.h	vdc_blk_addr, x		; What is the BLK data address?
 1877    0B:D145  29 1E      			and	#%00011110		; $4000, $4800, $5000 or $5800.
 1878    0B:D147  A8         			tay
 1879    0B:D148  B9 55 D1   			lda.h	.jump_table, y		; Push the address of the code.
 1880    0B:D14B  48         			pha
 1881    0B:D14C  B9 54 D1   			lda.l	.jump_table, y
 1882    0B:D14F  48         			pha
 1883                        	
 1884    0B:D150  B2 EC      			lda	[_bp]			; Get the first BLK number.
 1885    0B:D152  A8         			tay
 1886                        	
 1887    0B:D153  60         			rts				; Jump to the drawing code.
 1888                        	
 1889    0B:D154  76 D1      	.jump_table:	dw	b4000_top_even - 1
 1890    0B:D156  89 D1      			dw	b4000_top_odd - 1
 1891    0B:D158  A6 D1      			dw	b4000_btm_even - 1
 1892    0B:D15A  B9 D1      			dw	b4000_btm_odd - 1
 1893                        	
 1894    0B:D15C  D6 D1      			dw	b4800_top_even - 1
 1895    0B:D15E  E9 D1      			dw	b4800_top_odd - 1
 1896    0B:D160  06 D2      			dw	b4800_btm_even - 1
 1897    0B:D162  19 D2      			dw	b4800_btm_odd - 1
 1898                        	
 1899    0B:D164  36 D2      			dw	b5000_top_even - 1
 1900    0B:D166  49 D2      			dw	b5000_top_odd - 1
 1901    0B:D168  66 D2      			dw	b5000_btm_even - 1
 1902    0B:D16A  79 D2      			dw	b5000_btm_odd - 1
 1903                        	
 1904    0B:D16C  96 D2      			dw	b5800_top_even - 1
 1905    0B:D16E  A9 D2      			dw	b5800_top_odd - 1
 1906    0B:D170  C6 D2      			dw	b5800_btm_even - 1
 1907    0B:D172  D9 D2      			dw	b5800_btm_odd - 1
 1908                        	
 1909                        			; top horizontal (32+2 rept)
 1910                        			;
 1911                        			; 89 cycles per block * 17 -> 1513 cycles
 1912                        	
 1913    0B:D174  B2 EC      	!repeat:	lda	[_bp]			; 7
 1914    0B:D176  A8         			tay				; 2
 1915                        	
 1916    0B:D177  B9 00 40   	b4000_top_even:	lda	BLK_4000_TL_L, y	; 5
 1917    0B:D17A  9D 02 02   			sta	VDC_DL, x		; 6
 1918    0B:D17D  B9 00 44   			lda	BLK_4000_TL_H, y	; 5
 1919               0001     		.if	BLKDEF_CHR_FLAG
 1920    0B:D180  29 F3      			and	#%11110011		; 2
 1921                        		.endif
 1922    0B:D182  1A         			inc	a			; 2
 1923    0B:D183  9D 03 02   			sta	VDC_DH, x		; 6
 1924                        	
 1925    0B:D186  C6 00      			dec	<map_count		; 6
 1926    0B:D188  F0 19      			beq	!end+			; 2
 1927                        	
 1928    0B:D18A  B9 00 41   	b4000_top_odd:	lda	BLK_4000_TR_L, y	; 5
 1929    0B:D18D  9D 02 02   			sta	VDC_DL, x		; 6
 1930    0B:D190  B9 00 45   			lda	BLK_4000_TR_H, y	; 5
 1931               0001     		.if	BLKDEF_CHR_FLAG
 1932    0B:D193  29 F3      			and	#%11110011		; 2
 1933                        		.endif
 1934    0B:D195  1A         			inc	a			; 2
 1935    0B:D196  9D 03 02   			sta	VDC_DH, x		; 6
 1936                        	
 1937    0B:D199  E6 EC      			inc.l	<_bp			; 6
 1938    0B:D19B  D0 02      			bne	!+			; 2/4
 1939    0B:D19D  E6 ED      			inc.h	<_bp			; 6
 1940                        	
 1941    0B:D19F  C6 00      	!:		dec	<map_count		; 6
 1942    0B:D1A1  D0 D1      			bne	!repeat-		; 4
 1943                        	
 1944    0B:D1A3  60         	!end:		rts
 1945                        	
 1946                        			; btm horizontal (32+2 rept)
 1947                        			;
 1948                        			; 89 cycles per block * 17 -> 1513 cycles
 1949                        	
 1950    0B:D1A4  B2 EC      	!repeat:	lda	[_bp]			; 7
 1951    0B:D1A6  A8         			tay				; 2
 1952                        	
 1953    0B:D1A7  B9 00 42   	b4000_btm_even:	lda	BLK_4000_BL_L, y	; 5
 1954    0B:D1AA  9D 02 02   			sta	VDC_DL, x		; 6
 1955    0B:D1AD  B9 00 46   			lda	BLK_4000_BL_H, y	; 5
 1956               0001     		.if	BLKDEF_CHR_FLAG
 1957    0B:D1B0  29 F3      			and	#%11110011		; 2
 1958                        		.endif
 1959    0B:D1B2  1A         			inc	a			; 2
 1960    0B:D1B3  9D 03 02   			sta	VDC_DH, x		; 6
 1961                        	
 1962    0B:D1B6  C6 00      			dec	<map_count		; 6
 1963    0B:D1B8  F0 19      			beq	!end+			; 2
 1964                        	
 1965    0B:D1BA  B9 00 43   	b4000_btm_odd:	lda	BLK_4000_BR_L, y	; 5
 1966    0B:D1BD  9D 02 02   			sta	VDC_DL, x		; 6
 1967    0B:D1C0  B9 00 47   			lda	BLK_4000_BR_H, y	; 5
 1968               0001     		.if	BLKDEF_CHR_FLAG
 1969    0B:D1C3  29 F3      			and	#%11110011		; 2
 1970                        		.endif
 1971    0B:D1C5  1A         			inc	a			; 2
 1972    0B:D1C6  9D 03 02   			sta	VDC_DH, x		; 6
 1973                        	
 1974    0B:D1C9  E6 EC      			inc.l	<_bp			; 6
 1975    0B:D1CB  D0 02      			bne	!+			; 2/4
 1976    0B:D1CD  E6 ED      			inc.h	<_bp			; 6
 1977                        	
 1978    0B:D1CF  C6 00      	!:		dec	<map_count		; 6
 1979    0B:D1D1  D0 D1      			bne	!repeat-		; 4
 1980                        	
 1981    0B:D1D3  60         	!end:		rts
 1982                        	
 1983                        			; top horizontal (32+2 rept)
 1984                        			;
 1985                        			; 89 cycles per block * 17 -> 1513 cycles
 1986                        	
 1987    0B:D1D4  B2 EC      	!repeat:	lda	[_bp]			; 7
 1988    0B:D1D6  A8         			tay				; 2
 1989                        	
 1990    0B:D1D7  B9 00 48   	b4800_top_even:	lda	BLK_4800_TL_L, y	; 5
 1991    0B:D1DA  9D 02 02   			sta	VDC_DL, x		; 6
 1992    0B:D1DD  B9 00 4C   			lda	BLK_4800_TL_H, y	; 5
 1993               0001     		.if	BLKDEF_CHR_FLAG
 1994    0B:D1E0  29 F3      			and	#%11110011		; 2
 1995                        		.endif
 1996    0B:D1E2  1A         			inc	a			; 2
 1997    0B:D1E3  9D 03 02   			sta	VDC_DH, x		; 6
 1998                        	
 1999    0B:D1E6  C6 00      			dec	<map_count		; 6
 2000    0B:D1E8  F0 19      			beq	!end+			; 2
 2001                        	
 2002    0B:D1EA  B9 00 49   	b4800_top_odd:	lda	BLK_4800_TR_L, y	; 5
 2003    0B:D1ED  9D 02 02   			sta	VDC_DL, x		; 6
 2004    0B:D1F0  B9 00 4D   			lda	BLK_4800_TR_H, y	; 5
 2005               0001     		.if	BLKDEF_CHR_FLAG
 2006    0B:D1F3  29 F3      			and	#%11110011		; 2
 2007                        		.endif
 2008    0B:D1F5  1A         			inc	a			; 2
 2009    0B:D1F6  9D 03 02   			sta	VDC_DH, x		; 6
 2010                        	
 2011    0B:D1F9  E6 EC      			inc.l	<_bp			; 6
 2012    0B:D1FB  D0 02      			bne	!+			; 2/4
 2013    0B:D1FD  E6 ED      			inc.h	<_bp			; 6
 2014                        	
 2015    0B:D1FF  C6 00      	!:		dec	<map_count		; 6
 2016    0B:D201  D0 D1      			bne	!repeat-		; 4
 2017                        	
 2018    0B:D203  60         	!end:		rts
 2019                        	
 2020                        			; btm horizontal (32+2 rept)
 2021                        			;
 2022                        			; 89 cycles per block * 17 -> 1513 cycles
 2023                        	
 2024    0B:D204  B2 EC      	!repeat:	lda	[_bp]			; 7
 2025    0B:D206  A8         			tay				; 2
 2026                        	
 2027    0B:D207  B9 00 4A   	b4800_btm_even:	lda	BLK_4800_BL_L, y	; 5
 2028    0B:D20A  9D 02 02   			sta	VDC_DL, x		; 6
 2029    0B:D20D  B9 00 4E   			lda	BLK_4800_BL_H, y	; 5
 2030               0001     		.if	BLKDEF_CHR_FLAG
 2031    0B:D210  29 F3      			and	#%11110011		; 2
 2032                        		.endif
 2033    0B:D212  1A         			inc	a			; 2
 2034    0B:D213  9D 03 02   			sta	VDC_DH, x		; 6
 2035                        	
 2036    0B:D216  C6 00      			dec	<map_count		; 6
 2037    0B:D218  F0 19      			beq	!end+			; 2
 2038                        	
 2039    0B:D21A  B9 00 4B   	b4800_btm_odd:	lda	BLK_4800_BR_L, y	; 5
 2040    0B:D21D  9D 02 02   			sta	VDC_DL, x		; 6
 2041    0B:D220  B9 00 4F   			lda	BLK_4800_BR_H, y	; 5
 2042               0001     		.if	BLKDEF_CHR_FLAG
 2043    0B:D223  29 F3      			and	#%11110011		; 2
 2044                        		.endif
 2045    0B:D225  1A         			inc	a			; 2
 2046    0B:D226  9D 03 02   			sta	VDC_DH, x		; 6
 2047                        	
 2048    0B:D229  E6 EC      			inc.l	<_bp			; 6
 2049    0B:D22B  D0 02      			bne	!+			; 2/4
 2050    0B:D22D  E6 ED      			inc.h	<_bp			; 6
 2051                        	
 2052    0B:D22F  C6 00      	!:		dec	<map_count		; 6
 2053    0B:D231  D0 D1      			bne	!repeat-		; 4
 2054                        	
 2055    0B:D233  60         	!end:		rts
 2056                        	
 2057                        			; top horizontal (32+2 rept)
 2058                        			;
 2059                        			; 89 cycles per block * 17 -> 1513 cycles
 2060                        	
 2061    0B:D234  B2 EC      	!repeat:	lda	[_bp]			; 7
 2062    0B:D236  A8         			tay				; 2
 2063                        	
 2064    0B:D237  B9 00 50   	b5000_top_even:	lda	BLK_5000_TL_L, y	; 5
 2065    0B:D23A  9D 02 02   			sta	VDC_DL, x		; 6
 2066    0B:D23D  B9 00 54   			lda	BLK_5000_TL_H, y	; 5
 2067               0001     		.if	BLKDEF_CHR_FLAG
 2068    0B:D240  29 F3      			and	#%11110011		; 2
 2069                        		.endif
 2070    0B:D242  1A         			inc	a			; 2
 2071    0B:D243  9D 03 02   			sta	VDC_DH, x		; 6
 2072                        	
 2073    0B:D246  C6 00      			dec	<map_count		; 6
 2074    0B:D248  F0 19      			beq	!end+			; 2
 2075                        	
 2076    0B:D24A  B9 00 51   	b5000_top_odd:	lda	BLK_5000_TR_L, y	; 5
 2077    0B:D24D  9D 02 02   			sta	VDC_DL, x		; 6
 2078    0B:D250  B9 00 55   			lda	BLK_5000_TR_H, y	; 5
 2079               0001     		.if	BLKDEF_CHR_FLAG
 2080    0B:D253  29 F3      			and	#%11110011		; 2
 2081                        		.endif
 2082    0B:D255  1A         			inc	a			; 2
 2083    0B:D256  9D 03 02   			sta	VDC_DH, x		; 6
 2084                        	
 2085    0B:D259  E6 EC      			inc.l	<_bp			; 6
 2086    0B:D25B  D0 02      			bne	!+			; 2/4
 2087    0B:D25D  E6 ED      			inc.h	<_bp			; 6
 2088                        	
 2089    0B:D25F  C6 00      	!:		dec	<map_count		; 6
 2090    0B:D261  D0 D1      			bne	!repeat-		; 4
 2091                        	
 2092    0B:D263  60         	!end:		rts
 2093                        	
 2094                        			; btm horizontal (32+2 rept)
 2095                        			;
 2096                        			; 89 cycles per block * 17 -> 1513 cycles
 2097                        	
 2098    0B:D264  B2 EC      	!repeat:	lda	[_bp]			; 7
 2099    0B:D266  A8         			tay				; 2
 2100                        	
 2101    0B:D267  B9 00 52   	b5000_btm_even:	lda	BLK_5000_BL_L, y	; 5
 2102    0B:D26A  9D 02 02   			sta	VDC_DL, x		; 6
 2103    0B:D26D  B9 00 56   			lda	BLK_5000_BL_H, y	; 5
 2104               0001     		.if	BLKDEF_CHR_FLAG
 2105    0B:D270  29 F3      			and	#%11110011		; 2
 2106                        		.endif
 2107    0B:D272  1A         			inc	a			; 2
 2108    0B:D273  9D 03 02   			sta	VDC_DH, x		; 6
 2109                        	
 2110    0B:D276  C6 00      			dec	<map_count		; 6
 2111    0B:D278  F0 19      			beq	!end+			; 2
 2112                        	
 2113    0B:D27A  B9 00 53   	b5000_btm_odd:	lda	BLK_5000_BR_L, y	; 5
 2114    0B:D27D  9D 02 02   			sta	VDC_DL, x		; 6
 2115    0B:D280  B9 00 57   			lda	BLK_5000_BR_H, y	; 5
 2116               0001     		.if	BLKDEF_CHR_FLAG
 2117    0B:D283  29 F3      			and	#%11110011		; 2
 2118                        		.endif
 2119    0B:D285  1A         			inc	a			; 2
 2120    0B:D286  9D 03 02   			sta	VDC_DH, x		; 6
 2121                        	
 2122    0B:D289  E6 EC      			inc.l	<_bp			; 6
 2123    0B:D28B  D0 02      			bne	!+			; 2/4
 2124    0B:D28D  E6 ED      			inc.h	<_bp			; 6
 2125                        	
 2126    0B:D28F  C6 00      	!:		dec	<map_count		; 6
 2127    0B:D291  D0 D1      			bne	!repeat-		; 4
 2128                        	
 2129    0B:D293  60         	!end:		rts
 2130                        	
 2131                        			; top horizontal (32+2 rept)
 2132                        			;
 2133                        			; 89 cycles per block * 17 -> 1513 cycles
 2134                        	
 2135    0B:D294  B2 EC      	!repeat:	lda	[_bp]			; 7
 2136    0B:D296  A8         			tay				; 2
 2137                        	
 2138    0B:D297  B9 00 58   	b5800_top_even:	lda	BLK_5800_TL_L, y	; 5
 2139    0B:D29A  9D 02 02   			sta	VDC_DL, x		; 6
 2140    0B:D29D  B9 00 5C   			lda	BLK_5800_TL_H, y	; 5
 2141               0001     		.if	BLKDEF_CHR_FLAG
 2142    0B:D2A0  29 F3      			and	#%11110011		; 2
 2143                        		.endif
 2144    0B:D2A2  1A         			inc	a			; 2
 2145    0B:D2A3  9D 03 02   			sta	VDC_DH, x		; 6
 2146                        	
 2147    0B:D2A6  C6 00      			dec	<map_count		; 6
 2148    0B:D2A8  F0 19      			beq	!end+			; 2
 2149                        	
 2150    0B:D2AA  B9 00 59   	b5800_top_odd:	lda	BLK_5800_TR_L, y	; 5
 2151    0B:D2AD  9D 02 02   			sta	VDC_DL, x		; 6
 2152    0B:D2B0  B9 00 5D   			lda	BLK_5800_TR_H, y	; 5
 2153               0001     		.if	BLKDEF_CHR_FLAG
 2154    0B:D2B3  29 F3      			and	#%11110011		; 2
 2155                        		.endif
 2156    0B:D2B5  1A         			inc	a			; 2
 2157    0B:D2B6  9D 03 02   			sta	VDC_DH, x		; 6
 2158                        	
 2159    0B:D2B9  E6 EC      			inc.l	<_bp			; 6
 2160    0B:D2BB  D0 02      			bne	!+			; 2/4
 2161    0B:D2BD  E6 ED      			inc.h	<_bp			; 6
 2162                        	
 2163    0B:D2BF  C6 00      	!:		dec	<map_count		; 6
 2164    0B:D2C1  D0 D1      			bne	!repeat-		; 4
 2165                        	
 2166    0B:D2C3  60         	!end:		rts
 2167                        	
 2168                        			; btm horizontal (32+2 rept)
 2169                        			;
 2170                        			; 89 cycles per block * 17 -> 1513 cycles
 2171                        	
 2172    0B:D2C4  B2 EC      	!repeat:	lda	[_bp]		; 7
 2173    0B:D2C6  A8         			tay				; 2
 2174                        	
 2175    0B:D2C7  B9 00 5A   	b5800_btm_even:	lda	BLK_5800_BL_L, y	; 5
 2176    0B:D2CA  9D 02 02   			sta	VDC_DL, x		; 6
 2177    0B:D2CD  B9 00 5E   			lda	BLK_5800_BL_H, y	; 5
 2178               0001     		.if	BLKDEF_CHR_FLAG
 2179    0B:D2D0  29 F3      			and	#%11110011		; 2
 2180                        		.endif
 2181    0B:D2D2  1A         			inc	a			; 2
 2182    0B:D2D3  9D 03 02   			sta	VDC_DH, x		; 6
 2183                        	
 2184    0B:D2D6  C6 00      			dec	<map_count		; 6
 2185    0B:D2D8  F0 19      			beq	!end+			; 2
 2186                        	
 2187    0B:D2DA  B9 00 5B   	b5800_btm_odd:	lda	BLK_5800_BR_L, y	; 5
 2188    0B:D2DD  9D 02 02   			sta	VDC_DL, x		; 6
 2189    0B:D2E0  B9 00 5F   			lda	BLK_5800_BR_H, y	; 5
 2190               0001     		.if	BLKDEF_CHR_FLAG
 2191    0B:D2E3  29 F3      			and	#%11110011		; 2
 2192                        		.endif
 2193    0B:D2E5  1A         			inc	a			; 2
 2194    0B:D2E6  9D 03 02   			sta	VDC_DH, x		; 6
 2195                        	
 2196    0B:D2E9  E6 EC      			inc.l	<_bp			; 6
 2197    0B:D2EB  D0 02      			bne	!+			; 2/4
 2198    0B:D2ED  E6 ED      			inc.h	<_bp			; 6
 2199                        	
 2200    0B:D2EF  C6 00      	!:		dec	<map_count		; 6
 2201    0B:D2F1  D0 D1      			bne	!repeat-		; 4
 2202                        	
 2203    0B:D2F3  60         	!end:		rts
 2204                        	
 2205                        	
 2206                        	
 2207                        	; ***************************************************************************
 2208                        	; ***************************************************************************
 2209                        	;
 2210                        	; blk_col_strip - Draw a single column of CHR into the BAT.
 2211                        	;
 2212                        	
 2213    0B:D2F4  20 34 E4   	blk_col_strip:	jsr	set_di_xy_mawr		; Set the BAT VRAM destination.
 2214                        	
 2215    0B:D2F7  A5 FC      			lda	<map_chr_x		; Select what drawing code to
 2216    0B:D2F9  4A         			lsr	a			; use depending upon even/odd
 2217    0B:D2FA  A5 FE      			lda	<map_chr_y		; CHR coordinates (not BAT to
 2218    0B:D2FC  29 01      			and	#1			; support unaligned drawing).
 2219    0B:D2FE  2A         			rol	a
 2220    0B:D2FF  0A         			asl	a			; N.B. Always leaves C clear.
 2221    0B:D300  1D 7F 28   			ora.h	vdc_blk_addr, x		; What is the BLK data address?
 2222    0B:D303  29 1E      			and	#%00011110		; $4000, $4800, $5000 or $5800.
 2223    0B:D305  A8         			tay
 2224    0B:D306  B9 13 D3   			lda.h	.jump_table, y		; Push the address of the code.
 2225    0B:D309  48         			pha
 2226    0B:D30A  B9 12 D3   			lda.l	.jump_table, y
 2227    0B:D30D  48         			pha
 2228                        	
 2229    0B:D30E  B2 EC      			lda	[_bp]			; Get the first BLK number.
 2230    0B:D310  A8         			tay
 2231                        	
 2232    0B:D311  60         			rts				; Jump to the drawing code.
 2233                        	
 2234    0B:D312  34 D3      	.jump_table:	dw	b4000_lhs_even - 1
 2235    0B:D314  6A D3      			dw	b4000_rhs_even - 1
 2236    0B:D316  47 D3      			dw	b4000_lhs_odd - 1
 2237    0B:D318  7D D3      			dw	b4000_rhs_odd - 1
 2238                        	
 2239    0B:D31A  A0 D3      			dw	b4800_lhs_even - 1
 2240    0B:D31C  D6 D3      			dw	b4800_rhs_even - 1
 2241    0B:D31E  B3 D3      			dw	b4800_lhs_odd - 1
 2242    0B:D320  E9 D3      			dw	b4800_rhs_odd - 1
 2243                        	
 2244    0B:D322  0C D4      			dw	b5000_lhs_even - 1
 2245    0B:D324  42 D4      			dw	b5000_rhs_even - 1
 2246    0B:D326  1F D4      			dw	b5000_lhs_odd - 1
 2247    0B:D328  55 D4      			dw	b5000_rhs_odd - 1
 2248                        	
 2249    0B:D32A  78 D4      			dw	b5800_lhs_even - 1
 2250    0B:D32C  AE D4      			dw	b5800_rhs_even - 1
 2251    0B:D32E  8B D4      			dw	b5800_lhs_odd - 1
 2252    0B:D330  C1 D4      			dw	b5800_rhs_odd - 1
 2253                        	
 2254                        			; lhs vertical (28+2 rept)
 2255                        			;
 2256                        			; N.B. C is always clear on entry.
 2257                        			;
 2258                        			; 100 cycles per block * 15 -> 1500 cycles
 2259                        	
 2260    0B:D332  B2 EC      	!repeat:	lda	[_bp]			; 7
 2261    0B:D334  A8         			tay				; 2
 2262                        	
 2263    0B:D335  B9 00 40   	b4000_lhs_even:	lda	BLK_4000_TL_L, y	; 5
 2264    0B:D338  9D 02 02   			sta	VDC_DL, x		; 6
 2265    0B:D33B  B9 00 44   			lda	BLK_4000_TL_H, y	; 5
 2266               0001     		.if	BLKDEF_CHR_FLAG
 2267    0B:D33E  29 F3      			and	#%11110011		; 2
 2268                        		.endif
 2269    0B:D340  1A         			inc	a			; 2
 2270    0B:D341  9D 03 02   			sta	VDC_DH, x		; 6
 2271                        	
 2272    0B:D344  C6 00      			dec	<map_count		; 6
 2273    0B:D346  F0 1F      			beq	!end+			; 2
 2274                        	
 2275    0B:D348  B9 00 42   	b4000_lhs_odd:	lda	BLK_4000_BL_L, y	; 5
 2276    0B:D34B  9D 02 02   			sta	VDC_DL, x		; 6
 2277    0B:D34E  B9 00 46   			lda	BLK_4000_BL_H, y	; 5
 2278               0001     		.if	BLKDEF_CHR_FLAG
 2279    0B:D351  29 F3      			and	#%11110011		; 2
 2280                        		.endif
 2281    0B:D353  1A         			inc	a			; 2
 2282    0B:D354  9D 03 02   			sta	VDC_DH, x		; 6
 2283                        	
 2284    0B:D357  BD 44 23   			lda	vdc_map_line_w, x	; 5
 2285    0B:D35A  65 EC      			adc.l	<_bp			; 4
 2286    0B:D35C  85 EC      			sta.l	<_bp			; 4
 2287    0B:D35E  90 03      			bcc	!+			; 2/4
 2288    0B:D360  E6 ED      			inc.h	<_bp			; 6
 2289    0B:D362  18         			clc				; 2
 2290                        	
 2291    0B:D363  C6 00      	!:		dec	<map_count		; 6
 2292    0B:D365  D0 CB      			bne	!repeat-		; 4
 2293                        	
 2294    0B:D367  60         	!end:		rts
 2295                        	
 2296                        			; rhs vertical (28+2 rept)
 2297                        			;
 2298                        			; N.B. C is always clear on entry.
 2299                        			;
 2300                        			; 100 cycles per block * 15 -> 1500 cycles
 2301                        	
 2302    0B:D368  B2 EC      	!repeat:	lda	[_bp]			; 7
 2303    0B:D36A  A8         			tay				; 2
 2304                        	
 2305    0B:D36B  B9 00 41   	b4000_rhs_even:	lda	BLK_4000_TR_L, y	; 5
 2306    0B:D36E  9D 02 02   			sta	VDC_DL, x		; 6
 2307    0B:D371  B9 00 45   			lda	BLK_4000_TR_H, y	; 5
 2308               0001     		.if	BLKDEF_CHR_FLAG
 2309    0B:D374  29 F3      			and	#%11110011		; 2
 2310                        		.endif
 2311    0B:D376  1A         			inc	a			; 2
 2312    0B:D377  9D 03 02   			sta	VDC_DH, x		; 6
 2313                        	
 2314    0B:D37A  C6 00      			dec	<map_count		; 6
 2315    0B:D37C  F0 1F      			beq	!end+			; 2
 2316                        	
 2317    0B:D37E  B9 00 43   	b4000_rhs_odd:	lda	BLK_4000_BR_L, y	; 5
 2318    0B:D381  9D 02 02   			sta	VDC_DL, x		; 6
 2319    0B:D384  B9 00 47   			lda	BLK_4000_BR_H, y	; 5
 2320               0001     		.if	BLKDEF_CHR_FLAG
 2321    0B:D387  29 F3      			and	#%11110011		; 2
 2322                        		.endif
 2323    0B:D389  1A         			inc	a			; 2
 2324    0B:D38A  9D 03 02   			sta	VDC_DH, x		; 6
 2325                        	
 2326    0B:D38D  BD 44 23   			lda	vdc_map_line_w, x	; 5
 2327    0B:D390  65 EC      			adc.l	<_bp			; 4
 2328    0B:D392  85 EC      			sta.l	<_bp			; 4
 2329    0B:D394  90 03      			bcc	!+			; 2/4
 2330    0B:D396  E6 ED      			inc.h	<_bp			; 6
 2331    0B:D398  18         			clc				; 2
 2332                        	
 2333    0B:D399  C6 00      	!:		dec	<map_count		; 6
 2334    0B:D39B  D0 CB      			bne	!repeat-		; 4
 2335                        	
 2336    0B:D39D  60         	!end:		rts
 2337                        	
 2338                        			; lhs vertical (28+2 rept)
 2339                        			;
 2340                        			; N.B. C is always clear on entry.
 2341                        			;
 2342                        			; 100 cycles per block * 15 -> 1500 cycles
 2343                        	
 2344    0B:D39E  B2 EC      	!repeat:	lda	[_bp]			; 7
 2345    0B:D3A0  A8         			tay				; 2
 2346                        	
 2347    0B:D3A1  B9 00 48   	b4800_lhs_even:	lda	BLK_4800_TL_L, y	; 5
 2348    0B:D3A4  9D 02 02   			sta	VDC_DL, x		; 6
 2349    0B:D3A7  B9 00 4C   			lda	BLK_4800_TL_H, y	; 5
 2350               0001     		.if	BLKDEF_CHR_FLAG
 2351    0B:D3AA  29 F3      			and	#%11110011		; 2
 2352                        		.endif
 2353    0B:D3AC  1A         			inc	a			; 2
 2354    0B:D3AD  9D 03 02   			sta	VDC_DH, x		; 6
 2355                        	
 2356    0B:D3B0  C6 00      			dec	<map_count		; 6
 2357    0B:D3B2  F0 1F      			beq	!end+			; 2
 2358                        	
 2359    0B:D3B4  B9 00 4A   	b4800_lhs_odd:	lda	BLK_4800_BL_L, y	; 5
 2360    0B:D3B7  9D 02 02   			sta	VDC_DL, x		; 6
 2361    0B:D3BA  B9 00 4E   			lda	BLK_4800_BL_H, y	; 5
 2362               0001     		.if	BLKDEF_CHR_FLAG
 2363    0B:D3BD  29 F3      			and	#%11110011		; 2
 2364                        		.endif
 2365    0B:D3BF  1A         			inc	a			; 2
 2366    0B:D3C0  9D 03 02   			sta	VDC_DH, x		; 6
 2367                        	
 2368    0B:D3C3  BD 44 23   			lda	vdc_map_line_w, x	; 5
 2369    0B:D3C6  65 EC      			adc.l	<_bp			; 4
 2370    0B:D3C8  85 EC      			sta.l	<_bp			; 4
 2371    0B:D3CA  90 03      			bcc	!+			; 2/4
 2372    0B:D3CC  E6 ED      			inc.h	<_bp			; 6
 2373    0B:D3CE  18         			clc				; 2
 2374                        	
 2375    0B:D3CF  C6 00      	!:		dec	<map_count		; 6
 2376    0B:D3D1  D0 CB      			bne	!repeat-		; 4
 2377                        	
 2378    0B:D3D3  60         	!end:		rts
 2379                        	
 2380                        			; rhs vertical (28+2 rept)
 2381                        			;
 2382                        			; N.B. C is always clear on entry.
 2383                        			;
 2384                        			; 100 cycles per block * 15 -> 1500 cycles
 2385                        	
 2386    0B:D3D4  B2 EC      	!repeat:	lda	[_bp]			; 7
 2387    0B:D3D6  A8         			tay				; 2
 2388                        	
 2389    0B:D3D7  B9 00 49   	b4800_rhs_even:	lda	BLK_4800_TR_L, y	; 5
 2390    0B:D3DA  9D 02 02   			sta	VDC_DL, x		; 6
 2391    0B:D3DD  B9 00 4D   			lda	BLK_4800_TR_H, y	; 5
 2392               0001     		.if	BLKDEF_CHR_FLAG
 2393    0B:D3E0  29 F3      			and	#%11110011		; 2
 2394                        		.endif
 2395    0B:D3E2  1A         			inc	a			; 2
 2396    0B:D3E3  9D 03 02   			sta	VDC_DH, x		; 6
 2397                        	
 2398    0B:D3E6  C6 00      			dec	<map_count		; 6
 2399    0B:D3E8  F0 1F      			beq	!end+			; 2
 2400                        	
 2401    0B:D3EA  B9 00 4B   	b4800_rhs_odd:	lda	BLK_4800_BR_L, y	; 5
 2402    0B:D3ED  9D 02 02   			sta	VDC_DL, x		; 6
 2403    0B:D3F0  B9 00 4F   			lda	BLK_4800_BR_H, y	; 5
 2404               0001     		.if	BLKDEF_CHR_FLAG
 2405    0B:D3F3  29 F3      			and	#%11110011		; 2
 2406                        		.endif
 2407    0B:D3F5  1A         			inc	a			; 2
 2408    0B:D3F6  9D 03 02   			sta	VDC_DH, x		; 6
 2409                        	
 2410    0B:D3F9  BD 44 23   			lda	vdc_map_line_w, x	; 5
 2411    0B:D3FC  65 EC      			adc.l	<_bp			; 4
 2412    0B:D3FE  85 EC      			sta.l	<_bp			; 4
 2413    0B:D400  90 03      			bcc	!+			; 2/4
 2414    0B:D402  E6 ED      			inc.h	<_bp			; 6
 2415    0B:D404  18         			clc				; 2
 2416                        	
 2417    0B:D405  C6 00      	!:		dec	<map_count		; 6
 2418    0B:D407  D0 CB      			bne	!repeat-		; 4
 2419                        	
 2420    0B:D409  60         	!end:		rts
 2421                        	
 2422                        			; lhs vertical (28+2 rept)
 2423                        			;
 2424                        			; N.B. C is always clear on entry.
 2425                        			;
 2426                        			; 100 cycles per block * 15 -> 1500 cycles
 2427                        	
 2428    0B:D40A  B2 EC      	!repeat:	lda	[_bp]			; 7
 2429    0B:D40C  A8         			tay				; 2
 2430                        	
 2431    0B:D40D  B9 00 50   	b5000_lhs_even:	lda	BLK_5000_TL_L, y	; 5
 2432    0B:D410  9D 02 02   			sta	VDC_DL, x		; 6
 2433    0B:D413  B9 00 54   			lda	BLK_5000_TL_H, y	; 5
 2434               0001     		.if	BLKDEF_CHR_FLAG
 2435    0B:D416  29 F3      			and	#%11110011		; 2
 2436                        		.endif
 2437    0B:D418  1A         			inc	a			; 2
 2438    0B:D419  9D 03 02   			sta	VDC_DH, x		; 6
 2439                        	
 2440    0B:D41C  C6 00      			dec	<map_count		; 6
 2441    0B:D41E  F0 1F      			beq	!end+			; 2
 2442                        	
 2443    0B:D420  B9 00 52   	b5000_lhs_odd:	lda	BLK_5000_BL_L, y	; 5
 2444    0B:D423  9D 02 02   			sta	VDC_DL, x		; 6
 2445    0B:D426  B9 00 56   			lda	BLK_5000_BL_H, y	; 5
 2446               0001     		.if	BLKDEF_CHR_FLAG
 2447    0B:D429  29 F3      			and	#%11110011		; 2
 2448                        		.endif
 2449    0B:D42B  1A         			inc	a			; 2
 2450    0B:D42C  9D 03 02   			sta	VDC_DH, x		; 6
 2451                        	
 2452    0B:D42F  BD 44 23   			lda	vdc_map_line_w, x	; 5
 2453    0B:D432  65 EC      			adc.l	<_bp			; 4
 2454    0B:D434  85 EC      			sta.l	<_bp			; 4
 2455    0B:D436  90 03      			bcc	!+			; 2/4
 2456    0B:D438  E6 ED      			inc.h	<_bp			; 6
 2457    0B:D43A  18         			clc				; 2
 2458                        	
 2459    0B:D43B  C6 00      	!:		dec	<map_count		; 6
 2460    0B:D43D  D0 CB      			bne	!repeat-		; 4
 2461                        	
 2462    0B:D43F  60         	!end:		rts
 2463                        	
 2464                        			; rhs vertical (28+2 rept)
 2465                        			;
 2466                        			; N.B. C is always clear on entry.
 2467                        			;
 2468                        			; 100 cycles per block * 15 -> 1500 cycles
 2469                        	
 2470    0B:D440  B2 EC      	!repeat:	lda	[_bp]			; 7
 2471    0B:D442  A8         			tay				; 2
 2472                        	
 2473    0B:D443  B9 00 51   	b5000_rhs_even:	lda	BLK_5000_TR_L, y	; 5
 2474    0B:D446  9D 02 02   			sta	VDC_DL, x		; 6
 2475    0B:D449  B9 00 55   			lda	BLK_5000_TR_H, y	; 5
 2476               0001     		.if	BLKDEF_CHR_FLAG
 2477    0B:D44C  29 F3      			and	#%11110011		; 2
 2478                        		.endif
 2479    0B:D44E  1A         			inc	a			; 2
 2480    0B:D44F  9D 03 02   			sta	VDC_DH, x		; 6
 2481                        	
 2482    0B:D452  C6 00      			dec	<map_count		; 6
 2483    0B:D454  F0 1F      			beq	!end+			; 2
 2484                        	
 2485    0B:D456  B9 00 53   	b5000_rhs_odd:	lda	BLK_5000_BR_L, y	; 5
 2486    0B:D459  9D 02 02   			sta	VDC_DL, x		; 6
 2487    0B:D45C  B9 00 57   			lda	BLK_5000_BR_H, y	; 5
 2488               0001     		.if	BLKDEF_CHR_FLAG
 2489    0B:D45F  29 F3      			and	#%11110011		; 2
 2490                        		.endif
 2491    0B:D461  1A         			inc	a			; 2
 2492    0B:D462  9D 03 02   			sta	VDC_DH, x		; 6
 2493                        	
 2494    0B:D465  BD 44 23   			lda	vdc_map_line_w, x	; 5
 2495    0B:D468  65 EC      			adc.l	<_bp			; 4
 2496    0B:D46A  85 EC      			sta.l	<_bp			; 4
 2497    0B:D46C  90 03      			bcc	!+			; 2/4
 2498    0B:D46E  E6 ED      			inc.h	<_bp			; 6
 2499    0B:D470  18         			clc				; 2
 2500                        	
 2501    0B:D471  C6 00      	!:		dec	<map_count		; 6
 2502    0B:D473  D0 CB      			bne	!repeat-		; 4
 2503                        	
 2504    0B:D475  60         	!end:		rts
 2505                        	
 2506                        			; lhs vertical (28+2 rept)
 2507                        			;
 2508                        			; N.B. C is always clear on entry.
 2509                        			;
 2510                        			; 100 cycles per block * 15 -> 1500 cycles
 2511                        	
 2512    0B:D476  B2 EC      	!repeat:	lda	[_bp]			; 7
 2513    0B:D478  A8         			tay				; 2
 2514                        	
 2515    0B:D479  B9 00 58   	b5800_lhs_even:	lda	BLK_5800_TL_L, y	; 5
 2516    0B:D47C  9D 02 02   			sta	VDC_DL, x		; 6
 2517    0B:D47F  B9 00 5C   			lda	BLK_5800_TL_H, y	; 5
 2518               0001     		.if	BLKDEF_CHR_FLAG
 2519    0B:D482  29 F3      			and	#%11110011		; 2
 2520                        		.endif
 2521    0B:D484  1A         			inc	a			; 2
 2522    0B:D485  9D 03 02   			sta	VDC_DH, x		; 6
 2523                        	
 2524    0B:D488  C6 00      			dec	<map_count		; 6
 2525    0B:D48A  F0 1F      			beq	!end+			; 2
 2526                        	
 2527    0B:D48C  B9 00 5A   	b5800_lhs_odd:	lda	BLK_5800_BL_L, y	; 5
 2528    0B:D48F  9D 02 02   			sta	VDC_DL, x		; 6
 2529    0B:D492  B9 00 5E   			lda	BLK_5800_BL_H, y	; 5
 2530               0001     		.if	BLKDEF_CHR_FLAG
 2531    0B:D495  29 F3      			and	#%11110011		; 2
 2532                        		.endif
 2533    0B:D497  1A         			inc	a			; 2
 2534    0B:D498  9D 03 02   			sta	VDC_DH, x		; 6
 2535                        	
 2536    0B:D49B  BD 44 23   			lda	vdc_map_line_w, x	; 5
 2537    0B:D49E  65 EC      			adc.l	<_bp			; 4
 2538    0B:D4A0  85 EC      			sta.l	<_bp			; 4
 2539    0B:D4A2  90 03      			bcc	!+			; 2/4
 2540    0B:D4A4  E6 ED      			inc.h	<_bp			; 6
 2541    0B:D4A6  18         			clc				; 2
 2542                        	
 2543    0B:D4A7  C6 00      	!:		dec	<map_count		; 6
 2544    0B:D4A9  D0 CB      			bne	!repeat-		; 4
 2545                        	
 2546    0B:D4AB  60         	!end:		rts
 2547                        	
 2548                        			; rhs vertical (28+2 rept)
 2549                        			;
 2550                        			; N.B. C is always clear on entry.
 2551                        			;
 2552                        			; 100 cycles per block * 15 -> 1500 cycles
 2553                        	
 2554    0B:D4AC  B2 EC      	!repeat:	lda	[_bp]			; 7
 2555    0B:D4AE  A8         			tay				; 2
 2556                        	
 2557    0B:D4AF  B9 00 59   	b5800_rhs_even:	lda	BLK_5800_TR_L, y	; 5
 2558    0B:D4B2  9D 02 02   			sta	VDC_DL, x		; 6
 2559    0B:D4B5  B9 00 5D   			lda	BLK_5800_TR_H, y	; 5
 2560               0001     		.if	BLKDEF_CHR_FLAG
 2561    0B:D4B8  29 F3      			and	#%11110011		; 2
 2562                        		.endif
 2563    0B:D4BA  1A         			inc	a			; 2
 2564    0B:D4BB  9D 03 02   			sta	VDC_DH, x		; 6
 2565                        	
 2566    0B:D4BE  C6 00      			dec	<map_count		; 6
 2567    0B:D4C0  F0 1F      			beq	!end+			; 2
 2568                        	
 2569    0B:D4C2  B9 00 5B   	b5800_rhs_odd:	lda	BLK_5800_BR_L, y	; 5
 2570    0B:D4C5  9D 02 02   			sta	VDC_DL, x		; 6
 2571    0B:D4C8  B9 00 5F   			lda	BLK_5800_BR_H, y	; 5
 2572               0001     		.if	BLKDEF_CHR_FLAG
 2573    0B:D4CB  29 F3      			and	#%11110011		; 2
 2574                        		.endif
 2575    0B:D4CD  1A         			inc	a			; 2
 2576    0B:D4CE  9D 03 02   			sta	VDC_DH, x		; 6
 2577                        	
 2578    0B:D4D1  BD 44 23   			lda	vdc_map_line_w, x	; 5
 2579    0B:D4D4  65 EC      			adc.l	<_bp			; 4
 2580    0B:D4D6  85 EC      			sta.l	<_bp			; 4
 2581    0B:D4D8  90 03      			bcc	!+			; 2/4
 2582    0B:D4DA  E6 ED      			inc.h	<_bp			; 6
 2583    0B:D4DC  18         			clc				; 2
 2584                        	
 2585    0B:D4DD  C6 00      	!:		dec	<map_count		; 6
 2586    0B:D4DF  D0 CB      			bne	!repeat-		; 4
 2587                        	
 2588    0B:D4E1  60         	!end:		rts
 2589                        	
 2590                        		.endif	BLKDEF_POINTERS
 2591                        	
 2592                        		.endprocgroup	; blkmap_group
                             #[2]   "..\..\..\include\hucc\hucc-final.asm"
   80                        		.else
   84                        		.endif	HUCC_USES_BLKMAP
   85                        	
   86               0001     		.ifdef	HUCC_USES_CHRMAP		; Set in hucc_chrmap.h
                             #[3]   "..\..\..\include\hucc\chrmap.asm"
   87                        			include	"chrmap.asm"
    1                        	; ***************************************************************************
    2                        	; ***************************************************************************
    3                        	;
    4                        	; chrmap.asm
    5                        	;
    6                        	; A simple map system based on 8x8 characters (aka "tiles") in BAT format.
    7                        	;
    8                        	; Copyright John Brandwood 2025.
    9                        	;
   10                        	; Distributed under the Boost Software License, Version 1.0.
   11                        	; (See accompanying file LICENSE_1_0.txt or copy at
   12                        	;  http://www.boost.org/LICENSE_1_0.txt)
   13                        	;
   14                        	; ***************************************************************************
   15                        	; ***************************************************************************
   16                        	;
   17                        	; The maximum X and Y size for chrmaps is 256 characters (2048 pixels).
   18                        	;
   19                        	; The maximum total size for a chrmap is 16KBytes, which allows for maps up
   20                        	; to 256x32 tiles (2048x256 pixels).
   21                        	;
   22                        	; ***************************************************************************
   23                        	; ***************************************************************************
   24                        	
   25                        	;
   26                        	; Include dependancies ...
   27                        	;
   28                        	
   29                        			include "blkmap.asm"		; This defines the variables.
   30                        	
   31                        	;
   32                        	; Chrmaps in BAT format normally address all of VRAM from $0400..$7FFF, but
   33                        	; they can be limited to use the 32KByte of characters in VRAM $1000..$4FFF
   34                        	; which then frees up 2-bits for flag information for each character in the
   35                        	; BAT entry.
   36                        	;
   37                        	; These 2-bits are perfect for using as collision information in game maps,
   38                        	; allowing storage of states like transparent, solid, up-slope, down-slope.
   39                        	;
   40                        	; Typically this flag information is set by the map conversion tools from a
   41                        	; seperate "collision" map layer.
   42                        	;
   43                        	
   44               0000     		.ifndef	CHRMAP_BAT_FLAG
   46                        		.endif
   47                        	
   48                        	;
   49                        	;
   50                        	;
   51                        	
   52                        	
   53                        	
   54    01:C040             	chrmap_group	.procgroup
   55                        	
   56                        	; ***************************************************************************
   57                        	; ***************************************************************************
   58                        	;
   59                        	; _draw_bat - Draw the entire screen at the current coordinates.
   60                        	; _sgx_draw_bat - Draw the entire screen at the current coordinates.
   61                        	;
   62                        	; void __fastcall draw_bat( void );
   63                        	; void __fastcall sgx_draw_bat( void );
   64                        	;
   65                        	
   66               0001     		.if	SUPPORT_SGX
   67                        	
   68                        	_sgx_draw_bat	.proc
   74                        			.endp
   75                        		.endif
   76                        	
   77    01:C040             	_draw_bat	.proc
   78                        	
   79    01:C040  82         			clx				; Offset to PCE VDC.
   80                        	
   81    01:C041  43 08      			tma3				; Preserve MPR3..MPR5.
   82    01:C043  48         			pha
   83    01:C044  43 10      			tma4
   84    01:C046  48         			pha
   85    01:C047  43 20      			tma5
   86    01:C049  48         			pha
   87                        	
   88    01:C04A  20 ED C0   			jsr	bat_pxl_2_chr		; Set up the draw coordinates.
   89                        	
   90    01:C04D  A5 FC      			lda	<map_chr_x		; Reset previous X position.
   91    01:C04F  9D 79 28   			sta	vdc_old_chr_x, x
   92                        	
   93    01:C052  A5 FE      			lda	<map_chr_y		; Reset previous Y position,
   94    01:C054  1A         			inc	a			; ready to draw rows upwards.
   95    01:C055  9D 7A 28   			sta	vdc_old_chr_y, x
   96                        	
   97    01:C058  BD 42 23   			lda	vdc_map_draw_w, x	; Draw the whole screen.
   98    01:C05B  85 FA      			sta	<map_draw_w
   99    01:C05D  BD 43 23   			lda	vdc_map_draw_h, x
  100    01:C060  85 FB      			sta	<map_draw_h
  101                        	
  102    01:C062  20 D0 C1   			jsr	bat_scroll_y		; Draw N row of CHR to the BAT.
  103                        	
  104    01:C065  68         			pla				; Restore MPR3..MPR5.
  105    01:C066  53 20      			tam5
  106    01:C068  68         			pla
  107    01:C069  53 10      			tam4
  108    01:C06B  68         			pla
  109    01:C06C  53 08      			tam3
  110                        	
  111                        			leave
         01:C06E  4C EF FF   			jmp	leave_proc
  112                        	
  113                        			.endp
  114                        	
  115                        	
  116                        	
  117                        	; ***************************************************************************
  118                        	; ***************************************************************************
  119                        	;
  120                        	; _scroll_bat - Draw a single row of CHR into the BAT to update the edge.
  121                        	; _sgx_scroll_bat - Draw a single row of CHR into the BAT to update the edge.
  122                        	;
  123                        	; void __fastcall scroll_bat( void );
  124                        	; void __fastcall sgx_scroll_bat( void );
  125                        	;
  126                        	
  127               0001     		.if	SUPPORT_SGX
  128                        	
  129                        	_sgx_scroll_bat	.proc
  135                        			.endp
  136                        		.endif
  137                        	
  138    01:C071             	_scroll_bat	.proc
  139                        	
  140    01:C071  82         			clx				; Offset to PCE VDC.
  141                        	
  142    01:C072  43 08      			tma3				; Preserve MPR3..MPR5.
  143    01:C074  48         			pha
  144    01:C075  43 10      			tma4
  145    01:C077  48         			pha
  146    01:C078  43 20      			tma5
  147    01:C07A  48         			pha
  148                        	
  149    01:C07B  20 ED C0   			jsr	bat_pxl_2_chr		; Set up the draw coordinates.
  150                        	
  151    01:C07E  BD 43 23   			lda	vdc_map_draw_h, x	; Draw new LHS or RHS if needed.
  152    01:C081  85 FB      			sta	<map_draw_h
  153                        	;		lda	#1			; bat_scroll_x only ever draws a
  154                        	;		sta	<map_draw_w		; single column.
  155    01:C083  20 11 C1   			jsr	bat_scroll_x
  156                        	
  157    01:C086  BD 79 28   			lda	vdc_old_chr_x, x	; Restore map_chr_x which could
  158    01:C089  85 FC      			sta	<map_chr_x		; be changed by bat_scroll_x.
  159                        	
  160    01:C08B  BD 42 23   			lda	vdc_map_draw_w, x	; Draw new TOP or BTM if needed.
  161    01:C08E  85 FA      			sta	<map_draw_w
  162    01:C090  A9 01      			lda	#1
  163    01:C092  85 FB      			sta	<map_draw_h
  164    01:C094  20 D0 C1   			jsr	bat_scroll_y
  165                        	
  166    01:C097  68         			pla				; Restore MPR3..MPR5.
  167    01:C098  53 20      			tam5
  168    01:C09A  68         			pla
  169    01:C09B  53 10      			tam4
  170    01:C09D  68         			pla
  171    01:C09E  53 08      			tam3
  172                        	
  173                        			leave
         01:C0A0  4C EF FF   			jmp	leave_proc
  174                        	
  175                        			.endp
  176                        	
  177                        	
  178                        	
  179                        	; ***************************************************************************
  180                        	; ***************************************************************************
  181                        	;
  182                        	; _blit_bat - Draw a map rectangle to specific BAT coordinates.
  183                        	; _sgx_blit_bat - Draw a map rectangle to specific BAT coordinates.
  184                        	;
  185                        	; void __fastcall blit_bat( unsigned char tile_x<map_bat_x>, unsigned char tile_y<map_bat_y>, unsigned char tile_w<map_draw_x>, unsigned char tile_h<map_draw_y> );
  186                        	; void __fastcall sgx_blit_bat( unsigned char tile_x<map_bat_x>, unsigned char tile_y<map_bat_y>, unsigned char tile_w<map_draw_x>, unsigned char tile_h<map_draw_y> );
  187                        	;
  188                        	; Normally you'd just use _draw_bat() and _scroll_bat(), but for those folks
  189                        	; who really wish to take manual control, you can use this.
  190                        	;
  191                        	
  192               0001     		.if	SUPPORT_SGX
  193                        	
  194                        	_sgx_blit_bat	.proc
  200                        			.endp
  201                        		.endif
  202                        	
  203    01:C0A3             	_blit_bat	.proc
  204                        	
  205    01:C0A3  82         			clx				; Offset to PCE VDC.
  206                        	
  207    01:C0A4  43 08      			tma3				; Preserve MPR3..MPR5.
  208    01:C0A6  48         			pha
  209    01:C0A7  43 10      			tma4
  210    01:C0A9  48         			pha
  211    01:C0AA  43 20      			tma5
  212    01:C0AC  48         			pha
  213                        	
  214    01:C0AD  BD 4A 23   			lda	vdc_map_option, x	; Preserve current map options.
  215    01:C0B0  48         			pha
  216    01:C0B1  09 C0      			ora	#MAP_UNALIGNED_X | MAP_UNALIGNED_Y
  217    01:C0B3  9D 4A 23   			sta	vdc_map_option, x
  218                        	
  219    01:C0B6  20 ED C0   			jsr	bat_pxl_2_chr		; Set up the draw coordinates.
  220                        	
  221    01:C0B9  A5 FA      			lda	<map_draw_w		; Are we drawing just 1 column?
  222    01:C0BB  C9 01      			cmp	#1
  223    01:C0BD  F0 1E      			beq	.draw_column
  224                        	
  225                        			; Draw N rows.
  226                        	
  227    01:C0BF  A5 FC      	.draw_rows:	lda	<map_chr_x		; Reset previous X position.
  228    01:C0C1  9D 79 28   			sta	vdc_old_chr_x, x
  229                        	
  230    01:C0C4  A5 FE      			lda	<map_chr_y		; Reset previous Y position,
  231    01:C0C6  1A         			inc	a			; ready to draw rows upwards.
  232    01:C0C7  9D 7A 28   			sta	vdc_old_chr_y, x
  233                        	
  234    01:C0CA  20 D0 C1   			jsr	bat_scroll_y		; Draw a row of CHR to the BAT.
  235                        	
  236                        			; Drawing completed.
  237                        	
  238    01:C0CD  68         	.finished:	pla				; Restore previous map options.
  239    01:C0CE  9D 4A 23   			sta	vdc_map_option, x
  240                        	
  241    01:C0D1  68         			pla				; Restore MPR3..MPR5.
  242    01:C0D2  53 20      			tam5
  243    01:C0D4  68         			pla
  244    01:C0D5  53 10      			tam4
  245    01:C0D7  68         			pla
  246    01:C0D8  53 08      			tam3
  247                        	
  248                        	.exit:		leave
         01:C0DA  4C EF FF   			jmp	leave_proc
  249                        	
  250                        			; Draw 1 column.
  251                        	
  252    01:C0DD  A5 FC      	.draw_column:	lda	<map_chr_x		; Reset previous X position.
  253    01:C0DF  1A         			inc	a			; ready to draw 1 column.
  254    01:C0E0  9D 79 28   			sta	vdc_old_chr_x, x
  255                        	
  256    01:C0E3  A5 FE      			lda	<map_chr_y		; Reset previous Y position.
  257    01:C0E5  9D 7A 28   			sta	vdc_old_chr_y, x
  258                        	
  259    01:C0E8  20 11 C1   			jsr	bat_scroll_x		; Draw a single column of CHR.
  260                        	
  261    01:C0EB  80 E0      			bra	.finished
  262                        	
  263                        			.endp
  264                        	
  265                        	
  266                        	
  267                        	; ***************************************************************************
  268                        	; ***************************************************************************
  269                        	;
  270                        	
  271    01:C0ED  BD 46 23   	bat_pxl_2_chr:	lda.l	vdc_map_pxl_x, x	; Get current map X coordinate.
  272    01:C0F0  85 FC      			sta.l	<map_pxl_x
  273    01:C0F2  BD 47 23   			lda.h	vdc_map_pxl_x, x	; Xvert map_pxl_x to map_chr_x.
  274    01:C0F5  4A         			lsr	a
  275    01:C0F6  66 FC      			ror.l	<map_pxl_x
  276    01:C0F8  4A         			lsr	a
  277    01:C0F9  66 FC      			ror.l	<map_pxl_x
  278    01:C0FB  4A         			lsr	a
  279    01:C0FC  66 FC      			ror.l	<map_pxl_x		; Max map width is 256 CHR.
  280                        	
  281    01:C0FE  BD 48 23   			lda.l	vdc_map_pxl_y, x	; Get current map Y coordinate.
  282    01:C101  85 FE      			sta.l	<map_pxl_y
  283    01:C103  BD 49 23   			lda.h	vdc_map_pxl_y, x	; Xvert map_pxl_y to map_chr_y.
  284    01:C106  4A         			lsr	a
  285    01:C107  66 FE      			ror.l	<map_pxl_y
  286    01:C109  4A         			lsr	a
  287    01:C10A  66 FE      			ror.l	<map_pxl_y
  288    01:C10C  4A         			lsr	a
  289    01:C10D  66 FE      			ror.l	<map_pxl_y		; Max map width is 256 CHR.
  290                        	
  291    01:C10F  60         			rts
  292                        	
  293                        	
  294                        	
  295                        	; ***************************************************************************
  296                        	; ***************************************************************************
  297                        	;
  298                        	; bat_scroll_x - Update the BAT when X coordinate changes.
  299                        	;
  300                        	; N.B. This only ever draws a single column!
  301                        	;
  302                        	
  303    01:C110  60         	!no_change:	rts
  304                        	
  305    01:C111  A5 FC      	bat_scroll_x:	lda	<map_chr_x		; Compare old_x with cur_x.
  306    01:C113  DD 79 28   			cmp	vdc_old_chr_x, x
  307    01:C116  F0 F8      			beq	!no_change-		; Do nothing if no change.
  308    01:C118  9D 79 28   			sta	vdc_old_chr_x, x
  309    01:C11B  30 05      			bmi	.moved			; Test the sign of the change.
  310                        	
  311    01:C11D  18         			clc				; Draw RHS if chr_x >= old_x.
  312    01:C11E  7D 42 23   			adc	vdc_map_draw_w, x	; Usually (SCR_WIDTH / 8) + 1.
  313    01:C121  3A         			dec	a
  314                        	
  315    01:C122  48         	.moved:		pha				; Push chr_x in map section.
  316                        	
  317    01:C123  3C 4A 23   			bit	vdc_map_option, x	; Set bit7 to disable aligning
  318    01:C126  30 05      			bmi	!+			; BAT X with the map X.
  319    01:C128  3D 3F 23   			and	vdc_bat_x_mask, x
  320    01:C12B  85 F8      			sta	<map_bat_x		; Save BAT X chr coordinate.
  321                        	
  322    01:C12D  A5 FE      	!:		lda	<map_chr_y		; Y = chr_y in map section.
  323    01:C12F  A8         			tay
  324                        	
  325    01:C130  3C 4A 23   			bit	vdc_map_option, x	; Set bit6 to disable aligning
  326    01:C133  70 05      			bvs	!+			; BAT Y with the map Y.
  327    01:C135  3D 40 23   			and	vdc_bat_y_mask, x
  328    01:C138  85 F9      			sta	<map_bat_y		; Save BAT Y chr coordinate.
  329                        	
  330               0000     		.if	FAST_MULTIPLY
  333                        		.endif
  334                        	
  335    01:C13A  BD 44 23   	!:		lda	vdc_map_line_w, x	; Map width in CHR (0 == 256).
  336    01:C13D  D0 05      			bne	!+
  337                        	
  338    01:C13F  64 EE      			stz.l	<map_line		; Multiply by 256 is easy!
  339    01:C141  98         			tya
  340    01:C142  80 15      			bra	.double
  341                        	
  342               0000     		.if	FAST_MULTIPLY
  354                        		.else
  355    01:C144  84 EF      	!:		sty.h	<map_line		; Takes 144..176 cycles.
  356    01:C146  A0 08      			ldy	#8
  357    01:C148  4A         			lsr	a
  358    01:C149  85 EE      			sta.l	<map_line
  359    01:C14B  62         			cla
  360    01:C14C  90 03      			bcc	.rotate
  361    01:C14E  18         	.add:		clc
  362    01:C14F  65 EF      			adc.h	<map_line
  363    01:C151  6A         	.rotate:	ror	a
  364    01:C152  66 EE      			ror.l	<map_line		; Lo-byte of (CHR Y * width).
  365    01:C154  88         			dey
  366    01:C155  B0 F7      			bcs	.add
  367    01:C157  D0 F8      			bne	.rotate
  368                        		.endif
  369                        	
  370    01:C159  06 EE      	.double:	asl.l	<map_line		; Lo-byte of (CHR Y * width * 2).
  371    01:C15B  2A         			rol	a
  372    01:C15C  A8         			tay				; Hi-byte of (CHR Y * width * 2).
  373                        	
  374    01:C15D  BD 83 28   			lda	vdc_map_bank, x		; Put the MAP into MPR3-MPR5.
  375    01:C160  53 08      			tam3				; Allow for 16KByte chrmap.
  376    01:C162  1A         			inc	a
  377    01:C163  53 10      			tam4
  378    01:C165  1A         			inc	a
  379    01:C166  53 20      			tam5
  380                        	
  381    01:C168  68         			pla				; Pop chr_x in map section.
  382    01:C169  0A         			asl	a			; 2-bytes for a BAT value.
  383    01:C16A  90 02      			bcc	!+
  384    01:C16C  C8         			iny				; Hi-byte of (CHR Y * width * 2).
  385    01:C16D  18         			clc
  386    01:C16E  65 EE      	!:		adc.l	<map_line		; Lo-byte of (CHR Y * width * 2).
  387    01:C170  90 01      			bcc	!+
  388    01:C172  C8         			iny
  389                        	
  390    01:C173  18         	!:		clc				; Calc map data pointer.
  391    01:C174  7D 81 28   			adc.l	vdc_map_addr, x
  392    01:C177  85 EC      			sta.l	<_bp			; Maximum map size is 16KBytes
  393    01:C179  98         			tya				; so we don't need to consider
  394    01:C17A  7D 82 28   			adc.h	vdc_map_addr, x		; bank overflow.
  395    01:C17D  85 ED      			sta.h	<_bp
  396                        	
  397    01:C17F  C2         			cly				; Calculate the map line delta
  398    01:C180  BD 44 23   			lda	vdc_map_line_w, x	; in bytes.
  399    01:C183  D0 01      			bne	!+
  400    01:C185  C8         			iny
  401    01:C186  0A         	!:		asl	a
  402    01:C187  85 EE      			sta.l	<map_line
  403    01:C189  98         			tya
  404    01:C18A  2A         			rol	a
  405    01:C18B  85 EF      			sta.h	<map_line
  406                        	
  407                        			; Draw the first part of the column.
  408                        	
  409    01:C18D  A5 F8      	.draw_col:	lda	<map_bat_x		; Set the BAT VRAM destination
  410    01:C18F  85 F0      			sta.l	<_di			; coordinates.
  411    01:C191  A5 F9      			lda	<map_bat_y
  412    01:C193  85 F1      			sta.h	<_di
  413                        	
  414    01:C195  5D 40 23   			eor	vdc_bat_y_mask, x	; Calc CHR before wrap.
  415    01:C198  1A         			inc	a
  416    01:C199  C5 FB      			cmp	<map_draw_h		; Usually (SCR_HEIGHT / 8) + 1.
  417    01:C19B  90 02      			bcc	!+
  418    01:C19D  A5 FB      			lda	<map_draw_h		; Maximum CHR to draw.
  419    01:C19F  85 00      	!:		sta	<map_count		; Set number of CHR to draw.
  420    01:C1A1  85 01      			sta	<map_drawn		; Preserve number of CHR drawn.
  421                        	
  422    01:C1A3  A9 05      			lda	#VDC_CR			; Set VDC auto-increment from
  423    01:C1A5  95 F7      			sta	<vdc_reg, x		; the BAT width, which is set
  424    01:C1A7  9D 00 02   			sta	VDC_AR, x		; up by set_screen_size().
  425    01:C1AA  B5 F4      			lda	<vdc_crh, x
  426    01:C1AC  9D 03 02   			sta	VDC_DH, x
  427                        	
  428    01:C1AF  20 B1 C2   			jsr	bat_col_strip		; Draw top of vertical strip.
  429                        	
  430                        			; Wrap around and draw the rest of the column (if needed).
  431                        	
  432    01:C1B2  38         			sec				; Are there any more CHR that
  433    01:C1B3  A5 FB      			lda	<map_draw_h		; need to be drawn?
  434    01:C1B5  E5 01      			sbc	<map_drawn
  435    01:C1B7  F0 0B      			beq	.done
  436                        	
  437    01:C1B9  85 00      			sta	<map_count		; Set number of CHR to draw.
  438                        	
  439    01:C1BB  A5 F8      			lda	<map_bat_x		; Set the BAT VRAM destination
  440    01:C1BD  85 F0      			sta.l	<_di			; coordinates.
  441    01:C1BF  64 F1      			stz.h	<_di			; Reset 1st row to draw.
  442                        	
  443    01:C1C1  20 B1 C2   			jsr	bat_col_strip		; Draw btm of vertical strip.
  444                        	
  445    01:C1C4  A9 05      	.done:		lda	#VDC_CR			; Set VDC auto-increment to 1.
  446    01:C1C6  95 F7      			sta	<vdc_reg, x
  447    01:C1C8  9D 00 02   			sta	VDC_AR, x
  448    01:C1CB  9E 03 02   			stz	VDC_DH, x
  449                        	
  450    01:C1CE  60         			rts
  451                        	
  452                        	
  453                        	
  454                        	; ***************************************************************************
  455                        	; ***************************************************************************
  456                        	;
  457                        	; bat_scroll_y - Update the BAT when Y coordinate changes.
  458                        	;
  459                        	; N.B. This draws multiple rows when called from _draw_bat or _blit_bat.
  460                        	;
  461                        	
  462    01:C1CF  60         	!no_change:	rts
  463                        	
  464    01:C1D0  A5 FE      	bat_scroll_y:	lda	<map_chr_y		; Compare old_y with cur_y.
  465    01:C1D2  DD 7A 28   			cmp	vdc_old_chr_y, x
  466    01:C1D5  F0 F8      			beq	!no_change-		; Do nothing if no change.
  467    01:C1D7  9D 7A 28   			sta	vdc_old_chr_y, x
  468    01:C1DA  30 05      			bmi	.moved			; Test the sign of the change.
  469                        	
  470    01:C1DC  18         			clc				; Draw bottom if chr_y >= old_y.
  471    01:C1DD  7D 43 23   			adc	vdc_map_draw_h, x	; Usually (SCR_HEIGHT / 8) + 1.
  472    01:C1E0  3A         			dec	a
  473                        	
  474    01:C1E1  A8         	.moved:		tay				; Y = chr_y in map section.
  475                        	
  476    01:C1E2  3C 4A 23   			bit	vdc_map_option, x	; Set bit6 to disable aligning
  477    01:C1E5  70 05      			bvs	!+			; BAT Y with the map Y.
  478    01:C1E7  3D 40 23   			and	vdc_bat_y_mask, x
  479    01:C1EA  85 F9      			sta	<map_bat_y		; Save BAT Y chr coordinate.
  480                        	
  481    01:C1EC  3C 4A 23   	!:		bit	vdc_map_option, x	; Set bit7 to disable aligning
  482    01:C1EF  30 07      			bmi	!+			; BAT X with the map X.
  483    01:C1F1  A5 FC      			lda	<map_chr_x
  484    01:C1F3  3D 3F 23   			and	vdc_bat_x_mask, x
  485    01:C1F6  85 F8      			sta	<map_bat_x		; Save BAT X chr coordinate.
  486                        	
  487               0000     		.if	FAST_MULTIPLY
  490                        		.endif
  491                        	
  492    01:C1F8  BD 44 23   	!:		lda	vdc_map_line_w, x	; Map width in CHR (0 == 256).
  493    01:C1FB  D0 05      			bne	!+
  494                        	
  495    01:C1FD  64 EE      			stz.l	<map_line		; Multiply by 256 is easy!
  496    01:C1FF  98         			tya
  497    01:C200  80 15      			bra	.double
  498                        	
  499               0000     		.if	FAST_MULTIPLY
  511                        		.else
  512    01:C202  84 EF      	!:		sty.h	<map_line		; Takes 144..176 cycles.
  513    01:C204  A0 08      			ldy	#8
  514    01:C206  4A         			lsr	a
  515    01:C207  85 EE      			sta.l	<map_line
  516    01:C209  62         			cla
  517    01:C20A  90 03      			bcc	.rotate
  518    01:C20C  18         	.add:		clc
  519    01:C20D  65 EF      			adc.h	<map_line
  520    01:C20F  6A         	.rotate:	ror	a
  521    01:C210  66 EE      			ror.l	<map_line		; Lo-byte of (CHR Y * width).
  522    01:C212  88         			dey
  523    01:C213  B0 F7      			bcs	.add
  524    01:C215  D0 F8      			bne	.rotate
  525                        		.endif
  526                        	
  527    01:C217  06 EE      	.double:	asl.l	<map_line		; Lo-byte of (CHR Y * width * 2).
  528    01:C219  2A         			rol	a
  529    01:C21A  85 EF      			sta.h	<map_line		; Hi-byte of (CHR Y * width * 2).
  530    01:C21C  A8         			tay
  531                        	
  532    01:C21D  BD 83 28   			lda	vdc_map_bank, x		; Put the MAP into MPR3-MPR5.
  533    01:C220  53 08      			tam3				; Allow for 16KByte chrmap.
  534    01:C222  1A         			inc	a
  535    01:C223  53 10      			tam4
  536    01:C225  1A         			inc	a
  537    01:C226  53 20      			tam5
  538                        	
  539                        			; Loop to here if drawing multiple rows.
  540                        	
  541    01:C228  A5 FC      	.next_row:	lda	<map_chr_x		; Map CHR X coordinate.
  542    01:C22A  0A         			asl	a			; 2-bytes for a BAT value!
  543    01:C22B  90 02      			bcc	!+
  544    01:C22D  C8         			iny				; Hi-byte of (CHR Y * width * 2).
  545    01:C22E  18         			clc
  546    01:C22F  65 EE      	!:		adc.l	<map_line		; Lo-byte of (CHR Y * width * 2).
  547    01:C231  90 01      			bcc	!+
  548    01:C233  C8         			iny
  549    01:C234  18         	!:		clc				; Calc map data pointer.
  550    01:C235  7D 81 28   			adc.l	vdc_map_addr, x
  551    01:C238  85 EC      			sta.l	<_bp			; Maximum map size is 16KBytes
  552    01:C23A  98         			tya				; so we don't need to consider
  553    01:C23B  7D 82 28   			adc.h	vdc_map_addr, x		; bank overflow.
  554    01:C23E  85 ED      			sta.h	<_bp
  555                        	
  556                        			; Draw the first part of the row.
  557                        	
  558    01:C240  A5 F9      	.draw_row:	lda	<map_bat_y		; Set the BAT VRAM destination
  559    01:C242  85 F1      			sta.h	<_di			; coordinates.
  560    01:C244  A5 F8      			lda	<map_bat_x
  561    01:C246  85 F0      			sta.l	<_di
  562                        	
  563    01:C248  5D 3F 23   			eor	vdc_bat_x_mask, x	; Calc CHR before wrap.
  564    01:C24B  1A         			inc	a
  565    01:C24C  C5 FA      			cmp	<map_draw_w		; Usually (SCR_WIDTH / 8) + 1.
  566    01:C24E  90 02      			bcc	!+
  567    01:C250  A5 FA      			lda	<map_draw_w		; Maximum CHR to draw.
  568    01:C252  85 00      	!:		sta	<map_count		; Set number of CHR to draw.
  569    01:C254  85 01      			sta	<map_drawn		; Preserve number of CHR drawn.
  570                        	
  571    01:C256  20 90 C2   			jsr	bat_row_strip		; Draw lhs of horizontal strip.
  572                        	
  573                        			; Wrap around and draw the rest of the row (if needed).
  574                        	
  575    01:C259  38         			sec				; Are there any more CHR that
  576    01:C25A  A5 FA      			lda	<map_draw_w		; need to be drawn?
  577    01:C25C  E5 01      			sbc	<map_drawn
  578    01:C25E  F0 0B      			beq	.done_row
  579                        	
  580    01:C260  85 00      			sta	<map_count		; Set number of CHR to draw.
  581                        	
  582    01:C262  A5 F9      			lda	<map_bat_y		; Set the BAT VRAM destination
  583    01:C264  85 F1      			sta.h	<_di			; coordinates.
  584    01:C266  64 F0      			stz.l	<_di			; Reset 1st column to draw.
  585                        	
  586    01:C268  20 90 C2   			jsr	bat_row_strip		; Draw rhs of horizontal strip.
  587                        	
  588    01:C26B  C6 FB      	.done_row:	dec	<map_draw_h		; Are all desired rows drawn?
  589    01:C26D  F0 20      			beq	.finished
  590                        	
  591    01:C26F  A5 F9      			lda	<map_bat_y		; Move BAT Y down by 1.
  592    01:C271  1A         			inc	a
  593    01:C272  3D 40 23   			and	vdc_bat_y_mask, x
  594    01:C275  85 F9      			sta	<map_bat_y
  595                        	
  596    01:C277  A4 EF      			ldy.h	<map_line		; Move the map line pointer to
  597    01:C279  C8         			iny				; the next line.
  598    01:C27A  BD 44 23   			lda	vdc_map_line_w, x
  599    01:C27D  F0 0B      			beq	!++			; vdc_map_line_w == 0 == 256.
  600    01:C27F  0A         			asl	a			; 2-bytes for a BAT value!
  601    01:C280  B0 01      			bcs	!+
  602    01:C282  88         			dey				; Fix if vdc_map_line_w <= 127.
  603    01:C283  18         	!:		clc
  604    01:C284  65 EE      			adc.l	<map_line
  605    01:C286  85 EE      			sta.l	<map_line
  606    01:C288  90 01      			bcc	!++
  607    01:C28A  C8         	!:		iny
  608    01:C28B  84 EF      	!:		sty.h	<map_line		; Needed for .next_row!
  609                        	
  610    01:C28D  80 99      			bra	.next_row		; Draw next row.
  611                        	
  612    01:C28F  60         	.finished:	rts
  613                        	
  614                        	
  615                        	
  616                        	; ***************************************************************************
  617                        	; ***************************************************************************
  618                        	;
  619                        	; bat_row_strip - Draw a single row of CHR into the BAT.
  620                        	;
  621                        	
  622    01:C290  20 34 E4   	bat_row_strip:	jsr	set_di_xy_mawr		; Set the BAT VRAM destination.
  623                        	
  624    01:C293  C2         			cly				; 2
  625    01:C294  B1 EC      	.repeat:	lda	[_bp], y		; 7
  626    01:C296  9D 02 02   			sta	VDC_DL, x		; 6
  627    01:C299  C8         			iny				; 2
  628    01:C29A  B1 EC      			lda	[_bp], y		; 7
  629               0000     		.if	CHRMAP_BAT_FLAG
  634                        		.endif
  635    01:C29C  9D 03 02   			sta	VDC_DH, x		; 6
  636    01:C29F  C8         			iny				; 2
  637                        	
  638    01:C2A0  C6 00      	!:		dec	<map_count		; 6
  639    01:C2A2  D0 F0      			bne	.repeat			; 4
  640                        	
  641    01:C2A4  98         			tya				; 2
  642    01:C2A5  F0 07      			beq	!+			; 2/4
  643    01:C2A7  18         			clc				; 2
  644    01:C2A8  65 EC      			adc.l	<_bp			; 4
  645    01:C2AA  85 EC      			sta.l	<_bp			; 4
  646    01:C2AC  90 02      			bcc	.done			; 2/4
  647    01:C2AE  E6 ED      	!:		inc.h	<_bp			; 6
  648                        	
  649    01:C2B0  60         	.done:		rts
  650                        	
  651                        	
  652                        	
  653                        	; ***************************************************************************
  654                        	; ***************************************************************************
  655                        	;
  656                        	; bat_col_strip - Draw a single column of CHR into the BAT.
  657                        	;
  658                        	
  659    01:C2B1  20 34 E4   	bat_col_strip:	jsr	set_di_xy_mawr		; Set the BAT VRAM destination.
  660                        	
  661    01:C2B4  A0 01      			ldy	#1			; 2
  662    01:C2B6  B2 EC      	.repeat:	lda	[_bp]			; 7
  663    01:C2B8  9D 02 02   			sta	VDC_DL, x		; 6
  664    01:C2BB  B1 EC      			lda	[_bp], y		; 7
  665               0000     		.if	CHRMAP_BAT_FLAG
  670                        		.endif
  671    01:C2BD  9D 03 02   			sta	VDC_DH, x		; 6
  672                        	
  673    01:C2C0  18         			clc				; 2
  674    01:C2C1  A5 EE      			lda.l	<map_line		; 4
  675    01:C2C3  65 EC      			adc.l	<_bp			; 4
  676    01:C2C5  85 EC      			sta.l	<_bp			; 4
  677    01:C2C7  A5 EF      			lda.h	<map_line		; 4
  678    01:C2C9  65 ED      			adc.h	<_bp			; 4
  679    01:C2CB  85 ED      			sta.h	<_bp			; 4
  680                        	
  681    01:C2CD  C6 00      			dec	<map_count		; 6
  682    01:C2CF  D0 E5      			bne	.repeat			; 4
  683                        	
  684    01:C2D1  60         			rts
  685                        	
  686                        		.endprocgroup	; chrmap_group
                             #[2]   "..\..\..\include\hucc\hucc-final.asm"
   88                        		.endif	HUCC_USES_CHRMAP
   89                        	
   90               0001     		.ifdef	HUCC_USES_OLD_LINE		; Set in hucc_old_line.h
                             #[3]   "..\..\..\include\hucc\hucc-old-line.asm"
   91                        			include	"hucc-old-line.asm"
    1                        	; ***************************************************************************
    2                        	; ***************************************************************************
    3                        	;
    4                        	; hucc-old-line.asm
    5                        	;
    6                        	; Based on the original HuC and MagicKit functions by David Michel and the
    7                        	; other original HuC developers.
    8                        	;
    9                        	; Modifications copyright John Brandwood 2024-2025.
   10                        	;
   11                        	; Distributed under the Boost Software License, Version 1.0.
   12                        	; (See accompanying file LICENSE_1_0.txt or copy at
   13                        	;  http://www.boost.org/LICENSE_1_0.txt)
   14                        	;
   15                        	; ***************************************************************************
   16                        	; ***************************************************************************
   17                        	
   18                        	
   19                        	
   20                        	; ***************************************************************************
   21                        	; ***************************************************************************
   22                        	;
   23                        	; void __fastcall gfx_init( unsigned int start_vram_addr<_ax> );
   24                        	;
   25                        	; initialize graphics mode
   26                        	; - points graphics map to tiles at start_vram_addr
   27                        	
   28                        	_gfx_init.1	.proc
   73                        			.endp
   74                        	
   75                        	
   76                        	
   77                        	; ***************************************************************************
   78                        	; ***************************************************************************
   79                        	;
   80                        	; void __fastcall gfx_clear( unsigned int start_vram_addr<_di> );
   81                        	;
   82                        	; Clear the values in the graphics tiles
   83                        	; - places zeroes in graphics tiles at start_vram_addr
   84                        	
   85                        	_gfx_clear.1	.proc
  105                        			.endp
  106                        	
  107                        	
  108                        	
  109                        	; ***************************************************************************
  110                        	; ***************************************************************************
  111                        	;
  112                        	; void __fastcall gfx_line( unsigned int x1<_gfx_x1>, unsigned int y1<_gfx_y1>, unsigned int x2<_gfx_x2>, unsigned int y2<_gfx_y2>, unsigned char color<_gfx_color> );
  113                        	
  114                        	huc_gfx_line	.procgroup
  459                        			.endprocgroup	; huc_gfx_line
                             #[2]   "..\..\..\include\hucc\hucc-final.asm"
   92                        		.endif
   93                        	
   94               0000     		.ifdef	HUCC_USES_ZX0			; Set in hucc_zx0.h
   96                        		.endif
   97                        	
   98                        	
   99                        	
  100                        	; ***************************************************************************
  101                        	; ***************************************************************************
  102                        	;
  103                        	; Check that C "__zp" declarations aren't overwriting System Card variables.
  104                        	;
  105                        	
  106               20A0     			.zp
  107               0000     		.if	(* > zpg_sys_top) || (USING_PSGDRIVER && (* > zpg_psg_top))
  109                        		.endif
  110                        	
  111                        	
  112                        	
  113                        	; ***************************************************************************
  114                        	; ***************************************************************************
  115                        	;
  116                        	; Check that there isn't too much C "const" data in the ".RODATA" section.
  117                        	;
  118                        	
  119               6040     			.rodata
  120               0000     		.if	(bank(*) - _bank_base) >= (CONST_BANK + 2)
  122                        		.endif
  123               E937     			.code
                             #[1]   "main.s"

PROCEDURE LIST (in order of size):

Size: $086A, Addr: $0B:CC78, .procgroup blkmap_group
Size: $0390, Addr: $0B:D4E2,      .proc huc_monofont_x
Size: $0349, Addr: $0B:D872,      .proc _update_PLAYER
Size: $02D5, Addr: $0B:DBBB,      .proc _init_LEVEL
Size: $0292, Addr: $01:C040, .procgroup chrmap_group
Size: $0212, Addr: $06:DDE0,      .proc _joypad_DIR
Size: $0108, Addr: $0B:DE90,      .proc read_joypads
Size: $00DF, Addr: $01:C2D2, .procgroup vdc_set_mode
Size: $009F, Addr: $01:C3B1,      .proc _main
Size: $0086, Addr: $01:C450,      .proc _sgx_scroll_split.5
Size: $0081, Addr: $01:C4D6,      .proc vbl_init_scroll
Size: $0077, Addr: $01:C557,      .proc core_main
Size: $006A, Addr: $01:C5CE, .procgroup load_vram_group
Size: $0069, Addr: $01:C638, .procgroup vdc_tty_out
Size: $0064, Addr: $0B:DF98,      .proc _calculate_COLLISION_DEEP
Size: $0062, Addr: $01:C6A1,      .proc _init_256x224
Size: $0051, Addr: $01:C703,      .proc _check_WALL_R
Size: $0051, Addr: $01:C754,      .proc _check_WALL_L
Size: $0051, Addr: $01:C7A5,      .proc _check_FLOOR_R
Size: $0051, Addr: $01:C7F6,      .proc _check_FLOOR_L
Size: $004B, Addr: $01:C847, .procgroup hucc_memcmp
Size: $004B, Addr: $01:C892, .procgroup old_satb_group
Size: $0043, Addr: $01:C8DD,      .proc _joypad_BUTTONS
Size: $0043, Addr: $01:C920, .procgroup vdc_clear_vram
Size: $0043, Addr: $01:C963,      .proc sgx_detect
Size: $003F, Addr: $01:C9A6, .procgroup load_bat_group
Size: $003E, Addr: $01:C9E5,      .proc _vram2vram.3
Size: $003B, Addr: $01:CA23,      .proc init_random
Size: $002E, Addr: $01:CA5E,      .proc _scroll_BG
Size: $002B, Addr: $01:CA8C,      .proc _load_palette.3
Size: $001C, Addr: $01:CAB7,      .proc clear_vce
Size: $001A, Addr: $01:CAD3,      .proc _init_PLAYER
Size: $0010, Addr: $01:CAED,      .proc _init_VARIABLES
