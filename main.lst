                             #[1]   "main.s"
   27                        	
   28               0010     	CORE_VERSION	=	$10			; Version 1.0
   29                        	
   30                        			; Get the user program's configuration settings, this will
   31                        			; be read from the current directory, if it exists, or the
   32                        			; "../include/" directory if not.
   33                        	
                             #[4]   "..\..\..\include\hucc\core-config.inc"
   34                        			include	"core-config.inc"
    1                        	; ***************************************************************************
    2                        	; ***************************************************************************
    3                        	;
    4                        	; core-config.inc
    5                        	;
    6                        	; Configuration settings for the "CORE(not TM)" PC Engine library code.
    7                        	;
    8                        	; Copyright John Brandwood 2021-2024.
    9                        	;
   10                        	; Distributed under the Boost Software License, Version 1.0.
   11                        	; (See accompanying file LICENSE_1_0.txt or copy at
   12                        	;  http://www.boost.org/LICENSE_1_0.txt)
   13                        	;
   14                        	; ***************************************************************************
   15                        	; ***************************************************************************
   16                        	;
   17                        	; The idea is that you, a PCE developer, copy this file from the ../include/
   18                        	; directory and into your project's directory, and then customize the values
   19                        	; to suit your particular project.
   20                        	;
   21                        	; Because PCEAS searches the current (i.e. project) directory for an include
   22                        	; file first, then it will find your customized copy of the file rather than
   23                        	; the original copy in the ../include/ directory.
   24                        	;
   25                        	; That means that all of the different overlay programs in your project will
   26                        	; share the same overall library configuration for your game.
   27                        	;
   28                        	; ***************************************************************************
   29                        	; ***************************************************************************
   30                        	
   31                        	;
   32                        	; Are we going to take over MPR7?
   33                        	;
   34                        	; While this is the default for the "CORE(not TM)" library, it is definitely
   35                        	; possible to use the library to build CD-ROM code that runs with the System
   36                        	; Card in MPR7, and with the 1st bank remaining in MPR2.
   37                        	;
   38                        	; N.B. The CD-ROM Stage1 loader runs the library with USING_MPR7=0 while it
   39                        	;      installs the kernel into PCE RAM in MPR1.
   40                        	;
   41                        	
   42               0000     		.ifndef	USING_MPR7
   44                        		.endif
   45                        	
   46                        	;
   47                        	; Are we building a CD-ROM overlay that uses an already-built CD-ROM Stage1
   48                        	; loader to install the library's kernel code into PCE RAM in MPR1?
   49                        	;
   50                        	; If this is set, the library's kernel code will be excluded from the build,
   51                        	; which will save about 1KB-3KB of code space in every overlay program!
   52                        	;
   53                        	; N.B. The CD-ROM Stage1 loader sets USING_STAGE1=0 so it builds correctly.
   54                        	;
   55                        	
   56               0000     		.ifndef	USING_STAGE1
   58                        		.endif
   59                        	
   60                        	;
   61                        	; Are we currently building the CD-ROM Stage1 loader?
   62                        	;
   63                        	; If this is set, the library's startup code does not call the __sound_init
   64                        	; macro because the sound driver code is not usually a part of the kernel.
   65                        	;
   66                        	; N.B. The CD-ROM Stage1 loader sets BUILDING_STAGE1=1 so it builds correctly.
   67                        	;
   68                        	
   69               0000     		.ifndef	BUILDING_STAGE1
   71                        		.endif
   72                        	
   73                        	;
   74                        	; Is the last track of the CD a duplicate of the main ISO data track?
   75                        	;
   76                        	; Most CD games put two copies of the same ISO track on the CD, so that data
   77                        	; can be read from the secondary track if the drive has a problem reading it
   78                        	; it from the primary location.
   79                        	;
   80                        	; If set, the secondary track will be enabled when the library first starts.
   81                        	;
   82                        	
   83               0000     		.ifndef	SUPPORT_2ISO
   85                        		.endif
   86                        	
   87                        	;
   88                        	; Maximum number of directory entries to use from the ISO.
   89                        	;
   90                        	; The fewer that we choose, the less RAM memory we need. A setting of 64 is
   91                        	; a good compromise to use until you are putting lots of files on the ISO.
   92                        	;
   93                        	
   94               0000     		.ifndef	MAX_DIRSIZE
   96                        		.endif
   97                        	
   98                        	;
   99                        	; Use the System Card's PSG driver code instead of a modern alternative
  100                        	; sound driver like a DefleMask or Furnace player?
  101                        	;
  102                        	
  103               0000     		.ifndef	USING_PSGDRIVER
  105                        		.endif
  106                        	
  107                        	;
  108                        	; Support development for the Turbo EverDrive v2?
  109                        	;
  110                        	; This only applies to HuCard programs, but when chosen, the "CORE(not TM)"
  111                        	; kernel is moved from bank 0 to bank 2, and a minimal set of startup code
  112                        	; is put in bank 0.
  113                        	;
  114                        	; This is because the TED2 hardware occupies the whole of bank 0 when it is
  115                        	; activated, and so we need to run with a different bank in MPR7.
  116                        	;
  117                        	
  118               0000     		.ifndef	SUPPORT_TED2
  120                        		.endif
  121                        	
  122                        	;
  123                        	; Support development for the SuperGRAFX?
  124                        	;
  125                        	; This enables SuperGRAFX support in certain library functions.
  126                        	;
  127                        	
  128               0000     		.ifndef	SUPPORT_SGX
  130                        		.endif
  131                        	
  132                        	;
  133                        	; Choose SuperGRAFX VPC initialization mode.
  134                        	;
  135                        	; SGX_PARALLAX=0 (useful when VDC #1 is a fullscreen HUD)
  136                        	;
  137                        	;  FRONT
  138                        	;   SP1 = VDC #1 (pce) sprite pixels
  139                        	;   BG1 = VDC #1 (pce) background pixels
  140                        	;   SP2 = VDC #2 (sgx) sprite pixels
  141                        	;   BG2 = VDC #2 (sgx) background pixels
  142                        	;  BACK
  143                        	;
  144                        	; SGX_PARALLAX=1
  145                        	;
  146                        	;  FRONT
  147                        	;   SP1 = VDC #1 (pce) sprite pixels
  148                        	;   SP2 = VDC #2 (sgx) sprite pixels
  149                        	;   BG1 = VDC #1 (pce) background pixels
  150                        	;   BG2 = VDC #2 (sgx) background pixels
  151                        	;  BACK
  152                        	;
  153                        	
  154               0000     		.ifndef	SGX_PARALLAX
  156                        		.endif
  157                        	
  158                        	;
  159                        	; Support development for the ArcadeCard?
  160                        	;
  161                        	; This enables ArcadeCard support in certain library functions.
  162                        	;
  163                        	
  164               0000     		.ifndef	SUPPORT_ACD
  166                        		.endif
  167                        	
  168                        	;
  169                        	; Support development for the IFU's ADPCM hardware?
  170                        	;
  171                        	; Developers would normally just use the System Card functions for ADPCM, but
  172                        	; enabling this adds alternative functions, and allows ADPCM use on a HuCARD.
  173                        	;
  174                        	
  175               0000     		.ifndef	SUPPORT_ADPCM
  177                        		.endif
  178                        	
  179                        	;
  180                        	; Select which version of the joystick library code to include, only one of
  181                        	; these can be set to '1' ...
  182                        	;
  183                        	; SUPPORT_2BUTTON : Only returns buttons I and II.
  184                        	; SUPPORT_6BUTTON : Read buttons III-VI, but ignore a mouse.
  185                        	; SUPPORT_MOUSE	  : Read mouse, but ignore buttons III-VI.
  186                        	;
  187                        	; It doesn't make sense to design a game the relies on both the 6-button and
  188                        	; the mouse, so the joystick library is optimized for one or the other.
  189                        	;
  190                        	; Note that both those devices are always detected and no conflicts occur,
  191                        	; this just controls reading either buttons III-VI or the Mouse Y-movement.
  192                        	;
  193                        	
  194               0000     		.ifndef	SUPPORT_6BUTTON
  200                        		.endif
  201                        	
  202                        	;
  203                        	; How many joypad/mouse devices should be supported?
  204                        	;
  205                        	; This is normally 5, but can be set to 3 (or lower) in order to speed up
  206                        	; the processing and free up CPU time for other code, which is especially
  207                        	; useful for mouse games.
  208                        	;
  209                        	
  210               0000     		.ifndef	MAX_PADS
  212                        		.endif
  213                        	
  214                        	;
  215                        	; Implement a HuC-compatible seperate array for accumulating joypad presses?
  216                        	;
  217                        	; This is only really needed if your game is not expected to run at 60Hz and
  218                        	; so you will sometimes miss joypad presses.
  219                        	;
  220                        	; Alternatively you can set ACCUMULATE_JOY so that joypad presses are always
  221                        	; accumulated in the normal joytrg array, which is how asm programmers would
  222                        	; normally deal with this situation.
  223                        	;
  224                        	
  225               0000     		.ifndef HUC_JOY_EVENTS
  227                        		.endif
  228                        	
  229                        	;
  230                        	; Should "joytrg" accumulate presses, and so need to be explicitely cleared
  231                        	; after reading, or should it just be the result of the last read?
  232                        	;
  233                        	; This option has no effect if HUC_JOY_EVENTS is non-zero since that option
  234                        	; takes precedence over this one!
  235                        	;
  236                        	
  237               0000     		.ifndef ACCUMULATE_JOY
  239                        		.endif
  240                        	
  241                        	;
  242                        	; The DATA_BANK location needs to be set as early as possible so that library
  243                        	; code is able to put data in there before the total overall size of the code
  244                        	; is known.
  245                        	;
  246                        	; By default, DATA_BANK is the next bank after the CORE_BANK.
  247                        	;
  248                        	; RESERVE_BANKS allows developers to reserve some banks between the CORE_BANK
  249                        	; and the DATA_BANK that they can use however they wish.
  250                        	;
  251                        	; One use for RESERVE_BANKS is to create empty space that PCEAS can use when
  252                        	; it relocates procedures. This provides a way for a developer to group code
  253                        	; together at the start of memory, and leave the maximum number of banks for
  254                        	; loading dynamic data from CD-ROM.
  255                        	;
  256                        	; The KickC environment sets RESERVE_BANKS=1 (or higher) so that there is a
  257                        	; a bank for the permanent C code and static constants.
  258                        	;
  259                        	
  260               0000     		.ifndef	RESERVE_BANKS
  266                        		.endif	RESERVE_BANKS
                             #[3]   "..\..\..\include\hucc\core.inc"
   35                        	
   36                        	;
   37                        	; This is a simple macro to call System Card functions when using MPR7 for
   38                        	; running the "CORE(not TM)" PC Engine library code.
   39                        	;
   40                        	
   41                        	system		.macro
   42                        			ldy     #<\1
   43                        			jsr	call_bios
   44                        			.endm
   45                        	
   46                        	;
   47                        	; This replaces the System Card's ex_setvec, because "call_bios" uses the
   48                        	; Y register.
   49                        	;
   50                        	
   51                        	setvec		.macro
   52                        			php
   53                        			sei
   54                        			lda.l	#\2
   55                        			sta.l	\1
   56                        			lda.h	#\2
   57                        			sta.h	\1
   58                        			plp
   59                        			.endm
   60                        	
   61                        	;
   62                        	; Repurpose this System Card variable, since nmi_hook is never used.
   63                        	;
   64                        	; We'll use it as a vector to a user-supplied sound driver instead.
   65                        	;
   66                        	
   67               2206     	sound_hook	=	nmi_hook		; Sound Driver to run in VBL.
   68                        	
   69                        	;
   70                        	; CORE Zero-Page variables, relative to the System Card's ZP variables.
   71                        	;
   72                        	
   73               0000     		.if	USING_PSGDRIVER
   75                        		.else
   76               20EC     	core_zpend	=	$F8:20EC
   77                        		.endif	USING_PSGDRIVER
   78                        	
   79               0001     		.if	SUPPORT_SGX
   80                        	
   81                        			; Put some "CORE(not TM)" variables at the start of Zero Page.
   82                        			;
   83                        			; These are at the *start* of ZP so that the SuperGrafx shadow
   84                        			; "sgx_" registers are at a specific offset from their System
   85                        			; Card "vdc_" counterparts, and they MUST NOT be moved!
   86                        			;
   87                        			; This allows us to put SGX_VDC_OFFSET or PCE_VDC_OFFSET into
   88                        			; the X register, and then index into either set of hardware
   89                        			; registers and the "sgx_reg" or "vdc_reg" shadow-variables.
   90                        	
   91               0000     	PCE_VDC_OFFSET	=	$00		; Offset to PCE VDC chip & shadow vars.
   92               0010     	SGX_VDC_OFFSET	=	$10		; Offset to SGX VDC chip & shadow vars.
   93                        	
   94               2000     			.zp
   95               2000     			.org	$2000
   96    F8:2000             	__temp		ds	2		; $F8:2000 Use within any ASM routine.
   97    F8:2002             	_bp_bank	ds	1		; $F8:2002 Use within any ASM/HuCC routine.
   98    F8:2003             	sgx_crl		ds	1		; $F8:2003 SGX shadow (vdc_crl = $20F3).
   99    F8:2004             	sgx_crh		ds	1		; $F8:2004 SGX shadow (vdc_crh = $20F4).
  100    F8:2005             	core_1stbank	ds	1		; $F8:2005 1st bank of library code.
  101    F8:2006             	sgx_sr		ds	1		; $F8:2006 SGX shadow (vdc_sr  = $20F6).
  102    F8:2007             	sgx_reg		ds	1		; $F8:2007 SGX shadow (vdc_reg = $20F7).
  103                        	
  104               2008     	core_zp1st	=	*		; $F8:2008 1st free user address.
  105                        	
  106                        		.else	SUPPORT_SGX
  116                        		.endif	SUPPORT_SGX
  117                        	
  118                        	;
  119                        	; The kernel code in RAM follows the System Card's RAM variables.
  120                        	;
  121                        	
  122               0000     		.if	USING_PSGDRIVER
  124                        		.else
  125               22D0     	core_ram1st     =	$F8:22D0
  126                        		.endif	USING_PSGDRIVER
  127                        	
  128                        	;
  129                        	; Include the "CORE(not TM)" startup code to begin the HuCARD / Overlay.
  130                        	;
  131                        	
                             #[4]   "..\..\..\include\hucc\core-startup.asm"
  132                        			include	"core-startup.asm"
    1                        	; ***************************************************************************
    2                        	; ***************************************************************************
    3                        	;
    4                        	; core-startup.asm
    5                        	;
    6                        	; The "CORE(not TM)" PC Engine library startup code that runs at boot/reset.
    7                        	;
    8                        	; Copyright John Brandwood 2021-2024.
    9                        	;
   10                        	; Distributed under the Boost Software License, Version 1.0.
   11                        	; (See accompanying file LICENSE_1_0.txt or copy at
   12                        	;  http://www.boost.org/LICENSE_1_0.txt)
   13                        	;
   14                        	; ***************************************************************************
   15                        	; ***************************************************************************
   16                        	;
   17                        	; This is the initialization code in the 1st bank, and it is responsible for
   18                        	; setting up a consistant runtime environment for the developer's program,
   19                        	; so that the developer can concentrate on writing the program itself.
   20                        	;
   21                        	; The idea is that when a program is loaded, the first 40KB of it is mapped
   22                        	; as $4000..$DFFF, and initialization starts at $4000, with the developer's
   23                        	; program getting control after initialization, with a jump to "core_main".
   24                        	;
   25                        	; The initializtion sets up a small kernel of code that provides interrupt
   26                        	; handling that mimics a subset of the System Card's behavior, designed to
   27                        	; act in the same way on HuCARD and CD-ROM, with either the System Card in
   28                        	; MPR7, or with an overlay in MPR7.
   29                        	;
   30                        	; The kernel handles reading the joypad/mouse, and it offers handler hooks
   31                        	; for running the developer's interrupt code.  On CD-ROM systems, it also
   32                        	; handles the loading and running of subsequent overlay programs.
   33                        	;
   34                        	; On HuCARD, the kernel itself runs in MPR7; while on CD-ROM systems it is
   35                        	; run from RAM in MPR1, so that overlay programs are independant from each
   36                        	; other, and can be written in different programming languages.
   37                        	;
   38                        	;
   39                        	; 1) If we're running on a HuCARD, the initialization is simple!
   40                        	;
   41                        	;    The PC Engine's memory map is set to ...
   42                        	;
   43                        	;      MPR0 = bank $FF : PCE hardware
   44                        	;      MPR1 = bank $F8 : PCE RAM with Stack & ZP
   45                        	;      MPR2 = bank $00 : HuCARD ROM
   46                        	;      MPR3 = bank $01 : HuCARD ROM
   47                        	;      MPR4 = bank $02 : HuCARD ROM
   48                        	;      MPR5 = bank $03 : HuCARD ROM
   49                        	;      MPR6 = bank $04 : HuCARD ROM
   50                        	;      MPR7 = bank $00 : HuCARD ROM
   51                        	;
   52                        	;
   53                        	; 2) If we're running on a HuCARD that supports the Turbo Everdrive, then the
   54                        	;    first 2 banks are reserved for mapping the TED2 hardware and a RAM bank.
   55                        	;
   56                        	;    The PC Engine's memory map is set to ...
   57                        	;
   58                        	;      MPR0 = bank $FF : PCE hardware
   59                        	;      MPR1 = bank $F8 : PCE RAM with Stack & ZP
   60                        	;      MPR2 = bank $02 : HuCARD ROM
   61                        	;      MPR3 = bank $03 : HuCARD ROM
   62                        	;      MPR4 = bank $04 : HuCARD ROM
   63                        	;      MPR5 = bank $05 : HuCARD ROM
   64                        	;      MPR6 = bank $06 : HuCARD ROM
   65                        	;      MPR7 = bank $02 : HuCARD ROM
   66                        	;
   67                        	;
   68                        	; 3) If we're running on an old CD System, the overlay is loaded from the ISO
   69                        	;    into banks $80-$87 (64KB max).
   70                        	;
   71                        	;    The PC Engine's memory map is set to ...
   72                        	;
   73                        	;      MPR0 = bank $FF : PCE hardware
   74                        	;      MPR1 = bank $F8 : PCE RAM with Stack & ZP
   75                        	;      MPR2 = bank $80 : CD RAM
   76                        	;      MPR3 = bank $81 : CD RAM
   77                        	;      MPR4 = bank $82 : CD RAM
   78                        	;      MPR5 = bank $83 : CD RAM
   79                        	;      MPR6 = bank $84 : CD RAM
   80                        	;      MPR7 = bank $80 : CD RAM or System Card's bank $00
   81                        	;
   82                        	;
   83                        	; 4) If we're running on a SuperCD System, the overlay is loaded from the ISO
   84                        	;    into banks $68-$87 (256KB max).
   85                        	;
   86                        	;    The PC Engine's memory map is set to ...
   87                        	;
   88                        	;      MPR0 = bank $FF : PCE hardware
   89                        	;      MPR1 = bank $F8 : PCE RAM with Stack & ZP
   90                        	;      MPR2 = bank $68 : SCD RAM
   91                        	;      MPR3 = bank $69 : SCD RAM
   92                        	;      MPR4 = bank $6A : SCD RAM
   93                        	;      MPR5 = bank $6B : SCD RAM
   94                        	;      MPR6 = bank $6C : SCD RAM
   95                        	;      MPR7 = bank $68 : SCD RAM or System Card's bank $00
   96                        	;
   97                        	; ***************************************************************************
   98                        	; ***************************************************************************
   99                        	
  100                        	
  101                        	
  102               E000     			.code
  103               0000     			.bank	0
  104                        	
  105               0000     		.if	SUPPORT_TED2			; Do we want to use a TED2?
  177                        		.endif	SUPPORT_TED2
  178                        	
  179                        	
  180                        	
  181               0001     		.if	USING_MPR7
  182                        	
  183                        	; ***************************************************************************
  184                        	; ***************************************************************************
  185                        	;
  186                        	; RESET VECTORS (when running in MPR7, either as a HuCARD, or a CD overlay)
  187                        	;
  188                        	
  189                        			; Hardware reset and interrupt vectors.
  190                        	
  191               FFF4     			.org	$FFF4
  192                        	
  193    00:FFF4  10         	core_version:	db	CORE_VERSION		; CORE(not TM) Version.
  194    00:FFF5  80         			db	$80			; System Card compatibility.
  195                        	
  196    00:FFF6  5D E0      			dw	core_irq2		; IRQ2	(from CD/ADPCM)
  197    00:FFF8  64 E0      			dw	core_irq1		; IRQ1	(from VDC)
  198    00:FFFA  58 E1      			dw	core_timer		; TIMER (from CPU)
  199    00:FFFC  5E E1      			dw	core_rti		; NMI	(unused)
  200               0000     		.if	CDROM
  202                        		.else
  203    00:FFFE  21 E0      			dw	core_hw_reset		; RESET (HuCARD)
  204                        		.endif	CDROM
  205                        	
  206               0001     		.if	USING_NEWPROC			; If the ".proc" trampolines
  207               FFF3     	__trampolineptr =	$FFF3			; are in MPR7, tell PCEAS to
  208                        		.endif					; put them below the vectors.
  209                        	
  210                        		.else	USING_MPR7
  222                        		.endif	USING_MPR7
  223                        	
  224                        	
  225                        	
  226                        	; ***************************************************************************
  227                        	; ***************************************************************************
  228                        	;
  229                        	; !!! THE HuCARD/OVERLAY PROGRAM'S FIRST BANK STARTS HERE !!!
  230                        	;
  231                        	
  232                        			; Switch to MPR2 for the "CORE(not TM)" library init.
  233                        			;
  234                        			; This is also executed by a HuCARD once it has run
  235                        			; its initial hardware-reset code.
  236                        			;
  237                        			; When run, MPR2-MPR6 are always mapped to the 1st 5 banks of
  238                        			; the overlay program, and MPR7 contains the System Card.
  239                        	
  240               4000     			.org	$4000
  241                        	
  242               0000     	CORE_BANK	=	bank(*) - _bank_base	; It isn't always zero! ;-)
  243                        	
  244               0000     			.bank	CORE_BANK, "CORE_BANK"	; Give it a label.
  245                        	
  246               0001     		.if	USING_MPR7
  247               0007     	CORE_PAGE	=	7			; User code runs in MPR7.
  248                        		.else
  250                        		.endif	USING_MPR7
  251                        	
  252    00:4000  4C 06 40   	core_boot:	jmp	* + 6			; Allow someone to patch this.
  253                        	
  254                        			; Add an ident string so isoLINK can autodetect configuration.
  255                        			;
  256                        			; This allows isoLINK to decide whether to use the IPL-SCD boot
  257                        			; sector hack, and whether to include a SuperGRAFX signature in
  258                        			; the boot sector, without the user having to manually use some
  259                        			; command line parameters, although they are free to do that if
  260                        			; they wish.
  261                        	
  262               0001     		.if	SUPPORT_SGX
  263               0000     		.if	BUILDING_STAGE1
  265                        		.else
  266    00:4003  53 47 58   			db	"SGX"			; SGX SuperCD or SGX HuCARD.
  267                        		.endif	BUILDING_STAGE1
  268                        		.else
  282                        		.endif	SUPPORT_SGX
  283                        	
  284               0000     		.if	CDROM
  331                        		.else	CDROM
  332                        	
  333                        			; Set up HuCARD RAM in a compatible way to the System Card.
  334                        			;
  335                        			; Note that the entire RAM is cleared by "core_hw_reset".
  336                        	
  337    00:4006  A9 1F      			lda	#%11111			; Enable joypad soft-reset.
  338    00:4008  8D 27 22   			sta	joyena
  339                        	
  340                        		.endif	CDROM
  341                        	
  342                        			; Now that RAM is initialized ...
  343                        	
  344    00:400B  43 04      			tma2				; Remember overlay's 1st bank
  345    00:400D  85 05      			sta	<core_1stbank		; $00, $02, $68 or $80!
  346               0001     		.if	USING_MPR7
  347    00:400F  53 80      			tam7				; "CORE(not TM)" takes MPR7!
  348                        		.endif
  349                        	
  350    00:4011  A2 FF      			ldx	#$FF			; Initialize stack pointer.
  351    00:4013  9A         			txs
  352                        	
  353    00:4014  20 5F E1   			jsr	core_clr_hooks		; Reset default hooks.
  354                        	
  355                        	;		stz	TIMER_CR		; Stop HuC6280 timer.
  356                        	;		stz	IRQ_ACK			; Clr HuC6280 timer interrupt.
  357                        	;		stz	IRQ_MSK			; Clr HuC6280 interrupt mask.
  358                        	
  359    00:4017  AD 00 02   			lda	VDC_SR			; Purge any overdue VBL.
  360    00:401A  9C 41 22   			stz	irq_cnt			; Make it easy to check.
  361    00:401D  58         			cli				; Restore interrupts.
  362                        	
  363    00:401E  4C E5 FF   			jmp	core_main		; Start the game's code.
  364                        	
  365                        	
  366                        	
  367               0001     		.if	!CDROM
  368                        	
  369                        	; ***************************************************************************
  370                        	; ***************************************************************************
  371                        	;
  372                        	; HuCARD Kernel Code
  373                        	;
  374                        	; core_ram1st - Start of code to relocate to MPR1.
  375                        	; core_ramend - End of code to relocate to MPR1.
  376                        	;
  377                        	
  378                        			; In a HuCARD, BSS variables start as low as possible.
  379                        	
  380               2200     			.bss
  381               22D0     			.org	core_ram1st
  382               22D0     	core_ramend	=	*
  383               4021     			.code
  384                        	
  385                        			; Normal HuCARD hardware-reset code, executed in MPR7.
  386                        			;
  387                        			; This does the basic PCE startup that every HuCARD (including
  388                        			; a System Card) needs to do, and then it remaps memory to be
  389                        			; compatible with the "CORE(not TM)" CD overlay program start.
  390                        	
  391               E021     			.page	7			; This will run in MPR7.
  392                        	
  393    00:E021  78         	core_hw_reset:	sei				; Disable interrupts.
  394    00:E022  D4         			csh				; Set high-speed mode.
  395    00:E023  D8         			cld
  396                        	
  397    00:E024  A2 FF      			ldx	#$FF			; Initialize stack pointer.
  398    00:E026  9A         			txs
  399    00:E027  8A         			txa				; MPR0 = $FF : PCE hardware
  400    00:E028  53 01      			tam0				; MPR1 = $F8 : PCE RAM
  401    00:E02A  A9 F8      			lda	#$F8
  402    00:E02C  53 02      			tam1
  403                        	
  404    00:E02E  9C 01 0C   			stz	TIMER_CR		; HW reset already does these,
  405    00:E031  9C 03 14   			stz	IRQ_ACK			; but this may be a reset from
  406    00:E034  9C 02 14   			stz	IRQ_MSK			; software (i.e. joypad).
  407                        	
  408    00:E037  F3 53 E0 00			tai	const_0000, $2000, 8192 ; Clear RAM.
         00:E03B  20 00 20    
  409                        	
  410    00:E03E  43 80      			tma7				; Not always bank 0!
  411                        	
  412    00:E040  53 04      			tam2				; Set CD-ROM overlay memory map,
  413    00:E042  1A         			inc	a			; 1st 5 banks in MPR2-MPR6.
  414    00:E043  53 08      			tam3
  415    00:E045  1A         			inc	a
  416    00:E046  53 10      			tam4
  417    00:E048  1A         			inc	a
  418    00:E049  53 20      			tam5
  419    00:E04B  1A         			inc	a
  420    00:E04C  53 40      			tam6
  421                        	
  422    00:E04E  4C 00 40   			jmp	core_boot		; Continue execution in MPR2.
  423                        	
  424                        			; In a HuCARD, the kernel code is permanently in MPR7.
  425                        	
                             #[5]   "..\..\..\include\hucc\core-kernel.asm"
  426                        			include "core-kernel.asm"
    1                        	; ***************************************************************************
    2                        	; ***************************************************************************
    3                        	;
    4                        	; core-kernel.asm
    5                        	;
    6                        	; The "CORE(not TM)" PC Engine library kernel code that runs after startup.
    7                        	;
    8                        	; Copyright John Brandwood 2021-2024.
    9                        	;
   10                        	; Distributed under the Boost Software License, Version 1.0.
   11                        	; (See accompanying file LICENSE_1_0.txt or copy at
   12                        	;  http://www.boost.org/LICENSE_1_0.txt)
   13                        	;
   14                        	; ***************************************************************************
   15                        	; ***************************************************************************
   16                        	;
   17                        	; This code is permanently located in either MPR7 (HuCARD), or MPR1 (CD-ROM),
   18                        	; and it provides a consistant method of interrupt-handling on both systems
   19                        	; that is designed to be compatible with the System Card.
   20                        	;
   21                        	; The library uses the "irq1_hook" for its own VDC interrupt handler, and PCE
   22                        	; developers are expected to use "vsync_hook" and "hsync_hook" for their VDC
   23                        	; interrupt functions.  Plenty of memory is available in the 1st bank for the
   24                        	; developer to put those functions.
   25                        	;
   26                        	; The reason for using "irq1_hook", is so that the library can work properly
   27                        	; if either the current overlay program, or the System Card, are mapped into
   28                        	; MPR7 whenever an interrupt occurs.
   29                        	;
   30                        	; The VDC interupt handler itself is changed from the System Card's handler,
   31                        	; and it is designed to provide faster response to vsync_hook, and to enable
   32                        	; interrupts during the slow(ish) joypad and sound driver code, so that both
   33                        	; raster and timer interrupts are not delayed.
   34                        	;
   35                        	; Developers are free to enable interrupts during their own vsync_hook code,
   36                        	; if they wish to do so.
   37                        	;
   38                        	; On CD-ROM systems, this library kernel also provides a function to load and
   39                        	; run a new overlay program, without relying upon any of the code/data within
   40                        	; the current overlay program's memory (unlike HuC v3).
   41                        	;
   42                        	; ***************************************************************************
   43                        	; ***************************************************************************
   44                        	
   45                        	
   46                        	
   47                        	; ***************************************************************************
   48                        	; ***************************************************************************
   49                        	;
   50                        	; core_kernel - Start of kernel code.
   51                        	;
   52                        	
   53               E051     	core_kernel	=	*
   54                        	
   55                        	
   56                        	
   57                        	; ***************************************************************************
   58                        	; ***************************************************************************
   59                        	;
   60                        	; Useful constants, needed by joypad library code, and used by many others.
   61                        	;
   62                        	; The kernel starts with a non-zero byte so that core-startup.asm can check
   63                        	; whether it has already been loaded into RAM.
   64                        	;
   65                        	
   66    00:E051  FF FF      	const_FFFF:	dw	$FFFF			; Useful constant for TAI.
   67    00:E053  00 00      	const_0000:	dw	$0000			; Useful constant for TAI.
   68                        	
   69    00:E055  01 02 04 08	bit_mask:	db	$01,$02,$04,$08,$10,$20,$40,$80
         00:E059  10 20 40 80 
   70                        	
   71                        	
   72                        	
   73                        	; ***************************************************************************
   74                        	; ***************************************************************************
   75                        	;
   76                        	; core_irq2  - Minimal interrupt handler compatible with System Card.
   77                        	; core_irq1  - Minimal interrupt handler compatible with System Card.
   78                        	; core_timer - Minimal interrupt handler compatible with System Card.
   79                        	; core_rti   - Minimal interrupt handler compatible with System Card.
   80                        	;
   81                        	; Note that it takes 8 cycles to respond to an IRQ.
   82                        	;
   83                        	; These routines are copied to a location in RAM that does not vary when
   84                        	; a different overlay program is loaded.
   85                        	;
   86                        	; All overlay programs are set up to vector interrupts to these routines,
   87                        	; which is designed to avoid interrupt-related crashes when loading a new
   88                        	; overlay on top of an old overlay in memory.
   89                        	;
   90                        	; All of the game's actual interrupt handling itself is done in the "hook"
   91                        	; functions so that everything works the same if the System Card is banked
   92                        	; into MPR7 when an interrupt occurs.
   93                        	;
   94                        	; ***************************************************************************
   95                        	; ***************************************************************************
   96                        	;
   97                        	; Bit settings for irq_vec  ...
   98                        	;
   99                        	;   7 : 1 to skip BIOS hsync processsing
  100                        	;   6 : 1 to call [hsync_hook]
  101                        	;   5 : 1 to skip BIOS vsync processsing
  102                        	;   4 : 1 to call [vsync_hook]
  103                        	;
  104                        	;   3 : 1 to jump [nmi_hook]
  105                        	;   2 : 1 to jump [timer_hook]
  106                        	;   1 : 1 to jump [irq1_hook]
  107                        	;   0 : 1 to jump [irq2_hook]
  108                        	;
  109                        	; ***************************************************************************
  110                        	; ***************************************************************************
  111                        	
  112    00:E05D  8F F5 01   	core_irq2:	bbs0	<irq_vec, .hook		; 8 cycles if using hook.
  113                        	
  114               0000     		.if	CDROM
  138                        		.else
  139                        			; Does this HuCARD support the IFU's ADPCM hardware?
  140                        	
  141               0000     		.if	SUPPORT_ADPCM
  153                        		.endif	SUPPORT_ADPCM
  154                        	
  155    00:E060  40         			rti				; No IRQ2 hardware on HuCARD.
  156                        	
  157    00:E061  6C 00 22   	.hook:		jmp	[irq2_hook]		; 7 cycles.
  158                        		.endif	CDROM
  159                        	
  160                        	
  161                        	
  162                        	; ***************************************************************************
  163                        	; ***************************************************************************
  164                        	;
  165                        	; core_irq1 - Minimal interrupt handler compatible with System Card.
  166                        	;
  167                        	; irq1_handler - Basic "CORE(not TM)" IRQ1 handler to use as the "irq1_hook".
  168                        	;
  169                        	; Doing the IRQ1 handler processing in this hook means that things operate
  170                        	; the same whether the System Card or an Overlay is paged into MPR7.
  171                        	
  172               0000     		.ifndef	HUCC
  181                        		.else
  182                        			; Faster IRQ servicing for HuCC and code that would like to
  183                        			; avoid the 8 cycles used by the "bbs1" instruction that is
  184                        			; taken when the System Card is mapped into MPR7.
  185                        	
  186    00:E064             	core_irq1:	;;;				; 8 (cycles for the INT)
  187               0001     		.if	CDROM || !defined(NO_CORE_IRQ1_HOOK)
  188    00:E064  6C 02 22   			jmp	[irq1_hook]		; 7 cycles.
  189                        	
  190                        		.endif
  191                        		.endif
  192                        	
  193    00:E067  48         	irq1_handler:	pha				; 3 Save all registers.
  194    00:E068  DA         			phx				; 3
  195    00:E069  5A         			phy				; 3
  196                        	
  197               0000     		.ifndef	USING_RCR_MACROS		;   This slows things down
  206                        		.endif	USING_RCR_MACROS
  207                        	
  208    00:E06A  AD 00 02   			lda	VDC_SR			; 6 Acknowledge the VDC's IRQ.
  209    00:E06D  85 F6      			sta	<vdc_sr			; 4 Remember what caused it.
  210                        	
  211               0001     		.if	SUPPORT_SGX
  212    00:E06F  AE 10 02   			ldx	SGX_SR			; 6 Read SGX_SR after VDC_SR in
  213    00:E072  86 06      			stx	<sgx_sr			; 4 case this is not an SGX!
  214                        		.endif
  215                        	
  216                        			; Handle the VDC's RCR interrupt.
  217                        	
  218    00:E074  29 04      	!:		and	#$04			; 2 Is this an HSYNC interrupt?
  219    00:E076  F0 44      			beq	!+			; 2
  220                        	
  221               0001     		.ifdef	USING_RCR_MACROS
  222                        			VDC_RCR_MACRO
                             	
         00:E078  03 06      			st0	#VDC_RCR		; 5
                             	
         00:E07A  AE 57 25   			ldx	vdc_next_region		; 5 X and Y can be greater than
         00:E07D  BC 58 25   			ldy	vdc_regionA_nxt, x	; 5 HUCC_PCE_SPLITS if regionB!
         00:E080  18         			clc				; 2
         00:E081  D0 05      			bne	!set_next_rcr+		; 4 Stop RCR if next line is 0.
                             	
         00:E083  2D 53 E0   			and	const_0000		; 5 A=$00 with the same #cycles
         00:E086  80 05      			bra	!clr_next_rcr+		; 4 as if the branch were taken.
                             	
         00:E088  B9 07 25   	!set_next_rcr:	lda	vdc_regionA_rcr, y	; 5 Set next RCR 1 line before
         00:E08B  69 3F      			adc	#64-1			; 2 the region begins, or 0 to
         00:E08D  8D 02 02   	!clr_next_rcr:	sta	VDC_DL			; 6 disable.
         00:E090  62         			cla				; 2
         00:E091  2A         			rol	a			; 2
         00:E092  8D 03 02   			sta	VDC_DH			; 6
                             	
         00:E095  03 08      			st0	#VDC_BYR		; 5 Do BYR first to mitigate the
         00:E097  BD 37 25   			lda	vdc_regionA_yl, x	; 5 glitch if the IRQ is delayed.
         00:E09A  8D 02 02   			sta	VDC_DL			; 6 = 105 cycles from RCR on SGX
         00:E09D  BD 47 25   			lda	vdc_regionA_yh, x	; 5
         00:E0A0  8D 03 02   			sta	VDC_DH			; 6
                             	
         00:E0A3  03 05      			st0	#VDC_CR			; 5
         00:E0A5  BD F7 24   			lda	vdc_regionA_crl, x	; 5
                             	;		asl	a
         00:E0A8  8D 02 02   			sta	VDC_DL			; 6
                             	
         00:E0AB  03 07      			st0	#VDC_BXR		; 2
         00:E0AD  BD 17 25   			lda	vdc_regionA_xl, x	; 5
         00:E0B0  8D 02 02   			sta	VDC_DL			; 6
         00:E0B3  BD 27 25   			lda	vdc_regionA_xh, x	; 5
         00:E0B6  8D 03 02   			sta	VDC_DH			; 6 = 156 cycles from RCR if DUO
                             	
                             	;		bcc	!+
                             	;		lda	vdc_regionA_yh, x	; 5
                             	;		sta.l	VCE_CTW			; 6
                             	
         00:E0B9  8C 57 25   			sty	vdc_next_region		; 5
                             	
  223                        		.else
  225                        		.endif
  226                        	
  227               0001     		.if	SUPPORT_SGX
  228                        	
  229                        			; Handle the SGX's RCR interrupt.
  230                        	
  231    00:E0BC  2F 06 50   	!:		bbr2	<sgx_sr, !+		; 6 Is this an HSYNC interrupt?
  232                        	
  233               0001     		.ifdef	USING_RCR_MACROS
  234                        			SGX_RCR_MACRO
                             	
         00:E0BF  A9 06      			lda	#VDC_RCR		; 2
         00:E0C1  8D 10 02   			sta	SGX_AR			; 6
                             	
         00:E0C4  AE D8 25   			ldx	sgx_next_region		; 5 X and Y can be greater than
         00:E0C7  BC D9 25   			ldy	sgx_regionA_nxt, x	; 5 HUCC_SGX_SPLITS if regionB!
         00:E0CA  18         			clc				; 2
         00:E0CB  D0 05      			bne	!set_next_rcr+		; 4 Stop RCR if next line is 0.
                             	
         00:E0CD  2D 53 E0   			and	const_0000		; 5 A=$00 with the same #cycles
         00:E0D0  80 05      			bra	!clr_next_rcr+		; 4 as if the branch were taken.
                             	
         00:E0D2  B9 88 25   	!set_next_rcr:	lda	sgx_regionA_rcr, y	; 5 Set next RCR 1 line before
         00:E0D5  69 3F      			adc	#64-1			; 2 the region begins, or 0 to
         00:E0D7  8D 12 02   	!clr_next_rcr:	sta	SGX_DL			; 6 disable.
         00:E0DA  62         			cla				; 2
         00:E0DB  2A         			rol	a			; 2
         00:E0DC  8D 13 02   			sta	SGX_DH			; 6
                             	
         00:E0DF  A9 08      			lda	#VDC_BYR		; 2 Do BYR first to mitigate the
         00:E0E1  8D 10 02   			sta	SGX_AR			; 6 glitch if the IRQ is delayed.
         00:E0E4  BD B8 25   			lda	sgx_regionA_yl, x	; 5
         00:E0E7  8D 12 02   			sta	SGX_DL			; 6
         00:E0EA  BD C8 25   			lda	sgx_regionA_yh, x	; 5
         00:E0ED  8D 13 02   			sta	SGX_DH			; 6
                             	
         00:E0F0  A9 05      			lda	#VDC_CR			; 2
         00:E0F2  8D 10 02   			sta	SGX_AR			; 6
         00:E0F5  BD 78 25   			lda	sgx_regionA_crl, x	; 5
         00:E0F8  8D 12 02   			sta	SGX_DL			; 6
                             	
         00:E0FB  A9 07      			lda	#VDC_BXR		; 2
         00:E0FD  8D 10 02   			sta	SGX_AR			; 6
         00:E100  BD 98 25   			lda	sgx_regionA_xl, x	; 5
         00:E103  8D 12 02   			sta	SGX_DL			; 6
         00:E106  BD A8 25   			lda	sgx_regionA_xh, x	; 5
         00:E109  8D 13 02   			sta	SGX_DH			; 6 = 293 cycles (282 if no YH)
                             	
         00:E10C  8C D8 25   			sty	sgx_next_region		; 5
                             	
  235                        		.else
  237                        		.endif
  238                        	
  239                        		.endif	SUPPORT_SGX
  240                        	
  241                        			; Handle the VDC's VBL interrupt.
  242                        	
  243    00:E10F  5F F6 32   	!:		bbr5	<vdc_sr, .exit_irq1	; 6 Is this a VBLANK interrupt?
  244                        	
  245               0001     		.ifdef	USING_RCR_MACROS		;   If we didn't do it earlier
  246               0000     		.if	CDROM				;   then we need to do it now.
  253                        		.endif	CDROM
  254                        		.endif	USING_RCR_MACROS
  255                        	
  256               0001     		.if	SUPPORT_SGX
  257    00:E112  A9 05      			lda	#VDC_CR			; Update the SGX's Control
  258    00:E114  8D 10 02   			sta	SGX_AR			; Register first, just in
  259    00:E117  8D 00 02   			sta	VDC_AR			; case this is not an SGX!
  260    00:E11A  A5 03      			lda	<sgx_crl		
  261    00:E11C  8D 12 02   			sta	SGX_DL
  262    00:E11F  A5 F3      			lda	<vdc_crl
  263    00:E121  8D 02 02   			sta	VDC_DL
  264                        	
  265                        	;		lda	<sgx_crh		; Do not mess with the SGX's
  266                        	;		sta	SGX_DH			; auto-increment!!!
  267                        	;		lda	<vdc_crh		; Do not mess with the VDC's
  268                        	;		sta	VDC_DH			; auto-increment!!!
  269                        		.else
  277                        		.endif	SUPPORT_SGX
  278                        	
  279    00:E124  EE 41 22   			inc	irq_cnt			; Mark that a VBLANK occurred.
  280                        	
  281    00:E127  4F F5 02   			bbr4	<irq_vec, .skip_hookv	; Is a driver registered?
  282                        	
  283    00:E12A  44 26      			bsr	.user_vsync		; Call game's VBLANK code.
  284                        	
  285    00:E12C  DF F5 15   	.skip_hookv:	bbs5	<irq_vec, .exit_vbl	; Should we skip "BIOS" stuff?
  286                        	
  287    00:E12F  58         			cli				; Allow HSYNC and TIMER IRQ.
  288                        	
  289    00:E130  20 DB FF   			call	read_joypads		; Update joypad state.
  290                        	
  291               0000     		.if	USING_PSGDRIVER
  305                        		.else
  306    00:E133  AD 07 22   			lda	sound_hook + 1		; Is a driver registered?
  307    00:E136  F0 0C      			beq	.exit_vbl
  308                        	
  309    00:E138  A9 80      			lda	#$80			; Acquire sound mutex to avoid
  310    00:E13A  0C E7 22   			tsb	sound_mutex		; conflict with a delayed VBL.
  311    00:E13D  30 05      			bmi	.exit_vbl
  312                        	
  313    00:E13F  44 14      			bsr	.user_sound		; Call the driver hook.
  314                        	
  315    00:E141  9C E7 22   			stz	sound_mutex		; Release sound mutex.
  316                        		.endif	USING_PSGDRIVER
  317                        	
  318    00:E144             	.exit_vbl:
  319                        	
  320               0001     		.ifdef	USING_RCR_MACROS		; If USING_RCR_MACROS then 
  321               0000     		.if	CDROM				; restore after the VBLANK.
  326                        		.endif	CDROM
  327                        		.endif	USING_RCR_MACROS
  328                        	
  329    00:E144             	.exit_irq1:
  330                        	
  331               0000     		.ifndef	USING_RCR_MACROS		; If !USING_RCR_MACROS then
  338                        		.endif	USING_RCR_MACROS
  339                        	
  340               0001     		.if	SUPPORT_SGX
  341    00:E144  A5 07      			lda	<sgx_reg		; Restore SGX_AR first, just
  342    00:E146  8D 10 02   			sta	SGX_AR			; in case this is not an SGX!
  343                        		.endif
  344                        	
  345    00:E149  A5 F7      			lda	<vdc_reg		; Restore VDC_AR in case we
  346    00:E14B  8D 00 02   			sta	VDC_AR			; changed it.
  347                        	
  348    00:E14E  7A         			ply				; Restore all registers.
  349    00:E14F  FA         			plx
  350    00:E150  68         			pla
  351                        	
  352    00:E151  40         			rti				; Return from interrupt.
  353                        	
  354    00:E152  6C 08 22   	.user_vsync:	jmp	[vsync_hook]		; 7
  355    00:E155  6C 06 22   	.user_sound:	jmp	[sound_hook]		; 7
  356                        	
  357               0000     		.ifndef	USING_RCR_MACROS
  362                        		.endif	USING_RCR_MACROS
  363                        	
  364                        	
  365                        	
  366                        	; ***************************************************************************
  367                        	; ***************************************************************************
  368                        	;
  369                        	; core_timer - Minimal interrupt handler compatible with System Card.
  370                        	;
  371                        	; tirq_handler - Basic "CORE(not TM)" TIRQ handler to use as the "timer_hook".
  372                        	;
  373                        	; Doing the TIRQ handler processing in this hook means that things operate
  374                        	; the same whether the System Card or an Overlay is paged into MPR7.
  375                        	
  376               0000     		.ifndef	HUCC
  385                        		.else
  386                        			; Faster IRQ servicing for HuCC and code that would like to
  387                        			; avoid the 8 cycles used by the "bbs2" instruction that is
  388                        			; taken when the System Card is mapped into MPR7.
  389                        	
  390    00:E158             	core_timer:	;;;				; 8 (cycles for the INT)
  391               0001     		.if	CDROM || !defined(NO_CORE_TIRQ_HOOK)
  392    00:E158  6C 04 22   			jmp	[timer_hook]		; 7 cycles.
  393                        		.endif
  394                        		.endif
  395                        	
  396    00:E15B             	tirq_handler:
  397               0000     		.ifdef	USING_TIRQ_MACRO
  399                        		.else
  400    00:E15B  9C 03 14   			stz	IRQ_ACK			; 5 Clear timer interrupt.
  401                        		.endif
  402                        	
  403    00:E15E  40         	core_rti:	rti
  404                        	
  405                        	
  406                        	
  407                        	; ***************************************************************************
  408                        	; ***************************************************************************
  409                        	;
  410                        	; core_clr_hooks - Reset default "CORE(not TM)" interrupt-handling hooks.
  411                        	;
  412                        	
  413    00:E15F  08         	core_clr_hooks:	php				; Preserve interrupt state.
  414    00:E160  78         			sei				; Disable interrupts.
  415                        	
  416               0000     		.if	USING_PSGDRIVER
  419                        		.else
  420    00:E161  9C 07 22   			stz.h	sound_hook		; Disable sound driver calls.
  421                        		.endif
  422                        	
  423    00:E164  A9 88      			lda	#<core_sw_reset		; Set up the soft-reset hook.
  424    00:E166  8D 84 22   			sta.l	reset_hook
  425    00:E169  A9 E1      			lda	#>core_sw_reset
  426    00:E16B  8D 85 22   			sta.h	reset_hook
  427                        	
  428    00:E16E  A9 67      			lda	#<irq1_handler		; Set up the IRQ1 hook.
  429    00:E170  8D 02 22   			sta.l	irq1_hook
  430    00:E173  A9 E0      			lda	#>irq1_handler
  431    00:E175  8D 03 22   			sta.h	irq1_hook
  432                        	
  433    00:E178  A9 5B      			lda	#<tirq_handler		; Set up the TIRQ hook.
  434    00:E17A  8D 04 22   			sta.l	timer_hook
  435    00:E17D  A9 E1      			lda	#>tirq_handler
  436    00:E17F  8D 05 22   			sta.h	timer_hook
  437                        	
  438    00:E182  A9 06      			lda	#%00000110		; Replace the System Card's
  439    00:E184  85 F5      			sta	<irq_vec		; IRQ1 and TIRQ processing.
  440                        	
  441    00:E186  28         			plp				; Restore interrupt state.
  442    00:E187  60         			rts
  443                        	
  444                        	
  445                        	
  446                        	; ***************************************************************************
  447                        	; ***************************************************************************
  448                        	;
  449                        	; Include the joypad library, with configuration from "core-config.inc".
  450                        	;
  451                        	
                             #[6]   "..\..\..\include\hucc\joypad.asm"
  452                        			include "joypad.asm"
    1                        	; ***************************************************************************
    2                        	; ***************************************************************************
    3                        	;
    4                        	; joypad.asm
    5                        	;
    6                        	; Read 2-button & 6-button joypads & PCE mouse, with or without a MultiTap.
    7                        	;
    8                        	; Copyright John Brandwood 2019-2025.
    9                        	;
   10                        	; Distributed under the Boost Software License, Version 1.0.
   11                        	; (See accompanying file LICENSE_1_0.txt or copy at
   12                        	;  http://www.boost.org/LICENSE_1_0.txt)
   13                        	;
   14                        	; ***************************************************************************
   15                        	; ***************************************************************************
   16                        	;
   17                        	; Unlike Lemmings, this code does not interfere with a Memory Base 128! ;-)
   18                        	;
   19                        	; ***************************************************************************
   20                        	; ***************************************************************************
   21                        	;
   22                        	; With SUPPORT_MOUSE ..... 2602 cycles to read 5 ports with 5 mice
   23                        	;
   24                        	; With HuC library code .. 2442 cycles to read 5 ports with 5 pads (2-button)
   25                        	; With HuC library code .. 2442 cycles to read 5 ports with 5 pads (6-button)
   26                        	;
   27                        	; With SUPPORT_MOUSE ....  2016 cycles to read 5 ports with 5 pads (2-button)
   28                        	; With SUPPORT_MOUSE ..... 1976 cycles to read 5 ports with 5 pads (6-button)
   29                        	;
   30                        	; With SUPPORT_MOUSE ....  1618 cycles to read 3 ports with 3 mice
   31                        	; With SUPPORT_MOUSE ..... 1462 cycles to read 3 ports with 2 mice
   32                        	; With SUPPORT_MOUSE ..... 1306 cycles to read 3 ports with 1 mouse
   33                        	;
   34                        	; With SUPPORT_6BUTTON ... 1235 cycles to read 5 ports with 5 pads (2-button)
   35                        	; With SUPPORT_6BUTTON ... 1215 cycles to read 5 ports with 5 pads (6-button)
   36                        	;
   37                        	; With SUPPORT_MOUSE ..... 1126 cycles to read 2 ports with 2 mice
   38                        	; With SUPPORT_MOUSE ...... 970 cycles to read 2 ports with 1 mouse
   39                        	;
   40                        	; Only SUPPORT_2BUTTON .... 971 cycles to read 5 ports with 5 pads (2-button)
   41                        	; Only SUPPORT_2BUTTON .... 861 cycles to read 5 ports with 5 pads (6-button)
   42                        	;
   43                        	; With SUPPORT_MOUSE ...... 634 cycles to read 1 port  with 1 mouse
   44                        	;
   45                        	; ***************************************************************************
   46                        	; ***************************************************************************
   47                        	
  142                        	
  143                        	;
  144                        	; Now choose which version of the code to include.
  145                        	;
  146                        	
  147               0000     		.if	SUPPORT_2BUTTON
  278                        		.endif	SUPPORT_2BUTTON
  279                        	
  280                        	
  281                        	
  282               0000     		.if	SUPPORT_MOUSE
  845                        		.else	SUPPORT_MOUSE
  846                        	
  847                        	
  848                        	
  849               0001     		.if	SUPPORT_6BUTTON			; Without mouse!
  850                        	
  851                        	; ***************************************************************************
  852                        	; ***************************************************************************
  853                        	;
  854                        	; read_joypads - full 6-button pad support, but mouse movement is ignored.
  855                        	;
  856                        	; This code distinguishes between a mouse and a 2-button or 6-button joypad,
  857                        	; so that unsupported devices do not have to be unplugged from the MultiTap.
  858                        	;
  859                        	; The code loops two times to get both sets of buttons on a 6-button joypad.
  860                        	;
  861                        	; N.B. Takes approx 1/3 frame to detect mice the first time it is run.
  862                        	;
  863                        	; bit values for joypad 2-button bytes: (MSB = #7; LSB = #0)
  864                        	; ----------------------------------------------------------
  865                        	; bit 0 (ie $01) = I
  866                        	; bit 1 (ie $02) = II
  867                        	; bit 2 (ie $04) = SELECT
  868                        	; bit 3 (ie $08) = RUN
  869                        	; bit 4 (ie $10) = UP
  870                        	; bit 5 (ie $20) = RIGHT
  871                        	; bit 6 (ie $40) = DOWN
  872                        	; bit 7 (ie $80) = LEFT
  873                        	;
  874                        	; bit values for joypad 6-button bytes: (MSB = #7; LSB = #0)
  875                        	; ----------------------------------------------------------
  876                        	; bit 0 (ie $01) = III
  877                        	; bit 1 (ie $02) = IV
  878                        	; bit 2 (ie $04) = V
  879                        	; bit 3 (ie $08) = VI
  880                        	; bit 4 (ie $10) = zero
  881                        	; bit 5 (ie $20) = zero
  882                        	; bit 6 (ie $40) = zero
  883                        	; bit 7 (ie $80) = zero, but set to one if 6-button pad detected.
  884                        	;
  885                        	
  886               E188     			.code
  887                        	
  888               0001     		.if	(* >= $4000)			; Make this a ".proc" if it
  889    01:DE76             	read_joypads	.proc                           ; not running in RAM.
  890                        		.else
  892                        		.endif
  893                        	
  894    01:DE76  A9 80      			lda	#$80			; Acquire port mutex to avoid
  895    01:DE78  0C D0 22   			tsb	port_mutex		; conflict with a delayed VBL
  896    01:DE7B  30 75      			bmi	.exit			; or access to an MB128.
  897                        	
  898    01:DE7D  73 28 22 32			tii	joynow,joyold,MAX_PADS	; Save the previous values.
         01:DE81  22 05 00    
  899    01:DE84  73 D3 22 D8			tii	joy6now,joy6old,MAX_PADS
         01:DE88  22 05 00    
  900                        	
  901                        			; Reset the 6-btn bits, the user might change the joypad mode!
  902                        	
  903    01:DE8B  F3 53 E0 D3			tai	const_0000, joy6now, MAX_PADS
         01:DE8F  22 05 00    
  904                        	
  905                        			; Detect attached mice the first time this routine is called.
  906                        	
  907    01:DE92  AD D2 22   			lda	mouse_flg		; Has mouse detection happened?
  908    01:DE95  30 28      			bmi	.calc_pressed
  909                        	
  910    01:DE97  A9 05      			lda	#MAX_PADS		; Reset number of pads to read.
  911    01:DE99  8D D1 22   			sta	num_ports
  912                        	
  913    01:DE9C  A9 1F      			lda	#%00011111		; Try reading everything as a
  914    01:DE9E  8D D2 22   			sta	mouse_flg		; mouse.
  915                        	
  916    01:DEA1  A0 17      			ldy	#23			; Initialize repeat count.
  917    01:DEA3  A9 80      			lda	#$80			; Initialize mouse detection.
  918    01:DEA5  5A         	.detect_loop:	phy
  919    01:DEA6  48         			pha
  920    01:DEA7  44 53      			bsr	.read_devices		; Read all devices as if mice.
  921    01:DEA9  68         			pla
  922    01:DEAA  82         			clx
  923    01:DEAB  BC E2 22   	.detect_port:	ldy	mouse_x, x		; A movement of zero means
  924    01:DEAE  D0 03      			bne	.detect_next		; this port is a mouse.
  925    01:DEB0  1D 55 E0   			ora	bit_mask, x
  926    01:DEB3  E8         	.detect_next:	inx				; Get the next pad from the
  927    01:DEB4  E0 05      			cpx	#MAX_PADS		; multitap.
  928    01:DEB6  D0 F3      			bne	.detect_port
  929    01:DEB8  7A         			ply				; Repeat the detection test.
  930    01:DEB9  88         			dey
  931    01:DEBA  D0 E9      			bne	.detect_loop
  932                        	
  933                        	;	.if	DETECT_PHANTOMS
  934                        	;		cmp	#(1 << MAX_PADS) + 127	; If we find a mouse in every
  935                        	;		bne	.detect_done		; port, then assume mirrored!
  936                        	;		lda	#1			; Report a single mouse in a
  937                        	;		sta	num_ports		; single port.
  938                        	;		lda	#$81
  939                        	;	.endif
  940                        	
  941    01:DEBC  8D D2 22   	.detect_done:	sta	mouse_flg		; Report mouse detection.
  942                        	
  943                        			; See what has just been pressed, and check for soft-reset.
  944                        	
  945    01:DEBF  44 3B      	.calc_pressed:	bsr	.read_devices		; Read all devices normally.
  946                        	
  947    01:DEC1  A2 04      			ldx	#MAX_PADS - 1
  948                        	
  949    01:DEC3  BD D3 22   	.pressed_loop:	lda	joy6now, x		; Calc which buttons have just
  950    01:DEC6  5D D8 22   			eor	joy6old, x		; been pressed (6-button).
  951    01:DEC9  3D D3 22   			and	joy6now, x
  952               0000     		.if	HUC_JOY_EVENTS
  956                        		.else
  957               0000     		.if	ACCUMULATE_JOY
  959                        		.endif
  960    01:DECC  9D DD 22   			sta	joy6trg, x
  961                        		.endif
  962                        	
  963    01:DECF  BD 28 22   			lda	joynow, x		; Calc which buttons have just
  964    01:DED2  A8         			tay                             ; been pressed (2-button).
  965    01:DED3  5D 32 22   			eor	joyold, x
  966    01:DED6  3D 28 22   			and	joynow, x
  967               0000     		.if	HUC_JOY_EVENTS
  971                        		.else
  972               0000     		.if	ACCUMULATE_JOY
  974                        		.endif
  975    01:DED9  9D 2D 22   			sta	joytrg, x
  976                        		.endif
  977                        	
  978    01:DEDC  C9 04      			cmp	#$04			; Detect the soft-reset combo,
  979    01:DEDE  D0 0C      			bne	.not_reset		; hold RUN then press SELECT.
  980    01:DEE0  C0 0C      			cpy	#$0C
  981    01:DEE2  D0 08      			bne	.not_reset
  982    01:DEE4  BD 55 E0   			lda	bit_mask, x
  983    01:DEE7  2C 27 22   			bit	joyena
  984    01:DEEA  D0 09      			bne	.soft_reset
  985                        	
  986    01:DEEC  CA         	.not_reset:	dex				; Check the next pad from the
  987    01:DEED  10 D4      			bpl	.pressed_loop		; multitap.
  988                        	
  989    01:DEEF  9C D0 22   			stz	port_mutex		; Release port mutex.
  990                        	
  991               0001     		.if	(* >= $4000)			; This is a ".proc" if it is
  992                        	.exit:		leave                           ; not running in RAM.
         01:DEF2  4C EF FF   			jmp	leave_proc
  993                        		.else
  995                        		.endif
  996                        	
  997    01:DEF5  78         	.soft_reset:	sei				; Disable interrupts.
  998    01:DEF6  9C D0 22   			stz	port_mutex		; Release port mutex.
  999    01:DEF9  6C 84 22   			jmp	[reset_hook]		; Jump to the soft-reset hook.
 1000                        	
 1001                        			; Read all of the devices attached to the MultiTap.
 1002                        	
 1003    01:DEFC  A2 02      	.read_devices:	ldx	#2			; Repeat this loop 2 times.
 1004                        	
 1005    01:DEFE  A9 01      	.read_multitap:	lda	#$01			; CLR lo, SEL hi for d-pad.
 1006    01:DF00  8D 00 10   			sta	IO_PORT
 1007    01:DF03  A9 03      			lda	#$03			; CLR hi, SEL hi, reset tap.
 1008    01:DF05  8D 00 10   			sta	IO_PORT
 1009    01:DF08  C2         			cly				; Start at port 1.
 1010                        	
 1011    01:DF09  A9 01      	.read_port:	lda	#$01			; CLR lo, SEL hi for d-pad.
 1012    01:DF0B  8D 00 10   			sta	IO_PORT			; Wait 1.25us (9 cycles).
 1013                        	
 1014    01:DF0E  B9 55 E0   			lda	bit_mask, y		; Is there a mouse attached?
 1015    01:DF11  2D D2 22   			and	mouse_flg
 1016    01:DF14  D0 33      			bne	.read_mouse
 1017                        	
 1018    01:DF16  AD 00 10   	.read_pad:	lda	IO_PORT			; Read direction-pad bits.
 1019    01:DF19  9C 00 10   			stz	IO_PORT			; CLR lo, SEL lo for buttons.
 1020    01:DF1C  0A         			asl	a			; Wait 1.25us (9 cycles).
 1021    01:DF1D  0A         			asl	a
 1022    01:DF1E  0A         			asl	a
 1023    01:DF1F  0A         			asl	a
 1024    01:DF20  F0 1B      			beq	.read_6button		; 6-btn pad if UDLR all held.
 1025                        	
 1026    01:DF22  99 28 22   	.read_2button:	sta	joynow, y		; Get buttons of 2-btn pad.
 1027    01:DF25  AD 00 10   			lda	IO_PORT
 1028    01:DF28  29 0F      			and	#$0F
 1029    01:DF2A  19 28 22   			ora	joynow, y
 1030    01:DF2D  49 FF      			eor	#$FF
 1031    01:DF2F  99 28 22   			sta	joynow, y
 1032                        	
 1033    01:DF32  C8         	.next_port:	iny				; Get the next pad from the
 1034    01:DF33  CC D1 22   			cpy	num_ports		; multitap.
 1035    01:DF36  90 D1      			bcc	.read_port
 1036                        	
 1037    01:DF38  CA         			dex				; Do the next complete pass.
 1038    01:DF39  CA         			dex
 1039    01:DF3A  10 C2      			bpl	.read_multitap		; Have we finished 2 passes?
 1040    01:DF3C  60         			rts				; Now that everything is read.
 1041                        	
 1042    01:DF3D  AD 00 10   	.read_6button:	lda	IO_PORT			; Get buttons of 6-btn pad.
 1043    01:DF40  29 0F      			and	#$0F
 1044    01:DF42  49 8F      			eor	#$8F			; Set bit-7 to show that a
 1045    01:DF44  99 D3 22   			sta	joy6now, y		; 6-button pad is present.
 1046    01:DF47  80 E9      			bra	.next_port
 1047                        	
 1048    01:DF49  7C 7A DF   	.read_mouse:	jmp	[.mouse_vectors, x]	; Which mouse info is next?
 1049                        	
 1050                        			; Mouse processing, normally four passes, here just two.
 1051                        	
 1052    01:DF4C  A9 1C      	.mouse_x_hi:	lda	#28			; 189 cycle delay after CLR lo
 1053    01:DF4E  3A         	.wait_loop:	dec	a			; on port to allow the mouse
 1054    01:DF4F  D0 FD      			bne	.wait_loop		; to buffer and reset counters.
 1055                        	
 1056    01:DF51  AD 00 10   			lda	IO_PORT			; Read direction-pad bits.
 1057    01:DF54  9C 00 10   			stz	IO_PORT			; CLR lo, SEL lo for buttons.
 1058    01:DF57  0A         			asl	a			; Wait 1.25us (9 cycles).
 1059    01:DF58  0A         			asl	a
 1060    01:DF59  0A         			asl	a
 1061    01:DF5A  0A         			asl	a
 1062    01:DF5B  99 E2 22   			sta	mouse_x, y		; Save port's X-hi nibble.
 1063                        	
 1064    01:DF5E  AD 00 10   			lda	IO_PORT			; Get mouse buttons.
 1065    01:DF61  29 0F      			and	#$0F
 1066    01:DF63  49 0F      			eor	#$0F
 1067    01:DF65  99 28 22   			sta	joynow, y
 1068    01:DF68  80 C8      			bra	.next_port
 1069                        	
 1070    01:DF6A  AD 00 10   	.mouse_x_lo:	lda	IO_PORT			; Read direction-pad bits.
 1071    01:DF6D  9C 00 10   			stz	IO_PORT			; CLR lo, SEL lo for buttons.
 1072    01:DF70  29 0F      			and	#$0F			; Wait 1.25us (9 cycles).
 1073    01:DF72  19 E2 22   			ora	mouse_x, y		; Add port's X-hi nibble.
 1074                        	;		eor	#$FF			; Negate so LEFT is -ve.
 1075                        	;		inc	a
 1076    01:DF75  99 E2 22   			sta	mouse_x, y
 1077    01:DF78  80 B8      			bra	.next_port
 1078                        	
 1079    01:DF7A  6A DF      	.mouse_vectors: dw	.mouse_x_lo		; Pass 2
 1080    01:DF7C  4C DF      			dw	.mouse_x_hi		; Pass 1
 1081                        	
 1082               0001     		.if	(* >= $4000)			; This is a ".proc" if it is
 1083                        			.endp                           ; not running in RAM.
 1084               22D0     			.bss				; Put the variables in RAM.
 1085                        		.endif
 1086                        	
 1087    F8:22D0             	port_mutex:	ds	1			; NZ when controller port busy.
 1088    F8:22D1             	num_ports:	ds	1			; Set to 1 if no multitap.
 1089    F8:22D2             	mouse_flg:	ds	1			; Which ports are mice?
 1090               0000     		.if	HUC_JOY_EVENTS
 1093                        		.endif
 1094    F8:22D3             	joy6now:	ds	MAX_PADS
 1095    F8:22D8             	joy6old:	ds	MAX_PADS
 1096    F8:22DD             	joy6trg:	ds	MAX_PADS
 1097    F8:22E2             	mouse_x:	ds	MAX_PADS
 1098                        	
 1099               E188     			.code
 1100                        	
 1101                        		.endif	SUPPORT_6BUTTON			; Without mouse!
 1102                        	
 1103                        		.endif	SUPPORT_MOUSE
                             #[5]   "..\..\..\include\hucc\core-kernel.asm"
  453                        	
  454                        	
  455                        	
  456               0001     		.if	!CDROM
  457                        	
  458                        	; ***************************************************************************
  459                        	; ***************************************************************************
  460                        	;
  461                        	; core_sw_reset - Default HuCARD handler for a joypad "soft-reset".
  462                        	;
  463                        	
  464    00:E188  78         	core_sw_reset:	sei				; Disable interrupts.
  465                        	
  466    00:E189  6C FE FF   			jmp	[$FFFE]			; Jump to the HuCARD reset.
  467                        	
  468                        	
  469                        	
  470                        		.else	!CDROM
  616                        		.endif	!CDROM
  617                        	
  618                        	
  619                        	
  620                        	; ***************************************************************************
  621                        	; ***************************************************************************
  622                        	
  623               0001     		.if	(core_kernel >= $4000)		; If not running in RAM, then
  624               22E7     			.bss				; put these variables in RAM.
  625                        		.endif
  626                        	
  627    F8:22E7             	sound_mutex:	ds	1			; NZ when controller port busy.
  628                        	
  629               0001     		.if	SUPPORT_SGX
  630    F8:22E8             	sgx_detected:	ds	1			; NZ if SuperGrafx detected.
  631    F8:22E9             	hsync_hook_sgx:	ds	2			; SGX version of hsync_hook.
  632                        		.endif
  633                        	
  634               0000     		.if	SUPPORT_ACD
  636                        		.endif
  637                        	
  638               0001     		.if	(core_kernel >= $4000)
  639               E18C     			.code
  640                        		.endif
                             #[4]   "..\..\..\include\hucc\core-startup.asm"
  427                        	
  428                        	
  429                        	
  430                        		.else	!CDROM
  524                        		.endif	!CDROM
  525                        	
  526                        	
  527                        	
  528                        	; ***************************************************************************
  529                        	; ***************************************************************************
  530                        	;
  531                        	; With the availability of so many different configuration options, we've now
  532                        	; built somewhere between a few hundred bytes, and a couple of KB, of code in
  533                        	; the CORE_BANK of the HuCARD / overlay program.
  534                        	;
  535                        	; This is the end of the "CORE(not TM)" library code!
  536                        	;
  537                        	; Remember that the ".proc" trampolines are located at the end of this bank,
  538                        	; so the amount of free space left depends upon the number of ".proc" calls.
  539                        	;
  540                        	
  541                        			; Switch to CORE_PAGE to run the developer's game code.
  542               E18C     			.page	CORE_PAGE
  543                        	
  544                        	
  545                        	
  546                        	; ***************************************************************************
  547                        	; ***************************************************************************
  548                        	;
  549                        	; The DATA_BANK location needs to be set as early as possible so that library
  550                        	; code is able to put data in there before the total overall size of the code
  551                        	; is known.
  552                        	;
  553                        	; By default, DATA_BANK is the next bank after the CORE_BANK.
  554                        	;
  555                        	; RESERVE_BANKS allows developers to reserve some banks between the CORE_BANK
  556                        	; and the DATA_BANK that they can use however they wish.
  557                        	;
  558                        	; One use for RESERVE_BANKS is to create empty space that PCEAS can use when
  559                        	; it relocates procedures. This provides a way for a developer to group code
  560                        	; together at the start of memory, and leave the maximum number of banks for
  561                        	; loading dynamic data from CD-ROM.
  562                        	;
  563                        	; The KickC environment sets RESERVE_BANKS=1 (or higher) so that there is a
  564                        	; a bank for the permanent C code and static constants.
  565                        	;
  566                        	; RESERVE_BANKS is normally defined in each project's "core-config.inc".
  567                        	;
  568                        	
  569                        			.opt	d+			; DATA labels use fixed MPR.
  570                        	
  571               0001     			.rsset	CORE_BANK + 1
  572                        	
  573               0000     		.ifdef	NEED_HOME_BANK
  580                        		.endif
  581                        	
  582               0001     		.ifdef	NEED_SOUND_BANK			; Defined in hucc-sound.inc
  583               0000     		.if	NEED_SOUND_BANK			; if the driver wants a bank.
  585                        		.endif
  586                        		.endif
  587                        	
  588               0001     		.ifdef	RESERVE_BANKS			; For CORE projects.
  589               0001     	RESERVED_BANK	.rs	RESERVE_BANKS
  590                        		.endif
  591                        	
  592               0001     		.ifdef	HUCC
  593               0001     		.ifdef	HUC_RESERVE_BANKS		; For HuCC projects.
  594               0001     	HUC_USER_BANK	.rs	HUC_RESERVE_BANKS
  595                        		.endif
  596                        	
  597               0001     	CONST_BANK	.rs	2
  598               6000     			.rodata
  599               0001     			.bank	CONST_BANK, ".rodata"
  600                        		.endif	HUCC
  601                        	
  602               0003     	DATA_BANK	.rs	0
  603               6000     			.data
  604               0000     		.if	BUILDING_STAGE1
  606                        		.else
  607               0003     			.bank	DATA_BANK, ".data"
  608                        		.endif
  609               6000     			.org	$6000
  610                        	
  611               E18C     			.code
                             #[3]   "..\..\..\include\hucc\core.inc"
                             #[2]   "..\..\..\include\hucc\hucc.asm"
  120                        		.else
  126                        		.endif
  127                        	
  128                        			; Allocate this as early as possible to ensure bank-aligned
  129                        			; so that there is no wasted space for aligning the table.
  130                        	
  131               0000     		.if	FAST_MULTIPLY
  138                        		.endif
  139                        	
  140                        			;
  141                        	
  144                        	
  145                        			; The hardware stack is used for expressions.
  146                        	
  147               00FF     	__tos		=	$F8:2101, 255
  148                        	
  149               2008     			.zp
  150               2008     			.align	2
  151    F8:2008             	__stack:	ds	HUCC_STACK_SZ
  152                        	
  153    F8:2088             	__ptr:		ds	2
  154    F8:208A             	__fptr:		ds	2
  155    F8:208C             	__fbank:	ds	1
  156    F8:208D             	__sp:		ds	1
  157                        	
  158                        			; REGTEMP 6-byte stack for temporaries used by SDCC.
  159                        			; Keep the size in sync with NUM_TEMP_REGS in sdcc/src/mos6502/gen.h!
  160                        	
  161    F8:208E             	REGTEMP:	ds	6
  162                        	
  163                        			; HuCC's non-recursive consecutive varargs for printf().
  164                        	
  165               2008     	__vararg1	=	__stack + 0
  166               200A     	__vararg2	=	__stack + 2
  167               200C     	__vararg3	=	__stack + 4
  168               200E     	__vararg4	=	__stack + 6
  169                        	
  170                        			; Pointer used by poke() because __ptr could be overwritten.
  171                        	
  172               20EE     	__poke		=	__si
  173                        	
  174                        			; Used for indirect calls because __ptr could be overwritten.
  175                        	
  176               20EE     	__func		=	__si
  177                        	
  178                        			; Data pointer used by SDCC for indirect indexed memory access.
  179                        	
  180               2088     	DPTR		=	__ptr
  181                        	
  182                        			; Values returned from SDCC functions that don't fit into XA.
  183                        			; These are also used as workspace for SDCC library functions,
  184                        			; including HuCC's multiplication and division functions.
  185                        	
  186    F8:2094             	___SDCC_m6502_ret0:	ds	1
  187    F8:2095             	___SDCC_m6502_ret1:	ds	1
  188    F8:2096             	___SDCC_m6502_ret2:	ds	1
  189    F8:2097             	___SDCC_m6502_ret3:	ds	1
  190                        	
  191               0000     		.if	0
  196                        		.endif
  197                        	
  198                        			; Permanent pointers for fast table-of-squares multiplication.
  199                        	
  200               0000     		.if	FAST_MULTIPLY
  205                        		.endif
  206                        	
  207                        			; HuCC keeps a realtime clock, updated in hucc_vbl.
  208                        			;
  209                        			; Defining this here means that it will go before any HuCC
  210                        			; variables in "globals.h", and so it won't get cleared in
  211                        			; a CDROM game when loading different overlays.
  212                        	
  213               22EB     			.bss
  214    F8:22EB             	old_cnt:	ds	1			; irq_cnt of previous vsync().
  215    F8:22EC             	clock_hh:	ds	1			; System Clock, hours	(0-11)
  216    F8:22ED             	clock_mm:	ds	1			; System Clock, minutes (0-59)
  217    F8:22EE             	clock_ss:	ds	1			; System Clock, seconds (0-59)
  218    F8:22EF             	clock_tt:	ds	1			; System Clock, ticks	(0-59)
  219               E18C     			.code
  220                        	
  221                        			; Critical HuCC libraries that the compiler depends upon.
  222                        			;
  223                        			; These include various macros that must be defined before
  224                        			; they are encountered in any compiler-generated code.
  225                        	
                             #[3]   "..\..\..\include\hucc\hucc-codegen.asm"
  226                        			include "hucc-codegen.asm"	; HuCC i-code macros and funcs.
    1                        	; ***************************************************************************
    2                        	; ***************************************************************************
    3                        	;
    4                        	; hucc-codegen.asm
    5                        	;
    6                        	; The HuCC compiler translates C code into these macros, it does not directly
    7                        	; generate HuC6280 instructions.
    8                        	;
    9                        	; Based on the original HuC macros created by David Michel and the other HuC
   10                        	; developers, later modified and improved by Ulrich Hecht.
   11                        	;
   12                        	; Modifications copyright John Brandwood 2024.
   13                        	;
   14                        	; Distributed under the Boost Software License, Version 1.0.
   15                        	; (See accompanying file LICENSE_1_0.txt or copy at
   16                        	;  http://www.boost.org/LICENSE_1_0.txt)
   17                        	;
   18                        	; ***************************************************************************
   19                        	; ***************************************************************************
   20                        	;
   21                        	; NAMING SCHEME FOR HuCC MACROS ...
   22                        	;
   23                        	;   __function.parameters
   24                        	;
   25                        	; {parameters} is a list of alphanumeric specifiers, starting with {size} and
   26                        	; followed by {where}, followed by {index} if an array, then optional {value}
   27                        	; and finally ending with optional {suffix}
   28                        	;
   29                        	; {size}
   30                        	;   w : 16-bit signed int (default "int" in HuCC)
   31                        	;   c : 16-bit unsigned int (a "cardinal" in Pascal terms)
   32                        	;   b :  8-bit signed char
   33                        	;   u :  8-bit unsigned char (default "char" in HuCC)
   34                        	;
   35                        	; {where} or {index}
   36                        	;   r : HuCC primary register, made up of the Y:A cpu registers
   37                        	;   t : top of expression stack
   38                        	;   p : indirect pointer, usually [__ptr]
   39                        	;   f : structure field (member) offset value
   40                        	;   i : immediate value, i.e. a decimal number
   41                        	;   m : memory, i.e. C global, static, and "-fno-recursive" variables
   42                        	;   s : stack, i.e. C function parameters and locals (not "-fno-recursive")
   43                        	;   a : array, i.e. C global, static, "-fno-recursive" arrays <= 256 bytes
   44                        	;   x : array index already in the X register
   45                        	;   y : array index already in the Y register
   46                        	;
   47                        	; {value} OPTIONAL
   48                        	;   i : immediate value, i.e. a decimal number
   49                        	;   z : zero value
   50                        	;
   51                        	; {suffix} OPTIONAL
   52                        	;   q : quick, used for optimized math on only 8-bit values, because all math
   53                        	;       is normally promoted to "int" size in C; and when optimized stores do
   54                        	;       not need to preserve the primary register contents
   55                        	;
   56                        	; ***************************************************************************
   57                        	; ***************************************************************************
   58                        	
   59                        	
   60                        	
 8399                        	
 8400                        	; ***************************************************************************
 8401                        	; ***************************************************************************
 8402                        	; subroutines for logical and arithmetic shifts by a constant amount
 8403                        	; ***************************************************************************
 8404                        	; ***************************************************************************
 8405                        	
 8406                        	; **************
 8407                        	; Y:A = Y:A << const
 8408                        	
 8409    00:E1BE  0A         	aslw15:		asl	a
 8410    00:E1BF  0A         	aslw14:		asl	a
 8411    00:E1C0  0A         	aslw13:		asl	a
 8412    00:E1C1  0A         	aslw12:		asl	a
 8413    00:E1C2  0A         	aslw11:		asl	a
 8414    00:E1C3  0A         	aslw10:		asl	a
 8415    00:E1C4  0A         	aslw9:		asl	a
 8416    00:E1C5  A8         	aslw8:		tay
 8417    00:E1C6  62         			cla
 8418    00:E1C7  60         			rts
 8419                        	
 8420               0001     		.if	1
 8421    00:E1C8  66 00      	aslw5:		ror	<__temp
 8422    00:E1CA  6A         			ror	a
 8423    00:E1CB  66 00      	aslw6:		ror	<__temp
 8424    00:E1CD  6A         			ror	a
 8425    00:E1CE  66 00      	aslw7:		ror	<__temp
 8426    00:E1D0  6A         			ror	a
 8427    00:E1D1  A4 00      			ldy	<__temp
 8428    00:E1D3  60         			rts
 8429                        		.else
 8436                        		.endif
 8437    00:E1D4  0A         	aslw4:		asl	a
 8438    00:E1D5  26 00      			rol	<__temp
 8439    00:E1D7  0A         	aslw3:		asl	a
 8440    00:E1D8  26 00      			rol	<__temp
 8441    00:E1DA  0A         	aslw2:		asl	a
 8442    00:E1DB  26 00      			rol	<__temp
 8443    00:E1DD  0A         	aslw1:		asl	a
 8444    00:E1DE  26 00      			rol	<__temp
 8445    00:E1E0  A4 00      	aslw0:		ldy	<__temp
 8446    00:E1E2  60         			rts
 8447                        	
 8448                        	; **************
 8449                        	; Y:A = Y:A >> const
 8450                        	
 8451    00:E1E3  C9 80      	asrw15:		cmp	#$80
 8452    00:E1E5  6A         			ror	a
 8453    00:E1E6  C9 80      	asrw14:		cmp	#$80
 8454    00:E1E8  6A         			ror	a
 8455    00:E1E9  C9 80      	asrw13:		cmp	#$80
 8456    00:E1EB  6A         			ror	a
 8457    00:E1EC  C9 80      	asrw12:		cmp	#$80
 8458    00:E1EE  6A         			ror	a
 8459    00:E1EF  C9 80      	asrw11:		cmp	#$80
 8460    00:E1F1  6A         			ror	a
 8461    00:E1F2  C9 80      	asrw10:		cmp	#$80
 8462    00:E1F4  6A         			ror	a
 8463    00:E1F5  C9 80      	asrw9:		cmp	#$80
 8464    00:E1F7  6A         			ror	a
 8465    00:E1F8  C9 80      	asrw8:		cmp	#$80
 8466    00:E1FA  C2         			cly
 8467    00:E1FB  90 01      			bcc	!+
 8468    00:E1FD  88         			dey
 8469    00:E1FE  60         	!:		rts
 8470                        	
 8471    00:E1FF  C0 80      	asrw7:		cpy	#$80
 8472    00:E201  66 00      			ror	<__temp
 8473    00:E203  6A         			ror	a
 8474    00:E204  C0 80      	asrw6:		cpy	#$80
 8475    00:E206  66 00      			ror	<__temp
 8476    00:E208  6A         			ror	a
 8477    00:E209  C0 80      	asrw5:		cpy	#$80
 8478    00:E20B  66 00      			ror	<__temp
 8479    00:E20D  6A         			ror	a
 8480    00:E20E  C0 80      	asrw4:		cpy	#$80
 8481    00:E210  66 00      			ror	<__temp
 8482    00:E212  6A         			ror	a
 8483    00:E213  C0 80      	asrw3:		cpy	#$80
 8484    00:E215  66 00      			ror	<__temp
 8485    00:E217  6A         			ror	a
 8486    00:E218  C0 80      	asrw2:		cpy	#$80
 8487    00:E21A  66 00      			ror	<__temp
 8488    00:E21C  6A         			ror	a
 8489    00:E21D  C0 80      	asrw1:		cpy	#$80
 8490    00:E21F  66 00      			ror	<__temp
 8491    00:E221  6A         			ror	a
 8492    00:E222  A4 00      	asrw0:		ldy	<__temp
 8493    00:E224  60         			rts
 8494                        	
 8495                        	; **************
 8496                        	; Y:A = Y:A >> const
 8497                        	
 8498    00:E225  4A         	lsrw15:		lsr	a
 8499    00:E226  4A         	lsrw14:		lsr	a
 8500    00:E227  4A         	lsrw13:		lsr	a
 8501    00:E228  4A         	lsrw12:		lsr	a
 8502    00:E229  4A         	lsrw11:		lsr	a
 8503    00:E22A  4A         	lsrw10:		lsr	a
 8504    00:E22B  4A         	lsrw9:		lsr	a
 8505    00:E22C  C2         	lsrw8:		cly
 8506    00:E22D  60         			rts
 8507                        	
 8508    00:E22E  46 00      	lsrw7:		lsr	<__temp
 8509    00:E230  6A         			ror	a
 8510    00:E231  46 00      	lsrw6:		lsr	<__temp
 8511    00:E233  6A         			ror	a
 8512    00:E234  46 00      	lsrw5:		lsr	<__temp
 8513    00:E236  6A         			ror	a
 8514    00:E237  46 00      	lsrw4:		lsr	<__temp
 8515    00:E239  6A         			ror	a
 8516    00:E23A  46 00      	lsrw3:		lsr	<__temp
 8517    00:E23C  6A         			ror	a
 8518    00:E23D  46 00      	lsrw2:		lsr	<__temp
 8519    00:E23F  6A         			ror	a
 8520    00:E240  46 00      	lsrw1:		lsr	<__temp
 8521    00:E242  6A         			ror	a
 8522    00:E243  A4 00      	lsrw0:		ldy	<__temp
 8523    00:E245  60         			rts
 8524                        	
 8525                        	
 8526                        	
 8527                        	; ***************************************************************************
 8528                        	; ***************************************************************************
 8529                        	; subroutines for logical and arithmetic shifts by a variable amount
 8530                        	; ***************************************************************************
 8531                        	; ***************************************************************************
 8532                        	
 8533                        	; **************
 8534                        	; Y:A = Y:A << X
 8535                        	
 8536    00:E246  84 00      	asl.wx:		sty	<__temp
 8537    00:E248  E0 10      			cpx	#16
 8538    00:E24A  B0 37      			bcs	!zero+
 8539    00:E24C  CA         			dex
 8540    00:E24D  30 06      			bmi	.done
 8541    00:E24F  0A         	.loop:		asl	a
 8542    00:E250  26 00      			rol	<__temp
 8543    00:E252  CA         			dex
 8544    00:E253  10 FA      			bpl	.loop
 8545    00:E255  A4 00      	.done:		ldy	<__temp
 8546    00:E257  60         			rts
 8547                        	
 8548                        	; **************
 8549                        	; Y:A = Y:A >> X
 8550                        	
 8551    00:E258  84 00      	asr.wx:		sty	<__temp
 8552    00:E25A  10 17      			bpl	!positive+
 8553    00:E25C  E0 10      	!negative:	cpx	#16
 8554    00:E25E  B0 0D      			bcs	.sign
 8555    00:E260  CA         			dex
 8556    00:E261  30 07      			bmi	.done
 8557    00:E263  38         	.loop:		sec
 8558    00:E264  66 00      			ror	<__temp
 8559    00:E266  6A         			ror	a
 8560    00:E267  CA         			dex
 8561    00:E268  10 F9      			bpl	.loop
 8562    00:E26A  A4 00      	.done:		ldy	<__temp
 8563    00:E26C  60         			rts
 8564                        	
 8565    00:E26D  A9 FF      	.sign:		lda	#$FF
 8566    00:E26F  A8         			tay
 8567    00:E270  60         			rts
 8568                        	
 8569                        	; **************
 8570                        	; Y:A = Y:A >> X
 8571                        	
 8572    00:E271  84 00      	lsr.wx:		sty	<__temp
 8573    00:E273  E0 10      	!positive:	cpx	#16
 8574    00:E275  B0 0C      			bcs	!zero+
 8575    00:E277  CA         			dex
 8576    00:E278  30 06      			bmi	.done
 8577    00:E27A  46 00      	.loop:		lsr	<__temp
 8578    00:E27C  6A         			ror	a
 8579    00:E27D  CA         			dex
 8580    00:E27E  10 FA      			bpl	.loop
 8581    00:E280  A4 00      	.done:		ldy	<__temp
 8582    00:E282  60         			rts
 8583                        	
 8584    00:E283  62         	!zero:		cla
 8585    00:E284  C2         			cly
 8586    00:E285  60         			rts
 8587                        	
 8588                        	
 8589                        	
 8590                        	; ***************************************************************************
 8591                        	; ***************************************************************************
 8592                        	; POTENTIAL OPTIMIZATIONS, NOT YET ADDED
 8593                        	; ***************************************************************************
 8594                        	; ***************************************************************************
                             #[2]   "..\..\..\include\hucc\hucc.asm"
                             #[3]   "..\..\..\include\hucc\hucc-baselib.asm"
  227                        			include	"hucc-baselib.asm"	; HuCC base library macros.
    1                        	; ***************************************************************************
    2                        	; ***************************************************************************
    3                        	;
    4                        	; hucc-baselib.asm
    5                        	;
    6                        	; Basic library functions provided (mostly) as macros.
    7                        	;
    8                        	; Copyright John Brandwood 2024-2025.
    9                        	;
   10                        	; Distributed under the Boost Software License, Version 1.0.
   11                        	; (See accompanying file LICENSE_1_0.txt or copy at
   12                        	;  http://www.boost.org/LICENSE_1_0.txt)
   13                        	;
   14                        	; ***************************************************************************
   15                        	; ***************************************************************************
   16                        	
   17                        	
   18                        	
   19                        	; ***************************************************************************
   20                        	; ***************************************************************************
   21                        	;
   22                        	; Make certain System Card variables accessible to HuCC.
   23                        	
   24    00:E286             	_irq_cnt	.alias	irq_cnt
   25    00:E286             	_joynow		.alias	joynow
   26    00:E286             	_joytrg		.alias	joytrg
   27    00:E286             	_joy6now	.alias	joy6now
   28    00:E286             	_joy6trg	.alias	joy6trg
   29    00:E286             	_bg_x1		.alias	bg_x1
   30    00:E286             	_bg_y1		.alias	bg_y1
   31    00:E286             	_bg_x2		.alias	bg_x2
   32    00:E286             	_bg_y2		.alias	bg_y2
   33                        	
   34                        	
   35                        	
   36                        	; ***************************************************************************
   37                        	; ***************************************************************************
   38                        	;
   39                        	; void __fastcall dump_screen( void );
   40                        	;
   41                        	; THIS IS AN ILLEGAL INSTRUCTION ONLY IMPLEMENTED BY THE TGEMU EMULATOR!
   42                        	
   43    00:E286  33         	_dump_screen:	db	0x33
   44                        	
   45                        	
   46                        	
   47                        	; ***************************************************************************
   48                        	; ***************************************************************************
   49                        	;
   50                        	; void __fastcall abort( void );
   51                        	;
   52                        	; THIS IS AN ILLEGAL INSTRUCTION ONLY IMPLEMENTED BY THE TGEMU EMULATOR!
   53                        	
   54    00:E287  E2         	_abort:		db	0xE2
   55                        	
   56                        	
   57                        	
   58                        	; ***************************************************************************
   59                        	; ***************************************************************************
   60                        	;
   61                        	; void __fastcall exit( int value<acc> );
   62                        	;
   63                        	; THIS IS AN ILLEGAL INSTRUCTION ONLY IMPLEMENTED BY THE TGEMU EMULATOR!
   64                        	
   65    00:E288  AA         	_exit.1:	tax				; Put the return code into X.
   66    00:E289  63         			db	0x63
   67                        	
   68    00:E28A  80 FE      	.hang:		bra	.hang			; Hang if used in normal code.
   69                        	
   70                        	
   71                        	
   72                        	; ***************************************************************************
   73                        	; ***************************************************************************
   74                        	;
   75                        	; unsigned char __fastcall __macro cd_execoverlay( unsigned char ovl_index<acc> );
   76                        	;
   77                        	; Execute program overlay from disc
   78                        	;
   79                        	; N.B. This does not return, even if there's an error.
   80                        	
   81                        			.macro	_cd_execoverlay.1
   82                        			tax
   83                        			jmp	exec_overlay
   84                        			.endm
   85                        	
   86                        	
   87                        	
   88                        	; ***************************************************************************
   89                        	; ***************************************************************************
   90                        	;
   91                        	; void __fastcall __nop set_far_base( unsigned char data_bank<_bp_bank>, unsigned char *data_addr<_bp> );
   92                        	; void __fastcall set_far_offset( unsigned int offset<_bp>, unsigned char data_bank<_bp_bank>, unsigned char *data_addr<acc> );
   93                        	
   94    00:E28C             	_set_far_offset.3:
   95    00:E28C  18         			clc
   96    00:E28D  65 EC      			adc.l	<_bp
   97    00:E28F  85 EC      			sta.l	<_bp
   98    00:E291  98         			tya
   99    00:E292  29 1F      			and	#$1F
  100    00:E294  65 ED      			adc.h	<_bp
  101    00:E296  A8         			tay
  102    00:E297  29 1F      			and	#$1F
  103    00:E299  09 60      			ora	#$60
  104    00:E29B  85 ED      			sta.h	<_bp
  105    00:E29D  98         			tya
  106    00:E29E  6A         			ror	a
  107    00:E29F  4A         			lsr	a
  108    00:E2A0  4A         			lsr	a
  109    00:E2A1  4A         			lsr	a
  110    00:E2A2  4A         			lsr	a
  111    00:E2A3  18         			clc
  112    00:E2A4  65 02      			adc	<_bp_bank
  113    00:E2A6  85 02      			sta	<_bp_bank
  114    00:E2A8  60         			rts
  115                        	
  116                        	
  117                        	; ***************************************************************************
  118                        	; ***************************************************************************
  119                        	;
  120                        	; void __fastcall __macro reset_mpr2( void );
  121                        	; void __fastcall __macro reset_mpr34( void );
  122                        	;
  123                        	; void * __fastcall __macro set_mpr2( void __far *addr<_bp_bank:_bp> );
  124                        	; void * __fastcall __macro set_mpr34( void __far *addr<_bp_bank:_bp> );
  125                        	;
  126                        	; void * __fastcall __macro far_set_mpr2( void );
  127                        	; void * __fastcall __macro far_set_mpr34( void );
  128                        	
  129                        	_reset_mpr2	.macro
  130                        		.if	SUPPORT_SGX
  131                        			lda	#$F9
  132                        		.else
  133                        			lda	#$87
  134                        		.endif
  135                        			tam2
  136                        			.endm
  137                        	
  138                        	_reset_mpr34	.macro
  139                        			lda	#CONST_BANK + _bank_base
  140                        			tam3
  141                        			inc	a
  142                        			tam4
  143                        			.endm
  144                        	
  145                        	_farset_mpr2.1	.macro
  146                        			lda	<_bp_bank
  147                        			tam2
  148                        			lda.l	<_bp
  149                        			ldy.h	<_bp
  150                        			.endm
  151                        	
  152                        	_farset_mpr34.1	.macro
  153                        			lda	<_bp_bank
  154                        			tam3
  155                        			inc	a
  156                        			tam4
  157                        			lda.l	<_bp
  158                        			ldy.h	<_bp
  159                        			.endm
  160                        	
  161                        	_far_set_mpr2	.macro
  162                        			lda	<_bp_bank
  163                        			tam2
  164                        			lda.l	<_bp
  165                        			ldy.h	<_bp
  166                        			.endm
  167                        	
  168                        	_far_set_mpr34	.macro
  169                        			lda	<_bp_bank
  170                        			tam3
  171                        			inc	a
  172                        			tam4
  173                        			lda.l	<_bp
  174                        			ldy.h	<_bp
  175                        			.endm
  176                        	
  177                        	
  178                        	
  179                        	; ***************************************************************************
  180                        	; ***************************************************************************
  181                        	;
  182                        	; unsigned char __fastcall __macro ac_exists( void );
  183                        	
  184                        	_ac_exists	.macro
  185                        			cla
  186                        			ldy	ACD_FLAG
  187                        			cpy	#ACD_ID
  188                        			bne	!+
  189                        			inc	a
  190                        	!:		cly
  191                        			.endm
  192                        	
  193                        	
  194                        	
  195                        	; ***************************************************************************
  196                        	; ***************************************************************************
  197                        	;
  198                        	; unsigned char __fastcall __macro _sgx_detect( void );
  199                        	
  200                        	_sgx_detect	.macro
  201                        			lda	sgx_detected
  202                        			cly
  203                        			.endm
  204                        	
  205                        	
  206                        	
  207                        	; ***************************************************************************
  208                        	; ***************************************************************************
  209                        	;
  210                        	; unsigned int __fastcall __macro peek( unsigned int addr<__ptr> );
  211                        	
  212                        	_peek.1		.macro
  213                        			lda	[__ptr]
  214                        			cly
  215                        			.endm
  216                        	
  217                        	
  218                        	
  219                        	; ***************************************************************************
  220                        	; ***************************************************************************
  221                        	;
  222                        	; unsigned int __fastcall __macro peekw( unsigned int addr<__ptr> );
  223                        	
  224                        	_peekw.1	.macro
  225                        			lda	[__ptr]
  226                        			pha
  227                        			ldy	#1
  228                        			lda	[__ptr], y
  229                        			tay
  230                        			pla
  231                        			.endm
  232                        	
  233                        	
  234                        	
  235                        	; ***************************************************************************
  236                        	; ***************************************************************************
  237                        	;
  238                        	; void __fastcall __macro poke( unsigned int addr<__poke>, unsigned char with<acc> );
  239                        	;
  240                        	; N.B. Because the <acc> value can be a complex C calculation, it isn't safe
  241                        	; to use __ptr as the destination, which can be overwritten in C macros.
  242                        	
  243                        	_poke.2		.macro
  244                        			sta	[__poke]
  245                        			.endm
  246                        	
  247                        	
  248                        	
  249                        	; ***************************************************************************
  250                        	; ***************************************************************************
  251                        	;
  252                        	; void __fastcall __macro pokew( unsigned int addr<__poke>, unsigned int with<acc> );
  253                        	;
  254                        	; N.B. Because the <acc> value can be a complex C calculation, it isn't safe
  255                        	; to use __ptr as the destination, which can be overwritten in C macros.
  256                        	
  257                        	_pokew.2	.macro
  258                        			sta	[__poke]
  259                        			tya
  260                        			ldy	#1
  261                        			sta	[__poke], y
  262                        			.endm
  263                        	
  264                        	
  265                        	
  266                        	; ***************************************************************************
  267                        	; ***************************************************************************
  268                        	;
  269                        	; unsigned char __fastcall __macro clock_hh( void );
  270                        	
  271                        	_clock_hh	.macro
  272                        			lda	clock_hh
  273                        			cly
  274                        			.endm
  275                        	
  276                        	
  277                        	
  278                        	; ***************************************************************************
  279                        	; ***************************************************************************
  280                        	;
  281                        	; unsigned char __fastcall __macro clock_mm( void );
  282                        	
  283                        	_clock_mm	.macro
  284                        			lda	clock_mm
  285                        			cly
  286                        			.endm
  287                        	
  288                        	
  289                        	
  290                        	; ***************************************************************************
  291                        	; ***************************************************************************
  292                        	;
  293                        	; unsigned char __fastcall __macro clock_ss( void );
  294                        	
  295                        	_clock_ss	.macro
  296                        			lda	clock_ss
  297                        			cly
  298                        			.endm
  299                        	
  300                        	
  301                        	
  302                        	; ***************************************************************************
  303                        	; ***************************************************************************
  304                        	;
  305                        	; unsigned char __fastcall __macro clock_tt( void );
  306                        	
  307                        	_clock_tt	.macro
  308                        			lda	clock_tt
  309                        			cly
  310                        			.endm
  311                        	
  312                        	
  313                        	
  314                        	; ***************************************************************************
  315                        	; ***************************************************************************
  316                        	;
  317                        	; void __fastcall __macro clock_reset( void );
  318                        	
  319                        	_clock_reset	.macro
  320                        			stz	clock_hh
  321                        			stz	clock_mm
  322                        			stz	clock_ss
  323                        			stz	clock_tt
  324                        			.endm
  325                        	
  326                        	
  327                        	
  328                        	; ***************************************************************************
  329                        	; ***************************************************************************
  330                        	;
  331                        	; unsigned int __fastcall __macro joy( unsigned char which<acc> );
  332                        	
  333                        	_joy.1		.macro
  334                        			tax
  335                        			lda	joynow, x
  336                        		.if	SUPPORT_6BUTTON
  337                        			ldy	joy6now, x
  338                        		.else
  339                        			cly
  340                        		.endif
  341                        			.endm
  342                        	
  343                        	
  344                        	
  345                        	; ***************************************************************************
  346                        	; ***************************************************************************
  347                        	;
  348                        	; unsigned int __fastcall __macro joytrg( unsigned char which<acc> );
  349                        	
  350                        	_joytrg.1	.macro
  351                        			tax
  352                        			lda	joytrg, x
  353                        		.if	SUPPORT_6BUTTON
  354                        			ldy	joy6trg, x
  355                        		.else
  356                        			cly
  357                        		.endif
  358                        			.endm
  359                        	
  360                        	
  361                        	
  362                        	; ***************************************************************************
  363                        	; ***************************************************************************
  364                        	;
  365                        	; unsigned int __fastcall __macro joybuf( unsigned char which<acc> );
  366                        	
  367                        	_joybuf.1	.macro
  368                        		.if	HUC_JOY_EVENTS
  369                        			tax
  370                        			lda	joybuf, x
  371                        		.if	SUPPORT_6BUTTON
  372                        			ldy	joy6buf, x
  373                        		.else
  374                        			cly
  375                        		.endif
  376                        		.else
  377                        			.fail	You must enable HUC_JOY_EVENTS in your hucc-config.inc!
  378                        		.endif
  379                        			.endm
  380                        	
  381                        	
  382                        	
  383                        	; ***************************************************************************
  384                        	; ***************************************************************************
  385                        	;
  386                        	; unsigned int __fastcall __macro get_joy_events( unsigned char which<acc> );
  387                        	;
  388                        	; N.B. This is just a version of joybuf() that clears the accumulated events.
  389                        	
  390                        			.macro	_get_joy_events.1
  391                        		.if	HUC_JOY_EVENTS
  392                        			tax
  393                        			lda	joybuf, x
  394                        			stz	joybuf, x
  395                        		.if	SUPPORT_6BUTTON
  396                        			ldy	joy6buf, x
  397                        			stz	joy6buf, x
  398                        		.else
  399                        			cly
  400                        		.endif
  401                        		.else
  402                        		.if	ACCUMULATE_JOY
  403                        			tax
  404                        			lda	joytrg, x
  405                        			stz	joytrg, x
  406                        		.if	SUPPORT_6BUTTON
  407                        			ldy	joy6trg, x
  408                        			stz	joy6trg, x
  409                        		.else
  410                        			cly
  411                        		.endif
  412                        		.else
  413                        			.fail	You must enable HUC_JOY_EVENTS or ACCUMULATE_JOY in your hucc-config.inc!
  414                        		.endif
  415                        		.endif
  416                        			.endm
  417                        	
  418                        	
  419                        	
  420                        	; ***************************************************************************
  421                        	; ***************************************************************************
  422                        	;
  423                        	; void __fastcall __macro clear_joy_events( unsigned char mask<acc> );
  424                        	
  425                        			.macro	_clear_joy_events.1
  426                        			php
  427                        			sei
  428                        			and	#(1 << MAX_PADS) - 1
  429                        			ldx	#$FF
  430                        	.loop:		inx
  431                        			lsr	a
  432                        			bcc	.next
  433                        		.if	HUC_JOY_EVENTS
  434                        			stz	joybuf, x
  435                        		.if	SUPPORT_6BUTTON
  436                        			stz	joy6buf, x
  437                        		.endif
  438                        		.else
  439                        		.if	ACCUMULATE_JOY
  440                        			stz	joytrg, x
  441                        		.if	SUPPORT_6BUTTON
  442                        			stz	joy6trg, x
  443                        		.endif
  444                        		.else
  445                        			.fail	You must enable HUC_JOY_EVENTS or ACCUMULATE_JOY in your hucc-config.inc!
  446                        		.endif
  447                        		.endif
  448                        	.next:		bne	.loop
  449                        			plp
  450                        			.endm
  451                        	
  452                        	
  453                        	
  454                        	; ***************************************************************************
  455                        	; ***************************************************************************
  456                        	;
  457                        	; void __fastcall srand( unsigned char seed<acc> );
  458                        	
  459               0001     		.ifndef	HUCC_NO_DEFAULT_RANDOM
  460                        	_srand.1	.macro
  461                        			tay
  462                        			jsr	init_random
  463                        			.endm
  464                        		.endif
  465                        	
  466                        	
  467                        	
  468                        	; ***************************************************************************
  469                        	; ***************************************************************************
  470                        	;
  471                        	; unsigned int __fastcall rand( void );
  472                        	; unsigned char __fastcall rand8( void );
  473                        	
  474               0001     		.ifndef	HUCC_NO_DEFAULT_RANDOM
  475    00:E2A9  20 C3 E5   	_rand:		jsr	get_random		; Random in A, preserve Y.
  476    00:E2AC  A8         			tay
  477    00:E2AD  4C C3 E5   			jmp	get_random		; Random in A, preserve Y.
  478                        		.endif
  479                        	
  480                        	
  481                        	
  482                        	; ***************************************************************************
  483                        	; ***************************************************************************
  484                        	;
  485                        	; unsigned char __fastcall random8( unsigned char limit<acc> );
  486                        	;
  487                        	; IN :	A = range (0..255)
  488                        	; OUT : A = random number interval 0 <= x < A
  489                        	
  490               0001     		.ifndef	HUCC_NO_DEFAULT_RANDOM
  491                        	
  492    00:E2B0  A8         	_random8.1:	tay				; Preserve the limit.
  493    00:E2B1  20 C3 E5   			jsr	get_random		; Random in A, preserve Y.
  494                        	
  495    00:E2B4  20 F0 E4   			jsr	__muluchar
  496    00:E2B7  98         			tya				; Do a 8.0 x 0.8 fixed point
  497    00:E2B8  C2         			cly				; fractional multiply.
  498    00:E2B9  60         			rts
  499                        		.endif
  500                        	
  501                        	
  502                        	
  503                        	; ***************************************************************************
  504                        	; ***************************************************************************
  505                        	;
  506                        	; unsigned char __fastcall random( unsigned char limit<acc> );
  507                        	;
  508                        	; IN :	A = range (0..128), 129..255 is treated as 128
  509                        	; OUT : A = random number interval 0 <= x < A
  510                        	
  511               0001     		.ifndef	HUCC_NO_DEFAULT_RANDOM
  512                        	
  513    00:E2BA  A8         	_random.1:	tay				; Preserve the limit.
  514    00:E2BB  20 C3 E5   			jsr	get_random		; Random in A, preserve Y.
  515                        	
  516    00:E2BE  C0 80      			cpy	#128			; Check the limit.
  517    00:E2C0  90 04      			bcc	!+
  518                        	
  519    00:E2C2  29 7F      			and	#$7F			; Just mask the random if
  520    00:E2C4  C2         			cly				; the limit is >= 128.
  521    00:E2C5  60         			rts
  522                        	
  523    00:E2C6  20 F0 E4   	!:		jsr	__muluchar
  524    00:E2C9  98         			tya				; If the limit is < 128 then
  525    00:E2CA  C2         			cly				; do a 8.0 x 0.8 fixed point
  526    00:E2CB  60         			rts				; fractional multiply.
  527                        		.endif
  528                        	
  529                        	
  530                        	
  531                        	; ***************************************************************************
  532                        	; ***************************************************************************
  533                        	;
  534                        	; unsigned char __fastcall __builtin_ffs( unsigned int value<__temp> );
  535                        	
  536                        			.proc	___builtin_ffs.1
  556                        			.endp
  557                        	
  558                        	
  559                        	
  560                        	; ***************************************************************************
  561                        	; ***************************************************************************
  562                        	;
  563                        	; N.B. Declared in hucc-string.h, but defined here because they're macros!
  564                        	;
  565                        	; int __fastcall __macro memcmp( unsigned char *destination<_di>, unsigned char *source<_bp>, unsigned int count<acc> );
  566                        	
  567                        	_memcmp.3	.macro
  568                        			stz	<_bp_bank		; Map the source string.
  569                        			call	_farmemcmp.3
  570                        			.endm
  571                        	
  572                        	
  573                        	
  574                        	; ***************************************************************************
  575                        	; ***************************************************************************
  576                        	;
  577                        	; N.B. Declared in hucc-gfx.h, but defined here because they're macros!
  578                        	;
  579                        	; void __fastcall __macro get_color( unsigned int index<VCE_CTA> );
  580                        	
  581                        	_get_color.1	.macro
  582                        			lda.l	VCE_CTR
  583                        			ldy.h	VCE_CTR
  584                        			.endm
  585                        	
  586                        	
  587                        	
  588                        	; ***************************************************************************
  589                        	; ***************************************************************************
  590                        	;
  591                        	; N.B. Declared in hucc-gfx.h, but defined here because they're macros!
  592                        	;
  593                        	; void __fastcall __macro fade_to_black( unsigned int __far *from<_bp_bank:_bp>, unsigned int *destination<_di>, unsigned char num_colors<_al>, unsigned char value_to_sub<_ah> );
  594                        	; void __fastcall __macro fade_to_white( unsigned int __far *from<_bp_bank:_bp>, unsigned int *destination<_di>, unsigned char num_colors<_al>, unsigned char value_to_add<_ah> );
  595                        	; void __fastcall __macro cross_fade_to( unsigned int __far *from<_bp_bank:_bp>, unsigned int *destination<_di>, unsigned char num_colors<_al>, unsigned char which_component<_ah );
  596                        	;
  597                        	; void __fastcall __macro far_fade_to_black( unsigned int *destination<_di>, unsigned char num_colors<_al>, unsigned char value_to_sub<_ah> );
  598                        	; void __fastcall __macro far_fade_to_white( unsigned int *destination<_di>, unsigned char num_colors<_al>, unsigned char value_to_add<_ah> );
  599                        	; void __fastcall __macro far_cross_fade_to( unsigned int *destination<_di>, unsigned char num_colors<_al>, unsigned char which_component<_ah );
  600                        	
  601                        			.macro	_fade_to_black.4
  602                        			ldy	<_bp_bank
  603                        			call	fade_to_black
  604                        			.endm
  605                        	
  606                        			.macro	_fade_to_white.4
  607                        			ldy	<_bp_bank
  608                        			call	fade_to_white
  609                        			.endm
  610                        	
  611                        			.macro	_cross_fade_to.4
  612                        			ldy	<_bp_bank
  613                        			call	cross_fade_to
  614                        			.endm
  615                        	
  616                        			.macro	_far_fade_to_black.3
  617                        			ldy	<_bp_bank
  618                        			call	fade_to_black
  619                        			.endm
  620                        	
  621                        			.macro	_far_fade_to_white.3
  622                        			ldy	<_bp_bank
  623                        			call	fade_to_white
  624                        			.endm
  625                        	
  626                        			.macro	_far_cross_fade_to.3
  627                        			ldy	<_bp_bank
  628                        			call	cross_fade_to
  629                        			.endm
  630                        	
  631                        	
  632                        	
  633                        	; ***************************************************************************
  634                        	; ***************************************************************************
  635                        	;
  636                        	; N.B. Declared in hucc-gfx.h, but defined here because they're macros!
  637                        	;
  638                        	; void __fastcall __macro set_xres( unsigned int x_pixels<_ax> );
  639                        	; void __fastcall __macro sgx_set_xres( unsigned int x_pixels<_ax> );
  640                        	;
  641                        	; void __fastcall set_xres( unsigned int x_pixels<_ax>, unsigned char blur_flag<_bl> );
  642                        	; void __fastcall sgx_set_xres( unsigned int x_pixels<_ax>, unsigned char blur_flag<_bl> );
  643                        	
  644                        	_set_xres.1	.macro
  645                        			lda	#XRES_SOFT
  646                        			sta	<_bl
  647                        			call	_set_xres.2
  648                        			.endm
  649                        	
  650               0001     		.if	SUPPORT_SGX
  651                        			.macro	_sgx_set_xres.1
  652                        			lda	#XRES_SOFT
  653                        			sta	<_bl
  654                        			call	_sgx_set_xres.2
  655                        			.endm
  656                        		.endif
  657                        	
  658                        	
  659                        	
  660                        	; ***************************************************************************
  661                        	; ***************************************************************************
  662                        	;
  663                        	; N.B. Declared in hucc-gfx.h, but defined here because they're macros!
  664                        	;
  665                        	; unsigned int __fastcall __macro vram_addr( unsigned char bat_x<_al>, unsigned char bat_y<_ah> );
  666                        	; unsigned int __fastcall __macro sgx_vram_addr( unsigned char bat_x<_al>, unsigned char bat_y<_ah> );
  667                        	
  668                        			.macro	_vram_addr.2
  669                        			cla
  670                        			bit	vdc_bat_width
  671                        			bmi	!w128+
  672                        			bvs	!w64+
  673                        	!w32:		lsr	<_ah
  674                        			ror	a
  675                        	!w64:		lsr	<_ah
  676                        			ror	a
  677                        	!w128:		lsr	<_ah
  678                        			ror	a
  679                        			ora	<_al
  680                        			ldy	<_ah
  681                        			.endm
  682                        	
  683               0001     		.if	SUPPORT_SGX
  684                        			.macro	_sgx_vram_addr.2
  685                        			cla
  686                        			bit	sgx_bat_width
  687                        			bmi	!w128+
  688                        			bvs	!w64+
  689                        	!w32:		lsr	<_ah
  690                        			ror	a
  691                        	!w64:		lsr	<_ah
  692                        			ror	a
  693                        	!w128:		lsr	<_ah
  694                        			ror	a
  695                        			ora	<_al
  696                        			ldy	<_ah
  697                        			.endm
  698                        		.endif
  699                        	
  700                        	
  701                        	
  702                        	; ***************************************************************************
  703                        	; ***************************************************************************
  704                        	;
  705                        	; N.B. Declared in hucc-gfx.h, but defined here because they're macros!
  706                        	;
  707                        	; unsigned int __fastcall __macro get_vram( unsigned int address<_di> );
  708                        	; void __fastcall __macro put_vram( unsigned int address<_di>, unsigned int data<acc> );
  709                        	;
  710                        	; unsigned int __fastcall __macro sgx_get_vram( unsigned int address<_di> );
  711                        	; void __fastcall __macro sgx_put_vram( unsigned int address<_di>, unsigned int data<acc> );
  712                        	
  713                        			.macro	_get_vram.1
  714                        			jsr	vdc_di_to_marr
  715                        			lda	VDC_DL
  716                        			ldy	VDC_DH
  717                        			.endm
  718                        	
  719                        			.macro	_put_vram.2
  720                        			pha
  721                        			jsr	vdc_di_to_mawr
  722                        			pla
  723                        			sta	VDC_DL
  724                        			sty	VDC_DH
  725                        			.endm
  726                        	
  727               0001     		.if	SUPPORT_SGX
  728                        			.macro	_sgx_get_vram.1
  729                        			jsr	sgx_di_to_marr
  730                        			lda	SGX_DL
  731                        			ldy	SGX_DH
  732                        			.endm
  733                        	
  734                        			.macro	_sgx_put_vram.2
  735                        			pha
  736                        			jsr	sgx_di_to_mawr
  737                        			pla
  738                        			sta	SGX_DL
  739                        			sty	SGX_DH
  740                        			.endm
  741                        		.endif
  742                        	
  743                        	
  744                        	
  745                        	; ***************************************************************************
  746                        	; ***************************************************************************
  747                        	;
  748                        	; N.B. Declared in hucc-gfx.h, but defined here because they're macros!
  749                        	;
  750                        	; void __fastcall __macro set_bgpal( unsigned char palette<_al>, unsigned char __far *data<_bp_bank:_bp> );
  751                        	; void __fastcall __macro set_bgpal( unsigned char palette<_al>, unsigned char __far *data<_bp_bank:_bp>, unsigned int num_palettes<_ah> );
  752                        	; void __fastcall __macro set_sprpal( unsigned char palette<_al>, unsigned char __far *data<_bp_bank:_bp> );
  753                        	; void __fastcall __macro set_sprpal( unsigned char palette<_al>, unsigned char __far *data<_bp_bank:_bp>, unsigned int num_palettes<_ah> );
  754                        	
  755                        	_set_bgpal.2	.macro
  756                        			lda	#1
  757                        			sta	<_ah
  758                        			call	_load_palette.3
  759                        			.endm
  760                        	
  761                        	_set_bgpal.3	.macro
  762                        			call	_load_palette.3
  763                        			.endm
  764                        	
  765                        	_set_sprpal.2	.macro
  766                        			lda	#1
  767                        			sta	<_ah
  768                        			smb4	<_al
  769                        			call	_load_palette.3
  770                        			.endm
  771                        	
  772                        	_set_sprpal.3	.macro
  773                        			smb4	<_al
  774                        			call	_load_palette.3
  775                        			.endm
  776                        	
  777                        	
  778                        	
  779                        	; ***************************************************************************
  780                        	; ***************************************************************************
  781                        	;
  782                        	; N.B. Declared in hucc-gfx.h, but defined here because they're macros!
  783                        	;
  784                        	; void __fastcall __macro load_vram( unsigned int vram<_di>, unsigned char __far *data<_bp_bank:_bp>, unsigned int num_words<_ax> );
  785                        	; void __fastcall __macro sgx_load_vram( unsigned int vram<_di>, unsigned char __far *data<_bp_bank:_bp>, unsigned int num_words<_ax> );
  786                        	;
  787                        	; void __fastcall __macro far_load_vram( unsigned int vram<_di>, unsigned int num_words<_ax> );
  788                        	; void __fastcall __macro sgx_far_load_vram( unsigned int vram<_di>, unsigned int num_words<_ax> );
  789                        	;
  790                        	
  791               0001     		.if	SUPPORT_SGX
  792                        			.macro	_sgx_load_vram.3
  793                        			ldx	#SGX_VDC_OFFSET		; Offset to SGX VDC.
  794                        			call	load_vram_x
  795                        			.endm
  796                        	
  797                        			.macro	_sgx_far_load_vram.2
  798                        			ldx	#SGX_VDC_OFFSET		; Offset to SGX VDC.
  799                        			call	load_vram_x
  800                        			.endm
  801                        		.endif
  802                        	
  803                        			.macro	_load_vram.3
  804                        			clx				; Offset to PCE VDC.
  805                        			call	load_vram_x
  806                        			.endm
  807                        	
  808                        			.macro	_far_load_vram.2
  809                        			clx				; Offset to PCE VDC.
  810                        			call	load_vram_x
  811                        			.endm
  812                        	
  813                        	
  814                        	
  815                        	; ***************************************************************************
  816                        	; ***************************************************************************
  817                        	;
  818                        	; N.B. Declared in hucc-gfx.h, but defined here because they're macros!
  819                        	;
  820                        	; void __fastcall __macro load_sprites( unsigned int vram<_di>, unsigned char __far *data<_bp_bank:_bp>, unsigned int num_groups<acc> );
  821                        	; void __fastcall __macro sgx_load_sprites( unsigned int vram<_di>, unsigned char __far *data<_bp_bank:_bp>, unsigned int num_groups<acc> );
  822                        	; void __fastcall __macro far_load_sprites( unsigned int vram<_di>, unsigned int num_groups<acc> );
  823                        	; void __fastcall __macro sgx_far_load_sprites( unsigned int vram<_di>, unsigned int num_groups<acc> );
  824                        	
  825               0001     		.if	SUPPORT_SGX
  826                        			.macro	_sgx_load_sprites.3
  827                        			stz.l	<_ax
  828                        			asl	a
  829                        			sta.h	<_ax
  830                        			ldx	#SGX_VDC_OFFSET		; Offset to SGX VDC.
  831                        			call	load_vram_x
  832                        			.endm
  833                        	
  834                        			.macro	_sgx_far_load_sprites.2
  835                        			stz.l	<_ax
  836                        			asl	a
  837                        			sta.h	<_ax
  838                        			ldx	#SGX_VDC_OFFSET		; Offset to SGX VDC.
  839                        			call	load_vram_x
  840                        			.endm
  841                        		.endif
  842                        	
  843                        			.macro	_load_sprites.3
  844                        			stz.l	<_ax
  845                        			asl	a
  846                        			sta.h	<_ax
  847                        			clx				; Offset to PCE VDC.
  848                        			call	load_vram_x
  849                        			.endm
  850                        	
  851                        			.macro	_far_load_sprites.2
  852                        			stz.l	<_ax
  853                        			asl	a
  854                        			sta.h	<_ax
  855                        			clx				; Offset to PCE VDC.
  856                        			call	load_vram_x
  857                        			.endm
  858                        	
  859                        	
  860                        	
  861                        	; ***************************************************************************
  862                        	; ***************************************************************************
  863                        	;
  864                        	; N.B. Declared in hucc-gfx.h, but defined here because they're macros!
  865                        	;
  866                        	; void __fastcall load_default_font( void );
  867                        	; void __fastcall sgx_load_default_font( void );
  868                        	;
  869                        	
  870               0001     		.if	SUPPORT_SGX
  871                        			.macro	_sgx_load_default_font
  872                        			ldx	#SGX_VDC_OFFSET		; Offset to SGX VDC.
  873                        			call	huc_monofont_x
  874                        			.endm
  875                        		.endif
  876                        	
  877                        			.macro	_load_default_font
  878                        			clx				; Offset to PCE VDC.
  879                        			call	huc_monofont_x
  880                        			.endm
  881                        	
  882                        	
  883                        	
  884                        	; ***************************************************************************
  885                        	; ***************************************************************************
  886                        	
  887               0000     		.if	0
  905                        		.endif
                             #[2]   "..\..\..\include\hucc\hucc.asm"
  228                        	
  229               0000     		.if	CDROM
  231                        		.endif
  232                        	
  233                        			; Definitions for compatibility with old HuC/MagicKit projects.
  234                        	
  235               0001     		.ifndef	HUCC_NO_DEPRECATED
                             #[3]   "..\..\..\include\hucc\hucc-deprecated.inc"
  236                        			include	"hucc-deprecated.inc"
    1                        	; ***************************************************************************
    2                        	; ***************************************************************************
    3                        	;
    4                        	; hucc-deprecated.inc
    5                        	;
    6                        	; Macros and definitions for compatibility with old HuC/MagicKit projects.
    7                        	;
    8                        	; Based on the original HuC and MagicKit definitions by David Michel and the
    9                        	; other original HuC developers.
   10                        	;
   11                        	; ***************************************************************************
   12                        	; ***************************************************************************
   13                        	
   14                        			; For compatibility with HuC projects that use the old name.
   15                        	
   16               0001     	HUC_USER_RESERVED = HUC_USER_BANK
   17                        	
   18                        			; For compatibility with code that expects the HuC naming that
   19                        			; is used in the newer HuC, rather than the original HuC v3.21.
   20                        			;
   21                        			; Code generated by HuCC uses the original single-underscore.
   22                        	
   23               0001     		.if	1				
   24               0002     	__bp		=	$F8:20EC, 2		; base pointer
   25               0002     	__si		=	$F8:20EE, 2		; source address
   26               0002     	__di		=	$F8:20F0, 2		; destination address
   27                        	
   28               0002     	__ax		=	$F8:20F8, 2
   29               0001     	__al		=	$F8:20F8, 1
   30               0001     	__ah		=	$F8:20F9, 1
   31                        	
   32               0002     	__bx		=	$F8:20FA, 2
   33               0001     	__bl		=	$F8:20FA, 1
   34               0001     	__bh		=	$F8:20FB, 1
   35                        	
   36               0002     	__cx		=	$F8:20FC, 2
   37               0001     	__cl		=	$F8:20FC, 1
   38               0001     	__ch		=	$F8:20FD, 1
   39                        	
   40               0002     	__dx		=	$F8:20FE, 2
   41               0001     	__dl		=	$F8:20FE, 1
   42               0001     	__dh		=	$F8:20FF, 1
   43                        		.endif
   44                        	
   45                        			; For compatibility with code that expects the HuC naming that
   46                        			; is used rather than the shorter upper-case #define naming.
   47                        	
   48               0001     		.if	1				
   49               0001     	video_reg	=	$FF:0200, 1		; Address/Status Register
   50               0001     	video_reg_l	=	$FF:0200, 1		; Address/Status Register
   51               0001     	video_reg_h	=	$FF:0201, 1		; Address/Status Register
   52               0002     	video_data	=	$FF:0202, 2		; Data (Read/Write) Low
   53               0001     	video_data_l	=	$FF:0202, 1		; Data (Read/Write) Low
   54               0001     	video_data_h	=	$FF:0203, 1		; Data (Read/Write) High
   55                        	
   56               0002     	color_ctrl	=	$FF:0400, 2		; Control Register
   57               0002     	color_reg	=	$FF:0402, 2		; Color Table Address
   58               0001     	color_reg_l	=	$FF:0402, 1		; Color Table Address
   59               0001     	color_reg_h	=	$FF:0402, 1		; Color Table Address
   60               0002     	color_data	=	$FF:0404, 2		; Color Table Data Read/Write
   61               0001     	color_data_l	=	$FF:0404, 1		; Color Table Data Read/Write
   62               0001     	color_data_h	=	$FF:0405, 1		; Color Table Data Read/Write
   63                        	
   64               0001     	psg_ch		=	$FF:0800, 1		; Channel Select
   65               0001     	psg_mainvol	=	$FF:0801, 1		; Main Amplitude Level
   66               0001     	psg_freqlo	=	$FF:0802, 1		; Frequency Low
   67               0001     	psg_freqhi	=	$FF:0803, 1		; Frequency High
   68               0001     	psg_ctrl	=	$FF:0804, 1		; Control & Channel Amplitude
   69               0001     	psg_pan		=	$FF:0805, 1		; L/R Amplitude Level
   70               0001     	psg_wavebuf	=	$FF:0806, 1		; Waveform
   71               0001     	psg_noise	=	$FF:0807, 1		; Noise
   72               0001     	psg_lfofreq	=	$FF:0808, 1		; LFO Frequency
   73               0001     	psg_lfoctrl	=	$FF:0809, 1		; LFO Control
   74                        	
   75               0001     	irq_m		=	irq_vec, 1		; Old System Card name.
   76               0002     	irq2_jmp	=	irq2_hook, 2		; Old System Card name.
   77               0002     	irq1_jmp	=	irq1_hook, 2		; Old System Card name.
   78               0002     	timer_jmp	=	timer_hook, 2		; Old System Card name.
   79               0002     	nmi_jmp		=	nmi_hook, 2		; Old System Card name.
   80               0002     	sat_adr		=	satb_addr, 2		; Old System Card name.
   81               0005     	joy		=	joynow, 5		; Old System Card name.
   82               0001     	mwr_m		=	vdc_mwr, 1		; Old System Card name.
   83               0001     	dcr_m		=	vdc_dcr, 1		; Old System Card name.
   84                        		.endif
   85                        	
   86                        			; Macros for compatibility with #asm usage in old HuC projects.
   87                        	
   88                        	stw		.macro
   89                        			lda.l	\1
   90                        			sta.l	\2
   91                        			lda.h	\1
   92                        			sta.h	\2
   93                        			.endm
   94                        	
   95                        	stb		.macro
   96                        			lda	\1
   97                        			sta	\2
   98                        			.endm
   99                        	
  100                        	addw		.macro
  101                        		.if	(\# = 3)
  102                        			clc
  103                        			lda.l	\2
  104                        			adc.l	\1
  105                        			sta.l	\3
  106                        			lda.h	\2
  107                        			adc.h	\1
  108                        			sta.h	\3
  109                        		.else
  110                        			clc
  111                        			lda.l	\2
  112                        			adc.l	\1
  113                        			sta.l	\2
  114                        			lda.h	\2
  115                        			adc.h	\1
  116                        			sta.h	\2
  117                        		.endif
  118                        			.endm
  119                        	
  120                        	add		.macro			; add byte-sized value to
  121                        		.if (\# = 2)			; register A (handle carry
  122                        			lda	\2		; flag)
  123                        			clc
  124                        			adc	\1
  125                        			sta	\2
  126                        		.else
  127                        			clc
  128                        			adc	\1
  129                        		.endif
  130                        			.endm
  131                        	
  132                        	subw		.macro
  133                        			sec
  134                        			lda.l	\2
  135                        			sbc.l	\1
  136                        			sta.l	\2
  137                        			lda.h	\2
  138                        			sbc.h	\1
  139                        			sta.h	\2
  140                        			.endm
  141                        	
  142                        	sub		.macro			; subtract byte-sized value
  143                        		.if (\# = 2)			; from register A (handle
  144                        			lda	\2		; carry flag)
  145                        			sec
  146                        			sbc	\1
  147                        			sta	\2
  148                        		.else
  149                        			sec
  150                        			sbc	\1
  151                        		.endif
  152                        			.endm
  153                        	
  154                        	incw		.macro			; increment a word-sized
  155                        			inc.l	\1		; value at stated memory
  156                        			bne	!+		; location
  157                        			inc.h	\1
  158                        	!:
  159                        			.endm
  160                        	
  161                        	decw		.macro			; decrement a word-sized
  162                        			lda	\1		; value at stated memory
  163                        			bne	!+		; location
  164                        			dec.h	\1
  165                        	!:		dec.l	\1
  166                        			.endm
  167                        	
  168                        	lbne		.macro
  169                        			bne	\1
  170                        			.endm
  171                        	
  172                        	lbeq		.macro
  173                        			beq	\1
  174                        			.endm
  175                        	
  176                        	lbpl		.macro
  177                        			bpl	\1
  178                        			.endm
  179                        	
  180                        	lbmi		.macro
  181                        			bmi	\1
  182                        			.endm
  183                        	
  184                        	lbcc		.macro
  185                        			bcc	\1
  186                        			.endm
  187                        	
  188                        	lbcs		.macro
  189                        			bcs	\1
  190                        			.endm
  191                        	
  192                        	lblo		.macro
  193                        			bcc	\1
  194                        			.endm
  195                        	
  196                        	lbhs		.macro
  197                        			bcs	\1
  198                        			.endm
  199                        	
  200                        	__ldwi		.macro
  201                        		__ld.wi		\1
  202                        			.endm
                             #[2]   "..\..\..\include\hucc\hucc.asm"
  237                        		.endif
  238                        	
  239                        			;
  240                        			;
  241                        			;
  242                        	
  243                        	
  244                        	
  245                        	; ***************************************************************************
  246                        	; ***************************************************************************
  247                        	;
  248                        	; core_main - This is executed after "CORE(not TM)" library initialization.
  249                        	;
  250                        	; This is the first code assembled after the library includes, so we're still
  251                        	; in the CORE_BANK, usually ".bank 0"; and because this is assembled with the
  252                        	; default configuration from "include/core-config.inc", which sets the option
  253                        	; "USING_MPR7", then we're running in MPR7 ($E000-$FFFF).
  254                        	
  255    0D:DCD6             	core_main	.proc
  256                        	
  257               0001     		.if	SUPPORT_SGX
  258    0D:DCD6  A9 F9      			lda	#$F9			; Map the 2nd SGX RAM bank.
  259                        		.else
  261                        		.endif
  262    0D:DCD8  53 04      			tam2
  263                        	
  264    0D:DCDA  A9 01      			lda	#CONST_BANK + _bank_base; Map HuCC's .RODATA bank.
  265    0D:DCDC  53 08      			tam3
  266    0D:DCDE  1A         			inc	a
  267    0D:DCDF  53 10      			tam4
  268                        	
  269               0000     		.ifdef	HOME_BANK
  271                        		.else
  272    0D:DCE1  1A         			inc	a
  273                        		.endif
  274    0D:DCE2  53 20      			tam5
  275                        	
  276    0D:DCE4  08         			php				; Disable interrupts while
  277    0D:DCE5  78         			sei				; clearing overlay's BSS.
  278                        	
  279               0000     		.ifndef	USING_RCR_MACROS
  294                        		.endif	USING_RCR_MACROS
  295                        	
  296    0D:DCE6  A9 CC      			lda	#<hucc_vbl		; Setup HuCC's VBL IRQ handler.
  297    0D:DCE8  8D 08 22   			sta.l	vsync_hook
  298    0D:DCEB  A9 E2      			lda	#>hucc_vbl
  299    0D:DCED  8D 09 22   			sta.h	vsync_hook
  300                        	
  301               0000     		.if	CDROM				; Overlays should clear BSS.
  303                        		.else
  304    0D:DCF0  73 3D DD F0			tii	.rom_tia, ram_tia, 16	; Only needed on HuCARD.
         0D:DCF4  22 10 00    
  305                        		.endif	CDROM
  306                        	
  307               0000     		.if	(__heap_start - __bss_init)	; Copy initialized BSS data.
  309                        		.endif
  310                        	
  311    0D:DCF7  F3 3B DD 08			tai	.stack_fill, __stack, HUCC_STACK_SZ
         0D:DCFB  20 80 00    
  312                        	
  313               0000     		.if	FAST_MULTIPLY
  322                        		.endif
  323                        	
  324    0D:DCFE  A9 10      			lda	#$10			; Enable HuCC's vblank IRQ
  325    0D:DD00  04 F5      			tsb	<irq_vec		; handler.
  326                        	
  327                        			__sound_init			; Initialize a sound driver.
  328                        	
  329    0D:DD02  AD 00 02   			lda	VDC_SR			; Purge any overdue VBL.
  330    0D:DD05  9C 41 22   			stz	irq_cnt			; Make it easy to check.
  331                        	
  332    0D:DD08  28         			plp				; Restore interrupts.
  333                        	
  334               0001     		.ifndef	HUCC_NO_DEFAULT_SCREEN
  335    0D:DD09  20 D1 FF   			call	_init_256x224		; HuCC initializes the VDC and
  336    0D:DD0C  20 16 E4   			jsr	set_dspon		; turns the display on.
  337                        		.endif
  338                        	
  339               0001     		.ifndef	HUCC_NO_DEFAULT_FONT
  340    0D:DD0F  A9 01      			lda	#1			; HuCC loads a default font.
  341    0D:DD11  8D E5 24   			sta	monofont_fg
  342    0D:DD14  9C E6 24   			stz	monofont_bg
  343                        			_load_default_font
         0D:DD17  82         			clx				; Offset to PCE VDC.
         0D:DD18  20 C7 FF   			call	huc_monofont_x
  344    0D:DD1B  A9 01      			lda	#$01			; Set the font palette entry to
  345    0D:DD1D  8D 02 04   			sta.l	VCE_CTA			; cyan which is a) visible, but
  346    0D:DD20  9C 03 04   			stz.h	VCE_CTA			; b) a clear indicator that the
  347    0D:DD23  A0 96      			ldy	#$96			; user hasn't set a palette yet.
  348    0D:DD25  8C 04 04   			sty.l	VCE_CTW
  349    0D:DD28  8D 05 04   			sta.h	VCE_CTW
  350                        		.endif
  351                        	
  352               0001     		.ifndef	HUCC_NO_DEFAULT_RANDOM
  353    0D:DD2B  AC 41 22   			ldy	irq_cnt			; Initialize random seed.
  354    0D:DD2E  20 BD FF   			call	init_random
  355                        		.endif
  356                        	
  357    0D:DD31  A2 80      			ldx	#HUCC_STACK_SZ		; Initialize the HuCC stack.
  358    0D:DD33  86 8D      			stx	<__sp
  359                        	
  360    0D:DD35  20 B3 FF   			call	_main			; Execute the HuCC program.
  361                        	
  362    0D:DD38  4C 88 E2   			jmp	_exit.1			; Pass the exit code on.
  363                        	
  364    0D:DD3B  EA EA      	.stack_fill:	db	$EA,$EA			; To make it easier to see.
  365                        	
  366               0001     		.if	!CDROM
  367                        	
  368    0D:DD3D  E3 34 12 02	.rom_tia:	tia	$1234, VDC_DL, 32
         0D:DD41  02 20 00    
  369    0D:DD44  60         			rts
  370                        	
  371    0D:DD45  73 34 12 78	.rom_tii:	tii	$1234, $5678, $9ABC
         0D:DD49  56 BC 9A    
  372    0D:DD4C  60         			rts
  373                        	
  374               22F0     			.bss
  375    F8:22F0             	ram_tia:	ds	8
  376    F8:22F8             	ram_tii:	ds	8
  377               DD4D     			.code
  378                        	
  379                        		.endif	!CDROM
  380                        	
  381                        			.endp
  382                        	
  383                        			;
  384                        			; Self-Modifying TIA and TII instruction subroutines.
  385                        			;
  386                        			; These need to be in permanently-accessible memory so that
  387                        			; HuCC code can modify the values as __fastcall parameters.
  388                        			;
  389                        	
  390               0000     		.if	CDROM
  398                        		.endif	CDROM
  399                        	
  400               22F0     			rsset	ram_tia
  401               22F0     	ram_tia_opc	rs	1
  402               22F1     	ram_tia_src	rs	2
  403               22F3     	ram_tia_dst	rs	2
  404               22F5     	ram_tia_len	rs	2
  405               22F7     	ram_tia_rts	rs	1
  406                        	
  407               22F8     			rsset	ram_tii
  408               22F8     	ram_tii_opc	rs	1
  409               22F9     	ram_tii_src	rs	2
  410               22FB     	ram_tii_dst	rs	2
  411               22FD     	ram_tii_len	rs	2
  412               22FF     	ram_tii_rts	rs	1
  413                        	
  414                        	
  415                        	
  416                        	; ***************************************************************************
  417                        	; ***************************************************************************
  418                        	;
  419                        	; hucc_vbl - vblank IRQ handler, called by the "CORE(not TM)" kernel.
  420                        	;
  421                        	; This uses the kernel's hook to process things during vblank. It returns
  422                        	; with a simple RTS, and it can corrupt any register.
  423                        	;
  424                        	; Any slow routines in here should enable interrupts and protect itself from
  425                        	; re-entrancy problems.
  426                        	;
  427                        	
  428    00:E2CC  20 A9 FF   	hucc_vbl:	call	vbl_init_scroll		; Prepare for the next frame.
  429                        	
  430    00:E2CF  F8         			sed				; Update the HuC system clock
  431    00:E2D0  38         			sec				; which is in BCD here rather
  432    00:E2D1  AD EF 22   			lda	clock_tt		; than the binary one in HuC.
  433    00:E2D4  69 00      			adc	#0			; BCD add ...
  434    00:E2D6  C9 60      			cmp	#$60			; ... but binary comparison.
  435    00:E2D8  90 28      			bcc	.ticks
  436    00:E2DA  AD EE 22   			lda	clock_ss
  437    00:E2DD  69 00      			adc	#0			; BCD add ...
  438    00:E2DF  C9 60      			cmp	#$60			; ... but binary comparison.
  439    00:E2E1  90 1B      			bcc	.seconds
  440    00:E2E3  AD ED 22   			lda	clock_mm
  441    00:E2E6  69 00      			adc	#0			; BCD add ...
  442    00:E2E8  C9 60      			cmp	#$60			; ... but binary comparison.
  443    00:E2EA  90 0E      			bcc	.minutes
  444    00:E2EC  AD EC 22   			lda	clock_hh
  445    00:E2EF  69 00      			adc	#0			; BCD add ...
  446    00:E2F1  C9 12      			cmp	#$12			; ... but binary comparison.
  447    00:E2F3  90 01      			bcc	.hours
  448    00:E2F5  62         			cla
  449    00:E2F6  8D EC 22   	.hours:		sta	clock_hh
  450    00:E2F9  62         			cla
  451    00:E2FA  8D ED 22   	.minutes:	sta	clock_mm
  452    00:E2FD  62         			cla
  453    00:E2FE  8D EE 22   	.seconds:	sta	clock_ss
  454    00:E301  62         			cla
  455    00:E302  8D EF 22   	.ticks:		sta	clock_tt
  456    00:E305  D8         			cld
  457                        	
  458    00:E306  4C 96 E3   			jmp	xfer_palettes		; Upload any palette changes.
                             #[1]   "main.s"
   15               6000     			.data
   16               0003     			.bank	DATA_BANK
   17                        	
   18               E309     		.code
   19                        	
   20                        		.dbg	line,	"..\..\..\include\hucc\globals.h", 1; // **************************************************************************
   21                        		.dbg	line,	"..\..\..\include\hucc\globals.h", 2; // **************************************************************************
   22                        		.dbg	line,	"..\..\..\include\hucc\globals.h", 3; //
   23                        		.dbg	line,	"..\..\..\include\hucc\globals.h", 4; // globals.h
   24                        		.dbg	line,	"..\..\..\include\hucc\globals.h", 5; //
   25                        		.dbg	line,	"..\..\..\include\hucc\globals.h", 6; // **************************************************************************
   26                        		.dbg	line,	"..\..\..\include\hucc\globals.h", 7; // **************************************************************************
   27                        		.dbg	line,	"..\..\..\include\hucc\globals.h", 8; //
   28                        		.dbg	line,	"..\..\..\include\hucc\globals.h", 9; // The idea is that you, a PCE developer, copy this file from the ../include/
   29                        		.dbg	line,	"..\..\..\include\hucc\globals.h", 10; // directory and into your project's directory, and then define the variables
   30                        		.dbg	line,	"..\..\..\include\hucc\globals.h", 11; // that you want to have shared access to in all overlay programs on your CD.
   31                        		.dbg	line,	"..\..\..\include\hucc\globals.h", 12; //
   32                        		.dbg	line,	"..\..\..\include\hucc\globals.h", 13; // Because PCEAS searches the current (i.e. project) directory for an include
   33                        		.dbg	line,	"..\..\..\include\hucc\globals.h", 14; // file first, then it will find your customized copy of the file rather than
   34                        		.dbg	line,	"..\..\..\include\hucc\globals.h", 15; // the original copy in the ../include/ directory.
   35                        		.dbg	line,	"..\..\..\include\hucc\globals.h", 16; //
   36                        		.dbg	line,	"..\..\..\include\hucc\globals.h", 17; // **************************************************************************
   37                        		.dbg	line,	"..\..\..\include\hucc\globals.h", 18; // **************************************************************************
   38                        		.dbg	clear
   39               2300     		.bss
   40    F8:2300             	huc_globals:
   41                        	
   42    F8:2300             	huc_globals_end:
   43               E309     		.code
   44                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 1; #ifndef _hucc_legacy_h
   45                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 2; #define _hucc_legacy_h
   46                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 4; /****************************************************************************
   47                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 5; ; ***************************************************************************
   48                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 6; ;
   49                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 7; ; huc.h
   50                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 8; ;
   51                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 9; ; HuCC wrapper file to include a default set of HuC-compatible functions.
   52                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 10; ;
   53                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 11; ; Copyright John Brandwood 2024.
   54                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 12; ;
   55                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 13; ; Distributed under the Boost Software License, Version 1.0.
   56                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 14; ; (See accompanying file LICENSE_1_0.txt or copy at
   57                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 15; ;  http://www.boost.org/LICENSE_1_0.txt)
   58                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 16; ;
   59                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 17; ; ***************************************************************************
   60                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 18; ; ***************************************************************************
   61                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 19; ;
   62                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 20; ; When the HuCC compiler is invoked with the "--legacy" option to compile old
   63                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 21; ; projects, then this "huc.h" file is automatically included.
   64                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 22; ;
   65                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 23; ; This file includes a set of the individual HuCC headers which correspond to
   66                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 24; ; HuC's built-in functions and MagicKit library.
   67                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 25; ;
   68                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 26; ; New HuCC projects should, preferably, include the specific headers that are
   69                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 27; ; needed, which will then allow them to replace parts of the standard library
   70                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 28; ; with newer functions, or they can just manually include this "huc.h" file.
   71                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 29; ;
   72                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 30; ; ***************************************************************************
   73                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 31; ; **************************************************************************/
   74                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 33; #include "hucc-systemcard.h"
   75                        		.dbg	line,	"..\..\..\include\hucc\hucc-systemcard.h", 1; #ifndef _hucc_systemcard_h
   76                        		.dbg	line,	"..\..\..\include\hucc\hucc-systemcard.h", 2; #define _hucc_systemcard_h
   77                        		.dbg	line,	"..\..\..\include\hucc\hucc-systemcard.h", 4; /****************************************************************************
   78                        		.dbg	line,	"..\..\..\include\hucc\hucc-systemcard.h", 5; ; ***************************************************************************
   79                        		.dbg	line,	"..\..\..\include\hucc\hucc-systemcard.h", 6; ;
   80                        		.dbg	line,	"..\..\..\include\hucc\hucc-systemcard.h", 7; ; hucc-systemcard.h
   81                        		.dbg	line,	"..\..\..\include\hucc\hucc-systemcard.h", 8; ;
   82                        		.dbg	line,	"..\..\..\include\hucc\hucc-systemcard.h", 9; ; Macros and library functions for using the System Card.
   83                        		.dbg	line,	"..\..\..\include\hucc\hucc-systemcard.h", 10; ;
   84                        		.dbg	line,	"..\..\..\include\hucc\hucc-systemcard.h", 11; ; Copyright John Brandwood 2024.
   85                        		.dbg	line,	"..\..\..\include\hucc\hucc-systemcard.h", 12; ;
   86                        		.dbg	line,	"..\..\..\include\hucc\hucc-systemcard.h", 13; ; Distributed under the Boost Software License, Version 1.0.
   87                        		.dbg	line,	"..\..\..\include\hucc\hucc-systemcard.h", 14; ; (See accompanying file LICENSE_1_0.txt or copy at
   88                        		.dbg	line,	"..\..\..\include\hucc\hucc-systemcard.h", 15; ;  http://www.boost.org/LICENSE_1_0.txt)
   89                        		.dbg	line,	"..\..\..\include\hucc\hucc-systemcard.h", 16; ;
   90                        		.dbg	line,	"..\..\..\include\hucc\hucc-systemcard.h", 17; ; ***************************************************************************
   91                        		.dbg	line,	"..\..\..\include\hucc\hucc-systemcard.h", 18; ; ***************************************************************************
   92                        		.dbg	line,	"..\..\..\include\hucc\hucc-systemcard.h", 19; ;
   93                        		.dbg	line,	"..\..\..\include\hucc\hucc-systemcard.h", 20; ; Because these are mainly macros, and so must be included before being used
   94                        		.dbg	line,	"..\..\..\include\hucc\hucc-systemcard.h", 21; ; in compiled code, the actual functions here are written to avoid using any
   95                        		.dbg	line,	"..\..\..\include\hucc\hucc-systemcard.h", 22; ; BSS memory so that HuCC's overlay global-shared-variables are not effected.
   96                        		.dbg	line,	"..\..\..\include\hucc\hucc-systemcard.h", 23; ;
   97                        		.dbg	line,	"..\..\..\include\hucc\hucc-systemcard.h", 24; ; ***************************************************************************
   98                        		.dbg	line,	"..\..\..\include\hucc\hucc-systemcard.h", 25; ; **************************************************************************/
   99                        		.dbg	line,	"..\..\..\include\hucc\hucc-systemcard.h", 27; // *************
  100                        		.dbg	line,	"..\..\..\include\hucc\hucc-systemcard.h", 28; // Backup RAM defines ...
  101                        		.dbg	line,	"..\..\..\include\hucc\hucc-systemcard.h", 29; // *************
  102                        		.dbg	line,	"..\..\..\include\hucc\hucc-systemcard.h", 31; #define  BM_OK             0
  103                        		.dbg	line,	"..\..\..\include\hucc\hucc-systemcard.h", 32; #define  BM_NOT_FOUND      1
  104                        		.dbg	line,	"..\..\..\include\hucc\hucc-systemcard.h", 33; #define  BM_BAD_CHECKSUM   2
  105                        		.dbg	line,	"..\..\..\include\hucc\hucc-systemcard.h", 34; #define  BM_DIR_CORRUPTED  3
  106                        		.dbg	line,	"..\..\..\include\hucc\hucc-systemcard.h", 35; #define  BM_FILE_EMPTY     4
  107                        		.dbg	line,	"..\..\..\include\hucc\hucc-systemcard.h", 36; #define  BM_FULL           5
  108                        		.dbg	line,	"..\..\..\include\hucc\hucc-systemcard.h", 37; #define  BM_NOT_FORMATED   0xFF			// HuC incorrect spelling.
  109                        		.dbg	line,	"..\..\..\include\hucc\hucc-systemcard.h", 38; #define  BM_NOT_FORMATTED  0xFF			// HuCC can use a dictionary!
  110                        		.dbg	line,	"..\..\..\include\hucc\hucc-systemcard.h", 40; #define  BRAM_STARTPTR     0x8010
  111                        		.dbg	line,	"..\..\..\include\hucc\hucc-systemcard.h", 42; // *************
  112                        		.dbg	line,	"..\..\..\include\hucc\hucc-systemcard.h", 43; // CD defines ...
  113                        		.dbg	line,	"..\..\..\include\hucc\hucc-systemcard.h", 44; // *************
  114                        		.dbg	line,	"..\..\..\include\hucc\hucc-systemcard.h", 46; #define	CDPLAY_MUTE		0
  115                        		.dbg	line,	"..\..\..\include\hucc\hucc-systemcard.h", 47; #define	CDPLAY_REPEAT		1
  116                        		.dbg	line,	"..\..\..\include\hucc\hucc-systemcard.h", 48; #define	CDPLAY_NORMAL		2
  117                        		.dbg	line,	"..\..\..\include\hucc\hucc-systemcard.h", 49; #define	CDPLAY_ENDOFDISC	0
  118                        		.dbg	line,	"..\..\..\include\hucc\hucc-systemcard.h", 51; #define	CDFADE_CANCEL	0
  119                        		.dbg	line,	"..\..\..\include\hucc\hucc-systemcard.h", 52; #define	CDFADE_PCM6	8
  120                        		.dbg	line,	"..\..\..\include\hucc\hucc-systemcard.h", 53; #define	CDFADE_ADPCM6	10
  121                        		.dbg	line,	"..\..\..\include\hucc\hucc-systemcard.h", 54; #define	CDFADE_PCM2	12
  122                        		.dbg	line,	"..\..\..\include\hucc\hucc-systemcard.h", 55; #define	CDFADE_ADPCM2	14
  123                        		.dbg	line,	"..\..\..\include\hucc\hucc-systemcard.h", 57; #define CDTRK_AUDIO	0
  124                        		.dbg	line,	"..\..\..\include\hucc\hucc-systemcard.h", 58; #define CDTRK_DATA	4
  125                        		.dbg	line,	"..\..\..\include\hucc\hucc-systemcard.h", 60; // *************
  126                        		.dbg	line,	"..\..\..\include\hucc\hucc-systemcard.h", 61; // ADPCM defines ...
  127                        		.dbg	line,	"..\..\..\include\hucc\hucc-systemcard.h", 62; // *************
  128                        		.dbg	line,	"..\..\..\include\hucc\hucc-systemcard.h", 64; #define	ADPLAY_AUTOSTOP		0
  129                        		.dbg	line,	"..\..\..\include\hucc\hucc-systemcard.h", 65; #define	ADPLAY_REPEAT		0x80
  130                        		.dbg	line,	"..\..\..\include\hucc\hucc-systemcard.h", 67; #define ADPLAY_FREQ_16KHZ	0xE
  131                        		.dbg	line,	"..\..\..\include\hucc\hucc-systemcard.h", 68; #define ADPLAY_FREQ_10KHZ	0xD
  132                        		.dbg	line,	"..\..\..\include\hucc\hucc-systemcard.h", 69; #define ADPLAY_FREQ_8KHZ	0xC
  133                        		.dbg	line,	"..\..\..\include\hucc\hucc-systemcard.h", 70; #define ADPLAY_FREQ_6KHZ	0xB
  134                        		.dbg	line,	"..\..\..\include\hucc\hucc-systemcard.h", 71; #define ADPLAY_FREQ_5KHZ	0xA
  135                        		.dbg	line,	"..\..\..\include\hucc\hucc-systemcard.h", 73; #define ADREAD_RAM	0
  136                        		.dbg	line,	"..\..\..\include\hucc\hucc-systemcard.h", 74; #define ADREAD_VRAM	0xFF
  137                        		.dbg	line,	"..\..\..\include\hucc\hucc-systemcard.h", 76; #define ADWRITE_RAM	0
  138                        		.dbg	line,	"..\..\..\include\hucc\hucc-systemcard.h", 77; #define ADWRITE_VRAM	0xFF
  139                        		.dbg	line,	"..\..\..\include\hucc\hucc-systemcard.h", 79; // *************
  140                        		.dbg	line,	"..\..\..\include\hucc\hucc-systemcard.h", 80; // Functions in hucc-systemcard.asm ...
  141                        		.dbg	line,	"..\..\..\include\hucc\hucc-systemcard.h", 81; // *************
  142                        		.dbg	line,	"..\..\..\include\hucc\hucc-systemcard.h", 83; #ifdef __HUCC__
  143                        		.dbg	line,	"..\..\..\include\hucc\hucc-systemcard.h", 85; #asmdef	HUCC_USES_SYSTEMCARD 1
  144               0001     	HUCC_USES_SYSTEMCARD = 1
  145                        		.dbg	line,	"..\..\..\include\hucc\hucc-systemcard.h", 87; extern void __fastcall __macro cd_boot( void );
  146                        		.dbg	line,	"..\..\..\include\hucc\hucc-systemcard.h", 88; extern unsigned int __fastcall __macro cd_getver( void );
  147                        		.dbg	line,	"..\..\..\include\hucc\hucc-systemcard.h", 89; extern void __fastcall __macro cd_reset( void );
  148                        		.dbg	line,	"..\..\..\include\hucc\hucc-systemcard.h", 90; extern unsigned char __fastcall __macro cd_pause( void );
  149                        		.dbg	line,	"..\..\..\include\hucc\hucc-systemcard.h", 91; extern unsigned char __fastcall cd_unpause( void );
  150                        		.dbg	line,	"..\..\..\include\hucc\hucc-systemcard.h", 92; extern void __fastcall __macro cd_fade( unsigned char type<acc> );
  151                        		.dbg	line,	"..\..\..\include\hucc\hucc-systemcard.h", 93; extern unsigned char __fastcall cd_playtrk( unsigned char start_track<_bx>, unsigned char end_track<_cx>, unsigned char mode<_dh> );
  152                        		.dbg	line,	"..\..\..\include\hucc\hucc-systemcard.h", 94; extern unsigned char __fastcall cd_playmsf( unsigned char start_minute<_al>,  unsigned char start_second<_ah>,  unsigned char start_frame<_bl>, unsigned char end_minute<_cl>,  unsigned char end_second<_ch>,  unsigned char end_frame<_dl>,  unsigned char mode<_dh> );
  153                        		.dbg	line,	"..\..\..\include\hucc\hucc-systemcard.h", 95; extern unsigned char __fastcall cd_fastvram( unsigned char ovl_index<_cl>, unsigned int sect_offset<_si>, unsigned int vramaddr<_bx>, unsigned int sectors<_al> );
  154                        		.dbg	line,	"..\..\..\include\hucc\hucc-systemcard.h", 96; extern unsigned char __fastcall cd_loadvram( unsigned char ovl_index<_cl>, unsigned int sect_offset<_si>, unsigned int vramaddr<_bx>, unsigned int bytes<_ax> );
  155                        		.dbg	line,	"..\..\..\include\hucc\hucc-systemcard.h", 97; extern unsigned char __fastcall cd_loaddata( unsigned char ovl_index<_cl>, unsigned int sect_offset<_si>, unsigned char __far *buffer<_bp_bank:_bp>, unsigned int bytes<__ptr> );
  156                        		.dbg	line,	"..\..\..\include\hucc\hucc-systemcard.h", 98; extern unsigned char __fastcall cd_loadbank( unsigned char ovl_index<_cl>, unsigned int sect_offset<_si>, unsigned char bank<_bl>, unsigned int sectors<_al> );
  157                        		.dbg	line,	"..\..\..\include\hucc\hucc-systemcard.h", 99; extern unsigned char __fastcall __macro cd_status( unsigned char mode<acc> );
  158                        		.dbg	line,	"..\..\..\include\hucc\hucc-systemcard.h", 101; extern void __fastcall __macro ad_reset( void );
  159                        		.dbg	line,	"..\..\..\include\hucc\hucc-systemcard.h", 102; extern unsigned char __fastcall __macro ad_trans( unsigned char ovl_index<_cl>, unsigned int sect_offset<_si>, unsigned char nb_sectors<_dh>, unsigned int ad_addr<_bx> );
  160                        		.dbg	line,	"..\..\..\include\hucc\hucc-systemcard.h", 103; extern void __fastcall __macro ad_read( unsigned int ad_addr<_cx>, unsigned char mode<_dh>, unsigned int buf<_bx>, unsigned int bytes<_ax> );
  161                        		.dbg	line,	"..\..\..\include\hucc\hucc-systemcard.h", 104; extern void __fastcall __macro ad_write( unsigned int ad_addr<_cx>, unsigned char mode<_dh>, unsigned int buf<_bx>, unsigned int bytes<_ax> );
  162                        		.dbg	line,	"..\..\..\include\hucc\hucc-systemcard.h", 105; extern unsigned char __fastcall __macro ad_play( unsigned int ad_addr<_bx>, unsigned int bytes<_ax>, unsigned char freq<_dh>, unsigned char mode<_dl> );
  163                        		.dbg	line,	"..\..\..\include\hucc\hucc-systemcard.h", 106; extern unsigned char __fastcall __macro ad_cplay( unsigned char ovl_index<_cl>, unsigned int sect_offset<_si>, unsigned int nb_sectors<_bx>, unsigned char freq<_dh> );
  164                        		.dbg	line,	"..\..\..\include\hucc\hucc-systemcard.h", 107; extern void __fastcall __macro ad_stop( void );
  165                        		.dbg	line,	"..\..\..\include\hucc\hucc-systemcard.h", 108; extern unsigned char __fastcall __macro ad_stat( void );
  166                        		.dbg	line,	"..\..\..\include\hucc\hucc-systemcard.h", 110; extern unsigned char __fastcall bm_check( void );
  167                        		.dbg	line,	"..\..\..\include\hucc\hucc-systemcard.h", 111; extern unsigned char __fastcall bm_format( void );
  168                        		.dbg	line,	"..\..\..\include\hucc\hucc-systemcard.h", 112; extern unsigned int __fastcall __macro bm_free( void );
  169                        		.dbg	line,	"..\..\..\include\hucc\hucc-systemcard.h", 113; extern unsigned char __fastcall __macro bm_read( unsigned char *buffer<_bx>, unsigned char *name<_ax>, unsigned int offset<_dx>, unsigned int length<_cx> );
  170                        		.dbg	line,	"..\..\..\include\hucc\hucc-systemcard.h", 114; extern unsigned char __fastcall __macro bm_write( unsigned char *buffer<_bx>, unsigned char *name<_ax>, unsigned int offset<_dx>, unsigned int length<_cx> );
  171                        		.dbg	line,	"..\..\..\include\hucc\hucc-systemcard.h", 115; extern unsigned char __fastcall __macro bm_delete( unsigned char *name<_ax> );
  172                        		.dbg	line,	"..\..\..\include\hucc\hucc-systemcard.h", 117; // Deprecated functions ...
  173                        		.dbg	line,	"..\..\..\include\hucc\hucc-systemcard.h", 119; extern unsigned char __fastcall __macro bm_exist( unsigned char *name<_ax> );
  174                        		.dbg	line,	"..\..\..\include\hucc\hucc-systemcard.h", 120; extern unsigned char __fastcall __macro bm_create( unsigned char *name<_ax>, unsigned int length<_cx> );
  175                        		.dbg	line,	"..\..\..\include\hucc\hucc-systemcard.h", 122; // void __fastcall _xsafe add_sectors( unsigned int sector_offset<acc> );
  176                        		.dbg	line,	"..\..\..\include\hucc\hucc-systemcard.h", 124; #endif // __HUCC__
  177                        		.dbg	line,	"..\..\..\include\hucc\hucc-systemcard.h", 126; #endif // _hucc_systemcard_h
  178                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 34; #include "hucc-baselib.h"
  179                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 1; #ifndef _hucc_baselib_h
  180                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 2; #define _hucc_baselib_h
  181                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 4; /****************************************************************************
  182                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 5; ; ***************************************************************************
  183                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 6; ;
  184                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 7; ; hucc-baselib.h
  185                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 8; ;
  186                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 9; ; Basic library functions provided as macros.
  187                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 10; ;
  188                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 11; ; Copyright John Brandwood 2024.
  189                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 12; ;
  190                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 13; ; Distributed under the Boost Software License, Version 1.0.
  191                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 14; ; (See accompanying file LICENSE_1_0.txt or copy at
  192                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 15; ;  http://www.boost.org/LICENSE_1_0.txt)
  193                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 16; ;
  194                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 17; ; ***************************************************************************
  195                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 18; ; **************************************************************************/
  196                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 20; // *************
  197                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 21; // Joypad defines ...
  198                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 22; // *************
  199                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 24; #define	JOY_A		0x01
  200                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 25; #define	JOY_I		0x01
  201                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 26; #define	JOY_B		0x02
  202                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 27; #define	JOY_II		0x02
  203                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 28; #define	JOY_SLCT	0x04
  204                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 29; #define	JOY_SEL		0x04
  205                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 30; #define	JOY_STRT	0x08
  206                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 31; #define	JOY_RUN		0x08
  207                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 32; #define	JOY_UP		0x10
  208                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 33; #define	JOY_RGHT	0x20
  209                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 34; #define	JOY_RIGHT	0x20
  210                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 35; #define	JOY_DOWN	0x40
  211                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 36; #define	JOY_LEFT	0x80
  212                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 38; #define	JOY_C		0x0100
  213                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 39; #define	JOY_III		0x0100
  214                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 40; #define	JOY_D		0x0200
  215                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 41; #define	JOY_IV		0x0200
  216                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 42; #define	JOY_E		0x0400
  217                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 43; #define	JOY_V		0x0400
  218                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 44; #define	JOY_F		0x0800
  219                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 45; #define	JOY_VI		0x0800
  220                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 47; #define JOY_SIXBUT	0x8000
  221                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 48; #define JOY_TYPE6	0x8000
  222                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 50; // *************
  223                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 51; // SuperGRAFX VPC settings for set_vpc_ctl() ...
  224                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 52; // *************
  225                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 54; #define VPC_SPR1_BKG1_SPR2_BKG2	0x3000 // same as SGX_PARALLAX=0
  226                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 55; #define VPC_SPR1_SPR2_BKG1_BKG2	0x7000 // same as SGX_PARALLAX=1
  227                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 56; #define VPC_BKG1_BKG2_SPR1_SPR2	0xB000
  228                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 58; // *************
  229                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 59; // System Card variables ...
  230                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 60; // *************
  231                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 62; extern unsigned int si;
  232                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 63; extern unsigned int di;
  233                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 64; extern unsigned int bp;
  234                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 66; extern unsigned int ax;
  235                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 67; extern unsigned int bx;
  236                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 68; extern unsigned int cx;
  237                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 69; extern unsigned int dx;
  238                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 71; extern unsigned char al;
  239                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 72; extern unsigned char ah;
  240                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 73; extern unsigned char bl;
  241                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 74; extern unsigned char bh;
  242                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 75; extern unsigned char cl;
  243                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 76; extern unsigned char ch;
  244                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 77; extern unsigned char dl;
  245                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 78; extern unsigned char dh;
  246                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 80; extern unsigned char irq_cnt;
  247                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 81; extern unsigned char joynow[5];
  248                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 82; extern unsigned char joytrg[5];
  249                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 83; extern unsigned char joy6now[5];
  250                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 84; extern unsigned char joy6trg[5];
  251                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 85; extern unsigned int  bg_x1;
  252                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 86; extern unsigned int  bg_y1;
  253                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 87; extern unsigned int  bg_x2;
  254                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 88; extern unsigned int  bg_y2;
  255                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 90; // *************
  256                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 91; // Special macros to get information from PCEAS ...
  257                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 92; // *************
  258                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 94; #define BANK( datasym ) ((unsigned) (&__bank__ ## datasym))
  259                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 95; #define SIZEOF( datasym ) ((unsigned) (&__sizeof__ ## datasym))
  260                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 96; #define COUNTOF( datasym ) ((unsigned) (&__countof__ ## datasym))
  261                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 97; #define OVERLAY( datasym ) ((unsigned) (&__overlay__ ## datasym))
  262                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 100; // *************
  263                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 101; // Functions in hucc-baselib.asm ...
  264                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 102; // *************
  265                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 104; #ifdef __HUCC__
  266                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 106; #asmdef	HUCC_USES_BASELIB 1
  267               0001     	HUCC_USES_BASELIB = 1
  268                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 108; #define	_OPTIMIZE 1
  269                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 111; // *************
  270                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 112; // Hardware Detection
  271                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 113; // *************
  272                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 115; extern unsigned char __fastcall __macro sgx_detect( void );
  273                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 116; extern unsigned char __fastcall __macro ac_exists( void );
  274                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 119; // *************
  275                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 120; // Memory Access
  276                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 121; // *************
  277                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 123; extern unsigned char __fastcall __macro peek( unsigned int addr<__ptr> );
  278                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 124; extern unsigned int  __fastcall __macro peekw( unsigned int addr<__ptr> );
  279                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 126; extern void __fastcall __macro poke( unsigned int addr<__poke>, unsigned char with<acc> );
  280                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 127; extern void __fastcall __macro pokew( unsigned int addr<__poke>, unsigned int with<acc> );
  281                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 129; extern unsigned char __fastcall farpeek( void __far *addr<_bp_bank:_bp> );
  282                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 130; extern unsigned int  __fastcall farpeekw( void __far *addr<_bp_bank:_bp> );
  283                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 132; extern void __fastcall __nop set_far_base( unsigned char data_bank<_bp_bank>, unsigned char *data_addr<_bp> );
  284                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 133; extern void __fastcall set_far_offset( unsigned int offset<_bp>, unsigned char data_bank<_bp_bank>, unsigned char *data_addr<acc> );
  285                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 135; extern unsigned char __fastcall far_peek( void );
  286                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 136; extern unsigned int  __fastcall far_peekw( void );
  287                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 138; extern void __fastcall __macro reset_mpr2( void );
  288                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 139; extern void __fastcall __macro reset_mpr34( void );
  289                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 141; extern void * __fastcall __macro farset_mpr2( void __far *addr<_bp_bank:_bp> );
  290                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 142; extern void * __fastcall __macro farset_mpr34( void __far *addr<_bp_bank:_bp> );
  291                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 144; extern void * __fastcall __macro far_set_mpr2( void );
  292                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 145; extern void * __fastcall __macro far_set_mpr34( void );
  293                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 148; // *************
  294                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 149; // Clock Functions
  295                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 150; // *************
  296                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 152; extern unsigned char __fastcall __macro clock_hh( void );
  297                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 153; extern unsigned char __fastcall __macro clock_mm( void );
  298                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 154; extern unsigned char __fastcall __macro clock_ss( void );
  299                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 155; extern unsigned char __fastcall __macro clock_tt( void );
  300                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 156; extern void __fastcall __macro clock_reset( void );
  301                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 159; // *************
  302                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 160; // Joypad Functions
  303                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 161; // *************
  304                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 163; extern unsigned int __fastcall __macro joy( unsigned char which<acc> );
  305                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 164; extern unsigned int __fastcall __macro joytrg( unsigned char which<acc> );
  306                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 167; // *************
  307                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 168; // Number Functions
  308                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 169; // *************
  309                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 171; extern int __fastcall abs( int value<acc> );
  310                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 173; extern void __fastcall __macro srand( unsigned char seed<acc> );
  311                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 174; extern unsigned int __fastcall rand( void );
  312                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 175; extern unsigned char __fastcall rand8( void );
  313                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 177; // Note: "limit" is 0..255.
  314                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 178; extern unsigned char __fastcall random8( unsigned char limit<acc> );
  315                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 180; // Note: "limit" is 0..128, 129..255 are treated as 128!
  316                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 181; extern unsigned char __fastcall random( unsigned char limit<acc> );
  317                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 184; // *************
  318                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 185; // Overlay Execution
  319                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 186; // *************
  320                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 188; extern unsigned char __fastcall __macro cd_execoverlay( unsigned char ovl_index<acc> );
  321                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 191; // *************
  322                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 192; // Functions that are only optionally available if configured in your hucc-config.inc
  323                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 193; // *************
  324                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 195; extern unsigned int __fastcall __macro joybuf( unsigned char which<acc> );
  325                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 196; extern unsigned int __fastcall __macro get_joy_events( unsigned char which<acc> );
  326                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 197; extern void __fastcall __macro clear_joy_events( unsigned char mask<acc> );
  327                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 200; // *************
  328                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 201; // Functions that are only implemented in the TGEMU emulator for unit-testing
  329                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 202; // the compiler, and which should never be used in normal HuCC projects ...
  330                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 203; // *************
  331                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 205; extern void __fastcall dump_screen( void );
  332                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 206; extern void __fastcall abort( void );
  333                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 207; extern void __fastcall exit( int value<acc> );
  334                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 209; extern unsigned char __fastcall __builtin_ffs( unsigned int value<__temp> );
  335                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 211; #endif // __HUCC__
  336                        		.dbg	line,	"..\..\..\include\hucc\hucc-baselib.h", 213; #endif // _hucc_baselib_h
  337                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 35; #include "hucc-gfx.h"
  338                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 1; #ifndef _hucc_gfx_h
  339                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 2; #define _hucc_gfx_h
  340                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 4; /****************************************************************************
  341                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 5; ; ***************************************************************************
  342                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 6; ;
  343                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 7; ; huc-gfx.h
  344                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 8; ;
  345                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 9; ; Based on the original HuC and MagicKit functions by David Michel and the
  346                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 10; ; other original HuC developers.
  347                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 11; ;
  348                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 12; ; Modifications copyright John Brandwood 2024.
  349                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 13; ;
  350                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 14; ; Distributed under the Boost Software License, Version 1.0.
  351                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 15; ; (See accompanying file LICENSE_1_0.txt or copy at
  352                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 16; ;  http://www.boost.org/LICENSE_1_0.txt)
  353                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 17; ;
  354                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 18; ; ***************************************************************************
  355                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 19; ; **************************************************************************/
  356                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 21; // *************
  357                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 22; // Screen defines ...
  358                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 23; // *************
  359                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 25; #define	SCR_SIZE_32x32	0
  360                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 26; #define	SCR_SIZE_64x32	1
  361                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 27; #define	SCR_SIZE_128x32	2
  362                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 28; #define	SCR_SIZE_32x64	4
  363                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 29; #define	SCR_SIZE_64x64	5
  364                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 30; #define	SCR_SIZE_128x64	6
  365                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 32; #define	XRES_SHARP	0
  366                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 33; #define	XRES_SOFT	4
  367                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 34; #define	XRES_KEEP	128
  368                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 36; #define VPC_WIN_A	0x00
  369                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 37; #define VPC_WIN_B	0x01
  370                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 38; #define	VPC_WIN_AB	0x02
  371                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 39; #define	VPC_WIN_NONE	0x03
  372                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 40; #define	VPC_NORM	0x00
  373                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 41; #define	VPC_SPR		0x04
  374                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 42; #define	VPC_INV_SPR	0x08
  375                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 43; #define VDC1_ON		0x01
  376                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 44; #define	VDC1_OFF	0x00
  377                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 45; #define VDC2_ON		0x02
  378                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 46; #define	VDC2_OFF	0x00
  379                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 47; #define VDC_ON		0x03
  380                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 48; #define	VDC_OFF		0x00
  381                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 50; // *************
  382                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 51; // Functions in hucc-gfx.asm ...
  383                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 52; // *************
  384                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 54; #ifdef __HUCC__
  385                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 56; #asmdef	HUCC_USES_GFX 1
  386               0001     	HUCC_USES_GFX = 1
  387                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 58; // *************
  388                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 59; // Color and Palette Functions
  389                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 60; // *************
  390                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 62; extern void __fastcall clear_palette( void );
  391                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 64; extern void __fastcall __nop set_color( unsigned int index<VCE_CTA>, unsigned int value<VCE_CTW> );
  392                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 65; extern void __fastcall set_color_rgb( unsigned int index<VCE_CTA>, unsigned char r<_al>, unsigned char g<_ah>, unsigned char b<acc> );
  393                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 66; extern unsigned int __fastcall __macro get_color( unsigned int index<VCE_CTA> );
  394                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 68; extern void __fastcall load_palette( unsigned char palette<_al>, unsigned char __far *data<_bp_bank:_bp>, unsigned char num_palettes<_ah> );
  395                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 69; extern void __fastcall far_load_palette( unsigned char palette<_al>, unsigned char num_palettes<_ah> );
  396                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 71; extern void __fastcall read_palette( unsigned char palette<_al>, unsigned char num_palettes<_ah>, unsigned int *destination<_di> );
  397                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 73; extern void __fastcall __macro fade_to_black( unsigned int __far *from<_bp_bank:_bp>, unsigned int *destination<_di>, unsigned char num_colors<_al>, unsigned char value_to_sub<_ah> );
  398                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 74; extern void __fastcall __macro fade_to_white( unsigned int __far *from<_bp_bank:_bp>, unsigned int *destination<_di>, unsigned char num_colors<_al>, unsigned char value_to_add<_ah> );
  399                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 75; extern void __fastcall __macro cross_fade_to( unsigned int __far *from<_bp_bank:_bp>, unsigned int *destination<_di>, unsigned char num_colors<_al>, unsigned char which_component<_ah> );
  400                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 77; extern void __fastcall __macro far_fade_to_black( unsigned int *destination<_di>, unsigned char num_colors<_al>, unsigned char value_to_sub<_ah> );
  401                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 78; extern void __fastcall __macro far_fade_to_white( unsigned int *destination<_di>, unsigned char num_colors<_al>, unsigned char value_to_add<_ah> );
  402                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 79; extern void __fastcall __macro far_cross_fade_to( unsigned int *destination<_di>, unsigned char num_colors<_al>, unsigned char which_component<_ah> );
  403                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 83; // *************
  404                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 84; // Video Functions
  405                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 85; // *************
  406                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 87; extern void __fastcall init_240x208( void );
  407                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 88; extern void __fastcall init_256x224( void );
  408                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 90; extern void __fastcall vsync( void );
  409                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 91; extern void __fastcall vsync( unsigned char count<_al> );
  410                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 93; extern void __fastcall disp_on( void );
  411                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 94; extern void __fastcall disp_off( void );
  412                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 96; extern void __fastcall set_screen_size( unsigned char value<_al> );
  413                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 98; extern void __fastcall set_xres( unsigned int x_pixels<_ax>, unsigned char blur_flag<_bl> );
  414                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 100; extern void __fastcall cls( void );
  415                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 101; extern void __fastcall cls( unsigned int tile<acc> );
  416                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 103; extern unsigned int __fastcall __macro vram_addr( unsigned char bat_x<_al>, unsigned char bat_y<_ah> );
  417                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 104; extern unsigned int __fastcall __macro get_vram( unsigned int address<_di> );
  418                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 105; extern void __fastcall __macro put_vram( unsigned int address<_di>, unsigned int data<acc> );
  419                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 107; extern void __fastcall __macro load_vram( unsigned int vram<_di>, unsigned char __far *data<_bp_bank:_bp>, unsigned int num_words<_ax> );
  420                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 108; extern void __fastcall __macro far_load_vram( unsigned int vram<_di>,  unsigned int num_words<_ax> );
  421                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 110; extern void __fastcall load_bat( unsigned int vram<_di>, unsigned char __far *data<_bp_bank:_bp>, unsigned char tiles_w<_al>, unsigned char tiles_h<_ah> );
  422                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 111; extern void __fastcall far_load_bat( unsigned int vram<_di>, unsigned char tiles_w<_al>, unsigned char tiles_h<_ah> );
  423                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 113; extern void __fastcall __macro load_sprites( unsigned int vram<_di>, unsigned char __far *data<_bp_bank:_bp>, unsigned int num_groups<acc> );
  424                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 114; extern void __fastcall __macro far_load_sprites( unsigned int vram<_di>, unsigned int num_groups<acc> );
  425                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 116; extern void __fastcall vram2vram( unsigned int vram_dst<_ax>, unsigned int vram_src<_bx>, unsigned int word_len<_cx> );
  426                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 119; // *************
  427                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 120; // SuperGRAFX Video Functions
  428                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 121; // *************
  429                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 123; extern void __fastcall __nop vpc_set_ctl( unsigned int bits<VPC_CR> );
  430                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 124; extern void __fastcall __nop vpc_set_win1( unsigned int width<VPC_WINDOW1> );
  431                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 125; extern void __fastcall __nop vpc_set_win2( unsigned int width<VPC_WINDOW2> );
  432                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 127; extern void __fastcall sgx_set_screen_size( unsigned char value<_al> );
  433                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 129; extern void __fastcall sgx_set_xres( unsigned int x_pixels<_ax>, unsigned char blur_flag<_bl> );
  434                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 131; extern void __fastcall sgx_cls( void );
  435                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 132; extern void __fastcall sgx_cls( unsigned int tile<acc> );
  436                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 134; extern unsigned int __fastcall __macro sgx_vram_addr( unsigned char bat_x<_al>, unsigned char bat_y<_ah> );
  437                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 135; extern unsigned int __fastcall __macro sgx_get_vram( unsigned int address<_di> );
  438                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 136; extern void __fastcall __macro sgx_put_vram( unsigned int address<_di>, unsigned int data<acc> );
  439                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 138; extern void __fastcall __macro sgx_load_vram( unsigned int vram<_di>, unsigned char __far *data<_bp_bank:_bp>, unsigned int num_words<_ax> );
  440                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 139; extern void __fastcall __macro sgx_far_load_vram( unsigned int vram<_di>, unsigned int num_words<_ax> );
  441                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 141; extern void __fastcall sgx_load_bat( unsigned int vram<_di>, unsigned char __far *data<_bp_bank:_bp>, unsigned char tiles_w<_al>, unsigned char tiles_h<_ah> );
  442                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 142; extern void __fastcall sgx_far_load_bat( unsigned int vram<_di>, unsigned char tiles_w<_al>, unsigned char tiles_h<_ah> );
  443                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 144; extern void __fastcall __macro sgx_load_sprites( unsigned int vram<_di>, unsigned char __far *data<_bp_bank:_bp>, unsigned int num_groups<acc> );
  444                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 145; extern void __fastcall __macro sgx_far_load_sprites( unsigned int vram<_di>, unsigned int num_groups<acc> );
  445                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 147; extern void __fastcall sgx_vram2vram( unsigned int vram_dst<_ax>, unsigned int vram_src<_bx>, unsigned int word_len<_cx> );
  446                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 150; // *************
  447                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 151; // Font Functions
  448                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 152; // *************
  449                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 154; extern void __fastcall set_font_addr( unsigned int vram<acc> );
  450                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 155; extern void __fastcall set_font_pal( unsigned char palette<acc> );
  451                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 157; extern void __fastcall load_font( unsigned char __far *font<_bp_bank:_bp>, unsigned char count<_al>, unsigned int vram<acc> );
  452                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 158; extern void __fastcall far_load_font( unsigned char count<_al>, unsigned int vram<acc> );
  453                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 160; extern void __fastcall __nop set_font_color( unsigned char foreground<monofont_fg>, unsigned char background<monofont_bg> );
  454                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 161; extern void __fastcall __macro load_default_font( void );
  455                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 164; // *************
  456                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 165; // SuperGRAFX Font Functions
  457                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 166; // *************
  458                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 168; extern void __fastcall sgx_set_font_addr( unsigned int vram<acc> );
  459                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 169; extern void __fastcall sgx_set_font_pal( unsigned char palette<acc> );
  460                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 171; extern void __fastcall sgx_load_font( char __far *font<_bp_bank:_bp>, unsigned char count<_al>, unsigned int vram<acc> );
  461                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 172; extern void __fastcall sgx_far_load_font( unsigned char count<_al>, unsigned int vram<acc> );
  462                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 174; extern void __fastcall __macro sgx_load_default_font( void );
  463                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 177; // *************
  464                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 178; // Deprecated functions ...
  465                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 179; // *************
  466                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 181; extern void __fastcall __macro set_xres( unsigned int x_pixels<_ax> );
  467                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 182; extern void __fastcall __macro sgx_set_xres( unsigned int x_pixels<_ax> );
  468                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 184; extern void __fastcall load_background( unsigned char __far *tiles<_bp_bank:_bp>, unsigned char __far *palettes<__fbank:__fptr>, unsigned char __far *bat<_cl:_bx>, unsigned char w<_dl>, unsigned char h<_dh> );
  469                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 186; extern void __fastcall __macro set_bgpal( unsigned char palette<_al>, unsigned char __far *data<_bp_bank:_bp> );
  470                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 187; extern void __fastcall __macro set_bgpal( unsigned char palette<_al>, unsigned char __far *data<_bp_bank:_bp>, unsigned int num_palettes<_ah> );
  471                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 188; extern void __fastcall __macro set_sprpal( unsigned char palette<_al>, unsigned char __far *data<_bp_bank:_bp> );
  472                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 189; extern void __fastcall __macro set_sprpal( unsigned char palette<_al>, unsigned char __far *data<_bp_bank:_bp>, unsigned int num_palettes<_ah> );
  473                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 191; extern void __fastcall load_font( char __far *font<_bp_bank:_bp>, unsigned char count<_al> );
  474                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 193; extern void __fastcall put_string( unsigned char *string<_bp>, unsigned char bat_x<_dil>, unsigned char bat_y<_dih> );
  475                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 195; extern void __fastcall put_char( unsigned char digit<_bl>, unsigned char bat_x<_dil>, unsigned char bat_y<_dih> );
  476                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 196; extern void __fastcall put_digit( unsigned char digit<_bl>, unsigned char bat_x<_dil>, unsigned char bat_y<_dih> );
  477                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 197; extern void __fastcall put_hex( unsigned int number<_bx>, unsigned char length<_cl>, unsigned char bat_x<_dil>, unsigned char bat_y<_dih> );
  478                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 198; extern void __fastcall put_number( unsigned int number<_bx>, unsigned char length<_cl>, unsigned char bat_x<_dil>, unsigned char bat_y<_dih> );
  479                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 199; extern void __fastcall put_raw( unsigned int data<_bx>, unsigned char bat_x<_dil>, unsigned char bat_y<_dih> );
  480                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 201; #endif // __HUCC__
  481                        		.dbg	line,	"..\..\..\include\hucc\hucc-gfx.h", 203; #endif // _hucc_gfx_h
  482                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 36; #include "hucc-string.h"
  483                        		.dbg	line,	"..\..\..\include\hucc\hucc-string.h", 1; #ifndef _hucc_string_h
  484                        		.dbg	line,	"..\..\..\include\hucc\hucc-string.h", 2; #define _hucc_string_h
  485                        		.dbg	line,	"..\..\..\include\hucc\hucc-string.h", 4; /****************************************************************************
  486                        		.dbg	line,	"..\..\..\include\hucc\hucc-string.h", 5; ; ***************************************************************************
  487                        		.dbg	line,	"..\..\..\include\hucc\hucc-string.h", 6; ;
  488                        		.dbg	line,	"..\..\..\include\hucc\hucc-string.h", 7; ; hucc-string.h
  489                        		.dbg	line,	"..\..\..\include\hucc\hucc-string.h", 8; ;
  490                        		.dbg	line,	"..\..\..\include\hucc\hucc-string.h", 9; ; Not-quite-standard, but fast, replacements for <string.h>.
  491                        		.dbg	line,	"..\..\..\include\hucc\hucc-string.h", 10; ;
  492                        		.dbg	line,	"..\..\..\include\hucc\hucc-string.h", 11; ; Copyright John Brandwood 2024.
  493                        		.dbg	line,	"..\..\..\include\hucc\hucc-string.h", 12; ;
  494                        		.dbg	line,	"..\..\..\include\hucc\hucc-string.h", 13; ; Distributed under the Boost Software License, Version 1.0.
  495                        		.dbg	line,	"..\..\..\include\hucc\hucc-string.h", 14; ; (See accompanying file LICENSE_1_0.txt or copy at
  496                        		.dbg	line,	"..\..\..\include\hucc\hucc-string.h", 15; ;  http://www.boost.org/LICENSE_1_0.txt)
  497                        		.dbg	line,	"..\..\..\include\hucc\hucc-string.h", 16; ;
  498                        		.dbg	line,	"..\..\..\include\hucc\hucc-string.h", 17; ; ***************************************************************************
  499                        		.dbg	line,	"..\..\..\include\hucc\hucc-string.h", 18; ; ***************************************************************************
  500                        		.dbg	line,	"..\..\..\include\hucc\hucc-string.h", 19; ;
  501                        		.dbg	line,	"..\..\..\include\hucc\hucc-string.h", 20; ; !!! WARNING : non-standard return values !!!
  502                        		.dbg	line,	"..\..\..\include\hucc\hucc-string.h", 21; ;
  503                        		.dbg	line,	"..\..\..\include\hucc\hucc-string.h", 22; ; Strings are limited to a maximum of 255 characters (+ the terminator)!
  504                        		.dbg	line,	"..\..\..\include\hucc\hucc-string.h", 23; ;
  505                        		.dbg	line,	"..\..\..\include\hucc\hucc-string.h", 24; ; The memcpy(), strcpy() and strcat() functions do NOT return the destination
  506                        		.dbg	line,	"..\..\..\include\hucc\hucc-string.h", 25; ; address, and they are declared "void" to check that the value is not used.
  507                        		.dbg	line,	"..\..\..\include\hucc\hucc-string.h", 26; ;
  508                        		.dbg	line,	"..\..\..\include\hucc\hucc-string.h", 27; ; mempcpy() is provided which returns the end address instead of the starting
  509                        		.dbg	line,	"..\..\..\include\hucc\hucc-string.h", 28; ; address, because this is typically more useful.
  510                        		.dbg	line,	"..\..\..\include\hucc\hucc-string.h", 29; ;
  511                        		.dbg	line,	"..\..\..\include\hucc\hucc-string.h", 30; ; Please note that both memcpy() and memset() are implemented using a TII for
  512                        		.dbg	line,	"..\..\..\include\hucc\hucc-string.h", 31; ; speed, and so the length should be < 16 bytes if used in time-critical bits
  513                        		.dbg	line,	"..\..\..\include\hucc\hucc-string.h", 32; ; of code (such as when using a split screen) because they delay interrupts.
  514                        		.dbg	line,	"..\..\..\include\hucc\hucc-string.h", 33; ;
  515                        		.dbg	line,	"..\..\..\include\hucc\hucc-string.h", 34; ; strncpy() and strncat() are not provided, because strncpy() was not created
  516                        		.dbg	line,	"..\..\..\include\hucc\hucc-string.h", 35; ; for the purpose of avoiding string overruns, and strncat() is just a poorly
  517                        		.dbg	line,	"..\..\..\include\hucc\hucc-string.h", 36; ; designed function IMHO.
  518                        		.dbg	line,	"..\..\..\include\hucc\hucc-string.h", 37; ;
  519                        		.dbg	line,	"..\..\..\include\hucc\hucc-string.h", 38; ; POSIX strlcpy() and strlcat() are provided instead, but once again they are
  520                        		.dbg	line,	"..\..\..\include\hucc\hucc-string.h", 39; ; slightly non-standard in that the return value when there is an overflow is
  521                        		.dbg	line,	"..\..\..\include\hucc\hucc-string.h", 40; ; the buffer size (so that the overflow can be detected), instead of the full
  522                        		.dbg	line,	"..\..\..\include\hucc\hucc-string.h", 41; ; size of the destination string that was too big to fit in the buffer.
  523                        		.dbg	line,	"..\..\..\include\hucc\hucc-string.h", 42; ;
  524                        		.dbg	line,	"..\..\..\include\hucc\hucc-string.h", 43; ; ***************************************************************************
  525                        		.dbg	line,	"..\..\..\include\hucc\hucc-string.h", 44; ; **************************************************************************/
  526                        		.dbg	line,	"..\..\..\include\hucc\hucc-string.h", 46; // *************
  527                        		.dbg	line,	"..\..\..\include\hucc\hucc-string.h", 47; // Functions in hucc-string.asm ...
  528                        		.dbg	line,	"..\..\..\include\hucc\hucc-string.h", 48; // *************
  529                        		.dbg	line,	"..\..\..\include\hucc\hucc-string.h", 50; #ifdef __HUCC__
  530                        		.dbg	line,	"..\..\..\include\hucc\hucc-string.h", 52; #asmdef	HUCC_USES_STRING 1
  531               0001     	HUCC_USES_STRING = 1
  532                        		.dbg	line,	"..\..\..\include\hucc\hucc-string.h", 54; extern void __fastcall strcpy( char *destination<_di>, char *source<_bp> );
  533                        		.dbg	line,	"..\..\..\include\hucc\hucc-string.h", 55; extern void __fastcall strcat( char *destination<_di>, char *source<_bp> );
  534                        		.dbg	line,	"..\..\..\include\hucc\hucc-string.h", 57; extern unsigned int __fastcall strlen( char *source<_bp> );
  535                        		.dbg	line,	"..\..\..\include\hucc\hucc-string.h", 59; extern unsigned int __fastcall strlcpy( char *destination<_di>, char *source<_bp>, unsigned char size<acc> );
  536                        		.dbg	line,	"..\..\..\include\hucc\hucc-string.h", 60; extern unsigned int __fastcall strlcat( char *destination<_di>, char *source<_bp>, unsigned char size<acc> );
  537                        		.dbg	line,	"..\..\..\include\hucc\hucc-string.h", 62; extern void __fastcall memcpy( unsigned char *destination<ram_tii_dst>, unsigned char *source<ram_tii_src>, unsigned int count<acc> );
  538                        		.dbg	line,	"..\..\..\include\hucc\hucc-string.h", 63; extern void __fastcall farmemcpy( unsigned char *destination<ram_tii_dst>, unsigned char __far *source<_bp_bank:ram_tii_src>, unsigned int count<acc> );
  539                        		.dbg	line,	"..\..\..\include\hucc\hucc-string.h", 64; extern void __fastcall far_memcpy( unsigned char *destination<ram_tii_dst>, unsigned int count<acc> );
  540                        		.dbg	line,	"..\..\..\include\hucc\hucc-string.h", 66; extern unsigned char * __fastcall mempcpy( unsigned char *destination<ram_tii_dst>, unsigned char *source<ram_tii_src>, unsigned int count<acc> );
  541                        		.dbg	line,	"..\..\..\include\hucc\hucc-string.h", 67; extern unsigned char * __fastcall farmempcpy( unsigned char *destination<ram_tii_dst>, unsigned char __far *source<_bp_bank:ram_tii_src>, unsigned int count<acc> );
  542                        		.dbg	line,	"..\..\..\include\hucc\hucc-string.h", 68; extern unsigned char * __fastcall far_mempcpy( unsigned char *destination<ram_tii_dst>, unsigned int count<acc> );
  543                        		.dbg	line,	"..\..\..\include\hucc\hucc-string.h", 70; extern void __fastcall memset( unsigned char *destination<ram_tii_src>, unsigned char value<_al>, unsigned int count<acc> );
  544                        		.dbg	line,	"..\..\..\include\hucc\hucc-string.h", 72; //  0 	if strings are equal
  545                        		.dbg	line,	"..\..\..\include\hucc\hucc-string.h", 73; //  1 	if the first non-matching character in string1 > string2 (in ASCII).
  546                        		.dbg	line,	"..\..\..\include\hucc\hucc-string.h", 74; // -1 	if the first non-matching character in string1 < string2 (in ASCII).
  547                        		.dbg	line,	"..\..\..\include\hucc\hucc-string.h", 76; extern int __fastcall strcmp( char *string1<_di>, char *string2<_bp> );
  548                        		.dbg	line,	"..\..\..\include\hucc\hucc-string.h", 77; extern int __fastcall strncmp( char *string1<_di>, char *string2<_bp>, unsigned int count<_ax> );
  549                        		.dbg	line,	"..\..\..\include\hucc\hucc-string.h", 79; extern int __fastcall __macro memcmp( unsigned char *string1<_di>, unsigned char *string2<_bp>, unsigned int count<acc> );
  550                        		.dbg	line,	"..\..\..\include\hucc\hucc-string.h", 80; extern int __fastcall farmemcmp( unsigned char *string1<_di>, unsigned char __far *string2<_bp_bank:_bp>, unsigned int count<acc> );
  551                        		.dbg	line,	"..\..\..\include\hucc\hucc-string.h", 81; extern int __fastcall far_memcmp( unsigned char *string1<_di>, unsigned int count<acc> );
  552                        		.dbg	line,	"..\..\..\include\hucc\hucc-string.h", 83; #endif // __HUCC__
  553                        		.dbg	line,	"..\..\..\include\hucc\hucc-string.h", 85; #endif // _hucc_string_h
  554                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 37; #include "hucc-old-scroll.h"
  555                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-scroll.h", 1; #ifndef _hucc_old_scroll_h
  556                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-scroll.h", 2; #define _hucc_old_scroll_h
  557                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-scroll.h", 4; /****************************************************************************
  558                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-scroll.h", 5; ; ***************************************************************************
  559                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-scroll.h", 6; ;
  560                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-scroll.h", 7; ; hucc-old-scroll.h
  561                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-scroll.h", 8; ;
  562                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-scroll.h", 9; ; Based on the original HuC and MagicKit functions by David Michel and the
  563                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-scroll.h", 10; ; other original HuC developers.
  564                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-scroll.h", 11; ;
  565                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-scroll.h", 12; ; Modifications copyright John Brandwood 2024.
  566                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-scroll.h", 13; ;
  567                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-scroll.h", 14; ; Distributed under the Boost Software License, Version 1.0.
  568                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-scroll.h", 15; ; (See accompanying file LICENSE_1_0.txt or copy at
  569                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-scroll.h", 16; ;  http://www.boost.org/LICENSE_1_0.txt)
  570                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-scroll.h", 17; ;
  571                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-scroll.h", 18; ; ***************************************************************************
  572                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-scroll.h", 19; ; ***************************************************************************
  573                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-scroll.h", 20; ;
  574                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-scroll.h", 21; ; HuC's old scrolling library is provided for use with existing HuC projects,
  575                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-scroll.h", 22; ; but it should preferably be avoided in new projects because it is slow and
  576                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-scroll.h", 23; ; forever limited by its choice to handle gaps between areas, and sorting.
  577                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-scroll.h", 24; ;
  578                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-scroll.h", 25; ; HuCC's new scrolling library puts the responibility for defining both gaps
  579                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-scroll.h", 26; ; and the display order into the project's hands, but in return it runs much
  580                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-scroll.h", 27; ; faster, using less than 1/6 of the processing time in VBLANK, and far less
  581                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-scroll.h", 28; ; time in the RCR interrputs themselves. It also supports the 2nd SuperGRAFX
  582                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-scroll.h", 29; ; screen layer, which HuC's old scrolling library ignores.
  583                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-scroll.h", 30; ;
  584                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-scroll.h", 31; ; ***************************************************************************
  585                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-scroll.h", 32; ; **************************************************************************/
  586                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-scroll.h", 34; // *************
  587                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-scroll.h", 35; // Functions in hucc-old-scroll.asm ...
  588                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-scroll.h", 36; // *************
  589                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-scroll.h", 38; #ifdef __HUCC__
  590                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-scroll.h", 40; #asmdef	HUCC_USES_OLD_SCROLL 1
  591               0001     	HUCC_USES_OLD_SCROLL = 1
  592                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-scroll.h", 42; extern void __fastcall scroll( unsigned char num<_al>, unsigned int x<_cx>, unsigned int y<_dx>, unsigned char top<_ah>, unsigned char bottom<_bl>, unsigned char disp<acc> );
  593                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-scroll.h", 43; extern void __fastcall scroll_disable( unsigned char num<acc> );
  594                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-scroll.h", 45; #endif // __HUCC__
  595                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-scroll.h", 47; #endif // _hucc_old_scroll_h
  596                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 38; #include "hucc-old-spr.h"
  597                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-spr.h", 1; #ifndef _hucc_old_spr_h
  598                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-spr.h", 2; #define _hucc_old_spr_h
  599                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-spr.h", 4; /****************************************************************************
  600                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-spr.h", 5; ; ***************************************************************************
  601                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-spr.h", 6; ;
  602                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-spr.h", 7; ; hucc-old-spr.h
  603                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-spr.h", 8; ;
  604                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-spr.h", 9; ; Based on the original HuC and MagicKit functions by David Michel and the
  605                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-spr.h", 10; ; other original HuC developers.
  606                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-spr.h", 11; ;
  607                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-spr.h", 12; ; Modifications copyright John Brandwood 2024.
  608                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-spr.h", 13; ;
  609                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-spr.h", 14; ; Distributed under the Boost Software License, Version 1.0.
  610                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-spr.h", 15; ; (See accompanying file LICENSE_1_0.txt or copy at
  611                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-spr.h", 16; ;  http://www.boost.org/LICENSE_1_0.txt)
  612                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-spr.h", 17; ;
  613                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-spr.h", 18; ; ***************************************************************************
  614                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-spr.h", 19; ; **************************************************************************/
  615                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-spr.h", 21; // *************
  616                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-spr.h", 22; // Sprite defines ...
  617                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-spr.h", 23; // *************
  618                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-spr.h", 25; #define FLIP_X_MASK 0x08
  619                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-spr.h", 26; #define FLIP_Y_MASK 0x80
  620                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-spr.h", 27; #define FLIP_MAS    0x88
  621                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-spr.h", 28; #define SIZE_MAS    0x31
  622                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-spr.h", 30; #define NO_FLIP     0x00
  623                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-spr.h", 31; #define NO_FLIP_X   0x00
  624                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-spr.h", 32; #define NO_FLIP_Y   0x00
  625                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-spr.h", 33; #define FLIP_X      0x08
  626                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-spr.h", 34; #define FLIP_Y      0x80
  627                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-spr.h", 35; #define SZ_16x16    0x00
  628                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-spr.h", 36; #define SZ_16x32    0x10
  629                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-spr.h", 37; #define SZ_16x64    0x30
  630                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-spr.h", 38; #define SZ_32x16    0x01
  631                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-spr.h", 39; #define SZ_32x32    0x11
  632                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-spr.h", 40; #define	SZ_32x64    0x31
  633                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-spr.h", 42; // *************
  634                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-spr.h", 43; // Functions in hucc-old-spr.asm ...
  635                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-spr.h", 44; // *************
  636                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-spr.h", 46; #ifdef __HUCC__
  637                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-spr.h", 48; #asmdef	HUCC_USES_OLD_SPR 1
  638               0001     	HUCC_USES_OLD_SPR = 1
  639                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-spr.h", 50; extern void __fastcall init_satb( void );
  640                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-spr.h", 51; extern void __fastcall reset_satb( void );
  641                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-spr.h", 52; extern void __fastcall satb_update( void );
  642                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-spr.h", 53; extern void __fastcall spr_set( unsigned char num<acc> );
  643                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-spr.h", 54; extern void __fastcall spr_hide( void );
  644                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-spr.h", 55; extern void __fastcall spr_show( void );
  645                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-spr.h", 56; extern void __fastcall spr_x( unsigned int value<acc> );
  646                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-spr.h", 57; extern void __fastcall spr_y( unsigned int value<acc> );
  647                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-spr.h", 58; extern void __fastcall spr_pattern( unsigned int vaddr<acc> );
  648                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-spr.h", 59; extern void __fastcall spr_ctrl( unsigned char mask<_al>, unsigned char value<acc> );
  649                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-spr.h", 60; extern void __fastcall spr_pal( unsigned char palette<acc> );
  650                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-spr.h", 61; extern void __fastcall spr_pri( unsigned char priority<acc> );
  651                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-spr.h", 63; extern unsigned int __fastcall spr_get_x( void );
  652                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-spr.h", 64; extern unsigned int __fastcall spr_get_y( void );
  653                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-spr.h", 66; extern void __fastcall sgx_init_satb( void );
  654                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-spr.h", 67; extern void __fastcall sgx_reset_satb( void );
  655                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-spr.h", 68; extern void __fastcall sgx_satb_update( void );
  656                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-spr.h", 69; extern void __fastcall sgx_spr_set( unsigned char num<acc> );
  657                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-spr.h", 70; extern void __fastcall sgx_spr_hide( void );
  658                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-spr.h", 71; extern void __fastcall sgx_spr_show( void );
  659                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-spr.h", 72; extern void __fastcall sgx_spr_x( unsigned int value<acc> );
  660                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-spr.h", 73; extern void __fastcall sgx_spr_y( unsigned int value<acc> );
  661                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-spr.h", 74; extern void __fastcall sgx_spr_pattern( unsigned int vaddr<acc> );
  662                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-spr.h", 75; extern void __fastcall sgx_spr_ctrl( unsigned char mask<_al>, unsigned char value<acc> );
  663                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-spr.h", 76; extern void __fastcall sgx_spr_pal( unsigned char palette<acc> );
  664                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-spr.h", 77; extern void __fastcall sgx_spr_pri( unsigned char priority<acc> );
  665                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-spr.h", 79; extern unsigned int __fastcall sgx_spr_get_x( void );
  666                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-spr.h", 80; extern unsigned int __fastcall sgx_spr_get_y( void );
  667                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-spr.h", 82; #endif // __HUCC__
  668                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-spr.h", 84; #endif // _hucc_old_spr_h
  669                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 39; #include "hucc-old-map.h"
  670                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-map.h", 1; #ifndef _hucc_old_map_h
  671                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-map.h", 2; #define _hucc_old_map_h
  672                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-map.h", 4; /****************************************************************************
  673                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-map.h", 5; ; ***************************************************************************
  674                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-map.h", 6; ;
  675                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-map.h", 7; ; hucc-old-map.h
  676                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-map.h", 8; ;
  677                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-map.h", 9; ; Based on the original HuC and MagicKit functions by David Michel and the
  678                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-map.h", 10; ; other original HuC developers.
  679                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-map.h", 11; ;
  680                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-map.h", 12; ; Modifications copyright John Brandwood 2024.
  681                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-map.h", 13; ;
  682                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-map.h", 14; ; Distributed under the Boost Software License, Version 1.0.
  683                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-map.h", 15; ; (See accompanying file LICENSE_1_0.txt or copy at
  684                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-map.h", 16; ;  http://www.boost.org/LICENSE_1_0.txt)
  685                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-map.h", 17; ;
  686                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-map.h", 18; ; ***************************************************************************
  687                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-map.h", 19; ; **************************************************************************/
  688                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-map.h", 21; // *************
  689                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-map.h", 22; // Functions in hucc-old-map.asm ...
  690                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-map.h", 23; // *************
  691                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-map.h", 25; #ifdef __HUCC__
  692                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-map.h", 27; #asmdef	HUCC_USES_OLD_MAP 1
  693               0001     	HUCC_USES_OLD_MAP = 1
  694                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-map.h", 29; extern void __fastcall set_tile_address( unsigned int vram<_di> );
  695                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-map.h", 30; extern void __fastcall sgx_set_tile_address( unsigned int vram<_di> );
  696                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-map.h", 32; extern void __fastcall __nop set_tile_data( unsigned char __far *tiles<vdc_tile_bank:vdc_tile_addr>, unsigned char num_tiles<vdc_num_tiles>, unsigned char __far *palette_table<vdc_attr_bank:vdc_attr_addr>, unsigned char tile_type<vdc_tile_type> );
  697                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-map.h", 33; extern void __fastcall __nop sgx_set_tile_data( unsigned char __far *tiles<sgx_tile_bank:sgx_tile_addr>, unsigned char num_tiles<sgx_num_tiles>, unsigned char __far *palette_table<sgx_attr_bank:sgx_attr_addr>, unsigned char tile_type<sgx_tile_type> );
  698                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-map.h", 35; extern void __fastcall __nop set_far_tile_data( unsigned char tile_bank<vdc_tile_bank>, unsigned char *tile_addr<vdc_tile_addr>, unsigned char num_tiles<vdc_num_tiles>, unsigned char palette_table_bank<vdc_attr_bank>, unsigned char *palette_table_addr<vdc_attr_addr>, unsigned char tile_type<vdc_tile_type> );
  699                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-map.h", 36; extern void __fastcall __nop sgx_set_far_tile_data( unsigned char tile_bank<sgx_tile_bank>, unsigned char *tile_addr<sgx_tile_addr>, unsigned char num_tiles<sgx_num_tiles>, unsigned char palette_table_bank<sgx_attr_bank>, unsigned char *palette_table_addr<sgx_attr_addr>, unsigned char tile_type<sgx_tile_type> );
  700                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-map.h", 38; extern void __fastcall __nop set_map_data( unsigned char __far *map<vdc_map_bank:vdc_map_addr>, unsigned char w<vdc_map_width>, unsigned char h<vdc_map_height> );
  701                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-map.h", 39; extern void __fastcall __nop sgx_set_map_data( unsigned char __far *map<sgx_map_bank:sgx_map_addr>, unsigned char w<sgx_map_width>, unsigned char h<sgx_map_height> );
  702                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-map.h", 41; extern void __fastcall __nop set_far_map_data( unsigned char map_bank<vdc_map_bank>, unsigned char *map_addr<vdc_map_addr>, unsigned char w<vdc_map_width>, unsigned char h<vdc_map_height> );
  703                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-map.h", 42; extern void __fastcall __nop sgx_set_far_map_data( unsigned char map_bank<vdc_map_bank>, unsigned char *map_addr<vdc_map_addr>, unsigned char w<sgx_map_width>, unsigned char h<sgx_map_height> );
  704                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-map.h", 44; extern void __fastcall load_tile( unsigned int vram<_di> );
  705                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-map.h", 45; extern void __fastcall sgx_load_tile( unsigned int vram<_di> );
  706                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-map.h", 47; extern void __fastcall load_map( unsigned char bat_x<_al>, unsigned char bat_y<_ah>, int map_x<_bx>, int map_y<_dx>, unsigned char tiles_w<_cl>, unsigned char tiles_h<_ch> );
  707                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-map.h", 48; extern void __fastcall sgx_load_map( unsigned char bat_x<_al>, unsigned char bat_y<_ah>, int map_x<_bx>, int map_y<_dx>, unsigned char tiles_w<_cl>, unsigned char tiles_h<_ch> );
  708                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-map.h", 50; extern unsigned char __fastcall map_get_tile( unsigned char map_x<_bl>, unsigned char map_y<_bh> );
  709                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-map.h", 51; extern unsigned char __fastcall sgx_map_get_tile( unsigned char map_x<_bl>, unsigned char map_y<_bh> );
  710                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-map.h", 53; extern void __fastcall map_put_tile( unsigned char map_x<_bl>, unsigned char map_y<_bh>, unsigned char tile<_al> );
  711                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-map.h", 54; extern void __fastcall sgx_map_put_tile( unsigned char map_x<_bl>, unsigned char map_y<_bh>, unsigned char tile<_al> );
  712                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-map.h", 56; extern void __fastcall put_tile( unsigned char tile<_bl>, unsigned char bat_x<_al>, unsigned char bat_y<_ah> );
  713                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-map.h", 57; extern void __fastcall sgx_put_tile( unsigned char tile<_bl>, unsigned char bat_x<_al>, unsigned char bat_y<_ah> );
  714                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-map.h", 59; // Deprecated functions ...
  715                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-map.h", 61; extern void __fastcall set_tile_data( unsigned char *tile_ex<_di> );
  716                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-map.h", 63; extern void __fastcall __nop set_map_pals( unsigned char __far *palette_table<vdc_attr_bank:vdc_attr_addr> );
  717                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-map.h", 64; extern void __fastcall __nop set_map_tile_type( unsigned char tile_type<vdc_tile_type> );
  718                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-map.h", 66; extern void __fastcall __nop sgx_set_map_pals( unsigned char __far *palette_table<sgx_attr_bank:sgx_attr_addr> );
  719                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-map.h", 67; extern void __fastcall __nop sgx_set_map_tile_type( unsigned char tile_type<sgx_tile_type> );
  720                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-map.h", 69; extern void __fastcall set_map_tile_base( unsigned int vram<_di> );
  721                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-map.h", 70; extern void __fastcall sgx_set_map_tile_base( unsigned int vram<_di> );
  722                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-map.h", 72; #endif // __HUCC__
  723                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-map.h", 74; #endif // _hucc_old_map_h
  724                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 40; #include "hucc-old-line.h"
  725                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-line.h", 1; #ifndef _hucc_old_line_h
  726                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-line.h", 2; #define _hucc_old_line_h
  727                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-line.h", 4; /****************************************************************************
  728                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-line.h", 5; ; ***************************************************************************
  729                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-line.h", 6; ;
  730                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-line.h", 7; ; hucc-old-line.h
  731                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-line.h", 8; ;
  732                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-line.h", 9; ; Based on the original HuC and MagicKit functions by David Michel and the
  733                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-line.h", 10; ; other original HuC developers.
  734                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-line.h", 11; ;
  735                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-line.h", 12; ; Modifications copyright John Brandwood 2024.
  736                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-line.h", 13; ;
  737                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-line.h", 14; ; Distributed under the Boost Software License, Version 1.0.
  738                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-line.h", 15; ; (See accompanying file LICENSE_1_0.txt or copy at
  739                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-line.h", 16; ;  http://www.boost.org/LICENSE_1_0.txt)
  740                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-line.h", 17; ;
  741                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-line.h", 18; ; ***************************************************************************
  742                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-line.h", 19; ; **************************************************************************/
  743                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-line.h", 21; // *************
  744                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-line.h", 22; // Functions in hucc-old-line.asm ...
  745                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-line.h", 23; // *************
  746                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-line.h", 25; #ifdef __HUCC__
  747                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-line.h", 27; #asmdef	HUCC_USES_OLD_LINE 1
  748               0001     	HUCC_USES_OLD_LINE = 1
  749                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-line.h", 29; extern void __fastcall gfx_init( unsigned int start_vram_addr<_ax> );
  750                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-line.h", 30; extern void __fastcall gfx_clear( unsigned int start_vram_addr<_di> );
  751                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-line.h", 31; extern void __fastcall gfx_plot( unsigned int x<_gfx_x1>, unsigned int y<_gfx_y1>, char color<_gfx_color> );
  752                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-line.h", 32; extern void __fastcall gfx_line( unsigned int x1<_gfx_x1>, unsigned int y1<_gfx_y1>, unsigned int x2<_gfx_x2>, unsigned int y2<_gfx_y2>, unsigned char color<_gfx_color> );
  753                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-line.h", 34; #endif // __HUCC__
  754                        		.dbg	line,	"..\..\..\include\hucc\hucc-old-line.h", 36; #endif // _hucc_old_line_h
  755                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 42; #endif // _hucc_legacy_h
  756                        		.dbg	line,	"main.c", 1; #include "huc.h"
  757                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 1; #ifndef _hucc_legacy_h
  758                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 2; #define _hucc_legacy_h
  759                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 4; /****************************************************************************
  760                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 5; ; ***************************************************************************
  761                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 6; ;
  762                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 7; ; huc.h
  763                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 8; ;
  764                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 9; ; HuCC wrapper file to include a default set of HuC-compatible functions.
  765                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 10; ;
  766                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 11; ; Copyright John Brandwood 2024.
  767                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 12; ;
  768                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 13; ; Distributed under the Boost Software License, Version 1.0.
  769                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 14; ; (See accompanying file LICENSE_1_0.txt or copy at
  770                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 15; ;  http://www.boost.org/LICENSE_1_0.txt)
  771                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 16; ;
  772                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 17; ; ***************************************************************************
  773                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 18; ; ***************************************************************************
  774                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 19; ;
  775                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 20; ; When the HuCC compiler is invoked with the "--legacy" option to compile old
  776                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 21; ; projects, then this "huc.h" file is automatically included.
  777                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 22; ;
  778                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 23; ; This file includes a set of the individual HuCC headers which correspond to
  779                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 24; ; HuC's built-in functions and MagicKit library.
  780                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 25; ;
  781                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 26; ; New HuCC projects should, preferably, include the specific headers that are
  782                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 27; ; needed, which will then allow them to replace parts of the standard library
  783                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 28; ; with newer functions, or they can just manually include this "huc.h" file.
  784                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 29; ;
  785                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 30; ; ***************************************************************************
  786                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 31; ; **************************************************************************/
  787                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 33; #include "hucc-systemcard.h"
  788                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 34; #include "hucc-baselib.h"
  789                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 35; #include "hucc-gfx.h"
  790                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 36; #include "hucc-string.h"
  791                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 37; #include "hucc-old-scroll.h"
  792                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 38; #include "hucc-old-spr.h"
  793                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 39; #include "hucc-old-map.h"
  794                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 40; #include "hucc-old-line.h"
  795                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 42; #endif // _hucc_legacy_h
  796                        		.dbg	line,	"main.c", 2; #include "hucc-scroll.h"
  797                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 1; #ifndef _hucc_scroll_h
  798                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 2; #define _hucc_scroll_h
  799                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 4; /****************************************************************************
  800                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 5; ; ***************************************************************************
  801                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 6; ;
  802                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 7; ; hucc-scroll.h
  803                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 8; ;
  804                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 9; ; Routines for a fast split-screen scrolling system.
  805                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 10; ;
  806                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 11; ; Copyright John Brandwood 2024.
  807                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 12; ;
  808                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 13; ; Distributed under the Boost Software License, Version 1.0.
  809                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 14; ; (See accompanying file LICENSE_1_0.txt or copy at
  810                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 15; ;  http://www.boost.org/LICENSE_1_0.txt)
  811                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 16; ;
  812                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 17; ; ***************************************************************************
  813                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 18; ; ***************************************************************************
  814                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 19; ;
  815                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 20; ; The maximum number of splits for each screen layer is set in your project's
  816                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 21; ; "hucc-config.inc" file, with the library having a limit of 128-per-layer.
  817                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 22; ;
  818                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 23; ; Your first active split must be defined to start at screen line 0, and then
  819                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 24; ; the rest of the active splits must be in increasing line order to match the
  820                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 25; ; way that the PC Engine displays the output image.
  821                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 26; ;
  822                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 27; ; You can have disabled splits interleaved with your active splits.
  823                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 28; ;
  824                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 29; ; Splits that are normally disabled can be used to create full screen effects
  825                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 30; ; such as bouncing the screen up and down by adding blank areas at the top or
  826                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 31; ; bottom of the screen, and then rapidly changing the height of those areas.
  827                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 32; ;
  828                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 33; ; ***************************************************************************
  829                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 34; ; **************************************************************************/
  830                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 36; // *************
  831                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 37; // VDC bits for display_flags ...
  832                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 38; // *************
  833                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 40; #ifndef BKG_OFF
  834                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 41; #define BKG_OFF 0x00
  835                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 42; #endif
  836                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 44; #ifndef SPR_OFF
  837                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 45; #define SPR_OFF 0x00
  838                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 46; #endif
  839                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 48; #ifndef BKG_ON
  840                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 49; #define BKG_ON 0x80
  841                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 50; #endif
  842                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 52; #ifndef SPR_ON
  843                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 53; #define SPR_ON 0x40
  844                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 54; #endif
  845                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 56; // *************
  846                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 57; // Functions in hucc-scroll.asm ...
  847                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 58; // *************
  848                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 60; #ifdef __HUCC__
  849                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 62; #asmdef	HUCC_USES_NEW_SCROLL 1
  850               0001     	HUCC_USES_NEW_SCROLL = 1
  851                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 64; extern void __fastcall scroll_split( unsigned char index<_al>, unsigned char screen_line<_ah>, unsigned int bat_x<_bx>, unsigned int bat_y<_cx>, unsigned char display_flags<_dl> );
  852                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 65; extern void __fastcall sgx_scroll_split( unsigned char index<_al>, unsigned char screen_line<_ah>, unsigned int bat_x<_bx>, unsigned int bat_y<_cx>, unsigned char display_flags<_dl> );
  853                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 67; extern void __fastcall disable_split( unsigned char index<acc> );
  854                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 68; extern void __fastcall sgx_disable_split( unsigned char index<acc> );
  855                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 70; extern void __fastcall __macro disable_all_splits( void );
  856                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 71; extern void __fastcall __macro sgx_disable_all_splits( void );
  857                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 73; #asm
  858                        		.dbg	clear
  859                        			.macro	_disable_all_splits
  860                        			ldy	#HUCC_PCE_SPLITS - 1
  861                        	!loop:		tya
  862                        			call	_disable_split.1
  863                        			dey
  864                        			bpl	!loop-
  865                        			.endm
  866                        			.macro	_sgx_disable_all_splits
  867                        			ldy	#HUCC_SGX_SPLITS - 1
  868                        	!loop:		tya
  869                        			call	_sgx_disable_split.1
  870                        			dey
  871                        			bpl	!loop-
  872                        			.endm
  873                        	
  874                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 89; #endasm
  875                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 91; #endif // __HUCC__
  876                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 93; #endif // _hucc_scroll_h
  877                        		.dbg	line,	"main.c", 3; #include "hucc-chrmap.h"
  878                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 1; #ifndef _hucc_chrmap_h
  879                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 2; #define _hucc_chrmap_h
  880                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 4; /****************************************************************************
  881                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 5; ; ***************************************************************************
  882                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 6; ;
  883                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 7; ; hucc-chrmap.h
  884                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 8; ;
  885                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 9; ; A simple map system based on 8x8 characters (aka "tiles") in BAT format.
  886                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 10; ;
  887                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 11; ; Copyright John Brandwood 2025.
  888                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 12; ;
  889                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 13; ; Distributed under the Boost Software License, Version 1.0.
  890                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 14; ; (See accompanying file LICENSE_1_0.txt or copy at
  891                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 15; ;  http://www.boost.org/LICENSE_1_0.txt)
  892                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 16; ;
  893                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 17; ; ***************************************************************************
  894                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 18; ; ***************************************************************************
  895                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 19; ;
  896                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 20; ; The maximum X and Y size for chrmaps is 256 characters (2048 pixels).
  897                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 21; ;
  898                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 22; ; The maximum total size for a chrmap is 16KBytes, which allows for maps up
  899                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 23; ; to 256x32 tiles (2048x256 pixels).
  900                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 24; ;
  901                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 25; ; ***************************************************************************
  902                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 26; ; **************************************************************************/
  903                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 28; // *************
  904                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 29; // This code extends the blkmap library ...
  905                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 30; // *************
  906                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 32; #include "hucc-blkmap.h"
  907                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 1; #ifndef _hucc_blkmap_h
  908                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 2; #define _hucc_blkmap_h
  909                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 4; /****************************************************************************
  910                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 5; ; ***************************************************************************
  911                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 6; ;
  912                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 7; ; hucc-blkmap.h
  913                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 8; ;
  914                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 9; ; A map system based on 16x16 meta-tiles (aka "blocks", aka CHR/BLK/MAP).
  915                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 10; ;
  916                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 11; ; Copyright John Brandwood 2025.
  917                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 12; ;
  918                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 13; ; Distributed under the Boost Software License, Version 1.0.
  919                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 14; ; (See accompanying file LICENSE_1_0.txt or copy at
  920                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 15; ;  http://www.boost.org/LICENSE_1_0.txt)
  921                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 16; ;
  922                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 17; ; ***************************************************************************
  923                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 18; ; ***************************************************************************
  924                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 19; ;
  925                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 20; ; The maximum X and Y size for blkmaps is 128 blocks (2048 pixels).
  926                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 21; ;
  927                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 22; ; The maximum total size for a blkmap is 16KBytes, which allows for maps up
  928                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 23; ; to 128x128 blocks (2048x2048 pixels).
  929                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 24; ;
  930                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 25; ; Huge multi-screen blkmaps are also supported (optionally).
  931                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 26; ;
  932                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 27; ; The maximum X and Y for multi-screen maps is 128 screens (32768 pixels).
  933                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 28; ;
  934                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 29; ; The maximum total size for a multi-screen map is 8KBytes, which allows for
  935                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 30; ; a total of 1024 screens.
  936                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 31; ;
  937                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 32; ; ***************************************************************************
  938                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 33; ; **************************************************************************/
  939                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 35; // *************
  940                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 36; // Functions in blkmap.asm ...
  941                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 37; // *************
  942                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 39; #ifdef __HUCC__
  943                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 41; #asmdef	HUCC_USES_BLKMAP 1
  944               0001     	HUCC_USES_BLKMAP = 1
  945                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 43; // Current top-left of drawn map in pixels.
  946                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 44; extern unsigned int   vdc_map_pxl_x;
  947                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 45; extern unsigned int   vdc_map_pxl_y;
  948                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 47; // Width and height to draw/scroll in characters (not tiles).
  949                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 48; extern unsigned char  vdc_map_draw_w;
  950                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 49; extern unsigned char  vdc_map_draw_h;
  951                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 51; // Width of map (or multi-screen BAT) in tiles.
  952                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 52; extern unsigned char  vdc_map_line_w;
  953                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 54; // Width of map in screens (if multi-screen map).
  954                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 55; extern unsigned char  vdc_map_scrn_w;
  955                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 57; // Extra information returned by get_map_block() and sgx_get_map_block(),
  956                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 58; // which are the collision flags and the mask/overlay sprite for the BLK.
  957                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 59; extern unsigned char  map_blk_flag;
  958                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 60; extern unsigned char  map_blk_mask;
  959                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 62; extern unsigned char  vdc_scr_bank;
  960                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 63; extern unsigned char *vdc_scr_addr;
  961                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 65; extern unsigned char  vdc_map_bank;
  962                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 66; extern unsigned char *vdc_map_addr;
  963                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 68; extern unsigned char  vdc_blk_bank;
  964                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 69; extern unsigned char *vdc_blk_addr;
  965                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 71; extern unsigned char  vdc_tbl_bank;
  966                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 72; extern unsigned char *vdc_tbl_addr;
  967                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 74; extern void __fastcall set_blocks( unsigned char __far *blk_def<vdc_blk_bank:vdc_blk_addr>, unsigned char __far *flg_def<vdc_tbl_bank:vdc_tbl_addr>, unsigned char number_of_blocks<_al> );
  968                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 75; extern void __fastcall __macro set_blkmap( unsigned char __far *blk_map<vdc_map_bank:vdc_map_addr>, unsigned char blocks_w<vdc_map_line_w> );
  969                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 76; extern void __fastcall __macro set_multimap( unsigned char __far *multi_map<vdc_scr_bank:vdc_scr_addr>, unsigned char screens_w<vdc_map_scrn_w> );
  970                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 78; extern void __fastcall draw_map( void );
  971                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 79; extern void __fastcall scroll_map( void );
  972                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 81; extern void __fastcall blit_map( unsigned char tile_x<map_bat_x>, unsigned char tile_y<map_bat_y>, unsigned char tile_w<map_draw_x>, unsigned char tile_h<map_draw_y> );
  973                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 83; extern unsigned char __fastcall get_map_block( unsigned int x<map_pxl_x>, unsigned int y<map_pxl_y> );
  974                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 85; #asm
  975                        		.dbg	clear
  976                        			.macro	_set_blkmap.2
  977                        			stz	vdc_scr_bank
  978                        			.endm
  979                        			.macro	_set_multimap.2
  980                        			lda	vdc_bat_width
  981                        			lsr	a
  982                        			sta	vdc_map_line_w
  983                        			.endm
  984                        			.macro	SCREEN
  985                        			db	(((\1) & $1FFF) | $6000) >> 8, bank(\1)
  986                        			db	(((\2) & $1FFF) | $4000) >> 8, bank(\2)
  987                        			db	(((\3) & $1FFF) | $6000) >> 8, bank(\3)
  988                        			dw	(\4)
  989                        			.endm
  990                        	
  991                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 102; #endasm
  992                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 104; #ifdef _SGX
  993                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 106; // Current top-left of drawn map in pixels.
  994                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 107; extern unsigned int   sgx_map_pxl_x;
  995                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 108; extern unsigned int   sgx_map_pxl_y;
  996                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 110; // Width and height to draw/scroll in characters (not tiles).
  997                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 111; extern unsigned char  sgx_map_draw_w;
  998                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 112; extern unsigned char  sgx_map_draw_h;
  999                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 114; // Width of map (or multi-screen BAT) in tiles.
 1000                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 115; extern unsigned char  sgx_map_line_w;
 1001                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 117; // Width of map in screens (if multi-screen map).
 1002                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 118; extern unsigned char  sgx_map_scrn_w;
 1003                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 120; extern unsigned char  sgx_scr_bank;
 1004                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 121; extern unsigned char *sgx_scr_addr;
 1005                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 123; extern unsigned char  sgx_map_bank;
 1006                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 124; extern unsigned char *sgx_map_addr;
 1007                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 126; extern unsigned char  sgx_blk_bank;
 1008                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 127; extern unsigned char *sgx_blk_addr;
 1009                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 129; extern unsigned char  sgx_tbl_bank;
 1010                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 130; extern unsigned char *sgx_tbl_addr;
 1011                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 132; extern void __fastcall sgx_set_blocks( unsigned char __far *blk_def<sgx_blk_bank:sgx_blk_addr>, unsigned char __far *flg_def<sgx_tbl_bank:sgx_tbl_addr>, unsigned char number_of_blocks<_al> );
 1012                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 133; extern void __fastcall __macro sgx_set_blkmap( unsigned char __far *blk_map<sgx_map_bank:sgx_map_addr>, unsigned char blocks_w<sgx_map_line_w> );
 1013                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 134; extern void __fastcall __macro sgx_set_multimap( unsigned char __far *multi_map<sgx_scr_bank:sgx_scr_addr>, unsigned char screens_w<sgx_map_scrn_w> );
 1014                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 136; extern void __fastcall sgx_draw_map( void );
 1015                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 137; extern void __fastcall sgx_scroll_map( void );
 1016                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 139; extern void __fastcall sgx_blit_map( unsigned char tile_x<map_bat_x>, unsigned char tile_y<map_bat_y>, unsigned char tile_w<map_draw_x>, unsigned char tile_h<map_draw_y> );
 1017                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 141; extern unsigned char __fastcall sgx_get_map_block( unsigned int x<map_pxl_x>, unsigned int y<map_pxl_y> );
 1018                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 143; #asm
 1019                        		.dbg	clear
 1020                        			.macro	_sgx_set_blkmap.2
 1021                        			stz	sgx_scr_bank
 1022                        			.endm
 1023                        			.macro	_sgx_set_multimap.2
 1024                        			lda	sgx_bat_width
 1025                        			lsr	a
 1026                        			sta	sgx_map_line_w
 1027                        			.endm
 1028                        	
 1029                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 153; #endasm
 1030                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 155; #endif
 1031                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 157; #endif // __HUCC__
 1032                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 159; #endif // _hucc_blkmap_h
 1033                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 34; // *************
 1034                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 35; // Functions in chrmap.asm ...
 1035                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 36; // *************
 1036                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 38; #ifdef __HUCC__
 1037                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 40; #asmdef	HUCC_USES_CHRMAP 1
 1038               0001     	HUCC_USES_CHRMAP = 1
 1039                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 42; extern void __fastcall __nop set_chrmap( unsigned char __far *chrmap<vdc_map_bank:vdc_map_addr>, unsigned char tiles_w<vdc_map_line_w> );
 1040                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 44; extern void __fastcall draw_bat( void );
 1041                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 45; extern void __fastcall scroll_bat( void );
 1042                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 47; extern void __fastcall blit_bat( unsigned char tile_x<map_bat_x>, unsigned char tile_y<map_bat_y>, unsigned char tile_w<map_draw_x>, unsigned char tile_h<map_draw_y> );
 1043                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 49; #ifdef _SGX
 1044                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 51; extern void __fastcall __nop sgx_set_chrmap( unsigned char __far *chrmap<sgx_map_bank:sgx_map_addr>, unsigned char tiles_w<sgx_map_line_w> );
 1045                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 53; extern void __fastcall sgx_draw_bat( void );
 1046                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 54; extern void __fastcall sgx_scroll_bat( void );
 1047                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 56; extern void __fastcall sgx_blit_bat( unsigned char tile_x<map_bat_x>, unsigned char tile_y<map_bat_y>, unsigned char tile_w<map_draw_x>, unsigned char tile_h<map_draw_y> );
 1048                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 58; #endif
 1049                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 60; #endif // __HUCC__
 1050                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 62; #endif // _hucc_chrmap_h
 1051                        		.dbg	line,	"main.c", 4; #include "hucc-blkmap.h"
 1052                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 1; #ifndef _hucc_blkmap_h
 1053                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 2; #define _hucc_blkmap_h
 1054                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 4; /****************************************************************************
 1055                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 5; ; ***************************************************************************
 1056                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 6; ;
 1057                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 7; ; hucc-blkmap.h
 1058                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 8; ;
 1059                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 9; ; A map system based on 16x16 meta-tiles (aka "blocks", aka CHR/BLK/MAP).
 1060                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 10; ;
 1061                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 11; ; Copyright John Brandwood 2025.
 1062                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 12; ;
 1063                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 13; ; Distributed under the Boost Software License, Version 1.0.
 1064                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 14; ; (See accompanying file LICENSE_1_0.txt or copy at
 1065                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 15; ;  http://www.boost.org/LICENSE_1_0.txt)
 1066                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 16; ;
 1067                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 17; ; ***************************************************************************
 1068                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 18; ; ***************************************************************************
 1069                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 19; ;
 1070                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 20; ; The maximum X and Y size for blkmaps is 128 blocks (2048 pixels).
 1071                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 21; ;
 1072                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 22; ; The maximum total size for a blkmap is 16KBytes, which allows for maps up
 1073                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 23; ; to 128x128 blocks (2048x2048 pixels).
 1074                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 24; ;
 1075                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 25; ; Huge multi-screen blkmaps are also supported (optionally).
 1076                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 26; ;
 1077                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 27; ; The maximum X and Y for multi-screen maps is 128 screens (32768 pixels).
 1078                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 28; ;
 1079                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 29; ; The maximum total size for a multi-screen map is 8KBytes, which allows for
 1080                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 30; ; a total of 1024 screens.
 1081                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 31; ;
 1082                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 32; ; ***************************************************************************
 1083                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 33; ; **************************************************************************/
 1084                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 35; // *************
 1085                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 36; // Functions in blkmap.asm ...
 1086                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 37; // *************
 1087                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 39; #ifdef __HUCC__
 1088                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 41; #asmdef	HUCC_USES_BLKMAP 1
 1089                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 43; // Current top-left of drawn map in pixels.
 1090                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 44; extern unsigned int   vdc_map_pxl_x;
 1091                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 45; extern unsigned int   vdc_map_pxl_y;
 1092                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 47; // Width and height to draw/scroll in characters (not tiles).
 1093                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 48; extern unsigned char  vdc_map_draw_w;
 1094                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 49; extern unsigned char  vdc_map_draw_h;
 1095                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 51; // Width of map (or multi-screen BAT) in tiles.
 1096                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 52; extern unsigned char  vdc_map_line_w;
 1097                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 54; // Width of map in screens (if multi-screen map).
 1098                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 55; extern unsigned char  vdc_map_scrn_w;
 1099                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 57; // Extra information returned by get_map_block() and sgx_get_map_block(),
 1100                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 58; // which are the collision flags and the mask/overlay sprite for the BLK.
 1101                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 59; extern unsigned char  map_blk_flag;
 1102                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 60; extern unsigned char  map_blk_mask;
 1103                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 62; extern unsigned char  vdc_scr_bank;
 1104                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 63; extern unsigned char *vdc_scr_addr;
 1105                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 65; extern unsigned char  vdc_map_bank;
 1106                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 66; extern unsigned char *vdc_map_addr;
 1107                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 68; extern unsigned char  vdc_blk_bank;
 1108                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 69; extern unsigned char *vdc_blk_addr;
 1109                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 71; extern unsigned char  vdc_tbl_bank;
 1110                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 72; extern unsigned char *vdc_tbl_addr;
 1111                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 74; extern void __fastcall set_blocks( unsigned char __far *blk_def<vdc_blk_bank:vdc_blk_addr>, unsigned char __far *flg_def<vdc_tbl_bank:vdc_tbl_addr>, unsigned char number_of_blocks<_al> );
 1112                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 75; extern void __fastcall __macro set_blkmap( unsigned char __far *blk_map<vdc_map_bank:vdc_map_addr>, unsigned char blocks_w<vdc_map_line_w> );
 1113                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 76; extern void __fastcall __macro set_multimap( unsigned char __far *multi_map<vdc_scr_bank:vdc_scr_addr>, unsigned char screens_w<vdc_map_scrn_w> );
 1114                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 78; extern void __fastcall draw_map( void );
 1115                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 79; extern void __fastcall scroll_map( void );
 1116                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 81; extern void __fastcall blit_map( unsigned char tile_x<map_bat_x>, unsigned char tile_y<map_bat_y>, unsigned char tile_w<map_draw_x>, unsigned char tile_h<map_draw_y> );
 1117                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 83; extern unsigned char __fastcall get_map_block( unsigned int x<map_pxl_x>, unsigned int y<map_pxl_y> );
 1118                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 85; #asm
 1119                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 86; .macro	_set_blkmap.2
 1120                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 87; stz	vdc_scr_bank
 1121                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 88; .endm
 1122                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 90; .macro	_set_multimap.2
 1123                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 91; lda	vdc_bat_width
 1124                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 92; lsr	a
 1125                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 93; sta	vdc_map_line_w
 1126                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 94; .endm
 1127                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 96; .macro	SCREEN
 1128                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 97; db	(((\1) & $1FFF) | $6000) >> 8, bank(\1)
 1129                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 98; db	(((\2) & $1FFF) | $4000) >> 8, bank(\2)
 1130                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 99; db	(((\3) & $1FFF) | $6000) >> 8, bank(\3)
 1131                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 100; dw	(\4)
 1132                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 101; .endm
 1133                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 102; #endasm
 1134                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 104; #ifdef _SGX
 1135                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 106; // Current top-left of drawn map in pixels.
 1136                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 107; extern unsigned int   sgx_map_pxl_x;
 1137                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 108; extern unsigned int   sgx_map_pxl_y;
 1138                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 110; // Width and height to draw/scroll in characters (not tiles).
 1139                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 111; extern unsigned char  sgx_map_draw_w;
 1140                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 112; extern unsigned char  sgx_map_draw_h;
 1141                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 114; // Width of map (or multi-screen BAT) in tiles.
 1142                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 115; extern unsigned char  sgx_map_line_w;
 1143                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 117; // Width of map in screens (if multi-screen map).
 1144                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 118; extern unsigned char  sgx_map_scrn_w;
 1145                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 120; extern unsigned char  sgx_scr_bank;
 1146                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 121; extern unsigned char *sgx_scr_addr;
 1147                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 123; extern unsigned char  sgx_map_bank;
 1148                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 124; extern unsigned char *sgx_map_addr;
 1149                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 126; extern unsigned char  sgx_blk_bank;
 1150                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 127; extern unsigned char *sgx_blk_addr;
 1151                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 129; extern unsigned char  sgx_tbl_bank;
 1152                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 130; extern unsigned char *sgx_tbl_addr;
 1153                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 132; extern void __fastcall sgx_set_blocks( unsigned char __far *blk_def<sgx_blk_bank:sgx_blk_addr>, unsigned char __far *flg_def<sgx_tbl_bank:sgx_tbl_addr>, unsigned char number_of_blocks<_al> );
 1154                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 133; extern void __fastcall __macro sgx_set_blkmap( unsigned char __far *blk_map<sgx_map_bank:sgx_map_addr>, unsigned char blocks_w<sgx_map_line_w> );
 1155                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 134; extern void __fastcall __macro sgx_set_multimap( unsigned char __far *multi_map<sgx_scr_bank:sgx_scr_addr>, unsigned char screens_w<sgx_map_scrn_w> );
 1156                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 136; extern void __fastcall sgx_draw_map( void );
 1157                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 137; extern void __fastcall sgx_scroll_map( void );
 1158                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 139; extern void __fastcall sgx_blit_map( unsigned char tile_x<map_bat_x>, unsigned char tile_y<map_bat_y>, unsigned char tile_w<map_draw_x>, unsigned char tile_h<map_draw_y> );
 1159                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 141; extern unsigned char __fastcall sgx_get_map_block( unsigned int x<map_pxl_x>, unsigned int y<map_pxl_y> );
 1160                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 143; #asm
 1161                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 144; .macro	_sgx_set_blkmap.2
 1162                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 145; stz	sgx_scr_bank
 1163                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 146; .endm
 1164                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 148; .macro	_sgx_set_multimap.2
 1165                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 149; lda	sgx_bat_width
 1166                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 150; lsr	a
 1167                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 151; sta	sgx_map_line_w
 1168                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 152; .endm
 1169                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 153; #endasm
 1170                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 155; #endif
 1171                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 157; #endif // __HUCC__
 1172                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 159; #endif // _hucc_blkmap_h
 1173                        		.dbg	line,	"main.c", 9; #include "include/constants.c"
 1174                        		.dbg	line,	"include\constants.c", 1; //*****************************************************************************//
 1175                        		.dbg	line,	"include\constants.c", 2; //                                                                             //
 1176                        		.dbg	line,	"include\constants.c", 3; //                                SYSTEM CONSTANTS                             //
 1177                        		.dbg	line,	"include\constants.c", 4; //                                                                             //
 1178                        		.dbg	line,	"include\constants.c", 5; //*****************************************************************************//
 1179                        		.dbg	line,	"include\constants.c", 7; #define FALSE 0
 1180                        		.dbg	line,	"include\constants.c", 8; #define TRUE  1
 1181                        		.dbg	line,	"include\constants.c", 10; #define YES   1
 1182                        		.dbg	line,	"include\constants.c", 11; #define NO    2
 1183                        		.dbg	line,	"include\constants.c", 13; #define JOYPAD_1 0
 1184                        		.dbg	line,	"include\constants.c", 14; #define JOYPAD_2 1
 1185                        		.dbg	line,	"include\constants.c", 16; #define BAT_SIZE_W 2048 // IN PIXELS
 1186                        		.dbg	line,	"include\constants.c", 17; #define BAT_SIZE_H 256  // IN PIXELS
 1187                        		.dbg	line,	"include\constants.c", 19; #define JOY_DIR_PRESSED (JOY_DOWN | JOY_UP | JOY_RIGHT | JOY_LEFT)
 1188                        		.dbg	line,	"include\constants.c", 22; #define TILES_1   16
 1189                        		.dbg	line,	"include\constants.c", 23; #define TILES_2   32
 1190                        		.dbg	line,	"include\constants.c", 24; #define TILES_3   48
 1191                        		.dbg	line,	"include\constants.c", 25; #define TILES_4   64
 1192                        		.dbg	line,	"include\constants.c", 26; #define TILES_8   128
 1193                        		.dbg	line,	"include\constants.c", 27; #define TILES_16  256
 1194                        		.dbg	line,	"include\constants.c", 28; #define TILES_32  512
 1195                        		.dbg	line,	"include\constants.c", 29; #define TILES_48  768
 1196                        		.dbg	line,	"include\constants.c", 30; #define TILES_64  1024
 1197                        		.dbg	line,	"include\constants.c", 31; #define TILES_80  1280
 1198                        		.dbg	line,	"include\constants.c", 32; #define TILES_96  1536
 1199                        		.dbg	line,	"include\constants.c", 33; #define TILES_112 1792
 1200                        		.dbg	line,	"include\constants.c", 34; #define TILES_128 2048
 1201                        		.dbg	line,	"include\constants.c", 35; #define TILES_144 2304
 1202                        		.dbg	line,	"include\constants.c", 36; #define TILES_160 2560
 1203                        		.dbg	line,	"include\constants.c", 37; #define TILES_176 2816
 1204                        		.dbg	line,	"include\constants.c", 38; #define TILES_192 3072
 1205                        		.dbg	line,	"include\constants.c", 39; #define TILES_208 3328
 1206                        		.dbg	line,	"include\constants.c", 40; #define TILES_224 3584+256
 1207                        		.dbg	line,	"include\constants.c", 43; #define OFFSET_PLAYER_WALK_1     256
 1208                        		.dbg	line,	"include\constants.c", 44; #define OFFSET_PLAYER_WALK_2     512
 1209                        		.dbg	line,	"include\constants.c", 45; #define OFFSET_PLAYER_WALK_3     768
 1210                        		.dbg	line,	"include\constants.c", 46; #define OFFSET_PLAYER_WALK_4     1024
 1211                        		.dbg	line,	"include\constants.c", 47; #define OFFSET_PLAYER_WALK_5     1280
 1212                        		.dbg	line,	"include\constants.c", 48; #define OFFSET_PLAYER_WALK_6     1536
 1213                        		.dbg	line,	"include\constants.c", 55; #define SEQUENCE_TITLE      0
 1214                        		.dbg	line,	"include\constants.c", 56; #define SEQUENCE_INTRO      1
 1215                        		.dbg	line,	"include\constants.c", 57; #define SEQUENCE_GAME       2
 1216                        		.dbg	line,	"include\constants.c", 60; #define CAMERA_RECENTER_VELOCITY    4
 1217                        		.dbg	line,	"include\constants.c", 65; //-----------------------------------------------------------------------------//
 1218                        		.dbg	line,	"include\constants.c", 66; //                                                                             //
 1219                        		.dbg	line,	"include\constants.c", 67; //                                   PLAYER                                    //
 1220                        		.dbg	line,	"include\constants.c", 68; //                                                                             //
 1221                        		.dbg	line,	"include\constants.c", 69; //-----------------------------------------------------------------------------//
 1222                        		.dbg	line,	"include\constants.c", 71; #define AXIS_RIGHT          0
 1223                        		.dbg	line,	"include\constants.c", 72; #define AXIS_LEFT           1
 1224                        		.dbg	line,	"include\constants.c", 73; #define AXIS_UP             2
 1225                        		.dbg	line,	"include\constants.c", 74; #define AXIS_DOWN           3
 1226                        		.dbg	line,	"include\constants.c", 78; #define STATE_IDLE                  0
 1227                        		.dbg	line,	"include\constants.c", 79; #define STATE_WALK                  1
 1228                        		.dbg	line,	"include\constants.c", 80; #define STATE_PUNCH                 2
 1229                        		.dbg	line,	"include\constants.c", 81; #define STATE_JUMP                  4
 1230                        		.dbg	line,	"include\constants.c", 82; #define STATE_JUMP_RIGHT            5
 1231                        		.dbg	line,	"include\constants.c", 83; #define STATE_JUMP_LEFT             6
 1232                        		.dbg	line,	"include\constants.c", 84; #define STATE_CROUCH                7
 1233                        		.dbg	line,	"include\constants.c", 85; #define STATE_CROUCH_PUNCH          8
 1234                        		.dbg	line,	"include\constants.c", 86; #define STATE_FALL                  9
 1235                        		.dbg	line,	"include\constants.c", 87; #define STATE_HANG                  10
 1236                        		.dbg	line,	"include\constants.c", 88; #define STATE_CLIMB_UP              11
 1237                        		.dbg	line,	"include\constants.c", 89; #define STATE_CLIMB_DOWN            12
 1238                        		.dbg	line,	"include\constants.c", 90; #define STATE_JUMP_LADDER           13
 1239                        		.dbg	line,	"include\constants.c", 94; #define PLAYER_VRAM_ADR     0x1800
 1240                        		.dbg	line,	"include\constants.c", 96; #define PLAYER_BASE_Y_POS   128
 1241                        		.dbg	line,	"include\constants.c", 101; //-----------------------------------------------------------------------------//
 1242                        		.dbg	line,	"include\constants.c", 102; //                                                                             //
 1243                        		.dbg	line,	"include\constants.c", 103; //                                  COLLISIONS                                 //
 1244                        		.dbg	line,	"include\constants.c", 104; //                                                                             //
 1245                        		.dbg	line,	"include\constants.c", 105; //-----------------------------------------------------------------------------//
 1246                        		.dbg	line,	"include\constants.c", 107; #define TILE_EMPTY          0
 1247                        		.dbg	line,	"include\constants.c", 108; #define TILE_BG             1
 1248                        		.dbg	line,	"include\constants.c", 109; #define TILE_LADDER         2
 1249                        		.dbg	line,	"include\constants.c", 114; //-----------------------------------------------------------------------------//
 1250                        		.dbg	line,	"include\constants.c", 115; //                                                                             //
 1251                        		.dbg	line,	"include\constants.c", 116; //                                     HUD                                     //
 1252                        		.dbg	line,	"include\constants.c", 117; //                                                                             //
 1253                        		.dbg	line,	"include\constants.c", 118; //-----------------------------------------------------------------------------//
 1254                        		.dbg	line,	"include\constants.c", 120; #define LIFEBAR_1_VRAM_ADR      0x1000
 1255                        		.dbg	line,	"include\constants.c", 121; #define LIFEBAR_2_VRAM_ADR      LIFEBAR_1_VRAM_ADR+TILES_2
 1256                        		.dbg	line,	"include\constants.c", 122; #define LIFEBAR_3_VRAM_ADR      LIFEBAR_2_VRAM_ADR+TILES_2
 1257                        		.dbg	line,	"include\constants.c", 123; #define LIFEBAR_4_VRAM_ADR      LIFEBAR_3_VRAM_ADR+TILES_2
 1258                        		.dbg	line,	"include\constants.c", 124; #define LIFEBAR_5_VRAM_ADR      LIFEBAR_4_VRAM_ADR+TILES_2
 1259                        		.dbg	line,	"include\constants.c", 126; #define WEAPON_VRAM_ADR         LIFEBAR_5_VRAM_ADR+TILES_2
 1260                        		.dbg	line,	"include\constants.c", 127; #define ARMOR_VRAM_ADR          WEAPON_VRAM_ADR+TILES_4
 1261                        		.dbg	line,	"include\constants.c", 132; //-----------------------------------------------------------------------------//
 1262                        		.dbg	line,	"include\constants.c", 133; //                                                                             //
 1263                        		.dbg	line,	"include\constants.c", 134; //                                    LEVELS                                   //
 1264                        		.dbg	line,	"include\constants.c", 135; //                                                                             //
 1265                        		.dbg	line,	"include\constants.c", 136; //-----------------------------------------------------------------------------//
 1266                        		.dbg	line,	"include\constants.c", 138; #define LV1_WALL_VRAM_ADR       0x1000
 1267                        		.dbg	line,	"include\constants.c", 139; #define LV1_DOOR_VRAM_ADR       LV1_WALL_VRAM_ADR+256
 1268                        		.dbg	line,	"include\constants.c", 142; #define OBJECTS_NUMBER_LV1      25
 1269                        		.dbg	line,	"include\constants.c", 147; //-----------------------------------------------------------------------------//
 1270                        		.dbg	line,	"include\constants.c", 148; //                                                                             //
 1271                        		.dbg	line,	"include\constants.c", 149; //                                   OBJECTS                                   //
 1272                        		.dbg	line,	"include\constants.c", 150; //                                                                             //
 1273                        		.dbg	line,	"include\constants.c", 151; //-----------------------------------------------------------------------------//
 1274                        		.dbg	line,	"include\constants.c", 153; #define TYPE_HOURGLASS          0
 1275                        		.dbg	line,	"include\constants.c", 154; #define TYPE_POT                1
 1276                        		.dbg	line,	"include\constants.c", 155; #define TYPE_POW                2
 1277                        		.dbg	line,	"include\constants.c", 156; #define TYPE_CHEST              3
 1278                        		.dbg	line,	"include\constants.c", 157; #define TYPE_GRAY_KEY           4
 1279                        		.dbg	line,	"include\constants.c", 158; #define TYPE_GOLD_KEY           5
 1280                        		.dbg	line,	"include\constants.c", 159; #define TYPE_1UP                6
 1281                        		.dbg	line,	"include\constants.c", 161; #define STATE_ACTIVE            0
 1282                        		.dbg	line,	"include\constants.c", 162; #define STATE_INACTIVE          1
 1283                        		.dbg	line,	"include\constants.c", 165; #define POT1_VRAM_ADR           0x1C00
 1284                        		.dbg	line,	"include\constants.c", 166; #define POT2_VRAM_ADR           POT1_VRAM_ADR+TILES_4
 1285                        		.dbg	line,	"include\constants.c", 167; #define POT3_VRAM_ADR           POT2_VRAM_ADR+TILES_4
 1286                        		.dbg	line,	"include\constants.c", 168; #define POT4_VRAM_ADR           POT3_VRAM_ADR+TILES_4
 1287                        		.dbg	line,	"include\constants.c", 169; #define POT5_VRAM_ADR           POT4_VRAM_ADR+TILES_4
 1288                        		.dbg	line,	"include\constants.c", 170; #define POT6_VRAM_ADR           POT5_VRAM_ADR+TILES_4
 1289                        		.dbg	line,	"include\constants.c", 171; #define POT7_VRAM_ADR           POT6_VRAM_ADR+TILES_4
 1290                        		.dbg	line,	"include\constants.c", 172; #define POT8_VRAM_ADR           POT7_VRAM_ADR+TILES_4
 1291                        		.dbg	line,	"include\constants.c", 174; #define POW_VRAM_ADR            POT8_VRAM_ADR+TILES_4
 1292                        		.dbg	line,	"include\constants.c", 175; #define GRAY_KEY_VRAM_ADR       POW_VRAM_ADR+TILES_4
 1293                        		.dbg	line,	"include\constants.c", 176; #define GOLD_KEY_VRAM_ADR       GRAY_KEY_VRAM_ADR+TILES_4
 1294                        		.dbg	line,	"include\constants.c", 177; #define LIFE_VRAM_ADR           GOLD_KEY_VRAM_ADR+TILES_4
 1295                        		.dbg	line,	"include\constants.c", 179; #define COIN_1_VRAM_ADR         LIFE_VRAM_ADR+TILES_4
 1296                        		.dbg	line,	"include\constants.c", 180; #define COIN_5_VRAM_ADR         COIN_1_VRAM_ADR+TILES_4
 1297                        		.dbg	line,	"include\constants.c", 181; #define COIN_10_VRAM_ADR        COIN_5_VRAM_ADR+TILES_4
 1298                        		.dbg	line,	"include\constants.c", 182; #define COIN_50_VRAM_ADR        COIN_10_VRAM_ADR+TILES_4
 1299                        		.dbg	line,	"include\constants.c", 183; #define COIN_100_VRAM_ADR       COIN_50_VRAM_ADR+TILES_4
 1300                        		.dbg	line,	"include\constants.c", 184; #define COIN_500_VRAM_ADR       COIN_100_VRAM_ADR+TILES_4
 1301                        		.dbg	line,	"include\constants.c", 185; #define COIN_1000_VRAM_ADR      COIN_500_VRAM_ADR+TILES_4
 1302                        		.dbg	line,	"include\constants.c", 187; #define STAR_VRAM_ADR           COIN_1000_VRAM_ADR+TILES_4
 1303                        		.dbg	line,	"include\constants.c", 188; #define OCTOPUS_VRAM_ADR        STAR_VRAM_ADR+TILES_4
 1304                        		.dbg	line,	"include\constants.c", 189; #define FRUIT_VRAM_ADR          OCTOPUS_VRAM_ADR+TILES_4
 1305                        		.dbg	line,	"include\constants.c", 190; #define BARREL_VRAM_ADR         FRUIT_VRAM_ADR+TILES_4
 1306                        		.dbg	line,	"include\constants.c", 192; #define CHEST_VRAM_ADR          0x2400
 1307                        		.dbg	line,	"main.c", 10; #include "include/variables.c"
 1308                        		.dbg	line,	"include\variables.c", 1; #include "huc.h"
 1309                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 1; #ifndef _hucc_legacy_h
 1310                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 2; #define _hucc_legacy_h
 1311                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 4; /****************************************************************************
 1312                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 5; ; ***************************************************************************
 1313                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 6; ;
 1314                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 7; ; huc.h
 1315                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 8; ;
 1316                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 9; ; HuCC wrapper file to include a default set of HuC-compatible functions.
 1317                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 10; ;
 1318                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 11; ; Copyright John Brandwood 2024.
 1319                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 12; ;
 1320                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 13; ; Distributed under the Boost Software License, Version 1.0.
 1321                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 14; ; (See accompanying file LICENSE_1_0.txt or copy at
 1322                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 15; ;  http://www.boost.org/LICENSE_1_0.txt)
 1323                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 16; ;
 1324                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 17; ; ***************************************************************************
 1325                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 18; ; ***************************************************************************
 1326                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 19; ;
 1327                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 20; ; When the HuCC compiler is invoked with the "--legacy" option to compile old
 1328                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 21; ; projects, then this "huc.h" file is automatically included.
 1329                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 22; ;
 1330                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 23; ; This file includes a set of the individual HuCC headers which correspond to
 1331                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 24; ; HuC's built-in functions and MagicKit library.
 1332                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 25; ;
 1333                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 26; ; New HuCC projects should, preferably, include the specific headers that are
 1334                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 27; ; needed, which will then allow them to replace parts of the standard library
 1335                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 28; ; with newer functions, or they can just manually include this "huc.h" file.
 1336                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 29; ;
 1337                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 30; ; ***************************************************************************
 1338                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 31; ; **************************************************************************/
 1339                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 33; #include "hucc-systemcard.h"
 1340                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 34; #include "hucc-baselib.h"
 1341                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 35; #include "hucc-gfx.h"
 1342                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 36; #include "hucc-string.h"
 1343                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 37; #include "hucc-old-scroll.h"
 1344                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 38; #include "hucc-old-spr.h"
 1345                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 39; #include "hucc-old-map.h"
 1346                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 40; #include "hucc-old-line.h"
 1347                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 42; #endif // _hucc_legacy_h
 1348                        		.dbg	line,	"include\variables.c", 2; #include "hucc-scroll.h"
 1349                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 1; #ifndef _hucc_scroll_h
 1350                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 2; #define _hucc_scroll_h
 1351                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 4; /****************************************************************************
 1352                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 5; ; ***************************************************************************
 1353                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 6; ;
 1354                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 7; ; hucc-scroll.h
 1355                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 8; ;
 1356                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 9; ; Routines for a fast split-screen scrolling system.
 1357                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 10; ;
 1358                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 11; ; Copyright John Brandwood 2024.
 1359                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 12; ;
 1360                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 13; ; Distributed under the Boost Software License, Version 1.0.
 1361                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 14; ; (See accompanying file LICENSE_1_0.txt or copy at
 1362                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 15; ;  http://www.boost.org/LICENSE_1_0.txt)
 1363                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 16; ;
 1364                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 17; ; ***************************************************************************
 1365                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 18; ; ***************************************************************************
 1366                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 19; ;
 1367                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 20; ; The maximum number of splits for each screen layer is set in your project's
 1368                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 21; ; "hucc-config.inc" file, with the library having a limit of 128-per-layer.
 1369                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 22; ;
 1370                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 23; ; Your first active split must be defined to start at screen line 0, and then
 1371                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 24; ; the rest of the active splits must be in increasing line order to match the
 1372                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 25; ; way that the PC Engine displays the output image.
 1373                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 26; ;
 1374                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 27; ; You can have disabled splits interleaved with your active splits.
 1375                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 28; ;
 1376                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 29; ; Splits that are normally disabled can be used to create full screen effects
 1377                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 30; ; such as bouncing the screen up and down by adding blank areas at the top or
 1378                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 31; ; bottom of the screen, and then rapidly changing the height of those areas.
 1379                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 32; ;
 1380                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 33; ; ***************************************************************************
 1381                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 34; ; **************************************************************************/
 1382                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 36; // *************
 1383                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 37; // VDC bits for display_flags ...
 1384                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 38; // *************
 1385                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 40; #ifndef BKG_OFF
 1386                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 41; #define BKG_OFF 0x00
 1387                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 42; #endif
 1388                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 44; #ifndef SPR_OFF
 1389                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 45; #define SPR_OFF 0x00
 1390                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 46; #endif
 1391                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 48; #ifndef BKG_ON
 1392                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 49; #define BKG_ON 0x80
 1393                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 50; #endif
 1394                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 52; #ifndef SPR_ON
 1395                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 53; #define SPR_ON 0x40
 1396                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 54; #endif
 1397                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 56; // *************
 1398                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 57; // Functions in hucc-scroll.asm ...
 1399                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 58; // *************
 1400                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 60; #ifdef __HUCC__
 1401                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 62; #asmdef	HUCC_USES_NEW_SCROLL 1
 1402                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 64; extern void __fastcall scroll_split( unsigned char index<_al>, unsigned char screen_line<_ah>, unsigned int bat_x<_bx>, unsigned int bat_y<_cx>, unsigned char display_flags<_dl> );
 1403                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 65; extern void __fastcall sgx_scroll_split( unsigned char index<_al>, unsigned char screen_line<_ah>, unsigned int bat_x<_bx>, unsigned int bat_y<_cx>, unsigned char display_flags<_dl> );
 1404                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 67; extern void __fastcall disable_split( unsigned char index<acc> );
 1405                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 68; extern void __fastcall sgx_disable_split( unsigned char index<acc> );
 1406                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 70; extern void __fastcall __macro disable_all_splits( void );
 1407                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 71; extern void __fastcall __macro sgx_disable_all_splits( void );
 1408                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 73; #asm
 1409                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 74; .macro	_disable_all_splits
 1410                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 75; ldy	#HUCC_PCE_SPLITS - 1
 1411                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 76; !loop:		tya
 1412                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 77; call	_disable_split.1
 1413                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 78; dey
 1414                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 79; bpl	!loop-
 1415                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 80; .endm
 1416                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 82; .macro	_sgx_disable_all_splits
 1417                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 83; ldy	#HUCC_SGX_SPLITS - 1
 1418                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 84; !loop:		tya
 1419                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 85; call	_sgx_disable_split.1
 1420                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 86; dey
 1421                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 87; bpl	!loop-
 1422                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 88; .endm
 1423                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 89; #endasm
 1424                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 91; #endif // __HUCC__
 1425                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 93; #endif // _hucc_scroll_h
 1426                        		.dbg	line,	"include\variables.c", 3; #include "hucc-chrmap.h"
 1427                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 1; #ifndef _hucc_chrmap_h
 1428                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 2; #define _hucc_chrmap_h
 1429                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 4; /****************************************************************************
 1430                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 5; ; ***************************************************************************
 1431                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 6; ;
 1432                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 7; ; hucc-chrmap.h
 1433                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 8; ;
 1434                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 9; ; A simple map system based on 8x8 characters (aka "tiles") in BAT format.
 1435                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 10; ;
 1436                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 11; ; Copyright John Brandwood 2025.
 1437                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 12; ;
 1438                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 13; ; Distributed under the Boost Software License, Version 1.0.
 1439                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 14; ; (See accompanying file LICENSE_1_0.txt or copy at
 1440                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 15; ;  http://www.boost.org/LICENSE_1_0.txt)
 1441                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 16; ;
 1442                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 17; ; ***************************************************************************
 1443                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 18; ; ***************************************************************************
 1444                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 19; ;
 1445                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 20; ; The maximum X and Y size for chrmaps is 256 characters (2048 pixels).
 1446                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 21; ;
 1447                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 22; ; The maximum total size for a chrmap is 16KBytes, which allows for maps up
 1448                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 23; ; to 256x32 tiles (2048x256 pixels).
 1449                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 24; ;
 1450                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 25; ; ***************************************************************************
 1451                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 26; ; **************************************************************************/
 1452                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 28; // *************
 1453                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 29; // This code extends the blkmap library ...
 1454                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 30; // *************
 1455                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 32; #include "hucc-blkmap.h"
 1456                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 34; // *************
 1457                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 35; // Functions in chrmap.asm ...
 1458                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 36; // *************
 1459                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 38; #ifdef __HUCC__
 1460                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 40; #asmdef	HUCC_USES_CHRMAP 1
 1461                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 42; extern void __fastcall __nop set_chrmap( unsigned char __far *chrmap<vdc_map_bank:vdc_map_addr>, unsigned char tiles_w<vdc_map_line_w> );
 1462                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 44; extern void __fastcall draw_bat( void );
 1463                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 45; extern void __fastcall scroll_bat( void );
 1464                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 47; extern void __fastcall blit_bat( unsigned char tile_x<map_bat_x>, unsigned char tile_y<map_bat_y>, unsigned char tile_w<map_draw_x>, unsigned char tile_h<map_draw_y> );
 1465                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 49; #ifdef _SGX
 1466                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 51; extern void __fastcall __nop sgx_set_chrmap( unsigned char __far *chrmap<sgx_map_bank:sgx_map_addr>, unsigned char tiles_w<sgx_map_line_w> );
 1467                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 53; extern void __fastcall sgx_draw_bat( void );
 1468                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 54; extern void __fastcall sgx_scroll_bat( void );
 1469                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 56; extern void __fastcall sgx_blit_bat( unsigned char tile_x<map_bat_x>, unsigned char tile_y<map_bat_y>, unsigned char tile_w<map_draw_x>, unsigned char tile_h<map_draw_y> );
 1470                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 58; #endif
 1471                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 60; #endif // __HUCC__
 1472                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 62; #endif // _hucc_chrmap_h
 1473                        		.dbg	line,	"include\variables.c", 4; #include "hucc-blkmap.h"
 1474                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 1; #ifndef _hucc_blkmap_h
 1475                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 2; #define _hucc_blkmap_h
 1476                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 4; /****************************************************************************
 1477                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 5; ; ***************************************************************************
 1478                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 6; ;
 1479                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 7; ; hucc-blkmap.h
 1480                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 8; ;
 1481                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 9; ; A map system based on 16x16 meta-tiles (aka "blocks", aka CHR/BLK/MAP).
 1482                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 10; ;
 1483                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 11; ; Copyright John Brandwood 2025.
 1484                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 12; ;
 1485                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 13; ; Distributed under the Boost Software License, Version 1.0.
 1486                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 14; ; (See accompanying file LICENSE_1_0.txt or copy at
 1487                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 15; ;  http://www.boost.org/LICENSE_1_0.txt)
 1488                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 16; ;
 1489                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 17; ; ***************************************************************************
 1490                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 18; ; ***************************************************************************
 1491                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 19; ;
 1492                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 20; ; The maximum X and Y size for blkmaps is 128 blocks (2048 pixels).
 1493                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 21; ;
 1494                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 22; ; The maximum total size for a blkmap is 16KBytes, which allows for maps up
 1495                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 23; ; to 128x128 blocks (2048x2048 pixels).
 1496                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 24; ;
 1497                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 25; ; Huge multi-screen blkmaps are also supported (optionally).
 1498                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 26; ;
 1499                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 27; ; The maximum X and Y for multi-screen maps is 128 screens (32768 pixels).
 1500                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 28; ;
 1501                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 29; ; The maximum total size for a multi-screen map is 8KBytes, which allows for
 1502                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 30; ; a total of 1024 screens.
 1503                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 31; ;
 1504                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 32; ; ***************************************************************************
 1505                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 33; ; **************************************************************************/
 1506                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 35; // *************
 1507                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 36; // Functions in blkmap.asm ...
 1508                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 37; // *************
 1509                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 39; #ifdef __HUCC__
 1510                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 41; #asmdef	HUCC_USES_BLKMAP 1
 1511                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 43; // Current top-left of drawn map in pixels.
 1512                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 44; extern unsigned int   vdc_map_pxl_x;
 1513                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 45; extern unsigned int   vdc_map_pxl_y;
 1514                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 47; // Width and height to draw/scroll in characters (not tiles).
 1515                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 48; extern unsigned char  vdc_map_draw_w;
 1516                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 49; extern unsigned char  vdc_map_draw_h;
 1517                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 51; // Width of map (or multi-screen BAT) in tiles.
 1518                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 52; extern unsigned char  vdc_map_line_w;
 1519                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 54; // Width of map in screens (if multi-screen map).
 1520                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 55; extern unsigned char  vdc_map_scrn_w;
 1521                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 57; // Extra information returned by get_map_block() and sgx_get_map_block(),
 1522                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 58; // which are the collision flags and the mask/overlay sprite for the BLK.
 1523                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 59; extern unsigned char  map_blk_flag;
 1524                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 60; extern unsigned char  map_blk_mask;
 1525                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 62; extern unsigned char  vdc_scr_bank;
 1526                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 63; extern unsigned char *vdc_scr_addr;
 1527                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 65; extern unsigned char  vdc_map_bank;
 1528                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 66; extern unsigned char *vdc_map_addr;
 1529                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 68; extern unsigned char  vdc_blk_bank;
 1530                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 69; extern unsigned char *vdc_blk_addr;
 1531                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 71; extern unsigned char  vdc_tbl_bank;
 1532                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 72; extern unsigned char *vdc_tbl_addr;
 1533                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 74; extern void __fastcall set_blocks( unsigned char __far *blk_def<vdc_blk_bank:vdc_blk_addr>, unsigned char __far *flg_def<vdc_tbl_bank:vdc_tbl_addr>, unsigned char number_of_blocks<_al> );
 1534                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 75; extern void __fastcall __macro set_blkmap( unsigned char __far *blk_map<vdc_map_bank:vdc_map_addr>, unsigned char blocks_w<vdc_map_line_w> );
 1535                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 76; extern void __fastcall __macro set_multimap( unsigned char __far *multi_map<vdc_scr_bank:vdc_scr_addr>, unsigned char screens_w<vdc_map_scrn_w> );
 1536                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 78; extern void __fastcall draw_map( void );
 1537                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 79; extern void __fastcall scroll_map( void );
 1538                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 81; extern void __fastcall blit_map( unsigned char tile_x<map_bat_x>, unsigned char tile_y<map_bat_y>, unsigned char tile_w<map_draw_x>, unsigned char tile_h<map_draw_y> );
 1539                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 83; extern unsigned char __fastcall get_map_block( unsigned int x<map_pxl_x>, unsigned int y<map_pxl_y> );
 1540                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 85; #asm
 1541                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 86; .macro	_set_blkmap.2
 1542                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 87; stz	vdc_scr_bank
 1543                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 88; .endm
 1544                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 90; .macro	_set_multimap.2
 1545                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 91; lda	vdc_bat_width
 1546                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 92; lsr	a
 1547                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 93; sta	vdc_map_line_w
 1548                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 94; .endm
 1549                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 96; .macro	SCREEN
 1550                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 97; db	(((\1) & $1FFF) | $6000) >> 8, bank(\1)
 1551                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 98; db	(((\2) & $1FFF) | $4000) >> 8, bank(\2)
 1552                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 99; db	(((\3) & $1FFF) | $6000) >> 8, bank(\3)
 1553                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 100; dw	(\4)
 1554                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 101; .endm
 1555                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 102; #endasm
 1556                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 104; #ifdef _SGX
 1557                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 106; // Current top-left of drawn map in pixels.
 1558                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 107; extern unsigned int   sgx_map_pxl_x;
 1559                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 108; extern unsigned int   sgx_map_pxl_y;
 1560                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 110; // Width and height to draw/scroll in characters (not tiles).
 1561                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 111; extern unsigned char  sgx_map_draw_w;
 1562                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 112; extern unsigned char  sgx_map_draw_h;
 1563                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 114; // Width of map (or multi-screen BAT) in tiles.
 1564                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 115; extern unsigned char  sgx_map_line_w;
 1565                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 117; // Width of map in screens (if multi-screen map).
 1566                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 118; extern unsigned char  sgx_map_scrn_w;
 1567                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 120; extern unsigned char  sgx_scr_bank;
 1568                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 121; extern unsigned char *sgx_scr_addr;
 1569                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 123; extern unsigned char  sgx_map_bank;
 1570                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 124; extern unsigned char *sgx_map_addr;
 1571                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 126; extern unsigned char  sgx_blk_bank;
 1572                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 127; extern unsigned char *sgx_blk_addr;
 1573                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 129; extern unsigned char  sgx_tbl_bank;
 1574                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 130; extern unsigned char *sgx_tbl_addr;
 1575                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 132; extern void __fastcall sgx_set_blocks( unsigned char __far *blk_def<sgx_blk_bank:sgx_blk_addr>, unsigned char __far *flg_def<sgx_tbl_bank:sgx_tbl_addr>, unsigned char number_of_blocks<_al> );
 1576                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 133; extern void __fastcall __macro sgx_set_blkmap( unsigned char __far *blk_map<sgx_map_bank:sgx_map_addr>, unsigned char blocks_w<sgx_map_line_w> );
 1577                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 134; extern void __fastcall __macro sgx_set_multimap( unsigned char __far *multi_map<sgx_scr_bank:sgx_scr_addr>, unsigned char screens_w<sgx_map_scrn_w> );
 1578                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 136; extern void __fastcall sgx_draw_map( void );
 1579                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 137; extern void __fastcall sgx_scroll_map( void );
 1580                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 139; extern void __fastcall sgx_blit_map( unsigned char tile_x<map_bat_x>, unsigned char tile_y<map_bat_y>, unsigned char tile_w<map_draw_x>, unsigned char tile_h<map_draw_y> );
 1581                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 141; extern unsigned char __fastcall sgx_get_map_block( unsigned int x<map_pxl_x>, unsigned int y<map_pxl_y> );
 1582                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 143; #asm
 1583                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 144; .macro	_sgx_set_blkmap.2
 1584                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 145; stz	sgx_scr_bank
 1585                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 146; .endm
 1586                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 148; .macro	_sgx_set_multimap.2
 1587                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 149; lda	sgx_bat_width
 1588                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 150; lsr	a
 1589                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 151; sta	sgx_map_line_w
 1590                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 152; .endm
 1591                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 153; #endasm
 1592                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 155; #endif
 1593                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 157; #endif // __HUCC__
 1594                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 159; #endif // _hucc_blkmap_h
 1595                        		.dbg	line,	"include\variables.c", 13; unsigned char   sequence_id,
 1596                        		.dbg	line,	"include\variables.c", 14; sequence_loaded,
 1597                        		.dbg	line,	"include\variables.c", 16; level_id,
 1598                        		.dbg	line,	"include\variables.c", 18; player_id,
 1599                        		.dbg	line,	"include\variables.c", 19; player_state,
 1600                        		.dbg	line,	"include\variables.c", 20; player_axis,
 1601                        		.dbg	line,	"include\variables.c", 21; player_previous_axis,
 1602                        		.dbg	line,	"include\variables.c", 22; player_counter_anim,
 1603                        		.dbg	line,	"include\variables.c", 23; player_index_jump,
 1604                        		.dbg	line,	"include\variables.c", 24; player_index_fall,
 1605                        		.dbg	line,	"include\variables.c", 26; jump_ladder,
 1606                        		.dbg	line,	"include\variables.c", 27; jump_max_index,
 1607                        		.dbg	line,	"include\variables.c", 29; objects_max;
 1608                        		.dbg	line,	"include\variables.c", 34; signed int      player_pos_x,
 1609                        		.dbg	line,	"include\variables.c", 35; player_pos_y,
 1610                        		.dbg	line,	"include\variables.c", 36; camera_max_y_position,
 1611                        		.dbg	line,	"include\variables.c", 38; list_objects_type[25],
 1612                        		.dbg	line,	"include\variables.c", 39; list_objects_state[25],
 1613                        		.dbg	line,	"include\variables.c", 40; list_objects_x_pos[25],
 1614                        		.dbg	line,	"include\variables.c", 41; list_objects_y_pos[25],
 1615                        		.dbg	line,	"include\variables.c", 42; list_objects_x_pos_ref[25],
 1616                        		.dbg	line,	"include\variables.c", 43; list_objects_y_pos_ref[25],
 1617                        		.dbg	line,	"include\variables.c", 44; list_objects_energy[25];
 1618                        		.dbg	line,	"include\variables.c", 49; signed int      *ptr_objects_pos_x_ref;
 1619                        		.dbg	line,	"include\variables.c", 50; signed int      *ptr_objects_pos_y_ref;
 1620                        		.dbg	line,	"include\variables.c", 54; extern unsigned char tileset_LV1_BG_B[];
 1621                        		.dbg	line,	"include\variables.c", 55; extern unsigned char multimap_LV1_BG_B[];
 1622                        		.dbg	line,	"include\variables.c", 57; extern unsigned char tileset_LV1_BG_A[];
 1623                        		.dbg	line,	"include\variables.c", 58; extern unsigned char multimap_LV1_BG_A[];
 1624                        		.dbg	line,	"main.c", 15; #include "include/gfx_BG.c"
 1625                        		.dbg	line,	"include\gfx_BG.c", 1; #include "huc.h"
 1626                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 1; #ifndef _hucc_legacy_h
 1627                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 2; #define _hucc_legacy_h
 1628                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 4; /****************************************************************************
 1629                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 5; ; ***************************************************************************
 1630                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 6; ;
 1631                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 7; ; huc.h
 1632                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 8; ;
 1633                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 9; ; HuCC wrapper file to include a default set of HuC-compatible functions.
 1634                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 10; ;
 1635                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 11; ; Copyright John Brandwood 2024.
 1636                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 12; ;
 1637                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 13; ; Distributed under the Boost Software License, Version 1.0.
 1638                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 14; ; (See accompanying file LICENSE_1_0.txt or copy at
 1639                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 15; ;  http://www.boost.org/LICENSE_1_0.txt)
 1640                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 16; ;
 1641                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 17; ; ***************************************************************************
 1642                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 18; ; ***************************************************************************
 1643                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 19; ;
 1644                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 20; ; When the HuCC compiler is invoked with the "--legacy" option to compile old
 1645                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 21; ; projects, then this "huc.h" file is automatically included.
 1646                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 22; ;
 1647                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 23; ; This file includes a set of the individual HuCC headers which correspond to
 1648                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 24; ; HuC's built-in functions and MagicKit library.
 1649                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 25; ;
 1650                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 26; ; New HuCC projects should, preferably, include the specific headers that are
 1651                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 27; ; needed, which will then allow them to replace parts of the standard library
 1652                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 28; ; with newer functions, or they can just manually include this "huc.h" file.
 1653                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 29; ;
 1654                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 30; ; ***************************************************************************
 1655                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 31; ; **************************************************************************/
 1656                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 33; #include "hucc-systemcard.h"
 1657                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 34; #include "hucc-baselib.h"
 1658                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 35; #include "hucc-gfx.h"
 1659                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 36; #include "hucc-string.h"
 1660                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 37; #include "hucc-old-scroll.h"
 1661                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 38; #include "hucc-old-spr.h"
 1662                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 39; #include "hucc-old-map.h"
 1663                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 40; #include "hucc-old-line.h"
 1664                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 42; #endif // _hucc_legacy_h
 1665                        		.dbg	line,	"include\gfx_BG.c", 2; #include "hucc-scroll.h"
 1666                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 1; #ifndef _hucc_scroll_h
 1667                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 2; #define _hucc_scroll_h
 1668                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 4; /****************************************************************************
 1669                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 5; ; ***************************************************************************
 1670                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 6; ;
 1671                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 7; ; hucc-scroll.h
 1672                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 8; ;
 1673                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 9; ; Routines for a fast split-screen scrolling system.
 1674                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 10; ;
 1675                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 11; ; Copyright John Brandwood 2024.
 1676                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 12; ;
 1677                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 13; ; Distributed under the Boost Software License, Version 1.0.
 1678                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 14; ; (See accompanying file LICENSE_1_0.txt or copy at
 1679                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 15; ;  http://www.boost.org/LICENSE_1_0.txt)
 1680                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 16; ;
 1681                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 17; ; ***************************************************************************
 1682                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 18; ; ***************************************************************************
 1683                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 19; ;
 1684                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 20; ; The maximum number of splits for each screen layer is set in your project's
 1685                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 21; ; "hucc-config.inc" file, with the library having a limit of 128-per-layer.
 1686                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 22; ;
 1687                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 23; ; Your first active split must be defined to start at screen line 0, and then
 1688                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 24; ; the rest of the active splits must be in increasing line order to match the
 1689                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 25; ; way that the PC Engine displays the output image.
 1690                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 26; ;
 1691                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 27; ; You can have disabled splits interleaved with your active splits.
 1692                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 28; ;
 1693                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 29; ; Splits that are normally disabled can be used to create full screen effects
 1694                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 30; ; such as bouncing the screen up and down by adding blank areas at the top or
 1695                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 31; ; bottom of the screen, and then rapidly changing the height of those areas.
 1696                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 32; ;
 1697                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 33; ; ***************************************************************************
 1698                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 34; ; **************************************************************************/
 1699                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 36; // *************
 1700                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 37; // VDC bits for display_flags ...
 1701                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 38; // *************
 1702                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 40; #ifndef BKG_OFF
 1703                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 41; #define BKG_OFF 0x00
 1704                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 42; #endif
 1705                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 44; #ifndef SPR_OFF
 1706                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 45; #define SPR_OFF 0x00
 1707                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 46; #endif
 1708                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 48; #ifndef BKG_ON
 1709                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 49; #define BKG_ON 0x80
 1710                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 50; #endif
 1711                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 52; #ifndef SPR_ON
 1712                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 53; #define SPR_ON 0x40
 1713                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 54; #endif
 1714                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 56; // *************
 1715                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 57; // Functions in hucc-scroll.asm ...
 1716                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 58; // *************
 1717                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 60; #ifdef __HUCC__
 1718                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 62; #asmdef	HUCC_USES_NEW_SCROLL 1
 1719                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 64; extern void __fastcall scroll_split( unsigned char index<_al>, unsigned char screen_line<_ah>, unsigned int bat_x<_bx>, unsigned int bat_y<_cx>, unsigned char display_flags<_dl> );
 1720                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 65; extern void __fastcall sgx_scroll_split( unsigned char index<_al>, unsigned char screen_line<_ah>, unsigned int bat_x<_bx>, unsigned int bat_y<_cx>, unsigned char display_flags<_dl> );
 1721                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 67; extern void __fastcall disable_split( unsigned char index<acc> );
 1722                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 68; extern void __fastcall sgx_disable_split( unsigned char index<acc> );
 1723                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 70; extern void __fastcall __macro disable_all_splits( void );
 1724                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 71; extern void __fastcall __macro sgx_disable_all_splits( void );
 1725                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 73; #asm
 1726                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 74; .macro	_disable_all_splits
 1727                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 75; ldy	#HUCC_PCE_SPLITS - 1
 1728                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 76; !loop:		tya
 1729                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 77; call	_disable_split.1
 1730                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 78; dey
 1731                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 79; bpl	!loop-
 1732                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 80; .endm
 1733                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 82; .macro	_sgx_disable_all_splits
 1734                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 83; ldy	#HUCC_SGX_SPLITS - 1
 1735                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 84; !loop:		tya
 1736                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 85; call	_sgx_disable_split.1
 1737                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 86; dey
 1738                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 87; bpl	!loop-
 1739                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 88; .endm
 1740                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 89; #endasm
 1741                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 91; #endif // __HUCC__
 1742                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 93; #endif // _hucc_scroll_h
 1743                        		.dbg	line,	"include\gfx_BG.c", 3; #include "hucc-chrmap.h"
 1744                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 1; #ifndef _hucc_chrmap_h
 1745                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 2; #define _hucc_chrmap_h
 1746                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 4; /****************************************************************************
 1747                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 5; ; ***************************************************************************
 1748                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 6; ;
 1749                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 7; ; hucc-chrmap.h
 1750                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 8; ;
 1751                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 9; ; A simple map system based on 8x8 characters (aka "tiles") in BAT format.
 1752                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 10; ;
 1753                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 11; ; Copyright John Brandwood 2025.
 1754                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 12; ;
 1755                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 13; ; Distributed under the Boost Software License, Version 1.0.
 1756                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 14; ; (See accompanying file LICENSE_1_0.txt or copy at
 1757                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 15; ;  http://www.boost.org/LICENSE_1_0.txt)
 1758                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 16; ;
 1759                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 17; ; ***************************************************************************
 1760                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 18; ; ***************************************************************************
 1761                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 19; ;
 1762                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 20; ; The maximum X and Y size for chrmaps is 256 characters (2048 pixels).
 1763                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 21; ;
 1764                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 22; ; The maximum total size for a chrmap is 16KBytes, which allows for maps up
 1765                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 23; ; to 256x32 tiles (2048x256 pixels).
 1766                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 24; ;
 1767                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 25; ; ***************************************************************************
 1768                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 26; ; **************************************************************************/
 1769                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 28; // *************
 1770                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 29; // This code extends the blkmap library ...
 1771                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 30; // *************
 1772                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 32; #include "hucc-blkmap.h"
 1773                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 34; // *************
 1774                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 35; // Functions in chrmap.asm ...
 1775                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 36; // *************
 1776                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 38; #ifdef __HUCC__
 1777                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 40; #asmdef	HUCC_USES_CHRMAP 1
 1778                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 42; extern void __fastcall __nop set_chrmap( unsigned char __far *chrmap<vdc_map_bank:vdc_map_addr>, unsigned char tiles_w<vdc_map_line_w> );
 1779                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 44; extern void __fastcall draw_bat( void );
 1780                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 45; extern void __fastcall scroll_bat( void );
 1781                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 47; extern void __fastcall blit_bat( unsigned char tile_x<map_bat_x>, unsigned char tile_y<map_bat_y>, unsigned char tile_w<map_draw_x>, unsigned char tile_h<map_draw_y> );
 1782                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 49; #ifdef _SGX
 1783                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 51; extern void __fastcall __nop sgx_set_chrmap( unsigned char __far *chrmap<sgx_map_bank:sgx_map_addr>, unsigned char tiles_w<sgx_map_line_w> );
 1784                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 53; extern void __fastcall sgx_draw_bat( void );
 1785                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 54; extern void __fastcall sgx_scroll_bat( void );
 1786                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 56; extern void __fastcall sgx_blit_bat( unsigned char tile_x<map_bat_x>, unsigned char tile_y<map_bat_y>, unsigned char tile_w<map_draw_x>, unsigned char tile_h<map_draw_y> );
 1787                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 58; #endif
 1788                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 60; #endif // __HUCC__
 1789                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 62; #endif // _hucc_chrmap_h
 1790                        		.dbg	line,	"include\gfx_BG.c", 4; #include "hucc-blkmap.h"
 1791                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 1; #ifndef _hucc_blkmap_h
 1792                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 2; #define _hucc_blkmap_h
 1793                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 4; /****************************************************************************
 1794                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 5; ; ***************************************************************************
 1795                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 6; ;
 1796                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 7; ; hucc-blkmap.h
 1797                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 8; ;
 1798                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 9; ; A map system based on 16x16 meta-tiles (aka "blocks", aka CHR/BLK/MAP).
 1799                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 10; ;
 1800                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 11; ; Copyright John Brandwood 2025.
 1801                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 12; ;
 1802                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 13; ; Distributed under the Boost Software License, Version 1.0.
 1803                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 14; ; (See accompanying file LICENSE_1_0.txt or copy at
 1804                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 15; ;  http://www.boost.org/LICENSE_1_0.txt)
 1805                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 16; ;
 1806                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 17; ; ***************************************************************************
 1807                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 18; ; ***************************************************************************
 1808                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 19; ;
 1809                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 20; ; The maximum X and Y size for blkmaps is 128 blocks (2048 pixels).
 1810                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 21; ;
 1811                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 22; ; The maximum total size for a blkmap is 16KBytes, which allows for maps up
 1812                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 23; ; to 128x128 blocks (2048x2048 pixels).
 1813                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 24; ;
 1814                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 25; ; Huge multi-screen blkmaps are also supported (optionally).
 1815                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 26; ;
 1816                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 27; ; The maximum X and Y for multi-screen maps is 128 screens (32768 pixels).
 1817                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 28; ;
 1818                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 29; ; The maximum total size for a multi-screen map is 8KBytes, which allows for
 1819                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 30; ; a total of 1024 screens.
 1820                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 31; ;
 1821                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 32; ; ***************************************************************************
 1822                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 33; ; **************************************************************************/
 1823                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 35; // *************
 1824                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 36; // Functions in blkmap.asm ...
 1825                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 37; // *************
 1826                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 39; #ifdef __HUCC__
 1827                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 41; #asmdef	HUCC_USES_BLKMAP 1
 1828                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 43; // Current top-left of drawn map in pixels.
 1829                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 44; extern unsigned int   vdc_map_pxl_x;
 1830                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 45; extern unsigned int   vdc_map_pxl_y;
 1831                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 47; // Width and height to draw/scroll in characters (not tiles).
 1832                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 48; extern unsigned char  vdc_map_draw_w;
 1833                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 49; extern unsigned char  vdc_map_draw_h;
 1834                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 51; // Width of map (or multi-screen BAT) in tiles.
 1835                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 52; extern unsigned char  vdc_map_line_w;
 1836                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 54; // Width of map in screens (if multi-screen map).
 1837                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 55; extern unsigned char  vdc_map_scrn_w;
 1838                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 57; // Extra information returned by get_map_block() and sgx_get_map_block(),
 1839                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 58; // which are the collision flags and the mask/overlay sprite for the BLK.
 1840                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 59; extern unsigned char  map_blk_flag;
 1841                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 60; extern unsigned char  map_blk_mask;
 1842                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 62; extern unsigned char  vdc_scr_bank;
 1843                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 63; extern unsigned char *vdc_scr_addr;
 1844                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 65; extern unsigned char  vdc_map_bank;
 1845                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 66; extern unsigned char *vdc_map_addr;
 1846                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 68; extern unsigned char  vdc_blk_bank;
 1847                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 69; extern unsigned char *vdc_blk_addr;
 1848                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 71; extern unsigned char  vdc_tbl_bank;
 1849                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 72; extern unsigned char *vdc_tbl_addr;
 1850                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 74; extern void __fastcall set_blocks( unsigned char __far *blk_def<vdc_blk_bank:vdc_blk_addr>, unsigned char __far *flg_def<vdc_tbl_bank:vdc_tbl_addr>, unsigned char number_of_blocks<_al> );
 1851                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 75; extern void __fastcall __macro set_blkmap( unsigned char __far *blk_map<vdc_map_bank:vdc_map_addr>, unsigned char blocks_w<vdc_map_line_w> );
 1852                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 76; extern void __fastcall __macro set_multimap( unsigned char __far *multi_map<vdc_scr_bank:vdc_scr_addr>, unsigned char screens_w<vdc_map_scrn_w> );
 1853                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 78; extern void __fastcall draw_map( void );
 1854                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 79; extern void __fastcall scroll_map( void );
 1855                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 81; extern void __fastcall blit_map( unsigned char tile_x<map_bat_x>, unsigned char tile_y<map_bat_y>, unsigned char tile_w<map_draw_x>, unsigned char tile_h<map_draw_y> );
 1856                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 83; extern unsigned char __fastcall get_map_block( unsigned int x<map_pxl_x>, unsigned int y<map_pxl_y> );
 1857                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 85; #asm
 1858                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 86; .macro	_set_blkmap.2
 1859                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 87; stz	vdc_scr_bank
 1860                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 88; .endm
 1861                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 90; .macro	_set_multimap.2
 1862                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 91; lda	vdc_bat_width
 1863                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 92; lsr	a
 1864                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 93; sta	vdc_map_line_w
 1865                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 94; .endm
 1866                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 96; .macro	SCREEN
 1867                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 97; db	(((\1) & $1FFF) | $6000) >> 8, bank(\1)
 1868                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 98; db	(((\2) & $1FFF) | $4000) >> 8, bank(\2)
 1869                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 99; db	(((\3) & $1FFF) | $6000) >> 8, bank(\3)
 1870                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 100; dw	(\4)
 1871                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 101; .endm
 1872                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 102; #endasm
 1873                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 104; #ifdef _SGX
 1874                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 106; // Current top-left of drawn map in pixels.
 1875                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 107; extern unsigned int   sgx_map_pxl_x;
 1876                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 108; extern unsigned int   sgx_map_pxl_y;
 1877                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 110; // Width and height to draw/scroll in characters (not tiles).
 1878                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 111; extern unsigned char  sgx_map_draw_w;
 1879                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 112; extern unsigned char  sgx_map_draw_h;
 1880                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 114; // Width of map (or multi-screen BAT) in tiles.
 1881                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 115; extern unsigned char  sgx_map_line_w;
 1882                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 117; // Width of map in screens (if multi-screen map).
 1883                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 118; extern unsigned char  sgx_map_scrn_w;
 1884                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 120; extern unsigned char  sgx_scr_bank;
 1885                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 121; extern unsigned char *sgx_scr_addr;
 1886                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 123; extern unsigned char  sgx_map_bank;
 1887                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 124; extern unsigned char *sgx_map_addr;
 1888                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 126; extern unsigned char  sgx_blk_bank;
 1889                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 127; extern unsigned char *sgx_blk_addr;
 1890                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 129; extern unsigned char  sgx_tbl_bank;
 1891                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 130; extern unsigned char *sgx_tbl_addr;
 1892                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 132; extern void __fastcall sgx_set_blocks( unsigned char __far *blk_def<sgx_blk_bank:sgx_blk_addr>, unsigned char __far *flg_def<sgx_tbl_bank:sgx_tbl_addr>, unsigned char number_of_blocks<_al> );
 1893                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 133; extern void __fastcall __macro sgx_set_blkmap( unsigned char __far *blk_map<sgx_map_bank:sgx_map_addr>, unsigned char blocks_w<sgx_map_line_w> );
 1894                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 134; extern void __fastcall __macro sgx_set_multimap( unsigned char __far *multi_map<sgx_scr_bank:sgx_scr_addr>, unsigned char screens_w<sgx_map_scrn_w> );
 1895                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 136; extern void __fastcall sgx_draw_map( void );
 1896                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 137; extern void __fastcall sgx_scroll_map( void );
 1897                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 139; extern void __fastcall sgx_blit_map( unsigned char tile_x<map_bat_x>, unsigned char tile_y<map_bat_y>, unsigned char tile_w<map_draw_x>, unsigned char tile_h<map_draw_y> );
 1898                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 141; extern unsigned char __fastcall sgx_get_map_block( unsigned int x<map_pxl_x>, unsigned int y<map_pxl_y> );
 1899                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 143; #asm
 1900                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 144; .macro	_sgx_set_blkmap.2
 1901                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 145; stz	sgx_scr_bank
 1902                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 146; .endm
 1903                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 148; .macro	_sgx_set_multimap.2
 1904                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 149; lda	sgx_bat_width
 1905                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 150; lsr	a
 1906                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 151; sta	sgx_map_line_w
 1907                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 152; .endm
 1908                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 153; #endasm
 1909                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 155; #endif
 1910                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 157; #endif // __HUCC__
 1911                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 159; #endif // _hucc_blkmap_h
 1912                        		.dbg	line,	"include\gfx_BG.c", 13; //**************************************************************************************//
 1913                        		.dbg	line,	"include\gfx_BG.c", 14; //                                                                                      //
 1914                        		.dbg	line,	"include\gfx_BG.c", 15; //                                       LEVEL 1                                        //
 1915                        		.dbg	line,	"include\gfx_BG.c", 16; //                                                                                      //
 1916                        		.dbg	line,	"include\gfx_BG.c", 17; //**************************************************************************************//
 1917                        		.dbg	line,	"include\gfx_BG.c", 19; #incchr(tileset_LV1_WALL,"res/maps/tiles_LV1_WALL.png", 4 , 4);
 1918               6000     		.data
 1919    03:6000             	_tileset_LV1_WALL: 	.incchr		"res/maps/tiles_LV1_WALL.png", 4, 4
 1920               E309     		.code
 1921                        		.dbg	line,	"include\gfx_BG.c", 20; #incchr(tileset_LV1_DOOR_OPEN,"res/maps/tiles_LV1_DOOR_OPEN.png", 4 , 6);
 1922               6200     		.data
 1923    03:6200             	_tileset_LV1_DOOR_OPEN: 	.incchr		"res/maps/tiles_LV1_DOOR_OPEN.png", 4, 6
 1924               E309     		.code
 1925                        		.dbg	line,	"include\gfx_BG.c", 21; #incchr(tileset_LV1_DOOR_CLOSED,"res/maps/tiles_LV1_DOOR_CLOSED.png", 4 , 6);
 1926               6500     		.data
 1927    03:6500             	_tileset_LV1_DOOR_CLOSED: 	.incchr		"res/maps/tiles_LV1_DOOR_CLOSED.png", 4, 6
 1928               E309     		.code
 1929                        		.dbg	line,	"include\gfx_BG.c", 23; #incchr(tileset_LIFE_RED,"res/maps/tileset_LIFE_RED.png", 2 , 1);
 1930               6800     		.data
 1931    03:6800             	_tileset_LIFE_RED: 	.incchr		"res/maps/tileset_LIFE_RED.png", 2, 1
 1932               E309     		.code
 1933                        		.dbg	line,	"include\gfx_BG.c", 24; #incchr(tileset_LIFE_ORANGE,"res/maps/tileset_LIFE_ORANGE.png", 2 , 1);
 1934               6840     		.data
 1935    03:6840             	_tileset_LIFE_ORANGE: 	.incchr		"res/maps/tileset_LIFE_ORANGE.png", 2, 1
 1936               E309     		.code
 1937                        		.dbg	line,	"include\gfx_BG.c", 25; #incchr(tileset_LIFE_YELLOW,"res/maps/tileset_LIFE_YELLOW.png", 2 , 1);
 1938               6880     		.data
 1939    03:6880             	_tileset_LIFE_YELLOW: 	.incchr		"res/maps/tileset_LIFE_YELLOW.png", 2, 1
 1940               E309     		.code
 1941                        		.dbg	line,	"include\gfx_BG.c", 26; #incchr(tileset_LIFE_EMPTY,"res/maps/tileset_LIFE_EMPTY.png", 2 , 1);
 1942               68C0     		.data
 1943    03:68C0             	_tileset_LIFE_EMPTY: 	.incchr		"res/maps/tileset_LIFE_EMPTY.png", 2, 1
 1944               E309     		.code
 1945                        		.dbg	line,	"include\gfx_BG.c", 28; #incchr(tileset_ARMOR_1,"res/maps/tileset_ARMOR_1.png", 2 , 2);
 1946               6900     		.data
 1947    03:6900             	_tileset_ARMOR_1: 	.incchr		"res/maps/tileset_ARMOR_1.png", 2, 2
 1948               E309     		.code
 1949                        		.dbg	line,	"include\gfx_BG.c", 29; #incchr(tileset_ARMOR_2,"res/maps/tileset_ARMOR_2.png", 2 , 2);
 1950               6980     		.data
 1951    03:6980             	_tileset_ARMOR_2: 	.incchr		"res/maps/tileset_ARMOR_2.png", 2, 2
 1952               E309     		.code
 1953                        		.dbg	line,	"include\gfx_BG.c", 30; #incchr(tileset_ARMOR_4,"res/maps/tileset_ARMOR_4.png", 2 , 2);
 1954               6A00     		.data
 1955    03:6A00             	_tileset_ARMOR_4: 	.incchr		"res/maps/tileset_ARMOR_4.png", 2, 2
 1956               E309     		.code
 1957                        		.dbg	line,	"include\gfx_BG.c", 31; #incchr(tileset_ARMOR_8,"res/maps/tileset_ARMOR_8.png", 2 , 2);
 1958               6A80     		.data
 1959    03:6A80             	_tileset_ARMOR_8: 	.incchr		"res/maps/tileset_ARMOR_8.png", 2, 2
 1960               E309     		.code
 1961                        		.dbg	line,	"include\gfx_BG.c", 33; #incchr(tileset_WEAPON_1,"res/maps/tileset_WEAPON_1.png", 2 , 2);
 1962               6B00     		.data
 1963    03:6B00             	_tileset_WEAPON_1: 	.incchr		"res/maps/tileset_WEAPON_1.png", 2, 2
 1964               E309     		.code
 1965                        		.dbg	line,	"include\gfx_BG.c", 34; #incchr(tileset_WEAPON_2,"res/maps/tileset_WEAPON_2.png", 2 , 2);
 1966               6B80     		.data
 1967    03:6B80             	_tileset_WEAPON_2: 	.incchr		"res/maps/tileset_WEAPON_2.png", 2, 2
 1968               E309     		.code
 1969                        		.dbg	line,	"include\gfx_BG.c", 35; #incchr(tileset_WEAPON_4,"res/maps/tileset_WEAPON_4.png", 2 , 2);
 1970               6C00     		.data
 1971    03:6C00             	_tileset_WEAPON_4: 	.incchr		"res/maps/tileset_WEAPON_4.png", 2, 2
 1972               E309     		.code
 1973                        		.dbg	line,	"include\gfx_BG.c", 36; #incchr(tileset_WEAPON_5,"res/maps/tileset_WEAPON_5.png", 2 , 2);
 1974               6C80     		.data
 1975    03:6C80             	_tileset_WEAPON_5: 	.incchr		"res/maps/tileset_WEAPON_5.png", 2, 2
 1976               E309     		.code
 1977                        		.dbg	line,	"include\gfx_BG.c", 37; #incchr(tileset_WEAPON_8,"res/maps/tileset_WEAPON_8.png", 2 , 2);
 1978               6D00     		.data
 1979    03:6D00             	_tileset_WEAPON_8: 	.incchr		"res/maps/tileset_WEAPON_8.png", 2, 2
 1980               E309     		.code
 1981                        		.dbg	line,	"include\gfx_BG.c", 40; //--------------------------------------------------------------------------------------//
 1982                        		.dbg	line,	"include\gfx_BG.c", 41; //                                        VDC 2                                         //
 1983                        		.dbg	line,	"include\gfx_BG.c", 42; //--------------------------------------------------------------------------------------//
 1984                        		.dbg	line,	"include\gfx_BG.c", 44; #asm
 1985                        		.dbg	clear
 1986               0001     	OPTIMIZE	=	1
 1987               6D80     			.data
 1988                        	; EXTRACT TILESET
 1989                        	;----------------
 1990    03:6D80             	_tileset_LV1_BG_B:  incchr	"res/maps/template_LV1_WALL.png"
 1991    03:6F80             			incchr	"res/maps/template_LV1_DOOR.png"
 1992    03:7280             			incchr	"res/maps/tilemap_LV1_BG_B.png", OPTIMIZE
 1993                        	; EXTRACT BLOCKS
 1994                        	;--------------
 1995    07:6800             	blocks_LV1_BG_B1:	incblk	"res/maps/tilemap_LV1_BG_B.png" , 0x1000 ,    0 ,   0 ,  64 , 32 , _tileset_LV1_BG_B ; // 96x16 = 1536 | 32x16 =  512
 1996    07:7000             	blocks_LV1_BG_B2:	incblk	"res/maps/tilemap_LV1_BG_B.png" , 0x1000 , 1024 ,   0 ,  96 , 32 , _tileset_LV1_BG_B ; // 64x16 = 1024 | 32x16 =  512
 1997    07:7800             	blocks_LV1_BG_B3:	incblk	"res/maps/tilemap_LV1_BG_B.png" , 0x1000 ,    0 , 512 ,  64 , 32 , _tileset_LV1_BG_B ; // 96x16 = 1536 | 16x16 =  256
 1998    08:6000             	blocks_LV1_BG_B4:	incblk	"res/maps/tilemap_LV1_BG_B.png" , 0x1000 , 1024 , 512 ,  96 , 32 , _tileset_LV1_BG_B ; // 64x16 = 1024 | 16x16 =  256
 1999                        	; EXTRACT MAPS
 2000                        	;------------
 2001               6800     			align	256
 2002    08:6800             	MAP_LV1_BG_B1:		incmap	"res/maps/tilemap_LV1_BG_B.png",    0 ,   0 ,  64 , 32 , blocks_LV1_BG_B1 ; // 96x16 = 1536 | 32x16 =  512
 2003               7000     			align	256
 2004    08:7000             	MAP_LV1_BG_B2:		incmap	"res/maps/tilemap_LV1_BG_B.png", 1024 ,   0 ,  96 , 32 , blocks_LV1_BG_B2 ; // 64x16 = 1024 | 32x16 =  512
 2005               7C00     			align	256
 2006    08:7C00             	MAP_LV1_BG_B3:		incmap	"res/maps/tilemap_LV1_BG_B.png",    0 , 512 ,  64 , 32 , blocks_LV1_BG_B3 ; // 96x16 = 1536 | 16x16 =  256
 2007               6400     			align	256
 2008    09:6400             	MAP_LV1_BG_B4:		incmap	"res/maps/tilemap_LV1_BG_B.png", 1024 , 512 ,  96 , 32 , blocks_LV1_BG_B4 ; // 64x16 = 1024 | 16x16 =  256
 2009                        	; MASK (EMPTY)
 2010                        	;----------------
 2011    09:7000  00 00 00 00	dummy_tbl:	ds	256
         09:7004  00 00 00 00 
         09:7008  00 00 00 00 
         09:700C  00 00 00 00 
         09:7010  00 00 00 00 
         09:7014  00 00 00 00 
         09:7018  00 00 00 00 
         09:701C  00 00 00 00 
         09:7020  00 00 00 00 
         09:7024  00 00 00 00 
         09:7028  00 00 00 00 
         09:702C  00 00 00 00 
         09:7030  00 00 00 00 
         09:7034  00 00 00 00 
         09:7038  00 00 00 00 
         09:703C  00 00 00 00 
         09:7040  00 00 00 00 
         09:7044  00 00 00 00 
         09:7048  00 00 00 00 
         09:704C  00 00 00 00 
         09:7050  00 00 00 00 
         09:7054  00 00 00 00 
         09:7058  00 00 00 00 
         09:705C  00 00 00 00 
         09:7060  00 00 00 00 
         09:7064  00 00 00 00 
         09:7068  00 00 00 00 
         09:706C  00 00 00 00 
         09:7070  00 00 00 00 
         09:7074  00 00 00 00 
         09:7078  00 00 00 00 
         09:707C  00 00 00 00 
         09:7080  00 00 00 00 
         09:7084  00 00 00 00 
         09:7088  00 00 00 00 
         09:708C  00 00 00 00 
         09:7090  00 00 00 00 
         09:7094  00 00 00 00 
         09:7098  00 00 00 00 
         09:709C  00 00 00 00 
         09:70A0  00 00 00 00 
         09:70A4  00 00 00 00 
         09:70A8  00 00 00 00 
         09:70AC  00 00 00 00 
         09:70B0  00 00 00 00 
         09:70B4  00 00 00 00 
         09:70B8  00 00 00 00 
         09:70BC  00 00 00 00 
         09:70C0  00 00 00 00 
         09:70C4  00 00 00 00 
         09:70C8  00 00 00 00 
         09:70CC  00 00 00 00 
         09:70D0  00 00 00 00 
         09:70D4  00 00 00 00 
         09:70D8  00 00 00 00 
         09:70DC  00 00 00 00 
         09:70E0  00 00 00 00 
         09:70E4  00 00 00 00 
         09:70E8  00 00 00 00 
         09:70EC  00 00 00 00 
         09:70F0  00 00 00 00 
         09:70F4  00 00 00 00 
         09:70F8  00 00 00 00 
         09:70FC  00 00 00 00 
 2012                        	; SWIZZLE MAPS
 2013                        	;-------------
 2014    09:7100             	swizzle	MAP_LV1_BG_B1,  32, 16 ;
 2015    09:7100             	swizzle	MAP_LV1_BG_B2,  32, 16 ;
 2016    09:7100             	swizzle	MAP_LV1_BG_B3,  32, 16 ;
 2017    09:7100             	swizzle	MAP_LV1_BG_B4,  32, 16 ;
 2018                        	; BUILD MULTIMAP
 2019                        	;---------------
 2020    09:7100             	_multimap_LV1_BG_B:
 2021                        			; 1st line of 5 screens (512x256)
 2022                        			SCREEN MAP_LV1_BG_B1 + 0x0000, blocks_LV1_BG_B1, dummy_tbl, 0
         09:7100  68 08      			db	(((MAP_LV1_BG_B1 + 0x0000) & $1FFF) | $6000) >> 8, bank(MAP_LV1_BG_B1 + 0x0000)
         09:7102  48 07      			db	(((blocks_LV1_BG_B1) & $1FFF) | $4000) >> 8, bank(blocks_LV1_BG_B1)
         09:7104  70 09      			db	(((dummy_tbl) & $1FFF) | $6000) >> 8, bank(dummy_tbl)
         09:7106  00 00      			dw	(0)
 2023                        			SCREEN MAP_LV1_BG_B1 + 0x0200, blocks_LV1_BG_B1, dummy_tbl, 0
         09:7108  6A 08      			db	(((MAP_LV1_BG_B1 + 0x0200) & $1FFF) | $6000) >> 8, bank(MAP_LV1_BG_B1 + 0x0200)
         09:710A  48 07      			db	(((blocks_LV1_BG_B1) & $1FFF) | $4000) >> 8, bank(blocks_LV1_BG_B1)
         09:710C  70 09      			db	(((dummy_tbl) & $1FFF) | $6000) >> 8, bank(dummy_tbl)
         09:710E  00 00      			dw	(0)
 2024                        			SCREEN MAP_LV1_BG_B2 + 0x0000, blocks_LV1_BG_B2, dummy_tbl, 0
         09:7110  70 08      			db	(((MAP_LV1_BG_B2 + 0x0000) & $1FFF) | $6000) >> 8, bank(MAP_LV1_BG_B2 + 0x0000)
         09:7112  50 07      			db	(((blocks_LV1_BG_B2) & $1FFF) | $4000) >> 8, bank(blocks_LV1_BG_B2)
         09:7114  70 09      			db	(((dummy_tbl) & $1FFF) | $6000) >> 8, bank(dummy_tbl)
         09:7116  00 00      			dw	(0)
 2025                        			SCREEN MAP_LV1_BG_B2 + 0x0200, blocks_LV1_BG_B2, dummy_tbl, 0
         09:7118  72 08      			db	(((MAP_LV1_BG_B2 + 0x0200) & $1FFF) | $6000) >> 8, bank(MAP_LV1_BG_B2 + 0x0200)
         09:711A  50 07      			db	(((blocks_LV1_BG_B2) & $1FFF) | $4000) >> 8, bank(blocks_LV1_BG_B2)
         09:711C  70 09      			db	(((dummy_tbl) & $1FFF) | $6000) >> 8, bank(dummy_tbl)
         09:711E  00 00      			dw	(0)
 2026                        			SCREEN MAP_LV1_BG_B2 + 0x0400, blocks_LV1_BG_B2, dummy_tbl, 0
         09:7120  74 08      			db	(((MAP_LV1_BG_B2 + 0x0400) & $1FFF) | $6000) >> 8, bank(MAP_LV1_BG_B2 + 0x0400)
         09:7122  50 07      			db	(((blocks_LV1_BG_B2) & $1FFF) | $4000) >> 8, bank(blocks_LV1_BG_B2)
         09:7124  70 09      			db	(((dummy_tbl) & $1FFF) | $6000) >> 8, bank(dummy_tbl)
         09:7126  00 00      			dw	(0)
 2027                        			; 2nd line of 5 screens (512x256)
 2028                        			SCREEN MAP_LV1_BG_B1 + 0x0400, blocks_LV1_BG_B1, dummy_tbl, 0
         09:7128  6C 08      			db	(((MAP_LV1_BG_B1 + 0x0400) & $1FFF) | $6000) >> 8, bank(MAP_LV1_BG_B1 + 0x0400)
         09:712A  48 07      			db	(((blocks_LV1_BG_B1) & $1FFF) | $4000) >> 8, bank(blocks_LV1_BG_B1)
         09:712C  70 09      			db	(((dummy_tbl) & $1FFF) | $6000) >> 8, bank(dummy_tbl)
         09:712E  00 00      			dw	(0)
 2029                        			SCREEN MAP_LV1_BG_B1 + 0x0600, blocks_LV1_BG_B1, dummy_tbl, 0
         09:7130  6E 08      			db	(((MAP_LV1_BG_B1 + 0x0600) & $1FFF) | $6000) >> 8, bank(MAP_LV1_BG_B1 + 0x0600)
         09:7132  48 07      			db	(((blocks_LV1_BG_B1) & $1FFF) | $4000) >> 8, bank(blocks_LV1_BG_B1)
         09:7134  70 09      			db	(((dummy_tbl) & $1FFF) | $6000) >> 8, bank(dummy_tbl)
         09:7136  00 00      			dw	(0)
 2030                        			SCREEN MAP_LV1_BG_B2 + 0x0600, blocks_LV1_BG_B2, dummy_tbl, 0
         09:7138  76 08      			db	(((MAP_LV1_BG_B2 + 0x0600) & $1FFF) | $6000) >> 8, bank(MAP_LV1_BG_B2 + 0x0600)
         09:713A  50 07      			db	(((blocks_LV1_BG_B2) & $1FFF) | $4000) >> 8, bank(blocks_LV1_BG_B2)
         09:713C  70 09      			db	(((dummy_tbl) & $1FFF) | $6000) >> 8, bank(dummy_tbl)
         09:713E  00 00      			dw	(0)
 2031                        			SCREEN MAP_LV1_BG_B2 + 0x0800, blocks_LV1_BG_B2, dummy_tbl, 0
         09:7140  78 08      			db	(((MAP_LV1_BG_B2 + 0x0800) & $1FFF) | $6000) >> 8, bank(MAP_LV1_BG_B2 + 0x0800)
         09:7142  50 07      			db	(((blocks_LV1_BG_B2) & $1FFF) | $4000) >> 8, bank(blocks_LV1_BG_B2)
         09:7144  70 09      			db	(((dummy_tbl) & $1FFF) | $6000) >> 8, bank(dummy_tbl)
         09:7146  00 00      			dw	(0)
 2032                        			SCREEN MAP_LV1_BG_B2 + 0x0A00, blocks_LV1_BG_B2, dummy_tbl, 0
         09:7148  7A 08      			db	(((MAP_LV1_BG_B2 + 0x0A00) & $1FFF) | $6000) >> 8, bank(MAP_LV1_BG_B2 + 0x0A00)
         09:714A  50 07      			db	(((blocks_LV1_BG_B2) & $1FFF) | $4000) >> 8, bank(blocks_LV1_BG_B2)
         09:714C  70 09      			db	(((dummy_tbl) & $1FFF) | $6000) >> 8, bank(dummy_tbl)
         09:714E  00 00      			dw	(0)
 2033                        			; 3rd line of 5 screens (512x256)
 2034                        			SCREEN MAP_LV1_BG_B3 + 0x0000, blocks_LV1_BG_B3, dummy_tbl, 0
         09:7150  7C 08      			db	(((MAP_LV1_BG_B3 + 0x0000) & $1FFF) | $6000) >> 8, bank(MAP_LV1_BG_B3 + 0x0000)
         09:7152  58 07      			db	(((blocks_LV1_BG_B3) & $1FFF) | $4000) >> 8, bank(blocks_LV1_BG_B3)
         09:7154  70 09      			db	(((dummy_tbl) & $1FFF) | $6000) >> 8, bank(dummy_tbl)
         09:7156  00 00      			dw	(0)
 2035                        			SCREEN MAP_LV1_BG_B3 + 0x0200, blocks_LV1_BG_B3, dummy_tbl, 0
         09:7158  7E 08      			db	(((MAP_LV1_BG_B3 + 0x0200) & $1FFF) | $6000) >> 8, bank(MAP_LV1_BG_B3 + 0x0200)
         09:715A  58 07      			db	(((blocks_LV1_BG_B3) & $1FFF) | $4000) >> 8, bank(blocks_LV1_BG_B3)
         09:715C  70 09      			db	(((dummy_tbl) & $1FFF) | $6000) >> 8, bank(dummy_tbl)
         09:715E  00 00      			dw	(0)
 2036                        			SCREEN MAP_LV1_BG_B4 + 0x0000, blocks_LV1_BG_B4, dummy_tbl, 0
         09:7160  64 09      			db	(((MAP_LV1_BG_B4 + 0x0000) & $1FFF) | $6000) >> 8, bank(MAP_LV1_BG_B4 + 0x0000)
         09:7162  40 08      			db	(((blocks_LV1_BG_B4) & $1FFF) | $4000) >> 8, bank(blocks_LV1_BG_B4)
         09:7164  70 09      			db	(((dummy_tbl) & $1FFF) | $6000) >> 8, bank(dummy_tbl)
         09:7166  00 00      			dw	(0)
 2037                        			SCREEN MAP_LV1_BG_B4 + 0x0200, blocks_LV1_BG_B4, dummy_tbl, 0
         09:7168  66 09      			db	(((MAP_LV1_BG_B4 + 0x0200) & $1FFF) | $6000) >> 8, bank(MAP_LV1_BG_B4 + 0x0200)
         09:716A  40 08      			db	(((blocks_LV1_BG_B4) & $1FFF) | $4000) >> 8, bank(blocks_LV1_BG_B4)
         09:716C  70 09      			db	(((dummy_tbl) & $1FFF) | $6000) >> 8, bank(dummy_tbl)
         09:716E  00 00      			dw	(0)
 2038                        			SCREEN MAP_LV1_BG_B4 + 0x0400, blocks_LV1_BG_B4, dummy_tbl, 0
         09:7170  68 09      			db	(((MAP_LV1_BG_B4 + 0x0400) & $1FFF) | $6000) >> 8, bank(MAP_LV1_BG_B4 + 0x0400)
         09:7172  40 08      			db	(((blocks_LV1_BG_B4) & $1FFF) | $4000) >> 8, bank(blocks_LV1_BG_B4)
         09:7174  70 09      			db	(((dummy_tbl) & $1FFF) | $6000) >> 8, bank(dummy_tbl)
         09:7176  00 00      			dw	(0)
 2039                        			; 4th line of 5 screens (512x256)
 2040                        			SCREEN MAP_LV1_BG_B3 + 0x0400, blocks_LV1_BG_B3, dummy_tbl, 0
         09:7178  60 09      			db	(((MAP_LV1_BG_B3 + 0x0400) & $1FFF) | $6000) >> 8, bank(MAP_LV1_BG_B3 + 0x0400)
         09:717A  58 07      			db	(((blocks_LV1_BG_B3) & $1FFF) | $4000) >> 8, bank(blocks_LV1_BG_B3)
         09:717C  70 09      			db	(((dummy_tbl) & $1FFF) | $6000) >> 8, bank(dummy_tbl)
         09:717E  00 00      			dw	(0)
 2041                        			SCREEN MAP_LV1_BG_B3 + 0x0600, blocks_LV1_BG_B3, dummy_tbl, 0
         09:7180  62 09      			db	(((MAP_LV1_BG_B3 + 0x0600) & $1FFF) | $6000) >> 8, bank(MAP_LV1_BG_B3 + 0x0600)
         09:7182  58 07      			db	(((blocks_LV1_BG_B3) & $1FFF) | $4000) >> 8, bank(blocks_LV1_BG_B3)
         09:7184  70 09      			db	(((dummy_tbl) & $1FFF) | $6000) >> 8, bank(dummy_tbl)
         09:7186  00 00      			dw	(0)
 2042                        			SCREEN MAP_LV1_BG_B4 + 0x0600, blocks_LV1_BG_B4, dummy_tbl, 0
         09:7188  6A 09      			db	(((MAP_LV1_BG_B4 + 0x0600) & $1FFF) | $6000) >> 8, bank(MAP_LV1_BG_B4 + 0x0600)
         09:718A  40 08      			db	(((blocks_LV1_BG_B4) & $1FFF) | $4000) >> 8, bank(blocks_LV1_BG_B4)
         09:718C  70 09      			db	(((dummy_tbl) & $1FFF) | $6000) >> 8, bank(dummy_tbl)
         09:718E  00 00      			dw	(0)
 2043                        			SCREEN MAP_LV1_BG_B4 + 0x0800, blocks_LV1_BG_B4, dummy_tbl, 0
         09:7190  6C 09      			db	(((MAP_LV1_BG_B4 + 0x0800) & $1FFF) | $6000) >> 8, bank(MAP_LV1_BG_B4 + 0x0800)
         09:7192  40 08      			db	(((blocks_LV1_BG_B4) & $1FFF) | $4000) >> 8, bank(blocks_LV1_BG_B4)
         09:7194  70 09      			db	(((dummy_tbl) & $1FFF) | $6000) >> 8, bank(dummy_tbl)
         09:7196  00 00      			dw	(0)
 2044                        			SCREEN MAP_LV1_BG_B4 + 0x0A00, blocks_LV1_BG_B4, dummy_tbl, 0
         09:7198  6E 09      			db	(((MAP_LV1_BG_B4 + 0x0A00) & $1FFF) | $6000) >> 8, bank(MAP_LV1_BG_B4 + 0x0A00)
         09:719A  40 08      			db	(((blocks_LV1_BG_B4) & $1FFF) | $4000) >> 8, bank(blocks_LV1_BG_B4)
         09:719C  70 09      			db	(((dummy_tbl) & $1FFF) | $6000) >> 8, bank(dummy_tbl)
         09:719E  00 00      			dw	(0)
 2045                        	;//--------------------------------------------------------------------------------------//
 2046                        	;//                                        VDC 1                                         //
 2047                        	;//--------------------------------------------------------------------------------------//
 2048                        	; EXTRACT TILESET
 2049                        	;----------------
 2050    09:71A0             	_tileset_LV1_BG_A:	incchr	"res/maps/template_LIFEBAR_1.png"
 2051    09:71E0             			incchr	"res/maps/template_LIFEBAR_2.png"
 2052    09:7220             			incchr	"res/maps/template_LIFEBAR_3.png"
 2053    09:7260             			incchr	"res/maps/template_LIFEBAR_4.png"
 2054    09:72A0             			incchr	"res/maps/template_LIFEBAR_5.png"
 2055    09:72E0             			incchr	"res/maps/tileset_WEAPON_1.png"
 2056    09:7360             			incchr	"res/maps/tileset_ARMOR_1.png"
 2057    09:73E0             			incchr	"res/maps/tilemap_LV1_BG_A.png", OPTIMIZE
 2058                        	; EXTRACT BLOCKS
 2059                        	;--------------
 2060    0A:6000             	blocks_LV1_BG_A1:	incblk	"res/maps/tilemap_LV1_BG_A.png" , 0x1000 ,    0 ,   0 , 128 , 64 , _tileset_LV1_BG_A ; // 128x16 = 2048 | 64x16 = 1024
 2061    0A:6800             	blocks_LV1_BG_A2:	incblk	"res/maps/tilemap_LV1_BG_A.png" , 0x1000 , 2048 ,   0 ,  32 , 64 , _tileset_LV1_BG_A ; //  32x16 =  512 | 64x16 = 1024
 2062                        	; EXTRACT MAPS
 2063                        	;------------
 2064               7000     			align	256
 2065    0A:7000             	MAP_LV1_BG_A1:		incmap	"res/maps/tilemap_LV1_BG_A.png",    0 ,   0 , 128 , 64 , blocks_LV1_BG_A1 ; // 128x16 = 2048 | 64x16 = 1024
 2066    0B:7000             			flagmap "res/maps/collision_LV1.png",       0 ,   0 , 128 , 64 , MAP_LV1_BG_A1
 2067               7000     			align	256
 2068    0B:7000             	MAP_LV1_BG_A2:		incmap	"res/maps/tilemap_LV1_BG_A.png", 2048 ,   0 ,  32 , 64 , blocks_LV1_BG_A2 ; //  32x16 =  512 | 64x16 = 1024
 2069    0B:7800             			flagmap "res/maps/collision_LV1.png",    2048 ,   0 ,  32 , 64 , MAP_LV1_BG_A2
 2070                        	; SWIZZLE MAPS
 2071                        	;-------------
 2072    0B:7800             	swizzle	MAP_LV1_BG_A1,  32, 16 ;
 2073    0B:7800             	swizzle	MAP_LV1_BG_A2,  32, 16 ;
 2074                        	; BUILD MULTIMAP
 2075                        	;---------------
 2076    0B:7800             	_multimap_LV1_BG_A:
 2077                        			; 1st line of 5 screens (512x256)
 2078                        			SCREEN MAP_LV1_BG_A1 + 0x0000, blocks_LV1_BG_A1, dummy_tbl, 0
         0B:7800  70 0A      			db	(((MAP_LV1_BG_A1 + 0x0000) & $1FFF) | $6000) >> 8, bank(MAP_LV1_BG_A1 + 0x0000)
         0B:7802  40 0A      			db	(((blocks_LV1_BG_A1) & $1FFF) | $4000) >> 8, bank(blocks_LV1_BG_A1)
         0B:7804  70 09      			db	(((dummy_tbl) & $1FFF) | $6000) >> 8, bank(dummy_tbl)
         0B:7806  00 00      			dw	(0)
 2079                        			SCREEN MAP_LV1_BG_A1 + 0x0200, blocks_LV1_BG_A1, dummy_tbl, 0
         0B:7808  72 0A      			db	(((MAP_LV1_BG_A1 + 0x0200) & $1FFF) | $6000) >> 8, bank(MAP_LV1_BG_A1 + 0x0200)
         0B:780A  40 0A      			db	(((blocks_LV1_BG_A1) & $1FFF) | $4000) >> 8, bank(blocks_LV1_BG_A1)
         0B:780C  70 09      			db	(((dummy_tbl) & $1FFF) | $6000) >> 8, bank(dummy_tbl)
         0B:780E  00 00      			dw	(0)
 2080                        			SCREEN MAP_LV1_BG_A1 + 0x0400, blocks_LV1_BG_A1, dummy_tbl, 0
         0B:7810  74 0A      			db	(((MAP_LV1_BG_A1 + 0x0400) & $1FFF) | $6000) >> 8, bank(MAP_LV1_BG_A1 + 0x0400)
         0B:7812  40 0A      			db	(((blocks_LV1_BG_A1) & $1FFF) | $4000) >> 8, bank(blocks_LV1_BG_A1)
         0B:7814  70 09      			db	(((dummy_tbl) & $1FFF) | $6000) >> 8, bank(dummy_tbl)
         0B:7816  00 00      			dw	(0)
 2081                        			SCREEN MAP_LV1_BG_A1 + 0x0600, blocks_LV1_BG_A1, dummy_tbl, 0
         0B:7818  76 0A      			db	(((MAP_LV1_BG_A1 + 0x0600) & $1FFF) | $6000) >> 8, bank(MAP_LV1_BG_A1 + 0x0600)
         0B:781A  40 0A      			db	(((blocks_LV1_BG_A1) & $1FFF) | $4000) >> 8, bank(blocks_LV1_BG_A1)
         0B:781C  70 09      			db	(((dummy_tbl) & $1FFF) | $6000) >> 8, bank(dummy_tbl)
         0B:781E  00 00      			dw	(0)
 2082                        			SCREEN MAP_LV1_BG_A2 + 0x0000, blocks_LV1_BG_A2, dummy_tbl, 0
         0B:7820  70 0B      			db	(((MAP_LV1_BG_A2 + 0x0000) & $1FFF) | $6000) >> 8, bank(MAP_LV1_BG_A2 + 0x0000)
         0B:7822  48 0A      			db	(((blocks_LV1_BG_A2) & $1FFF) | $4000) >> 8, bank(blocks_LV1_BG_A2)
         0B:7824  70 09      			db	(((dummy_tbl) & $1FFF) | $6000) >> 8, bank(dummy_tbl)
         0B:7826  00 00      			dw	(0)
 2083                        			; 2nd line of 5 screens (512x256)
 2084                        			SCREEN MAP_LV1_BG_A1 + 0x0800, blocks_LV1_BG_A1, dummy_tbl, 0
         0B:7828  78 0A      			db	(((MAP_LV1_BG_A1 + 0x0800) & $1FFF) | $6000) >> 8, bank(MAP_LV1_BG_A1 + 0x0800)
         0B:782A  40 0A      			db	(((blocks_LV1_BG_A1) & $1FFF) | $4000) >> 8, bank(blocks_LV1_BG_A1)
         0B:782C  70 09      			db	(((dummy_tbl) & $1FFF) | $6000) >> 8, bank(dummy_tbl)
         0B:782E  00 00      			dw	(0)
 2085                        			SCREEN MAP_LV1_BG_A1 + 0x0A00, blocks_LV1_BG_A1, dummy_tbl, 0
         0B:7830  7A 0A      			db	(((MAP_LV1_BG_A1 + 0x0A00) & $1FFF) | $6000) >> 8, bank(MAP_LV1_BG_A1 + 0x0A00)
         0B:7832  40 0A      			db	(((blocks_LV1_BG_A1) & $1FFF) | $4000) >> 8, bank(blocks_LV1_BG_A1)
         0B:7834  70 09      			db	(((dummy_tbl) & $1FFF) | $6000) >> 8, bank(dummy_tbl)
         0B:7836  00 00      			dw	(0)
 2086                        			SCREEN MAP_LV1_BG_A1 + 0x0C00, blocks_LV1_BG_A1, dummy_tbl, 0
         0B:7838  7C 0A      			db	(((MAP_LV1_BG_A1 + 0x0C00) & $1FFF) | $6000) >> 8, bank(MAP_LV1_BG_A1 + 0x0C00)
         0B:783A  40 0A      			db	(((blocks_LV1_BG_A1) & $1FFF) | $4000) >> 8, bank(blocks_LV1_BG_A1)
         0B:783C  70 09      			db	(((dummy_tbl) & $1FFF) | $6000) >> 8, bank(dummy_tbl)
         0B:783E  00 00      			dw	(0)
 2087                        			SCREEN MAP_LV1_BG_A1 + 0x0E00, blocks_LV1_BG_A1, dummy_tbl, 0
         0B:7840  7E 0A      			db	(((MAP_LV1_BG_A1 + 0x0E00) & $1FFF) | $6000) >> 8, bank(MAP_LV1_BG_A1 + 0x0E00)
         0B:7842  40 0A      			db	(((blocks_LV1_BG_A1) & $1FFF) | $4000) >> 8, bank(blocks_LV1_BG_A1)
         0B:7844  70 09      			db	(((dummy_tbl) & $1FFF) | $6000) >> 8, bank(dummy_tbl)
         0B:7846  00 00      			dw	(0)
 2088                        			SCREEN MAP_LV1_BG_A2 + 0x0200, blocks_LV1_BG_A2, dummy_tbl, 0
         0B:7848  72 0B      			db	(((MAP_LV1_BG_A2 + 0x0200) & $1FFF) | $6000) >> 8, bank(MAP_LV1_BG_A2 + 0x0200)
         0B:784A  48 0A      			db	(((blocks_LV1_BG_A2) & $1FFF) | $4000) >> 8, bank(blocks_LV1_BG_A2)
         0B:784C  70 09      			db	(((dummy_tbl) & $1FFF) | $6000) >> 8, bank(dummy_tbl)
         0B:784E  00 00      			dw	(0)
 2089                        			; 3rd line of 5 screens (512x256)
 2090                        			SCREEN MAP_LV1_BG_A1 + 0x1000, blocks_LV1_BG_A1, dummy_tbl, 0
         0B:7850  60 0B      			db	(((MAP_LV1_BG_A1 + 0x1000) & $1FFF) | $6000) >> 8, bank(MAP_LV1_BG_A1 + 0x1000)
         0B:7852  40 0A      			db	(((blocks_LV1_BG_A1) & $1FFF) | $4000) >> 8, bank(blocks_LV1_BG_A1)
         0B:7854  70 09      			db	(((dummy_tbl) & $1FFF) | $6000) >> 8, bank(dummy_tbl)
         0B:7856  00 00      			dw	(0)
 2091                        			SCREEN MAP_LV1_BG_A1 + 0x1200, blocks_LV1_BG_A1, dummy_tbl, 0
         0B:7858  62 0B      			db	(((MAP_LV1_BG_A1 + 0x1200) & $1FFF) | $6000) >> 8, bank(MAP_LV1_BG_A1 + 0x1200)
         0B:785A  40 0A      			db	(((blocks_LV1_BG_A1) & $1FFF) | $4000) >> 8, bank(blocks_LV1_BG_A1)
         0B:785C  70 09      			db	(((dummy_tbl) & $1FFF) | $6000) >> 8, bank(dummy_tbl)
         0B:785E  00 00      			dw	(0)
 2092                        			SCREEN MAP_LV1_BG_A1 + 0x1400, blocks_LV1_BG_A1, dummy_tbl, 0
         0B:7860  64 0B      			db	(((MAP_LV1_BG_A1 + 0x1400) & $1FFF) | $6000) >> 8, bank(MAP_LV1_BG_A1 + 0x1400)
         0B:7862  40 0A      			db	(((blocks_LV1_BG_A1) & $1FFF) | $4000) >> 8, bank(blocks_LV1_BG_A1)
         0B:7864  70 09      			db	(((dummy_tbl) & $1FFF) | $6000) >> 8, bank(dummy_tbl)
         0B:7866  00 00      			dw	(0)
 2093                        			SCREEN MAP_LV1_BG_A1 + 0x1600, blocks_LV1_BG_A1, dummy_tbl, 0
         0B:7868  66 0B      			db	(((MAP_LV1_BG_A1 + 0x1600) & $1FFF) | $6000) >> 8, bank(MAP_LV1_BG_A1 + 0x1600)
         0B:786A  40 0A      			db	(((blocks_LV1_BG_A1) & $1FFF) | $4000) >> 8, bank(blocks_LV1_BG_A1)
         0B:786C  70 09      			db	(((dummy_tbl) & $1FFF) | $6000) >> 8, bank(dummy_tbl)
         0B:786E  00 00      			dw	(0)
 2094                        			SCREEN MAP_LV1_BG_A2 + 0x0400, blocks_LV1_BG_A2, dummy_tbl, 0
         0B:7870  74 0B      			db	(((MAP_LV1_BG_A2 + 0x0400) & $1FFF) | $6000) >> 8, bank(MAP_LV1_BG_A2 + 0x0400)
         0B:7872  48 0A      			db	(((blocks_LV1_BG_A2) & $1FFF) | $4000) >> 8, bank(blocks_LV1_BG_A2)
         0B:7874  70 09      			db	(((dummy_tbl) & $1FFF) | $6000) >> 8, bank(dummy_tbl)
         0B:7876  00 00      			dw	(0)
 2095                        			; 4th line of 5 screens (512x256)
 2096                        			SCREEN MAP_LV1_BG_A1 + 0x1800, blocks_LV1_BG_A1, dummy_tbl, 0
         0B:7878  68 0B      			db	(((MAP_LV1_BG_A1 + 0x1800) & $1FFF) | $6000) >> 8, bank(MAP_LV1_BG_A1 + 0x1800)
         0B:787A  40 0A      			db	(((blocks_LV1_BG_A1) & $1FFF) | $4000) >> 8, bank(blocks_LV1_BG_A1)
         0B:787C  70 09      			db	(((dummy_tbl) & $1FFF) | $6000) >> 8, bank(dummy_tbl)
         0B:787E  00 00      			dw	(0)
 2097                        			SCREEN MAP_LV1_BG_A1 + 0x1A00, blocks_LV1_BG_A1, dummy_tbl, 0
         0B:7880  6A 0B      			db	(((MAP_LV1_BG_A1 + 0x1A00) & $1FFF) | $6000) >> 8, bank(MAP_LV1_BG_A1 + 0x1A00)
         0B:7882  40 0A      			db	(((blocks_LV1_BG_A1) & $1FFF) | $4000) >> 8, bank(blocks_LV1_BG_A1)
         0B:7884  70 09      			db	(((dummy_tbl) & $1FFF) | $6000) >> 8, bank(dummy_tbl)
         0B:7886  00 00      			dw	(0)
 2098                        			SCREEN MAP_LV1_BG_A1 + 0x1C00, blocks_LV1_BG_A1, dummy_tbl, 0
         0B:7888  6C 0B      			db	(((MAP_LV1_BG_A1 + 0x1C00) & $1FFF) | $6000) >> 8, bank(MAP_LV1_BG_A1 + 0x1C00)
         0B:788A  40 0A      			db	(((blocks_LV1_BG_A1) & $1FFF) | $4000) >> 8, bank(blocks_LV1_BG_A1)
         0B:788C  70 09      			db	(((dummy_tbl) & $1FFF) | $6000) >> 8, bank(dummy_tbl)
         0B:788E  00 00      			dw	(0)
 2099                        			SCREEN MAP_LV1_BG_A1 + 0x1E00, blocks_LV1_BG_A1, dummy_tbl, 0
         0B:7890  6E 0B      			db	(((MAP_LV1_BG_A1 + 0x1E00) & $1FFF) | $6000) >> 8, bank(MAP_LV1_BG_A1 + 0x1E00)
         0B:7892  40 0A      			db	(((blocks_LV1_BG_A1) & $1FFF) | $4000) >> 8, bank(blocks_LV1_BG_A1)
         0B:7894  70 09      			db	(((dummy_tbl) & $1FFF) | $6000) >> 8, bank(dummy_tbl)
         0B:7896  00 00      			dw	(0)
 2100                        			SCREEN MAP_LV1_BG_A2 + 0x0600, blocks_LV1_BG_A2, dummy_tbl, 0
         0B:7898  76 0B      			db	(((MAP_LV1_BG_A2 + 0x0600) & $1FFF) | $6000) >> 8, bank(MAP_LV1_BG_A2 + 0x0600)
         0B:789A  48 0A      			db	(((blocks_LV1_BG_A2) & $1FFF) | $4000) >> 8, bank(blocks_LV1_BG_A2)
         0B:789C  70 09      			db	(((dummy_tbl) & $1FFF) | $6000) >> 8, bank(dummy_tbl)
         0B:789E  00 00      			dw	(0)
 2101               E309     			.code
 2102                        	
 2103                        		.dbg	line,	"include\gfx_BG.c", 204; #endasm
 2104                        		.dbg	line,	"include\gfx_BG.c", 208; //--------------------------------------------------------------------------------------//
 2105                        		.dbg	line,	"include\gfx_BG.c", 209; //                                   EXTRACT PALETTES                                   //
 2106                        		.dbg	line,	"include\gfx_BG.c", 210; //--------------------------------------------------------------------------------------//
 2107                        		.dbg	line,	"include\gfx_BG.c", 212; // EXTRACT PALETTE //
 2108                        		.dbg	line,	"include\gfx_BG.c", 213; #incpal(palette_LV1,"res/maps/tilemap_LV1_BG_B.png");
 2109               78A0     		.data
 2110    0B:78A0             	_palette_LV1:	.incpal		"res/maps/tilemap_LV1_BG_B.png"
 2111               E309     		.code
 2112                        		.dbg	line,	"main.c", 16; #include "include/gfx_SPRITES.c"
 2113                        		.dbg	line,	"include\gfx_SPRITES.c", 1; #include "huc.h"
 2114                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 1; #ifndef _hucc_legacy_h
 2115                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 2; #define _hucc_legacy_h
 2116                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 4; /****************************************************************************
 2117                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 5; ; ***************************************************************************
 2118                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 6; ;
 2119                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 7; ; huc.h
 2120                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 8; ;
 2121                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 9; ; HuCC wrapper file to include a default set of HuC-compatible functions.
 2122                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 10; ;
 2123                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 11; ; Copyright John Brandwood 2024.
 2124                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 12; ;
 2125                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 13; ; Distributed under the Boost Software License, Version 1.0.
 2126                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 14; ; (See accompanying file LICENSE_1_0.txt or copy at
 2127                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 15; ;  http://www.boost.org/LICENSE_1_0.txt)
 2128                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 16; ;
 2129                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 17; ; ***************************************************************************
 2130                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 18; ; ***************************************************************************
 2131                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 19; ;
 2132                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 20; ; When the HuCC compiler is invoked with the "--legacy" option to compile old
 2133                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 21; ; projects, then this "huc.h" file is automatically included.
 2134                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 22; ;
 2135                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 23; ; This file includes a set of the individual HuCC headers which correspond to
 2136                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 24; ; HuC's built-in functions and MagicKit library.
 2137                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 25; ;
 2138                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 26; ; New HuCC projects should, preferably, include the specific headers that are
 2139                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 27; ; needed, which will then allow them to replace parts of the standard library
 2140                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 28; ; with newer functions, or they can just manually include this "huc.h" file.
 2141                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 29; ;
 2142                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 30; ; ***************************************************************************
 2143                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 31; ; **************************************************************************/
 2144                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 33; #include "hucc-systemcard.h"
 2145                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 34; #include "hucc-baselib.h"
 2146                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 35; #include "hucc-gfx.h"
 2147                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 36; #include "hucc-string.h"
 2148                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 37; #include "hucc-old-scroll.h"
 2149                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 38; #include "hucc-old-spr.h"
 2150                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 39; #include "hucc-old-map.h"
 2151                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 40; #include "hucc-old-line.h"
 2152                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 42; #endif // _hucc_legacy_h
 2153                        		.dbg	line,	"include\gfx_SPRITES.c", 10; // EXTRACT PLAYER TILES //
 2154                        		.dbg	line,	"include\gfx_SPRITES.c", 11; #incspr(tiles_SPR_PLAYER,"res/sprites/tiles_SPR_PLAYER.png")
 2155               7AA0     		.data
 2156    0B:7AA0             	_tiles_SPR_PLAYER:	.incspr		"res/sprites/tiles_SPR_PLAYER.png"
 2157               E309     		.code
 2158                        		.dbg	line,	"include\gfx_SPRITES.c", 13; // EXTRACT PLAYER PALETTE //
 2159                        		.dbg	line,	"include\gfx_SPRITES.c", 14; #incpal(palette_PLAYER,"res/palettes/palette_PLAYER.png");
 2160               7AA0     		.data
 2161    0C:7AA0             	_palette_PLAYER:	.incpal		"res/palettes/palette_PLAYER.png"
 2162               E309     		.code
 2163                        		.dbg	line,	"include\gfx_SPRITES.c", 17; // EXTRACT OBJECTS TILES //
 2164                        		.dbg	line,	"include\gfx_SPRITES.c", 18; #incspr(tiles_SPR_BARREL,"res/sprites/tiles_SPR_BARREL.png")
 2165               7CA0     		.data
 2166    0C:7CA0             	_tiles_SPR_BARREL:	.incspr		"res/sprites/tiles_SPR_BARREL.png"
 2167               E309     		.code
 2168                        		.dbg	line,	"include\gfx_SPRITES.c", 19; #incspr(tiles_SPR_CHEST,"res/sprites/tiles_SPR_CHEST.png")
 2169               7D20     		.data
 2170    0C:7D20             	_tiles_SPR_CHEST:	.incspr		"res/sprites/tiles_SPR_CHEST.png"
 2171               E309     		.code
 2172                        		.dbg	line,	"include\gfx_SPRITES.c", 20; #incspr(tiles_SPR_COIN_1,"res/sprites/tiles_SPR_COIN_1.png")
 2173               7F20     		.data
 2174    0C:7F20             	_tiles_SPR_COIN_1:	.incspr		"res/sprites/tiles_SPR_COIN_1.png"
 2175               E309     		.code
 2176                        		.dbg	line,	"include\gfx_SPRITES.c", 21; #incspr(tiles_SPR_COIN_5,"res/sprites/tiles_SPR_COIN_5.png")
 2177               7FA0     		.data
 2178    0C:7FA0             	_tiles_SPR_COIN_5:	.incspr		"res/sprites/tiles_SPR_COIN_5.png"
 2179               E309     		.code
 2180                        		.dbg	line,	"include\gfx_SPRITES.c", 22; #incspr(tiles_SPR_COIN_10,"res/sprites/tiles_SPR_COIN_10.png")
 2181               6020     		.data
 2182    0D:6020             	_tiles_SPR_COIN_10:	.incspr		"res/sprites/tiles_SPR_COIN_10.png"
 2183               E309     		.code
 2184                        		.dbg	line,	"include\gfx_SPRITES.c", 23; #incspr(tiles_SPR_COIN_50,"res/sprites/tiles_SPR_COIN_50.png")
 2185               60A0     		.data
 2186    0D:60A0             	_tiles_SPR_COIN_50:	.incspr		"res/sprites/tiles_SPR_COIN_50.png"
 2187               E309     		.code
 2188                        		.dbg	line,	"include\gfx_SPRITES.c", 24; #incspr(tiles_SPR_COIN_100,"res/sprites/tiles_SPR_COIN_100.png")
 2189               6120     		.data
 2190    0D:6120             	_tiles_SPR_COIN_100:	.incspr		"res/sprites/tiles_SPR_COIN_100.png"
 2191               E309     		.code
 2192                        		.dbg	line,	"include\gfx_SPRITES.c", 25; #incspr(tiles_SPR_COIN_500,"res/sprites/tiles_SPR_COIN_500.png")
 2193               61A0     		.data
 2194    0D:61A0             	_tiles_SPR_COIN_500:	.incspr		"res/sprites/tiles_SPR_COIN_500.png"
 2195               E309     		.code
 2196                        		.dbg	line,	"include\gfx_SPRITES.c", 26; #incspr(tiles_SPR_COIN_1000,"res/sprites/tiles_SPR_COIN_1000.png")
 2197               6220     		.data
 2198    0D:6220             	_tiles_SPR_COIN_1000:	.incspr		"res/sprites/tiles_SPR_COIN_1000.png"
 2199               E309     		.code
 2200                        		.dbg	line,	"include\gfx_SPRITES.c", 27; #incspr(tiles_SPR_FRUIT,"res/sprites/tiles_SPR_FRUIT.png")
 2201               62A0     		.data
 2202    0D:62A0             	_tiles_SPR_FRUIT:	.incspr		"res/sprites/tiles_SPR_FRUIT.png"
 2203               E309     		.code
 2204                        		.dbg	line,	"include\gfx_SPRITES.c", 28; #incspr(tiles_SPR_GRAY_KEY,"res/sprites/tiles_SPR_GRAY_KEY.png")
 2205               6320     		.data
 2206    0D:6320             	_tiles_SPR_GRAY_KEY:	.incspr		"res/sprites/tiles_SPR_GRAY_KEY.png"
 2207               E309     		.code
 2208                        		.dbg	line,	"include\gfx_SPRITES.c", 29; #incspr(tiles_SPR_GOLD_KEY,"res/sprites/tiles_SPR_GOLD_KEY.png")
 2209               63A0     		.data
 2210    0D:63A0             	_tiles_SPR_GOLD_KEY:	.incspr		"res/sprites/tiles_SPR_GOLD_KEY.png"
 2211               E309     		.code
 2212                        		.dbg	line,	"include\gfx_SPRITES.c", 30; #incspr(tiles_SPR_HOURGLASS,"res/sprites/tiles_SPR_HOURGLASS.png")
 2213               6420     		.data
 2214    0D:6420             	_tiles_SPR_HOURGLASS:	.incspr		"res/sprites/tiles_SPR_HOURGLASS.png"
 2215               E309     		.code
 2216                        		.dbg	line,	"include\gfx_SPRITES.c", 31; #incspr(tiles_SPR_LIFE,"res/sprites/tiles_SPR_LIFE.png")
 2217               64A0     		.data
 2218    0D:64A0             	_tiles_SPR_LIFE:	.incspr		"res/sprites/tiles_SPR_LIFE.png"
 2219               E309     		.code
 2220                        		.dbg	line,	"include\gfx_SPRITES.c", 32; #incspr(tiles_SPR_OCTOPUS,"res/sprites/tiles_SPR_OCTOPUS.png")
 2221               6520     		.data
 2222    0D:6520             	_tiles_SPR_OCTOPUS:	.incspr		"res/sprites/tiles_SPR_OCTOPUS.png"
 2223               E309     		.code
 2224                        		.dbg	line,	"include\gfx_SPRITES.c", 33; #incspr(tiles_SPR_POT,"res/sprites/tiles_SPR_POT.png")
 2225               65A0     		.data
 2226    0D:65A0             	_tiles_SPR_POT:	.incspr		"res/sprites/tiles_SPR_POT.png"
 2227               E309     		.code
 2228                        		.dbg	line,	"include\gfx_SPRITES.c", 34; #incspr(tiles_SPR_POW,"res/sprites/tiles_SPR_POW.png")
 2229               69A0     		.data
 2230    0D:69A0             	_tiles_SPR_POW:	.incspr		"res/sprites/tiles_SPR_POW.png"
 2231               E309     		.code
 2232                        		.dbg	line,	"include\gfx_SPRITES.c", 35; #incspr(tiles_SPR_STAR,"res/sprites/tiles_SPR_STAR.png")
 2233               6A20     		.data
 2234    0D:6A20             	_tiles_SPR_STAR:	.incspr		"res/sprites/tiles_SPR_STAR.png"
 2235               E309     		.code
 2236                        		.dbg	line,	"include\gfx_SPRITES.c", 37; // EXTRACT OBJECTS PALETTE //
 2237                        		.dbg	line,	"include\gfx_SPRITES.c", 38; #incpal(palette_OBJECTS_1,"res/palettes/palette_OBJECTS_1.png");
 2238               6AA0     		.data
 2239    0D:6AA0             	_palette_OBJECTS_1:	.incpal		"res/palettes/palette_OBJECTS_1.png"
 2240               E309     		.code
 2241                        		.dbg	line,	"include\gfx_SPRITES.c", 39; #incpal(palette_OBJECTS_2,"res/palettes/palette_OBJECTS_2.png");
 2242               6CA0     		.data
 2243    0D:6CA0             	_palette_OBJECTS_2:	.incpal		"res/palettes/palette_OBJECTS_2.png"
 2244               E309     		.code
 2245                        		.dbg	line,	"include\gfx_SPRITES.c", 42; #incspr(tiles_SPR_HIT,"res/sprites/tiles_SPR_HIT.png")
 2246               6EA0     		.data
 2247    0D:6EA0             	_tiles_SPR_HIT:	.incspr		"res/sprites/tiles_SPR_HIT.png"
 2248               E309     		.code
 2249                        		.dbg	line,	"main.c", 20; #include "include/tables_objects.c"
 2250                        		.dbg	line,	"include\tables_objects.c", 1; //-----------------------------------------------------------------------------//
 2251                        		.dbg	line,	"include\tables_objects.c", 2; //                                                                             //
 2252                        		.dbg	line,	"include\tables_objects.c", 3; //                                   LEVEL 1                                   //
 2253                        		.dbg	line,	"include\tables_objects.c", 4; //                                                                             //
 2254                        		.dbg	line,	"include\tables_objects.c", 5; //-----------------------------------------------------------------------------//
 2255                        		.dbg	line,	"include\tables_objects.c", 7; const char              TABLE_OBJECTS_TYPE_LV1[OBJECTS_NUMBER_LV1]      =   {
 2256                        		.dbg	line,	"include\tables_objects.c", 8; TYPE_POT,//TYPE_HOURGLASS
 2257                        		.dbg	line,	"include\tables_objects.c", 9; TYPE_POT,
 2258                        		.dbg	line,	"include\tables_objects.c", 10; TYPE_POT,
 2259                        		.dbg	line,	"include\tables_objects.c", 11; TYPE_POT,
 2260                        		.dbg	line,	"include\tables_objects.c", 12; TYPE_POT,
 2261                        		.dbg	line,	"include\tables_objects.c", 13; TYPE_POT,
 2262                        		.dbg	line,	"include\tables_objects.c", 14; TYPE_POT,
 2263                        		.dbg	line,	"include\tables_objects.c", 15; TYPE_POW,
 2264                        		.dbg	line,	"include\tables_objects.c", 16; TYPE_POT,
 2265                        		.dbg	line,	"include\tables_objects.c", 17; TYPE_POT,
 2266                        		.dbg	line,	"include\tables_objects.c", 19; //
 2267                        		.dbg	line,	"include\tables_objects.c", 20; TYPE_POT,
 2268                        		.dbg	line,	"include\tables_objects.c", 21; TYPE_POT,
 2269                        		.dbg	line,	"include\tables_objects.c", 22; TYPE_POT,
 2270                        		.dbg	line,	"include\tables_objects.c", 23; TYPE_POT,
 2271                        		.dbg	line,	"include\tables_objects.c", 24; TYPE_POT,
 2272                        		.dbg	line,	"include\tables_objects.c", 25; TYPE_POT,
 2273                        		.dbg	line,	"include\tables_objects.c", 26; TYPE_POT,
 2274                        		.dbg	line,	"include\tables_objects.c", 27; TYPE_CHEST,
 2275                        		.dbg	line,	"include\tables_objects.c", 28; TYPE_CHEST,
 2276                        		.dbg	line,	"include\tables_objects.c", 29; TYPE_POT,
 2277                        		.dbg	line,	"include\tables_objects.c", 31; //
 2278                        		.dbg	line,	"include\tables_objects.c", 32; TYPE_POT,
 2279                        		.dbg	line,	"include\tables_objects.c", 33; TYPE_POT,
 2280                        		.dbg	line,	"include\tables_objects.c", 34; TYPE_POT,
 2281                        		.dbg	line,	"include\tables_objects.c", 35; TYPE_POT,
 2282                        		.dbg	line,	"include\tables_objects.c", 36; TYPE_POT
 2283                        		.dbg	line,	"include\tables_objects.c", 37; };
 2284                        		.dbg	line,	"include\tables_objects.c", 40; const signed int        TABLE_OBJECTS_X_POS_REF_LV1[OBJECTS_NUMBER_LV1] =   {
 2285                        		.dbg	line,	"include\tables_objects.c", 41; 1680,
 2286                        		.dbg	line,	"include\tables_objects.c", 42; 1280,
 2287                        		.dbg	line,	"include\tables_objects.c", 43; 1472,
 2288                        		.dbg	line,	"include\tables_objects.c", 44; 1440,
 2289                        		.dbg	line,	"include\tables_objects.c", 45; 1168,
 2290                        		.dbg	line,	"include\tables_objects.c", 46; 1200,
 2291                        		.dbg	line,	"include\tables_objects.c", 47; 960,
 2292                        		.dbg	line,	"include\tables_objects.c", 48; 984,
 2293                        		.dbg	line,	"include\tables_objects.c", 49; 1360,
 2294                        		.dbg	line,	"include\tables_objects.c", 50; 1392,
 2295                        		.dbg	line,	"include\tables_objects.c", 52; //
 2296                        		.dbg	line,	"include\tables_objects.c", 53; 1552,
 2297                        		.dbg	line,	"include\tables_objects.c", 54; 1680,
 2298                        		.dbg	line,	"include\tables_objects.c", 55; 1712,
 2299                        		.dbg	line,	"include\tables_objects.c", 56; 1744,
 2300                        		.dbg	line,	"include\tables_objects.c", 57; 1248,
 2301                        		.dbg	line,	"include\tables_objects.c", 58; 1280,
 2302                        		.dbg	line,	"include\tables_objects.c", 59; 1168,
 2303                        		.dbg	line,	"include\tables_objects.c", 60; 1072,
 2304                        		.dbg	line,	"include\tables_objects.c", 61; 816,
 2305                        		.dbg	line,	"include\tables_objects.c", 62; 1040,
 2306                        		.dbg	line,	"include\tables_objects.c", 64; //
 2307                        		.dbg	line,	"include\tables_objects.c", 65; 640,
 2308                        		.dbg	line,	"include\tables_objects.c", 66; 672,
 2309                        		.dbg	line,	"include\tables_objects.c", 67; 336,
 2310                        		.dbg	line,	"include\tables_objects.c", 68; 368,
 2311                        		.dbg	line,	"include\tables_objects.c", 69; 416
 2312                        		.dbg	line,	"include\tables_objects.c", 70; };
 2313                        		.dbg	line,	"include\tables_objects.c", 73; const signed int        TABLE_OBJECTS_Y_POS_REF_LV1[OBJECTS_NUMBER_LV1] =   {
 2314                        		.dbg	line,	"include\tables_objects.c", 74; 384,
 2315                        		.dbg	line,	"include\tables_objects.c", 75; 416,
 2316                        		.dbg	line,	"include\tables_objects.c", 76; 480,
 2317                        		.dbg	line,	"include\tables_objects.c", 77; 496,
 2318                        		.dbg	line,	"include\tables_objects.c", 78; 560,
 2319                        		.dbg	line,	"include\tables_objects.c", 79; 560,
 2320                        		.dbg	line,	"include\tables_objects.c", 80; 592,
 2321                        		.dbg	line,	"include\tables_objects.c", 81; 592,
 2322                        		.dbg	line,	"include\tables_objects.c", 82; 592,
 2323                        		.dbg	line,	"include\tables_objects.c", 83; 592,
 2324                        		.dbg	line,	"include\tables_objects.c", 85; //
 2325                        		.dbg	line,	"include\tables_objects.c", 86; 704,
 2326                        		.dbg	line,	"include\tables_objects.c", 87; 720,
 2327                        		.dbg	line,	"include\tables_objects.c", 88; 720,
 2328                        		.dbg	line,	"include\tables_objects.c", 89; 720,
 2329                        		.dbg	line,	"include\tables_objects.c", 90; 736,
 2330                        		.dbg	line,	"include\tables_objects.c", 91; 736,
 2331                        		.dbg	line,	"include\tables_objects.c", 92; 752,
 2332                        		.dbg	line,	"include\tables_objects.c", 93; 832,
 2333                        		.dbg	line,	"include\tables_objects.c", 94; 848,
 2334                        		.dbg	line,	"include\tables_objects.c", 95; 848,
 2335                        		.dbg	line,	"include\tables_objects.c", 97; //
 2336                        		.dbg	line,	"include\tables_objects.c", 98; 880,
 2337                        		.dbg	line,	"include\tables_objects.c", 99; 880,
 2338                        		.dbg	line,	"include\tables_objects.c", 100; 896,
 2339                        		.dbg	line,	"include\tables_objects.c", 101; 896,
 2340                        		.dbg	line,	"include\tables_objects.c", 102; 896
 2341                        		.dbg	line,	"main.c", 20; };
 2342                        		.dbg	line,	"main.c", 21; #include "include/tables_player.c"
 2343                        		.dbg	line,	"include\tables_player.c", 3; const signed char       TABLE_PLAYER_JUMP_V[35]     =   {
 2344                        		.dbg	line,	"include\tables_player.c", 4; // UPWARD
 2345                        		.dbg	line,	"include\tables_player.c", 5; -4,
 2346                        		.dbg	line,	"include\tables_player.c", 6; -5,
 2347                        		.dbg	line,	"include\tables_player.c", 7; -10,
 2348                        		.dbg	line,	"include\tables_player.c", 8; -4,
 2349                        		.dbg	line,	"include\tables_player.c", 9; -4,
 2350                        		.dbg	line,	"include\tables_player.c", 10; -7,
 2351                        		.dbg	line,	"include\tables_player.c", 11; -6,
 2352                        		.dbg	line,	"include\tables_player.c", 12; -3,
 2353                        		.dbg	line,	"include\tables_player.c", 13; -5,
 2354                        		.dbg	line,	"include\tables_player.c", 14; -2,
 2355                        		.dbg	line,	"include\tables_player.c", 15; -4,
 2356                        		.dbg	line,	"include\tables_player.c", 16; -1,
 2357                        		.dbg	line,	"include\tables_player.c", 17; -1,
 2358                        		.dbg	line,	"include\tables_player.c", 18; -1,
 2359                        		.dbg	line,	"include\tables_player.c", 19; -1,
 2360                        		.dbg	line,	"include\tables_player.c", 20; 0,
 2361                        		.dbg	line,	"include\tables_player.c", 21; 0,
 2362                        		.dbg	line,	"include\tables_player.c", 22; 0,
 2363                        		.dbg	line,	"include\tables_player.c", 23; 0,
 2364                        		.dbg	line,	"include\tables_player.c", 24; // DOWNWARD
 2365                        		.dbg	line,	"include\tables_player.c", 25; 1,
 2366                        		.dbg	line,	"include\tables_player.c", 26; 1,
 2367                        		.dbg	line,	"include\tables_player.c", 27; 1,
 2368                        		.dbg	line,	"include\tables_player.c", 28; 1,
 2369                        		.dbg	line,	"include\tables_player.c", 29; 4,
 2370                        		.dbg	line,	"include\tables_player.c", 30; 2,
 2371                        		.dbg	line,	"include\tables_player.c", 31; 5,
 2372                        		.dbg	line,	"include\tables_player.c", 32; 3,
 2373                        		.dbg	line,	"include\tables_player.c", 33; 6,
 2374                        		.dbg	line,	"include\tables_player.c", 34; 7,
 2375                        		.dbg	line,	"include\tables_player.c", 35; 4,
 2376                        		.dbg	line,	"include\tables_player.c", 36; 4,
 2377                        		.dbg	line,	"include\tables_player.c", 37; 10,
 2378                        		.dbg	line,	"include\tables_player.c", 38; 4,
 2379                        		.dbg	line,	"include\tables_player.c", 39; 4,
 2380                        		.dbg	line,	"include\tables_player.c", 40; 5
 2381                        		.dbg	line,	"include\tables_player.c", 41; };
 2382                        		.dbg	line,	"include\tables_player.c", 44; const signed char       TABLE_PLAYER_FALL[21]       =   {
 2383                        		.dbg	line,	"include\tables_player.c", 45; 0,
 2384                        		.dbg	line,	"include\tables_player.c", 46; 0,
 2385                        		.dbg	line,	"include\tables_player.c", 47; 0,
 2386                        		.dbg	line,	"include\tables_player.c", 48; 0,
 2387                        		.dbg	line,	"include\tables_player.c", 49; 1,
 2388                        		.dbg	line,	"include\tables_player.c", 50; 1,
 2389                        		.dbg	line,	"include\tables_player.c", 51; 1,
 2390                        		.dbg	line,	"include\tables_player.c", 52; 1,
 2391                        		.dbg	line,	"include\tables_player.c", 53; 2,
 2392                        		.dbg	line,	"include\tables_player.c", 54; 2,
 2393                        		.dbg	line,	"include\tables_player.c", 55; 2,
 2394                        		.dbg	line,	"include\tables_player.c", 56; 2,
 2395                        		.dbg	line,	"include\tables_player.c", 57; 3,
 2396                        		.dbg	line,	"include\tables_player.c", 58; 3,
 2397                        		.dbg	line,	"include\tables_player.c", 59; 3,
 2398                        		.dbg	line,	"include\tables_player.c", 60; 4,
 2399                        		.dbg	line,	"include\tables_player.c", 61; 4,
 2400                        		.dbg	line,	"include\tables_player.c", 62; 4,
 2401                        		.dbg	line,	"include\tables_player.c", 63; 4,
 2402                        		.dbg	line,	"include\tables_player.c", 64; 4,
 2403                        		.dbg	line,	"include\tables_player.c", 65; 5
 2404                        		.dbg	line,	"include\tables_player.c", 66; };
 2405                        		.dbg	line,	"include\tables_player.c", 69; const signed char       TABLE_PLAYER_JUMP_LADDER[30]    =   {
 2406                        		.dbg	line,	"include\tables_player.c", 70; // UPWARD
 2407                        		.dbg	line,	"include\tables_player.c", 71; -4,
 2408                        		.dbg	line,	"include\tables_player.c", 72; -4,
 2409                        		.dbg	line,	"include\tables_player.c", 73; -3,
 2410                        		.dbg	line,	"include\tables_player.c", 74; -3,
 2411                        		.dbg	line,	"include\tables_player.c", 75; -3,
 2412                        		.dbg	line,	"include\tables_player.c", 76; -2,
 2413                        		.dbg	line,	"include\tables_player.c", 77; -2,
 2414                        		.dbg	line,	"include\tables_player.c", 78; -2,
 2415                        		.dbg	line,	"include\tables_player.c", 79; -1,
 2416                        		.dbg	line,	"include\tables_player.c", 80; -1,
 2417                        		.dbg	line,	"include\tables_player.c", 81; -1,
 2418                        		.dbg	line,	"include\tables_player.c", 82; -1,
 2419                        		.dbg	line,	"include\tables_player.c", 83; -1,
 2420                        		.dbg	line,	"include\tables_player.c", 84; 0,
 2421                        		.dbg	line,	"include\tables_player.c", 85; 0,
 2422                        		.dbg	line,	"include\tables_player.c", 86; 0,
 2423                        		.dbg	line,	"include\tables_player.c", 87; 0,
 2424                        		.dbg	line,	"include\tables_player.c", 88; // DOWNWARD
 2425                        		.dbg	line,	"include\tables_player.c", 89; 1,
 2426                        		.dbg	line,	"include\tables_player.c", 90; 1,
 2427                        		.dbg	line,	"include\tables_player.c", 91; 1,
 2428                        		.dbg	line,	"include\tables_player.c", 92; 1,
 2429                        		.dbg	line,	"include\tables_player.c", 93; 1,
 2430                        		.dbg	line,	"include\tables_player.c", 94; 2,
 2431                        		.dbg	line,	"include\tables_player.c", 95; 2,
 2432                        		.dbg	line,	"include\tables_player.c", 96; 2,
 2433                        		.dbg	line,	"include\tables_player.c", 97; 3,
 2434                        		.dbg	line,	"include\tables_player.c", 98; 3,
 2435                        		.dbg	line,	"include\tables_player.c", 99; 3,
 2436                        		.dbg	line,	"include\tables_player.c", 100; 4,
 2437                        		.dbg	line,	"include\tables_player.c", 101; 4
 2438                        		.dbg	line,	"main.c", 21; };
 2439                        		.dbg	line,	"main.c", 22; #include "include/routines_LEVELS.c"
 2440                        		.dbg	line,	"include\routines_LEVELS.c", 1; #include "huc.h"
 2441                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 1; #ifndef _hucc_legacy_h
 2442                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 2; #define _hucc_legacy_h
 2443                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 4; /****************************************************************************
 2444                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 5; ; ***************************************************************************
 2445                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 6; ;
 2446                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 7; ; huc.h
 2447                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 8; ;
 2448                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 9; ; HuCC wrapper file to include a default set of HuC-compatible functions.
 2449                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 10; ;
 2450                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 11; ; Copyright John Brandwood 2024.
 2451                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 12; ;
 2452                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 13; ; Distributed under the Boost Software License, Version 1.0.
 2453                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 14; ; (See accompanying file LICENSE_1_0.txt or copy at
 2454                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 15; ;  http://www.boost.org/LICENSE_1_0.txt)
 2455                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 16; ;
 2456                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 17; ; ***************************************************************************
 2457                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 18; ; ***************************************************************************
 2458                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 19; ;
 2459                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 20; ; When the HuCC compiler is invoked with the "--legacy" option to compile old
 2460                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 21; ; projects, then this "huc.h" file is automatically included.
 2461                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 22; ;
 2462                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 23; ; This file includes a set of the individual HuCC headers which correspond to
 2463                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 24; ; HuC's built-in functions and MagicKit library.
 2464                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 25; ;
 2465                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 26; ; New HuCC projects should, preferably, include the specific headers that are
 2466                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 27; ; needed, which will then allow them to replace parts of the standard library
 2467                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 28; ; with newer functions, or they can just manually include this "huc.h" file.
 2468                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 29; ;
 2469                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 30; ; ***************************************************************************
 2470                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 31; ; **************************************************************************/
 2471                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 33; #include "hucc-systemcard.h"
 2472                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 34; #include "hucc-baselib.h"
 2473                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 35; #include "hucc-gfx.h"
 2474                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 36; #include "hucc-string.h"
 2475                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 37; #include "hucc-old-scroll.h"
 2476                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 38; #include "hucc-old-spr.h"
 2477                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 39; #include "hucc-old-map.h"
 2478                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 40; #include "hucc-old-line.h"
 2479                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 42; #endif // _hucc_legacy_h
 2480                        		.dbg	line,	"include\routines_LEVELS.c", 2; #include "hucc-scroll.h"
 2481                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 1; #ifndef _hucc_scroll_h
 2482                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 2; #define _hucc_scroll_h
 2483                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 4; /****************************************************************************
 2484                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 5; ; ***************************************************************************
 2485                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 6; ;
 2486                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 7; ; hucc-scroll.h
 2487                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 8; ;
 2488                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 9; ; Routines for a fast split-screen scrolling system.
 2489                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 10; ;
 2490                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 11; ; Copyright John Brandwood 2024.
 2491                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 12; ;
 2492                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 13; ; Distributed under the Boost Software License, Version 1.0.
 2493                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 14; ; (See accompanying file LICENSE_1_0.txt or copy at
 2494                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 15; ;  http://www.boost.org/LICENSE_1_0.txt)
 2495                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 16; ;
 2496                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 17; ; ***************************************************************************
 2497                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 18; ; ***************************************************************************
 2498                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 19; ;
 2499                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 20; ; The maximum number of splits for each screen layer is set in your project's
 2500                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 21; ; "hucc-config.inc" file, with the library having a limit of 128-per-layer.
 2501                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 22; ;
 2502                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 23; ; Your first active split must be defined to start at screen line 0, and then
 2503                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 24; ; the rest of the active splits must be in increasing line order to match the
 2504                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 25; ; way that the PC Engine displays the output image.
 2505                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 26; ;
 2506                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 27; ; You can have disabled splits interleaved with your active splits.
 2507                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 28; ;
 2508                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 29; ; Splits that are normally disabled can be used to create full screen effects
 2509                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 30; ; such as bouncing the screen up and down by adding blank areas at the top or
 2510                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 31; ; bottom of the screen, and then rapidly changing the height of those areas.
 2511                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 32; ;
 2512                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 33; ; ***************************************************************************
 2513                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 34; ; **************************************************************************/
 2514                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 36; // *************
 2515                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 37; // VDC bits for display_flags ...
 2516                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 38; // *************
 2517                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 40; #ifndef BKG_OFF
 2518                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 41; #define BKG_OFF 0x00
 2519                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 42; #endif
 2520                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 44; #ifndef SPR_OFF
 2521                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 45; #define SPR_OFF 0x00
 2522                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 46; #endif
 2523                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 48; #ifndef BKG_ON
 2524                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 49; #define BKG_ON 0x80
 2525                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 50; #endif
 2526                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 52; #ifndef SPR_ON
 2527                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 53; #define SPR_ON 0x40
 2528                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 54; #endif
 2529                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 56; // *************
 2530                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 57; // Functions in hucc-scroll.asm ...
 2531                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 58; // *************
 2532                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 60; #ifdef __HUCC__
 2533                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 62; #asmdef	HUCC_USES_NEW_SCROLL 1
 2534                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 64; extern void __fastcall scroll_split( unsigned char index<_al>, unsigned char screen_line<_ah>, unsigned int bat_x<_bx>, unsigned int bat_y<_cx>, unsigned char display_flags<_dl> );
 2535                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 65; extern void __fastcall sgx_scroll_split( unsigned char index<_al>, unsigned char screen_line<_ah>, unsigned int bat_x<_bx>, unsigned int bat_y<_cx>, unsigned char display_flags<_dl> );
 2536                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 67; extern void __fastcall disable_split( unsigned char index<acc> );
 2537                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 68; extern void __fastcall sgx_disable_split( unsigned char index<acc> );
 2538                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 70; extern void __fastcall __macro disable_all_splits( void );
 2539                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 71; extern void __fastcall __macro sgx_disable_all_splits( void );
 2540                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 73; #asm
 2541                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 74; .macro	_disable_all_splits
 2542                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 75; ldy	#HUCC_PCE_SPLITS - 1
 2543                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 76; !loop:		tya
 2544                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 77; call	_disable_split.1
 2545                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 78; dey
 2546                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 79; bpl	!loop-
 2547                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 80; .endm
 2548                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 82; .macro	_sgx_disable_all_splits
 2549                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 83; ldy	#HUCC_SGX_SPLITS - 1
 2550                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 84; !loop:		tya
 2551                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 85; call	_sgx_disable_split.1
 2552                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 86; dey
 2553                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 87; bpl	!loop-
 2554                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 88; .endm
 2555                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 89; #endasm
 2556                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 91; #endif // __HUCC__
 2557                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 93; #endif // _hucc_scroll_h
 2558                        		.dbg	line,	"include\routines_LEVELS.c", 3; #include "hucc-chrmap.h"
 2559                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 1; #ifndef _hucc_chrmap_h
 2560                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 2; #define _hucc_chrmap_h
 2561                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 4; /****************************************************************************
 2562                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 5; ; ***************************************************************************
 2563                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 6; ;
 2564                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 7; ; hucc-chrmap.h
 2565                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 8; ;
 2566                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 9; ; A simple map system based on 8x8 characters (aka "tiles") in BAT format.
 2567                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 10; ;
 2568                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 11; ; Copyright John Brandwood 2025.
 2569                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 12; ;
 2570                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 13; ; Distributed under the Boost Software License, Version 1.0.
 2571                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 14; ; (See accompanying file LICENSE_1_0.txt or copy at
 2572                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 15; ;  http://www.boost.org/LICENSE_1_0.txt)
 2573                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 16; ;
 2574                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 17; ; ***************************************************************************
 2575                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 18; ; ***************************************************************************
 2576                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 19; ;
 2577                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 20; ; The maximum X and Y size for chrmaps is 256 characters (2048 pixels).
 2578                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 21; ;
 2579                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 22; ; The maximum total size for a chrmap is 16KBytes, which allows for maps up
 2580                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 23; ; to 256x32 tiles (2048x256 pixels).
 2581                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 24; ;
 2582                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 25; ; ***************************************************************************
 2583                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 26; ; **************************************************************************/
 2584                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 28; // *************
 2585                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 29; // This code extends the blkmap library ...
 2586                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 30; // *************
 2587                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 32; #include "hucc-blkmap.h"
 2588                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 34; // *************
 2589                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 35; // Functions in chrmap.asm ...
 2590                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 36; // *************
 2591                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 38; #ifdef __HUCC__
 2592                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 40; #asmdef	HUCC_USES_CHRMAP 1
 2593                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 42; extern void __fastcall __nop set_chrmap( unsigned char __far *chrmap<vdc_map_bank:vdc_map_addr>, unsigned char tiles_w<vdc_map_line_w> );
 2594                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 44; extern void __fastcall draw_bat( void );
 2595                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 45; extern void __fastcall scroll_bat( void );
 2596                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 47; extern void __fastcall blit_bat( unsigned char tile_x<map_bat_x>, unsigned char tile_y<map_bat_y>, unsigned char tile_w<map_draw_x>, unsigned char tile_h<map_draw_y> );
 2597                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 49; #ifdef _SGX
 2598                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 51; extern void __fastcall __nop sgx_set_chrmap( unsigned char __far *chrmap<sgx_map_bank:sgx_map_addr>, unsigned char tiles_w<sgx_map_line_w> );
 2599                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 53; extern void __fastcall sgx_draw_bat( void );
 2600                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 54; extern void __fastcall sgx_scroll_bat( void );
 2601                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 56; extern void __fastcall sgx_blit_bat( unsigned char tile_x<map_bat_x>, unsigned char tile_y<map_bat_y>, unsigned char tile_w<map_draw_x>, unsigned char tile_h<map_draw_y> );
 2602                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 58; #endif
 2603                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 60; #endif // __HUCC__
 2604                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 62; #endif // _hucc_chrmap_h
 2605                        		.dbg	line,	"include\routines_LEVELS.c", 4; #include "hucc-blkmap.h"
 2606                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 1; #ifndef _hucc_blkmap_h
 2607                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 2; #define _hucc_blkmap_h
 2608                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 4; /****************************************************************************
 2609                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 5; ; ***************************************************************************
 2610                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 6; ;
 2611                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 7; ; hucc-blkmap.h
 2612                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 8; ;
 2613                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 9; ; A map system based on 16x16 meta-tiles (aka "blocks", aka CHR/BLK/MAP).
 2614                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 10; ;
 2615                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 11; ; Copyright John Brandwood 2025.
 2616                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 12; ;
 2617                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 13; ; Distributed under the Boost Software License, Version 1.0.
 2618                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 14; ; (See accompanying file LICENSE_1_0.txt or copy at
 2619                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 15; ;  http://www.boost.org/LICENSE_1_0.txt)
 2620                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 16; ;
 2621                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 17; ; ***************************************************************************
 2622                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 18; ; ***************************************************************************
 2623                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 19; ;
 2624                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 20; ; The maximum X and Y size for blkmaps is 128 blocks (2048 pixels).
 2625                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 21; ;
 2626                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 22; ; The maximum total size for a blkmap is 16KBytes, which allows for maps up
 2627                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 23; ; to 128x128 blocks (2048x2048 pixels).
 2628                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 24; ;
 2629                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 25; ; Huge multi-screen blkmaps are also supported (optionally).
 2630                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 26; ;
 2631                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 27; ; The maximum X and Y for multi-screen maps is 128 screens (32768 pixels).
 2632                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 28; ;
 2633                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 29; ; The maximum total size for a multi-screen map is 8KBytes, which allows for
 2634                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 30; ; a total of 1024 screens.
 2635                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 31; ;
 2636                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 32; ; ***************************************************************************
 2637                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 33; ; **************************************************************************/
 2638                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 35; // *************
 2639                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 36; // Functions in blkmap.asm ...
 2640                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 37; // *************
 2641                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 39; #ifdef __HUCC__
 2642                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 41; #asmdef	HUCC_USES_BLKMAP 1
 2643                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 43; // Current top-left of drawn map in pixels.
 2644                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 44; extern unsigned int   vdc_map_pxl_x;
 2645                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 45; extern unsigned int   vdc_map_pxl_y;
 2646                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 47; // Width and height to draw/scroll in characters (not tiles).
 2647                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 48; extern unsigned char  vdc_map_draw_w;
 2648                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 49; extern unsigned char  vdc_map_draw_h;
 2649                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 51; // Width of map (or multi-screen BAT) in tiles.
 2650                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 52; extern unsigned char  vdc_map_line_w;
 2651                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 54; // Width of map in screens (if multi-screen map).
 2652                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 55; extern unsigned char  vdc_map_scrn_w;
 2653                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 57; // Extra information returned by get_map_block() and sgx_get_map_block(),
 2654                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 58; // which are the collision flags and the mask/overlay sprite for the BLK.
 2655                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 59; extern unsigned char  map_blk_flag;
 2656                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 60; extern unsigned char  map_blk_mask;
 2657                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 62; extern unsigned char  vdc_scr_bank;
 2658                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 63; extern unsigned char *vdc_scr_addr;
 2659                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 65; extern unsigned char  vdc_map_bank;
 2660                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 66; extern unsigned char *vdc_map_addr;
 2661                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 68; extern unsigned char  vdc_blk_bank;
 2662                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 69; extern unsigned char *vdc_blk_addr;
 2663                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 71; extern unsigned char  vdc_tbl_bank;
 2664                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 72; extern unsigned char *vdc_tbl_addr;
 2665                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 74; extern void __fastcall set_blocks( unsigned char __far *blk_def<vdc_blk_bank:vdc_blk_addr>, unsigned char __far *flg_def<vdc_tbl_bank:vdc_tbl_addr>, unsigned char number_of_blocks<_al> );
 2666                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 75; extern void __fastcall __macro set_blkmap( unsigned char __far *blk_map<vdc_map_bank:vdc_map_addr>, unsigned char blocks_w<vdc_map_line_w> );
 2667                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 76; extern void __fastcall __macro set_multimap( unsigned char __far *multi_map<vdc_scr_bank:vdc_scr_addr>, unsigned char screens_w<vdc_map_scrn_w> );
 2668                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 78; extern void __fastcall draw_map( void );
 2669                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 79; extern void __fastcall scroll_map( void );
 2670                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 81; extern void __fastcall blit_map( unsigned char tile_x<map_bat_x>, unsigned char tile_y<map_bat_y>, unsigned char tile_w<map_draw_x>, unsigned char tile_h<map_draw_y> );
 2671                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 83; extern unsigned char __fastcall get_map_block( unsigned int x<map_pxl_x>, unsigned int y<map_pxl_y> );
 2672                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 85; #asm
 2673                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 86; .macro	_set_blkmap.2
 2674                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 87; stz	vdc_scr_bank
 2675                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 88; .endm
 2676                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 90; .macro	_set_multimap.2
 2677                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 91; lda	vdc_bat_width
 2678                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 92; lsr	a
 2679                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 93; sta	vdc_map_line_w
 2680                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 94; .endm
 2681                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 96; .macro	SCREEN
 2682                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 97; db	(((\1) & $1FFF) | $6000) >> 8, bank(\1)
 2683                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 98; db	(((\2) & $1FFF) | $4000) >> 8, bank(\2)
 2684                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 99; db	(((\3) & $1FFF) | $6000) >> 8, bank(\3)
 2685                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 100; dw	(\4)
 2686                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 101; .endm
 2687                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 102; #endasm
 2688                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 104; #ifdef _SGX
 2689                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 106; // Current top-left of drawn map in pixels.
 2690                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 107; extern unsigned int   sgx_map_pxl_x;
 2691                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 108; extern unsigned int   sgx_map_pxl_y;
 2692                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 110; // Width and height to draw/scroll in characters (not tiles).
 2693                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 111; extern unsigned char  sgx_map_draw_w;
 2694                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 112; extern unsigned char  sgx_map_draw_h;
 2695                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 114; // Width of map (or multi-screen BAT) in tiles.
 2696                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 115; extern unsigned char  sgx_map_line_w;
 2697                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 117; // Width of map in screens (if multi-screen map).
 2698                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 118; extern unsigned char  sgx_map_scrn_w;
 2699                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 120; extern unsigned char  sgx_scr_bank;
 2700                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 121; extern unsigned char *sgx_scr_addr;
 2701                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 123; extern unsigned char  sgx_map_bank;
 2702                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 124; extern unsigned char *sgx_map_addr;
 2703                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 126; extern unsigned char  sgx_blk_bank;
 2704                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 127; extern unsigned char *sgx_blk_addr;
 2705                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 129; extern unsigned char  sgx_tbl_bank;
 2706                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 130; extern unsigned char *sgx_tbl_addr;
 2707                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 132; extern void __fastcall sgx_set_blocks( unsigned char __far *blk_def<sgx_blk_bank:sgx_blk_addr>, unsigned char __far *flg_def<sgx_tbl_bank:sgx_tbl_addr>, unsigned char number_of_blocks<_al> );
 2708                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 133; extern void __fastcall __macro sgx_set_blkmap( unsigned char __far *blk_map<sgx_map_bank:sgx_map_addr>, unsigned char blocks_w<sgx_map_line_w> );
 2709                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 134; extern void __fastcall __macro sgx_set_multimap( unsigned char __far *multi_map<sgx_scr_bank:sgx_scr_addr>, unsigned char screens_w<sgx_map_scrn_w> );
 2710                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 136; extern void __fastcall sgx_draw_map( void );
 2711                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 137; extern void __fastcall sgx_scroll_map( void );
 2712                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 139; extern void __fastcall sgx_blit_map( unsigned char tile_x<map_bat_x>, unsigned char tile_y<map_bat_y>, unsigned char tile_w<map_draw_x>, unsigned char tile_h<map_draw_y> );
 2713                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 141; extern unsigned char __fastcall sgx_get_map_block( unsigned int x<map_pxl_x>, unsigned int y<map_pxl_y> );
 2714                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 143; #asm
 2715                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 144; .macro	_sgx_set_blkmap.2
 2716                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 145; stz	sgx_scr_bank
 2717                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 146; .endm
 2718                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 148; .macro	_sgx_set_multimap.2
 2719                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 149; lda	sgx_bat_width
 2720                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 150; lsr	a
 2721                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 151; sta	sgx_map_line_w
 2722                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 152; .endm
 2723                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 153; #endasm
 2724                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 155; #endif
 2725                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 157; #endif // __HUCC__
 2726                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 159; #endif // _hucc_blkmap_h
 2727                        		.dbg	line,	"include\routines_LEVELS.c", 13; void scroll_OBJECTS()
 2728                        		.dbg	line,	"include\routines_LEVELS.c", 14; {
 2729                        	;***********************
 2730                        	;***********************
 2731                        	
 2732                        		.hucc
 2733    09:DFFA             		.proc		_scroll_OBJECTS
 2734                        		__enter		_scroll_OBJECTS
 2735                        	
 2736                        		.dbg	line,	"include\routines_LEVELS.c", 15; //
 2737                        	
 2738                        		.dbg	line,	"include\routines_LEVELS.c", 16; }
 2739    09:DFFA             	.LL2:
 2740                        		__return	0
         09:DFFA  4C EF FF   			jmp	leave_proc
 2741                        		.dbg	clear
 2742                        		.endp
 2743                        		.pceas
 2744                        	
 2745                        		.dbg	line,	"include\routines_LEVELS.c", 19; int check_TILE_DEPTH(signed char x_offset , signed char y_offset)
 2746                        		.dbg	line,	"include\routines_LEVELS.c", 20; {
 2747                        	;***********************
 2748                        	;***********************
 2749                        	
 2750                        		.hucc
 2751    0D:DC5C             		.proc		_check_TILE_DEPTH
 2752                        		__enter		_check_TILE_DEPTH
 2753                        	
 2754                        		.dbg	line,	"include\routines_LEVELS.c", 21; int player_COLL_X;
 2755                        	
 2756                        		.dbg	line,	"include\routines_LEVELS.c", 22; int player_COLL_Y;
 2757                        	
 2758                        		.dbg	line,	"include\routines_LEVELS.c", 25; player_COLL_X = player_pos_x + x_offset;
 2759                        		__ld.bs		2  /* x_offset */
         0D:DC5C  A6 8D      			ldx	<__sp
         0D:DC5E  B5 0A      			lda	<__stack + 2, x
         0D:DC60  C2         			cly
         0D:DC61  10 01      			bpl	!+	; signed
         0D:DC63  88         			dey
         0D:DC64             	!:
 2760                        		__add.wm	_player_pos_x
         0D:DC64  18         			clc
         0D:DC65  6D 18 23   			adc.l	_player_pos_x
         0D:DC68  42         			say
         0D:DC69  6D 19 23   			adc.h	_player_pos_x
         0D:DC6C  42         			say
 2761                        		__st.wmq	__check_TILE_DEPTH_end - 2  /* player_COLL_X */
         0D:DC6D  8D 82 24   			sta.l	__check_TILE_DEPTH_end - 2
         0D:DC70  8C 83 24   			sty.h	__check_TILE_DEPTH_end - 2
 2762                        	
 2763                        		.dbg	line,	"include\routines_LEVELS.c", 26; player_COLL_Y = player_pos_y + 32 - y_offset;//32
 2764                        		__ld.wm		_player_pos_y
         0D:DC73  AD 1A 23   			lda.l	_player_pos_y
         0D:DC76  AC 1B 23   			ldy.h	_player_pos_y
 2765                        		__add.wi	32
         0D:DC79  18         			clc
         0D:DC7A  69 20      			adc.l	#32
         0D:DC7C  90 01      			bcc	!+
         0D:DC7E  C8         			iny
         0D:DC7F             	!:
 2766                        		__push.wr
         0D:DC7F  5A         			phy
         0D:DC80  48         			pha
 2767                        		__ld.bs		0  /* y_offset */
         0D:DC81  A6 8D      			ldx	<__sp
         0D:DC83  B5 08      			lda	<__stack + 0, x
         0D:DC85  C2         			cly
         0D:DC86  10 01      			bpl	!+	; signed
         0D:DC88  88         			dey
         0D:DC89             	!:
 2768                        		__sub.wt
         0D:DC89  BA         			tsx
         0D:DC8A  38         			sec
         0D:DC8B  49 FF      			eor	#$FF
         0D:DC8D  7D 01 21   			adc.l	__tos, x
         0D:DC90  42         			say
         0D:DC91  49 FF      			eor	#$FF
         0D:DC93  7D 02 21   			adc.h	__tos, x
         0D:DC96  42         			say
         0D:DC97  E8         			inx
         0D:DC98  E8         			inx
         0D:DC99  9A         			txs
 2769                        		__st.wmq	__check_TILE_DEPTH_end - 4  /* player_COLL_Y */
         0D:DC9A  8D 80 24   			sta.l	__check_TILE_DEPTH_end - 4
         0D:DC9D  8C 81 24   			sty.h	__check_TILE_DEPTH_end - 4
 2770                        	
 2771                        		.dbg	line,	"include\routines_LEVELS.c", 28; get_map_block(player_COLL_X + sgx_map_pxl_x, player_COLL_Y + sgx_map_pxl_y);
 2772                        		__ld.wm		__check_TILE_DEPTH_end - 2  /* player_COLL_X */
         0D:DCA0  AD 82 24   			lda.l	__check_TILE_DEPTH_end - 2
         0D:DCA3  AC 83 24   			ldy.h	__check_TILE_DEPTH_end - 2
 2773                        		__add.wm	_sgx_map_pxl_x
         0D:DCA6  18         			clc
         0D:DCA7  6D C8 24   			adc.l	_sgx_map_pxl_x
         0D:DCAA  42         			say
         0D:DCAB  6D C9 24   			adc.h	_sgx_map_pxl_x
         0D:DCAE  42         			say
 2774                        		__st.wmq	map_pxl_x
         0D:DCAF  85 FC      			sta.l	map_pxl_x
         0D:DCB1  84 FD      			sty.h	map_pxl_x
 2775                        		__ld.wm		__check_TILE_DEPTH_end - 4  /* player_COLL_Y */
         0D:DCB3  AD 80 24   			lda.l	__check_TILE_DEPTH_end - 4
         0D:DCB6  AC 81 24   			ldy.h	__check_TILE_DEPTH_end - 4
 2776                        		__add.wm	_sgx_map_pxl_y
         0D:DCB9  18         			clc
         0D:DCBA  6D CA 24   			adc.l	_sgx_map_pxl_y
         0D:DCBD  42         			say
         0D:DCBE  6D CB 24   			adc.h	_sgx_map_pxl_y
         0D:DCC1  42         			say
 2777                        		__st.wmq	map_pxl_y
         0D:DCC2  85 FE      			sta.l	map_pxl_y
         0D:DCC4  84 FF      			sty.h	map_pxl_y
 2778                        		__call		_get_map_block.2
         0D:DCC6  20 9F FF   			call	_get_map_block.2
 2779                        	
 2780                        		.dbg	line,	"include\routines_LEVELS.c", 29; }
 2781    0D:DCC9             	.LL3:
 2782                        		__modsp		4
         0D:DCC9  AA         			tax
         0D:DCCA  A5 8D      			lda	<__sp
         0D:DCCC  18         			clc
         0D:DCCD  69 04      			adc	#4
         0D:DCCF  85 8D      			sta	<__sp
         0D:DCD1  8A         			txa
 2783                        		__return	1
         0D:DCD2  AA         			tax
         0D:DCD3  4C EF FF   			jmp	leave_proc
 2784                        		.dbg	clear
 2785                        		.endp
 2786                        		.pceas
 2787                        	
 2788                        		.dbg	line,	"include\routines_LEVELS.c", 32; int check_BG(signed char x_offset , signed char y_offset)
 2789                        		.dbg	line,	"include\routines_LEVELS.c", 33; {
 2790                        	;***********************
 2791                        	;***********************
 2792                        	
 2793                        		.hucc
 2794    0D:DE20             		.proc		_check_BG
 2795                        		__enter		_check_BG
 2796                        	
 2797                        		.dbg	line,	"include\routines_LEVELS.c", 34; int player_COLL_X;
 2798                        	
 2799                        		.dbg	line,	"include\routines_LEVELS.c", 35; int player_COLL_Y;
 2800                        	
 2801                        		.dbg	line,	"include\routines_LEVELS.c", 38; player_COLL_X = player_pos_x + x_offset;
 2802                        		__ld.bs		2  /* x_offset */
         0D:DE20  A6 8D      			ldx	<__sp
         0D:DE22  B5 0A      			lda	<__stack + 2, x
         0D:DE24  C2         			cly
         0D:DE25  10 01      			bpl	!+	; signed
         0D:DE27  88         			dey
         0D:DE28             	!:
 2803                        		__add.wm	_player_pos_x
         0D:DE28  18         			clc
         0D:DE29  6D 18 23   			adc.l	_player_pos_x
         0D:DE2C  42         			say
         0D:DE2D  6D 19 23   			adc.h	_player_pos_x
         0D:DE30  42         			say
 2804                        		__st.wmq	__check_BG_end - 2  /* player_COLL_X */
         0D:DE31  8D 82 24   			sta.l	__check_BG_end - 2
         0D:DE34  8C 83 24   			sty.h	__check_BG_end - 2
 2805                        	
 2806                        		.dbg	line,	"include\routines_LEVELS.c", 39; player_COLL_Y = player_pos_y + y_offset;
 2807                        		__ld.bs		0  /* y_offset */
         0D:DE37  A6 8D      			ldx	<__sp
         0D:DE39  B5 08      			lda	<__stack + 0, x
         0D:DE3B  C2         			cly
         0D:DE3C  10 01      			bpl	!+	; signed
         0D:DE3E  88         			dey
         0D:DE3F             	!:
 2808                        		__add.wm	_player_pos_y
         0D:DE3F  18         			clc
         0D:DE40  6D 1A 23   			adc.l	_player_pos_y
         0D:DE43  42         			say
         0D:DE44  6D 1B 23   			adc.h	_player_pos_y
         0D:DE47  42         			say
 2809                        		__st.wmq	__check_BG_end - 4  /* player_COLL_Y */
         0D:DE48  8D 80 24   			sta.l	__check_BG_end - 4
         0D:DE4B  8C 81 24   			sty.h	__check_BG_end - 4
 2810                        	
 2811                        		.dbg	line,	"include\routines_LEVELS.c", 41; get_map_block(player_COLL_X + sgx_map_pxl_x, player_COLL_Y + sgx_map_pxl_y);
 2812                        		__ld.wm		__check_BG_end - 2  /* player_COLL_X */
         0D:DE4E  AD 82 24   			lda.l	__check_BG_end - 2
         0D:DE51  AC 83 24   			ldy.h	__check_BG_end - 2
 2813                        		__add.wm	_sgx_map_pxl_x
         0D:DE54  18         			clc
         0D:DE55  6D C8 24   			adc.l	_sgx_map_pxl_x
         0D:DE58  42         			say
         0D:DE59  6D C9 24   			adc.h	_sgx_map_pxl_x
         0D:DE5C  42         			say
 2814                        		__st.wmq	map_pxl_x
         0D:DE5D  85 FC      			sta.l	map_pxl_x
         0D:DE5F  84 FD      			sty.h	map_pxl_x
 2815                        		__ld.wm		__check_BG_end - 4  /* player_COLL_Y */
         0D:DE61  AD 80 24   			lda.l	__check_BG_end - 4
         0D:DE64  AC 81 24   			ldy.h	__check_BG_end - 4
 2816                        		__add.wm	_sgx_map_pxl_y
         0D:DE67  18         			clc
         0D:DE68  6D CA 24   			adc.l	_sgx_map_pxl_y
         0D:DE6B  42         			say
         0D:DE6C  6D CB 24   			adc.h	_sgx_map_pxl_y
         0D:DE6F  42         			say
 2817                        		__st.wmq	map_pxl_y
         0D:DE70  85 FE      			sta.l	map_pxl_y
         0D:DE72  84 FF      			sty.h	map_pxl_y
 2818                        		__call		_get_map_block.2
         0D:DE74  20 9F FF   			call	_get_map_block.2
 2819                        	
 2820                        		.dbg	line,	"include\routines_LEVELS.c", 42; }
 2821    0D:DE77             	.LL4:
 2822                        		__modsp		4
         0D:DE77  AA         			tax
         0D:DE78  A5 8D      			lda	<__sp
         0D:DE7A  18         			clc
         0D:DE7B  69 04      			adc	#4
         0D:DE7D  85 8D      			sta	<__sp
         0D:DE7F  8A         			txa
 2823                        		__return	1
         0D:DE80  AA         			tax
         0D:DE81  4C EF FF   			jmp	leave_proc
 2824                        		.dbg	clear
 2825                        		.endp
 2826                        		.pceas
 2827                        	
 2828                        		.dbg	line,	"include\routines_LEVELS.c", 51; void scroll_BG()
 2829                        		.dbg	line,	"include\routines_LEVELS.c", 52; {
 2830                        	;***********************
 2831                        	;***********************
 2832                        	
 2833                        		.hucc
 2834    02:C0BC             		.proc		_scroll_BG
 2835                        		__enter		_scroll_BG
 2836                        	
 2837                        		.dbg	line,	"include\routines_LEVELS.c", 53; // UPDATE VDC2 BG //
 2838                        	
 2839                        		.dbg	line,	"include\routines_LEVELS.c", 54; sgx_scroll_map();
 2840                        		__call		_sgx_scroll_map
         02:C0BC  20 95 FF   			call	_sgx_scroll_map
 2841                        	
 2842                        		.dbg	line,	"include\routines_LEVELS.c", 56; //--------------------------------------------------------------------------------------//
 2843                        	
 2844                        		.dbg	line,	"include\routines_LEVELS.c", 57; //                                        VDC 2                                         //
 2845                        	
 2846                        		.dbg	line,	"include\routines_LEVELS.c", 58; //--------------------------------------------------------------------------------------//
 2847                        	
 2848                        		.dbg	line,	"include\routines_LEVELS.c", 60; sgx_scroll_split(0,   0, sgx_map_pxl_x & (BAT_SIZE_W - 1), sgx_map_pxl_y & (BAT_SIZE_H - 1), BKG_ON | SPR_ON);
 2849                        		__st.umiq	0, _al
         02:C0BF  64 F8      			stz	_al
 2850                        		__st.umiq	0, _ah
         02:C0C1  64 F9      			stz	_ah
 2851                        		__ld.wm		_sgx_map_pxl_x
         02:C0C3  AD C8 24   			lda.l	_sgx_map_pxl_x
         02:C0C6  AC C9 24   			ldy.h	_sgx_map_pxl_x
 2852                        		__and.wi	2047
         02:C0C9  29 FF      			and.l	#2047
         02:C0CB  42         			say
         02:C0CC  29 07      			and.h	#2047
         02:C0CE  42         			say
 2853                        		__st.wmq	_bx
         02:C0CF  85 FA      			sta.l	_bx
         02:C0D1  84 FB      			sty.h	_bx
 2854                        		__ld.wm		_sgx_map_pxl_y
         02:C0D3  AD CA 24   			lda.l	_sgx_map_pxl_y
         02:C0D6  AC CB 24   			ldy.h	_sgx_map_pxl_y
 2855                        		__and.wi	255
         02:C0D9  29 FF      			and	#255
         02:C0DB  C2         			cly
 2856                        		__st.wmq	_cx
         02:C0DC  85 FC      			sta.l	_cx
         02:C0DE  84 FD      			sty.h	_cx
 2857                        		__st.umiq	192, _dl
         02:C0E0  A9 C0      			lda.l	#192
         02:C0E2  85 FE      			sta	_dl
 2858                        		__call		_sgx_scroll_split.5
         02:C0E4  20 8B FF   			call	_sgx_scroll_split.5
 2859                        	
 2860                        		.dbg	line,	"include\routines_LEVELS.c", 61; }
 2861    02:C0E7             	.LL5:
 2862                        		__return	0
         02:C0E7  4C EF FF   			jmp	leave_proc
 2863                        		.dbg	clear
 2864                        		.endp
 2865                        		.pceas
 2866                        	
 2867                        		.dbg	line,	"include\routines_LEVELS.c", 64; void recenter_CAMERA()
 2868                        		.dbg	line,	"include\routines_LEVELS.c", 65; {
 2869                        	;***********************
 2870                        	;***********************
 2871                        	
 2872                        		.hucc
 2873    0D:D959             		.proc		_recenter_CAMERA
 2874                        		__enter		_recenter_CAMERA
 2875                        	
 2876                        		.dbg	line,	"include\routines_LEVELS.c", 66; signed char camera_y_move;
 2877                        	
 2878                        		.dbg	line,	"include\routines_LEVELS.c", 68; spr_set(player_id);
 2879                        		__ld.umq	_player_id
         0D:D959  AD 0E 23   			lda	_player_id
 2880                        		__call		_spr_set.1
         0D:D95C  20 DD E7   			call	_spr_set.1
 2881                        	
 2882                        		.dbg	line,	"include\routines_LEVELS.c", 71; if(player_pos_y < 128)
 2883                        		__ld.wm		_player_pos_y
         0D:D95F  AD 1A 23   			lda.l	_player_pos_y
         0D:D962  AC 1B 23   			ldy.h	_player_pos_y
 2884                        		__slt_w.wi	128
         0D:D965  C9 80      			cmp.l	#128		; Subtract integer from Y:A.
         0D:D967  98         			tya
         0D:D968  E9 00      			sbc.h	#128
         0D:D96A  50 02      			bvc	!+
         0D:D96C  49 80      			eor	#$80		; -ve if Y:A < integer (signed).
         0D:D96E  0A         	!:		asl	a
 2885                        		__bfalse	.LL7
         0D:D96F  90 70      			bcc	.LL7
 2886                        	
 2887                        		.dbg	line,	"include\routines_LEVELS.c", 72; {
 2888                        	
 2889                        		.dbg	line,	"include\routines_LEVELS.c", 73; player_pos_y += CAMERA_RECENTER_VELOCITY;
 2890                        		__add_st.wmiq	4, _player_pos_y
         0D:D971  18         			clc
         0D:D972  AD 1A 23   			lda.l	_player_pos_y
         0D:D975  69 04      			adc.l	#4
         0D:D977  8D 1A 23   			sta.l	_player_pos_y
         0D:D97A  90 03      			bcc	!+
         0D:D97C  EE 1B 23   			inc.h	_player_pos_y
         0D:D97F             	!:
 2891                        	
 2892                        		.dbg	line,	"include\routines_LEVELS.c", 75; if(player_pos_y > 128)
 2893                        		__ld.wm		_player_pos_y
         0D:D97F  AD 1A 23   			lda.l	_player_pos_y
         0D:D982  AC 1B 23   			ldy.h	_player_pos_y
 2894                        		__sgt_w.wi	128
         0D:D985  18         			clc			; Subtract integer+1 from Y:A.
         0D:D986  E9 80      			sbc.l	#128
         0D:D988  98         			tya
         0D:D989  E9 00      			sbc.h	#128
         0D:D98B  50 02      			bvc	!+
         0D:D98D  49 80      			eor	#$80		; +ve if Y:A > integer (signed).
         0D:D98F  49 80      	!:		eor	#$80
         0D:D991  0A         			asl	a
 2895                        		__bfalse	.LL8
         0D:D992  90 24      			bcc	.LL8
 2896                        	
 2897                        		.dbg	line,	"include\routines_LEVELS.c", 76; {
 2898                        	
 2899                        		.dbg	line,	"include\routines_LEVELS.c", 77; camera_y_move = CAMERA_RECENTER_VELOCITY - (player_pos_y - 128);
 2900                        		__ld.wm		_player_pos_y
         0D:D994  AD 1A 23   			lda.l	_player_pos_y
         0D:D997  AC 1B 23   			ldy.h	_player_pos_y
 2901                        		__sub.wi	128
         0D:D99A  38         			sec
         0D:D99B  E9 80      			sbc.l	#128
         0D:D99D  B0 01      			bcs	!+
         0D:D99F  88         			dey
         0D:D9A0             	!:
 2902                        		__isub.wi	4
         0D:D9A0  38         			sec
         0D:D9A1  49 FF      			eor	#$FF
         0D:D9A3  69 04      			adc.l	#4
         0D:D9A5  42         			say
         0D:D9A6  49 FF      			eor	#$FF
         0D:D9A8  69 00      			adc.h	#4
         0D:D9AA  42         			say
 2903                        		__st.umq	__recenter_CAMERA_end - 1  /* camera_y_move */
         0D:D9AB  8D 83 24   			sta	__recenter_CAMERA_end - 1
 2904                        	
 2905                        		.dbg	line,	"include\routines_LEVELS.c", 79; player_pos_y = 128;
 2906                        		__st.wmiq	128, _player_pos_y
         0D:D9AE  A9 80      			lda.l	#128
         0D:D9B0  8D 1A 23   			sta.l	_player_pos_y
         0D:D9B3  9C 1B 23   			stz.h	_player_pos_y
 2907                        	
 2908                        		.dbg	line,	"include\routines_LEVELS.c", 80; }
 2909                        	
 2910                        		.dbg	line,	"include\routines_LEVELS.c", 82; else
 2911                        		__bra		.LL9
         0D:D9B6  80 05      			bra	.LL9
 2912    0D:D9B8             	.LL8:
 2913                        	
 2914                        		.dbg	line,	"include\routines_LEVELS.c", 83; {
 2915                        	
 2916                        		.dbg	line,	"include\routines_LEVELS.c", 84; camera_y_move = CAMERA_RECENTER_VELOCITY;
 2917                        		__st.umiq	4, __recenter_CAMERA_end - 1  /* camera_y_move */
         0D:D9B8  A9 04      			lda.l	#4
         0D:D9BA  8D 83 24   			sta	__recenter_CAMERA_end - 1
 2918                        	
 2919                        		.dbg	line,	"include\routines_LEVELS.c", 85; }
 2920    0D:D9BD             	.LL9:
 2921                        	
 2922                        		.dbg	line,	"include\routines_LEVELS.c", 87; spr_y(player_pos_y);
 2923                        		__ld.wm		_player_pos_y
         0D:D9BD  AD 1A 23   			lda.l	_player_pos_y
         0D:D9C0  AC 1B 23   			ldy.h	_player_pos_y
 2924                        		__call		_spr_y.1
         0D:D9C3  20 19 E8   			call	_spr_y.1
 2925                        	
 2926                        		.dbg	line,	"include\routines_LEVELS.c", 89; sgx_map_pxl_y -= camera_y_move;
 2927                        		__ld.bm		__recenter_CAMERA_end - 1  /* camera_y_move */
         0D:D9C6  AD 83 24   			lda	__recenter_CAMERA_end - 1
         0D:D9C9  C2         			cly
         0D:D9CA  10 01      			bpl	!+
         0D:D9CC  88         			dey
         0D:D9CD             	!:
 2928                        		__isub_st.wmq	_sgx_map_pxl_y
         0D:D9CD  38         			sec
         0D:D9CE  49 FF      			eor	#$FF
         0D:D9D0  6D CA 24   			adc.l	_sgx_map_pxl_y
         0D:D9D3  8D CA 24   			sta.l	_sgx_map_pxl_y
         0D:D9D6  98         			tya
         0D:D9D7  49 FF      			eor	#$FF
         0D:D9D9  6D CB 24   			adc.h	_sgx_map_pxl_y
         0D:D9DC  8D CB 24   			sta.h	_sgx_map_pxl_y
 2929                        	
 2930                        		.dbg	line,	"include\routines_LEVELS.c", 90; }
 2931                        	
 2932                        		.dbg	line,	"include\routines_LEVELS.c", 93; else if(player_pos_y > 128)
 2933                        		__bra		.LL10
         0D:D9DF  80 7C      			bra	.LL10
 2934    0D:D9E1             	.LL7:
 2935                        		__ld.wm		_player_pos_y
         0D:D9E1  AD 1A 23   			lda.l	_player_pos_y
         0D:D9E4  AC 1B 23   			ldy.h	_player_pos_y
 2936                        		__sgt_w.wi	128
         0D:D9E7  18         			clc			; Subtract integer+1 from Y:A.
         0D:D9E8  E9 80      			sbc.l	#128
         0D:D9EA  98         			tya
         0D:D9EB  E9 00      			sbc.h	#128
         0D:D9ED  50 02      			bvc	!+
         0D:D9EF  49 80      			eor	#$80		; +ve if Y:A > integer (signed).
         0D:D9F1  49 80      	!:		eor	#$80
         0D:D9F3  0A         			asl	a
 2937                        		__bfalse	.LL11
         0D:D9F4  90 67      			bcc	.LL11
 2938                        	
 2939                        		.dbg	line,	"include\routines_LEVELS.c", 94; {
 2940                        	
 2941                        		.dbg	line,	"include\routines_LEVELS.c", 95; player_pos_y -= CAMERA_RECENTER_VELOCITY;
 2942                        		__sub_st.wmiq	4, _player_pos_y
         0D:D9F6  38         			sec
         0D:D9F7  AD 1A 23   			lda.l	_player_pos_y
         0D:D9FA  E9 04      			sbc.l	#4
         0D:D9FC  8D 1A 23   			sta.l	_player_pos_y
         0D:D9FF  B0 03      			bcs	!+
         0D:DA01  CE 1B 23   			dec.h	_player_pos_y
         0D:DA04             	!:
 2943                        	
 2944                        		.dbg	line,	"include\routines_LEVELS.c", 97; if(player_pos_y < 128)
 2945                        		__ld.wm		_player_pos_y
         0D:DA04  AD 1A 23   			lda.l	_player_pos_y
         0D:DA07  AC 1B 23   			ldy.h	_player_pos_y
 2946                        		__slt_w.wi	128
         0D:DA0A  C9 80      			cmp.l	#128		; Subtract integer from Y:A.
         0D:DA0C  98         			tya
         0D:DA0D  E9 00      			sbc.h	#128
         0D:DA0F  50 02      			bvc	!+
         0D:DA11  49 80      			eor	#$80		; -ve if Y:A < integer (signed).
         0D:DA13  0A         	!:		asl	a
 2947                        		__bfalse	.LL12
         0D:DA14  90 24      			bcc	.LL12
 2948                        	
 2949                        		.dbg	line,	"include\routines_LEVELS.c", 98; {
 2950                        	
 2951                        		.dbg	line,	"include\routines_LEVELS.c", 99; camera_y_move = CAMERA_RECENTER_VELOCITY - (128 - player_pos_y);
 2952                        		__ld.wi		128
         0D:DA16  A9 80      			lda.l	#128
         0D:DA18  C2         			cly
 2953                        		__sub.wm	_player_pos_y
         0D:DA19  38         			sec
         0D:DA1A  ED 1A 23   			sbc.l	_player_pos_y
         0D:DA1D  42         			say
         0D:DA1E  ED 1B 23   			sbc.h	_player_pos_y
         0D:DA21  42         			say
 2954                        		__isub.wi	4
         0D:DA22  38         			sec
         0D:DA23  49 FF      			eor	#$FF
         0D:DA25  69 04      			adc.l	#4
         0D:DA27  42         			say
         0D:DA28  49 FF      			eor	#$FF
         0D:DA2A  69 00      			adc.h	#4
         0D:DA2C  42         			say
 2955                        		__st.umq	__recenter_CAMERA_end - 1  /* camera_y_move */
         0D:DA2D  8D 83 24   			sta	__recenter_CAMERA_end - 1
 2956                        	
 2957                        		.dbg	line,	"include\routines_LEVELS.c", 101; player_pos_y = 128;
 2958                        		__st.wmiq	128, _player_pos_y
         0D:DA30  A9 80      			lda.l	#128
         0D:DA32  8D 1A 23   			sta.l	_player_pos_y
         0D:DA35  9C 1B 23   			stz.h	_player_pos_y
 2959                        	
 2960                        		.dbg	line,	"include\routines_LEVELS.c", 102; }
 2961                        	
 2962                        		.dbg	line,	"include\routines_LEVELS.c", 104; else
 2963                        		__bra		.LL13
         0D:DA38  80 05      			bra	.LL13
 2964    0D:DA3A             	.LL12:
 2965                        	
 2966                        		.dbg	line,	"include\routines_LEVELS.c", 105; {
 2967                        	
 2968                        		.dbg	line,	"include\routines_LEVELS.c", 106; camera_y_move = CAMERA_RECENTER_VELOCITY;
 2969                        		__st.umiq	4, __recenter_CAMERA_end - 1  /* camera_y_move */
         0D:DA3A  A9 04      			lda.l	#4
         0D:DA3C  8D 83 24   			sta	__recenter_CAMERA_end - 1
 2970                        	
 2971                        		.dbg	line,	"include\routines_LEVELS.c", 107; }
 2972    0D:DA3F             	.LL13:
 2973                        	
 2974                        		.dbg	line,	"include\routines_LEVELS.c", 109; spr_y(player_pos_y);
 2975                        		__ld.wm		_player_pos_y
         0D:DA3F  AD 1A 23   			lda.l	_player_pos_y
         0D:DA42  AC 1B 23   			ldy.h	_player_pos_y
 2976                        		__call		_spr_y.1
         0D:DA45  20 19 E8   			call	_spr_y.1
 2977                        	
 2978                        		.dbg	line,	"include\routines_LEVELS.c", 111; sgx_map_pxl_y += camera_y_move;
 2979                        		__ld.bm		__recenter_CAMERA_end - 1  /* camera_y_move */
         0D:DA48  AD 83 24   			lda	__recenter_CAMERA_end - 1
         0D:DA4B  C2         			cly
         0D:DA4C  10 01      			bpl	!+
         0D:DA4E  88         			dey
         0D:DA4F             	!:
 2980                        		__add_st.wmq	_sgx_map_pxl_y
         0D:DA4F  18         			clc
         0D:DA50  6D CA 24   			adc.l	_sgx_map_pxl_y
         0D:DA53  8D CA 24   			sta.l	_sgx_map_pxl_y
         0D:DA56  98         			tya
         0D:DA57  6D CB 24   			adc.h	_sgx_map_pxl_y
         0D:DA5A  8D CB 24   			sta.h	_sgx_map_pxl_y
 2981                        	
 2982                        		.dbg	line,	"include\routines_LEVELS.c", 112; }
 2983                        	
 2984                        		.dbg	line,	"include\routines_LEVELS.c", 113; }
 2985    0D:DA5D             	.LL11:
 2986    0D:DA5D             	.LL10:
 2987    0D:DA5D             	.LL6:
 2988                        		__return	0
         0D:DA5D  4C EF FF   			jmp	leave_proc
 2989                        		.dbg	clear
 2990                        		.endp
 2991                        		.pceas
 2992                        	
 2993                        		.dbg	line,	"include\routines_LEVELS.c", 122; void joypad_BUTTONS()
 2994                        		.dbg	line,	"include\routines_LEVELS.c", 123; {
 2995                        	;***********************
 2996                        	;***********************
 2997                        	
 2998                        		.hucc
 2999    0D:DA60             		.proc		_joypad_BUTTONS
 3000                        		__enter		_joypad_BUTTONS
 3001                        	
 3002                        		.dbg	line,	"include\routines_LEVELS.c", 124; if(joytrg(JOYPAD_1) == JOY_I)
 3003                        		__ld.uiq	0
         0D:DA60  62         			cla
 3004                        		 _joytrg.1
         0D:DA61  AA         			tax
         0D:DA62  BD 2D 22   			lda	joytrg, x
         0D:DA65  BC DD 22   			ldy	joy6trg, x
 3005                        		__equ_w.wi	1
         0D:DA68  C9 01      			cmp.l	#1
         0D:DA6A  D0 04      			bne	!false+
         0D:DA6C  C0 00      			cpy.h	#1
         0D:DA6E  F0 01      			beq	!+
         0D:DA70  18         	!false:		clc
         0D:DA71             	!:
 3006                        		__bfalse	.LL15
         0D:DA71  B0 03 4C 31			bcc	.LL15
         0D:DA75  DB          
 3007                        	
 3008                        		.dbg	line,	"include\routines_LEVELS.c", 125; {
 3009                        	
 3010                        		.dbg	line,	"include\routines_LEVELS.c", 126; if(player_state == STATE_IDLE)
 3011                        		__not.um	_player_state
         0D:DA76  AD 0F 23   			lda	_player_state
         0D:DA79  18         			clc
         0D:DA7A  D0 01      			bne	!+
         0D:DA7C  38         			sec
         0D:DA7D             	!:
 3012                        		__bfalse	.LL16
         0D:DA7D  90 0B      			bcc	.LL16
 3013                        	
 3014                        		.dbg	line,	"include\routines_LEVELS.c", 127; {
 3015                        	
 3016                        		.dbg	line,	"include\routines_LEVELS.c", 128; player_counter_anim = 0;
 3017                        		__st.umiq	0, _player_counter_anim
         0D:DA7F  9C 12 23   			stz	_player_counter_anim
 3018                        	
 3019                        		.dbg	line,	"include\routines_LEVELS.c", 130; player_state = STATE_JUMP;
 3020                        		__st.umiq	4, _player_state
         0D:DA82  A9 04      			lda.l	#4
         0D:DA84  8D 0F 23   			sta	_player_state
 3021                        	
 3022                        		.dbg	line,	"include\routines_LEVELS.c", 131; }
 3023                        	
 3024                        		.dbg	line,	"include\routines_LEVELS.c", 134; else if(player_state == STATE_WALK)
 3025                        		__bra		.LL17
         0D:DA87  4C 31 DB   			bra	.LL17
 3026    0D:DA8A             	.LL16:
 3027                        		__ld.umq	_player_state
         0D:DA8A  AD 0F 23   			lda	_player_state
 3028                        		__equ_b.uiq	1
         0D:DA8D  C9 01      			cmp	#1
         0D:DA8F  F0 01      			beq	!+
         0D:DA91  18         			clc
         0D:DA92             	!:
 3029                        		__bfalse	.LL18
         0D:DA92  90 13      			bcc	.LL18
 3030                        	
 3031                        		.dbg	line,	"include\routines_LEVELS.c", 135; {
 3032                        	
 3033                        		.dbg	line,	"include\routines_LEVELS.c", 136; player_counter_anim = 0;
 3034                        		__st.umiq	0, _player_counter_anim
         0D:DA94  9C 12 23   			stz	_player_counter_anim
 3035                        	
 3036                        		.dbg	line,	"include\routines_LEVELS.c", 138; player_state = STATE_JUMP_RIGHT + player_axis;
 3037                        		__ld.wi		5
         0D:DA97  A9 05      			lda.l	#5
         0D:DA99  C2         			cly
 3038                        		__add.um	_player_axis
         0D:DA9A  18         			clc
         0D:DA9B  6D 10 23   			adc	_player_axis
         0D:DA9E  90 01      			bcc	!+
         0D:DAA0  C8         			iny
         0D:DAA1             	!:
 3039                        		__st.umq	_player_state
         0D:DAA1  8D 0F 23   			sta	_player_state
 3040                        	
 3041                        		.dbg	line,	"include\routines_LEVELS.c", 139; }
 3042                        	
 3043                        		.dbg	line,	"include\routines_LEVELS.c", 142; else if(player_state == STATE_HANG || player_state == STATE_CLIMB_UP || player_state == STATE_CLIMB_DOWN)
 3044                        		__bra		.LL19
         0D:DAA4  4C 31 DB   			bra	.LL19
 3045    0D:DAA7             	.LL18:
 3046                        		__ld.umq	_player_state
         0D:DAA7  AD 0F 23   			lda	_player_state
 3047                        		__equ_b.uiq	10
         0D:DAAA  C9 0A      			cmp	#10
         0D:DAAC  F0 01      			beq	!+
         0D:DAAE  18         			clc
         0D:DAAF             	!:
 3048                        		__btrue		.LL21
         0D:DAAF  B0 08      			bcs	.LL21
 3049                        		__ld.umq	_player_state
         0D:DAB1  AD 0F 23   			lda	_player_state
 3050                        		__equ_b.uiq	11
         0D:DAB4  C9 0B      			cmp	#11
         0D:DAB6  F0 01      			beq	!+
         0D:DAB8  18         			clc
         0D:DAB9             	!:
 3051    0D:DAB9             	.LL21:
 3052                        		__btrue		.LL22
         0D:DAB9  B0 08      			bcs	.LL22
 3053                        		__ld.umq	_player_state
         0D:DABB  AD 0F 23   			lda	_player_state
 3054                        		__equ_b.uiq	12
         0D:DABE  C9 0C      			cmp	#12
         0D:DAC0  F0 01      			beq	!+
         0D:DAC2  18         			clc
         0D:DAC3             	!:
 3055    0D:DAC3             	.LL22:
 3056                        		__bfalse	.LL20
         0D:DAC3  90 6C      			bcc	.LL20
 3057                        	
 3058                        		.dbg	line,	"include\routines_LEVELS.c", 143; {
 3059                        	
 3060                        		.dbg	line,	"include\routines_LEVELS.c", 144; if(joy(JOYPAD_1) & JOY_RIGHT)
 3061                        		__ld.uiq	0
         0D:DAC5  62         			cla
 3062                        		 _joy.1
         0D:DAC6  AA         			tax
         0D:DAC7  BD 28 22   			lda	joynow, x
         0D:DACA  BC D3 22   			ldy	joy6now, x
 3063                        		__tand.wi	32
         0D:DACD  29 20      			and	#32
         0D:DACF  C9 01      	!:		cmp	#1
 3064                        		__bfalse	.LL23
         0D:DAD1  90 0A      			bcc	.LL23
 3065                        	
 3066                        		.dbg	line,	"include\routines_LEVELS.c", 145; {
 3067                        	
 3068                        		.dbg	line,	"include\routines_LEVELS.c", 146; player_counter_anim = 0;
 3069                        		__st.umiq	0, _player_counter_anim
         0D:DAD3  9C 12 23   			stz	_player_counter_anim
 3070                        	
 3071                        		.dbg	line,	"include\routines_LEVELS.c", 148; player_state = STATE_JUMP_RIGHT;
 3072                        		__st.umiq	5, _player_state
         0D:DAD6  A9 05      			lda.l	#5
         0D:DAD8  8D 0F 23   			sta	_player_state
 3073                        	
 3074                        		.dbg	line,	"include\routines_LEVELS.c", 149; }
 3075                        	
 3076                        		.dbg	line,	"include\routines_LEVELS.c", 151; else if(joy(JOYPAD_1) & JOY_LEFT)
 3077                        		__bra		.LL24
         0D:DADB  80 54      			bra	.LL24
 3078    0D:DADD             	.LL23:
 3079                        		__ld.uiq	0
         0D:DADD  62         			cla
 3080                        		 _joy.1
         0D:DADE  AA         			tax
         0D:DADF  BD 28 22   			lda	joynow, x
         0D:DAE2  BC D3 22   			ldy	joy6now, x
 3081                        		__tand.wi	128
         0D:DAE5  29 80      			and	#128
         0D:DAE7  C9 01      	!:		cmp	#1
 3082                        		__bfalse	.LL25
         0D:DAE9  90 0A      			bcc	.LL25
 3083                        	
 3084                        		.dbg	line,	"include\routines_LEVELS.c", 152; {
 3085                        	
 3086                        		.dbg	line,	"include\routines_LEVELS.c", 153; player_counter_anim = 0;
 3087                        		__st.umiq	0, _player_counter_anim
         0D:DAEB  9C 12 23   			stz	_player_counter_anim
 3088                        	
 3089                        		.dbg	line,	"include\routines_LEVELS.c", 155; player_state = STATE_JUMP_LEFT;
 3090                        		__st.umiq	6, _player_state
         0D:DAEE  A9 06      			lda.l	#6
         0D:DAF0  8D 0F 23   			sta	_player_state
 3091                        	
 3092                        		.dbg	line,	"include\routines_LEVELS.c", 156; }
 3093                        	
 3094                        		.dbg	line,	"include\routines_LEVELS.c", 158; else if(joy(JOYPAD_1) & JOY_UP)
 3095                        		__bra		.LL26
         0D:DAF3  80 3C      			bra	.LL26
 3096    0D:DAF5             	.LL25:
 3097                        		__ld.uiq	0
         0D:DAF5  62         			cla
 3098                        		 _joy.1
         0D:DAF6  AA         			tax
         0D:DAF7  BD 28 22   			lda	joynow, x
         0D:DAFA  BC D3 22   			ldy	joy6now, x
 3099                        		__tand.wi	16
         0D:DAFD  29 10      			and	#16
         0D:DAFF  C9 01      	!:		cmp	#1
 3100                        		__bfalse	.LL27
         0D:DB01  90 2E      			bcc	.LL27
 3101                        	
 3102                        		.dbg	line,	"include\routines_LEVELS.c", 159; {
 3103                        	
 3104                        		.dbg	line,	"include\routines_LEVELS.c", 160; player_counter_anim = 0;
 3105                        		__st.umiq	0, _player_counter_anim
         0D:DB03  9C 12 23   			stz	_player_counter_anim
 3106                        	
 3107                        		.dbg	line,	"include\routines_LEVELS.c", 162; check_BG( 15 , 8 );
 3108                        		__ld.wi		15
         0D:DB06  A9 0F      			lda.l	#15
         0D:DB08  C2         			cly
 3109                        		__pusharg.wr
         0D:DB09  A6 8D      			ldx	<__sp
         0D:DB0B  CA         			dex
         0D:DB0C  CA         			dex
         0D:DB0D  95 08      			sta.l	<__stack, x
         0D:DB0F  94 09      			sty.h	<__stack, x
         0D:DB11  86 8D      			stx	<__sp
 3110                        		__ld.wi		8
         0D:DB13  A9 08      			lda.l	#8
         0D:DB15  C2         			cly
 3111                        		__pusharg.wr
         0D:DB16  A6 8D      			ldx	<__sp
         0D:DB18  CA         			dex
         0D:DB19  CA         			dex
         0D:DB1A  95 08      			sta.l	<__stack, x
         0D:DB1C  94 09      			sty.h	<__stack, x
         0D:DB1E  86 8D      			stx	<__sp
 3112                        		__call		_check_BG
         0D:DB20  20 81 FF   			call	_check_BG
 3113                        	
 3114                        		.dbg	line,	"include\routines_LEVELS.c", 164; if(map_blk_flag == TILE_EMPTY)
 3115                        		__not.um	_map_blk_flag
         0D:DB23  AD E9 29   			lda	_map_blk_flag
         0D:DB26  18         			clc
         0D:DB27  D0 01      			bne	!+
         0D:DB29  38         			sec
         0D:DB2A             	!:
 3116                        		__bfalse	.LL28
         0D:DB2A  90 05      			bcc	.LL28
 3117                        	
 3118                        		.dbg	line,	"include\routines_LEVELS.c", 165; {
 3119                        	
 3120                        		.dbg	line,	"include\routines_LEVELS.c", 166; player_state = STATE_JUMP_LADDER;
 3121                        		__st.umiq	13, _player_state
         0D:DB2C  A9 0D      			lda.l	#13
         0D:DB2E  8D 0F 23   			sta	_player_state
 3122                        	
 3123                        		.dbg	line,	"include\routines_LEVELS.c", 167; }
 3124                        	
 3125                        		.dbg	line,	"include\routines_LEVELS.c", 168; }
 3126    0D:DB31             	.LL28:
 3127                        	
 3128                        		.dbg	line,	"include\routines_LEVELS.c", 169; }
 3129    0D:DB31             	.LL27:
 3130    0D:DB31             	.LL26:
 3131    0D:DB31             	.LL24:
 3132                        	
 3133                        		.dbg	line,	"include\routines_LEVELS.c", 170; }
 3134    0D:DB31             	.LL20:
 3135    0D:DB31             	.LL19:
 3136    0D:DB31             	.LL17:
 3137                        	
 3138                        		.dbg	line,	"include\routines_LEVELS.c", 171; }
 3139    0D:DB31             	.LL15:
 3140    0D:DB31             	.LL14:
 3141                        		__return	0
         0D:DB31  4C EF FF   			jmp	leave_proc
 3142                        		.dbg	clear
 3143                        		.endp
 3144                        		.pceas
 3145                        	
 3146                        		.dbg	line,	"include\routines_LEVELS.c", 174; void joypad_DIR()
 3147                        		.dbg	line,	"include\routines_LEVELS.c", 175; {
 3148                        	;***********************
 3149                        	;***********************
 3150                        	
 3151                        		.hucc
 3152    0D:CF20             		.proc		_joypad_DIR
 3153                        		__enter		_joypad_DIR
 3154                        	
 3155                        		.dbg	line,	"include\routines_LEVELS.c", 176; //--------------------------------------------------------------------------------------//
 3156                        	
 3157                        		.dbg	line,	"include\routines_LEVELS.c", 177; //                                        NO DIR                                        //
 3158                        	
 3159                        		.dbg	line,	"include\routines_LEVELS.c", 178; //--------------------------------------------------------------------------------------//
 3160                        	
 3161                        		.dbg	line,	"include\routines_LEVELS.c", 180; if(! (joy(JOYPAD_1) & JOY_DIR_PRESSED) )
 3162                        		__ld.uiq	0
         0D:CF20  62         			cla
 3163                        		 _joy.1
         0D:CF21  AA         			tax
         0D:CF22  BD 28 22   			lda	joynow, x
         0D:CF25  BC D3 22   			ldy	joy6now, x
 3164                        		__nand.wi	240
         0D:CF28  18         			clc
         0D:CF29  29 F0      			and	#240
         0D:CF2B  D0 01      			bne	!+
         0D:CF2D  38         			sec
         0D:CF2E             	!:
 3165                        		__bfalse	.LL30
         0D:CF2E  90 3C      			bcc	.LL30
 3166                        	
 3167                        		.dbg	line,	"include\routines_LEVELS.c", 181; {
 3168                        	
 3169                        		.dbg	line,	"include\routines_LEVELS.c", 182; if(player_state == STATE_WALK || player_state == STATE_CROUCH)
 3170                        		__ld.umq	_player_state
         0D:CF30  AD 0F 23   			lda	_player_state
 3171                        		__equ_b.uiq	1
         0D:CF33  C9 01      			cmp	#1
         0D:CF35  F0 01      			beq	!+
         0D:CF37  18         			clc
         0D:CF38             	!:
 3172                        		__btrue		.LL32
         0D:CF38  B0 08      			bcs	.LL32
 3173                        		__ld.umq	_player_state
         0D:CF3A  AD 0F 23   			lda	_player_state
 3174                        		__equ_b.uiq	7
         0D:CF3D  C9 07      			cmp	#7
         0D:CF3F  F0 01      			beq	!+
         0D:CF41  18         			clc
         0D:CF42             	!:
 3175    0D:CF42             	.LL32:
 3176                        		__bfalse	.LL31
         0D:CF42  90 0A      			bcc	.LL31
 3177                        	
 3178                        		.dbg	line,	"include\routines_LEVELS.c", 183; {
 3179                        	
 3180                        		.dbg	line,	"include\routines_LEVELS.c", 184; player_counter_anim = 1;
 3181                        		__st.umiq	1, _player_counter_anim
         0D:CF44  A9 01      			lda.l	#1
         0D:CF46  8D 12 23   			sta	_player_counter_anim
 3182                        	
 3183                        		.dbg	line,	"include\routines_LEVELS.c", 185; player_state = STATE_IDLE;
 3184                        		__st.umiq	0, _player_state
         0D:CF49  9C 0F 23   			stz	_player_state
 3185                        	
 3186                        		.dbg	line,	"include\routines_LEVELS.c", 186; }
 3187                        	
 3188                        		.dbg	line,	"include\routines_LEVELS.c", 189; else if(player_state == STATE_CLIMB_UP || player_state == STATE_CLIMB_DOWN)
 3189                        		__bra		.LL33
         0D:CF4C  80 1E      			bra	.LL33
 3190    0D:CF4E             	.LL31:
 3191                        		__ld.umq	_player_state
         0D:CF4E  AD 0F 23   			lda	_player_state
 3192                        		__equ_b.uiq	11
         0D:CF51  C9 0B      			cmp	#11
         0D:CF53  F0 01      			beq	!+
         0D:CF55  18         			clc
         0D:CF56             	!:
 3193                        		__btrue		.LL35
         0D:CF56  B0 08      			bcs	.LL35
 3194                        		__ld.umq	_player_state
         0D:CF58  AD 0F 23   			lda	_player_state
 3195                        		__equ_b.uiq	12
         0D:CF5B  C9 0C      			cmp	#12
         0D:CF5D  F0 01      			beq	!+
         0D:CF5F  18         			clc
         0D:CF60             	!:
 3196    0D:CF60             	.LL35:
 3197                        		__bfalse	.LL34
         0D:CF60  90 0A      			bcc	.LL34
 3198                        	
 3199                        		.dbg	line,	"include\routines_LEVELS.c", 190; {
 3200                        	
 3201                        		.dbg	line,	"include\routines_LEVELS.c", 191; player_counter_anim = 1;
 3202                        		__st.umiq	1, _player_counter_anim
         0D:CF62  A9 01      			lda.l	#1
         0D:CF64  8D 12 23   			sta	_player_counter_anim
 3203                        	
 3204                        		.dbg	line,	"include\routines_LEVELS.c", 192; player_state = STATE_HANG;
 3205                        		__st.umiq	10, _player_state
         0D:CF67  A9 0A      			lda.l	#10
         0D:CF69  8D 0F 23   			sta	_player_state
 3206                        	
 3207                        		.dbg	line,	"include\routines_LEVELS.c", 193; }
 3208                        	
 3209                        		.dbg	line,	"include\routines_LEVELS.c", 194; }
 3210    0D:CF6C             	.LL34:
 3211    0D:CF6C             	.LL33:
 3212                        	
 3213                        		.dbg	line,	"include\routines_LEVELS.c", 197; //--------------------------------------------------------------------------------------//
 3214                        	
 3215                        		.dbg	line,	"include\routines_LEVELS.c", 198; //                                     RIGHT BUTTON                                     //
 3216                        	
 3217                        		.dbg	line,	"include\routines_LEVELS.c", 199; //--------------------------------------------------------------------------------------//
 3218                        	
 3219                        		.dbg	line,	"include\routines_LEVELS.c", 201; if(joy(JOYPAD_1) & JOY_RIGHT)
 3220    0D:CF6C             	.LL30:
 3221                        		__ld.uiq	0
         0D:CF6C  62         			cla
 3222                        		 _joy.1
         0D:CF6D  AA         			tax
         0D:CF6E  BD 28 22   			lda	joynow, x
         0D:CF71  BC D3 22   			ldy	joy6now, x
 3223                        		__tand.wi	32
         0D:CF74  29 20      			and	#32
         0D:CF76  C9 01      	!:		cmp	#1
 3224                        		__bfalse	.LL36
         0D:CF78  B0 03 4C 55			bcc	.LL36
         0D:CF7C  D0          
 3225                        	
 3226                        		.dbg	line,	"include\routines_LEVELS.c", 202; {
 3227                        	
 3228                        		.dbg	line,	"include\routines_LEVELS.c", 203; if(player_state == STATE_IDLE || player_state == STATE_WALK)
 3229                        		__not.um	_player_state
         0D:CF7D  AD 0F 23   			lda	_player_state
         0D:CF80  18         			clc
         0D:CF81  D0 01      			bne	!+
         0D:CF83  38         			sec
         0D:CF84             	!:
 3230                        		__btrue		.LL38
         0D:CF84  B0 08      			bcs	.LL38
 3231                        		__ld.umq	_player_state
         0D:CF86  AD 0F 23   			lda	_player_state
 3232                        		__equ_b.uiq	1
         0D:CF89  C9 01      			cmp	#1
         0D:CF8B  F0 01      			beq	!+
         0D:CF8D  18         			clc
         0D:CF8E             	!:
 3233    0D:CF8E             	.LL38:
 3234                        		__bfalse	.LL37
         0D:CF8E  90 47      			bcc	.LL37
 3235                        	
 3236                        		.dbg	line,	"include\routines_LEVELS.c", 204; {
 3237                        	
 3238                        		.dbg	line,	"include\routines_LEVELS.c", 205; player_axis = AXIS_RIGHT;
 3239                        		__st.umiq	0, _player_axis
         0D:CF90  9C 10 23   			stz	_player_axis
 3240                        	
 3241                        		.dbg	line,	"include\routines_LEVELS.c", 207; if(player_previous_axis != player_axis)
 3242                        		__ld.umq	_player_previous_axis
         0D:CF93  AD 11 23   			lda	_player_previous_axis
 3243                        		__neq_b.umq	_player_axis
         0D:CF96  38         			sec
         0D:CF97  4D 10 23   			eor	_player_axis
         0D:CF9A  D0 01      			bne	!+
         0D:CF9C  18         			clc
         0D:CF9D             	!:
 3244                        		__bfalse	.LL39
         0D:CF9D  90 15      			bcc	.LL39
 3245                        	
 3246                        		.dbg	line,	"include\routines_LEVELS.c", 208; {
 3247                        	
 3248                        		.dbg	line,	"include\routines_LEVELS.c", 209; player_previous_axis = player_axis;
 3249                        		__ld.um		_player_axis
         0D:CF9F  AD 10 23   			lda	_player_axis
         0D:CFA2  C2         			cly
 3250                        		__st.umq	_player_previous_axis
         0D:CFA3  8D 11 23   			sta	_player_previous_axis
 3251                        	
 3252                        		.dbg	line,	"include\routines_LEVELS.c", 211; spr_set(player_id);
 3253                        		__ld.umq	_player_id
         0D:CFA6  AD 0E 23   			lda	_player_id
 3254                        		__call		_spr_set.1
         0D:CFA9  20 DD E7   			call	_spr_set.1
 3255                        	
 3256                        		.dbg	line,	"include\routines_LEVELS.c", 212; spr_ctrl(FLIP_MAS, NO_FLIP_X);
 3257                        		__st.umiq	136, _al
         0D:CFAC  A9 88      			lda.l	#136
         0D:CFAE  85 F8      			sta	_al
 3258                        		__ld.uiq	0
         0D:CFB0  62         			cla
 3259                        		__call		_spr_ctrl.2
         0D:CFB1  20 3C E8   			call	_spr_ctrl.2
 3260                        	
 3261                        		.dbg	line,	"include\routines_LEVELS.c", 213; }
 3262                        	
 3263                        		.dbg	line,	"include\routines_LEVELS.c", 215; if(joy(JOYPAD_1) & JOY_DOWN)
 3264    0D:CFB4             	.LL39:
 3265                        		__ld.uiq	0
         0D:CFB4  62         			cla
 3266                        		 _joy.1
         0D:CFB5  AA         			tax
         0D:CFB6  BD 28 22   			lda	joynow, x
         0D:CFB9  BC D3 22   			ldy	joy6now, x
 3267                        		__tand.wi	64
         0D:CFBC  29 40      			and	#64
         0D:CFBE  C9 01      	!:		cmp	#1
 3268                        		__bfalse	.LL40
         0D:CFC0  90 0D      			bcc	.LL40
 3269                        	
 3270                        		.dbg	line,	"include\routines_LEVELS.c", 216; {
 3271                        	
 3272                        		.dbg	line,	"include\routines_LEVELS.c", 217; player_counter_anim = 1;
 3273                        		__st.umiq	1, _player_counter_anim
         0D:CFC2  A9 01      			lda.l	#1
         0D:CFC4  8D 12 23   			sta	_player_counter_anim
 3274                        	
 3275                        		.dbg	line,	"include\routines_LEVELS.c", 218; player_state = STATE_CROUCH;
 3276                        		__st.umiq	7, _player_state
         0D:CFC7  A9 07      			lda.l	#7
         0D:CFC9  8D 0F 23   			sta	_player_state
 3277                        	
 3278                        		.dbg	line,	"include\routines_LEVELS.c", 219; return;
 3279                        		__bra		.LL29
         0D:CFCC  4C 34 D3   			bra	.LL29
 3280                        	
 3281                        		.dbg	line,	"include\routines_LEVELS.c", 220; }
 3282                        	
 3283                        		.dbg	line,	"include\routines_LEVELS.c", 222; player_state = STATE_WALK;
 3284    0D:CFCF             	.LL40:
 3285                        		__st.umiq	1, _player_state
         0D:CFCF  A9 01      			lda.l	#1
         0D:CFD1  8D 0F 23   			sta	_player_state
 3286                        	
 3287                        		.dbg	line,	"include\routines_LEVELS.c", 223; }
 3288                        	
 3289                        		.dbg	line,	"include\routines_LEVELS.c", 226; else if(player_state == STATE_JUMP || player_state == STATE_JUMP_LEFT || player_state == STATE_CROUCH || player_state == STATE_FALL || player_state == STATE_HANG)
 3290                        		__bra		.LL41
         0D:CFD4  4C 34 D3   			bra	.LL41
 3291    0D:CFD7             	.LL37:
 3292                        		__ld.umq	_player_state
         0D:CFD7  AD 0F 23   			lda	_player_state
 3293                        		__equ_b.uiq	4
         0D:CFDA  C9 04      			cmp	#4
         0D:CFDC  F0 01      			beq	!+
         0D:CFDE  18         			clc
         0D:CFDF             	!:
 3294                        		__btrue		.LL43
         0D:CFDF  B0 08      			bcs	.LL43
 3295                        		__ld.umq	_player_state
         0D:CFE1  AD 0F 23   			lda	_player_state
 3296                        		__equ_b.uiq	6
         0D:CFE4  C9 06      			cmp	#6
         0D:CFE6  F0 01      			beq	!+
         0D:CFE8  18         			clc
         0D:CFE9             	!:
 3297    0D:CFE9             	.LL43:
 3298                        		__btrue		.LL44
         0D:CFE9  B0 08      			bcs	.LL44
 3299                        		__ld.umq	_player_state
         0D:CFEB  AD 0F 23   			lda	_player_state
 3300                        		__equ_b.uiq	7
         0D:CFEE  C9 07      			cmp	#7
         0D:CFF0  F0 01      			beq	!+
         0D:CFF2  18         			clc
         0D:CFF3             	!:
 3301    0D:CFF3             	.LL44:
 3302                        		__btrue		.LL45
         0D:CFF3  B0 08      			bcs	.LL45
 3303                        		__ld.umq	_player_state
         0D:CFF5  AD 0F 23   			lda	_player_state
 3304                        		__equ_b.uiq	9
         0D:CFF8  C9 09      			cmp	#9
         0D:CFFA  F0 01      			beq	!+
         0D:CFFC  18         			clc
         0D:CFFD             	!:
 3305    0D:CFFD             	.LL45:
 3306                        		__btrue		.LL46
         0D:CFFD  B0 08      			bcs	.LL46
 3307                        		__ld.umq	_player_state
         0D:CFFF  AD 0F 23   			lda	_player_state
 3308                        		__equ_b.uiq	10
         0D:D002  C9 0A      			cmp	#10
         0D:D004  F0 01      			beq	!+
         0D:D006  18         			clc
         0D:D007             	!:
 3309    0D:D007             	.LL46:
 3310                        		__bfalse	.LL42
         0D:D007  90 28      			bcc	.LL42
 3311                        	
 3312                        		.dbg	line,	"include\routines_LEVELS.c", 227; {
 3313                        	
 3314                        		.dbg	line,	"include\routines_LEVELS.c", 228; if(player_axis == AXIS_LEFT)
 3315                        		__ld.umq	_player_axis
         0D:D009  AD 10 23   			lda	_player_axis
 3316                        		__equ_b.uiq	1
         0D:D00C  C9 01      			cmp	#1
         0D:D00E  F0 01      			beq	!+
         0D:D010  18         			clc
         0D:D011             	!:
 3317                        		__bfalse	.LL47
         0D:D011  B0 03 4C 34			bcc	.LL47
         0D:D015  D3          
 3318                        	
 3319                        		.dbg	line,	"include\routines_LEVELS.c", 229; {
 3320                        	
 3321                        		.dbg	line,	"include\routines_LEVELS.c", 230; player_axis = AXIS_RIGHT;
 3322                        		__st.umiq	0, _player_axis
         0D:D016  9C 10 23   			stz	_player_axis
 3323                        	
 3324                        		.dbg	line,	"include\routines_LEVELS.c", 231; player_previous_axis = player_axis;
 3325                        		__ld.um		_player_axis
         0D:D019  AD 10 23   			lda	_player_axis
         0D:D01C  C2         			cly
 3326                        		__st.umq	_player_previous_axis
         0D:D01D  8D 11 23   			sta	_player_previous_axis
 3327                        	
 3328                        		.dbg	line,	"include\routines_LEVELS.c", 233; spr_set(player_id);
 3329                        		__ld.umq	_player_id
         0D:D020  AD 0E 23   			lda	_player_id
 3330                        		__call		_spr_set.1
         0D:D023  20 DD E7   			call	_spr_set.1
 3331                        	
 3332                        		.dbg	line,	"include\routines_LEVELS.c", 234; spr_ctrl(FLIP_MAS, NO_FLIP_X);
 3333                        		__st.umiq	136, _al
         0D:D026  A9 88      			lda.l	#136
         0D:D028  85 F8      			sta	_al
 3334                        		__ld.uiq	0
         0D:D02A  62         			cla
 3335                        		__call		_spr_ctrl.2
         0D:D02B  20 3C E8   			call	_spr_ctrl.2
 3336                        	
 3337                        		.dbg	line,	"include\routines_LEVELS.c", 235; }
 3338                        	
 3339                        		.dbg	line,	"include\routines_LEVELS.c", 236; }
 3340    0D:D02E             	.LL47	.alias		.LL48
 3341                        	
 3342                        		.dbg	line,	"include\routines_LEVELS.c", 239; else if(player_state == STATE_CLIMB_UP || player_state == STATE_CLIMB_DOWN)
 3343                        		__bra		.LL48
         0D:D02E  4C 34 D3   			bra	.LL48
 3344    0D:D031             	.LL42:
 3345                        		__ld.umq	_player_state
         0D:D031  AD 0F 23   			lda	_player_state
 3346                        		__equ_b.uiq	11
         0D:D034  C9 0B      			cmp	#11
         0D:D036  F0 01      			beq	!+
         0D:D038  18         			clc
         0D:D039             	!:
 3347                        		__btrue		.LL50
         0D:D039  B0 08      			bcs	.LL50
 3348                        		__ld.umq	_player_state
         0D:D03B  AD 0F 23   			lda	_player_state
 3349                        		__equ_b.uiq	12
         0D:D03E  C9 0C      			cmp	#12
         0D:D040  F0 01      			beq	!+
         0D:D042  18         			clc
         0D:D043             	!:
 3350    0D:D043             	.LL50:
 3351                        		__bfalse	.LL49
         0D:D043  B0 03 4C 34			bcc	.LL49
         0D:D047  D3          
 3352                        	
 3353                        		.dbg	line,	"include\routines_LEVELS.c", 240; {
 3354                        	
 3355                        		.dbg	line,	"include\routines_LEVELS.c", 241; player_counter_anim = 1;
 3356                        		__st.umiq	1, _player_counter_anim
         0D:D048  A9 01      			lda.l	#1
         0D:D04A  8D 12 23   			sta	_player_counter_anim
 3357                        	
 3358                        		.dbg	line,	"include\routines_LEVELS.c", 242; player_state = STATE_HANG;
 3359                        		__st.umiq	10, _player_state
         0D:D04D  A9 0A      			lda.l	#10
         0D:D04F  8D 0F 23   			sta	_player_state
 3360                        	
 3361                        		.dbg	line,	"include\routines_LEVELS.c", 243; }
 3362                        	
 3363                        		.dbg	line,	"include\routines_LEVELS.c", 244; }
 3364    0D:D052             	.LL49	.alias		.LL51
 3365    0D:D052             	.LL48	.alias		.LL51
 3366    0D:D052             	.LL41	.alias		.LL51
 3367                        	
 3368                        		.dbg	line,	"include\routines_LEVELS.c", 247; //--------------------------------------------------------------------------------------//
 3369                        	
 3370                        		.dbg	line,	"include\routines_LEVELS.c", 248; //                                     LEFT BUTTON                                      //
 3371                        	
 3372                        		.dbg	line,	"include\routines_LEVELS.c", 249; //--------------------------------------------------------------------------------------//
 3373                        	
 3374                        		.dbg	line,	"include\routines_LEVELS.c", 251; else if(joy(JOYPAD_1) & JOY_LEFT)
 3375                        		__bra		.LL51
         0D:D052  4C 34 D3   			bra	.LL51
 3376    0D:D055             	.LL36:
 3377                        		__ld.uiq	0
         0D:D055  62         			cla
 3378                        		 _joy.1
         0D:D056  AA         			tax
         0D:D057  BD 28 22   			lda	joynow, x
         0D:D05A  BC D3 22   			ldy	joy6now, x
 3379                        		__tand.wi	128
         0D:D05D  29 80      			and	#128
         0D:D05F  C9 01      	!:		cmp	#1
 3380                        		__bfalse	.LL52
         0D:D061  B0 03 4C 43			bcc	.LL52
         0D:D065  D1          
 3381                        	
 3382                        		.dbg	line,	"include\routines_LEVELS.c", 252; {
 3383                        	
 3384                        		.dbg	line,	"include\routines_LEVELS.c", 253; if(player_state == STATE_IDLE || player_state == STATE_WALK)
 3385                        		__not.um	_player_state
         0D:D066  AD 0F 23   			lda	_player_state
         0D:D069  18         			clc
         0D:D06A  D0 01      			bne	!+
         0D:D06C  38         			sec
         0D:D06D             	!:
 3386                        		__btrue		.LL54
         0D:D06D  B0 08      			bcs	.LL54
 3387                        		__ld.umq	_player_state
         0D:D06F  AD 0F 23   			lda	_player_state
 3388                        		__equ_b.uiq	1
         0D:D072  C9 01      			cmp	#1
         0D:D074  F0 01      			beq	!+
         0D:D076  18         			clc
         0D:D077             	!:
 3389    0D:D077             	.LL54:
 3390                        		__bfalse	.LL53
         0D:D077  90 4A      			bcc	.LL53
 3391                        	
 3392                        		.dbg	line,	"include\routines_LEVELS.c", 254; {
 3393                        	
 3394                        		.dbg	line,	"include\routines_LEVELS.c", 255; player_axis = AXIS_LEFT;
 3395                        		__st.umiq	1, _player_axis
         0D:D079  A9 01      			lda.l	#1
         0D:D07B  8D 10 23   			sta	_player_axis
 3396                        	
 3397                        		.dbg	line,	"include\routines_LEVELS.c", 257; if(player_previous_axis != player_axis)
 3398                        		__ld.umq	_player_previous_axis
         0D:D07E  AD 11 23   			lda	_player_previous_axis
 3399                        		__neq_b.umq	_player_axis
         0D:D081  38         			sec
         0D:D082  4D 10 23   			eor	_player_axis
         0D:D085  D0 01      			bne	!+
         0D:D087  18         			clc
         0D:D088             	!:
 3400                        		__bfalse	.LL55
         0D:D088  90 16      			bcc	.LL55
 3401                        	
 3402                        		.dbg	line,	"include\routines_LEVELS.c", 258; {
 3403                        	
 3404                        		.dbg	line,	"include\routines_LEVELS.c", 259; player_previous_axis = player_axis;
 3405                        		__ld.um		_player_axis
         0D:D08A  AD 10 23   			lda	_player_axis
         0D:D08D  C2         			cly
 3406                        		__st.umq	_player_previous_axis
         0D:D08E  8D 11 23   			sta	_player_previous_axis
 3407                        	
 3408                        		.dbg	line,	"include\routines_LEVELS.c", 261; spr_set(player_id);
 3409                        		__ld.umq	_player_id
         0D:D091  AD 0E 23   			lda	_player_id
 3410                        		__call		_spr_set.1
         0D:D094  20 DD E7   			call	_spr_set.1
 3411                        	
 3412                        		.dbg	line,	"include\routines_LEVELS.c", 262; spr_ctrl(FLIP_MAS, FLIP_X);
 3413                        		__st.umiq	136, _al
         0D:D097  A9 88      			lda.l	#136
         0D:D099  85 F8      			sta	_al
 3414                        		__ld.uiq	8
         0D:D09B  A9 08      			lda	#8
 3415                        		__call		_spr_ctrl.2
         0D:D09D  20 3C E8   			call	_spr_ctrl.2
 3416                        	
 3417                        		.dbg	line,	"include\routines_LEVELS.c", 263; }
 3418                        	
 3419                        		.dbg	line,	"include\routines_LEVELS.c", 265; if(joy(JOYPAD_1) & JOY_DOWN)
 3420    0D:D0A0             	.LL55:
 3421                        		__ld.uiq	0
         0D:D0A0  62         			cla
 3422                        		 _joy.1
         0D:D0A1  AA         			tax
         0D:D0A2  BD 28 22   			lda	joynow, x
         0D:D0A5  BC D3 22   			ldy	joy6now, x
 3423                        		__tand.wi	64
         0D:D0A8  29 40      			and	#64
         0D:D0AA  C9 01      	!:		cmp	#1
 3424                        		__bfalse	.LL56
         0D:D0AC  90 0D      			bcc	.LL56
 3425                        	
 3426                        		.dbg	line,	"include\routines_LEVELS.c", 266; {
 3427                        	
 3428                        		.dbg	line,	"include\routines_LEVELS.c", 267; player_counter_anim = 1;
 3429                        		__st.umiq	1, _player_counter_anim
         0D:D0AE  A9 01      			lda.l	#1
         0D:D0B0  8D 12 23   			sta	_player_counter_anim
 3430                        	
 3431                        		.dbg	line,	"include\routines_LEVELS.c", 268; player_state = STATE_CROUCH;
 3432                        		__st.umiq	7, _player_state
         0D:D0B3  A9 07      			lda.l	#7
         0D:D0B5  8D 0F 23   			sta	_player_state
 3433                        	
 3434                        		.dbg	line,	"include\routines_LEVELS.c", 269; return;
 3435                        		__bra		.LL29
         0D:D0B8  4C 34 D3   			bra	.LL29
 3436                        	
 3437                        		.dbg	line,	"include\routines_LEVELS.c", 270; }
 3438                        	
 3439                        		.dbg	line,	"include\routines_LEVELS.c", 272; player_state = STATE_WALK;
 3440    0D:D0BB             	.LL56:
 3441                        		__st.umiq	1, _player_state
         0D:D0BB  A9 01      			lda.l	#1
         0D:D0BD  8D 0F 23   			sta	_player_state
 3442                        	
 3443                        		.dbg	line,	"include\routines_LEVELS.c", 273; }
 3444                        	
 3445                        		.dbg	line,	"include\routines_LEVELS.c", 276; else if(player_state == STATE_JUMP || player_state == STATE_JUMP_RIGHT || player_state == STATE_CROUCH || player_state == STATE_FALL || player_state == STATE_HANG)
 3446                        		__bra		.LL57
         0D:D0C0  4C 34 D3   			bra	.LL57
 3447    0D:D0C3             	.LL53:
 3448                        		__ld.umq	_player_state
         0D:D0C3  AD 0F 23   			lda	_player_state
 3449                        		__equ_b.uiq	4
         0D:D0C6  C9 04      			cmp	#4
         0D:D0C8  F0 01      			beq	!+
         0D:D0CA  18         			clc
         0D:D0CB             	!:
 3450                        		__btrue		.LL59
         0D:D0CB  B0 08      			bcs	.LL59
 3451                        		__ld.umq	_player_state
         0D:D0CD  AD 0F 23   			lda	_player_state
 3452                        		__equ_b.uiq	5
         0D:D0D0  C9 05      			cmp	#5
         0D:D0D2  F0 01      			beq	!+
         0D:D0D4  18         			clc
         0D:D0D5             	!:
 3453    0D:D0D5             	.LL59:
 3454                        		__btrue		.LL60
         0D:D0D5  B0 08      			bcs	.LL60
 3455                        		__ld.umq	_player_state
         0D:D0D7  AD 0F 23   			lda	_player_state
 3456                        		__equ_b.uiq	7
         0D:D0DA  C9 07      			cmp	#7
         0D:D0DC  F0 01      			beq	!+
         0D:D0DE  18         			clc
         0D:D0DF             	!:
 3457    0D:D0DF             	.LL60:
 3458                        		__btrue		.LL61
         0D:D0DF  B0 08      			bcs	.LL61
 3459                        		__ld.umq	_player_state
         0D:D0E1  AD 0F 23   			lda	_player_state
 3460                        		__equ_b.uiq	9
         0D:D0E4  C9 09      			cmp	#9
         0D:D0E6  F0 01      			beq	!+
         0D:D0E8  18         			clc
         0D:D0E9             	!:
 3461    0D:D0E9             	.LL61:
 3462                        		__btrue		.LL62
         0D:D0E9  B0 08      			bcs	.LL62
 3463                        		__ld.umq	_player_state
         0D:D0EB  AD 0F 23   			lda	_player_state
 3464                        		__equ_b.uiq	10
         0D:D0EE  C9 0A      			cmp	#10
         0D:D0F0  F0 01      			beq	!+
         0D:D0F2  18         			clc
         0D:D0F3             	!:
 3465    0D:D0F3             	.LL62:
 3466                        		__bfalse	.LL58
         0D:D0F3  90 2A      			bcc	.LL58
 3467                        	
 3468                        		.dbg	line,	"include\routines_LEVELS.c", 277; {
 3469                        	
 3470                        		.dbg	line,	"include\routines_LEVELS.c", 278; if(player_axis == AXIS_RIGHT)
 3471                        		__not.um	_player_axis
         0D:D0F5  AD 10 23   			lda	_player_axis
         0D:D0F8  18         			clc
         0D:D0F9  D0 01      			bne	!+
         0D:D0FB  38         			sec
         0D:D0FC             	!:
 3472                        		__bfalse	.LL63
         0D:D0FC  B0 03 4C 34			bcc	.LL63
         0D:D100  D3          
 3473                        	
 3474                        		.dbg	line,	"include\routines_LEVELS.c", 279; {
 3475                        	
 3476                        		.dbg	line,	"include\routines_LEVELS.c", 280; player_axis = AXIS_LEFT;
 3477                        		__st.umiq	1, _player_axis
         0D:D101  A9 01      			lda.l	#1
         0D:D103  8D 10 23   			sta	_player_axis
 3478                        	
 3479                        		.dbg	line,	"include\routines_LEVELS.c", 281; player_previous_axis = player_axis;
 3480                        		__ld.um		_player_axis
         0D:D106  AD 10 23   			lda	_player_axis
         0D:D109  C2         			cly
 3481                        		__st.umq	_player_previous_axis
         0D:D10A  8D 11 23   			sta	_player_previous_axis
 3482                        	
 3483                        		.dbg	line,	"include\routines_LEVELS.c", 283; spr_set(player_id);
 3484                        		__ld.umq	_player_id
         0D:D10D  AD 0E 23   			lda	_player_id
 3485                        		__call		_spr_set.1
         0D:D110  20 DD E7   			call	_spr_set.1
 3486                        	
 3487                        		.dbg	line,	"include\routines_LEVELS.c", 284; spr_ctrl(FLIP_MAS, FLIP_X);
 3488                        		__st.umiq	136, _al
         0D:D113  A9 88      			lda.l	#136
         0D:D115  85 F8      			sta	_al
 3489                        		__ld.uiq	8
         0D:D117  A9 08      			lda	#8
 3490                        		__call		_spr_ctrl.2
         0D:D119  20 3C E8   			call	_spr_ctrl.2
 3491                        	
 3492                        		.dbg	line,	"include\routines_LEVELS.c", 285; }
 3493                        	
 3494                        		.dbg	line,	"include\routines_LEVELS.c", 286; }
 3495    0D:D11C             	.LL63	.alias		.LL64
 3496                        	
 3497                        		.dbg	line,	"include\routines_LEVELS.c", 289; else if(player_state == STATE_CLIMB_UP || player_state == STATE_CLIMB_DOWN)
 3498                        		__bra		.LL64
         0D:D11C  4C 34 D3   			bra	.LL64
 3499    0D:D11F             	.LL58:
 3500                        		__ld.umq	_player_state
         0D:D11F  AD 0F 23   			lda	_player_state
 3501                        		__equ_b.uiq	11
         0D:D122  C9 0B      			cmp	#11
         0D:D124  F0 01      			beq	!+
         0D:D126  18         			clc
         0D:D127             	!:
 3502                        		__btrue		.LL66
         0D:D127  B0 08      			bcs	.LL66
 3503                        		__ld.umq	_player_state
         0D:D129  AD 0F 23   			lda	_player_state
 3504                        		__equ_b.uiq	12
         0D:D12C  C9 0C      			cmp	#12
         0D:D12E  F0 01      			beq	!+
         0D:D130  18         			clc
         0D:D131             	!:
 3505    0D:D131             	.LL66:
 3506                        		__bfalse	.LL65
         0D:D131  B0 03 4C 34			bcc	.LL65
         0D:D135  D3          
 3507                        	
 3508                        		.dbg	line,	"include\routines_LEVELS.c", 290; {
 3509                        	
 3510                        		.dbg	line,	"include\routines_LEVELS.c", 291; player_counter_anim = 1;
 3511                        		__st.umiq	1, _player_counter_anim
         0D:D136  A9 01      			lda.l	#1
         0D:D138  8D 12 23   			sta	_player_counter_anim
 3512                        	
 3513                        		.dbg	line,	"include\routines_LEVELS.c", 292; player_state = STATE_HANG;
 3514                        		__st.umiq	10, _player_state
         0D:D13B  A9 0A      			lda.l	#10
         0D:D13D  8D 0F 23   			sta	_player_state
 3515                        	
 3516                        		.dbg	line,	"include\routines_LEVELS.c", 293; }
 3517                        	
 3518                        		.dbg	line,	"include\routines_LEVELS.c", 294; }
 3519    0D:D140             	.LL65	.alias		.LL67
 3520    0D:D140             	.LL64	.alias		.LL67
 3521    0D:D140             	.LL57	.alias		.LL67
 3522                        	
 3523                        		.dbg	line,	"include\routines_LEVELS.c", 297; //--------------------------------------------------------------------------------------//
 3524                        	
 3525                        		.dbg	line,	"include\routines_LEVELS.c", 298; //                                      UP BUTTON                                       //
 3526                        	
 3527                        		.dbg	line,	"include\routines_LEVELS.c", 299; //--------------------------------------------------------------------------------------//
 3528                        	
 3529                        		.dbg	line,	"include\routines_LEVELS.c", 301; else if(joy(JOYPAD_1) & JOY_UP)
 3530                        		__bra		.LL67
         0D:D140  4C 34 D3   			bra	.LL67
 3531    0D:D143             	.LL52:
 3532                        		__ld.uiq	0
         0D:D143  62         			cla
 3533                        		 _joy.1
         0D:D144  AA         			tax
         0D:D145  BD 28 22   			lda	joynow, x
         0D:D148  BC D3 22   			ldy	joy6now, x
 3534                        		__tand.wi	16
         0D:D14B  29 10      			and	#16
         0D:D14D  C9 01      	!:		cmp	#1
 3535                        		__bfalse	.LL68
         0D:D14F  B0 03 4C 18			bcc	.LL68
         0D:D153  D2          
 3536                        	
 3537                        		.dbg	line,	"include\routines_LEVELS.c", 302; {
 3538                        	
 3539                        		.dbg	line,	"include\routines_LEVELS.c", 303; if(player_state == STATE_HANG || player_state == STATE_CLIMB_UP || player_state == STATE_CLIMB_DOWN)
 3540                        		__ld.umq	_player_state
         0D:D154  AD 0F 23   			lda	_player_state
 3541                        		__equ_b.uiq	10
         0D:D157  C9 0A      			cmp	#10
         0D:D159  F0 01      			beq	!+
         0D:D15B  18         			clc
         0D:D15C             	!:
 3542                        		__btrue		.LL70
         0D:D15C  B0 08      			bcs	.LL70
 3543                        		__ld.umq	_player_state
         0D:D15E  AD 0F 23   			lda	_player_state
 3544                        		__equ_b.uiq	11
         0D:D161  C9 0B      			cmp	#11
         0D:D163  F0 01      			beq	!+
         0D:D165  18         			clc
         0D:D166             	!:
 3545    0D:D166             	.LL70:
 3546                        		__btrue		.LL71
         0D:D166  B0 08      			bcs	.LL71
 3547                        		__ld.umq	_player_state
         0D:D168  AD 0F 23   			lda	_player_state
 3548                        		__equ_b.uiq	12
         0D:D16B  C9 0C      			cmp	#12
         0D:D16D  F0 01      			beq	!+
         0D:D16F  18         			clc
         0D:D170             	!:
 3549    0D:D170             	.LL71:
 3550                        		__bfalse	.LL69
         0D:D170  B0 03 4C 34			bcc	.LL69
         0D:D174  D3          
 3551                        	
 3552                        		.dbg	line,	"include\routines_LEVELS.c", 304; {
 3553                        	
 3554                        		.dbg	line,	"include\routines_LEVELS.c", 305; unsigned char i;
 3555                        	
 3556                        		.dbg	line,	"include\routines_LEVELS.c", 307; check_BG( 15 , 8 );
 3557                        		__ld.wi		15
         0D:D175  A9 0F      			lda.l	#15
         0D:D177  C2         			cly
 3558                        		__pusharg.wr
         0D:D178  A6 8D      			ldx	<__sp
         0D:D17A  CA         			dex
         0D:D17B  CA         			dex
         0D:D17C  95 08      			sta.l	<__stack, x
         0D:D17E  94 09      			sty.h	<__stack, x
         0D:D180  86 8D      			stx	<__sp
 3559                        		__ld.wi		8
         0D:D182  A9 08      			lda.l	#8
         0D:D184  C2         			cly
 3560                        		__pusharg.wr
         0D:D185  A6 8D      			ldx	<__sp
         0D:D187  CA         			dex
         0D:D188  CA         			dex
         0D:D189  95 08      			sta.l	<__stack, x
         0D:D18B  94 09      			sty.h	<__stack, x
         0D:D18D  86 8D      			stx	<__sp
 3561                        		__call		_check_BG
         0D:D18F  20 81 FF   			call	_check_BG
 3562                        	
 3563                        		.dbg	line,	"include\routines_LEVELS.c", 309; if(map_blk_flag == TILE_EMPTY)
 3564                        		__not.um	_map_blk_flag
         0D:D192  AD E9 29   			lda	_map_blk_flag
         0D:D195  18         			clc
         0D:D196  D0 01      			bne	!+
         0D:D198  38         			sec
         0D:D199             	!:
 3565                        		__bfalse	.LL72
         0D:D199  90 67      			bcc	.LL72
 3566                        	
 3567                        		.dbg	line,	"include\routines_LEVELS.c", 310; {
 3568                        	
 3569                        		.dbg	line,	"include\routines_LEVELS.c", 311; for(i=1 ; i<3 ; i++)
 3570                        		__st.umiq	1, __joypad_DIR_end - 1  /* i */
         0D:D19B  A9 01      			lda.l	#1
         0D:D19D  8D 01 23   			sta	__joypad_DIR_end - 1
 3571    0D:D1A0             	.LL73:
 3572                        		__ld.umq	__joypad_DIR_end - 1  /* i */
         0D:D1A0  AD 01 23   			lda	__joypad_DIR_end - 1
 3573                        		__ult_b.uiq	3
         0D:D1A3  C9 03      			cmp	#3		; Subtract integer from A.
         0D:D1A5  6A         			ror	a		; CC if A < integer.
         0D:D1A6  49 80      			eor	#$80
         0D:D1A8  2A         			rol	a
 3574                        		__btrue		.LL75
         0D:D1A9  B0 07      			bcs	.LL75
 3575                        		__bra		.LL76
         0D:D1AB  80 63      			bra	.LL76
 3576    0D:D1AD             	.LL74:
 3577                        		__inc.umq	__joypad_DIR_end - 1  /* i */
         0D:D1AD  EE 01 23   			inc	__joypad_DIR_end - 1
 3578                        		__bra		.LL73
         0D:D1B0  80 EE      			bra	.LL73
 3579    0D:D1B2             	.LL75:
 3580                        	
 3581                        		.dbg	line,	"include\routines_LEVELS.c", 312; {
 3582                        	
 3583                        		.dbg	line,	"include\routines_LEVELS.c", 313; check_BG( 15 , 8 + i );
 3584                        		__ld.wi		15
         0D:D1B2  A9 0F      			lda.l	#15
         0D:D1B4  C2         			cly
 3585                        		__pusharg.wr
         0D:D1B5  A6 8D      			ldx	<__sp
         0D:D1B7  CA         			dex
         0D:D1B8  CA         			dex
         0D:D1B9  95 08      			sta.l	<__stack, x
         0D:D1BB  94 09      			sty.h	<__stack, x
         0D:D1BD  86 8D      			stx	<__sp
 3586                        		__ld.wi		8
         0D:D1BF  A9 08      			lda.l	#8
         0D:D1C1  C2         			cly
 3587                        		__add.um	__joypad_DIR_end - 1  /* i */
         0D:D1C2  18         			clc
         0D:D1C3  6D 01 23   			adc	__joypad_DIR_end - 1
         0D:D1C6  90 01      			bcc	!+
         0D:D1C8  C8         			iny
         0D:D1C9             	!:
 3588                        		__pusharg.wr
         0D:D1C9  A6 8D      			ldx	<__sp
         0D:D1CB  CA         			dex
         0D:D1CC  CA         			dex
         0D:D1CD  95 08      			sta.l	<__stack, x
         0D:D1CF  94 09      			sty.h	<__stack, x
         0D:D1D1  86 8D      			stx	<__sp
 3589                        		__call		_check_BG
         0D:D1D3  20 81 FF   			call	_check_BG
 3590                        	
 3591                        		.dbg	line,	"include\routines_LEVELS.c", 315; if(map_blk_flag == TILE_LADDER)
 3592                        		__ld.umq	_map_blk_flag
         0D:D1D6  AD E9 29   			lda	_map_blk_flag
 3593                        		__equ_b.uiq	2
         0D:D1D9  C9 02      			cmp	#2
         0D:D1DB  F0 01      			beq	!+
         0D:D1DD  18         			clc
         0D:D1DE             	!:
 3594                        		__bfalse	.LL77
         0D:D1DE  90 CD      			bcc	.LL77
 3595                        	
 3596                        		.dbg	line,	"include\routines_LEVELS.c", 316; {
 3597                        	
 3598                        		.dbg	line,	"include\routines_LEVELS.c", 317; sgx_map_pxl_y -= (2 - i);
 3599                        		__ld.wi		2
         0D:D1E0  A9 02      			lda.l	#2
         0D:D1E2  C2         			cly
 3600                        		__sub.um	__joypad_DIR_end - 1  /* i */
         0D:D1E3  38         			sec
         0D:D1E4  ED 01 23   			sbc	__joypad_DIR_end - 1
         0D:D1E7  B0 01      			bcs	!+
         0D:D1E9  88         			dey
         0D:D1EA             	!:
 3601                        		__isub_st.wmq	_sgx_map_pxl_y
         0D:D1EA  38         			sec
         0D:D1EB  49 FF      			eor	#$FF
         0D:D1ED  6D CA 24   			adc.l	_sgx_map_pxl_y
         0D:D1F0  8D CA 24   			sta.l	_sgx_map_pxl_y
         0D:D1F3  98         			tya
         0D:D1F4  49 FF      			eor	#$FF
         0D:D1F6  6D CB 24   			adc.h	_sgx_map_pxl_y
         0D:D1F9  8D CB 24   			sta.h	_sgx_map_pxl_y
 3602                        	
 3603                        		.dbg	line,	"include\routines_LEVELS.c", 318; break;
 3604                        		__bra		.LL76
         0D:D1FC  80 12      			bra	.LL76
 3605                        	
 3606                        		.dbg	line,	"include\routines_LEVELS.c", 319; }
 3607                        	
 3608                        		.dbg	line,	"include\routines_LEVELS.c", 320; }
 3609    0D:D1FE             	.LL77	.alias		.LL74
 3610                        		__bra		.LL74
         0D:D1FE  80 AD      			bra	.LL74
 3611    0D:D200             	.LL76	.alias		.LL78
 3612                        	
 3613                        		.dbg	line,	"include\routines_LEVELS.c", 321; }
 3614                        	
 3615                        		.dbg	line,	"include\routines_LEVELS.c", 323; else
 3616                        		__bra		.LL78
         0D:D200  80 0E      			bra	.LL78
 3617    0D:D202             	.LL72:
 3618                        	
 3619                        		.dbg	line,	"include\routines_LEVELS.c", 324; {
 3620                        	
 3621                        		.dbg	line,	"include\routines_LEVELS.c", 325; sgx_map_pxl_y -= 2;
 3622                        		__sub_st.wmiq	2, _sgx_map_pxl_y
         0D:D202  38         			sec
         0D:D203  AD CA 24   			lda.l	_sgx_map_pxl_y
         0D:D206  E9 02      			sbc.l	#2
         0D:D208  8D CA 24   			sta.l	_sgx_map_pxl_y
         0D:D20B  B0 03      			bcs	!+
         0D:D20D  CE CB 24   			dec.h	_sgx_map_pxl_y
         0D:D210             	!:
 3623                        	
 3624                        		.dbg	line,	"include\routines_LEVELS.c", 326; }
 3625    0D:D210             	.LL78:
 3626                        	
 3627                        		.dbg	line,	"include\routines_LEVELS.c", 328; player_state = STATE_CLIMB_UP;
 3628                        		__st.umiq	11, _player_state
         0D:D210  A9 0B      			lda.l	#11
         0D:D212  8D 0F 23   			sta	_player_state
 3629                        	
 3630                        		.dbg	line,	"include\routines_LEVELS.c", 329; }
 3631                        	
 3632                        		.dbg	line,	"include\routines_LEVELS.c", 330; }
 3633    0D:D215             	.LL69	.alias		.LL79
 3634                        	
 3635                        		.dbg	line,	"include\routines_LEVELS.c", 333; //--------------------------------------------------------------------------------------//
 3636                        	
 3637                        		.dbg	line,	"include\routines_LEVELS.c", 334; //                                     DOWN BUTTON                                      //
 3638                        	
 3639                        		.dbg	line,	"include\routines_LEVELS.c", 335; //--------------------------------------------------------------------------------------//
 3640                        	
 3641                        		.dbg	line,	"include\routines_LEVELS.c", 337; else if(joy(JOYPAD_1) & JOY_DOWN)
 3642                        		__bra		.LL79
         0D:D215  4C 34 D3   			bra	.LL79
 3643    0D:D218             	.LL68:
 3644                        		__ld.uiq	0
         0D:D218  62         			cla
 3645                        		 _joy.1
         0D:D219  AA         			tax
         0D:D21A  BD 28 22   			lda	joynow, x
         0D:D21D  BC D3 22   			ldy	joy6now, x
 3646                        		__tand.wi	64
         0D:D220  29 40      			and	#64
         0D:D222  C9 01      	!:		cmp	#1
 3647                        		__bfalse	.LL80
         0D:D224  B0 03 4C 34			bcc	.LL80
         0D:D228  D3          
 3648                        	
 3649                        		.dbg	line,	"include\routines_LEVELS.c", 338; {
 3650                        	
 3651                        		.dbg	line,	"include\routines_LEVELS.c", 339; if(player_state == STATE_IDLE || player_state == STATE_WALK)
 3652                        		__not.um	_player_state
         0D:D229  AD 0F 23   			lda	_player_state
         0D:D22C  18         			clc
         0D:D22D  D0 01      			bne	!+
         0D:D22F  38         			sec
         0D:D230             	!:
 3653                        		__btrue		.LL82
         0D:D230  B0 08      			bcs	.LL82
 3654                        		__ld.umq	_player_state
         0D:D232  AD 0F 23   			lda	_player_state
 3655                        		__equ_b.uiq	1
         0D:D235  C9 01      			cmp	#1
         0D:D237  F0 01      			beq	!+
         0D:D239  18         			clc
         0D:D23A             	!:
 3656    0D:D23A             	.LL82:
 3657                        		__bfalse	.LL81
         0D:D23A  90 0D      			bcc	.LL81
 3658                        	
 3659                        		.dbg	line,	"include\routines_LEVELS.c", 340; {
 3660                        	
 3661                        		.dbg	line,	"include\routines_LEVELS.c", 341; player_counter_anim = 1;
 3662                        		__st.umiq	1, _player_counter_anim
         0D:D23C  A9 01      			lda.l	#1
         0D:D23E  8D 12 23   			sta	_player_counter_anim
 3663                        	
 3664                        		.dbg	line,	"include\routines_LEVELS.c", 342; player_state = STATE_CROUCH;
 3665                        		__st.umiq	7, _player_state
         0D:D241  A9 07      			lda.l	#7
         0D:D243  8D 0F 23   			sta	_player_state
 3666                        	
 3667                        		.dbg	line,	"include\routines_LEVELS.c", 343; }
 3668                        	
 3669                        		.dbg	line,	"include\routines_LEVELS.c", 346; else if(player_state == STATE_HANG || player_state == STATE_CLIMB_UP || player_state == STATE_CLIMB_DOWN)
 3670                        		__bra		.LL83
         0D:D246  4C 34 D3   			bra	.LL83
 3671    0D:D249             	.LL81:
 3672                        		__ld.umq	_player_state
         0D:D249  AD 0F 23   			lda	_player_state
 3673                        		__equ_b.uiq	10
         0D:D24C  C9 0A      			cmp	#10
         0D:D24E  F0 01      			beq	!+
         0D:D250  18         			clc
         0D:D251             	!:
 3674                        		__btrue		.LL85
         0D:D251  B0 08      			bcs	.LL85
 3675                        		__ld.umq	_player_state
         0D:D253  AD 0F 23   			lda	_player_state
 3676                        		__equ_b.uiq	11
         0D:D256  C9 0B      			cmp	#11
         0D:D258  F0 01      			beq	!+
         0D:D25A  18         			clc
         0D:D25B             	!:
 3677    0D:D25B             	.LL85:
 3678                        		__btrue		.LL86
         0D:D25B  B0 08      			bcs	.LL86
 3679                        		__ld.umq	_player_state
         0D:D25D  AD 0F 23   			lda	_player_state
 3680                        		__equ_b.uiq	12
         0D:D260  C9 0C      			cmp	#12
         0D:D262  F0 01      			beq	!+
         0D:D264  18         			clc
         0D:D265             	!:
 3681    0D:D265             	.LL86:
 3682                        		__bfalse	.LL84
         0D:D265  B0 03 4C 34			bcc	.LL84
         0D:D269  D3          
 3683                        	
 3684                        		.dbg	line,	"include\routines_LEVELS.c", 347; {
 3685                        	
 3686                        		.dbg	line,	"include\routines_LEVELS.c", 348; unsigned char i;
 3687                        	
 3688                        		.dbg	line,	"include\routines_LEVELS.c", 350; check_BG( 15 , 10 );
 3689                        		__ld.wi		15
         0D:D26A  A9 0F      			lda.l	#15
         0D:D26C  C2         			cly
 3690                        		__pusharg.wr
         0D:D26D  A6 8D      			ldx	<__sp
         0D:D26F  CA         			dex
         0D:D270  CA         			dex
         0D:D271  95 08      			sta.l	<__stack, x
         0D:D273  94 09      			sty.h	<__stack, x
         0D:D275  86 8D      			stx	<__sp
 3691                        		__ld.wi		10
         0D:D277  A9 0A      			lda.l	#10
         0D:D279  C2         			cly
 3692                        		__pusharg.wr
         0D:D27A  A6 8D      			ldx	<__sp
         0D:D27C  CA         			dex
         0D:D27D  CA         			dex
         0D:D27E  95 08      			sta.l	<__stack, x
         0D:D280  94 09      			sty.h	<__stack, x
         0D:D282  86 8D      			stx	<__sp
 3693                        		__call		_check_BG
         0D:D284  20 81 FF   			call	_check_BG
 3694                        	
 3695                        		.dbg	line,	"include\routines_LEVELS.c", 352; if(map_blk_flag == TILE_EMPTY)
 3696                        		__not.um	_map_blk_flag
         0D:D287  AD E9 29   			lda	_map_blk_flag
         0D:D28A  18         			clc
         0D:D28B  D0 01      			bne	!+
         0D:D28D  38         			sec
         0D:D28E             	!:
 3697                        		__bfalse	.LL87
         0D:D28E  B0 03 4C 21			bcc	.LL87
         0D:D292  D3          
 3698                        	
 3699                        		.dbg	line,	"include\routines_LEVELS.c", 353; {
 3700                        	
 3701                        		.dbg	line,	"include\routines_LEVELS.c", 354; for(i=1 ; i<3 ; i++)
 3702                        		__st.umiq	1, __joypad_DIR_end - 2  /* i */
         0D:D293  A9 01      			lda.l	#1
         0D:D295  8D 00 23   			sta	__joypad_DIR_end - 2
 3703    0D:D298             	.LL88:
 3704                        		__ld.umq	__joypad_DIR_end - 2  /* i */
         0D:D298  AD 00 23   			lda	__joypad_DIR_end - 2
 3705                        		__ult_b.uiq	3
         0D:D29B  C9 03      			cmp	#3		; Subtract integer from A.
         0D:D29D  6A         			ror	a		; CC if A < integer.
         0D:D29E  49 80      			eor	#$80
         0D:D2A0  2A         			rol	a
 3706                        		__btrue		.LL90
         0D:D2A1  B0 08      			bcs	.LL90
 3707                        		__bra		.LL91
         0D:D2A3  4C 34 D3   			bra	.LL91
 3708    0D:D2A6             	.LL89:
 3709                        		__inc.umq	__joypad_DIR_end - 2  /* i */
         0D:D2A6  EE 00 23   			inc	__joypad_DIR_end - 2
 3710                        		__bra		.LL88
         0D:D2A9  80 ED      			bra	.LL88
 3711    0D:D2AB             	.LL90:
 3712                        	
 3713                        		.dbg	line,	"include\routines_LEVELS.c", 355; {
 3714                        	
 3715                        		.dbg	line,	"include\routines_LEVELS.c", 356; check_BG( 15 , 22 + i );
 3716                        		__ld.wi		15
         0D:D2AB  A9 0F      			lda.l	#15
         0D:D2AD  C2         			cly
 3717                        		__pusharg.wr
         0D:D2AE  A6 8D      			ldx	<__sp
         0D:D2B0  CA         			dex
         0D:D2B1  CA         			dex
         0D:D2B2  95 08      			sta.l	<__stack, x
         0D:D2B4  94 09      			sty.h	<__stack, x
         0D:D2B6  86 8D      			stx	<__sp
 3718                        		__ld.wi		22
         0D:D2B8  A9 16      			lda.l	#22
         0D:D2BA  C2         			cly
 3719                        		__add.um	__joypad_DIR_end - 2  /* i */
         0D:D2BB  18         			clc
         0D:D2BC  6D 00 23   			adc	__joypad_DIR_end - 2
         0D:D2BF  90 01      			bcc	!+
         0D:D2C1  C8         			iny
         0D:D2C2             	!:
 3720                        		__pusharg.wr
         0D:D2C2  A6 8D      			ldx	<__sp
         0D:D2C4  CA         			dex
         0D:D2C5  CA         			dex
         0D:D2C6  95 08      			sta.l	<__stack, x
         0D:D2C8  94 09      			sty.h	<__stack, x
         0D:D2CA  86 8D      			stx	<__sp
 3721                        		__call		_check_BG
         0D:D2CC  20 81 FF   			call	_check_BG
 3722                        	
 3723                        		.dbg	line,	"include\routines_LEVELS.c", 358; if(map_blk_flag == TILE_LADDER)
 3724                        		__ld.umq	_map_blk_flag
         0D:D2CF  AD E9 29   			lda	_map_blk_flag
 3725                        		__equ_b.uiq	2
         0D:D2D2  C9 02      			cmp	#2
         0D:D2D4  F0 01      			beq	!+
         0D:D2D6  18         			clc
         0D:D2D7             	!:
 3726                        		__bfalse	.LL92
         0D:D2D7  90 1A      			bcc	.LL92
 3727                        	
 3728                        		.dbg	line,	"include\routines_LEVELS.c", 359; {
 3729                        	
 3730                        		.dbg	line,	"include\routines_LEVELS.c", 360; sgx_map_pxl_y += (2 - i);
 3731                        		__ld.wi		2
         0D:D2D9  A9 02      			lda.l	#2
         0D:D2DB  C2         			cly
 3732                        		__sub.um	__joypad_DIR_end - 2  /* i */
         0D:D2DC  38         			sec
         0D:D2DD  ED 00 23   			sbc	__joypad_DIR_end - 2
         0D:D2E0  B0 01      			bcs	!+
         0D:D2E2  88         			dey
         0D:D2E3             	!:
 3733                        		__add_st.wmq	_sgx_map_pxl_y
         0D:D2E3  18         			clc
         0D:D2E4  6D CA 24   			adc.l	_sgx_map_pxl_y
         0D:D2E7  8D CA 24   			sta.l	_sgx_map_pxl_y
         0D:D2EA  98         			tya
         0D:D2EB  6D CB 24   			adc.h	_sgx_map_pxl_y
         0D:D2EE  8D CB 24   			sta.h	_sgx_map_pxl_y
 3734                        	
 3735                        		.dbg	line,	"include\routines_LEVELS.c", 361; break;
 3736                        		__bra		.LL91
         0D:D2F1  80 41      			bra	.LL91
 3737                        	
 3738                        		.dbg	line,	"include\routines_LEVELS.c", 362; }
 3739                        	
 3740                        		.dbg	line,	"include\routines_LEVELS.c", 364; else
 3741    0D:D2F3             	.LL92:
 3742                        	
 3743                        		.dbg	line,	"include\routines_LEVELS.c", 365; {
 3744                        	
 3745                        		.dbg	line,	"include\routines_LEVELS.c", 366; load_vram(PLAYER_VRAM_ADR, tiles_SPR_PLAYER + TILES_224 , TILES_16);
 3746                        		__st.wmiq	6144, _di
         0D:D2F3  64 F0      			stz.l	_di
         0D:D2F5  A9 18      			lda.h	#6144
         0D:D2F7  85 F1      			sta.h	_di
 3747                        		__farptr	_tiles_SPR_PLAYER + 7168 + 512, _bp_bank, _bp
         0D:D2F9  A9 A0      			lda.l	#$6000 + ($1FFF & (_tiles_SPR_PLAYER + 7168 + 512))
         0D:D2FB  85 EC      			sta.l	_bp
         0D:D2FD  A9 78      			lda.h	#$6000 + ($1FFF & (_tiles_SPR_PLAYER + 7168 + 512))
         0D:D2FF  85 ED      			sta.h	_bp
         0D:D301  A9 0C      			lda	#bank(_tiles_SPR_PLAYER + 7168 + 512)
         0D:D303  85 02      			sta	_bp_bank
 3748                        		__st.wmiq	256, _ax
         0D:D305  64 F8      			stz.l	_ax
         0D:D307  A9 01      			lda.h	#256
         0D:D309  85 F9      			sta.h	_ax
 3749                        		 _load_vram.3
         0D:D30B  82         			clx				; Offset to PCE VDC.
         0D:D30C  20 77 FF   			call	load_vram_x
 3750                        	
 3751                        		.dbg	line,	"include\routines_LEVELS.c", 368; jump_ladder = FALSE;
 3752                        		__st.umiq	0, _jump_ladder
         0D:D30F  9C 15 23   			stz	_jump_ladder
 3753                        	
 3754                        		.dbg	line,	"include\routines_LEVELS.c", 369; player_index_jump = 0;
 3755                        		__st.umiq	0, _player_index_jump
         0D:D312  9C 13 23   			stz	_player_index_jump
 3756                        	
 3757                        		.dbg	line,	"include\routines_LEVELS.c", 370; player_index_fall = 0;
 3758                        		__st.umiq	0, _player_index_fall
         0D:D315  9C 14 23   			stz	_player_index_fall
 3759                        	
 3760                        		.dbg	line,	"include\routines_LEVELS.c", 371; player_state = STATE_FALL;
 3761                        		__st.umiq	9, _player_state
         0D:D318  A9 09      			lda.l	#9
         0D:D31A  8D 0F 23   			sta	_player_state
 3762                        	
 3763                        		.dbg	line,	"include\routines_LEVELS.c", 372; }
 3764    0D:D31D             	.LL93	.alias		.LL89
 3765                        	
 3766                        		.dbg	line,	"include\routines_LEVELS.c", 373; }
 3767                        		__bra		.LL89
         0D:D31D  80 87      			bra	.LL89
 3768    0D:D31F             	.LL91	.alias		.LL94
 3769                        	
 3770                        		.dbg	line,	"include\routines_LEVELS.c", 374; }
 3771                        	
 3772                        		.dbg	line,	"include\routines_LEVELS.c", 376; else
 3773                        		__bra		.LL94
         0D:D31F  80 13      			bra	.LL94
 3774    0D:D321             	.LL87:
 3775                        	
 3776                        		.dbg	line,	"include\routines_LEVELS.c", 377; {
 3777                        	
 3778                        		.dbg	line,	"include\routines_LEVELS.c", 378; sgx_map_pxl_y += 2;
 3779                        		__add_st.wmiq	2, _sgx_map_pxl_y
         0D:D321  18         			clc
         0D:D322  AD CA 24   			lda.l	_sgx_map_pxl_y
         0D:D325  69 02      			adc.l	#2
         0D:D327  8D CA 24   			sta.l	_sgx_map_pxl_y
         0D:D32A  90 03      			bcc	!+
         0D:D32C  EE CB 24   			inc.h	_sgx_map_pxl_y
         0D:D32F             	!:
 3780                        	
 3781                        		.dbg	line,	"include\routines_LEVELS.c", 379; player_state = STATE_CLIMB_DOWN;
 3782                        		__st.umiq	12, _player_state
         0D:D32F  A9 0C      			lda.l	#12
         0D:D331  8D 0F 23   			sta	_player_state
 3783                        	
 3784                        		.dbg	line,	"include\routines_LEVELS.c", 380; }
 3785    0D:D334             	.LL94:
 3786                        	
 3787                        		.dbg	line,	"include\routines_LEVELS.c", 381; }
 3788                        	
 3789                        		.dbg	line,	"include\routines_LEVELS.c", 382; }
 3790    0D:D334             	.LL84:
 3791    0D:D334             	.LL83:
 3792                        	
 3793                        		.dbg	line,	"include\routines_LEVELS.c", 383; }
 3794    0D:D334             	.LL80:
 3795    0D:D334             	.LL79:
 3796    0D:D334             	.LL67:
 3797    0D:D334             	.LL51:
 3798    0D:D334             	.LL29:
 3799                        		__return	0
         0D:D334  4C EF FF   			jmp	leave_proc
 3800                        		.dbg	clear
 3801                        		.endp
 3802               6F20     		.data
 3803               2300     		.bss
 3804    F8:2300             	__joypad_DIR_loc:
 3805    F8:2300             			ds	2
 3806    F8:2302             	__joypad_DIR_end:
 3807               E309     		.code
 3808                        		.pceas
 3809                        	
 3810                        		.dbg	line,	"include\routines_LEVELS.c", 392; void update_PLAYER()
 3811                        		.dbg	line,	"include\routines_LEVELS.c", 393; {
 3812                        	;***********************
 3813                        	;***********************
 3814                        	
 3815                        		.hucc
 3816    01:C0F0             		.proc		_update_PLAYER
 3817                        		__enter		_update_PLAYER
 3818                        	
 3819                        		.dbg	line,	"include\routines_LEVELS.c", 394; if(player_state == STATE_IDLE)
 3820                        		__not.um	_player_state
         01:C0F0  AD 0F 23   			lda	_player_state
         01:C0F3  18         			clc
         01:C0F4  D0 01      			bne	!+
         01:C0F6  38         			sec
         01:C0F7             	!:
 3821                        		__bfalse	.LL96
         01:C0F7  B0 03 4C A7			bcc	.LL96
         01:C0FB  C1          
 3822                        	
 3823                        		.dbg	line,	"include\routines_LEVELS.c", 395; {
 3824                        	
 3825                        		.dbg	line,	"include\routines_LEVELS.c", 396; if(player_counter_anim == 1)
 3826                        		__ld.umq	_player_counter_anim
         01:C0FC  AD 12 23   			lda	_player_counter_anim
 3827                        		__equ_b.uiq	1
         01:C0FF  C9 01      			cmp	#1
         01:C101  F0 01      			beq	!+
         01:C103  18         			clc
         01:C104             	!:
 3828                        		__bfalse	.LL97
         01:C104  90 1F      			bcc	.LL97
 3829                        	
 3830                        		.dbg	line,	"include\routines_LEVELS.c", 397; {
 3831                        	
 3832                        		.dbg	line,	"include\routines_LEVELS.c", 398; load_vram(PLAYER_VRAM_ADR, tiles_SPR_PLAYER , TILES_16);
 3833                        		__st.wmiq	6144, _di
         01:C106  64 F0      			stz.l	_di
         01:C108  A9 18      			lda.h	#6144
         01:C10A  85 F1      			sta.h	_di
 3834                        		__farptr	_tiles_SPR_PLAYER, _bp_bank, _bp
         01:C10C  A9 A0      			lda.l	#$6000 + ($1FFF & (_tiles_SPR_PLAYER))
         01:C10E  85 EC      			sta.l	_bp
         01:C110  A9 7A      			lda.h	#$6000 + ($1FFF & (_tiles_SPR_PLAYER))
         01:C112  85 ED      			sta.h	_bp
         01:C114  A9 0B      			lda	#bank(_tiles_SPR_PLAYER)
         01:C116  85 02      			sta	_bp_bank
 3835                        		__st.wmiq	256, _ax
         01:C118  64 F8      			stz.l	_ax
         01:C11A  A9 01      			lda.h	#256
         01:C11C  85 F9      			sta.h	_ax
 3836                        		 _load_vram.3
         01:C11E  82         			clx				; Offset to PCE VDC.
         01:C11F  20 77 FF   			call	load_vram_x
 3837                        	
 3838                        		.dbg	line,	"include\routines_LEVELS.c", 400; player_counter_anim = 0;
 3839                        		__st.umiq	0, _player_counter_anim
         01:C122  9C 12 23   			stz	_player_counter_anim
 3840                        	
 3841                        		.dbg	line,	"include\routines_LEVELS.c", 401; }
 3842                        	
 3843                        		.dbg	line,	"include\routines_LEVELS.c", 403; recenter_CAMERA();
 3844    01:C125             	.LL97:
 3845                        		__call		_recenter_CAMERA
         01:C125  20 6D FF   			call	_recenter_CAMERA
 3846                        	
 3847                        		.dbg	line,	"include\routines_LEVELS.c", 406; // CHECK COLLISION WITH LEFT FLOOR //
 3848                        	
 3849                        		.dbg	line,	"include\routines_LEVELS.c", 407; check_BG( 10 , 32 );//8
 3850                        		__ld.wi		10
         01:C128  A9 0A      			lda.l	#10
         01:C12A  C2         			cly
 3851                        		__pusharg.wr
         01:C12B  A6 8D      			ldx	<__sp
         01:C12D  CA         			dex
         01:C12E  CA         			dex
         01:C12F  95 08      			sta.l	<__stack, x
         01:C131  94 09      			sty.h	<__stack, x
         01:C133  86 8D      			stx	<__sp
 3852                        		__ld.wi		32
         01:C135  A9 20      			lda.l	#32
         01:C137  C2         			cly
 3853                        		__pusharg.wr
         01:C138  A6 8D      			ldx	<__sp
         01:C13A  CA         			dex
         01:C13B  CA         			dex
         01:C13C  95 08      			sta.l	<__stack, x
         01:C13E  94 09      			sty.h	<__stack, x
         01:C140  86 8D      			stx	<__sp
 3854                        		__call		_check_BG
         01:C142  20 81 FF   			call	_check_BG
 3855                        	
 3856                        		.dbg	line,	"include\routines_LEVELS.c", 409; if(map_blk_flag == TILE_EMPTY)
 3857                        		__not.um	_map_blk_flag
         01:C145  AD E9 29   			lda	_map_blk_flag
         01:C148  18         			clc
         01:C149  D0 01      			bne	!+
         01:C14B  38         			sec
         01:C14C             	!:
 3858                        		__bfalse	.LL98
         01:C14C  B0 03 4C 09			bcc	.LL98
         01:C150  D6          
 3859                        	
 3860                        		.dbg	line,	"include\routines_LEVELS.c", 410; {
 3861                        	
 3862                        		.dbg	line,	"include\routines_LEVELS.c", 411; // CHECK COLLISION WITH RIGHT FLOOR //
 3863                        	
 3864                        		.dbg	line,	"include\routines_LEVELS.c", 412; check_BG( 22 , 32 );//24
 3865                        		__ld.wi		22
         01:C151  A9 16      			lda.l	#22
         01:C153  C2         			cly
 3866                        		__pusharg.wr
         01:C154  A6 8D      			ldx	<__sp
         01:C156  CA         			dex
         01:C157  CA         			dex
         01:C158  95 08      			sta.l	<__stack, x
         01:C15A  94 09      			sty.h	<__stack, x
         01:C15C  86 8D      			stx	<__sp
 3867                        		__ld.wi		32
         01:C15E  A9 20      			lda.l	#32
         01:C160  C2         			cly
 3868                        		__pusharg.wr
         01:C161  A6 8D      			ldx	<__sp
         01:C163  CA         			dex
         01:C164  CA         			dex
         01:C165  95 08      			sta.l	<__stack, x
         01:C167  94 09      			sty.h	<__stack, x
         01:C169  86 8D      			stx	<__sp
 3869                        		__call		_check_BG
         01:C16B  20 81 FF   			call	_check_BG
 3870                        	
 3871                        		.dbg	line,	"include\routines_LEVELS.c", 414; if(map_blk_flag == TILE_EMPTY)
 3872                        		__not.um	_map_blk_flag
         01:C16E  AD E9 29   			lda	_map_blk_flag
         01:C171  18         			clc
         01:C172  D0 01      			bne	!+
         01:C174  38         			sec
         01:C175             	!:
 3873                        		__bfalse	.LL99
         01:C175  B0 03 4C 09			bcc	.LL99
         01:C179  D6          
 3874                        	
 3875                        		.dbg	line,	"include\routines_LEVELS.c", 415; {
 3876                        	
 3877                        		.dbg	line,	"include\routines_LEVELS.c", 416; load_vram(PLAYER_VRAM_ADR, tiles_SPR_PLAYER , TILES_16);
 3878                        		__st.wmiq	6144, _di
         01:C17A  64 F0      			stz.l	_di
         01:C17C  A9 18      			lda.h	#6144
         01:C17E  85 F1      			sta.h	_di
 3879                        		__farptr	_tiles_SPR_PLAYER, _bp_bank, _bp
         01:C180  A9 A0      			lda.l	#$6000 + ($1FFF & (_tiles_SPR_PLAYER))
         01:C182  85 EC      			sta.l	_bp
         01:C184  A9 7A      			lda.h	#$6000 + ($1FFF & (_tiles_SPR_PLAYER))
         01:C186  85 ED      			sta.h	_bp
         01:C188  A9 0B      			lda	#bank(_tiles_SPR_PLAYER)
         01:C18A  85 02      			sta	_bp_bank
 3880                        		__st.wmiq	256, _ax
         01:C18C  64 F8      			stz.l	_ax
         01:C18E  A9 01      			lda.h	#256
         01:C190  85 F9      			sta.h	_ax
 3881                        		 _load_vram.3
         01:C192  82         			clx				; Offset to PCE VDC.
         01:C193  20 77 FF   			call	load_vram_x
 3882                        	
 3883                        		.dbg	line,	"include\routines_LEVELS.c", 418; jump_ladder = FALSE;
 3884                        		__st.umiq	0, _jump_ladder
         01:C196  9C 15 23   			stz	_jump_ladder
 3885                        	
 3886                        		.dbg	line,	"include\routines_LEVELS.c", 419; player_index_jump = 0;
 3887                        		__st.umiq	0, _player_index_jump
         01:C199  9C 13 23   			stz	_player_index_jump
 3888                        	
 3889                        		.dbg	line,	"include\routines_LEVELS.c", 420; player_index_fall = 0;
 3890                        		__st.umiq	0, _player_index_fall
         01:C19C  9C 14 23   			stz	_player_index_fall
 3891                        	
 3892                        		.dbg	line,	"include\routines_LEVELS.c", 421; player_state = STATE_FALL;
 3893                        		__st.umiq	9, _player_state
         01:C19F  A9 09      			lda.l	#9
         01:C1A1  8D 0F 23   			sta	_player_state
 3894                        	
 3895                        		.dbg	line,	"include\routines_LEVELS.c", 422; }
 3896                        	
 3897                        		.dbg	line,	"include\routines_LEVELS.c", 423; }
 3898    01:C1A4             	.LL99	.alias		.LL100
 3899                        	
 3900                        		.dbg	line,	"include\routines_LEVELS.c", 424; }
 3901    01:C1A4             	.LL98	.alias		.LL100
 3902                        	
 3903                        		.dbg	line,	"include\routines_LEVELS.c", 427; else if(player_state == STATE_WALK)
 3904                        		__bra		.LL100
         01:C1A4  4C 09 D6   			bra	.LL100
 3905    01:C1A7             	.LL96:
 3906                        		__ld.umq	_player_state
         01:C1A7  AD 0F 23   			lda	_player_state
 3907                        		__equ_b.uiq	1
         01:C1AA  C9 01      			cmp	#1
         01:C1AC  F0 01      			beq	!+
         01:C1AE  18         			clc
         01:C1AF             	!:
 3908                        		__bfalse	.LL101
         01:C1AF  B0 03 4C 82			bcc	.LL101
         01:C1B3  C4          
 3909                        	
 3910                        		.dbg	line,	"include\routines_LEVELS.c", 428; {
 3911                        	
 3912                        		.dbg	line,	"include\routines_LEVELS.c", 429; recenter_CAMERA();
 3913                        		__call		_recenter_CAMERA
         01:C1B4  20 6D FF   			call	_recenter_CAMERA
 3914                        	
 3915                        		.dbg	line,	"include\routines_LEVELS.c", 432; //--------------------------------------------------------------------------------------//
 3916                        	
 3917                        		.dbg	line,	"include\routines_LEVELS.c", 433; //                                   FLOOR COLLISION                                    //
 3918                        	
 3919                        		.dbg	line,	"include\routines_LEVELS.c", 434; //--------------------------------------------------------------------------------------//
 3920                        	
 3921                        		.dbg	line,	"include\routines_LEVELS.c", 436; // CHECK COLLISION WITH LEFT FLOOR //
 3922                        	
 3923                        		.dbg	line,	"include\routines_LEVELS.c", 437; check_BG( 10 , 32 );//8
 3924                        		__ld.wi		10
         01:C1B7  A9 0A      			lda.l	#10
         01:C1B9  C2         			cly
 3925                        		__pusharg.wr
         01:C1BA  A6 8D      			ldx	<__sp
         01:C1BC  CA         			dex
         01:C1BD  CA         			dex
         01:C1BE  95 08      			sta.l	<__stack, x
         01:C1C0  94 09      			sty.h	<__stack, x
         01:C1C2  86 8D      			stx	<__sp
 3926                        		__ld.wi		32
         01:C1C4  A9 20      			lda.l	#32
         01:C1C6  C2         			cly
 3927                        		__pusharg.wr
         01:C1C7  A6 8D      			ldx	<__sp
         01:C1C9  CA         			dex
         01:C1CA  CA         			dex
         01:C1CB  95 08      			sta.l	<__stack, x
         01:C1CD  94 09      			sty.h	<__stack, x
         01:C1CF  86 8D      			stx	<__sp
 3928                        		__call		_check_BG
         01:C1D1  20 81 FF   			call	_check_BG
 3929                        	
 3930                        		.dbg	line,	"include\routines_LEVELS.c", 439; if(map_blk_flag == TILE_EMPTY)
 3931                        		__not.um	_map_blk_flag
         01:C1D4  AD E9 29   			lda	_map_blk_flag
         01:C1D7  18         			clc
         01:C1D8  D0 01      			bne	!+
         01:C1DA  38         			sec
         01:C1DB             	!:
 3932                        		__bfalse	.LL102
         01:C1DB  B0 03 4C AF			bcc	.LL102
         01:C1DF  C2          
 3933                        	
 3934                        		.dbg	line,	"include\routines_LEVELS.c", 440; {
 3935                        	
 3936                        		.dbg	line,	"include\routines_LEVELS.c", 441; // CHECK COLLISION WITH RIGHT FLOOR //
 3937                        	
 3938                        		.dbg	line,	"include\routines_LEVELS.c", 442; check_BG( 22 , 32 );//24
 3939                        		__ld.wi		22
         01:C1E0  A9 16      			lda.l	#22
         01:C1E2  C2         			cly
 3940                        		__pusharg.wr
         01:C1E3  A6 8D      			ldx	<__sp
         01:C1E5  CA         			dex
         01:C1E6  CA         			dex
         01:C1E7  95 08      			sta.l	<__stack, x
         01:C1E9  94 09      			sty.h	<__stack, x
         01:C1EB  86 8D      			stx	<__sp
 3941                        		__ld.wi		32
         01:C1ED  A9 20      			lda.l	#32
         01:C1EF  C2         			cly
 3942                        		__pusharg.wr
         01:C1F0  A6 8D      			ldx	<__sp
         01:C1F2  CA         			dex
         01:C1F3  CA         			dex
         01:C1F4  95 08      			sta.l	<__stack, x
         01:C1F6  94 09      			sty.h	<__stack, x
         01:C1F8  86 8D      			stx	<__sp
 3943                        		__call		_check_BG
         01:C1FA  20 81 FF   			call	_check_BG
 3944                        	
 3945                        		.dbg	line,	"include\routines_LEVELS.c", 444; if(map_blk_flag == TILE_EMPTY)
 3946                        		__not.um	_map_blk_flag
         01:C1FD  AD E9 29   			lda	_map_blk_flag
         01:C200  18         			clc
         01:C201  D0 01      			bne	!+
         01:C203  38         			sec
         01:C204             	!:
 3947                        		__bfalse	.LL103
         01:C204  90 2D      			bcc	.LL103
 3948                        	
 3949                        		.dbg	line,	"include\routines_LEVELS.c", 445; {
 3950                        	
 3951                        		.dbg	line,	"include\routines_LEVELS.c", 446; load_vram(PLAYER_VRAM_ADR, tiles_SPR_PLAYER , TILES_16);
 3952                        		__st.wmiq	6144, _di
         01:C206  64 F0      			stz.l	_di
         01:C208  A9 18      			lda.h	#6144
         01:C20A  85 F1      			sta.h	_di
 3953                        		__farptr	_tiles_SPR_PLAYER, _bp_bank, _bp
         01:C20C  A9 A0      			lda.l	#$6000 + ($1FFF & (_tiles_SPR_PLAYER))
         01:C20E  85 EC      			sta.l	_bp
         01:C210  A9 7A      			lda.h	#$6000 + ($1FFF & (_tiles_SPR_PLAYER))
         01:C212  85 ED      			sta.h	_bp
         01:C214  A9 0B      			lda	#bank(_tiles_SPR_PLAYER)
         01:C216  85 02      			sta	_bp_bank
 3954                        		__st.wmiq	256, _ax
         01:C218  64 F8      			stz.l	_ax
         01:C21A  A9 01      			lda.h	#256
         01:C21C  85 F9      			sta.h	_ax
 3955                        		 _load_vram.3
         01:C21E  82         			clx				; Offset to PCE VDC.
         01:C21F  20 77 FF   			call	load_vram_x
 3956                        	
 3957                        		.dbg	line,	"include\routines_LEVELS.c", 448; jump_ladder = FALSE;
 3958                        		__st.umiq	0, _jump_ladder
         01:C222  9C 15 23   			stz	_jump_ladder
 3959                        	
 3960                        		.dbg	line,	"include\routines_LEVELS.c", 449; player_index_jump = 0;
 3961                        		__st.umiq	0, _player_index_jump
         01:C225  9C 13 23   			stz	_player_index_jump
 3962                        	
 3963                        		.dbg	line,	"include\routines_LEVELS.c", 450; player_index_fall = 0;
 3964                        		__st.umiq	0, _player_index_fall
         01:C228  9C 14 23   			stz	_player_index_fall
 3965                        	
 3966                        		.dbg	line,	"include\routines_LEVELS.c", 451; player_state = STATE_FALL;
 3967                        		__st.umiq	9, _player_state
         01:C22B  A9 09      			lda.l	#9
         01:C22D  8D 0F 23   			sta	_player_state
 3968                        	
 3969                        		.dbg	line,	"include\routines_LEVELS.c", 452; }
 3970                        	
 3971                        		.dbg	line,	"include\routines_LEVELS.c", 454; else
 3972                        		__bra		.LL104
         01:C230  4C 22 C3   			bra	.LL104
 3973    01:C233             	.LL103:
 3974                        	
 3975                        		.dbg	line,	"include\routines_LEVELS.c", 455; {
 3976                        	
 3977                        		.dbg	line,	"include\routines_LEVELS.c", 456; if(player_axis == AXIS_RIGHT)
 3978                        		__not.um	_player_axis
         01:C233  AD 10 23   			lda	_player_axis
         01:C236  18         			clc
         01:C237  D0 01      			bne	!+
         01:C239  38         			sec
         01:C23A             	!:
 3979                        		__bfalse	.LL105
         01:C23A  90 3A      			bcc	.LL105
 3980                        	
 3981                        		.dbg	line,	"include\routines_LEVELS.c", 457; {
 3982                        	
 3983                        		.dbg	line,	"include\routines_LEVELS.c", 458; // CHECK COLLISION WITH RIGHT WALL //
 3984                        	
 3985                        		.dbg	line,	"include\routines_LEVELS.c", 459; check_BG( 24 , 31 ); // 24+2
 3986                        		__ld.wi		24
         01:C23C  A9 18      			lda.l	#24
         01:C23E  C2         			cly
 3987                        		__pusharg.wr
         01:C23F  A6 8D      			ldx	<__sp
         01:C241  CA         			dex
         01:C242  CA         			dex
         01:C243  95 08      			sta.l	<__stack, x
         01:C245  94 09      			sty.h	<__stack, x
         01:C247  86 8D      			stx	<__sp
 3988                        		__ld.wi		31
         01:C249  A9 1F      			lda.l	#31
         01:C24B  C2         			cly
 3989                        		__pusharg.wr
         01:C24C  A6 8D      			ldx	<__sp
         01:C24E  CA         			dex
         01:C24F  CA         			dex
         01:C250  95 08      			sta.l	<__stack, x
         01:C252  94 09      			sty.h	<__stack, x
         01:C254  86 8D      			stx	<__sp
 3990                        		__call		_check_BG
         01:C256  20 81 FF   			call	_check_BG
 3991                        	
 3992                        		.dbg	line,	"include\routines_LEVELS.c", 461; if(map_blk_flag == TILE_EMPTY)
 3993                        		__not.um	_map_blk_flag
         01:C259  AD E9 29   			lda	_map_blk_flag
         01:C25C  18         			clc
         01:C25D  D0 01      			bne	!+
         01:C25F  38         			sec
         01:C260             	!:
 3994                        		__bfalse	.LL106
         01:C260  B0 03 4C 22			bcc	.LL106
         01:C264  C3          
 3995                        	
 3996                        		.dbg	line,	"include\routines_LEVELS.c", 462; {
 3997                        	
 3998                        		.dbg	line,	"include\routines_LEVELS.c", 463; sgx_map_pxl_x += 2;
 3999                        		__add_st.wmiq	2, _sgx_map_pxl_x
         01:C265  18         			clc
         01:C266  AD C8 24   			lda.l	_sgx_map_pxl_x
         01:C269  69 02      			adc.l	#2
         01:C26B  8D C8 24   			sta.l	_sgx_map_pxl_x
         01:C26E  90 03      			bcc	!+
         01:C270  EE C9 24   			inc.h	_sgx_map_pxl_x
         01:C273             	!:
 4000                        	
 4001                        		.dbg	line,	"include\routines_LEVELS.c", 464; }
 4002                        	
 4003                        		.dbg	line,	"include\routines_LEVELS.c", 465; }
 4004    01:C273             	.LL106	.alias		.LL107
 4005                        	
 4006                        		.dbg	line,	"include\routines_LEVELS.c", 467; else
 4007                        		__bra		.LL107
         01:C273  4C 22 C3   			bra	.LL107
 4008    01:C276             	.LL105:
 4009                        	
 4010                        		.dbg	line,	"include\routines_LEVELS.c", 468; {
 4011                        	
 4012                        		.dbg	line,	"include\routines_LEVELS.c", 469; // CHECK COLLISION WITH LEFT WALL //
 4013                        	
 4014                        		.dbg	line,	"include\routines_LEVELS.c", 470; check_BG( 8 , 31 ); // 8-2
 4015                        		__ld.wi		8
         01:C276  A9 08      			lda.l	#8
         01:C278  C2         			cly
 4016                        		__pusharg.wr
         01:C279  A6 8D      			ldx	<__sp
         01:C27B  CA         			dex
         01:C27C  CA         			dex
         01:C27D  95 08      			sta.l	<__stack, x
         01:C27F  94 09      			sty.h	<__stack, x
         01:C281  86 8D      			stx	<__sp
 4017                        		__ld.wi		31
         01:C283  A9 1F      			lda.l	#31
         01:C285  C2         			cly
 4018                        		__pusharg.wr
         01:C286  A6 8D      			ldx	<__sp
         01:C288  CA         			dex
         01:C289  CA         			dex
         01:C28A  95 08      			sta.l	<__stack, x
         01:C28C  94 09      			sty.h	<__stack, x
         01:C28E  86 8D      			stx	<__sp
 4019                        		__call		_check_BG
         01:C290  20 81 FF   			call	_check_BG
 4020                        	
 4021                        		.dbg	line,	"include\routines_LEVELS.c", 472; if(map_blk_flag == TILE_EMPTY)
 4022                        		__not.um	_map_blk_flag
         01:C293  AD E9 29   			lda	_map_blk_flag
         01:C296  18         			clc
         01:C297  D0 01      			bne	!+
         01:C299  38         			sec
         01:C29A             	!:
 4023                        		__bfalse	.LL108
         01:C29A  B0 03 4C 22			bcc	.LL108
         01:C29E  C3          
 4024                        	
 4025                        		.dbg	line,	"include\routines_LEVELS.c", 473; {
 4026                        	
 4027                        		.dbg	line,	"include\routines_LEVELS.c", 474; sgx_map_pxl_x -= 2;
 4028                        		__sub_st.wmiq	2, _sgx_map_pxl_x
         01:C29F  38         			sec
         01:C2A0  AD C8 24   			lda.l	_sgx_map_pxl_x
         01:C2A3  E9 02      			sbc.l	#2
         01:C2A5  8D C8 24   			sta.l	_sgx_map_pxl_x
         01:C2A8  B0 03      			bcs	!+
         01:C2AA  CE C9 24   			dec.h	_sgx_map_pxl_x
         01:C2AD             	!:
 4029                        	
 4030                        		.dbg	line,	"include\routines_LEVELS.c", 475; }
 4031                        	
 4032                        		.dbg	line,	"include\routines_LEVELS.c", 476; }
 4033    01:C2AD             	.LL108	.alias		.LL109
 4034    01:C2AD             	.LL107	.alias		.LL109
 4035                        	
 4036                        		.dbg	line,	"include\routines_LEVELS.c", 477; }
 4037    01:C2AD             	.LL104	.alias		.LL109
 4038                        	
 4039                        		.dbg	line,	"include\routines_LEVELS.c", 478; }
 4040                        	
 4041                        		.dbg	line,	"include\routines_LEVELS.c", 480; else
 4042                        		__bra		.LL109
         01:C2AD  80 73      			bra	.LL109
 4043    01:C2AF             	.LL102:
 4044                        	
 4045                        		.dbg	line,	"include\routines_LEVELS.c", 481; {
 4046                        	
 4047                        		.dbg	line,	"include\routines_LEVELS.c", 482; if(player_axis == AXIS_RIGHT)
 4048                        		__not.um	_player_axis
         01:C2AF  AD 10 23   			lda	_player_axis
         01:C2B2  18         			clc
         01:C2B3  D0 01      			bne	!+
         01:C2B5  38         			sec
         01:C2B6             	!:
 4049                        		__bfalse	.LL110
         01:C2B6  90 36      			bcc	.LL110
 4050                        	
 4051                        		.dbg	line,	"include\routines_LEVELS.c", 483; {
 4052                        	
 4053                        		.dbg	line,	"include\routines_LEVELS.c", 484; // CHECK COLLISION WITH RIGHT WALL //
 4054                        	
 4055                        		.dbg	line,	"include\routines_LEVELS.c", 485; check_BG( 24 , 31 ); // 24+2
 4056                        		__ld.wi		24
         01:C2B8  A9 18      			lda.l	#24
         01:C2BA  C2         			cly
 4057                        		__pusharg.wr
         01:C2BB  A6 8D      			ldx	<__sp
         01:C2BD  CA         			dex
         01:C2BE  CA         			dex
         01:C2BF  95 08      			sta.l	<__stack, x
         01:C2C1  94 09      			sty.h	<__stack, x
         01:C2C3  86 8D      			stx	<__sp
 4058                        		__ld.wi		31
         01:C2C5  A9 1F      			lda.l	#31
         01:C2C7  C2         			cly
 4059                        		__pusharg.wr
         01:C2C8  A6 8D      			ldx	<__sp
         01:C2CA  CA         			dex
         01:C2CB  CA         			dex
         01:C2CC  95 08      			sta.l	<__stack, x
         01:C2CE  94 09      			sty.h	<__stack, x
         01:C2D0  86 8D      			stx	<__sp
 4060                        		__call		_check_BG
         01:C2D2  20 81 FF   			call	_check_BG
 4061                        	
 4062                        		.dbg	line,	"include\routines_LEVELS.c", 487; if(map_blk_flag == TILE_EMPTY)
 4063                        		__not.um	_map_blk_flag
         01:C2D5  AD E9 29   			lda	_map_blk_flag
         01:C2D8  18         			clc
         01:C2D9  D0 01      			bne	!+
         01:C2DB  38         			sec
         01:C2DC             	!:
 4064                        		__bfalse	.LL111
         01:C2DC  90 44      			bcc	.LL111
 4065                        	
 4066                        		.dbg	line,	"include\routines_LEVELS.c", 488; {
 4067                        	
 4068                        		.dbg	line,	"include\routines_LEVELS.c", 489; sgx_map_pxl_x += 2;
 4069                        		__add_st.wmiq	2, _sgx_map_pxl_x
         01:C2DE  18         			clc
         01:C2DF  AD C8 24   			lda.l	_sgx_map_pxl_x
         01:C2E2  69 02      			adc.l	#2
         01:C2E4  8D C8 24   			sta.l	_sgx_map_pxl_x
         01:C2E7  90 03      			bcc	!+
         01:C2E9  EE C9 24   			inc.h	_sgx_map_pxl_x
         01:C2EC             	!:
 4070                        	
 4071                        		.dbg	line,	"include\routines_LEVELS.c", 490; }
 4072                        	
 4073                        		.dbg	line,	"include\routines_LEVELS.c", 491; }
 4074    01:C2EC             	.LL111	.alias		.LL112
 4075                        	
 4076                        		.dbg	line,	"include\routines_LEVELS.c", 493; else
 4077                        		__bra		.LL112
         01:C2EC  80 34      			bra	.LL112
 4078    01:C2EE             	.LL110:
 4079                        	
 4080                        		.dbg	line,	"include\routines_LEVELS.c", 494; {
 4081                        	
 4082                        		.dbg	line,	"include\routines_LEVELS.c", 495; // CHECK COLLISION WITH LEFT WALL //
 4083                        	
 4084                        		.dbg	line,	"include\routines_LEVELS.c", 496; check_BG( 8 , 31 ); // 8-2
 4085                        		__ld.wi		8
         01:C2EE  A9 08      			lda.l	#8
         01:C2F0  C2         			cly
 4086                        		__pusharg.wr
         01:C2F1  A6 8D      			ldx	<__sp
         01:C2F3  CA         			dex
         01:C2F4  CA         			dex
         01:C2F5  95 08      			sta.l	<__stack, x
         01:C2F7  94 09      			sty.h	<__stack, x
         01:C2F9  86 8D      			stx	<__sp
 4087                        		__ld.wi		31
         01:C2FB  A9 1F      			lda.l	#31
         01:C2FD  C2         			cly
 4088                        		__pusharg.wr
         01:C2FE  A6 8D      			ldx	<__sp
         01:C300  CA         			dex
         01:C301  CA         			dex
         01:C302  95 08      			sta.l	<__stack, x
         01:C304  94 09      			sty.h	<__stack, x
         01:C306  86 8D      			stx	<__sp
 4089                        		__call		_check_BG
         01:C308  20 81 FF   			call	_check_BG
 4090                        	
 4091                        		.dbg	line,	"include\routines_LEVELS.c", 498; if(map_blk_flag == TILE_EMPTY)
 4092                        		__not.um	_map_blk_flag
         01:C30B  AD E9 29   			lda	_map_blk_flag
         01:C30E  18         			clc
         01:C30F  D0 01      			bne	!+
         01:C311  38         			sec
         01:C312             	!:
 4093                        		__bfalse	.LL113
         01:C312  90 0E      			bcc	.LL113
 4094                        	
 4095                        		.dbg	line,	"include\routines_LEVELS.c", 499; {
 4096                        	
 4097                        		.dbg	line,	"include\routines_LEVELS.c", 500; sgx_map_pxl_x -= 2;
 4098                        		__sub_st.wmiq	2, _sgx_map_pxl_x
         01:C314  38         			sec
         01:C315  AD C8 24   			lda.l	_sgx_map_pxl_x
         01:C318  E9 02      			sbc.l	#2
         01:C31A  8D C8 24   			sta.l	_sgx_map_pxl_x
         01:C31D  B0 03      			bcs	!+
         01:C31F  CE C9 24   			dec.h	_sgx_map_pxl_x
         01:C322             	!:
 4099                        	
 4100                        		.dbg	line,	"include\routines_LEVELS.c", 501; }
 4101                        	
 4102                        		.dbg	line,	"include\routines_LEVELS.c", 502; }
 4103    01:C322             	.LL113:
 4104    01:C322             	.LL112:
 4105                        	
 4106                        		.dbg	line,	"include\routines_LEVELS.c", 503; }
 4107    01:C322             	.LL109:
 4108                        	
 4109                        		.dbg	line,	"include\routines_LEVELS.c", 508; spr_set(player_id);
 4110                        		__ld.umq	_player_id
         01:C322  AD 0E 23   			lda	_player_id
 4111                        		__call		_spr_set.1
         01:C325  20 DD E7   			call	_spr_set.1
 4112                        	
 4113                        		.dbg	line,	"include\routines_LEVELS.c", 511; // UPDATE PLAYER TILES //
 4114                        	
 4115                        		.dbg	line,	"include\routines_LEVELS.c", 512; if(player_counter_anim == 0)
 4116                        		__not.um	_player_counter_anim
         01:C328  AD 12 23   			lda	_player_counter_anim
         01:C32B  18         			clc
         01:C32C  D0 01      			bne	!+
         01:C32E  38         			sec
         01:C32F             	!:
 4117                        		__bfalse	.LL114
         01:C32F  90 1F      			bcc	.LL114
 4118                        	
 4119                        		.dbg	line,	"include\routines_LEVELS.c", 513; {
 4120                        	
 4121                        		.dbg	line,	"include\routines_LEVELS.c", 514; load_vram(PLAYER_VRAM_ADR, tiles_SPR_PLAYER , TILES_16);
 4122                        		__st.wmiq	6144, _di
         01:C331  64 F0      			stz.l	_di
         01:C333  A9 18      			lda.h	#6144
         01:C335  85 F1      			sta.h	_di
 4123                        		__farptr	_tiles_SPR_PLAYER, _bp_bank, _bp
         01:C337  A9 A0      			lda.l	#$6000 + ($1FFF & (_tiles_SPR_PLAYER))
         01:C339  85 EC      			sta.l	_bp
         01:C33B  A9 7A      			lda.h	#$6000 + ($1FFF & (_tiles_SPR_PLAYER))
         01:C33D  85 ED      			sta.h	_bp
         01:C33F  A9 0B      			lda	#bank(_tiles_SPR_PLAYER)
         01:C341  85 02      			sta	_bp_bank
 4124                        		__st.wmiq	256, _ax
         01:C343  64 F8      			stz.l	_ax
         01:C345  A9 01      			lda.h	#256
         01:C347  85 F9      			sta.h	_ax
 4125                        		 _load_vram.3
         01:C349  82         			clx				; Offset to PCE VDC.
         01:C34A  20 77 FF   			call	load_vram_x
 4126                        	
 4127                        		.dbg	line,	"include\routines_LEVELS.c", 515; }
 4128                        	
 4129                        		.dbg	line,	"include\routines_LEVELS.c", 518; else if(player_counter_anim == 2)
 4130                        		__bra		.LL115
         01:C34D  4C 7C C4   			bra	.LL115
 4131    01:C350             	.LL114:
 4132                        		__ld.umq	_player_counter_anim
         01:C350  AD 12 23   			lda	_player_counter_anim
 4133                        		__equ_b.uiq	2
         01:C353  C9 02      			cmp	#2
         01:C355  F0 01      			beq	!+
         01:C357  18         			clc
         01:C358             	!:
 4134                        		__bfalse	.LL116
         01:C358  90 1F      			bcc	.LL116
 4135                        	
 4136                        		.dbg	line,	"include\routines_LEVELS.c", 519; {
 4137                        	
 4138                        		.dbg	line,	"include\routines_LEVELS.c", 520; load_vram(PLAYER_VRAM_ADR, tiles_SPR_PLAYER + OFFSET_PLAYER_WALK_1 , TILES_16);
 4139                        		__st.wmiq	6144, _di
         01:C35A  64 F0      			stz.l	_di
         01:C35C  A9 18      			lda.h	#6144
         01:C35E  85 F1      			sta.h	_di
 4140                        		__farptr	_tiles_SPR_PLAYER + 512, _bp_bank, _bp
         01:C360  A9 A0      			lda.l	#$6000 + ($1FFF & (_tiles_SPR_PLAYER + 512))
         01:C362  85 EC      			sta.l	_bp
         01:C364  A9 7C      			lda.h	#$6000 + ($1FFF & (_tiles_SPR_PLAYER + 512))
         01:C366  85 ED      			sta.h	_bp
         01:C368  A9 0B      			lda	#bank(_tiles_SPR_PLAYER + 512)
         01:C36A  85 02      			sta	_bp_bank
 4141                        		__st.wmiq	256, _ax
         01:C36C  64 F8      			stz.l	_ax
         01:C36E  A9 01      			lda.h	#256
         01:C370  85 F9      			sta.h	_ax
 4142                        		 _load_vram.3
         01:C372  82         			clx				; Offset to PCE VDC.
         01:C373  20 77 FF   			call	load_vram_x
 4143                        	
 4144                        		.dbg	line,	"include\routines_LEVELS.c", 521; }
 4145                        	
 4146                        		.dbg	line,	"include\routines_LEVELS.c", 524; else if(player_counter_anim == 5)
 4147                        		__bra		.LL117
         01:C376  4C 7C C4   			bra	.LL117
 4148    01:C379             	.LL116:
 4149                        		__ld.umq	_player_counter_anim
         01:C379  AD 12 23   			lda	_player_counter_anim
 4150                        		__equ_b.uiq	5
         01:C37C  C9 05      			cmp	#5
         01:C37E  F0 01      			beq	!+
         01:C380  18         			clc
         01:C381             	!:
 4151                        		__bfalse	.LL118
         01:C381  90 1F      			bcc	.LL118
 4152                        	
 4153                        		.dbg	line,	"include\routines_LEVELS.c", 525; {
 4154                        	
 4155                        		.dbg	line,	"include\routines_LEVELS.c", 526; load_vram(PLAYER_VRAM_ADR, tiles_SPR_PLAYER + OFFSET_PLAYER_WALK_2 , TILES_16);
 4156                        		__st.wmiq	6144, _di
         01:C383  64 F0      			stz.l	_di
         01:C385  A9 18      			lda.h	#6144
         01:C387  85 F1      			sta.h	_di
 4157                        		__farptr	_tiles_SPR_PLAYER + 1024, _bp_bank, _bp
         01:C389  A9 A0      			lda.l	#$6000 + ($1FFF & (_tiles_SPR_PLAYER + 1024))
         01:C38B  85 EC      			sta.l	_bp
         01:C38D  A9 7E      			lda.h	#$6000 + ($1FFF & (_tiles_SPR_PLAYER + 1024))
         01:C38F  85 ED      			sta.h	_bp
         01:C391  A9 0B      			lda	#bank(_tiles_SPR_PLAYER + 1024)
         01:C393  85 02      			sta	_bp_bank
 4158                        		__st.wmiq	256, _ax
         01:C395  64 F8      			stz.l	_ax
         01:C397  A9 01      			lda.h	#256
         01:C399  85 F9      			sta.h	_ax
 4159                        		 _load_vram.3
         01:C39B  82         			clx				; Offset to PCE VDC.
         01:C39C  20 77 FF   			call	load_vram_x
 4160                        	
 4161                        		.dbg	line,	"include\routines_LEVELS.c", 527; }
 4162                        	
 4163                        		.dbg	line,	"include\routines_LEVELS.c", 530; else if(player_counter_anim == 8)
 4164                        		__bra		.LL119
         01:C39F  4C 7C C4   			bra	.LL119
 4165    01:C3A2             	.LL118:
 4166                        		__ld.umq	_player_counter_anim
         01:C3A2  AD 12 23   			lda	_player_counter_anim
 4167                        		__equ_b.uiq	8
         01:C3A5  C9 08      			cmp	#8
         01:C3A7  F0 01      			beq	!+
         01:C3A9  18         			clc
         01:C3AA             	!:
 4168                        		__bfalse	.LL120
         01:C3AA  90 1F      			bcc	.LL120
 4169                        	
 4170                        		.dbg	line,	"include\routines_LEVELS.c", 531; {
 4171                        	
 4172                        		.dbg	line,	"include\routines_LEVELS.c", 532; load_vram(PLAYER_VRAM_ADR, tiles_SPR_PLAYER + OFFSET_PLAYER_WALK_3 , TILES_16);
 4173                        		__st.wmiq	6144, _di
         01:C3AC  64 F0      			stz.l	_di
         01:C3AE  A9 18      			lda.h	#6144
         01:C3B0  85 F1      			sta.h	_di
 4174                        		__farptr	_tiles_SPR_PLAYER + 1536, _bp_bank, _bp
         01:C3B2  A9 A0      			lda.l	#$6000 + ($1FFF & (_tiles_SPR_PLAYER + 1536))
         01:C3B4  85 EC      			sta.l	_bp
         01:C3B6  A9 60      			lda.h	#$6000 + ($1FFF & (_tiles_SPR_PLAYER + 1536))
         01:C3B8  85 ED      			sta.h	_bp
         01:C3BA  A9 0C      			lda	#bank(_tiles_SPR_PLAYER + 1536)
         01:C3BC  85 02      			sta	_bp_bank
 4175                        		__st.wmiq	256, _ax
         01:C3BE  64 F8      			stz.l	_ax
         01:C3C0  A9 01      			lda.h	#256
         01:C3C2  85 F9      			sta.h	_ax
 4176                        		 _load_vram.3
         01:C3C4  82         			clx				; Offset to PCE VDC.
         01:C3C5  20 77 FF   			call	load_vram_x
 4177                        	
 4178                        		.dbg	line,	"include\routines_LEVELS.c", 533; }
 4179                        	
 4180                        		.dbg	line,	"include\routines_LEVELS.c", 536; else if(player_counter_anim == 11)
 4181                        		__bra		.LL121
         01:C3C8  4C 7C C4   			bra	.LL121
 4182    01:C3CB             	.LL120:
 4183                        		__ld.umq	_player_counter_anim
         01:C3CB  AD 12 23   			lda	_player_counter_anim
 4184                        		__equ_b.uiq	11
         01:C3CE  C9 0B      			cmp	#11
         01:C3D0  F0 01      			beq	!+
         01:C3D2  18         			clc
         01:C3D3             	!:
 4185                        		__bfalse	.LL122
         01:C3D3  90 1F      			bcc	.LL122
 4186                        	
 4187                        		.dbg	line,	"include\routines_LEVELS.c", 537; {
 4188                        	
 4189                        		.dbg	line,	"include\routines_LEVELS.c", 538; load_vram(PLAYER_VRAM_ADR, tiles_SPR_PLAYER , TILES_16);
 4190                        		__st.wmiq	6144, _di
         01:C3D5  64 F0      			stz.l	_di
         01:C3D7  A9 18      			lda.h	#6144
         01:C3D9  85 F1      			sta.h	_di
 4191                        		__farptr	_tiles_SPR_PLAYER, _bp_bank, _bp
         01:C3DB  A9 A0      			lda.l	#$6000 + ($1FFF & (_tiles_SPR_PLAYER))
         01:C3DD  85 EC      			sta.l	_bp
         01:C3DF  A9 7A      			lda.h	#$6000 + ($1FFF & (_tiles_SPR_PLAYER))
         01:C3E1  85 ED      			sta.h	_bp
         01:C3E3  A9 0B      			lda	#bank(_tiles_SPR_PLAYER)
         01:C3E5  85 02      			sta	_bp_bank
 4192                        		__st.wmiq	256, _ax
         01:C3E7  64 F8      			stz.l	_ax
         01:C3E9  A9 01      			lda.h	#256
         01:C3EB  85 F9      			sta.h	_ax
 4193                        		 _load_vram.3
         01:C3ED  82         			clx				; Offset to PCE VDC.
         01:C3EE  20 77 FF   			call	load_vram_x
 4194                        	
 4195                        		.dbg	line,	"include\routines_LEVELS.c", 539; }
 4196                        	
 4197                        		.dbg	line,	"include\routines_LEVELS.c", 542; else if(player_counter_anim == 14)
 4198                        		__bra		.LL123
         01:C3F1  4C 7C C4   			bra	.LL123
 4199    01:C3F4             	.LL122:
 4200                        		__ld.umq	_player_counter_anim
         01:C3F4  AD 12 23   			lda	_player_counter_anim
 4201                        		__equ_b.uiq	14
         01:C3F7  C9 0E      			cmp	#14
         01:C3F9  F0 01      			beq	!+
         01:C3FB  18         			clc
         01:C3FC             	!:
 4202                        		__bfalse	.LL124
         01:C3FC  90 1E      			bcc	.LL124
 4203                        	
 4204                        		.dbg	line,	"include\routines_LEVELS.c", 543; {
 4205                        	
 4206                        		.dbg	line,	"include\routines_LEVELS.c", 544; load_vram(PLAYER_VRAM_ADR, tiles_SPR_PLAYER + OFFSET_PLAYER_WALK_4 , TILES_16);
 4207                        		__st.wmiq	6144, _di
         01:C3FE  64 F0      			stz.l	_di
         01:C400  A9 18      			lda.h	#6144
         01:C402  85 F1      			sta.h	_di
 4208                        		__farptr	_tiles_SPR_PLAYER + 2048, _bp_bank, _bp
         01:C404  A9 A0      			lda.l	#$6000 + ($1FFF & (_tiles_SPR_PLAYER + 2048))
         01:C406  85 EC      			sta.l	_bp
         01:C408  A9 62      			lda.h	#$6000 + ($1FFF & (_tiles_SPR_PLAYER + 2048))
         01:C40A  85 ED      			sta.h	_bp
         01:C40C  A9 0C      			lda	#bank(_tiles_SPR_PLAYER + 2048)
         01:C40E  85 02      			sta	_bp_bank
 4209                        		__st.wmiq	256, _ax
         01:C410  64 F8      			stz.l	_ax
         01:C412  A9 01      			lda.h	#256
         01:C414  85 F9      			sta.h	_ax
 4210                        		 _load_vram.3
         01:C416  82         			clx				; Offset to PCE VDC.
         01:C417  20 77 FF   			call	load_vram_x
 4211                        	
 4212                        		.dbg	line,	"include\routines_LEVELS.c", 545; }
 4213                        	
 4214                        		.dbg	line,	"include\routines_LEVELS.c", 548; else if(player_counter_anim == 17)
 4215                        		__bra		.LL125
         01:C41A  80 60      			bra	.LL125
 4216    01:C41C             	.LL124:
 4217                        		__ld.umq	_player_counter_anim
         01:C41C  AD 12 23   			lda	_player_counter_anim
 4218                        		__equ_b.uiq	17
         01:C41F  C9 11      			cmp	#17
         01:C421  F0 01      			beq	!+
         01:C423  18         			clc
         01:C424             	!:
 4219                        		__bfalse	.LL126
         01:C424  90 1E      			bcc	.LL126
 4220                        	
 4221                        		.dbg	line,	"include\routines_LEVELS.c", 549; {
 4222                        	
 4223                        		.dbg	line,	"include\routines_LEVELS.c", 550; load_vram(PLAYER_VRAM_ADR, tiles_SPR_PLAYER + OFFSET_PLAYER_WALK_5 , TILES_16);
 4224                        		__st.wmiq	6144, _di
         01:C426  64 F0      			stz.l	_di
         01:C428  A9 18      			lda.h	#6144
         01:C42A  85 F1      			sta.h	_di
 4225                        		__farptr	_tiles_SPR_PLAYER + 2560, _bp_bank, _bp
         01:C42C  A9 A0      			lda.l	#$6000 + ($1FFF & (_tiles_SPR_PLAYER + 2560))
         01:C42E  85 EC      			sta.l	_bp
         01:C430  A9 64      			lda.h	#$6000 + ($1FFF & (_tiles_SPR_PLAYER + 2560))
         01:C432  85 ED      			sta.h	_bp
         01:C434  A9 0C      			lda	#bank(_tiles_SPR_PLAYER + 2560)
         01:C436  85 02      			sta	_bp_bank
 4226                        		__st.wmiq	256, _ax
         01:C438  64 F8      			stz.l	_ax
         01:C43A  A9 01      			lda.h	#256
         01:C43C  85 F9      			sta.h	_ax
 4227                        		 _load_vram.3
         01:C43E  82         			clx				; Offset to PCE VDC.
         01:C43F  20 77 FF   			call	load_vram_x
 4228                        	
 4229                        		.dbg	line,	"include\routines_LEVELS.c", 551; }
 4230                        	
 4231                        		.dbg	line,	"include\routines_LEVELS.c", 554; else if(player_counter_anim == 20)
 4232                        		__bra		.LL127
         01:C442  80 38      			bra	.LL127
 4233    01:C444             	.LL126:
 4234                        		__ld.umq	_player_counter_anim
         01:C444  AD 12 23   			lda	_player_counter_anim
 4235                        		__equ_b.uiq	20
         01:C447  C9 14      			cmp	#20
         01:C449  F0 01      			beq	!+
         01:C44B  18         			clc
         01:C44C             	!:
 4236                        		__bfalse	.LL128
         01:C44C  90 1E      			bcc	.LL128
 4237                        	
 4238                        		.dbg	line,	"include\routines_LEVELS.c", 555; {
 4239                        	
 4240                        		.dbg	line,	"include\routines_LEVELS.c", 556; load_vram(PLAYER_VRAM_ADR, tiles_SPR_PLAYER + OFFSET_PLAYER_WALK_6 , TILES_16);
 4241                        		__st.wmiq	6144, _di
         01:C44E  64 F0      			stz.l	_di
         01:C450  A9 18      			lda.h	#6144
         01:C452  85 F1      			sta.h	_di
 4242                        		__farptr	_tiles_SPR_PLAYER + 3072, _bp_bank, _bp
         01:C454  A9 A0      			lda.l	#$6000 + ($1FFF & (_tiles_SPR_PLAYER + 3072))
         01:C456  85 EC      			sta.l	_bp
         01:C458  A9 66      			lda.h	#$6000 + ($1FFF & (_tiles_SPR_PLAYER + 3072))
         01:C45A  85 ED      			sta.h	_bp
         01:C45C  A9 0C      			lda	#bank(_tiles_SPR_PLAYER + 3072)
         01:C45E  85 02      			sta	_bp_bank
 4243                        		__st.wmiq	256, _ax
         01:C460  64 F8      			stz.l	_ax
         01:C462  A9 01      			lda.h	#256
         01:C464  85 F9      			sta.h	_ax
 4244                        		 _load_vram.3
         01:C466  82         			clx				; Offset to PCE VDC.
         01:C467  20 77 FF   			call	load_vram_x
 4245                        	
 4246                        		.dbg	line,	"include\routines_LEVELS.c", 557; }
 4247                        	
 4248                        		.dbg	line,	"include\routines_LEVELS.c", 560; else if(player_counter_anim == 22)
 4249                        		__bra		.LL129
         01:C46A  80 10      			bra	.LL129
 4250    01:C46C             	.LL128:
 4251                        		__ld.umq	_player_counter_anim
         01:C46C  AD 12 23   			lda	_player_counter_anim
 4252                        		__equ_b.uiq	22
         01:C46F  C9 16      			cmp	#22
         01:C471  F0 01      			beq	!+
         01:C473  18         			clc
         01:C474             	!:
 4253                        		__bfalse	.LL130
         01:C474  90 06      			bcc	.LL130
 4254                        	
 4255                        		.dbg	line,	"include\routines_LEVELS.c", 561; {
 4256                        	
 4257                        		.dbg	line,	"include\routines_LEVELS.c", 562; player_counter_anim = 0;
 4258                        		__st.umiq	0, _player_counter_anim
         01:C476  9C 12 23   			stz	_player_counter_anim
 4259                        	
 4260                        		.dbg	line,	"include\routines_LEVELS.c", 564; return;
 4261                        		__bra		.LL95
         01:C479  4C 09 D6   			bra	.LL95
 4262                        	
 4263                        		.dbg	line,	"include\routines_LEVELS.c", 565; }
 4264                        	
 4265                        		.dbg	line,	"include\routines_LEVELS.c", 568; player_counter_anim += 1;
 4266    01:C47C             	.LL130:
 4267    01:C47C             	.LL129:
 4268    01:C47C             	.LL127:
 4269    01:C47C             	.LL125:
 4270    01:C47C             	.LL123:
 4271    01:C47C             	.LL121:
 4272    01:C47C             	.LL119:
 4273    01:C47C             	.LL117:
 4274    01:C47C             	.LL115:
 4275                        		__add_st.umiq	1, _player_counter_anim
         01:C47C  EE 12 23   			inc	_player_counter_anim
 4276                        	
 4277                        		.dbg	line,	"include\routines_LEVELS.c", 570; }
 4278                        	
 4279                        		.dbg	line,	"include\routines_LEVELS.c", 573; else if(player_state == STATE_JUMP)
 4280                        		__bra		.LL131
         01:C47F  4C 09 D6   			bra	.LL131
 4281    01:C482             	.LL101:
 4282                        		__ld.umq	_player_state
         01:C482  AD 0F 23   			lda	_player_state
 4283                        		__equ_b.uiq	4
         01:C485  C9 04      			cmp	#4
         01:C487  F0 01      			beq	!+
         01:C489  18         			clc
         01:C48A             	!:
 4284                        		__bfalse	.LL132
         01:C48A  B0 03 4C 82			bcc	.LL132
         01:C48E  C7          
 4285                        	
 4286                        		.dbg	line,	"include\routines_LEVELS.c", 574; {
 4287                        	
 4288                        		.dbg	line,	"include\routines_LEVELS.c", 575; unsigned char i;
 4289                        	
 4290                        		.dbg	line,	"include\routines_LEVELS.c", 576; i = 1;
 4291                        		__st.umiq	1, __update_PLAYER_end - 1  /* i */
         01:C48F  A9 01      			lda.l	#1
         01:C491  8D 09 23   			sta	__update_PLAYER_end - 1
 4292                        	
 4293                        		.dbg	line,	"include\routines_LEVELS.c", 579; if(player_counter_anim == 0)
 4294                        		__not.um	_player_counter_anim
         01:C494  AD 12 23   			lda	_player_counter_anim
         01:C497  18         			clc
         01:C498  D0 01      			bne	!+
         01:C49A  38         			sec
         01:C49B             	!:
 4295                        		__bfalse	.LL133
         01:C49B  90 21      			bcc	.LL133
 4296                        	
 4297                        		.dbg	line,	"include\routines_LEVELS.c", 580; {
 4298                        	
 4299                        		.dbg	line,	"include\routines_LEVELS.c", 581; load_vram(PLAYER_VRAM_ADR, tiles_SPR_PLAYER + TILES_112 , TILES_16);
 4300                        		__st.wmiq	6144, _di
         01:C49D  64 F0      			stz.l	_di
         01:C49F  A9 18      			lda.h	#6144
         01:C4A1  85 F1      			sta.h	_di
 4301                        		__farptr	_tiles_SPR_PLAYER + 3584, _bp_bank, _bp
         01:C4A3  A9 A0      			lda.l	#$6000 + ($1FFF & (_tiles_SPR_PLAYER + 3584))
         01:C4A5  85 EC      			sta.l	_bp
         01:C4A7  A9 68      			lda.h	#$6000 + ($1FFF & (_tiles_SPR_PLAYER + 3584))
         01:C4A9  85 ED      			sta.h	_bp
         01:C4AB  A9 0C      			lda	#bank(_tiles_SPR_PLAYER + 3584)
         01:C4AD  85 02      			sta	_bp_bank
 4302                        		__st.wmiq	256, _ax
         01:C4AF  64 F8      			stz.l	_ax
         01:C4B1  A9 01      			lda.h	#256
         01:C4B3  85 F9      			sta.h	_ax
 4303                        		 _load_vram.3
         01:C4B5  82         			clx				; Offset to PCE VDC.
         01:C4B6  20 77 FF   			call	load_vram_x
 4304                        	
 4305                        		.dbg	line,	"include\routines_LEVELS.c", 583; player_counter_anim = 1;
 4306                        		__st.umiq	1, _player_counter_anim
         01:C4B9  A9 01      			lda.l	#1
         01:C4BB  8D 12 23   			sta	_player_counter_anim
 4307                        	
 4308                        		.dbg	line,	"include\routines_LEVELS.c", 584; }
 4309                        	
 4310                        		.dbg	line,	"include\routines_LEVELS.c", 587; player_pos_y += TABLE_PLAYER_JUMP_V[player_index_jump];
 4311    01:C4BE             	.LL133:
 4312                        		__ldx.umq	_player_index_jump
         01:C4BE  AE 13 23   			ldx	_player_index_jump
 4313                        		__ld.bax	_TABLE_PLAYER_JUMP_V
         01:C4C1  BD 9A 60   			lda	_TABLE_PLAYER_JUMP_V, x
         01:C4C4  C2         			cly
         01:C4C5  10 01      			bpl	!+
         01:C4C7  88         			dey
         01:C4C8             	!:
 4314                        		__add_st.wmq	_player_pos_y
         01:C4C8  18         			clc
         01:C4C9  6D 1A 23   			adc.l	_player_pos_y
         01:C4CC  8D 1A 23   			sta.l	_player_pos_y
         01:C4CF  98         			tya
         01:C4D0  6D 1B 23   			adc.h	_player_pos_y
         01:C4D3  8D 1B 23   			sta.h	_player_pos_y
 4315                        	
 4316                        		.dbg	line,	"include\routines_LEVELS.c", 589; // CHECK COLLISION WITH CEILING //
 4317                        	
 4318                        		.dbg	line,	"include\routines_LEVELS.c", 590; check_BG( 15 , 8 );
 4319                        		__ld.wi		15
         01:C4D6  A9 0F      			lda.l	#15
         01:C4D8  C2         			cly
 4320                        		__pusharg.wr
         01:C4D9  A6 8D      			ldx	<__sp
         01:C4DB  CA         			dex
         01:C4DC  CA         			dex
         01:C4DD  95 08      			sta.l	<__stack, x
         01:C4DF  94 09      			sty.h	<__stack, x
         01:C4E1  86 8D      			stx	<__sp
 4321                        		__ld.wi		8
         01:C4E3  A9 08      			lda.l	#8
         01:C4E5  C2         			cly
 4322                        		__pusharg.wr
         01:C4E6  A6 8D      			ldx	<__sp
         01:C4E8  CA         			dex
         01:C4E9  CA         			dex
         01:C4EA  95 08      			sta.l	<__stack, x
         01:C4EC  94 09      			sty.h	<__stack, x
         01:C4EE  86 8D      			stx	<__sp
 4323                        		__call		_check_BG
         01:C4F0  20 81 FF   			call	_check_BG
 4324                        	
 4325                        		.dbg	line,	"include\routines_LEVELS.c", 592; if(map_blk_flag == TILE_BG)
 4326                        		__ld.umq	_map_blk_flag
         01:C4F3  AD E9 29   			lda	_map_blk_flag
 4327                        		__equ_b.uiq	1
         01:C4F6  C9 01      			cmp	#1
         01:C4F8  F0 01      			beq	!+
         01:C4FA  18         			clc
         01:C4FB             	!:
 4328                        		__bfalse	.LL134
         01:C4FB  90 5A      			bcc	.LL134
 4329                        	
 4330                        		.dbg	line,	"include\routines_LEVELS.c", 593; {
 4331                        	
 4332                        		.dbg	line,	"include\routines_LEVELS.c", 594; for(i=1 ; i<8 ; i++)
 4333                        		__st.umiq	1, __update_PLAYER_end - 1  /* i */
         01:C4FD  A9 01      			lda.l	#1
         01:C4FF  8D 09 23   			sta	__update_PLAYER_end - 1
 4334    01:C502             	.LL135:
 4335                        		__ld.umq	__update_PLAYER_end - 1  /* i */
         01:C502  AD 09 23   			lda	__update_PLAYER_end - 1
 4336                        		__ult_b.uiq	8
         01:C505  C9 08      			cmp	#8		; Subtract integer from A.
         01:C507  6A         			ror	a		; CC if A < integer.
         01:C508  49 80      			eor	#$80
         01:C50A  2A         			rol	a
 4337                        		__btrue		.LL137
         01:C50B  B0 07      			bcs	.LL137
 4338                        		__bra		.LL138
         01:C50D  80 48      			bra	.LL138
 4339    01:C50F             	.LL136:
 4340                        		__inc.umq	__update_PLAYER_end - 1  /* i */
         01:C50F  EE 09 23   			inc	__update_PLAYER_end - 1
 4341                        		__bra		.LL135
         01:C512  80 EE      			bra	.LL135
 4342    01:C514             	.LL137:
 4343                        	
 4344                        		.dbg	line,	"include\routines_LEVELS.c", 595; {
 4345                        	
 4346                        		.dbg	line,	"include\routines_LEVELS.c", 596; check_BG( 15 , 8 + i );
 4347                        		__ld.wi		15
         01:C514  A9 0F      			lda.l	#15
         01:C516  C2         			cly
 4348                        		__pusharg.wr
         01:C517  A6 8D      			ldx	<__sp
         01:C519  CA         			dex
         01:C51A  CA         			dex
         01:C51B  95 08      			sta.l	<__stack, x
         01:C51D  94 09      			sty.h	<__stack, x
         01:C51F  86 8D      			stx	<__sp
 4349                        		__ld.wi		8
         01:C521  A9 08      			lda.l	#8
         01:C523  C2         			cly
 4350                        		__add.um	__update_PLAYER_end - 1  /* i */
         01:C524  18         			clc
         01:C525  6D 09 23   			adc	__update_PLAYER_end - 1
         01:C528  90 01      			bcc	!+
         01:C52A  C8         			iny
         01:C52B             	!:
 4351                        		__pusharg.wr
         01:C52B  A6 8D      			ldx	<__sp
         01:C52D  CA         			dex
         01:C52E  CA         			dex
         01:C52F  95 08      			sta.l	<__stack, x
         01:C531  94 09      			sty.h	<__stack, x
         01:C533  86 8D      			stx	<__sp
 4352                        		__call		_check_BG
         01:C535  20 81 FF   			call	_check_BG
 4353                        	
 4354                        		.dbg	line,	"include\routines_LEVELS.c", 597; {
 4355                        	
 4356                        		.dbg	line,	"include\routines_LEVELS.c", 598; if(map_blk_flag == TILE_EMPTY)
 4357                        		__not.um	_map_blk_flag
         01:C538  AD E9 29   			lda	_map_blk_flag
         01:C53B  18         			clc
         01:C53C  D0 01      			bne	!+
         01:C53E  38         			sec
         01:C53F             	!:
 4358                        		__bfalse	.LL139
         01:C53F  90 CE      			bcc	.LL139
 4359                        	
 4360                        		.dbg	line,	"include\routines_LEVELS.c", 599; {
 4361                        	
 4362                        		.dbg	line,	"include\routines_LEVELS.c", 600; player_pos_y += i;
 4363                        		__ld.um		__update_PLAYER_end - 1  /* i */
         01:C541  AD 09 23   			lda	__update_PLAYER_end - 1
         01:C544  C2         			cly
 4364                        		__add_st.wmq	_player_pos_y
         01:C545  18         			clc
         01:C546  6D 1A 23   			adc.l	_player_pos_y
         01:C549  8D 1A 23   			sta.l	_player_pos_y
         01:C54C  98         			tya
         01:C54D  6D 1B 23   			adc.h	_player_pos_y
         01:C550  8D 1B 23   			sta.h	_player_pos_y
 4365                        	
 4366                        		.dbg	line,	"include\routines_LEVELS.c", 601; break;
 4367                        		__bra		.LL138
         01:C553  80 02      			bra	.LL138
 4368                        	
 4369                        		.dbg	line,	"include\routines_LEVELS.c", 602; }
 4370                        	
 4371                        		.dbg	line,	"include\routines_LEVELS.c", 603; }
 4372    01:C555             	.LL139	.alias		.LL136
 4373                        	
 4374                        		.dbg	line,	"include\routines_LEVELS.c", 604; }
 4375                        		__bra		.LL136
         01:C555  80 B8      			bra	.LL136
 4376    01:C557             	.LL138:
 4377                        	
 4378                        		.dbg	line,	"include\routines_LEVELS.c", 605; }
 4379                        	
 4380                        		.dbg	line,	"include\routines_LEVELS.c", 607; spr_set(player_id);
 4381    01:C557             	.LL134:
 4382                        		__ld.umq	_player_id
         01:C557  AD 0E 23   			lda	_player_id
 4383                        		__call		_spr_set.1
         01:C55A  20 DD E7   			call	_spr_set.1
 4384                        	
 4385                        		.dbg	line,	"include\routines_LEVELS.c", 608; spr_y(player_pos_y);
 4386                        		__ld.wm		_player_pos_y
         01:C55D  AD 1A 23   			lda.l	_player_pos_y
         01:C560  AC 1B 23   			ldy.h	_player_pos_y
 4387                        		__call		_spr_y.1
         01:C563  20 19 E8   			call	_spr_y.1
 4388                        	
 4389                        		.dbg	line,	"include\routines_LEVELS.c", 612; if(player_index_jump < 34)
 4390                        		__ld.umq	_player_index_jump
         01:C566  AD 13 23   			lda	_player_index_jump
 4391                        		__ult_b.uiq	34
         01:C569  C9 22      			cmp	#34		; Subtract integer from A.
         01:C56B  6A         			ror	a		; CC if A < integer.
         01:C56C  49 80      			eor	#$80
         01:C56E  2A         			rol	a
 4392                        		__bfalse	.LL140
         01:C56F  90 03      			bcc	.LL140
 4393                        	
 4394                        		.dbg	line,	"include\routines_LEVELS.c", 613; {
 4395                        	
 4396                        		.dbg	line,	"include\routines_LEVELS.c", 615; player_index_jump += 1;
 4397                        		__add_st.umiq	1, _player_index_jump
         01:C571  EE 13 23   			inc	_player_index_jump
 4398                        	
 4399                        		.dbg	line,	"include\routines_LEVELS.c", 616; }
 4400                        	
 4401                        		.dbg	line,	"include\routines_LEVELS.c", 621; //--------------------------------------------------------------------------------------//
 4402                        	
 4403                        		.dbg	line,	"include\routines_LEVELS.c", 622; //                                   FLOOR COLLISION                                    //
 4404                        	
 4405                        		.dbg	line,	"include\routines_LEVELS.c", 623; //--------------------------------------------------------------------------------------//
 4406                        	
 4407                        		.dbg	line,	"include\routines_LEVELS.c", 625; if(player_index_jump > 14)
 4408    01:C574             	.LL140:
 4409                        		__ld.umq	_player_index_jump
         01:C574  AD 13 23   			lda	_player_index_jump
 4410                        		__ugt_b.uiq	14
         01:C577  18         			clc			; Subtract integer+1 from A.
         01:C578  E9 0E      			sbc	#14		; CS if A > integer.
 4411                        		__bfalse	.LL141
         01:C57A  B0 03 4C F5			bcc	.LL141
         01:C57E  C6          
 4412                        	
 4413                        		.dbg	line,	"include\routines_LEVELS.c", 626; {
 4414                        	
 4415                        		.dbg	line,	"include\routines_LEVELS.c", 627; // CHECK COLLISION WITH LEFT FLOOR //
 4416                        	
 4417                        		.dbg	line,	"include\routines_LEVELS.c", 628; check_BG( 10 , 32 );
 4418                        		__ld.wi		10
         01:C57F  A9 0A      			lda.l	#10
         01:C581  C2         			cly
 4419                        		__pusharg.wr
         01:C582  A6 8D      			ldx	<__sp
         01:C584  CA         			dex
         01:C585  CA         			dex
         01:C586  95 08      			sta.l	<__stack, x
         01:C588  94 09      			sty.h	<__stack, x
         01:C58A  86 8D      			stx	<__sp
 4420                        		__ld.wi		32
         01:C58C  A9 20      			lda.l	#32
         01:C58E  C2         			cly
 4421                        		__pusharg.wr
         01:C58F  A6 8D      			ldx	<__sp
         01:C591  CA         			dex
         01:C592  CA         			dex
         01:C593  95 08      			sta.l	<__stack, x
         01:C595  94 09      			sty.h	<__stack, x
         01:C597  86 8D      			stx	<__sp
 4422                        		__call		_check_BG
         01:C599  20 81 FF   			call	_check_BG
 4423                        	
 4424                        		.dbg	line,	"include\routines_LEVELS.c", 630; // IF PLAYER TOUCHES THE GROUND TO THE LEFT //
 4425                        	
 4426                        		.dbg	line,	"include\routines_LEVELS.c", 631; if(map_blk_flag == TILE_BG)
 4427                        		__ld.umq	_map_blk_flag
         01:C59C  AD E9 29   			lda	_map_blk_flag
 4428                        		__equ_b.uiq	1
         01:C59F  C9 01      			cmp	#1
         01:C5A1  F0 01      			beq	!+
         01:C5A3  18         			clc
         01:C5A4             	!:
 4429                        		__bfalse	.LL142
         01:C5A4  B0 03 4C 3A			bcc	.LL142
         01:C5A8  C6          
 4430                        	
 4431                        		.dbg	line,	"include\routines_LEVELS.c", 632; {
 4432                        	
 4433                        		.dbg	line,	"include\routines_LEVELS.c", 633; // CALCULATE HOW MANY PIXELS THE PLAYER MOVED INTO THE GROUND //
 4434                        	
 4435                        		.dbg	line,	"include\routines_LEVELS.c", 634; for(i=1; i<11 ; i++ )
 4436                        		__st.umiq	1, __update_PLAYER_end - 1  /* i */
         01:C5A9  A9 01      			lda.l	#1
         01:C5AB  8D 09 23   			sta	__update_PLAYER_end - 1
 4437    01:C5AE             	.LL143:
 4438                        		__ld.umq	__update_PLAYER_end - 1  /* i */
         01:C5AE  AD 09 23   			lda	__update_PLAYER_end - 1
 4439                        		__ult_b.uiq	11
         01:C5B1  C9 0B      			cmp	#11		; Subtract integer from A.
         01:C5B3  6A         			ror	a		; CC if A < integer.
         01:C5B4  49 80      			eor	#$80
         01:C5B6  2A         			rol	a
 4440                        		__btrue		.LL145
         01:C5B7  B0 07      			bcs	.LL145
 4441                        		__bra		.LL146
         01:C5B9  80 71      			bra	.LL146
 4442    01:C5BB             	.LL144:
 4443                        		__inc.umq	__update_PLAYER_end - 1  /* i */
         01:C5BB  EE 09 23   			inc	__update_PLAYER_end - 1
 4444                        		__bra		.LL143
         01:C5BE  80 EE      			bra	.LL143
 4445    01:C5C0             	.LL145:
 4446                        	
 4447                        		.dbg	line,	"include\routines_LEVELS.c", 635; {
 4448                        	
 4449                        		.dbg	line,	"include\routines_LEVELS.c", 636; check_TILE_DEPTH( 10 , i);
 4450                        		__ld.wi		10
         01:C5C0  A9 0A      			lda.l	#10
         01:C5C2  C2         			cly
 4451                        		__pusharg.wr
         01:C5C3  A6 8D      			ldx	<__sp
         01:C5C5  CA         			dex
         01:C5C6  CA         			dex
         01:C5C7  95 08      			sta.l	<__stack, x
         01:C5C9  94 09      			sty.h	<__stack, x
         01:C5CB  86 8D      			stx	<__sp
 4452                        		__ld.um		__update_PLAYER_end - 1  /* i */
         01:C5CD  AD 09 23   			lda	__update_PLAYER_end - 1
         01:C5D0  C2         			cly
 4453                        		__pusharg.wr
         01:C5D1  A6 8D      			ldx	<__sp
         01:C5D3  CA         			dex
         01:C5D4  CA         			dex
         01:C5D5  95 08      			sta.l	<__stack, x
         01:C5D7  94 09      			sty.h	<__stack, x
         01:C5D9  86 8D      			stx	<__sp
 4454                        		__call		_check_TILE_DEPTH
         01:C5DB  20 63 FF   			call	_check_TILE_DEPTH
 4455                        	
 4456                        		.dbg	line,	"include\routines_LEVELS.c", 638; if(map_blk_flag == TILE_EMPTY)
 4457                        		__not.um	_map_blk_flag
         01:C5DE  AD E9 29   			lda	_map_blk_flag
         01:C5E1  18         			clc
         01:C5E2  D0 01      			bne	!+
         01:C5E4  38         			sec
         01:C5E5             	!:
 4458                        		__bfalse	.LL147
         01:C5E5  90 D4      			bcc	.LL147
 4459                        	
 4460                        		.dbg	line,	"include\routines_LEVELS.c", 639; {
 4461                        	
 4462                        		.dbg	line,	"include\routines_LEVELS.c", 640; load_vram(PLAYER_VRAM_ADR, tiles_SPR_PLAYER , TILES_16);
 4463                        		__st.wmiq	6144, _di
         01:C5E7  64 F0      			stz.l	_di
         01:C5E9  A9 18      			lda.h	#6144
         01:C5EB  85 F1      			sta.h	_di
 4464                        		__farptr	_tiles_SPR_PLAYER, _bp_bank, _bp
         01:C5ED  A9 A0      			lda.l	#$6000 + ($1FFF & (_tiles_SPR_PLAYER))
         01:C5EF  85 EC      			sta.l	_bp
         01:C5F1  A9 7A      			lda.h	#$6000 + ($1FFF & (_tiles_SPR_PLAYER))
         01:C5F3  85 ED      			sta.h	_bp
         01:C5F5  A9 0B      			lda	#bank(_tiles_SPR_PLAYER)
         01:C5F7  85 02      			sta	_bp_bank
 4465                        		__st.wmiq	256, _ax
         01:C5F9  64 F8      			stz.l	_ax
         01:C5FB  A9 01      			lda.h	#256
         01:C5FD  85 F9      			sta.h	_ax
 4466                        		 _load_vram.3
         01:C5FF  82         			clx				; Offset to PCE VDC.
         01:C600  20 77 FF   			call	load_vram_x
 4467                        	
 4468                        		.dbg	line,	"include\routines_LEVELS.c", 642; player_pos_y -= (i - 1);
 4469                        		__ld.um		__update_PLAYER_end - 1  /* i */
         01:C603  AD 09 23   			lda	__update_PLAYER_end - 1
         01:C606  C2         			cly
 4470                        		__sub.wi	1
         01:C607  38         			sec
         01:C608  E9 01      			sbc.l	#1
         01:C60A  B0 01      			bcs	!+
         01:C60C  88         			dey
         01:C60D             	!:
 4471                        		__isub_st.wmq	_player_pos_y
         01:C60D  38         			sec
         01:C60E  49 FF      			eor	#$FF
         01:C610  6D 1A 23   			adc.l	_player_pos_y
         01:C613  8D 1A 23   			sta.l	_player_pos_y
         01:C616  98         			tya
         01:C617  49 FF      			eor	#$FF
         01:C619  6D 1B 23   			adc.h	_player_pos_y
         01:C61C  8D 1B 23   			sta.h	_player_pos_y
 4472                        	
 4473                        		.dbg	line,	"include\routines_LEVELS.c", 643; spr_y(player_pos_y);
 4474                        		__ld.wm		_player_pos_y
         01:C61F  AD 1A 23   			lda.l	_player_pos_y
         01:C622  AC 1B 23   			ldy.h	_player_pos_y
 4475                        		__call		_spr_y.1
         01:C625  20 19 E8   			call	_spr_y.1
 4476                        	
 4477                        		.dbg	line,	"include\routines_LEVELS.c", 644; break;
 4478                        		__bra		.LL146
         01:C628  80 02      			bra	.LL146
 4479                        	
 4480                        		.dbg	line,	"include\routines_LEVELS.c", 645; }
 4481                        	
 4482                        		.dbg	line,	"include\routines_LEVELS.c", 647; }
 4483    01:C62A             	.LL147	.alias		.LL144
 4484                        		__bra		.LL144
         01:C62A  80 8F      			bra	.LL144
 4485    01:C62C             	.LL146:
 4486                        	
 4487                        		.dbg	line,	"include\routines_LEVELS.c", 649; player_counter_anim = 1;
 4488                        		__st.umiq	1, _player_counter_anim
         01:C62C  A9 01      			lda.l	#1
         01:C62E  8D 12 23   			sta	_player_counter_anim
 4489                        	
 4490                        		.dbg	line,	"include\routines_LEVELS.c", 650; player_index_jump = 0;
 4491                        		__st.umiq	0, _player_index_jump
         01:C631  9C 13 23   			stz	_player_index_jump
 4492                        	
 4493                        		.dbg	line,	"include\routines_LEVELS.c", 651; player_state = STATE_IDLE;
 4494                        		__st.umiq	0, _player_state
         01:C634  9C 0F 23   			stz	_player_state
 4495                        	
 4496                        		.dbg	line,	"include\routines_LEVELS.c", 652; return;
 4497                        		__bra		.LL95
         01:C637  4C 09 D6   			bra	.LL95
 4498                        	
 4499                        		.dbg	line,	"include\routines_LEVELS.c", 653; }
 4500                        	
 4501                        		.dbg	line,	"include\routines_LEVELS.c", 655; // IF PLAYER TOUCHES THE GROUND TO THE RIGHT //
 4502                        	
 4503                        		.dbg	line,	"include\routines_LEVELS.c", 656; else
 4504    01:C63A             	.LL142:
 4505                        	
 4506                        		.dbg	line,	"include\routines_LEVELS.c", 657; {
 4507                        	
 4508                        		.dbg	line,	"include\routines_LEVELS.c", 658; // CHECK COLLISION WITH RIGHT FLOOR //
 4509                        	
 4510                        		.dbg	line,	"include\routines_LEVELS.c", 659; check_BG( 22 , 32 );
 4511                        		__ld.wi		22
         01:C63A  A9 16      			lda.l	#22
         01:C63C  C2         			cly
 4512                        		__pusharg.wr
         01:C63D  A6 8D      			ldx	<__sp
         01:C63F  CA         			dex
         01:C640  CA         			dex
         01:C641  95 08      			sta.l	<__stack, x
         01:C643  94 09      			sty.h	<__stack, x
         01:C645  86 8D      			stx	<__sp
 4513                        		__ld.wi		32
         01:C647  A9 20      			lda.l	#32
         01:C649  C2         			cly
 4514                        		__pusharg.wr
         01:C64A  A6 8D      			ldx	<__sp
         01:C64C  CA         			dex
         01:C64D  CA         			dex
         01:C64E  95 08      			sta.l	<__stack, x
         01:C650  94 09      			sty.h	<__stack, x
         01:C652  86 8D      			stx	<__sp
 4515                        		__call		_check_BG
         01:C654  20 81 FF   			call	_check_BG
 4516                        	
 4517                        		.dbg	line,	"include\routines_LEVELS.c", 661; if(map_blk_flag == TILE_BG)
 4518                        		__ld.umq	_map_blk_flag
         01:C657  AD E9 29   			lda	_map_blk_flag
 4519                        		__equ_b.uiq	1
         01:C65A  C9 01      			cmp	#1
         01:C65C  F0 01      			beq	!+
         01:C65E  18         			clc
         01:C65F             	!:
 4520                        		__bfalse	.LL149
         01:C65F  B0 03 4C F5			bcc	.LL149
         01:C663  C6          
 4521                        	
 4522                        		.dbg	line,	"include\routines_LEVELS.c", 662; {
 4523                        	
 4524                        		.dbg	line,	"include\routines_LEVELS.c", 663; // CALCULATE HOW MANY PIXELS THE PLAYER MOVED INTO THE GROUND //
 4525                        	
 4526                        		.dbg	line,	"include\routines_LEVELS.c", 664; for(i=1; i<11 ; i++ )
 4527                        		__st.umiq	1, __update_PLAYER_end - 1  /* i */
         01:C664  A9 01      			lda.l	#1
         01:C666  8D 09 23   			sta	__update_PLAYER_end - 1
 4528    01:C669             	.LL150:
 4529                        		__ld.umq	__update_PLAYER_end - 1  /* i */
         01:C669  AD 09 23   			lda	__update_PLAYER_end - 1
 4530                        		__ult_b.uiq	11
         01:C66C  C9 0B      			cmp	#11		; Subtract integer from A.
         01:C66E  6A         			ror	a		; CC if A < integer.
         01:C66F  49 80      			eor	#$80
         01:C671  2A         			rol	a
 4531                        		__btrue		.LL152
         01:C672  B0 07      			bcs	.LL152
 4532                        		__bra		.LL153
         01:C674  80 71      			bra	.LL153
 4533    01:C676             	.LL151:
 4534                        		__inc.umq	__update_PLAYER_end - 1  /* i */
         01:C676  EE 09 23   			inc	__update_PLAYER_end - 1
 4535                        		__bra		.LL150
         01:C679  80 EE      			bra	.LL150
 4536    01:C67B             	.LL152:
 4537                        	
 4538                        		.dbg	line,	"include\routines_LEVELS.c", 665; {
 4539                        	
 4540                        		.dbg	line,	"include\routines_LEVELS.c", 666; check_TILE_DEPTH( 22 , i);
 4541                        		__ld.wi		22
         01:C67B  A9 16      			lda.l	#22
         01:C67D  C2         			cly
 4542                        		__pusharg.wr
         01:C67E  A6 8D      			ldx	<__sp
         01:C680  CA         			dex
         01:C681  CA         			dex
         01:C682  95 08      			sta.l	<__stack, x
         01:C684  94 09      			sty.h	<__stack, x
         01:C686  86 8D      			stx	<__sp
 4543                        		__ld.um		__update_PLAYER_end - 1  /* i */
         01:C688  AD 09 23   			lda	__update_PLAYER_end - 1
         01:C68B  C2         			cly
 4544                        		__pusharg.wr
         01:C68C  A6 8D      			ldx	<__sp
         01:C68E  CA         			dex
         01:C68F  CA         			dex
         01:C690  95 08      			sta.l	<__stack, x
         01:C692  94 09      			sty.h	<__stack, x
         01:C694  86 8D      			stx	<__sp
 4545                        		__call		_check_TILE_DEPTH
         01:C696  20 63 FF   			call	_check_TILE_DEPTH
 4546                        	
 4547                        		.dbg	line,	"include\routines_LEVELS.c", 668; if(map_blk_flag == TILE_EMPTY)
 4548                        		__not.um	_map_blk_flag
         01:C699  AD E9 29   			lda	_map_blk_flag
         01:C69C  18         			clc
         01:C69D  D0 01      			bne	!+
         01:C69F  38         			sec
         01:C6A0             	!:
 4549                        		__bfalse	.LL154
         01:C6A0  90 D4      			bcc	.LL154
 4550                        	
 4551                        		.dbg	line,	"include\routines_LEVELS.c", 669; {
 4552                        	
 4553                        		.dbg	line,	"include\routines_LEVELS.c", 670; load_vram(PLAYER_VRAM_ADR, tiles_SPR_PLAYER , TILES_16);
 4554                        		__st.wmiq	6144, _di
         01:C6A2  64 F0      			stz.l	_di
         01:C6A4  A9 18      			lda.h	#6144
         01:C6A6  85 F1      			sta.h	_di
 4555                        		__farptr	_tiles_SPR_PLAYER, _bp_bank, _bp
         01:C6A8  A9 A0      			lda.l	#$6000 + ($1FFF & (_tiles_SPR_PLAYER))
         01:C6AA  85 EC      			sta.l	_bp
         01:C6AC  A9 7A      			lda.h	#$6000 + ($1FFF & (_tiles_SPR_PLAYER))
         01:C6AE  85 ED      			sta.h	_bp
         01:C6B0  A9 0B      			lda	#bank(_tiles_SPR_PLAYER)
         01:C6B2  85 02      			sta	_bp_bank
 4556                        		__st.wmiq	256, _ax
         01:C6B4  64 F8      			stz.l	_ax
         01:C6B6  A9 01      			lda.h	#256
         01:C6B8  85 F9      			sta.h	_ax
 4557                        		 _load_vram.3
         01:C6BA  82         			clx				; Offset to PCE VDC.
         01:C6BB  20 77 FF   			call	load_vram_x
 4558                        	
 4559                        		.dbg	line,	"include\routines_LEVELS.c", 672; player_pos_y -= (i - 1);
 4560                        		__ld.um		__update_PLAYER_end - 1  /* i */
         01:C6BE  AD 09 23   			lda	__update_PLAYER_end - 1
         01:C6C1  C2         			cly
 4561                        		__sub.wi	1
         01:C6C2  38         			sec
         01:C6C3  E9 01      			sbc.l	#1
         01:C6C5  B0 01      			bcs	!+
         01:C6C7  88         			dey
         01:C6C8             	!:
 4562                        		__isub_st.wmq	_player_pos_y
         01:C6C8  38         			sec
         01:C6C9  49 FF      			eor	#$FF
         01:C6CB  6D 1A 23   			adc.l	_player_pos_y
         01:C6CE  8D 1A 23   			sta.l	_player_pos_y
         01:C6D1  98         			tya
         01:C6D2  49 FF      			eor	#$FF
         01:C6D4  6D 1B 23   			adc.h	_player_pos_y
         01:C6D7  8D 1B 23   			sta.h	_player_pos_y
 4563                        	
 4564                        		.dbg	line,	"include\routines_LEVELS.c", 673; spr_y(player_pos_y);
 4565                        		__ld.wm		_player_pos_y
         01:C6DA  AD 1A 23   			lda.l	_player_pos_y
         01:C6DD  AC 1B 23   			ldy.h	_player_pos_y
 4566                        		__call		_spr_y.1
         01:C6E0  20 19 E8   			call	_spr_y.1
 4567                        	
 4568                        		.dbg	line,	"include\routines_LEVELS.c", 674; break;
 4569                        		__bra		.LL153
         01:C6E3  80 02      			bra	.LL153
 4570                        	
 4571                        		.dbg	line,	"include\routines_LEVELS.c", 675; }
 4572                        	
 4573                        		.dbg	line,	"include\routines_LEVELS.c", 677; }
 4574    01:C6E5             	.LL154	.alias		.LL151
 4575                        		__bra		.LL151
         01:C6E5  80 8F      			bra	.LL151
 4576    01:C6E7             	.LL153:
 4577                        	
 4578                        		.dbg	line,	"include\routines_LEVELS.c", 679; player_counter_anim = 1;
 4579                        		__st.umiq	1, _player_counter_anim
         01:C6E7  A9 01      			lda.l	#1
         01:C6E9  8D 12 23   			sta	_player_counter_anim
 4580                        	
 4581                        		.dbg	line,	"include\routines_LEVELS.c", 680; player_index_jump = 0;
 4582                        		__st.umiq	0, _player_index_jump
         01:C6EC  9C 13 23   			stz	_player_index_jump
 4583                        	
 4584                        		.dbg	line,	"include\routines_LEVELS.c", 681; player_state = STATE_IDLE;
 4585                        		__st.umiq	0, _player_state
         01:C6EF  9C 0F 23   			stz	_player_state
 4586                        	
 4587                        		.dbg	line,	"include\routines_LEVELS.c", 682; return;
 4588                        		__bra		.LL95
         01:C6F2  4C 09 D6   			bra	.LL95
 4589                        	
 4590                        		.dbg	line,	"include\routines_LEVELS.c", 683; }
 4591                        	
 4592                        		.dbg	line,	"include\routines_LEVELS.c", 684; }
 4593    01:C6F5             	.LL149:
 4594    01:C6F5             	.LL148:
 4595                        	
 4596                        		.dbg	line,	"include\routines_LEVELS.c", 685; }
 4597                        	
 4598                        		.dbg	line,	"include\routines_LEVELS.c", 689; // CHECK COLLISION WITH LADDERS //
 4599                        	
 4600                        		.dbg	line,	"include\routines_LEVELS.c", 690; check_BG( 16 , 16 );
 4601    01:C6F5             	.LL141:
 4602                        		__ld.wi		16
         01:C6F5  A9 10      			lda.l	#16
         01:C6F7  C2         			cly
 4603                        		__pusharg.wr
         01:C6F8  A6 8D      			ldx	<__sp
         01:C6FA  CA         			dex
         01:C6FB  CA         			dex
         01:C6FC  95 08      			sta.l	<__stack, x
         01:C6FE  94 09      			sty.h	<__stack, x
         01:C700  86 8D      			stx	<__sp
 4604                        		__ld.wi		16
         01:C702  A9 10      			lda.l	#16
         01:C704  C2         			cly
 4605                        		__pusharg.wr
         01:C705  A6 8D      			ldx	<__sp
         01:C707  CA         			dex
         01:C708  CA         			dex
         01:C709  95 08      			sta.l	<__stack, x
         01:C70B  94 09      			sty.h	<__stack, x
         01:C70D  86 8D      			stx	<__sp
 4606                        		__call		_check_BG
         01:C70F  20 81 FF   			call	_check_BG
 4607                        	
 4608                        		.dbg	line,	"include\routines_LEVELS.c", 692; // IF PLAYER HITS THE LADDER //
 4609                        	
 4610                        		.dbg	line,	"include\routines_LEVELS.c", 693; if(map_blk_flag == TILE_LADDER)
 4611                        		__ld.umq	_map_blk_flag
         01:C712  AD E9 29   			lda	_map_blk_flag
 4612                        		__equ_b.uiq	2
         01:C715  C9 02      			cmp	#2
         01:C717  F0 01      			beq	!+
         01:C719  18         			clc
         01:C71A             	!:
 4613                        		__bfalse	.LL155
         01:C71A  B0 03 4C 09			bcc	.LL155
         01:C71E  D6          
 4614                        	
 4615                        		.dbg	line,	"include\routines_LEVELS.c", 694; {
 4616                        	
 4617                        		.dbg	line,	"include\routines_LEVELS.c", 695; // CAMERA GOES 8 PX BACKWARD //
 4618                        	
 4619                        		.dbg	line,	"include\routines_LEVELS.c", 696; sgx_map_pxl_x = ( (sgx_map_pxl_x >> 3) << 3 );
 4620                        		__ld.wm		_sgx_map_pxl_x
         01:C71F  AD C8 24   			lda.l	_sgx_map_pxl_x
         01:C722  AC C9 24   			ldy.h	_sgx_map_pxl_x
 4621                        		__lsr.wi	3
         01:C725  84 00      			sty	__temp
         01:C727  20 3A E2   			jsr	lsrw3
 4622                        		__asl.wi	3
         01:C72A  84 00      			sty	__temp
         01:C72C  20 D7 E1   			jsr	aslw3
 4623                        		__st.wmq	_sgx_map_pxl_x
         01:C72F  8D C8 24   			sta.l	_sgx_map_pxl_x
         01:C732  8C C9 24   			sty.h	_sgx_map_pxl_x
 4624                        	
 4625                        		.dbg	line,	"include\routines_LEVELS.c", 698; // SO WE UPDATE THE MAP //
 4626                        	
 4627                        		.dbg	line,	"include\routines_LEVELS.c", 699; sgx_scroll_map();
 4628                        		__call		_sgx_scroll_map
         01:C735  20 95 FF   			call	_sgx_scroll_map
 4629                        	
 4630                        		.dbg	line,	"include\routines_LEVELS.c", 701; // CHECK IF THE PLAYER STANDS RIGHT TO THE LADDER //
 4631                        	
 4632                        		.dbg	line,	"include\routines_LEVELS.c", 702; check_BG( 31 , 16 );
 4633                        		__ld.wi		31
         01:C738  A9 1F      			lda.l	#31
         01:C73A  C2         			cly
 4634                        		__pusharg.wr
         01:C73B  A6 8D      			ldx	<__sp
         01:C73D  CA         			dex
         01:C73E  CA         			dex
         01:C73F  95 08      			sta.l	<__stack, x
         01:C741  94 09      			sty.h	<__stack, x
         01:C743  86 8D      			stx	<__sp
 4635                        		__ld.wi		16
         01:C745  A9 10      			lda.l	#16
         01:C747  C2         			cly
 4636                        		__pusharg.wr
         01:C748  A6 8D      			ldx	<__sp
         01:C74A  CA         			dex
         01:C74B  CA         			dex
         01:C74C  95 08      			sta.l	<__stack, x
         01:C74E  94 09      			sty.h	<__stack, x
         01:C750  86 8D      			stx	<__sp
 4637                        		__call		_check_BG
         01:C752  20 81 FF   			call	_check_BG
 4638                        	
 4639                        		.dbg	line,	"include\routines_LEVELS.c", 704; if(map_blk_flag == TILE_LADDER)
 4640                        		__ld.umq	_map_blk_flag
         01:C755  AD E9 29   			lda	_map_blk_flag
 4641                        		__equ_b.uiq	2
         01:C758  C9 02      			cmp	#2
         01:C75A  F0 01      			beq	!+
         01:C75C  18         			clc
         01:C75D             	!:
 4642                        		__bfalse	.LL156
         01:C75D  90 0E      			bcc	.LL156
 4643                        	
 4644                        		.dbg	line,	"include\routines_LEVELS.c", 705; {
 4645                        	
 4646                        		.dbg	line,	"include\routines_LEVELS.c", 706; sgx_map_pxl_x += 8;
 4647                        		__add_st.wmiq	8, _sgx_map_pxl_x
         01:C75F  18         			clc
         01:C760  AD C8 24   			lda.l	_sgx_map_pxl_x
         01:C763  69 08      			adc.l	#8
         01:C765  8D C8 24   			sta.l	_sgx_map_pxl_x
         01:C768  90 03      			bcc	!+
         01:C76A  EE C9 24   			inc.h	_sgx_map_pxl_x
         01:C76D             	!:
 4648                        	
 4649                        		.dbg	line,	"include\routines_LEVELS.c", 707; }
 4650                        	
 4651                        		.dbg	line,	"include\routines_LEVELS.c", 709; player_counter_anim = 1;
 4652    01:C76D             	.LL156:
 4653                        		__st.umiq	1, _player_counter_anim
         01:C76D  A9 01      			lda.l	#1
         01:C76F  8D 12 23   			sta	_player_counter_anim
 4654                        	
 4655                        		.dbg	line,	"include\routines_LEVELS.c", 710; player_index_jump = 0;
 4656                        		__st.umiq	0, _player_index_jump
         01:C772  9C 13 23   			stz	_player_index_jump
 4657                        	
 4658                        		.dbg	line,	"include\routines_LEVELS.c", 711; jump_ladder = TRUE;
 4659                        		__st.umiq	1, _jump_ladder
         01:C775  A9 01      			lda.l	#1
         01:C777  8D 15 23   			sta	_jump_ladder
 4660                        	
 4661                        		.dbg	line,	"include\routines_LEVELS.c", 712; player_state = STATE_HANG;
 4662                        		__st.umiq	10, _player_state
         01:C77A  A9 0A      			lda.l	#10
         01:C77C  8D 0F 23   			sta	_player_state
 4663                        	
 4664                        		.dbg	line,	"include\routines_LEVELS.c", 713; }
 4665                        	
 4666                        		.dbg	line,	"include\routines_LEVELS.c", 714; }
 4667    01:C77F             	.LL155	.alias		.LL157
 4668                        	
 4669                        		.dbg	line,	"include\routines_LEVELS.c", 717; else if(player_state == STATE_JUMP_RIGHT)
 4670                        		__bra		.LL157
         01:C77F  4C 09 D6   			bra	.LL157
 4671    01:C782             	.LL132:
 4672                        		__ld.umq	_player_state
         01:C782  AD 0F 23   			lda	_player_state
 4673                        		__equ_b.uiq	5
         01:C785  C9 05      			cmp	#5
         01:C787  F0 01      			beq	!+
         01:C789  18         			clc
         01:C78A             	!:
 4674                        		__bfalse	.LL158
         01:C78A  B0 03 4C AD			bcc	.LL158
         01:C78E  CB          
 4675                        	
 4676                        		.dbg	line,	"include\routines_LEVELS.c", 718; {
 4677                        	
 4678                        		.dbg	line,	"include\routines_LEVELS.c", 719; unsigned char i, camera_y_move;
 4679                        	
 4680                        		.dbg	line,	"include\routines_LEVELS.c", 720; i = 1;
 4681                        		__st.umiq	1, __update_PLAYER_end - 2  /* i */
         01:C78F  A9 01      			lda.l	#1
         01:C791  8D 08 23   			sta	__update_PLAYER_end - 2
 4682                        	
 4683                        		.dbg	line,	"include\routines_LEVELS.c", 723; // UPDATE PLAYER TILES //
 4684                        	
 4685                        		.dbg	line,	"include\routines_LEVELS.c", 724; if(player_counter_anim == 0)
 4686                        		__not.um	_player_counter_anim
         01:C794  AD 12 23   			lda	_player_counter_anim
         01:C797  18         			clc
         01:C798  D0 01      			bne	!+
         01:C79A  38         			sec
         01:C79B             	!:
 4687                        		__bfalse	.LL159
         01:C79B  90 21      			bcc	.LL159
 4688                        	
 4689                        		.dbg	line,	"include\routines_LEVELS.c", 725; {
 4690                        	
 4691                        		.dbg	line,	"include\routines_LEVELS.c", 726; load_vram(PLAYER_VRAM_ADR, tiles_SPR_PLAYER + TILES_112 , TILES_16);
 4692                        		__st.wmiq	6144, _di
         01:C79D  64 F0      			stz.l	_di
         01:C79F  A9 18      			lda.h	#6144
         01:C7A1  85 F1      			sta.h	_di
 4693                        		__farptr	_tiles_SPR_PLAYER + 3584, _bp_bank, _bp
         01:C7A3  A9 A0      			lda.l	#$6000 + ($1FFF & (_tiles_SPR_PLAYER + 3584))
         01:C7A5  85 EC      			sta.l	_bp
         01:C7A7  A9 68      			lda.h	#$6000 + ($1FFF & (_tiles_SPR_PLAYER + 3584))
         01:C7A9  85 ED      			sta.h	_bp
         01:C7AB  A9 0C      			lda	#bank(_tiles_SPR_PLAYER + 3584)
         01:C7AD  85 02      			sta	_bp_bank
 4694                        		__st.wmiq	256, _ax
         01:C7AF  64 F8      			stz.l	_ax
         01:C7B1  A9 01      			lda.h	#256
         01:C7B3  85 F9      			sta.h	_ax
 4695                        		 _load_vram.3
         01:C7B5  82         			clx				; Offset to PCE VDC.
         01:C7B6  20 77 FF   			call	load_vram_x
 4696                        	
 4697                        		.dbg	line,	"include\routines_LEVELS.c", 728; player_counter_anim = 1;
 4698                        		__st.umiq	1, _player_counter_anim
         01:C7B9  A9 01      			lda.l	#1
         01:C7BB  8D 12 23   			sta	_player_counter_anim
 4699                        	
 4700                        		.dbg	line,	"include\routines_LEVELS.c", 729; }
 4701                        	
 4702                        		.dbg	line,	"include\routines_LEVELS.c", 732; // SELECT PLAYER SPRITE //
 4703                        	
 4704                        		.dbg	line,	"include\routines_LEVELS.c", 733; spr_set(player_id);
 4705    01:C7BE             	.LL159:
 4706                        		__ld.umq	_player_id
         01:C7BE  AD 0E 23   			lda	_player_id
 4707                        		__call		_spr_set.1
         01:C7C1  20 DD E7   			call	_spr_set.1
 4708                        	
 4709                        		.dbg	line,	"include\routines_LEVELS.c", 736; //**************************************************************************************//
 4710                        	
 4711                        		.dbg	line,	"include\routines_LEVELS.c", 737; //                                        H MOVE                                        //
 4712                        	
 4713                        		.dbg	line,	"include\routines_LEVELS.c", 738; //**************************************************************************************//
 4714                        	
 4715                        		.dbg	line,	"include\routines_LEVELS.c", 740; //--------------------------------------------------------------------------------------//
 4716                        	
 4717                        		.dbg	line,	"include\routines_LEVELS.c", 741; //                                    WALL COLLISION                                    //
 4718                        	
 4719                        		.dbg	line,	"include\routines_LEVELS.c", 742; //--------------------------------------------------------------------------------------//
 4720                        	
 4721                        		.dbg	line,	"include\routines_LEVELS.c", 744; // CHECK COLLISION WITH BOTTOM RIGHT WALL //
 4722                        	
 4723                        		.dbg	line,	"include\routines_LEVELS.c", 745; check_BG( 24 , 31 );
 4724                        		__ld.wi		24
         01:C7C4  A9 18      			lda.l	#24
         01:C7C6  C2         			cly
 4725                        		__pusharg.wr
         01:C7C7  A6 8D      			ldx	<__sp
         01:C7C9  CA         			dex
         01:C7CA  CA         			dex
         01:C7CB  95 08      			sta.l	<__stack, x
         01:C7CD  94 09      			sty.h	<__stack, x
         01:C7CF  86 8D      			stx	<__sp
 4726                        		__ld.wi		31
         01:C7D1  A9 1F      			lda.l	#31
         01:C7D3  C2         			cly
 4727                        		__pusharg.wr
         01:C7D4  A6 8D      			ldx	<__sp
         01:C7D6  CA         			dex
         01:C7D7  CA         			dex
         01:C7D8  95 08      			sta.l	<__stack, x
         01:C7DA  94 09      			sty.h	<__stack, x
         01:C7DC  86 8D      			stx	<__sp
 4728                        		__call		_check_BG
         01:C7DE  20 81 FF   			call	_check_BG
 4729                        	
 4730                        		.dbg	line,	"include\routines_LEVELS.c", 747; if(map_blk_flag != TILE_BG)
 4731                        		__ld.umq	_map_blk_flag
         01:C7E1  AD E9 29   			lda	_map_blk_flag
 4732                        		__neq_b.uiq	1
         01:C7E4  38         			sec
         01:C7E5  49 01      			eor	#1
         01:C7E7  D0 01      			bne	!+
         01:C7E9  18         			clc
         01:C7EA             	!:
 4733                        		__bfalse	.LL160
         01:C7EA  90 78      			bcc	.LL160
 4734                        	
 4735                        		.dbg	line,	"include\routines_LEVELS.c", 748; {
 4736                        	
 4737                        		.dbg	line,	"include\routines_LEVELS.c", 749; // CHECK COLLISION WITH TOP RIGHT WALL //
 4738                        	
 4739                        		.dbg	line,	"include\routines_LEVELS.c", 750; check_BG( 24 , 15 );
 4740                        		__ld.wi		24
         01:C7EC  A9 18      			lda.l	#24
         01:C7EE  C2         			cly
 4741                        		__pusharg.wr
         01:C7EF  A6 8D      			ldx	<__sp
         01:C7F1  CA         			dex
         01:C7F2  CA         			dex
         01:C7F3  95 08      			sta.l	<__stack, x
         01:C7F5  94 09      			sty.h	<__stack, x
         01:C7F7  86 8D      			stx	<__sp
 4742                        		__ld.wi		15
         01:C7F9  A9 0F      			lda.l	#15
         01:C7FB  C2         			cly
 4743                        		__pusharg.wr
         01:C7FC  A6 8D      			ldx	<__sp
         01:C7FE  CA         			dex
         01:C7FF  CA         			dex
         01:C800  95 08      			sta.l	<__stack, x
         01:C802  94 09      			sty.h	<__stack, x
         01:C804  86 8D      			stx	<__sp
 4744                        		__call		_check_BG
         01:C806  20 81 FF   			call	_check_BG
 4745                        	
 4746                        		.dbg	line,	"include\routines_LEVELS.c", 752; if(map_blk_flag == TILE_BG)
 4747                        		__ld.umq	_map_blk_flag
         01:C809  AD E9 29   			lda	_map_blk_flag
 4748                        		__equ_b.uiq	1
         01:C80C  C9 01      			cmp	#1
         01:C80E  F0 01      			beq	!+
         01:C810  18         			clc
         01:C811             	!:
 4749                        		__bfalse	.LL161
         01:C811  90 41      			bcc	.LL161
 4750                        	
 4751                        		.dbg	line,	"include\routines_LEVELS.c", 753; {
 4752                        	
 4753                        		.dbg	line,	"include\routines_LEVELS.c", 754; check_TILE_DEPTH( 15 , -16 );
 4754                        		__ld.wi		15
         01:C813  A9 0F      			lda.l	#15
         01:C815  C2         			cly
 4755                        		__pusharg.wr
         01:C816  A6 8D      			ldx	<__sp
         01:C818  CA         			dex
         01:C819  CA         			dex
         01:C81A  95 08      			sta.l	<__stack, x
         01:C81C  94 09      			sty.h	<__stack, x
         01:C81E  86 8D      			stx	<__sp
 4756                        		__ld.wi		-16
         01:C820  A9 F0      			lda.l	#-16
         01:C822  A0 FF      			ldy.h	#-16
 4757                        		__pusharg.wr
         01:C824  A6 8D      			ldx	<__sp
         01:C826  CA         			dex
         01:C827  CA         			dex
         01:C828  95 08      			sta.l	<__stack, x
         01:C82A  94 09      			sty.h	<__stack, x
         01:C82C  86 8D      			stx	<__sp
 4758                        		__call		_check_TILE_DEPTH
         01:C82E  20 63 FF   			call	_check_TILE_DEPTH
 4759                        	
 4760                        		.dbg	line,	"include\routines_LEVELS.c", 756; if(map_blk_flag == TILE_EMPTY && jump_ladder == TRUE)
 4761                        		__not.um	_map_blk_flag
         01:C831  AD E9 29   			lda	_map_blk_flag
         01:C834  18         			clc
         01:C835  D0 01      			bne	!+
         01:C837  38         			sec
         01:C838             	!:
 4762                        		__bfalse	.LL163
         01:C838  90 08      			bcc	.LL163
 4763                        		__ld.umq	_jump_ladder
         01:C83A  AD 15 23   			lda	_jump_ladder
 4764                        		__equ_b.uiq	1
         01:C83D  C9 01      			cmp	#1
         01:C83F  F0 01      			beq	!+
         01:C841  18         			clc
         01:C842             	!:
 4765    01:C842             	.LL163:
 4766                        		__bfalse	.LL162
         01:C842  90 5F      			bcc	.LL162
 4767                        	
 4768                        		.dbg	line,	"include\routines_LEVELS.c", 757; {
 4769                        	
 4770                        		.dbg	line,	"include\routines_LEVELS.c", 758; jump_ladder = FALSE;
 4771                        		__st.umiq	0, _jump_ladder
         01:C844  9C 15 23   			stz	_jump_ladder
 4772                        	
 4773                        		.dbg	line,	"include\routines_LEVELS.c", 759; player_index_fall = 0;
 4774                        		__st.umiq	0, _player_index_fall
         01:C847  9C 14 23   			stz	_player_index_fall
 4775                        	
 4776                        		.dbg	line,	"include\routines_LEVELS.c", 760; player_state = STATE_FALL;
 4777                        		__st.umiq	9, _player_state
         01:C84A  A9 09      			lda.l	#9
         01:C84C  8D 0F 23   			sta	_player_state
 4778                        	
 4779                        		.dbg	line,	"include\routines_LEVELS.c", 761; return;
 4780                        		__bra		.LL95
         01:C84F  4C 09 D6   			bra	.LL95
 4781                        	
 4782                        		.dbg	line,	"include\routines_LEVELS.c", 762; }
 4783                        	
 4784                        		.dbg	line,	"include\routines_LEVELS.c", 763; }
 4785    01:C852             	.LL162	.alias		.LL164
 4786                        	
 4787                        		.dbg	line,	"include\routines_LEVELS.c", 765; else
 4788                        		__bra		.LL164
         01:C852  80 4F      			bra	.LL164
 4789    01:C854             	.LL161:
 4790                        	
 4791                        		.dbg	line,	"include\routines_LEVELS.c", 766; {
 4792                        	
 4793                        		.dbg	line,	"include\routines_LEVELS.c", 767; sgx_map_pxl_x += 2;
 4794                        		__add_st.wmiq	2, _sgx_map_pxl_x
         01:C854  18         			clc
         01:C855  AD C8 24   			lda.l	_sgx_map_pxl_x
         01:C858  69 02      			adc.l	#2
         01:C85A  8D C8 24   			sta.l	_sgx_map_pxl_x
         01:C85D  90 03      			bcc	!+
         01:C85F  EE C9 24   			inc.h	_sgx_map_pxl_x
         01:C862             	!:
 4795                        	
 4796                        		.dbg	line,	"include\routines_LEVELS.c", 768; }
 4797    01:C862             	.LL164	.alias		.LL165
 4798                        	
 4799                        		.dbg	line,	"include\routines_LEVELS.c", 769; }
 4800                        	
 4801                        		.dbg	line,	"include\routines_LEVELS.c", 771; else
 4802                        		__bra		.LL165
         01:C862  80 3F      			bra	.LL165
 4803    01:C864             	.LL160:
 4804                        	
 4805                        		.dbg	line,	"include\routines_LEVELS.c", 772; {
 4806                        	
 4807                        		.dbg	line,	"include\routines_LEVELS.c", 773; check_TILE_DEPTH( 15 , -16 );
 4808                        		__ld.wi		15
         01:C864  A9 0F      			lda.l	#15
         01:C866  C2         			cly
 4809                        		__pusharg.wr
         01:C867  A6 8D      			ldx	<__sp
         01:C869  CA         			dex
         01:C86A  CA         			dex
         01:C86B  95 08      			sta.l	<__stack, x
         01:C86D  94 09      			sty.h	<__stack, x
         01:C86F  86 8D      			stx	<__sp
 4810                        		__ld.wi		-16
         01:C871  A9 F0      			lda.l	#-16
         01:C873  A0 FF      			ldy.h	#-16
 4811                        		__pusharg.wr
         01:C875  A6 8D      			ldx	<__sp
         01:C877  CA         			dex
         01:C878  CA         			dex
         01:C879  95 08      			sta.l	<__stack, x
         01:C87B  94 09      			sty.h	<__stack, x
         01:C87D  86 8D      			stx	<__sp
 4812                        		__call		_check_TILE_DEPTH
         01:C87F  20 63 FF   			call	_check_TILE_DEPTH
 4813                        	
 4814                        		.dbg	line,	"include\routines_LEVELS.c", 775; if(map_blk_flag == TILE_EMPTY && jump_ladder == TRUE)
 4815                        		__not.um	_map_blk_flag
         01:C882  AD E9 29   			lda	_map_blk_flag
         01:C885  18         			clc
         01:C886  D0 01      			bne	!+
         01:C888  38         			sec
         01:C889             	!:
 4816                        		__bfalse	.LL167
         01:C889  90 08      			bcc	.LL167
 4817                        		__ld.umq	_jump_ladder
         01:C88B  AD 15 23   			lda	_jump_ladder
 4818                        		__equ_b.uiq	1
         01:C88E  C9 01      			cmp	#1
         01:C890  F0 01      			beq	!+
         01:C892  18         			clc
         01:C893             	!:
 4819    01:C893             	.LL167:
 4820                        		__bfalse	.LL166
         01:C893  90 0E      			bcc	.LL166
 4821                        	
 4822                        		.dbg	line,	"include\routines_LEVELS.c", 776; {
 4823                        	
 4824                        		.dbg	line,	"include\routines_LEVELS.c", 777; jump_ladder = FALSE;
 4825                        		__st.umiq	0, _jump_ladder
         01:C895  9C 15 23   			stz	_jump_ladder
 4826                        	
 4827                        		.dbg	line,	"include\routines_LEVELS.c", 778; player_index_fall = 0;
 4828                        		__st.umiq	0, _player_index_fall
         01:C898  9C 14 23   			stz	_player_index_fall
 4829                        	
 4830                        		.dbg	line,	"include\routines_LEVELS.c", 779; player_state = STATE_FALL;
 4831                        		__st.umiq	9, _player_state
         01:C89B  A9 09      			lda.l	#9
         01:C89D  8D 0F 23   			sta	_player_state
 4832                        	
 4833                        		.dbg	line,	"include\routines_LEVELS.c", 780; return;
 4834                        		__bra		.LL95
         01:C8A0  4C 09 D6   			bra	.LL95
 4835                        	
 4836                        		.dbg	line,	"include\routines_LEVELS.c", 781; }
 4837                        	
 4838                        		.dbg	line,	"include\routines_LEVELS.c", 782; }
 4839    01:C8A3             	.LL166:
 4840    01:C8A3             	.LL165:
 4841                        	
 4842                        		.dbg	line,	"include\routines_LEVELS.c", 787; //**************************************************************************************//
 4843                        	
 4844                        		.dbg	line,	"include\routines_LEVELS.c", 788; //                                        V MOVE                                        //
 4845                        	
 4846                        		.dbg	line,	"include\routines_LEVELS.c", 789; //**************************************************************************************//
 4847                        	
 4848                        		.dbg	line,	"include\routines_LEVELS.c", 791; // UPDATE PLAYER Y POSITION //
 4849                        	
 4850                        		.dbg	line,	"include\routines_LEVELS.c", 792; if(jump_ladder == FALSE)
 4851                        		__not.um	_jump_ladder
         01:C8A3  AD 15 23   			lda	_jump_ladder
         01:C8A6  18         			clc
         01:C8A7  D0 01      			bne	!+
         01:C8A9  38         			sec
         01:C8AA             	!:
 4852                        		__bfalse	.LL168
         01:C8AA  90 1A      			bcc	.LL168
 4853                        	
 4854                        		.dbg	line,	"include\routines_LEVELS.c", 793; {
 4855                        	
 4856                        		.dbg	line,	"include\routines_LEVELS.c", 794; player_pos_y += TABLE_PLAYER_JUMP_V[player_index_jump];
 4857                        		__ldx.umq	_player_index_jump
         01:C8AC  AE 13 23   			ldx	_player_index_jump
 4858                        		__ld.bax	_TABLE_PLAYER_JUMP_V
         01:C8AF  BD 9A 60   			lda	_TABLE_PLAYER_JUMP_V, x
         01:C8B2  C2         			cly
         01:C8B3  10 01      			bpl	!+
         01:C8B5  88         			dey
         01:C8B6             	!:
 4859                        		__add_st.wmq	_player_pos_y
         01:C8B6  18         			clc
         01:C8B7  6D 1A 23   			adc.l	_player_pos_y
         01:C8BA  8D 1A 23   			sta.l	_player_pos_y
         01:C8BD  98         			tya
         01:C8BE  6D 1B 23   			adc.h	_player_pos_y
         01:C8C1  8D 1B 23   			sta.h	_player_pos_y
 4860                        	
 4861                        		.dbg	line,	"include\routines_LEVELS.c", 795; }
 4862                        	
 4863                        		.dbg	line,	"include\routines_LEVELS.c", 797; else
 4864                        		__bra		.LL169
         01:C8C4  80 18      			bra	.LL169
 4865    01:C8C6             	.LL168:
 4866                        	
 4867                        		.dbg	line,	"include\routines_LEVELS.c", 798; {
 4868                        	
 4869                        		.dbg	line,	"include\routines_LEVELS.c", 799; player_pos_y += TABLE_PLAYER_JUMP_LADDER[player_index_jump];
 4870                        		__ldx.umq	_player_index_jump
         01:C8C6  AE 13 23   			ldx	_player_index_jump
 4871                        		__ld.bax	_TABLE_PLAYER_JUMP_LADDER
         01:C8C9  BD D2 60   			lda	_TABLE_PLAYER_JUMP_LADDER, x
         01:C8CC  C2         			cly
         01:C8CD  10 01      			bpl	!+
         01:C8CF  88         			dey
         01:C8D0             	!:
 4872                        		__add_st.wmq	_player_pos_y
         01:C8D0  18         			clc
         01:C8D1  6D 1A 23   			adc.l	_player_pos_y
         01:C8D4  8D 1A 23   			sta.l	_player_pos_y
         01:C8D7  98         			tya
         01:C8D8  6D 1B 23   			adc.h	_player_pos_y
         01:C8DB  8D 1B 23   			sta.h	_player_pos_y
 4873                        	
 4874                        		.dbg	line,	"include\routines_LEVELS.c", 800; }
 4875    01:C8DE             	.LL169:
 4876                        	
 4877                        		.dbg	line,	"include\routines_LEVELS.c", 804; // IF PLAYER GOES BELOW ITS BASE Y POSITION //
 4878                        	
 4879                        		.dbg	line,	"include\routines_LEVELS.c", 805; if(player_pos_y >= PLAYER_BASE_Y_POS)
 4880                        		__ld.wm		_player_pos_y
         01:C8DE  AD 1A 23   			lda.l	_player_pos_y
         01:C8E1  AC 1B 23   			ldy.h	_player_pos_y
 4881                        		__sge_w.wi	128
         01:C8E4  C9 80      			cmp.l	#128		; Subtract integer from Y:A.
         01:C8E6  98         			tya
         01:C8E7  E9 00      			sbc.h	#128
         01:C8E9  50 02      			bvc	!+
         01:C8EB  49 80      			eor	#$80		; +ve if Y:A >= integer (signed).
         01:C8ED  49 80      	!:		eor	#$80
         01:C8EF  0A         			asl	a
 4882                        		__bfalse	.LL170
         01:C8F0  90 4E      			bcc	.LL170
 4883                        	
 4884                        		.dbg	line,	"include\routines_LEVELS.c", 806; {
 4885                        	
 4886                        		.dbg	line,	"include\routines_LEVELS.c", 807; // THE CAMERA MOVES //
 4887                        	
 4888                        		.dbg	line,	"include\routines_LEVELS.c", 808; // CALCULATE HOW MANY PIXELS THE CAMERA HAS TO MOVE DOWN //
 4889                        	
 4890                        		.dbg	line,	"include\routines_LEVELS.c", 809; camera_y_move = player_pos_y - PLAYER_BASE_Y_POS;
 4891                        		__ld.wm		_player_pos_y
         01:C8F2  AD 1A 23   			lda.l	_player_pos_y
         01:C8F5  AC 1B 23   			ldy.h	_player_pos_y
 4892                        		__sub.wi	128
         01:C8F8  38         			sec
         01:C8F9  E9 80      			sbc.l	#128
         01:C8FB  B0 01      			bcs	!+
         01:C8FD  88         			dey
         01:C8FE             	!:
 4893                        		__st.umq	__update_PLAYER_end - 3  /* camera_y_move */
         01:C8FE  8D 07 23   			sta	__update_PLAYER_end - 3
 4894                        	
 4895                        		.dbg	line,	"include\routines_LEVELS.c", 810; sgx_map_pxl_y += camera_y_move;
 4896                        		__ld.um		__update_PLAYER_end - 3  /* camera_y_move */
         01:C901  AD 07 23   			lda	__update_PLAYER_end - 3
         01:C904  C2         			cly
 4897                        		__add_st.wmq	_sgx_map_pxl_y
         01:C905  18         			clc
         01:C906  6D CA 24   			adc.l	_sgx_map_pxl_y
         01:C909  8D CA 24   			sta.l	_sgx_map_pxl_y
         01:C90C  98         			tya
         01:C90D  6D CB 24   			adc.h	_sgx_map_pxl_y
         01:C910  8D CB 24   			sta.h	_sgx_map_pxl_y
 4898                        	
 4899                        		.dbg	line,	"include\routines_LEVELS.c", 812; // IF THE CAMERA HAS REACHED ITS MAX (LOWEST) POSITION //
 4900                        	
 4901                        		.dbg	line,	"include\routines_LEVELS.c", 813; if(sgx_map_pxl_y > camera_max_y_position)
 4902                        		__ld.wm		_sgx_map_pxl_y
         01:C913  AD CA 24   			lda.l	_sgx_map_pxl_y
         01:C916  AC CB 24   			ldy.h	_sgx_map_pxl_y
 4903                        		__ugt_w.wm	_camera_max_y_position
         01:C919  18         			clc			; Subtract memory+1 from Y:A.
         01:C91A  ED 1C 23   			sbc.l	_camera_max_y_position
         01:C91D  98         			tya
         01:C91E  ED 1D 23   			sbc.h	_camera_max_y_position		; CS if Y:A > memory.
 4904                        		__bfalse	.LL171
         01:C921  90 0C      			bcc	.LL171
 4905                        	
 4906                        		.dbg	line,	"include\routines_LEVELS.c", 814; {
 4907                        	
 4908                        		.dbg	line,	"include\routines_LEVELS.c", 815; // THE CAMERA CAN NOT MOVE LOWER //
 4909                        	
 4910                        		.dbg	line,	"include\routines_LEVELS.c", 816; sgx_map_pxl_y = camera_max_y_position;
 4911                        		__ld.wm		_camera_max_y_position
         01:C923  AD 1C 23   			lda.l	_camera_max_y_position
         01:C926  AC 1D 23   			ldy.h	_camera_max_y_position
 4912                        		__st.wmq	_sgx_map_pxl_y
         01:C929  8D CA 24   			sta.l	_sgx_map_pxl_y
         01:C92C  8C CB 24   			sty.h	_sgx_map_pxl_y
 4913                        	
 4914                        		.dbg	line,	"include\routines_LEVELS.c", 817; }
 4915                        	
 4916                        		.dbg	line,	"include\routines_LEVELS.c", 819; // THE PLAYER STAYS AT ITS BASE Y POSITION //
 4917                        	
 4918                        		.dbg	line,	"include\routines_LEVELS.c", 820; player_pos_y = PLAYER_BASE_Y_POS;
 4919    01:C92F             	.LL171:
 4920                        		__st.wmiq	128, _player_pos_y
         01:C92F  A9 80      			lda.l	#128
         01:C931  8D 1A 23   			sta.l	_player_pos_y
         01:C934  9C 1B 23   			stz.h	_player_pos_y
 4921                        	
 4922                        		.dbg	line,	"include\routines_LEVELS.c", 822; spr_y(player_pos_y);
 4923                        		__ld.wm		_player_pos_y
         01:C937  AD 1A 23   			lda.l	_player_pos_y
         01:C93A  AC 1B 23   			ldy.h	_player_pos_y
 4924                        		__call		_spr_y.1
         01:C93D  20 19 E8   			call	_spr_y.1
 4925                        	
 4926                        		.dbg	line,	"include\routines_LEVELS.c", 823; }
 4927                        	
 4928                        		.dbg	line,	"include\routines_LEVELS.c", 826; // UPDATE JUMP INDEX IN THE ARRAY //
 4929                        	
 4930                        		.dbg	line,	"include\routines_LEVELS.c", 827; if(player_index_jump < jump_max_index)
 4931    01:C940             	.LL170:
 4932                        		__ld.umq	_player_index_jump
         01:C940  AD 13 23   			lda	_player_index_jump
 4933                        		__ult_b.umq	_jump_max_index
         01:C943  CD 16 23   			cmp	_jump_max_index		; Subtract memory from A.
         01:C946  6A         			ror	a		; CC if A < memory.
         01:C947  49 80      			eor	#$80
         01:C949  2A         			rol	a
 4934                        		__bfalse	.LL172
         01:C94A  90 03      			bcc	.LL172
 4935                        	
 4936                        		.dbg	line,	"include\routines_LEVELS.c", 828; {
 4937                        	
 4938                        		.dbg	line,	"include\routines_LEVELS.c", 829; player_index_jump += 1;
 4939                        		__add_st.umiq	1, _player_index_jump
         01:C94C  EE 13 23   			inc	_player_index_jump
 4940                        	
 4941                        		.dbg	line,	"include\routines_LEVELS.c", 830; }
 4942                        	
 4943                        		.dbg	line,	"include\routines_LEVELS.c", 835; //--------------------------------------------------------------------------------------//
 4944                        	
 4945                        		.dbg	line,	"include\routines_LEVELS.c", 836; //                                   FLOOR COLLISION                                    //
 4946                        	
 4947                        		.dbg	line,	"include\routines_LEVELS.c", 837; //--------------------------------------------------------------------------------------//
 4948                        	
 4949                        		.dbg	line,	"include\routines_LEVELS.c", 839; if(player_index_jump > 14)
 4950    01:C94F             	.LL172:
 4951                        		__ld.umq	_player_index_jump
         01:C94F  AD 13 23   			lda	_player_index_jump
 4952                        		__ugt_b.uiq	14
         01:C952  18         			clc			; Subtract integer+1 from A.
         01:C953  E9 0E      			sbc	#14		; CS if A > integer.
 4953                        		__bfalse	.LL173
         01:C955  B0 03 4C 0A			bcc	.LL173
         01:C959  CB          
 4954                        	
 4955                        		.dbg	line,	"include\routines_LEVELS.c", 840; {
 4956                        	
 4957                        		.dbg	line,	"include\routines_LEVELS.c", 841; // CHECK COLLISION WITH LEFT FLOOR //
 4958                        	
 4959                        		.dbg	line,	"include\routines_LEVELS.c", 842; check_BG( 10 , 32 );
 4960                        		__ld.wi		10
         01:C95A  A9 0A      			lda.l	#10
         01:C95C  C2         			cly
 4961                        		__pusharg.wr
         01:C95D  A6 8D      			ldx	<__sp
         01:C95F  CA         			dex
         01:C960  CA         			dex
         01:C961  95 08      			sta.l	<__stack, x
         01:C963  94 09      			sty.h	<__stack, x
         01:C965  86 8D      			stx	<__sp
 4962                        		__ld.wi		32
         01:C967  A9 20      			lda.l	#32
         01:C969  C2         			cly
 4963                        		__pusharg.wr
         01:C96A  A6 8D      			ldx	<__sp
         01:C96C  CA         			dex
         01:C96D  CA         			dex
         01:C96E  95 08      			sta.l	<__stack, x
         01:C970  94 09      			sty.h	<__stack, x
         01:C972  86 8D      			stx	<__sp
 4964                        		__call		_check_BG
         01:C974  20 81 FF   			call	_check_BG
 4965                        	
 4966                        		.dbg	line,	"include\routines_LEVELS.c", 844; // IF PLAYER TOUCHES THE GROUND TO THE LEFT //
 4967                        	
 4968                        		.dbg	line,	"include\routines_LEVELS.c", 845; if(map_blk_flag == TILE_BG)
 4969                        		__ld.umq	_map_blk_flag
         01:C977  AD E9 29   			lda	_map_blk_flag
 4970                        		__equ_b.uiq	1
         01:C97A  C9 01      			cmp	#1
         01:C97C  F0 01      			beq	!+
         01:C97E  18         			clc
         01:C97F             	!:
 4971                        		__bfalse	.LL174
         01:C97F  B0 03 4C 32			bcc	.LL174
         01:C983  CA          
 4972                        	
 4973                        		.dbg	line,	"include\routines_LEVELS.c", 846; {
 4974                        	
 4975                        		.dbg	line,	"include\routines_LEVELS.c", 847; // CALCULATE HOW MANY PIXELS THE PLAYER MOVED INTO THE GROUND //
 4976                        	
 4977                        		.dbg	line,	"include\routines_LEVELS.c", 848; for(i=1; i<11 ; i++)
 4978                        		__st.umiq	1, __update_PLAYER_end - 2  /* i */
         01:C984  A9 01      			lda.l	#1
         01:C986  8D 08 23   			sta	__update_PLAYER_end - 2
 4979    01:C989             	.LL175:
 4980                        		__ld.umq	__update_PLAYER_end - 2  /* i */
         01:C989  AD 08 23   			lda	__update_PLAYER_end - 2
 4981                        		__ult_b.uiq	11
         01:C98C  C9 0B      			cmp	#11		; Subtract integer from A.
         01:C98E  6A         			ror	a		; CC if A < integer.
         01:C98F  49 80      			eor	#$80
         01:C991  2A         			rol	a
 4982                        		__btrue		.LL177
         01:C992  B0 07      			bcs	.LL177
 4983                        		__bra		.LL178
         01:C994  80 7D      			bra	.LL178
 4984    01:C996             	.LL176:
 4985                        		__inc.umq	__update_PLAYER_end - 2  /* i */
         01:C996  EE 08 23   			inc	__update_PLAYER_end - 2
 4986                        		__bra		.LL175
         01:C999  80 EE      			bra	.LL175
 4987    01:C99B             	.LL177:
 4988                        	
 4989                        		.dbg	line,	"include\routines_LEVELS.c", 849; {
 4990                        	
 4991                        		.dbg	line,	"include\routines_LEVELS.c", 850; check_TILE_DEPTH( 10 , i);
 4992                        		__ld.wi		10
         01:C99B  A9 0A      			lda.l	#10
         01:C99D  C2         			cly
 4993                        		__pusharg.wr
         01:C99E  A6 8D      			ldx	<__sp
         01:C9A0  CA         			dex
         01:C9A1  CA         			dex
         01:C9A2  95 08      			sta.l	<__stack, x
         01:C9A4  94 09      			sty.h	<__stack, x
         01:C9A6  86 8D      			stx	<__sp
 4994                        		__ld.um		__update_PLAYER_end - 2  /* i */
         01:C9A8  AD 08 23   			lda	__update_PLAYER_end - 2
         01:C9AB  C2         			cly
 4995                        		__pusharg.wr
         01:C9AC  A6 8D      			ldx	<__sp
         01:C9AE  CA         			dex
         01:C9AF  CA         			dex
         01:C9B0  95 08      			sta.l	<__stack, x
         01:C9B2  94 09      			sty.h	<__stack, x
         01:C9B4  86 8D      			stx	<__sp
 4996                        		__call		_check_TILE_DEPTH
         01:C9B6  20 63 FF   			call	_check_TILE_DEPTH
 4997                        	
 4998                        		.dbg	line,	"include\routines_LEVELS.c", 852; if(map_blk_flag == TILE_EMPTY)
 4999                        		__not.um	_map_blk_flag
         01:C9B9  AD E9 29   			lda	_map_blk_flag
         01:C9BC  18         			clc
         01:C9BD  D0 01      			bne	!+
         01:C9BF  38         			sec
         01:C9C0             	!:
 5000                        		__bfalse	.LL179
         01:C9C0  90 D4      			bcc	.LL179
 5001                        	
 5002                        		.dbg	line,	"include\routines_LEVELS.c", 853; {
 5003                        	
 5004                        		.dbg	line,	"include\routines_LEVELS.c", 854; if(player_pos_y != PLAYER_BASE_Y_POS)
 5005                        		__ld.wm		_player_pos_y
         01:C9C2  AD 1A 23   			lda.l	_player_pos_y
         01:C9C5  AC 1B 23   			ldy.h	_player_pos_y
 5006                        		__neq_w.wi	128
         01:C9C8  38         			sec
         01:C9C9  49 80      			eor.l	#128
         01:C9CB  D0 06      			bne	!+
         01:C9CD  98         			tya
         01:C9CE  49 00      			eor.h	#128
         01:C9D0  D0 01      			bne	!+
         01:C9D2  18         			clc
         01:C9D3             	!:
 5007                        		__bfalse	.LL180
         01:C9D3  90 1E      			bcc	.LL180
 5008                        	
 5009                        		.dbg	line,	"include\routines_LEVELS.c", 855; {
 5010                        	
 5011                        		.dbg	line,	"include\routines_LEVELS.c", 856; player_pos_y -= (i - 1);
 5012                        		__ld.um		__update_PLAYER_end - 2  /* i */
         01:C9D5  AD 08 23   			lda	__update_PLAYER_end - 2
         01:C9D8  C2         			cly
 5013                        		__sub.wi	1
         01:C9D9  38         			sec
         01:C9DA  E9 01      			sbc.l	#1
         01:C9DC  B0 01      			bcs	!+
         01:C9DE  88         			dey
         01:C9DF             	!:
 5014                        		__isub_st.wmq	_player_pos_y
         01:C9DF  38         			sec
         01:C9E0  49 FF      			eor	#$FF
         01:C9E2  6D 1A 23   			adc.l	_player_pos_y
         01:C9E5  8D 1A 23   			sta.l	_player_pos_y
         01:C9E8  98         			tya
         01:C9E9  49 FF      			eor	#$FF
         01:C9EB  6D 1B 23   			adc.h	_player_pos_y
         01:C9EE  8D 1B 23   			sta.h	_player_pos_y
 5015                        	
 5016                        		.dbg	line,	"include\routines_LEVELS.c", 857; }
 5017                        	
 5018                        		.dbg	line,	"include\routines_LEVELS.c", 859; else
 5019                        		__bra		.LL181
         01:C9F1  80 20      			bra	.LL181
 5020    01:C9F3             	.LL180:
 5021                        	
 5022                        		.dbg	line,	"include\routines_LEVELS.c", 860; {
 5023                        	
 5024                        		.dbg	line,	"include\routines_LEVELS.c", 861; sgx_map_pxl_y -= (i - 1);
 5025                        		__ld.um		__update_PLAYER_end - 2  /* i */
         01:C9F3  AD 08 23   			lda	__update_PLAYER_end - 2
         01:C9F6  C2         			cly
 5026                        		__sub.wi	1
         01:C9F7  38         			sec
         01:C9F8  E9 01      			sbc.l	#1
         01:C9FA  B0 01      			bcs	!+
         01:C9FC  88         			dey
         01:C9FD             	!:
 5027                        		__isub_st.wmq	_sgx_map_pxl_y
         01:C9FD  38         			sec
         01:C9FE  49 FF      			eor	#$FF
         01:CA00  6D CA 24   			adc.l	_sgx_map_pxl_y
         01:CA03  8D CA 24   			sta.l	_sgx_map_pxl_y
         01:CA06  98         			tya
         01:CA07  49 FF      			eor	#$FF
         01:CA09  6D CB 24   			adc.h	_sgx_map_pxl_y
         01:CA0C  8D CB 24   			sta.h	_sgx_map_pxl_y
 5028                        	
 5029                        		.dbg	line,	"include\routines_LEVELS.c", 862; }
 5030    01:CA0F             	.LL181	.alias		.LL178
 5031                        	
 5032                        		.dbg	line,	"include\routines_LEVELS.c", 864; break;
 5033                        		__bra		.LL178
         01:CA0F  80 02      			bra	.LL178
 5034                        	
 5035                        		.dbg	line,	"include\routines_LEVELS.c", 865; }
 5036                        	
 5037                        		.dbg	line,	"include\routines_LEVELS.c", 866; }
 5038    01:CA11             	.LL179	.alias		.LL176
 5039                        		__bra		.LL176
         01:CA11  80 83      			bra	.LL176
 5040    01:CA13             	.LL178:
 5041                        	
 5042                        		.dbg	line,	"include\routines_LEVELS.c", 868; // SET PLAYER SPRITE NEW POSITION //
 5043                        	
 5044                        		.dbg	line,	"include\routines_LEVELS.c", 869; spr_y(player_pos_y);
 5045                        		__ld.wm		_player_pos_y
         01:CA13  AD 1A 23   			lda.l	_player_pos_y
         01:CA16  AC 1B 23   			ldy.h	_player_pos_y
 5046                        		__call		_spr_y.1
         01:CA19  20 19 E8   			call	_spr_y.1
 5047                        	
 5048                        		.dbg	line,	"include\routines_LEVELS.c", 871; player_counter_anim = 1;
 5049                        		__st.umiq	1, _player_counter_anim
         01:CA1C  A9 01      			lda.l	#1
         01:CA1E  8D 12 23   			sta	_player_counter_anim
 5050                        	
 5051                        		.dbg	line,	"include\routines_LEVELS.c", 872; player_index_jump = 0;
 5052                        		__st.umiq	0, _player_index_jump
         01:CA21  9C 13 23   			stz	_player_index_jump
 5053                        	
 5054                        		.dbg	line,	"include\routines_LEVELS.c", 873; jump_ladder = FALSE;
 5055                        		__st.umiq	0, _jump_ladder
         01:CA24  9C 15 23   			stz	_jump_ladder
 5056                        	
 5057                        		.dbg	line,	"include\routines_LEVELS.c", 874; jump_max_index = 34;
 5058                        		__st.umiq	34, _jump_max_index
         01:CA27  A9 22      			lda.l	#34
         01:CA29  8D 16 23   			sta	_jump_max_index
 5059                        	
 5060                        		.dbg	line,	"include\routines_LEVELS.c", 875; player_state = STATE_IDLE;
 5061                        		__st.umiq	0, _player_state
         01:CA2C  9C 0F 23   			stz	_player_state
 5062                        	
 5063                        		.dbg	line,	"include\routines_LEVELS.c", 876; return;
 5064                        		__bra		.LL95
         01:CA2F  4C 09 D6   			bra	.LL95
 5065                        	
 5066                        		.dbg	line,	"include\routines_LEVELS.c", 877; }
 5067                        	
 5068                        		.dbg	line,	"include\routines_LEVELS.c", 879; // IF PLAYER TOUCHES THE GROUND TO THE RIGHT //
 5069                        	
 5070                        		.dbg	line,	"include\routines_LEVELS.c", 880; else
 5071    01:CA32             	.LL174:
 5072                        	
 5073                        		.dbg	line,	"include\routines_LEVELS.c", 881; {
 5074                        	
 5075                        		.dbg	line,	"include\routines_LEVELS.c", 882; // CHECK COLLISION WITH RIGHT FLOOR //
 5076                        	
 5077                        		.dbg	line,	"include\routines_LEVELS.c", 883; check_BG( 22 , 32 );
 5078                        		__ld.wi		22
         01:CA32  A9 16      			lda.l	#22
         01:CA34  C2         			cly
 5079                        		__pusharg.wr
         01:CA35  A6 8D      			ldx	<__sp
         01:CA37  CA         			dex
         01:CA38  CA         			dex
         01:CA39  95 08      			sta.l	<__stack, x
         01:CA3B  94 09      			sty.h	<__stack, x
         01:CA3D  86 8D      			stx	<__sp
 5080                        		__ld.wi		32
         01:CA3F  A9 20      			lda.l	#32
         01:CA41  C2         			cly
 5081                        		__pusharg.wr
         01:CA42  A6 8D      			ldx	<__sp
         01:CA44  CA         			dex
         01:CA45  CA         			dex
         01:CA46  95 08      			sta.l	<__stack, x
         01:CA48  94 09      			sty.h	<__stack, x
         01:CA4A  86 8D      			stx	<__sp
 5082                        		__call		_check_BG
         01:CA4C  20 81 FF   			call	_check_BG
 5083                        	
 5084                        		.dbg	line,	"include\routines_LEVELS.c", 885; if(map_blk_flag == TILE_BG)
 5085                        		__ld.umq	_map_blk_flag
         01:CA4F  AD E9 29   			lda	_map_blk_flag
 5086                        		__equ_b.uiq	1
         01:CA52  C9 01      			cmp	#1
         01:CA54  F0 01      			beq	!+
         01:CA56  18         			clc
         01:CA57             	!:
 5087                        		__bfalse	.LL183
         01:CA57  B0 03 4C 0A			bcc	.LL183
         01:CA5B  CB          
 5088                        	
 5089                        		.dbg	line,	"include\routines_LEVELS.c", 886; {
 5090                        	
 5091                        		.dbg	line,	"include\routines_LEVELS.c", 887; // CALCULATE HOW MANY PIXELS THE PLAYER MOVED INTO THE GROUND //
 5092                        	
 5093                        		.dbg	line,	"include\routines_LEVELS.c", 888; for(i=1; i<11 ; i++)
 5094                        		__st.umiq	1, __update_PLAYER_end - 2  /* i */
         01:CA5C  A9 01      			lda.l	#1
         01:CA5E  8D 08 23   			sta	__update_PLAYER_end - 2
 5095    01:CA61             	.LL184:
 5096                        		__ld.umq	__update_PLAYER_end - 2  /* i */
         01:CA61  AD 08 23   			lda	__update_PLAYER_end - 2
 5097                        		__ult_b.uiq	11
         01:CA64  C9 0B      			cmp	#11		; Subtract integer from A.
         01:CA66  6A         			ror	a		; CC if A < integer.
         01:CA67  49 80      			eor	#$80
         01:CA69  2A         			rol	a
 5098                        		__btrue		.LL186
         01:CA6A  B0 07      			bcs	.LL186
 5099                        		__bra		.LL187
         01:CA6C  80 7D      			bra	.LL187
 5100    01:CA6E             	.LL185:
 5101                        		__inc.umq	__update_PLAYER_end - 2  /* i */
         01:CA6E  EE 08 23   			inc	__update_PLAYER_end - 2
 5102                        		__bra		.LL184
         01:CA71  80 EE      			bra	.LL184
 5103    01:CA73             	.LL186:
 5104                        	
 5105                        		.dbg	line,	"include\routines_LEVELS.c", 889; {
 5106                        	
 5107                        		.dbg	line,	"include\routines_LEVELS.c", 890; check_TILE_DEPTH( 22 , i);
 5108                        		__ld.wi		22
         01:CA73  A9 16      			lda.l	#22
         01:CA75  C2         			cly
 5109                        		__pusharg.wr
         01:CA76  A6 8D      			ldx	<__sp
         01:CA78  CA         			dex
         01:CA79  CA         			dex
         01:CA7A  95 08      			sta.l	<__stack, x
         01:CA7C  94 09      			sty.h	<__stack, x
         01:CA7E  86 8D      			stx	<__sp
 5110                        		__ld.um		__update_PLAYER_end - 2  /* i */
         01:CA80  AD 08 23   			lda	__update_PLAYER_end - 2
         01:CA83  C2         			cly
 5111                        		__pusharg.wr
         01:CA84  A6 8D      			ldx	<__sp
         01:CA86  CA         			dex
         01:CA87  CA         			dex
         01:CA88  95 08      			sta.l	<__stack, x
         01:CA8A  94 09      			sty.h	<__stack, x
         01:CA8C  86 8D      			stx	<__sp
 5112                        		__call		_check_TILE_DEPTH
         01:CA8E  20 63 FF   			call	_check_TILE_DEPTH
 5113                        	
 5114                        		.dbg	line,	"include\routines_LEVELS.c", 892; if(map_blk_flag == TILE_EMPTY)
 5115                        		__not.um	_map_blk_flag
         01:CA91  AD E9 29   			lda	_map_blk_flag
         01:CA94  18         			clc
         01:CA95  D0 01      			bne	!+
         01:CA97  38         			sec
         01:CA98             	!:
 5116                        		__bfalse	.LL188
         01:CA98  90 D4      			bcc	.LL188
 5117                        	
 5118                        		.dbg	line,	"include\routines_LEVELS.c", 893; {
 5119                        	
 5120                        		.dbg	line,	"include\routines_LEVELS.c", 894; if(player_pos_y != PLAYER_BASE_Y_POS)
 5121                        		__ld.wm		_player_pos_y
         01:CA9A  AD 1A 23   			lda.l	_player_pos_y
         01:CA9D  AC 1B 23   			ldy.h	_player_pos_y
 5122                        		__neq_w.wi	128
         01:CAA0  38         			sec
         01:CAA1  49 80      			eor.l	#128
         01:CAA3  D0 06      			bne	!+
         01:CAA5  98         			tya
         01:CAA6  49 00      			eor.h	#128
         01:CAA8  D0 01      			bne	!+
         01:CAAA  18         			clc
         01:CAAB             	!:
 5123                        		__bfalse	.LL189
         01:CAAB  90 1E      			bcc	.LL189
 5124                        	
 5125                        		.dbg	line,	"include\routines_LEVELS.c", 895; {
 5126                        	
 5127                        		.dbg	line,	"include\routines_LEVELS.c", 896; player_pos_y -= (i - 1);
 5128                        		__ld.um		__update_PLAYER_end - 2  /* i */
         01:CAAD  AD 08 23   			lda	__update_PLAYER_end - 2
         01:CAB0  C2         			cly
 5129                        		__sub.wi	1
         01:CAB1  38         			sec
         01:CAB2  E9 01      			sbc.l	#1
         01:CAB4  B0 01      			bcs	!+
         01:CAB6  88         			dey
         01:CAB7             	!:
 5130                        		__isub_st.wmq	_player_pos_y
         01:CAB7  38         			sec
         01:CAB8  49 FF      			eor	#$FF
         01:CABA  6D 1A 23   			adc.l	_player_pos_y
         01:CABD  8D 1A 23   			sta.l	_player_pos_y
         01:CAC0  98         			tya
         01:CAC1  49 FF      			eor	#$FF
         01:CAC3  6D 1B 23   			adc.h	_player_pos_y
         01:CAC6  8D 1B 23   			sta.h	_player_pos_y
 5131                        	
 5132                        		.dbg	line,	"include\routines_LEVELS.c", 897; }
 5133                        	
 5134                        		.dbg	line,	"include\routines_LEVELS.c", 899; else
 5135                        		__bra		.LL190
         01:CAC9  80 20      			bra	.LL190
 5136    01:CACB             	.LL189:
 5137                        	
 5138                        		.dbg	line,	"include\routines_LEVELS.c", 900; {
 5139                        	
 5140                        		.dbg	line,	"include\routines_LEVELS.c", 901; sgx_map_pxl_y -= (i - 1);
 5141                        		__ld.um		__update_PLAYER_end - 2  /* i */
         01:CACB  AD 08 23   			lda	__update_PLAYER_end - 2
         01:CACE  C2         			cly
 5142                        		__sub.wi	1
         01:CACF  38         			sec
         01:CAD0  E9 01      			sbc.l	#1
         01:CAD2  B0 01      			bcs	!+
         01:CAD4  88         			dey
         01:CAD5             	!:
 5143                        		__isub_st.wmq	_sgx_map_pxl_y
         01:CAD5  38         			sec
         01:CAD6  49 FF      			eor	#$FF
         01:CAD8  6D CA 24   			adc.l	_sgx_map_pxl_y
         01:CADB  8D CA 24   			sta.l	_sgx_map_pxl_y
         01:CADE  98         			tya
         01:CADF  49 FF      			eor	#$FF
         01:CAE1  6D CB 24   			adc.h	_sgx_map_pxl_y
         01:CAE4  8D CB 24   			sta.h	_sgx_map_pxl_y
 5144                        	
 5145                        		.dbg	line,	"include\routines_LEVELS.c", 902; }
 5146    01:CAE7             	.LL190	.alias		.LL187
 5147                        	
 5148                        		.dbg	line,	"include\routines_LEVELS.c", 904; break;
 5149                        		__bra		.LL187
         01:CAE7  80 02      			bra	.LL187
 5150                        	
 5151                        		.dbg	line,	"include\routines_LEVELS.c", 905; }
 5152                        	
 5153                        		.dbg	line,	"include\routines_LEVELS.c", 906; }
 5154    01:CAE9             	.LL188	.alias		.LL185
 5155                        		__bra		.LL185
         01:CAE9  80 83      			bra	.LL185
 5156    01:CAEB             	.LL187:
 5157                        	
 5158                        		.dbg	line,	"include\routines_LEVELS.c", 908; // SET PLAYER SPRITE NEW POSITION //
 5159                        	
 5160                        		.dbg	line,	"include\routines_LEVELS.c", 909; spr_y(player_pos_y);
 5161                        		__ld.wm		_player_pos_y
         01:CAEB  AD 1A 23   			lda.l	_player_pos_y
         01:CAEE  AC 1B 23   			ldy.h	_player_pos_y
 5162                        		__call		_spr_y.1
         01:CAF1  20 19 E8   			call	_spr_y.1
 5163                        	
 5164                        		.dbg	line,	"include\routines_LEVELS.c", 911; player_counter_anim = 1;
 5165                        		__st.umiq	1, _player_counter_anim
         01:CAF4  A9 01      			lda.l	#1
         01:CAF6  8D 12 23   			sta	_player_counter_anim
 5166                        	
 5167                        		.dbg	line,	"include\routines_LEVELS.c", 912; player_index_jump = 0;
 5168                        		__st.umiq	0, _player_index_jump
         01:CAF9  9C 13 23   			stz	_player_index_jump
 5169                        	
 5170                        		.dbg	line,	"include\routines_LEVELS.c", 913; jump_ladder = FALSE;
 5171                        		__st.umiq	0, _jump_ladder
         01:CAFC  9C 15 23   			stz	_jump_ladder
 5172                        	
 5173                        		.dbg	line,	"include\routines_LEVELS.c", 914; jump_max_index = 34;
 5174                        		__st.umiq	34, _jump_max_index
         01:CAFF  A9 22      			lda.l	#34
         01:CB01  8D 16 23   			sta	_jump_max_index
 5175                        	
 5176                        		.dbg	line,	"include\routines_LEVELS.c", 915; player_state = STATE_IDLE;
 5177                        		__st.umiq	0, _player_state
         01:CB04  9C 0F 23   			stz	_player_state
 5178                        	
 5179                        		.dbg	line,	"include\routines_LEVELS.c", 916; return;
 5180                        		__bra		.LL95
         01:CB07  4C 09 D6   			bra	.LL95
 5181                        	
 5182                        		.dbg	line,	"include\routines_LEVELS.c", 917; }
 5183                        	
 5184                        		.dbg	line,	"include\routines_LEVELS.c", 918; }
 5185    01:CB0A             	.LL183:
 5186    01:CB0A             	.LL182:
 5187                        	
 5188                        		.dbg	line,	"include\routines_LEVELS.c", 919; }
 5189                        	
 5190                        		.dbg	line,	"include\routines_LEVELS.c", 924; //--------------------------------------------------------------------------------------//
 5191                        	
 5192                        		.dbg	line,	"include\routines_LEVELS.c", 925; //                                   LADDER COLLISION                                   //
 5193                        	
 5194                        		.dbg	line,	"include\routines_LEVELS.c", 926; //--------------------------------------------------------------------------------------//
 5195                        	
 5196                        		.dbg	line,	"include\routines_LEVELS.c", 928; if(player_index_jump > 4)
 5197    01:CB0A             	.LL173:
 5198                        		__ld.umq	_player_index_jump
         01:CB0A  AD 13 23   			lda	_player_index_jump
 5199                        		__ugt_b.uiq	4
         01:CB0D  18         			clc			; Subtract integer+1 from A.
         01:CB0E  E9 04      			sbc	#4		; CS if A > integer.
 5200                        		__bfalse	.LL191
         01:CB10  B0 03 4C A1			bcc	.LL191
         01:CB14  CB          
 5201                        	
 5202                        		.dbg	line,	"include\routines_LEVELS.c", 929; {
 5203                        	
 5204                        		.dbg	line,	"include\routines_LEVELS.c", 930; check_BG( 16 , 16 );
 5205                        		__ld.wi		16
         01:CB15  A9 10      			lda.l	#16
         01:CB17  C2         			cly
 5206                        		__pusharg.wr
         01:CB18  A6 8D      			ldx	<__sp
         01:CB1A  CA         			dex
         01:CB1B  CA         			dex
         01:CB1C  95 08      			sta.l	<__stack, x
         01:CB1E  94 09      			sty.h	<__stack, x
         01:CB20  86 8D      			stx	<__sp
 5207                        		__ld.wi		16
         01:CB22  A9 10      			lda.l	#16
         01:CB24  C2         			cly
 5208                        		__pusharg.wr
         01:CB25  A6 8D      			ldx	<__sp
         01:CB27  CA         			dex
         01:CB28  CA         			dex
         01:CB29  95 08      			sta.l	<__stack, x
         01:CB2B  94 09      			sty.h	<__stack, x
         01:CB2D  86 8D      			stx	<__sp
 5209                        		__call		_check_BG
         01:CB2F  20 81 FF   			call	_check_BG
 5210                        	
 5211                        		.dbg	line,	"include\routines_LEVELS.c", 932; // IF PLAYER HITS THE LADDER //
 5212                        	
 5213                        		.dbg	line,	"include\routines_LEVELS.c", 933; if(map_blk_flag == TILE_LADDER)
 5214                        		__ld.umq	_map_blk_flag
         01:CB32  AD E9 29   			lda	_map_blk_flag
 5215                        		__equ_b.uiq	2
         01:CB35  C9 02      			cmp	#2
         01:CB37  F0 01      			beq	!+
         01:CB39  18         			clc
         01:CB3A             	!:
 5216                        		__bfalse	.LL192
         01:CB3A  90 65      			bcc	.LL192
 5217                        	
 5218                        		.dbg	line,	"include\routines_LEVELS.c", 934; {
 5219                        	
 5220                        		.dbg	line,	"include\routines_LEVELS.c", 935; // CAMERA GOES 8 PX BACKWARD //
 5221                        	
 5222                        		.dbg	line,	"include\routines_LEVELS.c", 936; sgx_map_pxl_x = ( (sgx_map_pxl_x >> 3) << 3 );
 5223                        		__ld.wm		_sgx_map_pxl_x
         01:CB3C  AD C8 24   			lda.l	_sgx_map_pxl_x
         01:CB3F  AC C9 24   			ldy.h	_sgx_map_pxl_x
 5224                        		__lsr.wi	3
         01:CB42  84 00      			sty	__temp
         01:CB44  20 3A E2   			jsr	lsrw3
 5225                        		__asl.wi	3
         01:CB47  84 00      			sty	__temp
         01:CB49  20 D7 E1   			jsr	aslw3
 5226                        		__st.wmq	_sgx_map_pxl_x
         01:CB4C  8D C8 24   			sta.l	_sgx_map_pxl_x
         01:CB4F  8C C9 24   			sty.h	_sgx_map_pxl_x
 5227                        	
 5228                        		.dbg	line,	"include\routines_LEVELS.c", 938; // SO WE UPDATE THE MAP //
 5229                        	
 5230                        		.dbg	line,	"include\routines_LEVELS.c", 939; sgx_scroll_map();
 5231                        		__call		_sgx_scroll_map
         01:CB52  20 95 FF   			call	_sgx_scroll_map
 5232                        	
 5233                        		.dbg	line,	"include\routines_LEVELS.c", 941; // CHECK IF THE PLAYER STANDS RIGHT TO THE LADDER //
 5234                        	
 5235                        		.dbg	line,	"include\routines_LEVELS.c", 942; check_BG( 31 , 16 );
 5236                        		__ld.wi		31
         01:CB55  A9 1F      			lda.l	#31
         01:CB57  C2         			cly
 5237                        		__pusharg.wr
         01:CB58  A6 8D      			ldx	<__sp
         01:CB5A  CA         			dex
         01:CB5B  CA         			dex
         01:CB5C  95 08      			sta.l	<__stack, x
         01:CB5E  94 09      			sty.h	<__stack, x
         01:CB60  86 8D      			stx	<__sp
 5238                        		__ld.wi		16
         01:CB62  A9 10      			lda.l	#16
         01:CB64  C2         			cly
 5239                        		__pusharg.wr
         01:CB65  A6 8D      			ldx	<__sp
         01:CB67  CA         			dex
         01:CB68  CA         			dex
         01:CB69  95 08      			sta.l	<__stack, x
         01:CB6B  94 09      			sty.h	<__stack, x
         01:CB6D  86 8D      			stx	<__sp
 5240                        		__call		_check_BG
         01:CB6F  20 81 FF   			call	_check_BG
 5241                        	
 5242                        		.dbg	line,	"include\routines_LEVELS.c", 944; if(map_blk_flag == TILE_LADDER)
 5243                        		__ld.umq	_map_blk_flag
         01:CB72  AD E9 29   			lda	_map_blk_flag
 5244                        		__equ_b.uiq	2
         01:CB75  C9 02      			cmp	#2
         01:CB77  F0 01      			beq	!+
         01:CB79  18         			clc
         01:CB7A             	!:
 5245                        		__bfalse	.LL193
         01:CB7A  90 0E      			bcc	.LL193
 5246                        	
 5247                        		.dbg	line,	"include\routines_LEVELS.c", 945; {
 5248                        	
 5249                        		.dbg	line,	"include\routines_LEVELS.c", 946; sgx_map_pxl_x += 8;
 5250                        		__add_st.wmiq	8, _sgx_map_pxl_x
         01:CB7C  18         			clc
         01:CB7D  AD C8 24   			lda.l	_sgx_map_pxl_x
         01:CB80  69 08      			adc.l	#8
         01:CB82  8D C8 24   			sta.l	_sgx_map_pxl_x
         01:CB85  90 03      			bcc	!+
         01:CB87  EE C9 24   			inc.h	_sgx_map_pxl_x
         01:CB8A             	!:
 5251                        	
 5252                        		.dbg	line,	"include\routines_LEVELS.c", 947; }
 5253                        	
 5254                        		.dbg	line,	"include\routines_LEVELS.c", 949; player_counter_anim = 1;
 5255    01:CB8A             	.LL193:
 5256                        		__st.umiq	1, _player_counter_anim
         01:CB8A  A9 01      			lda.l	#1
         01:CB8C  8D 12 23   			sta	_player_counter_anim
 5257                        	
 5258                        		.dbg	line,	"include\routines_LEVELS.c", 950; player_index_jump = 0;
 5259                        		__st.umiq	0, _player_index_jump
         01:CB8F  9C 13 23   			stz	_player_index_jump
 5260                        	
 5261                        		.dbg	line,	"include\routines_LEVELS.c", 951; jump_ladder = TRUE;
 5262                        		__st.umiq	1, _jump_ladder
         01:CB92  A9 01      			lda.l	#1
         01:CB94  8D 15 23   			sta	_jump_ladder
 5263                        	
 5264                        		.dbg	line,	"include\routines_LEVELS.c", 952; jump_max_index = 29;
 5265                        		__st.umiq	29, _jump_max_index
         01:CB97  A9 1D      			lda.l	#29
         01:CB99  8D 16 23   			sta	_jump_max_index
 5266                        	
 5267                        		.dbg	line,	"include\routines_LEVELS.c", 953; player_state = STATE_HANG;
 5268                        		__st.umiq	10, _player_state
         01:CB9C  A9 0A      			lda.l	#10
         01:CB9E  8D 0F 23   			sta	_player_state
 5269                        	
 5270                        		.dbg	line,	"include\routines_LEVELS.c", 954; }
 5271                        	
 5272                        		.dbg	line,	"include\routines_LEVELS.c", 955; }
 5273    01:CBA1             	.LL192:
 5274                        	
 5275                        		.dbg	line,	"include\routines_LEVELS.c", 958; // SET PLAYER SPRITE NEW POSITION //
 5276                        	
 5277                        		.dbg	line,	"include\routines_LEVELS.c", 959; spr_y(player_pos_y);
 5278    01:CBA1             	.LL191:
 5279                        		__ld.wm		_player_pos_y
         01:CBA1  AD 1A 23   			lda.l	_player_pos_y
         01:CBA4  AC 1B 23   			ldy.h	_player_pos_y
 5280                        		__call		_spr_y.1
         01:CBA7  20 19 E8   			call	_spr_y.1
 5281                        	
 5282                        		.dbg	line,	"include\routines_LEVELS.c", 960; }
 5283                        	
 5284                        		.dbg	line,	"include\routines_LEVELS.c", 963; else if(player_state == STATE_JUMP_LEFT)
 5285                        		__bra		.LL194
         01:CBAA  4C 09 D6   			bra	.LL194
 5286    01:CBAD             	.LL158:
 5287                        		__ld.umq	_player_state
         01:CBAD  AD 0F 23   			lda	_player_state
 5288                        		__equ_b.uiq	6
         01:CBB0  C9 06      			cmp	#6
         01:CBB2  F0 01      			beq	!+
         01:CBB4  18         			clc
         01:CBB5             	!:
 5289                        		__bfalse	.LL195
         01:CBB5  B0 03 4C D8			bcc	.LL195
         01:CBB9  CF          
 5290                        	
 5291                        		.dbg	line,	"include\routines_LEVELS.c", 964; {
 5292                        	
 5293                        		.dbg	line,	"include\routines_LEVELS.c", 965; unsigned char i, camera_y_move;
 5294                        	
 5295                        		.dbg	line,	"include\routines_LEVELS.c", 966; i = 1;
 5296                        		__st.umiq	1, __update_PLAYER_end - 4  /* i */
         01:CBBA  A9 01      			lda.l	#1
         01:CBBC  8D 06 23   			sta	__update_PLAYER_end - 4
 5297                        	
 5298                        		.dbg	line,	"include\routines_LEVELS.c", 969; // UPDATE PLAYER TILES //
 5299                        	
 5300                        		.dbg	line,	"include\routines_LEVELS.c", 970; if(player_counter_anim == 0)
 5301                        		__not.um	_player_counter_anim
         01:CBBF  AD 12 23   			lda	_player_counter_anim
         01:CBC2  18         			clc
         01:CBC3  D0 01      			bne	!+
         01:CBC5  38         			sec
         01:CBC6             	!:
 5302                        		__bfalse	.LL196
         01:CBC6  90 21      			bcc	.LL196
 5303                        	
 5304                        		.dbg	line,	"include\routines_LEVELS.c", 971; {
 5305                        	
 5306                        		.dbg	line,	"include\routines_LEVELS.c", 972; load_vram(PLAYER_VRAM_ADR, tiles_SPR_PLAYER + TILES_112 , TILES_16);
 5307                        		__st.wmiq	6144, _di
         01:CBC8  64 F0      			stz.l	_di
         01:CBCA  A9 18      			lda.h	#6144
         01:CBCC  85 F1      			sta.h	_di
 5308                        		__farptr	_tiles_SPR_PLAYER + 3584, _bp_bank, _bp
         01:CBCE  A9 A0      			lda.l	#$6000 + ($1FFF & (_tiles_SPR_PLAYER + 3584))
         01:CBD0  85 EC      			sta.l	_bp
         01:CBD2  A9 68      			lda.h	#$6000 + ($1FFF & (_tiles_SPR_PLAYER + 3584))
         01:CBD4  85 ED      			sta.h	_bp
         01:CBD6  A9 0C      			lda	#bank(_tiles_SPR_PLAYER + 3584)
         01:CBD8  85 02      			sta	_bp_bank
 5309                        		__st.wmiq	256, _ax
         01:CBDA  64 F8      			stz.l	_ax
         01:CBDC  A9 01      			lda.h	#256
         01:CBDE  85 F9      			sta.h	_ax
 5310                        		 _load_vram.3
         01:CBE0  82         			clx				; Offset to PCE VDC.
         01:CBE1  20 77 FF   			call	load_vram_x
 5311                        	
 5312                        		.dbg	line,	"include\routines_LEVELS.c", 974; player_counter_anim = 1;
 5313                        		__st.umiq	1, _player_counter_anim
         01:CBE4  A9 01      			lda.l	#1
         01:CBE6  8D 12 23   			sta	_player_counter_anim
 5314                        	
 5315                        		.dbg	line,	"include\routines_LEVELS.c", 975; }
 5316                        	
 5317                        		.dbg	line,	"include\routines_LEVELS.c", 978; // SELECT PLAYER SPRITE //
 5318                        	
 5319                        		.dbg	line,	"include\routines_LEVELS.c", 979; spr_set(player_id);
 5320    01:CBE9             	.LL196:
 5321                        		__ld.umq	_player_id
         01:CBE9  AD 0E 23   			lda	_player_id
 5322                        		__call		_spr_set.1
         01:CBEC  20 DD E7   			call	_spr_set.1
 5323                        	
 5324                        		.dbg	line,	"include\routines_LEVELS.c", 982; //**************************************************************************************//
 5325                        	
 5326                        		.dbg	line,	"include\routines_LEVELS.c", 983; //                                        H MOVE                                        //
 5327                        	
 5328                        		.dbg	line,	"include\routines_LEVELS.c", 984; //**************************************************************************************//
 5329                        	
 5330                        		.dbg	line,	"include\routines_LEVELS.c", 986; //--------------------------------------------------------------------------------------//
 5331                        	
 5332                        		.dbg	line,	"include\routines_LEVELS.c", 987; //                                    WALL COLLISION                                    //
 5333                        	
 5334                        		.dbg	line,	"include\routines_LEVELS.c", 988; //--------------------------------------------------------------------------------------//
 5335                        	
 5336                        		.dbg	line,	"include\routines_LEVELS.c", 990; // CHECK COLLISION WITH BOTTOM LEFT WALL //
 5337                        	
 5338                        		.dbg	line,	"include\routines_LEVELS.c", 991; check_BG( 8 , 31 );
 5339                        		__ld.wi		8
         01:CBEF  A9 08      			lda.l	#8
         01:CBF1  C2         			cly
 5340                        		__pusharg.wr
         01:CBF2  A6 8D      			ldx	<__sp
         01:CBF4  CA         			dex
         01:CBF5  CA         			dex
         01:CBF6  95 08      			sta.l	<__stack, x
         01:CBF8  94 09      			sty.h	<__stack, x
         01:CBFA  86 8D      			stx	<__sp
 5341                        		__ld.wi		31
         01:CBFC  A9 1F      			lda.l	#31
         01:CBFE  C2         			cly
 5342                        		__pusharg.wr
         01:CBFF  A6 8D      			ldx	<__sp
         01:CC01  CA         			dex
         01:CC02  CA         			dex
         01:CC03  95 08      			sta.l	<__stack, x
         01:CC05  94 09      			sty.h	<__stack, x
         01:CC07  86 8D      			stx	<__sp
 5343                        		__call		_check_BG
         01:CC09  20 81 FF   			call	_check_BG
 5344                        	
 5345                        		.dbg	line,	"include\routines_LEVELS.c", 993; if(map_blk_flag != TILE_BG)
 5346                        		__ld.umq	_map_blk_flag
         01:CC0C  AD E9 29   			lda	_map_blk_flag
 5347                        		__neq_b.uiq	1
         01:CC0F  38         			sec
         01:CC10  49 01      			eor	#1
         01:CC12  D0 01      			bne	!+
         01:CC14  18         			clc
         01:CC15             	!:
 5348                        		__bfalse	.LL197
         01:CC15  90 78      			bcc	.LL197
 5349                        	
 5350                        		.dbg	line,	"include\routines_LEVELS.c", 994; {
 5351                        	
 5352                        		.dbg	line,	"include\routines_LEVELS.c", 995; // CHECK COLLISION WITH TOP RIGHT WALL //
 5353                        	
 5354                        		.dbg	line,	"include\routines_LEVELS.c", 996; check_BG( 8 , 15 );
 5355                        		__ld.wi		8
         01:CC17  A9 08      			lda.l	#8
         01:CC19  C2         			cly
 5356                        		__pusharg.wr
         01:CC1A  A6 8D      			ldx	<__sp
         01:CC1C  CA         			dex
         01:CC1D  CA         			dex
         01:CC1E  95 08      			sta.l	<__stack, x
         01:CC20  94 09      			sty.h	<__stack, x
         01:CC22  86 8D      			stx	<__sp
 5357                        		__ld.wi		15
         01:CC24  A9 0F      			lda.l	#15
         01:CC26  C2         			cly
 5358                        		__pusharg.wr
         01:CC27  A6 8D      			ldx	<__sp
         01:CC29  CA         			dex
         01:CC2A  CA         			dex
         01:CC2B  95 08      			sta.l	<__stack, x
         01:CC2D  94 09      			sty.h	<__stack, x
         01:CC2F  86 8D      			stx	<__sp
 5359                        		__call		_check_BG
         01:CC31  20 81 FF   			call	_check_BG
 5360                        	
 5361                        		.dbg	line,	"include\routines_LEVELS.c", 998; if(map_blk_flag == TILE_BG)
 5362                        		__ld.umq	_map_blk_flag
         01:CC34  AD E9 29   			lda	_map_blk_flag
 5363                        		__equ_b.uiq	1
         01:CC37  C9 01      			cmp	#1
         01:CC39  F0 01      			beq	!+
         01:CC3B  18         			clc
         01:CC3C             	!:
 5364                        		__bfalse	.LL198
         01:CC3C  90 41      			bcc	.LL198
 5365                        	
 5366                        		.dbg	line,	"include\routines_LEVELS.c", 999; {
 5367                        	
 5368                        		.dbg	line,	"include\routines_LEVELS.c", 1000; check_TILE_DEPTH( 15 , -16 );
 5369                        		__ld.wi		15
         01:CC3E  A9 0F      			lda.l	#15
         01:CC40  C2         			cly
 5370                        		__pusharg.wr
         01:CC41  A6 8D      			ldx	<__sp
         01:CC43  CA         			dex
         01:CC44  CA         			dex
         01:CC45  95 08      			sta.l	<__stack, x
         01:CC47  94 09      			sty.h	<__stack, x
         01:CC49  86 8D      			stx	<__sp
 5371                        		__ld.wi		-16
         01:CC4B  A9 F0      			lda.l	#-16
         01:CC4D  A0 FF      			ldy.h	#-16
 5372                        		__pusharg.wr
         01:CC4F  A6 8D      			ldx	<__sp
         01:CC51  CA         			dex
         01:CC52  CA         			dex
         01:CC53  95 08      			sta.l	<__stack, x
         01:CC55  94 09      			sty.h	<__stack, x
         01:CC57  86 8D      			stx	<__sp
 5373                        		__call		_check_TILE_DEPTH
         01:CC59  20 63 FF   			call	_check_TILE_DEPTH
 5374                        	
 5375                        		.dbg	line,	"include\routines_LEVELS.c", 1002; if(map_blk_flag == TILE_EMPTY && jump_ladder == TRUE)
 5376                        		__not.um	_map_blk_flag
         01:CC5C  AD E9 29   			lda	_map_blk_flag
         01:CC5F  18         			clc
         01:CC60  D0 01      			bne	!+
         01:CC62  38         			sec
         01:CC63             	!:
 5377                        		__bfalse	.LL200
         01:CC63  90 08      			bcc	.LL200
 5378                        		__ld.umq	_jump_ladder
         01:CC65  AD 15 23   			lda	_jump_ladder
 5379                        		__equ_b.uiq	1
         01:CC68  C9 01      			cmp	#1
         01:CC6A  F0 01      			beq	!+
         01:CC6C  18         			clc
         01:CC6D             	!:
 5380    01:CC6D             	.LL200:
 5381                        		__bfalse	.LL199
         01:CC6D  90 5F      			bcc	.LL199
 5382                        	
 5383                        		.dbg	line,	"include\routines_LEVELS.c", 1003; {
 5384                        	
 5385                        		.dbg	line,	"include\routines_LEVELS.c", 1004; jump_ladder = FALSE;
 5386                        		__st.umiq	0, _jump_ladder
         01:CC6F  9C 15 23   			stz	_jump_ladder
 5387                        	
 5388                        		.dbg	line,	"include\routines_LEVELS.c", 1005; player_index_fall = 0;
 5389                        		__st.umiq	0, _player_index_fall
         01:CC72  9C 14 23   			stz	_player_index_fall
 5390                        	
 5391                        		.dbg	line,	"include\routines_LEVELS.c", 1006; player_state = STATE_FALL;
 5392                        		__st.umiq	9, _player_state
         01:CC75  A9 09      			lda.l	#9
         01:CC77  8D 0F 23   			sta	_player_state
 5393                        	
 5394                        		.dbg	line,	"include\routines_LEVELS.c", 1007; return;
 5395                        		__bra		.LL95
         01:CC7A  4C 09 D6   			bra	.LL95
 5396                        	
 5397                        		.dbg	line,	"include\routines_LEVELS.c", 1008; }
 5398                        	
 5399                        		.dbg	line,	"include\routines_LEVELS.c", 1009; }
 5400    01:CC7D             	.LL199	.alias		.LL201
 5401                        	
 5402                        		.dbg	line,	"include\routines_LEVELS.c", 1011; else
 5403                        		__bra		.LL201
         01:CC7D  80 4F      			bra	.LL201
 5404    01:CC7F             	.LL198:
 5405                        	
 5406                        		.dbg	line,	"include\routines_LEVELS.c", 1012; {
 5407                        	
 5408                        		.dbg	line,	"include\routines_LEVELS.c", 1013; sgx_map_pxl_x -= 2;
 5409                        		__sub_st.wmiq	2, _sgx_map_pxl_x
         01:CC7F  38         			sec
         01:CC80  AD C8 24   			lda.l	_sgx_map_pxl_x
         01:CC83  E9 02      			sbc.l	#2
         01:CC85  8D C8 24   			sta.l	_sgx_map_pxl_x
         01:CC88  B0 03      			bcs	!+
         01:CC8A  CE C9 24   			dec.h	_sgx_map_pxl_x
         01:CC8D             	!:
 5410                        	
 5411                        		.dbg	line,	"include\routines_LEVELS.c", 1014; }
 5412    01:CC8D             	.LL201	.alias		.LL202
 5413                        	
 5414                        		.dbg	line,	"include\routines_LEVELS.c", 1015; }
 5415                        	
 5416                        		.dbg	line,	"include\routines_LEVELS.c", 1017; else
 5417                        		__bra		.LL202
         01:CC8D  80 3F      			bra	.LL202
 5418    01:CC8F             	.LL197:
 5419                        	
 5420                        		.dbg	line,	"include\routines_LEVELS.c", 1018; {
 5421                        	
 5422                        		.dbg	line,	"include\routines_LEVELS.c", 1019; check_TILE_DEPTH( 15 , -16 );
 5423                        		__ld.wi		15
         01:CC8F  A9 0F      			lda.l	#15
         01:CC91  C2         			cly
 5424                        		__pusharg.wr
         01:CC92  A6 8D      			ldx	<__sp
         01:CC94  CA         			dex
         01:CC95  CA         			dex
         01:CC96  95 08      			sta.l	<__stack, x
         01:CC98  94 09      			sty.h	<__stack, x
         01:CC9A  86 8D      			stx	<__sp
 5425                        		__ld.wi		-16
         01:CC9C  A9 F0      			lda.l	#-16
         01:CC9E  A0 FF      			ldy.h	#-16
 5426                        		__pusharg.wr
         01:CCA0  A6 8D      			ldx	<__sp
         01:CCA2  CA         			dex
         01:CCA3  CA         			dex
         01:CCA4  95 08      			sta.l	<__stack, x
         01:CCA6  94 09      			sty.h	<__stack, x
         01:CCA8  86 8D      			stx	<__sp
 5427                        		__call		_check_TILE_DEPTH
         01:CCAA  20 63 FF   			call	_check_TILE_DEPTH
 5428                        	
 5429                        		.dbg	line,	"include\routines_LEVELS.c", 1021; if(map_blk_flag == TILE_EMPTY && jump_ladder == TRUE)
 5430                        		__not.um	_map_blk_flag
         01:CCAD  AD E9 29   			lda	_map_blk_flag
         01:CCB0  18         			clc
         01:CCB1  D0 01      			bne	!+
         01:CCB3  38         			sec
         01:CCB4             	!:
 5431                        		__bfalse	.LL204
         01:CCB4  90 08      			bcc	.LL204
 5432                        		__ld.umq	_jump_ladder
         01:CCB6  AD 15 23   			lda	_jump_ladder
 5433                        		__equ_b.uiq	1
         01:CCB9  C9 01      			cmp	#1
         01:CCBB  F0 01      			beq	!+
         01:CCBD  18         			clc
         01:CCBE             	!:
 5434    01:CCBE             	.LL204:
 5435                        		__bfalse	.LL203
         01:CCBE  90 0E      			bcc	.LL203
 5436                        	
 5437                        		.dbg	line,	"include\routines_LEVELS.c", 1022; {
 5438                        	
 5439                        		.dbg	line,	"include\routines_LEVELS.c", 1023; jump_ladder = FALSE;
 5440                        		__st.umiq	0, _jump_ladder
         01:CCC0  9C 15 23   			stz	_jump_ladder
 5441                        	
 5442                        		.dbg	line,	"include\routines_LEVELS.c", 1024; player_index_fall = 0;
 5443                        		__st.umiq	0, _player_index_fall
         01:CCC3  9C 14 23   			stz	_player_index_fall
 5444                        	
 5445                        		.dbg	line,	"include\routines_LEVELS.c", 1025; player_state = STATE_FALL;
 5446                        		__st.umiq	9, _player_state
         01:CCC6  A9 09      			lda.l	#9
         01:CCC8  8D 0F 23   			sta	_player_state
 5447                        	
 5448                        		.dbg	line,	"include\routines_LEVELS.c", 1026; return;
 5449                        		__bra		.LL95
         01:CCCB  4C 09 D6   			bra	.LL95
 5450                        	
 5451                        		.dbg	line,	"include\routines_LEVELS.c", 1027; }
 5452                        	
 5453                        		.dbg	line,	"include\routines_LEVELS.c", 1028; }
 5454    01:CCCE             	.LL203:
 5455    01:CCCE             	.LL202:
 5456                        	
 5457                        		.dbg	line,	"include\routines_LEVELS.c", 1033; //**************************************************************************************//
 5458                        	
 5459                        		.dbg	line,	"include\routines_LEVELS.c", 1034; //                                        V MOVE                                        //
 5460                        	
 5461                        		.dbg	line,	"include\routines_LEVELS.c", 1035; //**************************************************************************************//
 5462                        	
 5463                        		.dbg	line,	"include\routines_LEVELS.c", 1037; // UPDATE PLAYER Y POSITION //
 5464                        	
 5465                        		.dbg	line,	"include\routines_LEVELS.c", 1038; if(jump_ladder == FALSE)
 5466                        		__not.um	_jump_ladder
         01:CCCE  AD 15 23   			lda	_jump_ladder
         01:CCD1  18         			clc
         01:CCD2  D0 01      			bne	!+
         01:CCD4  38         			sec
         01:CCD5             	!:
 5467                        		__bfalse	.LL205
         01:CCD5  90 1A      			bcc	.LL205
 5468                        	
 5469                        		.dbg	line,	"include\routines_LEVELS.c", 1039; {
 5470                        	
 5471                        		.dbg	line,	"include\routines_LEVELS.c", 1040; player_pos_y += TABLE_PLAYER_JUMP_V[player_index_jump];
 5472                        		__ldx.umq	_player_index_jump
         01:CCD7  AE 13 23   			ldx	_player_index_jump
 5473                        		__ld.bax	_TABLE_PLAYER_JUMP_V
         01:CCDA  BD 9A 60   			lda	_TABLE_PLAYER_JUMP_V, x
         01:CCDD  C2         			cly
         01:CCDE  10 01      			bpl	!+
         01:CCE0  88         			dey
         01:CCE1             	!:
 5474                        		__add_st.wmq	_player_pos_y
         01:CCE1  18         			clc
         01:CCE2  6D 1A 23   			adc.l	_player_pos_y
         01:CCE5  8D 1A 23   			sta.l	_player_pos_y
         01:CCE8  98         			tya
         01:CCE9  6D 1B 23   			adc.h	_player_pos_y
         01:CCEC  8D 1B 23   			sta.h	_player_pos_y
 5475                        	
 5476                        		.dbg	line,	"include\routines_LEVELS.c", 1041; }
 5477                        	
 5478                        		.dbg	line,	"include\routines_LEVELS.c", 1043; else
 5479                        		__bra		.LL206
         01:CCEF  80 18      			bra	.LL206
 5480    01:CCF1             	.LL205:
 5481                        	
 5482                        		.dbg	line,	"include\routines_LEVELS.c", 1044; {
 5483                        	
 5484                        		.dbg	line,	"include\routines_LEVELS.c", 1045; player_pos_y += TABLE_PLAYER_JUMP_LADDER[player_index_jump];
 5485                        		__ldx.umq	_player_index_jump
         01:CCF1  AE 13 23   			ldx	_player_index_jump
 5486                        		__ld.bax	_TABLE_PLAYER_JUMP_LADDER
         01:CCF4  BD D2 60   			lda	_TABLE_PLAYER_JUMP_LADDER, x
         01:CCF7  C2         			cly
         01:CCF8  10 01      			bpl	!+
         01:CCFA  88         			dey
         01:CCFB             	!:
 5487                        		__add_st.wmq	_player_pos_y
         01:CCFB  18         			clc
         01:CCFC  6D 1A 23   			adc.l	_player_pos_y
         01:CCFF  8D 1A 23   			sta.l	_player_pos_y
         01:CD02  98         			tya
         01:CD03  6D 1B 23   			adc.h	_player_pos_y
         01:CD06  8D 1B 23   			sta.h	_player_pos_y
 5488                        	
 5489                        		.dbg	line,	"include\routines_LEVELS.c", 1046; }
 5490    01:CD09             	.LL206:
 5491                        	
 5492                        		.dbg	line,	"include\routines_LEVELS.c", 1049; // IF PLAYER GOES BELOW ITS BASE Y POSITION //
 5493                        	
 5494                        		.dbg	line,	"include\routines_LEVELS.c", 1050; if(player_pos_y >= PLAYER_BASE_Y_POS)
 5495                        		__ld.wm		_player_pos_y
         01:CD09  AD 1A 23   			lda.l	_player_pos_y
         01:CD0C  AC 1B 23   			ldy.h	_player_pos_y
 5496                        		__sge_w.wi	128
         01:CD0F  C9 80      			cmp.l	#128		; Subtract integer from Y:A.
         01:CD11  98         			tya
         01:CD12  E9 00      			sbc.h	#128
         01:CD14  50 02      			bvc	!+
         01:CD16  49 80      			eor	#$80		; +ve if Y:A >= integer (signed).
         01:CD18  49 80      	!:		eor	#$80
         01:CD1A  0A         			asl	a
 5497                        		__bfalse	.LL207
         01:CD1B  90 4E      			bcc	.LL207
 5498                        	
 5499                        		.dbg	line,	"include\routines_LEVELS.c", 1051; {
 5500                        	
 5501                        		.dbg	line,	"include\routines_LEVELS.c", 1052; // THE CAMERA MOVES //
 5502                        	
 5503                        		.dbg	line,	"include\routines_LEVELS.c", 1053; // CALCULATE HOW MANY PIXELS THE CAMERA HAS TO MOVE DOWN //
 5504                        	
 5505                        		.dbg	line,	"include\routines_LEVELS.c", 1054; camera_y_move = player_pos_y - PLAYER_BASE_Y_POS;
 5506                        		__ld.wm		_player_pos_y
         01:CD1D  AD 1A 23   			lda.l	_player_pos_y
         01:CD20  AC 1B 23   			ldy.h	_player_pos_y
 5507                        		__sub.wi	128
         01:CD23  38         			sec
         01:CD24  E9 80      			sbc.l	#128
         01:CD26  B0 01      			bcs	!+
         01:CD28  88         			dey
         01:CD29             	!:
 5508                        		__st.umq	__update_PLAYER_end - 5  /* camera_y_move */
         01:CD29  8D 05 23   			sta	__update_PLAYER_end - 5
 5509                        	
 5510                        		.dbg	line,	"include\routines_LEVELS.c", 1055; sgx_map_pxl_y += camera_y_move;
 5511                        		__ld.um		__update_PLAYER_end - 5  /* camera_y_move */
         01:CD2C  AD 05 23   			lda	__update_PLAYER_end - 5
         01:CD2F  C2         			cly
 5512                        		__add_st.wmq	_sgx_map_pxl_y
         01:CD30  18         			clc
         01:CD31  6D CA 24   			adc.l	_sgx_map_pxl_y
         01:CD34  8D CA 24   			sta.l	_sgx_map_pxl_y
         01:CD37  98         			tya
         01:CD38  6D CB 24   			adc.h	_sgx_map_pxl_y
         01:CD3B  8D CB 24   			sta.h	_sgx_map_pxl_y
 5513                        	
 5514                        		.dbg	line,	"include\routines_LEVELS.c", 1057; // IF THE CAMERA HAS REACHED ITS MAX (LOWEST) POSITION //
 5515                        	
 5516                        		.dbg	line,	"include\routines_LEVELS.c", 1058; if(sgx_map_pxl_y > camera_max_y_position)
 5517                        		__ld.wm		_sgx_map_pxl_y
         01:CD3E  AD CA 24   			lda.l	_sgx_map_pxl_y
         01:CD41  AC CB 24   			ldy.h	_sgx_map_pxl_y
 5518                        		__ugt_w.wm	_camera_max_y_position
         01:CD44  18         			clc			; Subtract memory+1 from Y:A.
         01:CD45  ED 1C 23   			sbc.l	_camera_max_y_position
         01:CD48  98         			tya
         01:CD49  ED 1D 23   			sbc.h	_camera_max_y_position		; CS if Y:A > memory.
 5519                        		__bfalse	.LL208
         01:CD4C  90 0C      			bcc	.LL208
 5520                        	
 5521                        		.dbg	line,	"include\routines_LEVELS.c", 1059; {
 5522                        	
 5523                        		.dbg	line,	"include\routines_LEVELS.c", 1060; // THE CAMERA CAN NOT MOVE LOWER //
 5524                        	
 5525                        		.dbg	line,	"include\routines_LEVELS.c", 1061; sgx_map_pxl_y = camera_max_y_position;
 5526                        		__ld.wm		_camera_max_y_position
         01:CD4E  AD 1C 23   			lda.l	_camera_max_y_position
         01:CD51  AC 1D 23   			ldy.h	_camera_max_y_position
 5527                        		__st.wmq	_sgx_map_pxl_y
         01:CD54  8D CA 24   			sta.l	_sgx_map_pxl_y
         01:CD57  8C CB 24   			sty.h	_sgx_map_pxl_y
 5528                        	
 5529                        		.dbg	line,	"include\routines_LEVELS.c", 1062; }
 5530                        	
 5531                        		.dbg	line,	"include\routines_LEVELS.c", 1064; // THE PLAYER STAYS AT ITS BASE Y POSITION //
 5532                        	
 5533                        		.dbg	line,	"include\routines_LEVELS.c", 1065; player_pos_y = PLAYER_BASE_Y_POS;
 5534    01:CD5A             	.LL208:
 5535                        		__st.wmiq	128, _player_pos_y
         01:CD5A  A9 80      			lda.l	#128
         01:CD5C  8D 1A 23   			sta.l	_player_pos_y
         01:CD5F  9C 1B 23   			stz.h	_player_pos_y
 5536                        	
 5537                        		.dbg	line,	"include\routines_LEVELS.c", 1067; spr_y(player_pos_y);
 5538                        		__ld.wm		_player_pos_y
         01:CD62  AD 1A 23   			lda.l	_player_pos_y
         01:CD65  AC 1B 23   			ldy.h	_player_pos_y
 5539                        		__call		_spr_y.1
         01:CD68  20 19 E8   			call	_spr_y.1
 5540                        	
 5541                        		.dbg	line,	"include\routines_LEVELS.c", 1068; }
 5542                        	
 5543                        		.dbg	line,	"include\routines_LEVELS.c", 1071; // UPDATE JUMP INDEX IN THE ARRAY //
 5544                        	
 5545                        		.dbg	line,	"include\routines_LEVELS.c", 1072; if(player_index_jump < jump_max_index)
 5546    01:CD6B             	.LL207:
 5547                        		__ld.umq	_player_index_jump
         01:CD6B  AD 13 23   			lda	_player_index_jump
 5548                        		__ult_b.umq	_jump_max_index
         01:CD6E  CD 16 23   			cmp	_jump_max_index		; Subtract memory from A.
         01:CD71  6A         			ror	a		; CC if A < memory.
         01:CD72  49 80      			eor	#$80
         01:CD74  2A         			rol	a
 5549                        		__bfalse	.LL209
         01:CD75  90 03      			bcc	.LL209
 5550                        	
 5551                        		.dbg	line,	"include\routines_LEVELS.c", 1073; {
 5552                        	
 5553                        		.dbg	line,	"include\routines_LEVELS.c", 1074; player_index_jump += 1;
 5554                        		__add_st.umiq	1, _player_index_jump
         01:CD77  EE 13 23   			inc	_player_index_jump
 5555                        	
 5556                        		.dbg	line,	"include\routines_LEVELS.c", 1075; }
 5557                        	
 5558                        		.dbg	line,	"include\routines_LEVELS.c", 1080; //--------------------------------------------------------------------------------------//
 5559                        	
 5560                        		.dbg	line,	"include\routines_LEVELS.c", 1081; //                                   FLOOR COLLISION                                    //
 5561                        	
 5562                        		.dbg	line,	"include\routines_LEVELS.c", 1082; //--------------------------------------------------------------------------------------//
 5563                        	
 5564                        		.dbg	line,	"include\routines_LEVELS.c", 1084; if(player_index_jump > 14)
 5565    01:CD7A             	.LL209:
 5566                        		__ld.umq	_player_index_jump
         01:CD7A  AD 13 23   			lda	_player_index_jump
 5567                        		__ugt_b.uiq	14
         01:CD7D  18         			clc			; Subtract integer+1 from A.
         01:CD7E  E9 0E      			sbc	#14		; CS if A > integer.
 5568                        		__bfalse	.LL210
         01:CD80  B0 03 4C 35			bcc	.LL210
         01:CD84  CF          
 5569                        	
 5570                        		.dbg	line,	"include\routines_LEVELS.c", 1085; {
 5571                        	
 5572                        		.dbg	line,	"include\routines_LEVELS.c", 1086; // CHECK COLLISION WITH LEFT FLOOR //
 5573                        	
 5574                        		.dbg	line,	"include\routines_LEVELS.c", 1087; check_BG( 10 , 32 );
 5575                        		__ld.wi		10
         01:CD85  A9 0A      			lda.l	#10
         01:CD87  C2         			cly
 5576                        		__pusharg.wr
         01:CD88  A6 8D      			ldx	<__sp
         01:CD8A  CA         			dex
         01:CD8B  CA         			dex
         01:CD8C  95 08      			sta.l	<__stack, x
         01:CD8E  94 09      			sty.h	<__stack, x
         01:CD90  86 8D      			stx	<__sp
 5577                        		__ld.wi		32
         01:CD92  A9 20      			lda.l	#32
         01:CD94  C2         			cly
 5578                        		__pusharg.wr
         01:CD95  A6 8D      			ldx	<__sp
         01:CD97  CA         			dex
         01:CD98  CA         			dex
         01:CD99  95 08      			sta.l	<__stack, x
         01:CD9B  94 09      			sty.h	<__stack, x
         01:CD9D  86 8D      			stx	<__sp
 5579                        		__call		_check_BG
         01:CD9F  20 81 FF   			call	_check_BG
 5580                        	
 5581                        		.dbg	line,	"include\routines_LEVELS.c", 1089; if(map_blk_flag == TILE_BG)
 5582                        		__ld.umq	_map_blk_flag
         01:CDA2  AD E9 29   			lda	_map_blk_flag
 5583                        		__equ_b.uiq	1
         01:CDA5  C9 01      			cmp	#1
         01:CDA7  F0 01      			beq	!+
         01:CDA9  18         			clc
         01:CDAA             	!:
 5584                        		__bfalse	.LL211
         01:CDAA  B0 03 4C 5D			bcc	.LL211
         01:CDAE  CE          
 5585                        	
 5586                        		.dbg	line,	"include\routines_LEVELS.c", 1090; {
 5587                        	
 5588                        		.dbg	line,	"include\routines_LEVELS.c", 1091; // CALCULATE HOW MANY PIXELS THE PLAYER MOVED INTO THE GROUND //
 5589                        	
 5590                        		.dbg	line,	"include\routines_LEVELS.c", 1092; for(i=1; i<11 ; i++)
 5591                        		__st.umiq	1, __update_PLAYER_end - 4  /* i */
         01:CDAF  A9 01      			lda.l	#1
         01:CDB1  8D 06 23   			sta	__update_PLAYER_end - 4
 5592    01:CDB4             	.LL212:
 5593                        		__ld.umq	__update_PLAYER_end - 4  /* i */
         01:CDB4  AD 06 23   			lda	__update_PLAYER_end - 4
 5594                        		__ult_b.uiq	11
         01:CDB7  C9 0B      			cmp	#11		; Subtract integer from A.
         01:CDB9  6A         			ror	a		; CC if A < integer.
         01:CDBA  49 80      			eor	#$80
         01:CDBC  2A         			rol	a
 5595                        		__btrue		.LL214
         01:CDBD  B0 07      			bcs	.LL214
 5596                        		__bra		.LL215
         01:CDBF  80 7D      			bra	.LL215
 5597    01:CDC1             	.LL213:
 5598                        		__inc.umq	__update_PLAYER_end - 4  /* i */
         01:CDC1  EE 06 23   			inc	__update_PLAYER_end - 4
 5599                        		__bra		.LL212
         01:CDC4  80 EE      			bra	.LL212
 5600    01:CDC6             	.LL214:
 5601                        	
 5602                        		.dbg	line,	"include\routines_LEVELS.c", 1093; {
 5603                        	
 5604                        		.dbg	line,	"include\routines_LEVELS.c", 1094; check_TILE_DEPTH( 10 , i);
 5605                        		__ld.wi		10
         01:CDC6  A9 0A      			lda.l	#10
         01:CDC8  C2         			cly
 5606                        		__pusharg.wr
         01:CDC9  A6 8D      			ldx	<__sp
         01:CDCB  CA         			dex
         01:CDCC  CA         			dex
         01:CDCD  95 08      			sta.l	<__stack, x
         01:CDCF  94 09      			sty.h	<__stack, x
         01:CDD1  86 8D      			stx	<__sp
 5607                        		__ld.um		__update_PLAYER_end - 4  /* i */
         01:CDD3  AD 06 23   			lda	__update_PLAYER_end - 4
         01:CDD6  C2         			cly
 5608                        		__pusharg.wr
         01:CDD7  A6 8D      			ldx	<__sp
         01:CDD9  CA         			dex
         01:CDDA  CA         			dex
         01:CDDB  95 08      			sta.l	<__stack, x
         01:CDDD  94 09      			sty.h	<__stack, x
         01:CDDF  86 8D      			stx	<__sp
 5609                        		__call		_check_TILE_DEPTH
         01:CDE1  20 63 FF   			call	_check_TILE_DEPTH
 5610                        	
 5611                        		.dbg	line,	"include\routines_LEVELS.c", 1096; if(map_blk_flag == TILE_EMPTY)
 5612                        		__not.um	_map_blk_flag
         01:CDE4  AD E9 29   			lda	_map_blk_flag
         01:CDE7  18         			clc
         01:CDE8  D0 01      			bne	!+
         01:CDEA  38         			sec
         01:CDEB             	!:
 5613                        		__bfalse	.LL216
         01:CDEB  90 D4      			bcc	.LL216
 5614                        	
 5615                        		.dbg	line,	"include\routines_LEVELS.c", 1097; {
 5616                        	
 5617                        		.dbg	line,	"include\routines_LEVELS.c", 1098; if(player_pos_y != PLAYER_BASE_Y_POS)
 5618                        		__ld.wm		_player_pos_y
         01:CDED  AD 1A 23   			lda.l	_player_pos_y
         01:CDF0  AC 1B 23   			ldy.h	_player_pos_y
 5619                        		__neq_w.wi	128
         01:CDF3  38         			sec
         01:CDF4  49 80      			eor.l	#128
         01:CDF6  D0 06      			bne	!+
         01:CDF8  98         			tya
         01:CDF9  49 00      			eor.h	#128
         01:CDFB  D0 01      			bne	!+
         01:CDFD  18         			clc
         01:CDFE             	!:
 5620                        		__bfalse	.LL217
         01:CDFE  90 1E      			bcc	.LL217
 5621                        	
 5622                        		.dbg	line,	"include\routines_LEVELS.c", 1099; {
 5623                        	
 5624                        		.dbg	line,	"include\routines_LEVELS.c", 1100; player_pos_y -= (i - 1);
 5625                        		__ld.um		__update_PLAYER_end - 4  /* i */
         01:CE00  AD 06 23   			lda	__update_PLAYER_end - 4
         01:CE03  C2         			cly
 5626                        		__sub.wi	1
         01:CE04  38         			sec
         01:CE05  E9 01      			sbc.l	#1
         01:CE07  B0 01      			bcs	!+
         01:CE09  88         			dey
         01:CE0A             	!:
 5627                        		__isub_st.wmq	_player_pos_y
         01:CE0A  38         			sec
         01:CE0B  49 FF      			eor	#$FF
         01:CE0D  6D 1A 23   			adc.l	_player_pos_y
         01:CE10  8D 1A 23   			sta.l	_player_pos_y
         01:CE13  98         			tya
         01:CE14  49 FF      			eor	#$FF
         01:CE16  6D 1B 23   			adc.h	_player_pos_y
         01:CE19  8D 1B 23   			sta.h	_player_pos_y
 5628                        	
 5629                        		.dbg	line,	"include\routines_LEVELS.c", 1101; }
 5630                        	
 5631                        		.dbg	line,	"include\routines_LEVELS.c", 1103; else
 5632                        		__bra		.LL218
         01:CE1C  80 20      			bra	.LL218
 5633    01:CE1E             	.LL217:
 5634                        	
 5635                        		.dbg	line,	"include\routines_LEVELS.c", 1104; {
 5636                        	
 5637                        		.dbg	line,	"include\routines_LEVELS.c", 1105; sgx_map_pxl_y -= (i - 1);
 5638                        		__ld.um		__update_PLAYER_end - 4  /* i */
         01:CE1E  AD 06 23   			lda	__update_PLAYER_end - 4
         01:CE21  C2         			cly
 5639                        		__sub.wi	1
         01:CE22  38         			sec
         01:CE23  E9 01      			sbc.l	#1
         01:CE25  B0 01      			bcs	!+
         01:CE27  88         			dey
         01:CE28             	!:
 5640                        		__isub_st.wmq	_sgx_map_pxl_y
         01:CE28  38         			sec
         01:CE29  49 FF      			eor	#$FF
         01:CE2B  6D CA 24   			adc.l	_sgx_map_pxl_y
         01:CE2E  8D CA 24   			sta.l	_sgx_map_pxl_y
         01:CE31  98         			tya
         01:CE32  49 FF      			eor	#$FF
         01:CE34  6D CB 24   			adc.h	_sgx_map_pxl_y
         01:CE37  8D CB 24   			sta.h	_sgx_map_pxl_y
 5641                        	
 5642                        		.dbg	line,	"include\routines_LEVELS.c", 1106; }
 5643    01:CE3A             	.LL218	.alias		.LL215
 5644                        	
 5645                        		.dbg	line,	"include\routines_LEVELS.c", 1108; break;
 5646                        		__bra		.LL215
         01:CE3A  80 02      			bra	.LL215
 5647                        	
 5648                        		.dbg	line,	"include\routines_LEVELS.c", 1109; }
 5649                        	
 5650                        		.dbg	line,	"include\routines_LEVELS.c", 1110; }
 5651    01:CE3C             	.LL216	.alias		.LL213
 5652                        		__bra		.LL213
         01:CE3C  80 83      			bra	.LL213
 5653    01:CE3E             	.LL215:
 5654                        	
 5655                        		.dbg	line,	"include\routines_LEVELS.c", 1112; // SET PLAYER SPRITE NEW POSITION //
 5656                        	
 5657                        		.dbg	line,	"include\routines_LEVELS.c", 1113; spr_y(player_pos_y);
 5658                        		__ld.wm		_player_pos_y
         01:CE3E  AD 1A 23   			lda.l	_player_pos_y
         01:CE41  AC 1B 23   			ldy.h	_player_pos_y
 5659                        		__call		_spr_y.1
         01:CE44  20 19 E8   			call	_spr_y.1
 5660                        	
 5661                        		.dbg	line,	"include\routines_LEVELS.c", 1115; player_counter_anim = 1;
 5662                        		__st.umiq	1, _player_counter_anim
         01:CE47  A9 01      			lda.l	#1
         01:CE49  8D 12 23   			sta	_player_counter_anim
 5663                        	
 5664                        		.dbg	line,	"include\routines_LEVELS.c", 1116; player_index_jump = 0;
 5665                        		__st.umiq	0, _player_index_jump
         01:CE4C  9C 13 23   			stz	_player_index_jump
 5666                        	
 5667                        		.dbg	line,	"include\routines_LEVELS.c", 1117; jump_ladder = FALSE;
 5668                        		__st.umiq	0, _jump_ladder
         01:CE4F  9C 15 23   			stz	_jump_ladder
 5669                        	
 5670                        		.dbg	line,	"include\routines_LEVELS.c", 1118; jump_max_index = 34;
 5671                        		__st.umiq	34, _jump_max_index
         01:CE52  A9 22      			lda.l	#34
         01:CE54  8D 16 23   			sta	_jump_max_index
 5672                        	
 5673                        		.dbg	line,	"include\routines_LEVELS.c", 1119; player_state = STATE_IDLE;
 5674                        		__st.umiq	0, _player_state
         01:CE57  9C 0F 23   			stz	_player_state
 5675                        	
 5676                        		.dbg	line,	"include\routines_LEVELS.c", 1120; return;
 5677                        		__bra		.LL95
         01:CE5A  4C 09 D6   			bra	.LL95
 5678                        	
 5679                        		.dbg	line,	"include\routines_LEVELS.c", 1121; }
 5680                        	
 5681                        		.dbg	line,	"include\routines_LEVELS.c", 1123; else
 5682    01:CE5D             	.LL211:
 5683                        	
 5684                        		.dbg	line,	"include\routines_LEVELS.c", 1124; {
 5685                        	
 5686                        		.dbg	line,	"include\routines_LEVELS.c", 1125; // CHECK COLLISION WITH RIGHT FLOOR //
 5687                        	
 5688                        		.dbg	line,	"include\routines_LEVELS.c", 1126; check_BG( 22 , 32 );
 5689                        		__ld.wi		22
         01:CE5D  A9 16      			lda.l	#22
         01:CE5F  C2         			cly
 5690                        		__pusharg.wr
         01:CE60  A6 8D      			ldx	<__sp
         01:CE62  CA         			dex
         01:CE63  CA         			dex
         01:CE64  95 08      			sta.l	<__stack, x
         01:CE66  94 09      			sty.h	<__stack, x
         01:CE68  86 8D      			stx	<__sp
 5691                        		__ld.wi		32
         01:CE6A  A9 20      			lda.l	#32
         01:CE6C  C2         			cly
 5692                        		__pusharg.wr
         01:CE6D  A6 8D      			ldx	<__sp
         01:CE6F  CA         			dex
         01:CE70  CA         			dex
         01:CE71  95 08      			sta.l	<__stack, x
         01:CE73  94 09      			sty.h	<__stack, x
         01:CE75  86 8D      			stx	<__sp
 5693                        		__call		_check_BG
         01:CE77  20 81 FF   			call	_check_BG
 5694                        	
 5695                        		.dbg	line,	"include\routines_LEVELS.c", 1128; if(map_blk_flag == TILE_BG)
 5696                        		__ld.umq	_map_blk_flag
         01:CE7A  AD E9 29   			lda	_map_blk_flag
 5697                        		__equ_b.uiq	1
         01:CE7D  C9 01      			cmp	#1
         01:CE7F  F0 01      			beq	!+
         01:CE81  18         			clc
         01:CE82             	!:
 5698                        		__bfalse	.LL220
         01:CE82  B0 03 4C 35			bcc	.LL220
         01:CE86  CF          
 5699                        	
 5700                        		.dbg	line,	"include\routines_LEVELS.c", 1129; {
 5701                        	
 5702                        		.dbg	line,	"include\routines_LEVELS.c", 1130; // CALCULATE HOW MANY PIXELS THE PLAYER MOVED INTO THE GROUND //
 5703                        	
 5704                        		.dbg	line,	"include\routines_LEVELS.c", 1131; for(i=1; i<11 ; i++)
 5705                        		__st.umiq	1, __update_PLAYER_end - 4  /* i */
         01:CE87  A9 01      			lda.l	#1
         01:CE89  8D 06 23   			sta	__update_PLAYER_end - 4
 5706    01:CE8C             	.LL221:
 5707                        		__ld.umq	__update_PLAYER_end - 4  /* i */
         01:CE8C  AD 06 23   			lda	__update_PLAYER_end - 4
 5708                        		__ult_b.uiq	11
         01:CE8F  C9 0B      			cmp	#11		; Subtract integer from A.
         01:CE91  6A         			ror	a		; CC if A < integer.
         01:CE92  49 80      			eor	#$80
         01:CE94  2A         			rol	a
 5709                        		__btrue		.LL223
         01:CE95  B0 07      			bcs	.LL223
 5710                        		__bra		.LL224
         01:CE97  80 7D      			bra	.LL224
 5711    01:CE99             	.LL222:
 5712                        		__inc.umq	__update_PLAYER_end - 4  /* i */
         01:CE99  EE 06 23   			inc	__update_PLAYER_end - 4
 5713                        		__bra		.LL221
         01:CE9C  80 EE      			bra	.LL221
 5714    01:CE9E             	.LL223:
 5715                        	
 5716                        		.dbg	line,	"include\routines_LEVELS.c", 1132; {
 5717                        	
 5718                        		.dbg	line,	"include\routines_LEVELS.c", 1133; check_TILE_DEPTH( 22 , i);
 5719                        		__ld.wi		22
         01:CE9E  A9 16      			lda.l	#22
         01:CEA0  C2         			cly
 5720                        		__pusharg.wr
         01:CEA1  A6 8D      			ldx	<__sp
         01:CEA3  CA         			dex
         01:CEA4  CA         			dex
         01:CEA5  95 08      			sta.l	<__stack, x
         01:CEA7  94 09      			sty.h	<__stack, x
         01:CEA9  86 8D      			stx	<__sp
 5721                        		__ld.um		__update_PLAYER_end - 4  /* i */
         01:CEAB  AD 06 23   			lda	__update_PLAYER_end - 4
         01:CEAE  C2         			cly
 5722                        		__pusharg.wr
         01:CEAF  A6 8D      			ldx	<__sp
         01:CEB1  CA         			dex
         01:CEB2  CA         			dex
         01:CEB3  95 08      			sta.l	<__stack, x
         01:CEB5  94 09      			sty.h	<__stack, x
         01:CEB7  86 8D      			stx	<__sp
 5723                        		__call		_check_TILE_DEPTH
         01:CEB9  20 63 FF   			call	_check_TILE_DEPTH
 5724                        	
 5725                        		.dbg	line,	"include\routines_LEVELS.c", 1135; if(map_blk_flag == TILE_EMPTY)
 5726                        		__not.um	_map_blk_flag
         01:CEBC  AD E9 29   			lda	_map_blk_flag
         01:CEBF  18         			clc
         01:CEC0  D0 01      			bne	!+
         01:CEC2  38         			sec
         01:CEC3             	!:
 5727                        		__bfalse	.LL225
         01:CEC3  90 D4      			bcc	.LL225
 5728                        	
 5729                        		.dbg	line,	"include\routines_LEVELS.c", 1136; {
 5730                        	
 5731                        		.dbg	line,	"include\routines_LEVELS.c", 1137; if(player_pos_y != PLAYER_BASE_Y_POS)
 5732                        		__ld.wm		_player_pos_y
         01:CEC5  AD 1A 23   			lda.l	_player_pos_y
         01:CEC8  AC 1B 23   			ldy.h	_player_pos_y
 5733                        		__neq_w.wi	128
         01:CECB  38         			sec
         01:CECC  49 80      			eor.l	#128
         01:CECE  D0 06      			bne	!+
         01:CED0  98         			tya
         01:CED1  49 00      			eor.h	#128
         01:CED3  D0 01      			bne	!+
         01:CED5  18         			clc
         01:CED6             	!:
 5734                        		__bfalse	.LL226
         01:CED6  90 1E      			bcc	.LL226
 5735                        	
 5736                        		.dbg	line,	"include\routines_LEVELS.c", 1138; {
 5737                        	
 5738                        		.dbg	line,	"include\routines_LEVELS.c", 1139; player_pos_y -= (i - 1);
 5739                        		__ld.um		__update_PLAYER_end - 4  /* i */
         01:CED8  AD 06 23   			lda	__update_PLAYER_end - 4
         01:CEDB  C2         			cly
 5740                        		__sub.wi	1
         01:CEDC  38         			sec
         01:CEDD  E9 01      			sbc.l	#1
         01:CEDF  B0 01      			bcs	!+
         01:CEE1  88         			dey
         01:CEE2             	!:
 5741                        		__isub_st.wmq	_player_pos_y
         01:CEE2  38         			sec
         01:CEE3  49 FF      			eor	#$FF
         01:CEE5  6D 1A 23   			adc.l	_player_pos_y
         01:CEE8  8D 1A 23   			sta.l	_player_pos_y
         01:CEEB  98         			tya
         01:CEEC  49 FF      			eor	#$FF
         01:CEEE  6D 1B 23   			adc.h	_player_pos_y
         01:CEF1  8D 1B 23   			sta.h	_player_pos_y
 5742                        	
 5743                        		.dbg	line,	"include\routines_LEVELS.c", 1140; }
 5744                        	
 5745                        		.dbg	line,	"include\routines_LEVELS.c", 1142; else
 5746                        		__bra		.LL227
         01:CEF4  80 20      			bra	.LL227
 5747    01:CEF6             	.LL226:
 5748                        	
 5749                        		.dbg	line,	"include\routines_LEVELS.c", 1143; {
 5750                        	
 5751                        		.dbg	line,	"include\routines_LEVELS.c", 1144; sgx_map_pxl_y -= (i - 1);
 5752                        		__ld.um		__update_PLAYER_end - 4  /* i */
         01:CEF6  AD 06 23   			lda	__update_PLAYER_end - 4
         01:CEF9  C2         			cly
 5753                        		__sub.wi	1
         01:CEFA  38         			sec
         01:CEFB  E9 01      			sbc.l	#1
         01:CEFD  B0 01      			bcs	!+
         01:CEFF  88         			dey
         01:CF00             	!:
 5754                        		__isub_st.wmq	_sgx_map_pxl_y
         01:CF00  38         			sec
         01:CF01  49 FF      			eor	#$FF
         01:CF03  6D CA 24   			adc.l	_sgx_map_pxl_y
         01:CF06  8D CA 24   			sta.l	_sgx_map_pxl_y
         01:CF09  98         			tya
         01:CF0A  49 FF      			eor	#$FF
         01:CF0C  6D CB 24   			adc.h	_sgx_map_pxl_y
         01:CF0F  8D CB 24   			sta.h	_sgx_map_pxl_y
 5755                        	
 5756                        		.dbg	line,	"include\routines_LEVELS.c", 1145; }
 5757    01:CF12             	.LL227	.alias		.LL224
 5758                        	
 5759                        		.dbg	line,	"include\routines_LEVELS.c", 1147; break;
 5760                        		__bra		.LL224
         01:CF12  80 02      			bra	.LL224
 5761                        	
 5762                        		.dbg	line,	"include\routines_LEVELS.c", 1148; }
 5763                        	
 5764                        		.dbg	line,	"include\routines_LEVELS.c", 1149; }
 5765    01:CF14             	.LL225	.alias		.LL222
 5766                        		__bra		.LL222
         01:CF14  80 83      			bra	.LL222
 5767    01:CF16             	.LL224:
 5768                        	
 5769                        		.dbg	line,	"include\routines_LEVELS.c", 1151; // SET PLAYER SPRITE NEW POSITION //
 5770                        	
 5771                        		.dbg	line,	"include\routines_LEVELS.c", 1152; spr_y(player_pos_y);
 5772                        		__ld.wm		_player_pos_y
         01:CF16  AD 1A 23   			lda.l	_player_pos_y
         01:CF19  AC 1B 23   			ldy.h	_player_pos_y
 5773                        		__call		_spr_y.1
         01:CF1C  20 19 E8   			call	_spr_y.1
 5774                        	
 5775                        		.dbg	line,	"include\routines_LEVELS.c", 1154; player_counter_anim = 1;
 5776                        		__st.umiq	1, _player_counter_anim
         01:CF1F  A9 01      			lda.l	#1
         01:CF21  8D 12 23   			sta	_player_counter_anim
 5777                        	
 5778                        		.dbg	line,	"include\routines_LEVELS.c", 1155; player_index_jump = 0;
 5779                        		__st.umiq	0, _player_index_jump
         01:CF24  9C 13 23   			stz	_player_index_jump
 5780                        	
 5781                        		.dbg	line,	"include\routines_LEVELS.c", 1156; jump_ladder = FALSE;
 5782                        		__st.umiq	0, _jump_ladder
         01:CF27  9C 15 23   			stz	_jump_ladder
 5783                        	
 5784                        		.dbg	line,	"include\routines_LEVELS.c", 1157; jump_max_index = 34;
 5785                        		__st.umiq	34, _jump_max_index
         01:CF2A  A9 22      			lda.l	#34
         01:CF2C  8D 16 23   			sta	_jump_max_index
 5786                        	
 5787                        		.dbg	line,	"include\routines_LEVELS.c", 1158; player_state = STATE_IDLE;
 5788                        		__st.umiq	0, _player_state
         01:CF2F  9C 0F 23   			stz	_player_state
 5789                        	
 5790                        		.dbg	line,	"include\routines_LEVELS.c", 1159; return;
 5791                        		__bra		.LL95
         01:CF32  4C 09 D6   			bra	.LL95
 5792                        	
 5793                        		.dbg	line,	"include\routines_LEVELS.c", 1160; }
 5794                        	
 5795                        		.dbg	line,	"include\routines_LEVELS.c", 1161; }
 5796    01:CF35             	.LL220:
 5797    01:CF35             	.LL219:
 5798                        	
 5799                        		.dbg	line,	"include\routines_LEVELS.c", 1162; }
 5800                        	
 5801                        		.dbg	line,	"include\routines_LEVELS.c", 1167; //--------------------------------------------------------------------------------------//
 5802                        	
 5803                        		.dbg	line,	"include\routines_LEVELS.c", 1168; //                                   LADDER COLLISION                                   //
 5804                        	
 5805                        		.dbg	line,	"include\routines_LEVELS.c", 1169; //--------------------------------------------------------------------------------------//
 5806                        	
 5807                        		.dbg	line,	"include\routines_LEVELS.c", 1171; if(player_index_jump > 4)
 5808    01:CF35             	.LL210:
 5809                        		__ld.umq	_player_index_jump
         01:CF35  AD 13 23   			lda	_player_index_jump
 5810                        		__ugt_b.uiq	4
         01:CF38  18         			clc			; Subtract integer+1 from A.
         01:CF39  E9 04      			sbc	#4		; CS if A > integer.
 5811                        		__bfalse	.LL228
         01:CF3B  B0 03 4C CC			bcc	.LL228
         01:CF3F  CF          
 5812                        	
 5813                        		.dbg	line,	"include\routines_LEVELS.c", 1172; {
 5814                        	
 5815                        		.dbg	line,	"include\routines_LEVELS.c", 1173; check_BG( 16 , 16 );
 5816                        		__ld.wi		16
         01:CF40  A9 10      			lda.l	#16
         01:CF42  C2         			cly
 5817                        		__pusharg.wr
         01:CF43  A6 8D      			ldx	<__sp
         01:CF45  CA         			dex
         01:CF46  CA         			dex
         01:CF47  95 08      			sta.l	<__stack, x
         01:CF49  94 09      			sty.h	<__stack, x
         01:CF4B  86 8D      			stx	<__sp
 5818                        		__ld.wi		16
         01:CF4D  A9 10      			lda.l	#16
         01:CF4F  C2         			cly
 5819                        		__pusharg.wr
         01:CF50  A6 8D      			ldx	<__sp
         01:CF52  CA         			dex
         01:CF53  CA         			dex
         01:CF54  95 08      			sta.l	<__stack, x
         01:CF56  94 09      			sty.h	<__stack, x
         01:CF58  86 8D      			stx	<__sp
 5820                        		__call		_check_BG
         01:CF5A  20 81 FF   			call	_check_BG
 5821                        	
 5822                        		.dbg	line,	"include\routines_LEVELS.c", 1175; if(map_blk_flag == TILE_LADDER)
 5823                        		__ld.umq	_map_blk_flag
         01:CF5D  AD E9 29   			lda	_map_blk_flag
 5824                        		__equ_b.uiq	2
         01:CF60  C9 02      			cmp	#2
         01:CF62  F0 01      			beq	!+
         01:CF64  18         			clc
         01:CF65             	!:
 5825                        		__bfalse	.LL229
         01:CF65  90 65      			bcc	.LL229
 5826                        	
 5827                        		.dbg	line,	"include\routines_LEVELS.c", 1176; {
 5828                        	
 5829                        		.dbg	line,	"include\routines_LEVELS.c", 1177; // CAMERA GOES 8 PX BACKWARD //
 5830                        	
 5831                        		.dbg	line,	"include\routines_LEVELS.c", 1178; sgx_map_pxl_x = ( (sgx_map_pxl_x >> 3) << 3 );
 5832                        		__ld.wm		_sgx_map_pxl_x
         01:CF67  AD C8 24   			lda.l	_sgx_map_pxl_x
         01:CF6A  AC C9 24   			ldy.h	_sgx_map_pxl_x
 5833                        		__lsr.wi	3
         01:CF6D  84 00      			sty	__temp
         01:CF6F  20 3A E2   			jsr	lsrw3
 5834                        		__asl.wi	3
         01:CF72  84 00      			sty	__temp
         01:CF74  20 D7 E1   			jsr	aslw3
 5835                        		__st.wmq	_sgx_map_pxl_x
         01:CF77  8D C8 24   			sta.l	_sgx_map_pxl_x
         01:CF7A  8C C9 24   			sty.h	_sgx_map_pxl_x
 5836                        	
 5837                        		.dbg	line,	"include\routines_LEVELS.c", 1180; // SO WE UPDATE THE MAP //
 5838                        	
 5839                        		.dbg	line,	"include\routines_LEVELS.c", 1181; sgx_scroll_map();
 5840                        		__call		_sgx_scroll_map
         01:CF7D  20 95 FF   			call	_sgx_scroll_map
 5841                        	
 5842                        		.dbg	line,	"include\routines_LEVELS.c", 1183; // CHECK IF THE PLAYER STANDS RIGHT TO THE LADDER //
 5843                        	
 5844                        		.dbg	line,	"include\routines_LEVELS.c", 1184; check_BG( 31 , 16 );
 5845                        		__ld.wi		31
         01:CF80  A9 1F      			lda.l	#31
         01:CF82  C2         			cly
 5846                        		__pusharg.wr
         01:CF83  A6 8D      			ldx	<__sp
         01:CF85  CA         			dex
         01:CF86  CA         			dex
         01:CF87  95 08      			sta.l	<__stack, x
         01:CF89  94 09      			sty.h	<__stack, x
         01:CF8B  86 8D      			stx	<__sp
 5847                        		__ld.wi		16
         01:CF8D  A9 10      			lda.l	#16
         01:CF8F  C2         			cly
 5848                        		__pusharg.wr
         01:CF90  A6 8D      			ldx	<__sp
         01:CF92  CA         			dex
         01:CF93  CA         			dex
         01:CF94  95 08      			sta.l	<__stack, x
         01:CF96  94 09      			sty.h	<__stack, x
         01:CF98  86 8D      			stx	<__sp
 5849                        		__call		_check_BG
         01:CF9A  20 81 FF   			call	_check_BG
 5850                        	
 5851                        		.dbg	line,	"include\routines_LEVELS.c", 1186; if(map_blk_flag == TILE_LADDER)
 5852                        		__ld.umq	_map_blk_flag
         01:CF9D  AD E9 29   			lda	_map_blk_flag
 5853                        		__equ_b.uiq	2
         01:CFA0  C9 02      			cmp	#2
         01:CFA2  F0 01      			beq	!+
         01:CFA4  18         			clc
         01:CFA5             	!:
 5854                        		__bfalse	.LL230
         01:CFA5  90 0E      			bcc	.LL230
 5855                        	
 5856                        		.dbg	line,	"include\routines_LEVELS.c", 1187; {
 5857                        	
 5858                        		.dbg	line,	"include\routines_LEVELS.c", 1188; sgx_map_pxl_x += 8;
 5859                        		__add_st.wmiq	8, _sgx_map_pxl_x
         01:CFA7  18         			clc
         01:CFA8  AD C8 24   			lda.l	_sgx_map_pxl_x
         01:CFAB  69 08      			adc.l	#8
         01:CFAD  8D C8 24   			sta.l	_sgx_map_pxl_x
         01:CFB0  90 03      			bcc	!+
         01:CFB2  EE C9 24   			inc.h	_sgx_map_pxl_x
         01:CFB5             	!:
 5860                        	
 5861                        		.dbg	line,	"include\routines_LEVELS.c", 1189; }
 5862                        	
 5863                        		.dbg	line,	"include\routines_LEVELS.c", 1191; player_counter_anim = 1;
 5864    01:CFB5             	.LL230:
 5865                        		__st.umiq	1, _player_counter_anim
         01:CFB5  A9 01      			lda.l	#1
         01:CFB7  8D 12 23   			sta	_player_counter_anim
 5866                        	
 5867                        		.dbg	line,	"include\routines_LEVELS.c", 1192; player_index_jump = 0;
 5868                        		__st.umiq	0, _player_index_jump
         01:CFBA  9C 13 23   			stz	_player_index_jump
 5869                        	
 5870                        		.dbg	line,	"include\routines_LEVELS.c", 1193; jump_ladder = TRUE;
 5871                        		__st.umiq	1, _jump_ladder
         01:CFBD  A9 01      			lda.l	#1
         01:CFBF  8D 15 23   			sta	_jump_ladder
 5872                        	
 5873                        		.dbg	line,	"include\routines_LEVELS.c", 1194; jump_max_index = 29;
 5874                        		__st.umiq	29, _jump_max_index
         01:CFC2  A9 1D      			lda.l	#29
         01:CFC4  8D 16 23   			sta	_jump_max_index
 5875                        	
 5876                        		.dbg	line,	"include\routines_LEVELS.c", 1195; player_state = STATE_HANG;
 5877                        		__st.umiq	10, _player_state
         01:CFC7  A9 0A      			lda.l	#10
         01:CFC9  8D 0F 23   			sta	_player_state
 5878                        	
 5879                        		.dbg	line,	"include\routines_LEVELS.c", 1196; }
 5880                        	
 5881                        		.dbg	line,	"include\routines_LEVELS.c", 1197; }
 5882    01:CFCC             	.LL229:
 5883                        	
 5884                        		.dbg	line,	"include\routines_LEVELS.c", 1200; // SET PLAYER SPRITE NEW POSITION //
 5885                        	
 5886                        		.dbg	line,	"include\routines_LEVELS.c", 1201; spr_y(player_pos_y);
 5887    01:CFCC             	.LL228:
 5888                        		__ld.wm		_player_pos_y
         01:CFCC  AD 1A 23   			lda.l	_player_pos_y
         01:CFCF  AC 1B 23   			ldy.h	_player_pos_y
 5889                        		__call		_spr_y.1
         01:CFD2  20 19 E8   			call	_spr_y.1
 5890                        	
 5891                        		.dbg	line,	"include\routines_LEVELS.c", 1202; }
 5892                        	
 5893                        		.dbg	line,	"include\routines_LEVELS.c", 1205; else if(player_state == STATE_CROUCH)
 5894                        		__bra		.LL231
         01:CFD5  4C 09 D6   			bra	.LL231
 5895    01:CFD8             	.LL195:
 5896                        		__ld.umq	_player_state
         01:CFD8  AD 0F 23   			lda	_player_state
 5897                        		__equ_b.uiq	7
         01:CFDB  C9 07      			cmp	#7
         01:CFDD  F0 01      			beq	!+
         01:CFDF  18         			clc
         01:CFE0             	!:
 5898                        		__bfalse	.LL232
         01:CFE0  90 2F      			bcc	.LL232
 5899                        	
 5900                        		.dbg	line,	"include\routines_LEVELS.c", 1206; {
 5901                        	
 5902                        		.dbg	line,	"include\routines_LEVELS.c", 1207; if(player_counter_anim == 1)
 5903                        		__ld.umq	_player_counter_anim
         01:CFE2  AD 12 23   			lda	_player_counter_anim
 5904                        		__equ_b.uiq	1
         01:CFE5  C9 01      			cmp	#1
         01:CFE7  F0 01      			beq	!+
         01:CFE9  18         			clc
         01:CFEA             	!:
 5905                        		__bfalse	.LL233
         01:CFEA  90 1F      			bcc	.LL233
 5906                        	
 5907                        		.dbg	line,	"include\routines_LEVELS.c", 1208; {
 5908                        	
 5909                        		.dbg	line,	"include\routines_LEVELS.c", 1209; load_vram(PLAYER_VRAM_ADR, tiles_SPR_PLAYER + TILES_128 , TILES_16);
 5910                        		__st.wmiq	6144, _di
         01:CFEC  64 F0      			stz.l	_di
         01:CFEE  A9 18      			lda.h	#6144
         01:CFF0  85 F1      			sta.h	_di
 5911                        		__farptr	_tiles_SPR_PLAYER + 4096, _bp_bank, _bp
         01:CFF2  A9 A0      			lda.l	#$6000 + ($1FFF & (_tiles_SPR_PLAYER + 4096))
         01:CFF4  85 EC      			sta.l	_bp
         01:CFF6  A9 6A      			lda.h	#$6000 + ($1FFF & (_tiles_SPR_PLAYER + 4096))
         01:CFF8  85 ED      			sta.h	_bp
         01:CFFA  A9 0C      			lda	#bank(_tiles_SPR_PLAYER + 4096)
         01:CFFC  85 02      			sta	_bp_bank
 5912                        		__st.wmiq	256, _ax
         01:CFFE  64 F8      			stz.l	_ax
         01:D000  A9 01      			lda.h	#256
         01:D002  85 F9      			sta.h	_ax
 5913                        		 _load_vram.3
         01:D004  82         			clx				; Offset to PCE VDC.
         01:D005  20 77 FF   			call	load_vram_x
 5914                        	
 5915                        		.dbg	line,	"include\routines_LEVELS.c", 1211; player_counter_anim = 0;
 5916                        		__st.umiq	0, _player_counter_anim
         01:D008  9C 12 23   			stz	_player_counter_anim
 5917                        	
 5918                        		.dbg	line,	"include\routines_LEVELS.c", 1212; }
 5919                        	
 5920                        		.dbg	line,	"include\routines_LEVELS.c", 1214; recenter_CAMERA();
 5921    01:D00B             	.LL233:
 5922                        		__call		_recenter_CAMERA
         01:D00B  20 6D FF   			call	_recenter_CAMERA
 5923                        	
 5924                        		.dbg	line,	"include\routines_LEVELS.c", 1215; }
 5925                        	
 5926                        		.dbg	line,	"include\routines_LEVELS.c", 1218; else if(player_state == STATE_FALL)
 5927                        		__bra		.LL234
         01:D00E  4C 09 D6   			bra	.LL234
 5928    01:D011             	.LL232:
 5929                        		__ld.umq	_player_state
         01:D011  AD 0F 23   			lda	_player_state
 5930                        		__equ_b.uiq	9
         01:D014  C9 09      			cmp	#9
         01:D016  F0 01      			beq	!+
         01:D018  18         			clc
         01:D019             	!:
 5931                        		__bfalse	.LL235
         01:D019  B0 03 4C 20			bcc	.LL235
         01:D01D  D2          
 5932                        	
 5933                        		.dbg	line,	"include\routines_LEVELS.c", 1219; {
 5934                        	
 5935                        		.dbg	line,	"include\routines_LEVELS.c", 1220; unsigned char i, camera_y_move;
 5936                        	
 5937                        		.dbg	line,	"include\routines_LEVELS.c", 1221; i = 1;
 5938                        		__st.umiq	1, __update_PLAYER_end - 6  /* i */
         01:D01E  A9 01      			lda.l	#1
         01:D020  8D 04 23   			sta	__update_PLAYER_end - 6
 5939                        	
 5940                        		.dbg	line,	"include\routines_LEVELS.c", 1224; spr_set(player_id);
 5941                        		__ld.umq	_player_id
         01:D023  AD 0E 23   			lda	_player_id
 5942                        		__call		_spr_set.1
         01:D026  20 DD E7   			call	_spr_set.1
 5943                        	
 5944                        		.dbg	line,	"include\routines_LEVELS.c", 1227; //--------------------------------------------------------------------------------------//
 5945                        	
 5946                        		.dbg	line,	"include\routines_LEVELS.c", 1228; //                                        V MOVE                                        //
 5947                        	
 5948                        		.dbg	line,	"include\routines_LEVELS.c", 1229; //--------------------------------------------------------------------------------------//
 5949                        	
 5950                        		.dbg	line,	"include\routines_LEVELS.c", 1231; // UPDATE PLAYER Y POSITION //
 5951                        	
 5952                        		.dbg	line,	"include\routines_LEVELS.c", 1232; player_pos_y += TABLE_PLAYER_FALL[player_index_fall];
 5953                        		__ldx.umq	_player_index_fall
         01:D029  AE 14 23   			ldx	_player_index_fall
 5954                        		__ld.bax	_TABLE_PLAYER_FALL
         01:D02C  BD BD 60   			lda	_TABLE_PLAYER_FALL, x
         01:D02F  C2         			cly
         01:D030  10 01      			bpl	!+
         01:D032  88         			dey
         01:D033             	!:
 5955                        		__add_st.wmq	_player_pos_y
         01:D033  18         			clc
         01:D034  6D 1A 23   			adc.l	_player_pos_y
         01:D037  8D 1A 23   			sta.l	_player_pos_y
         01:D03A  98         			tya
         01:D03B  6D 1B 23   			adc.h	_player_pos_y
         01:D03E  8D 1B 23   			sta.h	_player_pos_y
 5956                        	
 5957                        		.dbg	line,	"include\routines_LEVELS.c", 1235; // IF PLAYER GOES BELOW ITS BASE Y POSITION //
 5958                        	
 5959                        		.dbg	line,	"include\routines_LEVELS.c", 1236; if(player_pos_y >= PLAYER_BASE_Y_POS)
 5960                        		__ld.wm		_player_pos_y
         01:D041  AD 1A 23   			lda.l	_player_pos_y
         01:D044  AC 1B 23   			ldy.h	_player_pos_y
 5961                        		__sge_w.wi	128
         01:D047  C9 80      			cmp.l	#128		; Subtract integer from Y:A.
         01:D049  98         			tya
         01:D04A  E9 00      			sbc.h	#128
         01:D04C  50 02      			bvc	!+
         01:D04E  49 80      			eor	#$80		; +ve if Y:A >= integer (signed).
         01:D050  49 80      	!:		eor	#$80
         01:D052  0A         			asl	a
 5962                        		__bfalse	.LL236
         01:D053  90 45      			bcc	.LL236
 5963                        	
 5964                        		.dbg	line,	"include\routines_LEVELS.c", 1237; {
 5965                        	
 5966                        		.dbg	line,	"include\routines_LEVELS.c", 1238; // THE CAMERA MOVES //
 5967                        	
 5968                        		.dbg	line,	"include\routines_LEVELS.c", 1239; // CALCULATE HOW MANY PIXELS THE CAMERA HAS TO MOVE DOWN //
 5969                        	
 5970                        		.dbg	line,	"include\routines_LEVELS.c", 1240; camera_y_move = player_pos_y - PLAYER_BASE_Y_POS;
 5971                        		__ld.wm		_player_pos_y
         01:D055  AD 1A 23   			lda.l	_player_pos_y
         01:D058  AC 1B 23   			ldy.h	_player_pos_y
 5972                        		__sub.wi	128
         01:D05B  38         			sec
         01:D05C  E9 80      			sbc.l	#128
         01:D05E  B0 01      			bcs	!+
         01:D060  88         			dey
         01:D061             	!:
 5973                        		__st.umq	__update_PLAYER_end - 7  /* camera_y_move */
         01:D061  8D 03 23   			sta	__update_PLAYER_end - 7
 5974                        	
 5975                        		.dbg	line,	"include\routines_LEVELS.c", 1241; sgx_map_pxl_y += camera_y_move;
 5976                        		__ld.um		__update_PLAYER_end - 7  /* camera_y_move */
         01:D064  AD 03 23   			lda	__update_PLAYER_end - 7
         01:D067  C2         			cly
 5977                        		__add_st.wmq	_sgx_map_pxl_y
         01:D068  18         			clc
         01:D069  6D CA 24   			adc.l	_sgx_map_pxl_y
         01:D06C  8D CA 24   			sta.l	_sgx_map_pxl_y
         01:D06F  98         			tya
         01:D070  6D CB 24   			adc.h	_sgx_map_pxl_y
         01:D073  8D CB 24   			sta.h	_sgx_map_pxl_y
 5978                        	
 5979                        		.dbg	line,	"include\routines_LEVELS.c", 1243; // IF THE CAMERA HAS REACHED ITS MAX (LOWEST) POSITION //
 5980                        	
 5981                        		.dbg	line,	"include\routines_LEVELS.c", 1244; if(sgx_map_pxl_y > camera_max_y_position)
 5982                        		__ld.wm		_sgx_map_pxl_y
         01:D076  AD CA 24   			lda.l	_sgx_map_pxl_y
         01:D079  AC CB 24   			ldy.h	_sgx_map_pxl_y
 5983                        		__ugt_w.wm	_camera_max_y_position
         01:D07C  18         			clc			; Subtract memory+1 from Y:A.
         01:D07D  ED 1C 23   			sbc.l	_camera_max_y_position
         01:D080  98         			tya
         01:D081  ED 1D 23   			sbc.h	_camera_max_y_position		; CS if Y:A > memory.
 5984                        		__bfalse	.LL237
         01:D084  90 0C      			bcc	.LL237
 5985                        	
 5986                        		.dbg	line,	"include\routines_LEVELS.c", 1245; {
 5987                        	
 5988                        		.dbg	line,	"include\routines_LEVELS.c", 1246; // THE CAMERA CAN NOT MOVE LOWER //
 5989                        	
 5990                        		.dbg	line,	"include\routines_LEVELS.c", 1247; sgx_map_pxl_y = camera_max_y_position;
 5991                        		__ld.wm		_camera_max_y_position
         01:D086  AD 1C 23   			lda.l	_camera_max_y_position
         01:D089  AC 1D 23   			ldy.h	_camera_max_y_position
 5992                        		__st.wmq	_sgx_map_pxl_y
         01:D08C  8D CA 24   			sta.l	_sgx_map_pxl_y
         01:D08F  8C CB 24   			sty.h	_sgx_map_pxl_y
 5993                        	
 5994                        		.dbg	line,	"include\routines_LEVELS.c", 1248; }
 5995                        	
 5996                        		.dbg	line,	"include\routines_LEVELS.c", 1250; // THE PLAYER STAYS AT ITS BASE Y POSITION //
 5997                        	
 5998                        		.dbg	line,	"include\routines_LEVELS.c", 1251; player_pos_y = PLAYER_BASE_Y_POS;
 5999    01:D092             	.LL237:
 6000                        		__st.wmiq	128, _player_pos_y
         01:D092  A9 80      			lda.l	#128
         01:D094  8D 1A 23   			sta.l	_player_pos_y
         01:D097  9C 1B 23   			stz.h	_player_pos_y
 6001                        	
 6002                        		.dbg	line,	"include\routines_LEVELS.c", 1252; }
 6003                        	
 6004                        		.dbg	line,	"include\routines_LEVELS.c", 1255; // UPDATE JUMP INDEX IN THE ARRAY //
 6005                        	
 6006                        		.dbg	line,	"include\routines_LEVELS.c", 1256; // ARRAY MAX ENTRY : 20//
 6007                        	
 6008                        		.dbg	line,	"include\routines_LEVELS.c", 1257; if(player_index_fall < 20)
 6009    01:D09A             	.LL236:
 6010                        		__ld.umq	_player_index_fall
         01:D09A  AD 14 23   			lda	_player_index_fall
 6011                        		__ult_b.uiq	20
         01:D09D  C9 14      			cmp	#20		; Subtract integer from A.
         01:D09F  6A         			ror	a		; CC if A < integer.
         01:D0A0  49 80      			eor	#$80
         01:D0A2  2A         			rol	a
 6012                        		__bfalse	.LL238
         01:D0A3  90 03      			bcc	.LL238
 6013                        	
 6014                        		.dbg	line,	"include\routines_LEVELS.c", 1258; {
 6015                        	
 6016                        		.dbg	line,	"include\routines_LEVELS.c", 1259; player_index_fall += 1;
 6017                        		__add_st.umiq	1, _player_index_fall
         01:D0A5  EE 14 23   			inc	_player_index_fall
 6018                        	
 6019                        		.dbg	line,	"include\routines_LEVELS.c", 1260; }
 6020                        	
 6021                        		.dbg	line,	"include\routines_LEVELS.c", 1263; check_TILE_DEPTH( 15 , 0);
 6022    01:D0A8             	.LL238:
 6023                        		__ld.wi		15
         01:D0A8  A9 0F      			lda.l	#15
         01:D0AA  C2         			cly
 6024                        		__pusharg.wr
         01:D0AB  A6 8D      			ldx	<__sp
         01:D0AD  CA         			dex
         01:D0AE  CA         			dex
         01:D0AF  95 08      			sta.l	<__stack, x
         01:D0B1  94 09      			sty.h	<__stack, x
         01:D0B3  86 8D      			stx	<__sp
 6025                        		__ld.wi		0
         01:D0B5  62         			cla
         01:D0B6  C2         			cly
 6026                        		__pusharg.wr
         01:D0B7  A6 8D      			ldx	<__sp
         01:D0B9  CA         			dex
         01:D0BA  CA         			dex
         01:D0BB  95 08      			sta.l	<__stack, x
         01:D0BD  94 09      			sty.h	<__stack, x
         01:D0BF  86 8D      			stx	<__sp
 6027                        		__call		_check_TILE_DEPTH
         01:D0C1  20 63 FF   			call	_check_TILE_DEPTH
 6028                        	
 6029                        		.dbg	line,	"include\routines_LEVELS.c", 1266; if(map_blk_flag == TILE_BG)
 6030                        		__ld.umq	_map_blk_flag
         01:D0C4  AD E9 29   			lda	_map_blk_flag
 6031                        		__equ_b.uiq	1
         01:D0C7  C9 01      			cmp	#1
         01:D0C9  F0 01      			beq	!+
         01:D0CB  18         			clc
         01:D0CC             	!:
 6032                        		__bfalse	.LL239
         01:D0CC  B0 03 4C 82			bcc	.LL239
         01:D0D0  D1          
 6033                        	
 6034                        		.dbg	line,	"include\routines_LEVELS.c", 1267; {
 6035                        	
 6036                        		.dbg	line,	"include\routines_LEVELS.c", 1268; // CALCULATE HOW MANY PIXELS THE PLAYER MOVED INTO THE GROUND //
 6037                        	
 6038                        		.dbg	line,	"include\routines_LEVELS.c", 1269; for(i=1; i<11 ; i++ )
 6039                        		__st.umiq	1, __update_PLAYER_end - 6  /* i */
         01:D0D1  A9 01      			lda.l	#1
         01:D0D3  8D 04 23   			sta	__update_PLAYER_end - 6
 6040    01:D0D6             	.LL240:
 6041                        		__ld.umq	__update_PLAYER_end - 6  /* i */
         01:D0D6  AD 04 23   			lda	__update_PLAYER_end - 6
 6042                        		__ult_b.uiq	11
         01:D0D9  C9 0B      			cmp	#11		; Subtract integer from A.
         01:D0DB  6A         			ror	a		; CC if A < integer.
         01:D0DC  49 80      			eor	#$80
         01:D0DE  2A         			rol	a
 6043                        		__btrue		.LL242
         01:D0DF  B0 07      			bcs	.LL242
 6044                        		__bra		.LL243
         01:D0E1  80 7D      			bra	.LL243
 6045    01:D0E3             	.LL241:
 6046                        		__inc.umq	__update_PLAYER_end - 6  /* i */
         01:D0E3  EE 04 23   			inc	__update_PLAYER_end - 6
 6047                        		__bra		.LL240
         01:D0E6  80 EE      			bra	.LL240
 6048    01:D0E8             	.LL242:
 6049                        	
 6050                        		.dbg	line,	"include\routines_LEVELS.c", 1270; {
 6051                        	
 6052                        		.dbg	line,	"include\routines_LEVELS.c", 1271; //if(player_axis == AXIS_RIGHT)
 6053                        	
 6054                        		.dbg	line,	"include\routines_LEVELS.c", 1272; //{
 6055                        	
 6056                        		.dbg	line,	"include\routines_LEVELS.c", 1273; check_TILE_DEPTH( 15 , i);//20
 6057                        		__ld.wi		15
         01:D0E8  A9 0F      			lda.l	#15
         01:D0EA  C2         			cly
 6058                        		__pusharg.wr
         01:D0EB  A6 8D      			ldx	<__sp
         01:D0ED  CA         			dex
         01:D0EE  CA         			dex
         01:D0EF  95 08      			sta.l	<__stack, x
         01:D0F1  94 09      			sty.h	<__stack, x
         01:D0F3  86 8D      			stx	<__sp
 6059                        		__ld.um		__update_PLAYER_end - 6  /* i */
         01:D0F5  AD 04 23   			lda	__update_PLAYER_end - 6
         01:D0F8  C2         			cly
 6060                        		__pusharg.wr
         01:D0F9  A6 8D      			ldx	<__sp
         01:D0FB  CA         			dex
         01:D0FC  CA         			dex
         01:D0FD  95 08      			sta.l	<__stack, x
         01:D0FF  94 09      			sty.h	<__stack, x
         01:D101  86 8D      			stx	<__sp
 6061                        		__call		_check_TILE_DEPTH
         01:D103  20 63 FF   			call	_check_TILE_DEPTH
 6062                        	
 6063                        		.dbg	line,	"include\routines_LEVELS.c", 1274; //}
 6064                        	
 6065                        		.dbg	line,	"include\routines_LEVELS.c", 1276; /*else
 6066                        	
 6067                        		.dbg	line,	"include\routines_LEVELS.c", 1277; {
 6068                        	
 6069                        		.dbg	line,	"include\routines_LEVELS.c", 1278; check_TILE_DEPTH( 10 , i);
 6070                        	
 6071                        		.dbg	line,	"include\routines_LEVELS.c", 1279; }*/
 6072                        	
 6073                        		.dbg	line,	"include\routines_LEVELS.c", 1282; if(map_blk_flag == TILE_EMPTY)
 6074                        		__not.um	_map_blk_flag
         01:D106  AD E9 29   			lda	_map_blk_flag
         01:D109  18         			clc
         01:D10A  D0 01      			bne	!+
         01:D10C  38         			sec
         01:D10D             	!:
 6075                        		__bfalse	.LL244
         01:D10D  90 D4      			bcc	.LL244
 6076                        	
 6077                        		.dbg	line,	"include\routines_LEVELS.c", 1283; {
 6078                        	
 6079                        		.dbg	line,	"include\routines_LEVELS.c", 1284; if(player_pos_y != PLAYER_BASE_Y_POS)
 6080                        		__ld.wm		_player_pos_y
         01:D10F  AD 1A 23   			lda.l	_player_pos_y
         01:D112  AC 1B 23   			ldy.h	_player_pos_y
 6081                        		__neq_w.wi	128
         01:D115  38         			sec
         01:D116  49 80      			eor.l	#128
         01:D118  D0 06      			bne	!+
         01:D11A  98         			tya
         01:D11B  49 00      			eor.h	#128
         01:D11D  D0 01      			bne	!+
         01:D11F  18         			clc
         01:D120             	!:
 6082                        		__bfalse	.LL245
         01:D120  90 1E      			bcc	.LL245
 6083                        	
 6084                        		.dbg	line,	"include\routines_LEVELS.c", 1285; {
 6085                        	
 6086                        		.dbg	line,	"include\routines_LEVELS.c", 1286; player_pos_y -= (i - 1);
 6087                        		__ld.um		__update_PLAYER_end - 6  /* i */
         01:D122  AD 04 23   			lda	__update_PLAYER_end - 6
         01:D125  C2         			cly
 6088                        		__sub.wi	1
         01:D126  38         			sec
         01:D127  E9 01      			sbc.l	#1
         01:D129  B0 01      			bcs	!+
         01:D12B  88         			dey
         01:D12C             	!:
 6089                        		__isub_st.wmq	_player_pos_y
         01:D12C  38         			sec
         01:D12D  49 FF      			eor	#$FF
         01:D12F  6D 1A 23   			adc.l	_player_pos_y
         01:D132  8D 1A 23   			sta.l	_player_pos_y
         01:D135  98         			tya
         01:D136  49 FF      			eor	#$FF
         01:D138  6D 1B 23   			adc.h	_player_pos_y
         01:D13B  8D 1B 23   			sta.h	_player_pos_y
 6090                        	
 6091                        		.dbg	line,	"include\routines_LEVELS.c", 1287; }
 6092                        	
 6093                        		.dbg	line,	"include\routines_LEVELS.c", 1289; else
 6094                        		__bra		.LL246
         01:D13E  80 20      			bra	.LL246
 6095    01:D140             	.LL245:
 6096                        	
 6097                        		.dbg	line,	"include\routines_LEVELS.c", 1290; {
 6098                        	
 6099                        		.dbg	line,	"include\routines_LEVELS.c", 1291; sgx_map_pxl_y -= (i - 1);
 6100                        		__ld.um		__update_PLAYER_end - 6  /* i */
         01:D140  AD 04 23   			lda	__update_PLAYER_end - 6
         01:D143  C2         			cly
 6101                        		__sub.wi	1
         01:D144  38         			sec
         01:D145  E9 01      			sbc.l	#1
         01:D147  B0 01      			bcs	!+
         01:D149  88         			dey
         01:D14A             	!:
 6102                        		__isub_st.wmq	_sgx_map_pxl_y
         01:D14A  38         			sec
         01:D14B  49 FF      			eor	#$FF
         01:D14D  6D CA 24   			adc.l	_sgx_map_pxl_y
         01:D150  8D CA 24   			sta.l	_sgx_map_pxl_y
         01:D153  98         			tya
         01:D154  49 FF      			eor	#$FF
         01:D156  6D CB 24   			adc.h	_sgx_map_pxl_y
         01:D159  8D CB 24   			sta.h	_sgx_map_pxl_y
 6103                        	
 6104                        		.dbg	line,	"include\routines_LEVELS.c", 1292; }
 6105    01:D15C             	.LL246	.alias		.LL243
 6106                        	
 6107                        		.dbg	line,	"include\routines_LEVELS.c", 1295; break;
 6108                        		__bra		.LL243
         01:D15C  80 02      			bra	.LL243
 6109                        	
 6110                        		.dbg	line,	"include\routines_LEVELS.c", 1296; }
 6111                        	
 6112                        		.dbg	line,	"include\routines_LEVELS.c", 1298; }
 6113    01:D15E             	.LL244	.alias		.LL241
 6114                        		__bra		.LL241
         01:D15E  80 83      			bra	.LL241
 6115    01:D160             	.LL243:
 6116                        	
 6117                        		.dbg	line,	"include\routines_LEVELS.c", 1300; spr_y(player_pos_y);
 6118                        		__ld.wm		_player_pos_y
         01:D160  AD 1A 23   			lda.l	_player_pos_y
         01:D163  AC 1B 23   			ldy.h	_player_pos_y
 6119                        		__call		_spr_y.1
         01:D166  20 19 E8   			call	_spr_y.1
 6120                        	
 6121                        		.dbg	line,	"include\routines_LEVELS.c", 1302; player_counter_anim = 1;
 6122                        		__st.umiq	1, _player_counter_anim
         01:D169  A9 01      			lda.l	#1
         01:D16B  8D 12 23   			sta	_player_counter_anim
 6123                        	
 6124                        		.dbg	line,	"include\routines_LEVELS.c", 1303; player_index_jump = 0;
 6125                        		__st.umiq	0, _player_index_jump
         01:D16E  9C 13 23   			stz	_player_index_jump
 6126                        	
 6127                        		.dbg	line,	"include\routines_LEVELS.c", 1304; player_index_fall = 0;
 6128                        		__st.umiq	0, _player_index_fall
         01:D171  9C 14 23   			stz	_player_index_fall
 6129                        	
 6130                        		.dbg	line,	"include\routines_LEVELS.c", 1305; jump_ladder = FALSE;
 6131                        		__st.umiq	0, _jump_ladder
         01:D174  9C 15 23   			stz	_jump_ladder
 6132                        	
 6133                        		.dbg	line,	"include\routines_LEVELS.c", 1306; jump_max_index = 34;
 6134                        		__st.umiq	34, _jump_max_index
         01:D177  A9 22      			lda.l	#34
         01:D179  8D 16 23   			sta	_jump_max_index
 6135                        	
 6136                        		.dbg	line,	"include\routines_LEVELS.c", 1307; player_state = STATE_IDLE;
 6137                        		__st.umiq	0, _player_state
         01:D17C  9C 0F 23   			stz	_player_state
 6138                        	
 6139                        		.dbg	line,	"include\routines_LEVELS.c", 1308; return;
 6140                        		__bra		.LL95
         01:D17F  4C 09 D6   			bra	.LL95
 6141                        	
 6142                        		.dbg	line,	"include\routines_LEVELS.c", 1309; }
 6143                        	
 6144                        		.dbg	line,	"include\routines_LEVELS.c", 1312; check_BG( 16 , 16 );
 6145    01:D182             	.LL239:
 6146                        		__ld.wi		16
         01:D182  A9 10      			lda.l	#16
         01:D184  C2         			cly
 6147                        		__pusharg.wr
         01:D185  A6 8D      			ldx	<__sp
         01:D187  CA         			dex
         01:D188  CA         			dex
         01:D189  95 08      			sta.l	<__stack, x
         01:D18B  94 09      			sty.h	<__stack, x
         01:D18D  86 8D      			stx	<__sp
 6148                        		__ld.wi		16
         01:D18F  A9 10      			lda.l	#16
         01:D191  C2         			cly
 6149                        		__pusharg.wr
         01:D192  A6 8D      			ldx	<__sp
         01:D194  CA         			dex
         01:D195  CA         			dex
         01:D196  95 08      			sta.l	<__stack, x
         01:D198  94 09      			sty.h	<__stack, x
         01:D19A  86 8D      			stx	<__sp
 6150                        		__call		_check_BG
         01:D19C  20 81 FF   			call	_check_BG
 6151                        	
 6152                        		.dbg	line,	"include\routines_LEVELS.c", 1314; // IF PLAYER HITS THE LADDER //
 6153                        	
 6154                        		.dbg	line,	"include\routines_LEVELS.c", 1315; if(map_blk_flag == TILE_LADDER)
 6155                        		__ld.umq	_map_blk_flag
         01:D19F  AD E9 29   			lda	_map_blk_flag
 6156                        		__equ_b.uiq	2
         01:D1A2  C9 02      			cmp	#2
         01:D1A4  F0 01      			beq	!+
         01:D1A6  18         			clc
         01:D1A7             	!:
 6157                        		__bfalse	.LL247
         01:D1A7  90 6B      			bcc	.LL247
 6158                        	
 6159                        		.dbg	line,	"include\routines_LEVELS.c", 1316; {
 6160                        	
 6161                        		.dbg	line,	"include\routines_LEVELS.c", 1317; // CAMERA GOES 8 PX BACKWARD //
 6162                        	
 6163                        		.dbg	line,	"include\routines_LEVELS.c", 1318; sgx_map_pxl_x = ( (sgx_map_pxl_x >> 3) << 3 );
 6164                        		__ld.wm		_sgx_map_pxl_x
         01:D1A9  AD C8 24   			lda.l	_sgx_map_pxl_x
         01:D1AC  AC C9 24   			ldy.h	_sgx_map_pxl_x
 6165                        		__lsr.wi	3
         01:D1AF  84 00      			sty	__temp
         01:D1B1  20 3A E2   			jsr	lsrw3
 6166                        		__asl.wi	3
         01:D1B4  84 00      			sty	__temp
         01:D1B6  20 D7 E1   			jsr	aslw3
 6167                        		__st.wmq	_sgx_map_pxl_x
         01:D1B9  8D C8 24   			sta.l	_sgx_map_pxl_x
         01:D1BC  8C C9 24   			sty.h	_sgx_map_pxl_x
 6168                        	
 6169                        		.dbg	line,	"include\routines_LEVELS.c", 1320; // SO WE UPDATE THE MAP //
 6170                        	
 6171                        		.dbg	line,	"include\routines_LEVELS.c", 1321; sgx_scroll_map();
 6172                        		__call		_sgx_scroll_map
         01:D1BF  20 95 FF   			call	_sgx_scroll_map
 6173                        	
 6174                        		.dbg	line,	"include\routines_LEVELS.c", 1323; // CHECK IF THE PLAYER STANDS RIGHT TO THE LADDER //
 6175                        	
 6176                        		.dbg	line,	"include\routines_LEVELS.c", 1324; check_BG( 31 , 16 );
 6177                        		__ld.wi		31
         01:D1C2  A9 1F      			lda.l	#31
         01:D1C4  C2         			cly
 6178                        		__pusharg.wr
         01:D1C5  A6 8D      			ldx	<__sp
         01:D1C7  CA         			dex
         01:D1C8  CA         			dex
         01:D1C9  95 08      			sta.l	<__stack, x
         01:D1CB  94 09      			sty.h	<__stack, x
         01:D1CD  86 8D      			stx	<__sp
 6179                        		__ld.wi		16
         01:D1CF  A9 10      			lda.l	#16
         01:D1D1  C2         			cly
 6180                        		__pusharg.wr
         01:D1D2  A6 8D      			ldx	<__sp
         01:D1D4  CA         			dex
         01:D1D5  CA         			dex
         01:D1D6  95 08      			sta.l	<__stack, x
         01:D1D8  94 09      			sty.h	<__stack, x
         01:D1DA  86 8D      			stx	<__sp
 6181                        		__call		_check_BG
         01:D1DC  20 81 FF   			call	_check_BG
 6182                        	
 6183                        		.dbg	line,	"include\routines_LEVELS.c", 1326; if(map_blk_flag == TILE_LADDER)
 6184                        		__ld.umq	_map_blk_flag
         01:D1DF  AD E9 29   			lda	_map_blk_flag
 6185                        		__equ_b.uiq	2
         01:D1E2  C9 02      			cmp	#2
         01:D1E4  F0 01      			beq	!+
         01:D1E6  18         			clc
         01:D1E7             	!:
 6186                        		__bfalse	.LL248
         01:D1E7  90 0E      			bcc	.LL248
 6187                        	
 6188                        		.dbg	line,	"include\routines_LEVELS.c", 1327; {
 6189                        	
 6190                        		.dbg	line,	"include\routines_LEVELS.c", 1328; sgx_map_pxl_x += 8;
 6191                        		__add_st.wmiq	8, _sgx_map_pxl_x
         01:D1E9  18         			clc
         01:D1EA  AD C8 24   			lda.l	_sgx_map_pxl_x
         01:D1ED  69 08      			adc.l	#8
         01:D1EF  8D C8 24   			sta.l	_sgx_map_pxl_x
         01:D1F2  90 03      			bcc	!+
         01:D1F4  EE C9 24   			inc.h	_sgx_map_pxl_x
         01:D1F7             	!:
 6192                        	
 6193                        		.dbg	line,	"include\routines_LEVELS.c", 1329; }
 6194                        	
 6195                        		.dbg	line,	"include\routines_LEVELS.c", 1331; player_counter_anim = 1;
 6196    01:D1F7             	.LL248:
 6197                        		__st.umiq	1, _player_counter_anim
         01:D1F7  A9 01      			lda.l	#1
         01:D1F9  8D 12 23   			sta	_player_counter_anim
 6198                        	
 6199                        		.dbg	line,	"include\routines_LEVELS.c", 1332; player_index_jump = 0;
 6200                        		__st.umiq	0, _player_index_jump
         01:D1FC  9C 13 23   			stz	_player_index_jump
 6201                        	
 6202                        		.dbg	line,	"include\routines_LEVELS.c", 1333; player_index_fall = 0;
 6203                        		__st.umiq	0, _player_index_fall
         01:D1FF  9C 14 23   			stz	_player_index_fall
 6204                        	
 6205                        		.dbg	line,	"include\routines_LEVELS.c", 1334; jump_ladder = TRUE;
 6206                        		__st.umiq	1, _jump_ladder
         01:D202  A9 01      			lda.l	#1
         01:D204  8D 15 23   			sta	_jump_ladder
 6207                        	
 6208                        		.dbg	line,	"include\routines_LEVELS.c", 1335; jump_max_index = 29;
 6209                        		__st.umiq	29, _jump_max_index
         01:D207  A9 1D      			lda.l	#29
         01:D209  8D 16 23   			sta	_jump_max_index
 6210                        	
 6211                        		.dbg	line,	"include\routines_LEVELS.c", 1336; player_state = STATE_HANG;
 6212                        		__st.umiq	10, _player_state
         01:D20C  A9 0A      			lda.l	#10
         01:D20E  8D 0F 23   			sta	_player_state
 6213                        	
 6214                        		.dbg	line,	"include\routines_LEVELS.c", 1337; return;
 6215                        		__bra		.LL95
         01:D211  4C 09 D6   			bra	.LL95
 6216                        	
 6217                        		.dbg	line,	"include\routines_LEVELS.c", 1338; }
 6218                        	
 6219                        		.dbg	line,	"include\routines_LEVELS.c", 1341; spr_y(player_pos_y);
 6220    01:D214             	.LL247:
 6221                        		__ld.wm		_player_pos_y
         01:D214  AD 1A 23   			lda.l	_player_pos_y
         01:D217  AC 1B 23   			ldy.h	_player_pos_y
 6222                        		__call		_spr_y.1
         01:D21A  20 19 E8   			call	_spr_y.1
 6223                        	
 6224                        		.dbg	line,	"include\routines_LEVELS.c", 1342; }
 6225                        	
 6226                        		.dbg	line,	"include\routines_LEVELS.c", 1345; else if(player_state == STATE_HANG)
 6227                        		__bra		.LL249
         01:D21D  4C 09 D6   			bra	.LL249
 6228    01:D220             	.LL235:
 6229                        		__ld.umq	_player_state
         01:D220  AD 0F 23   			lda	_player_state
 6230                        		__equ_b.uiq	10
         01:D223  C9 0A      			cmp	#10
         01:D225  F0 01      			beq	!+
         01:D227  18         			clc
         01:D228             	!:
 6231                        		__bfalse	.LL250
         01:D228  90 32      			bcc	.LL250
 6232                        	
 6233                        		.dbg	line,	"include\routines_LEVELS.c", 1346; {
 6234                        	
 6235                        		.dbg	line,	"include\routines_LEVELS.c", 1347; recenter_CAMERA();
 6236                        		__call		_recenter_CAMERA
         01:D22A  20 6D FF   			call	_recenter_CAMERA
 6237                        	
 6238                        		.dbg	line,	"include\routines_LEVELS.c", 1349; if(player_counter_anim == 1)
 6239                        		__ld.umq	_player_counter_anim
         01:D22D  AD 12 23   			lda	_player_counter_anim
 6240                        		__equ_b.uiq	1
         01:D230  C9 01      			cmp	#1
         01:D232  F0 01      			beq	!+
         01:D234  18         			clc
         01:D235             	!:
 6241                        		__bfalse	.LL251
         01:D235  B0 03 4C 09			bcc	.LL251
         01:D239  D6          
 6242                        	
 6243                        		.dbg	line,	"include\routines_LEVELS.c", 1350; {
 6244                        	
 6245                        		.dbg	line,	"include\routines_LEVELS.c", 1351; load_vram(PLAYER_VRAM_ADR, tiles_SPR_PLAYER + TILES_144 , TILES_16);
 6246                        		__st.wmiq	6144, _di
         01:D23A  64 F0      			stz.l	_di
         01:D23C  A9 18      			lda.h	#6144
         01:D23E  85 F1      			sta.h	_di
 6247                        		__farptr	_tiles_SPR_PLAYER + 4608, _bp_bank, _bp
         01:D240  A9 A0      			lda.l	#$6000 + ($1FFF & (_tiles_SPR_PLAYER + 4608))
         01:D242  85 EC      			sta.l	_bp
         01:D244  A9 6C      			lda.h	#$6000 + ($1FFF & (_tiles_SPR_PLAYER + 4608))
         01:D246  85 ED      			sta.h	_bp
         01:D248  A9 0C      			lda	#bank(_tiles_SPR_PLAYER + 4608)
         01:D24A  85 02      			sta	_bp_bank
 6248                        		__st.wmiq	256, _ax
         01:D24C  64 F8      			stz.l	_ax
         01:D24E  A9 01      			lda.h	#256
         01:D250  85 F9      			sta.h	_ax
 6249                        		 _load_vram.3
         01:D252  82         			clx				; Offset to PCE VDC.
         01:D253  20 77 FF   			call	load_vram_x
 6250                        	
 6251                        		.dbg	line,	"include\routines_LEVELS.c", 1353; player_counter_anim = 0;
 6252                        		__st.umiq	0, _player_counter_anim
         01:D256  9C 12 23   			stz	_player_counter_anim
 6253                        	
 6254                        		.dbg	line,	"include\routines_LEVELS.c", 1354; }
 6255                        	
 6256                        		.dbg	line,	"include\routines_LEVELS.c", 1355; }
 6257    01:D259             	.LL251	.alias		.LL252
 6258                        	
 6259                        		.dbg	line,	"include\routines_LEVELS.c", 1358; else if(player_state == STATE_CLIMB_UP)
 6260                        		__bra		.LL252
         01:D259  4C 09 D6   			bra	.LL252
 6261    01:D25C             	.LL250:
 6262                        		__ld.umq	_player_state
         01:D25C  AD 0F 23   			lda	_player_state
 6263                        		__equ_b.uiq	11
         01:D25F  C9 0B      			cmp	#11
         01:D261  F0 01      			beq	!+
         01:D263  18         			clc
         01:D264             	!:
 6264                        		__bfalse	.LL253
         01:D264  B0 03 4C 6E			bcc	.LL253
         01:D268  D3          
 6265                        	
 6266                        		.dbg	line,	"include\routines_LEVELS.c", 1359; {
 6267                        	
 6268                        		.dbg	line,	"include\routines_LEVELS.c", 1360; if(player_counter_anim == 0)
 6269                        		__not.um	_player_counter_anim
         01:D269  AD 12 23   			lda	_player_counter_anim
         01:D26C  18         			clc
         01:D26D  D0 01      			bne	!+
         01:D26F  38         			sec
         01:D270             	!:
 6270                        		__bfalse	.LL254
         01:D270  90 1F      			bcc	.LL254
 6271                        	
 6272                        		.dbg	line,	"include\routines_LEVELS.c", 1361; {
 6273                        	
 6274                        		.dbg	line,	"include\routines_LEVELS.c", 1362; load_vram(PLAYER_VRAM_ADR, tiles_SPR_PLAYER + TILES_160 , TILES_16);
 6275                        		__st.wmiq	6144, _di
         01:D272  64 F0      			stz.l	_di
         01:D274  A9 18      			lda.h	#6144
         01:D276  85 F1      			sta.h	_di
 6276                        		__farptr	_tiles_SPR_PLAYER + 5120, _bp_bank, _bp
         01:D278  A9 A0      			lda.l	#$6000 + ($1FFF & (_tiles_SPR_PLAYER + 5120))
         01:D27A  85 EC      			sta.l	_bp
         01:D27C  A9 6E      			lda.h	#$6000 + ($1FFF & (_tiles_SPR_PLAYER + 5120))
         01:D27E  85 ED      			sta.h	_bp
         01:D280  A9 0C      			lda	#bank(_tiles_SPR_PLAYER + 5120)
         01:D282  85 02      			sta	_bp_bank
 6277                        		__st.wmiq	256, _ax
         01:D284  64 F8      			stz.l	_ax
         01:D286  A9 01      			lda.h	#256
         01:D288  85 F9      			sta.h	_ax
 6278                        		 _load_vram.3
         01:D28A  82         			clx				; Offset to PCE VDC.
         01:D28B  20 77 FF   			call	load_vram_x
 6279                        	
 6280                        		.dbg	line,	"include\routines_LEVELS.c", 1363; }
 6281                        	
 6282                        		.dbg	line,	"include\routines_LEVELS.c", 1365; else if(player_counter_anim == 3)
 6283                        		__bra		.LL255
         01:D28E  4C 58 D3   			bra	.LL255
 6284    01:D291             	.LL254:
 6285                        		__ld.umq	_player_counter_anim
         01:D291  AD 12 23   			lda	_player_counter_anim
 6286                        		__equ_b.uiq	3
         01:D294  C9 03      			cmp	#3
         01:D296  F0 01      			beq	!+
         01:D298  18         			clc
         01:D299             	!:
 6287                        		__bfalse	.LL256
         01:D299  90 1F      			bcc	.LL256
 6288                        	
 6289                        		.dbg	line,	"include\routines_LEVELS.c", 1366; {
 6290                        	
 6291                        		.dbg	line,	"include\routines_LEVELS.c", 1367; load_vram(PLAYER_VRAM_ADR, tiles_SPR_PLAYER + TILES_176 , TILES_16);
 6292                        		__st.wmiq	6144, _di
         01:D29B  64 F0      			stz.l	_di
         01:D29D  A9 18      			lda.h	#6144
         01:D29F  85 F1      			sta.h	_di
 6293                        		__farptr	_tiles_SPR_PLAYER + 5632, _bp_bank, _bp
         01:D2A1  A9 A0      			lda.l	#$6000 + ($1FFF & (_tiles_SPR_PLAYER + 5632))
         01:D2A3  85 EC      			sta.l	_bp
         01:D2A5  A9 70      			lda.h	#$6000 + ($1FFF & (_tiles_SPR_PLAYER + 5632))
         01:D2A7  85 ED      			sta.h	_bp
         01:D2A9  A9 0C      			lda	#bank(_tiles_SPR_PLAYER + 5632)
         01:D2AB  85 02      			sta	_bp_bank
 6294                        		__st.wmiq	256, _ax
         01:D2AD  64 F8      			stz.l	_ax
         01:D2AF  A9 01      			lda.h	#256
         01:D2B1  85 F9      			sta.h	_ax
 6295                        		 _load_vram.3
         01:D2B3  82         			clx				; Offset to PCE VDC.
         01:D2B4  20 77 FF   			call	load_vram_x
 6296                        	
 6297                        		.dbg	line,	"include\routines_LEVELS.c", 1368; }
 6298                        	
 6299                        		.dbg	line,	"include\routines_LEVELS.c", 1370; else if(player_counter_anim == 6)
 6300                        		__bra		.LL257
         01:D2B7  4C 58 D3   			bra	.LL257
 6301    01:D2BA             	.LL256:
 6302                        		__ld.umq	_player_counter_anim
         01:D2BA  AD 12 23   			lda	_player_counter_anim
 6303                        		__equ_b.uiq	6
         01:D2BD  C9 06      			cmp	#6
         01:D2BF  F0 01      			beq	!+
         01:D2C1  18         			clc
         01:D2C2             	!:
 6304                        		__bfalse	.LL258
         01:D2C2  90 1E      			bcc	.LL258
 6305                        	
 6306                        		.dbg	line,	"include\routines_LEVELS.c", 1371; {
 6307                        	
 6308                        		.dbg	line,	"include\routines_LEVELS.c", 1372; load_vram(PLAYER_VRAM_ADR, tiles_SPR_PLAYER + TILES_192 , TILES_16);
 6309                        		__st.wmiq	6144, _di
         01:D2C4  64 F0      			stz.l	_di
         01:D2C6  A9 18      			lda.h	#6144
         01:D2C8  85 F1      			sta.h	_di
 6310                        		__farptr	_tiles_SPR_PLAYER + 6144, _bp_bank, _bp
         01:D2CA  A9 A0      			lda.l	#$6000 + ($1FFF & (_tiles_SPR_PLAYER + 6144))
         01:D2CC  85 EC      			sta.l	_bp
         01:D2CE  A9 72      			lda.h	#$6000 + ($1FFF & (_tiles_SPR_PLAYER + 6144))
         01:D2D0  85 ED      			sta.h	_bp
         01:D2D2  A9 0C      			lda	#bank(_tiles_SPR_PLAYER + 6144)
         01:D2D4  85 02      			sta	_bp_bank
 6311                        		__st.wmiq	256, _ax
         01:D2D6  64 F8      			stz.l	_ax
         01:D2D8  A9 01      			lda.h	#256
         01:D2DA  85 F9      			sta.h	_ax
 6312                        		 _load_vram.3
         01:D2DC  82         			clx				; Offset to PCE VDC.
         01:D2DD  20 77 FF   			call	load_vram_x
 6313                        	
 6314                        		.dbg	line,	"include\routines_LEVELS.c", 1373; }
 6315                        	
 6316                        		.dbg	line,	"include\routines_LEVELS.c", 1375; else if(player_counter_anim == 9)
 6317                        		__bra		.LL259
         01:D2E0  80 76      			bra	.LL259
 6318    01:D2E2             	.LL258:
 6319                        		__ld.umq	_player_counter_anim
         01:D2E2  AD 12 23   			lda	_player_counter_anim
 6320                        		__equ_b.uiq	9
         01:D2E5  C9 09      			cmp	#9
         01:D2E7  F0 01      			beq	!+
         01:D2E9  18         			clc
         01:D2EA             	!:
 6321                        		__bfalse	.LL260
         01:D2EA  90 1E      			bcc	.LL260
 6322                        	
 6323                        		.dbg	line,	"include\routines_LEVELS.c", 1376; {
 6324                        	
 6325                        		.dbg	line,	"include\routines_LEVELS.c", 1377; load_vram(PLAYER_VRAM_ADR, tiles_SPR_PLAYER + TILES_208 , TILES_16);
 6326                        		__st.wmiq	6144, _di
         01:D2EC  64 F0      			stz.l	_di
         01:D2EE  A9 18      			lda.h	#6144
         01:D2F0  85 F1      			sta.h	_di
 6327                        		__farptr	_tiles_SPR_PLAYER + 6656, _bp_bank, _bp
         01:D2F2  A9 A0      			lda.l	#$6000 + ($1FFF & (_tiles_SPR_PLAYER + 6656))
         01:D2F4  85 EC      			sta.l	_bp
         01:D2F6  A9 74      			lda.h	#$6000 + ($1FFF & (_tiles_SPR_PLAYER + 6656))
         01:D2F8  85 ED      			sta.h	_bp
         01:D2FA  A9 0C      			lda	#bank(_tiles_SPR_PLAYER + 6656)
         01:D2FC  85 02      			sta	_bp_bank
 6328                        		__st.wmiq	256, _ax
         01:D2FE  64 F8      			stz.l	_ax
         01:D300  A9 01      			lda.h	#256
         01:D302  85 F9      			sta.h	_ax
 6329                        		 _load_vram.3
         01:D304  82         			clx				; Offset to PCE VDC.
         01:D305  20 77 FF   			call	load_vram_x
 6330                        	
 6331                        		.dbg	line,	"include\routines_LEVELS.c", 1378; }
 6332                        	
 6333                        		.dbg	line,	"include\routines_LEVELS.c", 1380; else if(player_counter_anim == 12)
 6334                        		__bra		.LL261
         01:D308  80 4E      			bra	.LL261
 6335    01:D30A             	.LL260:
 6336                        		__ld.umq	_player_counter_anim
         01:D30A  AD 12 23   			lda	_player_counter_anim
 6337                        		__equ_b.uiq	12
         01:D30D  C9 0C      			cmp	#12
         01:D30F  F0 01      			beq	!+
         01:D311  18         			clc
         01:D312             	!:
 6338                        		__bfalse	.LL262
         01:D312  90 1E      			bcc	.LL262
 6339                        	
 6340                        		.dbg	line,	"include\routines_LEVELS.c", 1381; {
 6341                        	
 6342                        		.dbg	line,	"include\routines_LEVELS.c", 1382; load_vram(PLAYER_VRAM_ADR, tiles_SPR_PLAYER + TILES_192 , TILES_16);
 6343                        		__st.wmiq	6144, _di
         01:D314  64 F0      			stz.l	_di
         01:D316  A9 18      			lda.h	#6144
         01:D318  85 F1      			sta.h	_di
 6344                        		__farptr	_tiles_SPR_PLAYER + 6144, _bp_bank, _bp
         01:D31A  A9 A0      			lda.l	#$6000 + ($1FFF & (_tiles_SPR_PLAYER + 6144))
         01:D31C  85 EC      			sta.l	_bp
         01:D31E  A9 72      			lda.h	#$6000 + ($1FFF & (_tiles_SPR_PLAYER + 6144))
         01:D320  85 ED      			sta.h	_bp
         01:D322  A9 0C      			lda	#bank(_tiles_SPR_PLAYER + 6144)
         01:D324  85 02      			sta	_bp_bank
 6345                        		__st.wmiq	256, _ax
         01:D326  64 F8      			stz.l	_ax
         01:D328  A9 01      			lda.h	#256
         01:D32A  85 F9      			sta.h	_ax
 6346                        		 _load_vram.3
         01:D32C  82         			clx				; Offset to PCE VDC.
         01:D32D  20 77 FF   			call	load_vram_x
 6347                        	
 6348                        		.dbg	line,	"include\routines_LEVELS.c", 1383; }
 6349                        	
 6350                        		.dbg	line,	"include\routines_LEVELS.c", 1385; else if(player_counter_anim == 15)
 6351                        		__bra		.LL263
         01:D330  80 26      			bra	.LL263
 6352    01:D332             	.LL262:
 6353                        		__ld.umq	_player_counter_anim
         01:D332  AD 12 23   			lda	_player_counter_anim
 6354                        		__equ_b.uiq	15
         01:D335  C9 0F      			cmp	#15
         01:D337  F0 01      			beq	!+
         01:D339  18         			clc
         01:D33A             	!:
 6355                        		__bfalse	.LL264
         01:D33A  90 1C      			bcc	.LL264
 6356                        	
 6357                        		.dbg	line,	"include\routines_LEVELS.c", 1386; {
 6358                        	
 6359                        		.dbg	line,	"include\routines_LEVELS.c", 1387; load_vram(PLAYER_VRAM_ADR, tiles_SPR_PLAYER + TILES_176 , TILES_16);
 6360                        		__st.wmiq	6144, _di
         01:D33C  64 F0      			stz.l	_di
         01:D33E  A9 18      			lda.h	#6144
         01:D340  85 F1      			sta.h	_di
 6361                        		__farptr	_tiles_SPR_PLAYER + 5632, _bp_bank, _bp
         01:D342  A9 A0      			lda.l	#$6000 + ($1FFF & (_tiles_SPR_PLAYER + 5632))
         01:D344  85 EC      			sta.l	_bp
         01:D346  A9 70      			lda.h	#$6000 + ($1FFF & (_tiles_SPR_PLAYER + 5632))
         01:D348  85 ED      			sta.h	_bp
         01:D34A  A9 0C      			lda	#bank(_tiles_SPR_PLAYER + 5632)
         01:D34C  85 02      			sta	_bp_bank
 6362                        		__st.wmiq	256, _ax
         01:D34E  64 F8      			stz.l	_ax
         01:D350  A9 01      			lda.h	#256
         01:D352  85 F9      			sta.h	_ax
 6363                        		 _load_vram.3
         01:D354  82         			clx				; Offset to PCE VDC.
         01:D355  20 77 FF   			call	load_vram_x
 6364                        	
 6365                        		.dbg	line,	"include\routines_LEVELS.c", 1388; }
 6366                        	
 6367                        		.dbg	line,	"include\routines_LEVELS.c", 1391; player_counter_anim += 1;
 6368    01:D358             	.LL264:
 6369    01:D358             	.LL263:
 6370    01:D358             	.LL261:
 6371    01:D358             	.LL259:
 6372    01:D358             	.LL257:
 6373    01:D358             	.LL255:
 6374                        		__add_st.umiq	1, _player_counter_anim
         01:D358  EE 12 23   			inc	_player_counter_anim
 6375                        	
 6376                        		.dbg	line,	"include\routines_LEVELS.c", 1393; if(player_counter_anim == 17)
 6377                        		__ld.umq	_player_counter_anim
         01:D35B  AD 12 23   			lda	_player_counter_anim
 6378                        		__equ_b.uiq	17
         01:D35E  C9 11      			cmp	#17
         01:D360  F0 01      			beq	!+
         01:D362  18         			clc
         01:D363             	!:
 6379                        		__bfalse	.LL265
         01:D363  90 03      			bcc	.LL265
 6380                        	
 6381                        		.dbg	line,	"include\routines_LEVELS.c", 1394; {
 6382                        	
 6383                        		.dbg	line,	"include\routines_LEVELS.c", 1395; player_counter_anim = 0;
 6384                        		__st.umiq	0, _player_counter_anim
         01:D365  9C 12 23   			stz	_player_counter_anim
 6385                        	
 6386                        		.dbg	line,	"include\routines_LEVELS.c", 1396; }
 6387                        	
 6388                        		.dbg	line,	"include\routines_LEVELS.c", 1398; recenter_CAMERA();
 6389    01:D368             	.LL265:
 6390                        		__call		_recenter_CAMERA
         01:D368  20 6D FF   			call	_recenter_CAMERA
 6391                        	
 6392                        		.dbg	line,	"include\routines_LEVELS.c", 1399; }
 6393                        	
 6394                        		.dbg	line,	"include\routines_LEVELS.c", 1402; else if(player_state == STATE_CLIMB_DOWN)
 6395                        		__bra		.LL266
         01:D36B  4C 09 D6   			bra	.LL266
 6396    01:D36E             	.LL253:
 6397                        		__ld.umq	_player_state
         01:D36E  AD 0F 23   			lda	_player_state
 6398                        		__equ_b.uiq	12
         01:D371  C9 0C      			cmp	#12
         01:D373  F0 01      			beq	!+
         01:D375  18         			clc
         01:D376             	!:
 6399                        		__bfalse	.LL267
         01:D376  B0 03 4C 80			bcc	.LL267
         01:D37A  D4          
 6400                        	
 6401                        		.dbg	line,	"include\routines_LEVELS.c", 1403; {
 6402                        	
 6403                        		.dbg	line,	"include\routines_LEVELS.c", 1404; if(player_counter_anim == 0)
 6404                        		__not.um	_player_counter_anim
         01:D37B  AD 12 23   			lda	_player_counter_anim
         01:D37E  18         			clc
         01:D37F  D0 01      			bne	!+
         01:D381  38         			sec
         01:D382             	!:
 6405                        		__bfalse	.LL268
         01:D382  90 1F      			bcc	.LL268
 6406                        	
 6407                        		.dbg	line,	"include\routines_LEVELS.c", 1405; {
 6408                        	
 6409                        		.dbg	line,	"include\routines_LEVELS.c", 1406; load_vram(PLAYER_VRAM_ADR, tiles_SPR_PLAYER + TILES_176 , TILES_16);
 6410                        		__st.wmiq	6144, _di
         01:D384  64 F0      			stz.l	_di
         01:D386  A9 18      			lda.h	#6144
         01:D388  85 F1      			sta.h	_di
 6411                        		__farptr	_tiles_SPR_PLAYER + 5632, _bp_bank, _bp
         01:D38A  A9 A0      			lda.l	#$6000 + ($1FFF & (_tiles_SPR_PLAYER + 5632))
         01:D38C  85 EC      			sta.l	_bp
         01:D38E  A9 70      			lda.h	#$6000 + ($1FFF & (_tiles_SPR_PLAYER + 5632))
         01:D390  85 ED      			sta.h	_bp
         01:D392  A9 0C      			lda	#bank(_tiles_SPR_PLAYER + 5632)
         01:D394  85 02      			sta	_bp_bank
 6412                        		__st.wmiq	256, _ax
         01:D396  64 F8      			stz.l	_ax
         01:D398  A9 01      			lda.h	#256
         01:D39A  85 F9      			sta.h	_ax
 6413                        		 _load_vram.3
         01:D39C  82         			clx				; Offset to PCE VDC.
         01:D39D  20 77 FF   			call	load_vram_x
 6414                        	
 6415                        		.dbg	line,	"include\routines_LEVELS.c", 1407; }
 6416                        	
 6417                        		.dbg	line,	"include\routines_LEVELS.c", 1409; else if(player_counter_anim == 3)
 6418                        		__bra		.LL269
         01:D3A0  4C 6A D4   			bra	.LL269
 6419    01:D3A3             	.LL268:
 6420                        		__ld.umq	_player_counter_anim
         01:D3A3  AD 12 23   			lda	_player_counter_anim
 6421                        		__equ_b.uiq	3
         01:D3A6  C9 03      			cmp	#3
         01:D3A8  F0 01      			beq	!+
         01:D3AA  18         			clc
         01:D3AB             	!:
 6422                        		__bfalse	.LL270
         01:D3AB  90 1F      			bcc	.LL270
 6423                        	
 6424                        		.dbg	line,	"include\routines_LEVELS.c", 1410; {
 6425                        	
 6426                        		.dbg	line,	"include\routines_LEVELS.c", 1411; load_vram(PLAYER_VRAM_ADR, tiles_SPR_PLAYER + TILES_192 , TILES_16);
 6427                        		__st.wmiq	6144, _di
         01:D3AD  64 F0      			stz.l	_di
         01:D3AF  A9 18      			lda.h	#6144
         01:D3B1  85 F1      			sta.h	_di
 6428                        		__farptr	_tiles_SPR_PLAYER + 6144, _bp_bank, _bp
         01:D3B3  A9 A0      			lda.l	#$6000 + ($1FFF & (_tiles_SPR_PLAYER + 6144))
         01:D3B5  85 EC      			sta.l	_bp
         01:D3B7  A9 72      			lda.h	#$6000 + ($1FFF & (_tiles_SPR_PLAYER + 6144))
         01:D3B9  85 ED      			sta.h	_bp
         01:D3BB  A9 0C      			lda	#bank(_tiles_SPR_PLAYER + 6144)
         01:D3BD  85 02      			sta	_bp_bank
 6429                        		__st.wmiq	256, _ax
         01:D3BF  64 F8      			stz.l	_ax
         01:D3C1  A9 01      			lda.h	#256
         01:D3C3  85 F9      			sta.h	_ax
 6430                        		 _load_vram.3
         01:D3C5  82         			clx				; Offset to PCE VDC.
         01:D3C6  20 77 FF   			call	load_vram_x
 6431                        	
 6432                        		.dbg	line,	"include\routines_LEVELS.c", 1412; }
 6433                        	
 6434                        		.dbg	line,	"include\routines_LEVELS.c", 1414; else if(player_counter_anim == 6)
 6435                        		__bra		.LL271
         01:D3C9  4C 6A D4   			bra	.LL271
 6436    01:D3CC             	.LL270:
 6437                        		__ld.umq	_player_counter_anim
         01:D3CC  AD 12 23   			lda	_player_counter_anim
 6438                        		__equ_b.uiq	6
         01:D3CF  C9 06      			cmp	#6
         01:D3D1  F0 01      			beq	!+
         01:D3D3  18         			clc
         01:D3D4             	!:
 6439                        		__bfalse	.LL272
         01:D3D4  90 1E      			bcc	.LL272
 6440                        	
 6441                        		.dbg	line,	"include\routines_LEVELS.c", 1415; {
 6442                        	
 6443                        		.dbg	line,	"include\routines_LEVELS.c", 1416; load_vram(PLAYER_VRAM_ADR, tiles_SPR_PLAYER + TILES_208 , TILES_16);
 6444                        		__st.wmiq	6144, _di
         01:D3D6  64 F0      			stz.l	_di
         01:D3D8  A9 18      			lda.h	#6144
         01:D3DA  85 F1      			sta.h	_di
 6445                        		__farptr	_tiles_SPR_PLAYER + 6656, _bp_bank, _bp
         01:D3DC  A9 A0      			lda.l	#$6000 + ($1FFF & (_tiles_SPR_PLAYER + 6656))
         01:D3DE  85 EC      			sta.l	_bp
         01:D3E0  A9 74      			lda.h	#$6000 + ($1FFF & (_tiles_SPR_PLAYER + 6656))
         01:D3E2  85 ED      			sta.h	_bp
         01:D3E4  A9 0C      			lda	#bank(_tiles_SPR_PLAYER + 6656)
         01:D3E6  85 02      			sta	_bp_bank
 6446                        		__st.wmiq	256, _ax
         01:D3E8  64 F8      			stz.l	_ax
         01:D3EA  A9 01      			lda.h	#256
         01:D3EC  85 F9      			sta.h	_ax
 6447                        		 _load_vram.3
         01:D3EE  82         			clx				; Offset to PCE VDC.
         01:D3EF  20 77 FF   			call	load_vram_x
 6448                        	
 6449                        		.dbg	line,	"include\routines_LEVELS.c", 1417; }
 6450                        	
 6451                        		.dbg	line,	"include\routines_LEVELS.c", 1419; else if(player_counter_anim == 9)
 6452                        		__bra		.LL273
         01:D3F2  80 76      			bra	.LL273
 6453    01:D3F4             	.LL272:
 6454                        		__ld.umq	_player_counter_anim
         01:D3F4  AD 12 23   			lda	_player_counter_anim
 6455                        		__equ_b.uiq	9
         01:D3F7  C9 09      			cmp	#9
         01:D3F9  F0 01      			beq	!+
         01:D3FB  18         			clc
         01:D3FC             	!:
 6456                        		__bfalse	.LL274
         01:D3FC  90 1E      			bcc	.LL274
 6457                        	
 6458                        		.dbg	line,	"include\routines_LEVELS.c", 1420; {
 6459                        	
 6460                        		.dbg	line,	"include\routines_LEVELS.c", 1421; load_vram(PLAYER_VRAM_ADR, tiles_SPR_PLAYER + TILES_192 , TILES_16);
 6461                        		__st.wmiq	6144, _di
         01:D3FE  64 F0      			stz.l	_di
         01:D400  A9 18      			lda.h	#6144
         01:D402  85 F1      			sta.h	_di
 6462                        		__farptr	_tiles_SPR_PLAYER + 6144, _bp_bank, _bp
         01:D404  A9 A0      			lda.l	#$6000 + ($1FFF & (_tiles_SPR_PLAYER + 6144))
         01:D406  85 EC      			sta.l	_bp
         01:D408  A9 72      			lda.h	#$6000 + ($1FFF & (_tiles_SPR_PLAYER + 6144))
         01:D40A  85 ED      			sta.h	_bp
         01:D40C  A9 0C      			lda	#bank(_tiles_SPR_PLAYER + 6144)
         01:D40E  85 02      			sta	_bp_bank
 6463                        		__st.wmiq	256, _ax
         01:D410  64 F8      			stz.l	_ax
         01:D412  A9 01      			lda.h	#256
         01:D414  85 F9      			sta.h	_ax
 6464                        		 _load_vram.3
         01:D416  82         			clx				; Offset to PCE VDC.
         01:D417  20 77 FF   			call	load_vram_x
 6465                        	
 6466                        		.dbg	line,	"include\routines_LEVELS.c", 1422; }
 6467                        	
 6468                        		.dbg	line,	"include\routines_LEVELS.c", 1424; else if(player_counter_anim == 12)
 6469                        		__bra		.LL275
         01:D41A  80 4E      			bra	.LL275
 6470    01:D41C             	.LL274:
 6471                        		__ld.umq	_player_counter_anim
         01:D41C  AD 12 23   			lda	_player_counter_anim
 6472                        		__equ_b.uiq	12
         01:D41F  C9 0C      			cmp	#12
         01:D421  F0 01      			beq	!+
         01:D423  18         			clc
         01:D424             	!:
 6473                        		__bfalse	.LL276
         01:D424  90 1E      			bcc	.LL276
 6474                        	
 6475                        		.dbg	line,	"include\routines_LEVELS.c", 1425; {
 6476                        	
 6477                        		.dbg	line,	"include\routines_LEVELS.c", 1426; load_vram(PLAYER_VRAM_ADR, tiles_SPR_PLAYER + TILES_176 , TILES_16);
 6478                        		__st.wmiq	6144, _di
         01:D426  64 F0      			stz.l	_di
         01:D428  A9 18      			lda.h	#6144
         01:D42A  85 F1      			sta.h	_di
 6479                        		__farptr	_tiles_SPR_PLAYER + 5632, _bp_bank, _bp
         01:D42C  A9 A0      			lda.l	#$6000 + ($1FFF & (_tiles_SPR_PLAYER + 5632))
         01:D42E  85 EC      			sta.l	_bp
         01:D430  A9 70      			lda.h	#$6000 + ($1FFF & (_tiles_SPR_PLAYER + 5632))
         01:D432  85 ED      			sta.h	_bp
         01:D434  A9 0C      			lda	#bank(_tiles_SPR_PLAYER + 5632)
         01:D436  85 02      			sta	_bp_bank
 6480                        		__st.wmiq	256, _ax
         01:D438  64 F8      			stz.l	_ax
         01:D43A  A9 01      			lda.h	#256
         01:D43C  85 F9      			sta.h	_ax
 6481                        		 _load_vram.3
         01:D43E  82         			clx				; Offset to PCE VDC.
         01:D43F  20 77 FF   			call	load_vram_x
 6482                        	
 6483                        		.dbg	line,	"include\routines_LEVELS.c", 1427; }
 6484                        	
 6485                        		.dbg	line,	"include\routines_LEVELS.c", 1429; else if(player_counter_anim == 15)
 6486                        		__bra		.LL277
         01:D442  80 26      			bra	.LL277
 6487    01:D444             	.LL276:
 6488                        		__ld.umq	_player_counter_anim
         01:D444  AD 12 23   			lda	_player_counter_anim
 6489                        		__equ_b.uiq	15
         01:D447  C9 0F      			cmp	#15
         01:D449  F0 01      			beq	!+
         01:D44B  18         			clc
         01:D44C             	!:
 6490                        		__bfalse	.LL278
         01:D44C  90 1C      			bcc	.LL278
 6491                        	
 6492                        		.dbg	line,	"include\routines_LEVELS.c", 1430; {
 6493                        	
 6494                        		.dbg	line,	"include\routines_LEVELS.c", 1431; load_vram(PLAYER_VRAM_ADR, tiles_SPR_PLAYER + TILES_160 , TILES_16);
 6495                        		__st.wmiq	6144, _di
         01:D44E  64 F0      			stz.l	_di
         01:D450  A9 18      			lda.h	#6144
         01:D452  85 F1      			sta.h	_di
 6496                        		__farptr	_tiles_SPR_PLAYER + 5120, _bp_bank, _bp
         01:D454  A9 A0      			lda.l	#$6000 + ($1FFF & (_tiles_SPR_PLAYER + 5120))
         01:D456  85 EC      			sta.l	_bp
         01:D458  A9 6E      			lda.h	#$6000 + ($1FFF & (_tiles_SPR_PLAYER + 5120))
         01:D45A  85 ED      			sta.h	_bp
         01:D45C  A9 0C      			lda	#bank(_tiles_SPR_PLAYER + 5120)
         01:D45E  85 02      			sta	_bp_bank
 6497                        		__st.wmiq	256, _ax
         01:D460  64 F8      			stz.l	_ax
         01:D462  A9 01      			lda.h	#256
         01:D464  85 F9      			sta.h	_ax
 6498                        		 _load_vram.3
         01:D466  82         			clx				; Offset to PCE VDC.
         01:D467  20 77 FF   			call	load_vram_x
 6499                        	
 6500                        		.dbg	line,	"include\routines_LEVELS.c", 1432; }
 6501                        	
 6502                        		.dbg	line,	"include\routines_LEVELS.c", 1435; player_counter_anim += 1;
 6503    01:D46A             	.LL278:
 6504    01:D46A             	.LL277:
 6505    01:D46A             	.LL275:
 6506    01:D46A             	.LL273:
 6507    01:D46A             	.LL271:
 6508    01:D46A             	.LL269:
 6509                        		__add_st.umiq	1, _player_counter_anim
         01:D46A  EE 12 23   			inc	_player_counter_anim
 6510                        	
 6511                        		.dbg	line,	"include\routines_LEVELS.c", 1437; if(player_counter_anim == 17)
 6512                        		__ld.umq	_player_counter_anim
         01:D46D  AD 12 23   			lda	_player_counter_anim
 6513                        		__equ_b.uiq	17
         01:D470  C9 11      			cmp	#17
         01:D472  F0 01      			beq	!+
         01:D474  18         			clc
         01:D475             	!:
 6514                        		__bfalse	.LL279
         01:D475  90 03      			bcc	.LL279
 6515                        	
 6516                        		.dbg	line,	"include\routines_LEVELS.c", 1438; {
 6517                        	
 6518                        		.dbg	line,	"include\routines_LEVELS.c", 1439; player_counter_anim = 0;
 6519                        		__st.umiq	0, _player_counter_anim
         01:D477  9C 12 23   			stz	_player_counter_anim
 6520                        	
 6521                        		.dbg	line,	"include\routines_LEVELS.c", 1440; }
 6522                        	
 6523                        		.dbg	line,	"include\routines_LEVELS.c", 1442; recenter_CAMERA();
 6524    01:D47A             	.LL279:
 6525                        		__call		_recenter_CAMERA
         01:D47A  20 6D FF   			call	_recenter_CAMERA
 6526                        	
 6527                        		.dbg	line,	"include\routines_LEVELS.c", 1443; }
 6528                        	
 6529                        		.dbg	line,	"include\routines_LEVELS.c", 1446; else if(player_state == STATE_JUMP_LADDER)
 6530                        		__bra		.LL280
         01:D47D  4C 09 D6   			bra	.LL280
 6531    01:D480             	.LL267:
 6532                        		__ld.umq	_player_state
         01:D480  AD 0F 23   			lda	_player_state
 6533                        		__equ_b.uiq	13
         01:D483  C9 0D      			cmp	#13
         01:D485  F0 01      			beq	!+
         01:D487  18         			clc
         01:D488             	!:
 6534                        		__bfalse	.LL281
         01:D488  B0 03 4C 09			bcc	.LL281
         01:D48C  D6          
 6535                        	
 6536                        		.dbg	line,	"include\routines_LEVELS.c", 1447; {
 6537                        	
 6538                        		.dbg	line,	"include\routines_LEVELS.c", 1448; unsigned char i;
 6539                        	
 6540                        		.dbg	line,	"include\routines_LEVELS.c", 1449; i = 1;
 6541                        		__st.umiq	1, __update_PLAYER_end - 8  /* i */
         01:D48D  A9 01      			lda.l	#1
         01:D48F  8D 02 23   			sta	__update_PLAYER_end - 8
 6542                        	
 6543                        		.dbg	line,	"include\routines_LEVELS.c", 1452; if(player_counter_anim == 0)
 6544                        		__not.um	_player_counter_anim
         01:D492  AD 12 23   			lda	_player_counter_anim
         01:D495  18         			clc
         01:D496  D0 01      			bne	!+
         01:D498  38         			sec
         01:D499             	!:
 6545                        		__bfalse	.LL282
         01:D499  90 21      			bcc	.LL282
 6546                        	
 6547                        		.dbg	line,	"include\routines_LEVELS.c", 1453; {
 6548                        	
 6549                        		.dbg	line,	"include\routines_LEVELS.c", 1454; load_vram(PLAYER_VRAM_ADR, tiles_SPR_PLAYER + TILES_112 , TILES_16);
 6550                        		__st.wmiq	6144, _di
         01:D49B  64 F0      			stz.l	_di
         01:D49D  A9 18      			lda.h	#6144
         01:D49F  85 F1      			sta.h	_di
 6551                        		__farptr	_tiles_SPR_PLAYER + 3584, _bp_bank, _bp
         01:D4A1  A9 A0      			lda.l	#$6000 + ($1FFF & (_tiles_SPR_PLAYER + 3584))
         01:D4A3  85 EC      			sta.l	_bp
         01:D4A5  A9 68      			lda.h	#$6000 + ($1FFF & (_tiles_SPR_PLAYER + 3584))
         01:D4A7  85 ED      			sta.h	_bp
         01:D4A9  A9 0C      			lda	#bank(_tiles_SPR_PLAYER + 3584)
         01:D4AB  85 02      			sta	_bp_bank
 6552                        		__st.wmiq	256, _ax
         01:D4AD  64 F8      			stz.l	_ax
         01:D4AF  A9 01      			lda.h	#256
         01:D4B1  85 F9      			sta.h	_ax
 6553                        		 _load_vram.3
         01:D4B3  82         			clx				; Offset to PCE VDC.
         01:D4B4  20 77 FF   			call	load_vram_x
 6554                        	
 6555                        		.dbg	line,	"include\routines_LEVELS.c", 1456; player_counter_anim = 1;
 6556                        		__st.umiq	1, _player_counter_anim
         01:D4B7  A9 01      			lda.l	#1
         01:D4B9  8D 12 23   			sta	_player_counter_anim
 6557                        	
 6558                        		.dbg	line,	"include\routines_LEVELS.c", 1457; }
 6559                        	
 6560                        		.dbg	line,	"include\routines_LEVELS.c", 1460; player_pos_y += TABLE_PLAYER_JUMP_V[player_index_jump];
 6561    01:D4BC             	.LL282:
 6562                        		__ldx.umq	_player_index_jump
         01:D4BC  AE 13 23   			ldx	_player_index_jump
 6563                        		__ld.bax	_TABLE_PLAYER_JUMP_V
         01:D4BF  BD 9A 60   			lda	_TABLE_PLAYER_JUMP_V, x
         01:D4C2  C2         			cly
         01:D4C3  10 01      			bpl	!+
         01:D4C5  88         			dey
         01:D4C6             	!:
 6564                        		__add_st.wmq	_player_pos_y
         01:D4C6  18         			clc
         01:D4C7  6D 1A 23   			adc.l	_player_pos_y
         01:D4CA  8D 1A 23   			sta.l	_player_pos_y
         01:D4CD  98         			tya
         01:D4CE  6D 1B 23   			adc.h	_player_pos_y
         01:D4D1  8D 1B 23   			sta.h	_player_pos_y
 6565                        	
 6566                        		.dbg	line,	"include\routines_LEVELS.c", 1462; // CHECK COLLISION WITH CEILING //
 6567                        	
 6568                        		.dbg	line,	"include\routines_LEVELS.c", 1463; check_BG( 15 , 8 );
 6569                        		__ld.wi		15
         01:D4D4  A9 0F      			lda.l	#15
         01:D4D6  C2         			cly
 6570                        		__pusharg.wr
         01:D4D7  A6 8D      			ldx	<__sp
         01:D4D9  CA         			dex
         01:D4DA  CA         			dex
         01:D4DB  95 08      			sta.l	<__stack, x
         01:D4DD  94 09      			sty.h	<__stack, x
         01:D4DF  86 8D      			stx	<__sp
 6571                        		__ld.wi		8
         01:D4E1  A9 08      			lda.l	#8
         01:D4E3  C2         			cly
 6572                        		__pusharg.wr
         01:D4E4  A6 8D      			ldx	<__sp
         01:D4E6  CA         			dex
         01:D4E7  CA         			dex
         01:D4E8  95 08      			sta.l	<__stack, x
         01:D4EA  94 09      			sty.h	<__stack, x
         01:D4EC  86 8D      			stx	<__sp
 6573                        		__call		_check_BG
         01:D4EE  20 81 FF   			call	_check_BG
 6574                        	
 6575                        		.dbg	line,	"include\routines_LEVELS.c", 1465; if(map_blk_flag == TILE_BG)
 6576                        		__ld.umq	_map_blk_flag
         01:D4F1  AD E9 29   			lda	_map_blk_flag
 6577                        		__equ_b.uiq	1
         01:D4F4  C9 01      			cmp	#1
         01:D4F6  F0 01      			beq	!+
         01:D4F8  18         			clc
         01:D4F9             	!:
 6578                        		__bfalse	.LL283
         01:D4F9  90 5A      			bcc	.LL283
 6579                        	
 6580                        		.dbg	line,	"include\routines_LEVELS.c", 1466; {
 6581                        	
 6582                        		.dbg	line,	"include\routines_LEVELS.c", 1467; for(i=1 ; i<8 ; i++)
 6583                        		__st.umiq	1, __update_PLAYER_end - 8  /* i */
         01:D4FB  A9 01      			lda.l	#1
         01:D4FD  8D 02 23   			sta	__update_PLAYER_end - 8
 6584    01:D500             	.LL284:
 6585                        		__ld.umq	__update_PLAYER_end - 8  /* i */
         01:D500  AD 02 23   			lda	__update_PLAYER_end - 8
 6586                        		__ult_b.uiq	8
         01:D503  C9 08      			cmp	#8		; Subtract integer from A.
         01:D505  6A         			ror	a		; CC if A < integer.
         01:D506  49 80      			eor	#$80
         01:D508  2A         			rol	a
 6587                        		__btrue		.LL286
         01:D509  B0 07      			bcs	.LL286
 6588                        		__bra		.LL287
         01:D50B  80 48      			bra	.LL287
 6589    01:D50D             	.LL285:
 6590                        		__inc.umq	__update_PLAYER_end - 8  /* i */
         01:D50D  EE 02 23   			inc	__update_PLAYER_end - 8
 6591                        		__bra		.LL284
         01:D510  80 EE      			bra	.LL284
 6592    01:D512             	.LL286:
 6593                        	
 6594                        		.dbg	line,	"include\routines_LEVELS.c", 1468; {
 6595                        	
 6596                        		.dbg	line,	"include\routines_LEVELS.c", 1469; check_BG( 15 , 8 + i );
 6597                        		__ld.wi		15
         01:D512  A9 0F      			lda.l	#15
         01:D514  C2         			cly
 6598                        		__pusharg.wr
         01:D515  A6 8D      			ldx	<__sp
         01:D517  CA         			dex
         01:D518  CA         			dex
         01:D519  95 08      			sta.l	<__stack, x
         01:D51B  94 09      			sty.h	<__stack, x
         01:D51D  86 8D      			stx	<__sp
 6599                        		__ld.wi		8
         01:D51F  A9 08      			lda.l	#8
         01:D521  C2         			cly
 6600                        		__add.um	__update_PLAYER_end - 8  /* i */
         01:D522  18         			clc
         01:D523  6D 02 23   			adc	__update_PLAYER_end - 8
         01:D526  90 01      			bcc	!+
         01:D528  C8         			iny
         01:D529             	!:
 6601                        		__pusharg.wr
         01:D529  A6 8D      			ldx	<__sp
         01:D52B  CA         			dex
         01:D52C  CA         			dex
         01:D52D  95 08      			sta.l	<__stack, x
         01:D52F  94 09      			sty.h	<__stack, x
         01:D531  86 8D      			stx	<__sp
 6602                        		__call		_check_BG
         01:D533  20 81 FF   			call	_check_BG
 6603                        	
 6604                        		.dbg	line,	"include\routines_LEVELS.c", 1470; {
 6605                        	
 6606                        		.dbg	line,	"include\routines_LEVELS.c", 1471; if(map_blk_flag == TILE_EMPTY)
 6607                        		__not.um	_map_blk_flag
         01:D536  AD E9 29   			lda	_map_blk_flag
         01:D539  18         			clc
         01:D53A  D0 01      			bne	!+
         01:D53C  38         			sec
         01:D53D             	!:
 6608                        		__bfalse	.LL288
         01:D53D  90 CE      			bcc	.LL288
 6609                        	
 6610                        		.dbg	line,	"include\routines_LEVELS.c", 1472; {
 6611                        	
 6612                        		.dbg	line,	"include\routines_LEVELS.c", 1473; player_pos_y += i;
 6613                        		__ld.um		__update_PLAYER_end - 8  /* i */
         01:D53F  AD 02 23   			lda	__update_PLAYER_end - 8
         01:D542  C2         			cly
 6614                        		__add_st.wmq	_player_pos_y
         01:D543  18         			clc
         01:D544  6D 1A 23   			adc.l	_player_pos_y
         01:D547  8D 1A 23   			sta.l	_player_pos_y
         01:D54A  98         			tya
         01:D54B  6D 1B 23   			adc.h	_player_pos_y
         01:D54E  8D 1B 23   			sta.h	_player_pos_y
 6615                        	
 6616                        		.dbg	line,	"include\routines_LEVELS.c", 1474; break;
 6617                        		__bra		.LL287
         01:D551  80 02      			bra	.LL287
 6618                        	
 6619                        		.dbg	line,	"include\routines_LEVELS.c", 1475; }
 6620                        	
 6621                        		.dbg	line,	"include\routines_LEVELS.c", 1476; }
 6622    01:D553             	.LL288	.alias		.LL285
 6623                        	
 6624                        		.dbg	line,	"include\routines_LEVELS.c", 1477; }
 6625                        		__bra		.LL285
         01:D553  80 B8      			bra	.LL285
 6626    01:D555             	.LL287:
 6627                        	
 6628                        		.dbg	line,	"include\routines_LEVELS.c", 1478; }
 6629                        	
 6630                        		.dbg	line,	"include\routines_LEVELS.c", 1480; spr_set(player_id);
 6631    01:D555             	.LL283:
 6632                        		__ld.umq	_player_id
         01:D555  AD 0E 23   			lda	_player_id
 6633                        		__call		_spr_set.1
         01:D558  20 DD E7   			call	_spr_set.1
 6634                        	
 6635                        		.dbg	line,	"include\routines_LEVELS.c", 1481; spr_y(player_pos_y);
 6636                        		__ld.wm		_player_pos_y
         01:D55B  AD 1A 23   			lda.l	_player_pos_y
         01:D55E  AC 1B 23   			ldy.h	_player_pos_y
 6637                        		__call		_spr_y.1
         01:D561  20 19 E8   			call	_spr_y.1
 6638                        	
 6639                        		.dbg	line,	"include\routines_LEVELS.c", 1485; if(player_index_jump < 34)
 6640                        		__ld.umq	_player_index_jump
         01:D564  AD 13 23   			lda	_player_index_jump
 6641                        		__ult_b.uiq	34
         01:D567  C9 22      			cmp	#34		; Subtract integer from A.
         01:D569  6A         			ror	a		; CC if A < integer.
         01:D56A  49 80      			eor	#$80
         01:D56C  2A         			rol	a
 6642                        		__bfalse	.LL289
         01:D56D  90 03      			bcc	.LL289
 6643                        	
 6644                        		.dbg	line,	"include\routines_LEVELS.c", 1486; {
 6645                        	
 6646                        		.dbg	line,	"include\routines_LEVELS.c", 1487; player_index_jump += 1;
 6647                        		__add_st.umiq	1, _player_index_jump
         01:D56F  EE 13 23   			inc	_player_index_jump
 6648                        	
 6649                        		.dbg	line,	"include\routines_LEVELS.c", 1488; }
 6650                        	
 6651                        		.dbg	line,	"include\routines_LEVELS.c", 1493; //--------------------------------------------------------------------------------------//
 6652                        	
 6653                        		.dbg	line,	"include\routines_LEVELS.c", 1494; //                                   LADDER COLLISION                                   //
 6654                        	
 6655                        		.dbg	line,	"include\routines_LEVELS.c", 1495; //--------------------------------------------------------------------------------------//
 6656                        	
 6657                        		.dbg	line,	"include\routines_LEVELS.c", 1497; if(player_index_jump > 18)
 6658    01:D572             	.LL289:
 6659                        		__ld.umq	_player_index_jump
         01:D572  AD 13 23   			lda	_player_index_jump
 6660                        		__ugt_b.uiq	18
         01:D575  18         			clc			; Subtract integer+1 from A.
         01:D576  E9 12      			sbc	#18		; CS if A > integer.
 6661                        		__bfalse	.LL290
         01:D578  B0 03 4C 09			bcc	.LL290
         01:D57C  D6          
 6662                        	
 6663                        		.dbg	line,	"include\routines_LEVELS.c", 1498; {
 6664                        	
 6665                        		.dbg	line,	"include\routines_LEVELS.c", 1499; // CHECK COLLISION WITH LADDERS //
 6666                        	
 6667                        		.dbg	line,	"include\routines_LEVELS.c", 1500; check_BG( 16 , 8 );
 6668                        		__ld.wi		16
         01:D57D  A9 10      			lda.l	#16
         01:D57F  C2         			cly
 6669                        		__pusharg.wr
         01:D580  A6 8D      			ldx	<__sp
         01:D582  CA         			dex
         01:D583  CA         			dex
         01:D584  95 08      			sta.l	<__stack, x
         01:D586  94 09      			sty.h	<__stack, x
         01:D588  86 8D      			stx	<__sp
 6670                        		__ld.wi		8
         01:D58A  A9 08      			lda.l	#8
         01:D58C  C2         			cly
 6671                        		__pusharg.wr
         01:D58D  A6 8D      			ldx	<__sp
         01:D58F  CA         			dex
         01:D590  CA         			dex
         01:D591  95 08      			sta.l	<__stack, x
         01:D593  94 09      			sty.h	<__stack, x
         01:D595  86 8D      			stx	<__sp
 6672                        		__call		_check_BG
         01:D597  20 81 FF   			call	_check_BG
 6673                        	
 6674                        		.dbg	line,	"include\routines_LEVELS.c", 1502; // IF PLAYER HITS THE LADDER //
 6675                        	
 6676                        		.dbg	line,	"include\routines_LEVELS.c", 1503; if(map_blk_flag == TILE_LADDER)
 6677                        		__ld.umq	_map_blk_flag
         01:D59A  AD E9 29   			lda	_map_blk_flag
 6678                        		__equ_b.uiq	2
         01:D59D  C9 02      			cmp	#2
         01:D59F  F0 01      			beq	!+
         01:D5A1  18         			clc
         01:D5A2             	!:
 6679                        		__bfalse	.LL291
         01:D5A2  90 65      			bcc	.LL291
 6680                        	
 6681                        		.dbg	line,	"include\routines_LEVELS.c", 1504; {
 6682                        	
 6683                        		.dbg	line,	"include\routines_LEVELS.c", 1505; // CAMERA GOES 8 PX BACKWARD //
 6684                        	
 6685                        		.dbg	line,	"include\routines_LEVELS.c", 1506; sgx_map_pxl_x = ( (sgx_map_pxl_x >> 3) << 3 );
 6686                        		__ld.wm		_sgx_map_pxl_x
         01:D5A4  AD C8 24   			lda.l	_sgx_map_pxl_x
         01:D5A7  AC C9 24   			ldy.h	_sgx_map_pxl_x
 6687                        		__lsr.wi	3
         01:D5AA  84 00      			sty	__temp
         01:D5AC  20 3A E2   			jsr	lsrw3
 6688                        		__asl.wi	3
         01:D5AF  84 00      			sty	__temp
         01:D5B1  20 D7 E1   			jsr	aslw3
 6689                        		__st.wmq	_sgx_map_pxl_x
         01:D5B4  8D C8 24   			sta.l	_sgx_map_pxl_x
         01:D5B7  8C C9 24   			sty.h	_sgx_map_pxl_x
 6690                        	
 6691                        		.dbg	line,	"include\routines_LEVELS.c", 1508; // SO WE UPDATE THE MAP //
 6692                        	
 6693                        		.dbg	line,	"include\routines_LEVELS.c", 1509; sgx_scroll_map();
 6694                        		__call		_sgx_scroll_map
         01:D5BA  20 95 FF   			call	_sgx_scroll_map
 6695                        	
 6696                        		.dbg	line,	"include\routines_LEVELS.c", 1511; // CHECK IF THE PLAYER STANDS RIGHT TO THE LADDER //
 6697                        	
 6698                        		.dbg	line,	"include\routines_LEVELS.c", 1512; check_BG( 31 , 8 );
 6699                        		__ld.wi		31
         01:D5BD  A9 1F      			lda.l	#31
         01:D5BF  C2         			cly
 6700                        		__pusharg.wr
         01:D5C0  A6 8D      			ldx	<__sp
         01:D5C2  CA         			dex
         01:D5C3  CA         			dex
         01:D5C4  95 08      			sta.l	<__stack, x
         01:D5C6  94 09      			sty.h	<__stack, x
         01:D5C8  86 8D      			stx	<__sp
 6701                        		__ld.wi		8
         01:D5CA  A9 08      			lda.l	#8
         01:D5CC  C2         			cly
 6702                        		__pusharg.wr
         01:D5CD  A6 8D      			ldx	<__sp
         01:D5CF  CA         			dex
         01:D5D0  CA         			dex
         01:D5D1  95 08      			sta.l	<__stack, x
         01:D5D3  94 09      			sty.h	<__stack, x
         01:D5D5  86 8D      			stx	<__sp
 6703                        		__call		_check_BG
         01:D5D7  20 81 FF   			call	_check_BG
 6704                        	
 6705                        		.dbg	line,	"include\routines_LEVELS.c", 1514; if(map_blk_flag == TILE_LADDER)
 6706                        		__ld.umq	_map_blk_flag
         01:D5DA  AD E9 29   			lda	_map_blk_flag
 6707                        		__equ_b.uiq	2
         01:D5DD  C9 02      			cmp	#2
         01:D5DF  F0 01      			beq	!+
         01:D5E1  18         			clc
         01:D5E2             	!:
 6708                        		__bfalse	.LL292
         01:D5E2  90 0E      			bcc	.LL292
 6709                        	
 6710                        		.dbg	line,	"include\routines_LEVELS.c", 1515; {
 6711                        	
 6712                        		.dbg	line,	"include\routines_LEVELS.c", 1516; sgx_map_pxl_x += 8;
 6713                        		__add_st.wmiq	8, _sgx_map_pxl_x
         01:D5E4  18         			clc
         01:D5E5  AD C8 24   			lda.l	_sgx_map_pxl_x
         01:D5E8  69 08      			adc.l	#8
         01:D5EA  8D C8 24   			sta.l	_sgx_map_pxl_x
         01:D5ED  90 03      			bcc	!+
         01:D5EF  EE C9 24   			inc.h	_sgx_map_pxl_x
         01:D5F2             	!:
 6714                        	
 6715                        		.dbg	line,	"include\routines_LEVELS.c", 1517; }
 6716                        	
 6717                        		.dbg	line,	"include\routines_LEVELS.c", 1519; player_counter_anim = 1;
 6718    01:D5F2             	.LL292:
 6719                        		__st.umiq	1, _player_counter_anim
         01:D5F2  A9 01      			lda.l	#1
         01:D5F4  8D 12 23   			sta	_player_counter_anim
 6720                        	
 6721                        		.dbg	line,	"include\routines_LEVELS.c", 1520; player_index_jump = 0;
 6722                        		__st.umiq	0, _player_index_jump
         01:D5F7  9C 13 23   			stz	_player_index_jump
 6723                        	
 6724                        		.dbg	line,	"include\routines_LEVELS.c", 1521; jump_ladder = TRUE;
 6725                        		__st.umiq	1, _jump_ladder
         01:D5FA  A9 01      			lda.l	#1
         01:D5FC  8D 15 23   			sta	_jump_ladder
 6726                        	
 6727                        		.dbg	line,	"include\routines_LEVELS.c", 1522; jump_max_index = 29;
 6728                        		__st.umiq	29, _jump_max_index
         01:D5FF  A9 1D      			lda.l	#29
         01:D601  8D 16 23   			sta	_jump_max_index
 6729                        	
 6730                        		.dbg	line,	"include\routines_LEVELS.c", 1523; player_state = STATE_HANG;
 6731                        		__st.umiq	10, _player_state
         01:D604  A9 0A      			lda.l	#10
         01:D606  8D 0F 23   			sta	_player_state
 6732                        	
 6733                        		.dbg	line,	"include\routines_LEVELS.c", 1524; }
 6734                        	
 6735                        		.dbg	line,	"include\routines_LEVELS.c", 1525; }
 6736    01:D609             	.LL291:
 6737                        	
 6738                        		.dbg	line,	"include\routines_LEVELS.c", 1526; }
 6739    01:D609             	.LL290:
 6740                        	
 6741                        		.dbg	line,	"include\routines_LEVELS.c", 1528; }
 6742    01:D609             	.LL281:
 6743    01:D609             	.LL280:
 6744    01:D609             	.LL266:
 6745    01:D609             	.LL252:
 6746    01:D609             	.LL249:
 6747    01:D609             	.LL234:
 6748    01:D609             	.LL231:
 6749    01:D609             	.LL194:
 6750    01:D609             	.LL157:
 6751    01:D609             	.LL131:
 6752    01:D609             	.LL100:
 6753    01:D609             	.LL95:
 6754                        		__return	0
         01:D609  4C EF FF   			jmp	leave_proc
 6755                        		.dbg	clear
 6756                        		.endp
 6757               6F20     		.data
 6758               2302     		.bss
 6759    F8:2302             	__update_PLAYER_loc:
 6760    F8:2302             			ds	8
 6761    F8:230A             	__update_PLAYER_end:
 6762               E309     		.code
 6763                        		.pceas
 6764                        	
 6765                        		.dbg	line,	"main.c", 23; #include "include/init.c"
 6766                        		.dbg	line,	"include\init.c", 1; #include "huc.h"
 6767                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 1; #ifndef _hucc_legacy_h
 6768                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 2; #define _hucc_legacy_h
 6769                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 4; /****************************************************************************
 6770                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 5; ; ***************************************************************************
 6771                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 6; ;
 6772                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 7; ; huc.h
 6773                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 8; ;
 6774                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 9; ; HuCC wrapper file to include a default set of HuC-compatible functions.
 6775                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 10; ;
 6776                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 11; ; Copyright John Brandwood 2024.
 6777                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 12; ;
 6778                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 13; ; Distributed under the Boost Software License, Version 1.0.
 6779                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 14; ; (See accompanying file LICENSE_1_0.txt or copy at
 6780                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 15; ;  http://www.boost.org/LICENSE_1_0.txt)
 6781                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 16; ;
 6782                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 17; ; ***************************************************************************
 6783                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 18; ; ***************************************************************************
 6784                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 19; ;
 6785                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 20; ; When the HuCC compiler is invoked with the "--legacy" option to compile old
 6786                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 21; ; projects, then this "huc.h" file is automatically included.
 6787                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 22; ;
 6788                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 23; ; This file includes a set of the individual HuCC headers which correspond to
 6789                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 24; ; HuC's built-in functions and MagicKit library.
 6790                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 25; ;
 6791                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 26; ; New HuCC projects should, preferably, include the specific headers that are
 6792                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 27; ; needed, which will then allow them to replace parts of the standard library
 6793                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 28; ; with newer functions, or they can just manually include this "huc.h" file.
 6794                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 29; ;
 6795                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 30; ; ***************************************************************************
 6796                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 31; ; **************************************************************************/
 6797                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 33; #include "hucc-systemcard.h"
 6798                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 34; #include "hucc-baselib.h"
 6799                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 35; #include "hucc-gfx.h"
 6800                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 36; #include "hucc-string.h"
 6801                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 37; #include "hucc-old-scroll.h"
 6802                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 38; #include "hucc-old-spr.h"
 6803                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 39; #include "hucc-old-map.h"
 6804                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 40; #include "hucc-old-line.h"
 6805                        		.dbg	line,	"..\..\..\include\hucc\huc.h", 42; #endif // _hucc_legacy_h
 6806                        		.dbg	line,	"include\init.c", 2; #include "hucc-scroll.h"
 6807                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 1; #ifndef _hucc_scroll_h
 6808                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 2; #define _hucc_scroll_h
 6809                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 4; /****************************************************************************
 6810                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 5; ; ***************************************************************************
 6811                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 6; ;
 6812                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 7; ; hucc-scroll.h
 6813                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 8; ;
 6814                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 9; ; Routines for a fast split-screen scrolling system.
 6815                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 10; ;
 6816                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 11; ; Copyright John Brandwood 2024.
 6817                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 12; ;
 6818                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 13; ; Distributed under the Boost Software License, Version 1.0.
 6819                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 14; ; (See accompanying file LICENSE_1_0.txt or copy at
 6820                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 15; ;  http://www.boost.org/LICENSE_1_0.txt)
 6821                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 16; ;
 6822                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 17; ; ***************************************************************************
 6823                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 18; ; ***************************************************************************
 6824                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 19; ;
 6825                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 20; ; The maximum number of splits for each screen layer is set in your project's
 6826                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 21; ; "hucc-config.inc" file, with the library having a limit of 128-per-layer.
 6827                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 22; ;
 6828                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 23; ; Your first active split must be defined to start at screen line 0, and then
 6829                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 24; ; the rest of the active splits must be in increasing line order to match the
 6830                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 25; ; way that the PC Engine displays the output image.
 6831                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 26; ;
 6832                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 27; ; You can have disabled splits interleaved with your active splits.
 6833                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 28; ;
 6834                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 29; ; Splits that are normally disabled can be used to create full screen effects
 6835                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 30; ; such as bouncing the screen up and down by adding blank areas at the top or
 6836                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 31; ; bottom of the screen, and then rapidly changing the height of those areas.
 6837                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 32; ;
 6838                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 33; ; ***************************************************************************
 6839                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 34; ; **************************************************************************/
 6840                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 36; // *************
 6841                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 37; // VDC bits for display_flags ...
 6842                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 38; // *************
 6843                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 40; #ifndef BKG_OFF
 6844                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 41; #define BKG_OFF 0x00
 6845                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 42; #endif
 6846                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 44; #ifndef SPR_OFF
 6847                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 45; #define SPR_OFF 0x00
 6848                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 46; #endif
 6849                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 48; #ifndef BKG_ON
 6850                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 49; #define BKG_ON 0x80
 6851                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 50; #endif
 6852                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 52; #ifndef SPR_ON
 6853                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 53; #define SPR_ON 0x40
 6854                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 54; #endif
 6855                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 56; // *************
 6856                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 57; // Functions in hucc-scroll.asm ...
 6857                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 58; // *************
 6858                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 60; #ifdef __HUCC__
 6859                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 62; #asmdef	HUCC_USES_NEW_SCROLL 1
 6860                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 64; extern void __fastcall scroll_split( unsigned char index<_al>, unsigned char screen_line<_ah>, unsigned int bat_x<_bx>, unsigned int bat_y<_cx>, unsigned char display_flags<_dl> );
 6861                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 65; extern void __fastcall sgx_scroll_split( unsigned char index<_al>, unsigned char screen_line<_ah>, unsigned int bat_x<_bx>, unsigned int bat_y<_cx>, unsigned char display_flags<_dl> );
 6862                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 67; extern void __fastcall disable_split( unsigned char index<acc> );
 6863                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 68; extern void __fastcall sgx_disable_split( unsigned char index<acc> );
 6864                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 70; extern void __fastcall __macro disable_all_splits( void );
 6865                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 71; extern void __fastcall __macro sgx_disable_all_splits( void );
 6866                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 73; #asm
 6867                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 74; .macro	_disable_all_splits
 6868                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 75; ldy	#HUCC_PCE_SPLITS - 1
 6869                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 76; !loop:		tya
 6870                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 77; call	_disable_split.1
 6871                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 78; dey
 6872                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 79; bpl	!loop-
 6873                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 80; .endm
 6874                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 82; .macro	_sgx_disable_all_splits
 6875                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 83; ldy	#HUCC_SGX_SPLITS - 1
 6876                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 84; !loop:		tya
 6877                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 85; call	_sgx_disable_split.1
 6878                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 86; dey
 6879                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 87; bpl	!loop-
 6880                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 88; .endm
 6881                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 89; #endasm
 6882                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 91; #endif // __HUCC__
 6883                        		.dbg	line,	"..\..\..\include\hucc\hucc-scroll.h", 93; #endif // _hucc_scroll_h
 6884                        		.dbg	line,	"include\init.c", 3; #include "hucc-chrmap.h"
 6885                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 1; #ifndef _hucc_chrmap_h
 6886                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 2; #define _hucc_chrmap_h
 6887                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 4; /****************************************************************************
 6888                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 5; ; ***************************************************************************
 6889                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 6; ;
 6890                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 7; ; hucc-chrmap.h
 6891                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 8; ;
 6892                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 9; ; A simple map system based on 8x8 characters (aka "tiles") in BAT format.
 6893                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 10; ;
 6894                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 11; ; Copyright John Brandwood 2025.
 6895                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 12; ;
 6896                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 13; ; Distributed under the Boost Software License, Version 1.0.
 6897                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 14; ; (See accompanying file LICENSE_1_0.txt or copy at
 6898                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 15; ;  http://www.boost.org/LICENSE_1_0.txt)
 6899                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 16; ;
 6900                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 17; ; ***************************************************************************
 6901                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 18; ; ***************************************************************************
 6902                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 19; ;
 6903                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 20; ; The maximum X and Y size for chrmaps is 256 characters (2048 pixels).
 6904                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 21; ;
 6905                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 22; ; The maximum total size for a chrmap is 16KBytes, which allows for maps up
 6906                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 23; ; to 256x32 tiles (2048x256 pixels).
 6907                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 24; ;
 6908                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 25; ; ***************************************************************************
 6909                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 26; ; **************************************************************************/
 6910                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 28; // *************
 6911                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 29; // This code extends the blkmap library ...
 6912                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 30; // *************
 6913                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 32; #include "hucc-blkmap.h"
 6914                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 34; // *************
 6915                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 35; // Functions in chrmap.asm ...
 6916                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 36; // *************
 6917                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 38; #ifdef __HUCC__
 6918                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 40; #asmdef	HUCC_USES_CHRMAP 1
 6919                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 42; extern void __fastcall __nop set_chrmap( unsigned char __far *chrmap<vdc_map_bank:vdc_map_addr>, unsigned char tiles_w<vdc_map_line_w> );
 6920                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 44; extern void __fastcall draw_bat( void );
 6921                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 45; extern void __fastcall scroll_bat( void );
 6922                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 47; extern void __fastcall blit_bat( unsigned char tile_x<map_bat_x>, unsigned char tile_y<map_bat_y>, unsigned char tile_w<map_draw_x>, unsigned char tile_h<map_draw_y> );
 6923                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 49; #ifdef _SGX
 6924                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 51; extern void __fastcall __nop sgx_set_chrmap( unsigned char __far *chrmap<sgx_map_bank:sgx_map_addr>, unsigned char tiles_w<sgx_map_line_w> );
 6925                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 53; extern void __fastcall sgx_draw_bat( void );
 6926                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 54; extern void __fastcall sgx_scroll_bat( void );
 6927                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 56; extern void __fastcall sgx_blit_bat( unsigned char tile_x<map_bat_x>, unsigned char tile_y<map_bat_y>, unsigned char tile_w<map_draw_x>, unsigned char tile_h<map_draw_y> );
 6928                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 58; #endif
 6929                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 60; #endif // __HUCC__
 6930                        		.dbg	line,	"..\..\..\include\hucc\hucc-chrmap.h", 62; #endif // _hucc_chrmap_h
 6931                        		.dbg	line,	"include\init.c", 4; #include "hucc-blkmap.h"
 6932                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 1; #ifndef _hucc_blkmap_h
 6933                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 2; #define _hucc_blkmap_h
 6934                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 4; /****************************************************************************
 6935                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 5; ; ***************************************************************************
 6936                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 6; ;
 6937                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 7; ; hucc-blkmap.h
 6938                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 8; ;
 6939                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 9; ; A map system based on 16x16 meta-tiles (aka "blocks", aka CHR/BLK/MAP).
 6940                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 10; ;
 6941                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 11; ; Copyright John Brandwood 2025.
 6942                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 12; ;
 6943                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 13; ; Distributed under the Boost Software License, Version 1.0.
 6944                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 14; ; (See accompanying file LICENSE_1_0.txt or copy at
 6945                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 15; ;  http://www.boost.org/LICENSE_1_0.txt)
 6946                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 16; ;
 6947                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 17; ; ***************************************************************************
 6948                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 18; ; ***************************************************************************
 6949                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 19; ;
 6950                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 20; ; The maximum X and Y size for blkmaps is 128 blocks (2048 pixels).
 6951                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 21; ;
 6952                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 22; ; The maximum total size for a blkmap is 16KBytes, which allows for maps up
 6953                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 23; ; to 128x128 blocks (2048x2048 pixels).
 6954                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 24; ;
 6955                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 25; ; Huge multi-screen blkmaps are also supported (optionally).
 6956                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 26; ;
 6957                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 27; ; The maximum X and Y for multi-screen maps is 128 screens (32768 pixels).
 6958                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 28; ;
 6959                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 29; ; The maximum total size for a multi-screen map is 8KBytes, which allows for
 6960                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 30; ; a total of 1024 screens.
 6961                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 31; ;
 6962                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 32; ; ***************************************************************************
 6963                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 33; ; **************************************************************************/
 6964                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 35; // *************
 6965                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 36; // Functions in blkmap.asm ...
 6966                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 37; // *************
 6967                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 39; #ifdef __HUCC__
 6968                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 41; #asmdef	HUCC_USES_BLKMAP 1
 6969                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 43; // Current top-left of drawn map in pixels.
 6970                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 44; extern unsigned int   vdc_map_pxl_x;
 6971                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 45; extern unsigned int   vdc_map_pxl_y;
 6972                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 47; // Width and height to draw/scroll in characters (not tiles).
 6973                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 48; extern unsigned char  vdc_map_draw_w;
 6974                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 49; extern unsigned char  vdc_map_draw_h;
 6975                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 51; // Width of map (or multi-screen BAT) in tiles.
 6976                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 52; extern unsigned char  vdc_map_line_w;
 6977                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 54; // Width of map in screens (if multi-screen map).
 6978                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 55; extern unsigned char  vdc_map_scrn_w;
 6979                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 57; // Extra information returned by get_map_block() and sgx_get_map_block(),
 6980                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 58; // which are the collision flags and the mask/overlay sprite for the BLK.
 6981                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 59; extern unsigned char  map_blk_flag;
 6982                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 60; extern unsigned char  map_blk_mask;
 6983                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 62; extern unsigned char  vdc_scr_bank;
 6984                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 63; extern unsigned char *vdc_scr_addr;
 6985                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 65; extern unsigned char  vdc_map_bank;
 6986                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 66; extern unsigned char *vdc_map_addr;
 6987                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 68; extern unsigned char  vdc_blk_bank;
 6988                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 69; extern unsigned char *vdc_blk_addr;
 6989                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 71; extern unsigned char  vdc_tbl_bank;
 6990                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 72; extern unsigned char *vdc_tbl_addr;
 6991                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 74; extern void __fastcall set_blocks( unsigned char __far *blk_def<vdc_blk_bank:vdc_blk_addr>, unsigned char __far *flg_def<vdc_tbl_bank:vdc_tbl_addr>, unsigned char number_of_blocks<_al> );
 6992                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 75; extern void __fastcall __macro set_blkmap( unsigned char __far *blk_map<vdc_map_bank:vdc_map_addr>, unsigned char blocks_w<vdc_map_line_w> );
 6993                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 76; extern void __fastcall __macro set_multimap( unsigned char __far *multi_map<vdc_scr_bank:vdc_scr_addr>, unsigned char screens_w<vdc_map_scrn_w> );
 6994                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 78; extern void __fastcall draw_map( void );
 6995                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 79; extern void __fastcall scroll_map( void );
 6996                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 81; extern void __fastcall blit_map( unsigned char tile_x<map_bat_x>, unsigned char tile_y<map_bat_y>, unsigned char tile_w<map_draw_x>, unsigned char tile_h<map_draw_y> );
 6997                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 83; extern unsigned char __fastcall get_map_block( unsigned int x<map_pxl_x>, unsigned int y<map_pxl_y> );
 6998                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 85; #asm
 6999                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 86; .macro	_set_blkmap.2
 7000                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 87; stz	vdc_scr_bank
 7001                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 88; .endm
 7002                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 90; .macro	_set_multimap.2
 7003                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 91; lda	vdc_bat_width
 7004                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 92; lsr	a
 7005                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 93; sta	vdc_map_line_w
 7006                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 94; .endm
 7007                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 96; .macro	SCREEN
 7008                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 97; db	(((\1) & $1FFF) | $6000) >> 8, bank(\1)
 7009                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 98; db	(((\2) & $1FFF) | $4000) >> 8, bank(\2)
 7010                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 99; db	(((\3) & $1FFF) | $6000) >> 8, bank(\3)
 7011                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 100; dw	(\4)
 7012                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 101; .endm
 7013                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 102; #endasm
 7014                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 104; #ifdef _SGX
 7015                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 106; // Current top-left of drawn map in pixels.
 7016                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 107; extern unsigned int   sgx_map_pxl_x;
 7017                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 108; extern unsigned int   sgx_map_pxl_y;
 7018                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 110; // Width and height to draw/scroll in characters (not tiles).
 7019                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 111; extern unsigned char  sgx_map_draw_w;
 7020                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 112; extern unsigned char  sgx_map_draw_h;
 7021                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 114; // Width of map (or multi-screen BAT) in tiles.
 7022                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 115; extern unsigned char  sgx_map_line_w;
 7023                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 117; // Width of map in screens (if multi-screen map).
 7024                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 118; extern unsigned char  sgx_map_scrn_w;
 7025                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 120; extern unsigned char  sgx_scr_bank;
 7026                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 121; extern unsigned char *sgx_scr_addr;
 7027                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 123; extern unsigned char  sgx_map_bank;
 7028                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 124; extern unsigned char *sgx_map_addr;
 7029                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 126; extern unsigned char  sgx_blk_bank;
 7030                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 127; extern unsigned char *sgx_blk_addr;
 7031                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 129; extern unsigned char  sgx_tbl_bank;
 7032                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 130; extern unsigned char *sgx_tbl_addr;
 7033                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 132; extern void __fastcall sgx_set_blocks( unsigned char __far *blk_def<sgx_blk_bank:sgx_blk_addr>, unsigned char __far *flg_def<sgx_tbl_bank:sgx_tbl_addr>, unsigned char number_of_blocks<_al> );
 7034                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 133; extern void __fastcall __macro sgx_set_blkmap( unsigned char __far *blk_map<sgx_map_bank:sgx_map_addr>, unsigned char blocks_w<sgx_map_line_w> );
 7035                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 134; extern void __fastcall __macro sgx_set_multimap( unsigned char __far *multi_map<sgx_scr_bank:sgx_scr_addr>, unsigned char screens_w<sgx_map_scrn_w> );
 7036                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 136; extern void __fastcall sgx_draw_map( void );
 7037                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 137; extern void __fastcall sgx_scroll_map( void );
 7038                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 139; extern void __fastcall sgx_blit_map( unsigned char tile_x<map_bat_x>, unsigned char tile_y<map_bat_y>, unsigned char tile_w<map_draw_x>, unsigned char tile_h<map_draw_y> );
 7039                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 141; extern unsigned char __fastcall sgx_get_map_block( unsigned int x<map_pxl_x>, unsigned int y<map_pxl_y> );
 7040                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 143; #asm
 7041                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 144; .macro	_sgx_set_blkmap.2
 7042                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 145; stz	sgx_scr_bank
 7043                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 146; .endm
 7044                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 148; .macro	_sgx_set_multimap.2
 7045                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 149; lda	sgx_bat_width
 7046                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 150; lsr	a
 7047                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 151; sta	sgx_map_line_w
 7048                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 152; .endm
 7049                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 153; #endasm
 7050                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 155; #endif
 7051                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 157; #endif // __HUCC__
 7052                        		.dbg	line,	"..\..\..\include\hucc\hucc-blkmap.h", 159; #endif // _hucc_blkmap_h
 7053                        		.dbg	line,	"include\init.c", 13; void init_VARIABLES()
 7054                        		.dbg	line,	"include\init.c", 14; {
 7055                        	;***********************
 7056                        	;***********************
 7057                        	
 7058                        		.hucc
 7059    02:C14F             		.proc		_init_VARIABLES
 7060                        		__enter		_init_VARIABLES
 7061                        	
 7062                        		.dbg	line,	"include\init.c", 15; sequence_id = SEQUENCE_GAME;
 7063                        		__st.umiq	2, _sequence_id
         02:C14F  A9 02      			lda.l	#2
         02:C151  8D 0B 23   			sta	_sequence_id
 7064                        	
 7065                        		.dbg	line,	"include\init.c", 17; level_id = 1;
 7066                        		__st.umiq	1, _level_id
         02:C154  A9 01      			lda.l	#1
         02:C156  8D 0D 23   			sta	_level_id
 7067                        	
 7068                        		.dbg	line,	"include\init.c", 19; sequence_loaded = FALSE;
 7069                        		__st.umiq	0, _sequence_loaded
         02:C159  9C 0C 23   			stz	_sequence_loaded
 7070                        	
 7071                        		.dbg	line,	"include\init.c", 20; }
 7072    02:C15C             	.LL293:
 7073                        		__return	0
         02:C15C  4C EF FF   			jmp	leave_proc
 7074                        		.dbg	clear
 7075                        		.endp
 7076                        		.pceas
 7077                        	
 7078                        		.dbg	line,	"include\init.c", 23; void init_PLAYER()
 7079                        		.dbg	line,	"include\init.c", 24; {
 7080                        	;***********************
 7081                        	;***********************
 7082                        	
 7083                        		.hucc
 7084    02:C115             		.proc		_init_PLAYER
 7085                        		__enter		_init_PLAYER
 7086                        	
 7087                        		.dbg	line,	"include\init.c", 25; player_id = 2;
 7088                        		__st.umiq	2, _player_id
         02:C115  A9 02      			lda.l	#2
         02:C117  8D 0E 23   			sta	_player_id
 7089                        	
 7090                        		.dbg	line,	"include\init.c", 26; player_axis = AXIS_RIGHT;
 7091                        		__st.umiq	0, _player_axis
         02:C11A  9C 10 23   			stz	_player_axis
 7092                        	
 7093                        		.dbg	line,	"include\init.c", 27; player_previous_axis = player_axis;
 7094                        		__ld.um		_player_axis
         02:C11D  AD 10 23   			lda	_player_axis
         02:C120  C2         			cly
 7095                        		__st.umq	_player_previous_axis
         02:C121  8D 11 23   			sta	_player_previous_axis
 7096                        	
 7097                        		.dbg	line,	"include\init.c", 28; player_counter_anim = 0;
 7098                        		__st.umiq	0, _player_counter_anim
         02:C124  9C 12 23   			stz	_player_counter_anim
 7099                        	
 7100                        		.dbg	line,	"include\init.c", 29; player_index_jump = 0;
 7101                        		__st.umiq	0, _player_index_jump
         02:C127  9C 13 23   			stz	_player_index_jump
 7102                        	
 7103                        		.dbg	line,	"include\init.c", 30; player_index_fall = 0;
 7104                        		__st.umiq	0, _player_index_fall
         02:C12A  9C 14 23   			stz	_player_index_fall
 7105                        	
 7106                        		.dbg	line,	"include\init.c", 31; player_state = STATE_IDLE;
 7107                        		__st.umiq	0, _player_state
         02:C12D  9C 0F 23   			stz	_player_state
 7108                        	
 7109                        		.dbg	line,	"include\init.c", 32; }
 7110    02:C130             	.LL294:
 7111                        		__return	0
         02:C130  4C EF FF   			jmp	leave_proc
 7112                        		.dbg	clear
 7113                        		.endp
 7114                        		.pceas
 7115                        	
 7116                        		.dbg	line,	"include\init.c", 35; void init_LEVEL()
 7117                        		.dbg	line,	"include\init.c", 36; {
 7118                        	;***********************
 7119                        	;***********************
 7120                        	
 7121                        		.hucc
 7122    09:D860             		.proc		_init_LEVEL
 7123                        		__enter		_init_LEVEL
 7124                        	
 7125                        		.dbg	line,	"include\init.c", 37; if(level_id == 1)
 7126                        		__ld.umq	_level_id
         09:D860  AD 0D 23   			lda	_level_id
 7127                        		__equ_b.uiq	1
         09:D863  C9 01      			cmp	#1
         09:D865  F0 01      			beq	!+
         09:D867  18         			clc
         09:D868             	!:
 7128                        		__bfalse	.LL296
         09:D868  B0 03 4C 18			bcc	.LL296
         09:D86C  DF          
 7129                        	
 7130                        		.dbg	line,	"include\init.c", 38; {
 7131                        	
 7132                        		.dbg	line,	"include\init.c", 39; signed char i;
 7133                        	
 7134                        		.dbg	line,	"include\init.c", 41; // VSYNC //
 7135                        	
 7136                        		.dbg	line,	"include\init.c", 42; vsync();
 7137                        		__call		_vsync
         09:D86D  20 09 E3   			call	_vsync
 7138                        	
 7139                        		.dbg	line,	"include\init.c", 44; // LOAD DEFAULT FONT //
 7140                        	
 7141                        		.dbg	line,	"include\init.c", 45; load_default_font();
 7142                        		 _load_default_font
         09:D870  82         			clx				; Offset to PCE VDC.
         09:D871  20 C7 FF   			call	huc_monofont_x
 7143                        	
 7144                        		.dbg	line,	"include\init.c", 50; // SET VDC 1 SCREEN SIZE (IN TILES) - 64x32 = 512x256 PIXELS
 7145                        	
 7146                        		.dbg	line,	"include\init.c", 51; set_screen_size(SCR_SIZE_64x32);
 7147                        		__st.umiq	1, _al
         09:D874  A9 01      			lda.l	#1
         09:D876  85 F8      			sta	_al
 7148                        		__call		_set_screen_size.1
         09:D878  20 59 FF   			call	_set_screen_size.1
 7149                        	
 7150                        		.dbg	line,	"include\init.c", 54; // SET VDC 2 SCREEN SIZE (IN TILES) - 64x32 = 512x256 PIXELS
 7151                        	
 7152                        		.dbg	line,	"include\init.c", 55; sgx_set_screen_size(SCR_SIZE_64x32);
 7153                        		__st.umiq	1, _al
         09:D87B  A9 01      			lda.l	#1
         09:D87D  85 F8      			sta	_al
 7154                        		__call		_sgx_set_screen_size.1
         09:D87F  20 4F FF   			call	_sgx_set_screen_size.1
 7155                        	
 7156                        		.dbg	line,	"include\init.c", 58; // INIT SPRITE ATTRIBUTE TABLE //
 7157                        	
 7158                        		.dbg	line,	"include\init.c", 59; init_satb();
 7159                        		__call		_init_satb
         09:D882  20 B7 E7   			call	_init_satb
 7160                        	
 7161                        		.dbg	line,	"include\init.c", 63; //**************************************************************************************//
 7162                        	
 7163                        		.dbg	line,	"include\init.c", 64; //                                                                                      //
 7164                        	
 7165                        		.dbg	line,	"include\init.c", 65; //                                      VARIABLES                                       //
 7166                        	
 7167                        		.dbg	line,	"include\init.c", 66; //                                                                                      //
 7168                        	
 7169                        		.dbg	line,	"include\init.c", 67; //**************************************************************************************//
 7170                        	
 7171                        		.dbg	line,	"include\init.c", 69; //signed char i;
 7172                        	
 7173                        		.dbg	line,	"include\init.c", 71; camera_max_y_position = 768;
 7174                        		__st.wmiq	768, _camera_max_y_position
         09:D885  9C 1C 23   			stz.l	_camera_max_y_position
         09:D888  A9 03      			lda.h	#768
         09:D88A  8D 1D 23   			sta.h	_camera_max_y_position
 7175                        	
 7176                        		.dbg	line,	"include\init.c", 72; jump_max_index = 34;
 7177                        		__st.umiq	34, _jump_max_index
         09:D88D  A9 22      			lda.l	#34
         09:D88F  8D 16 23   			sta	_jump_max_index
 7178                        	
 7179                        		.dbg	line,	"include\init.c", 73; objects_max = 25;
 7180                        		__st.umiq	25, _objects_max
         09:D892  A9 19      			lda.l	#25
         09:D894  8D 17 23   			sta	_objects_max
 7181                        	
 7182                        		.dbg	line,	"include\init.c", 74; jump_ladder = FALSE;
 7183                        		__st.umiq	0, _jump_ladder
         09:D897  9C 15 23   			stz	_jump_ladder
 7184                        	
 7185                        		.dbg	line,	"include\init.c", 76; ptr_objects_pos_x_ref = TABLE_OBJECTS_X_POS_REF_LV1;
 7186                        		__ld.wi		_TABLE_OBJECTS_X_POS_REF_LV1
         09:D89A  A9 36      			lda.l	#_TABLE_OBJECTS_X_POS_REF_LV1
         09:D89C  A0 60      			ldy.h	#_TABLE_OBJECTS_X_POS_REF_LV1
 7187                        		__st.wmq	_ptr_objects_pos_x_ref
         09:D89E  8D 7C 24   			sta.l	_ptr_objects_pos_x_ref
         09:D8A1  8C 7D 24   			sty.h	_ptr_objects_pos_x_ref
 7188                        	
 7189                        		.dbg	line,	"include\init.c", 77; ptr_objects_pos_y_ref = TABLE_OBJECTS_Y_POS_REF_LV1;
 7190                        		__ld.wi		_TABLE_OBJECTS_Y_POS_REF_LV1
         09:D8A4  A9 68      			lda.l	#_TABLE_OBJECTS_Y_POS_REF_LV1
         09:D8A6  A0 60      			ldy.h	#_TABLE_OBJECTS_Y_POS_REF_LV1
 7191                        		__st.wmq	_ptr_objects_pos_y_ref
         09:D8A8  8D 7E 24   			sta.l	_ptr_objects_pos_y_ref
         09:D8AB  8C 7F 24   			sty.h	_ptr_objects_pos_y_ref
 7192                        	
 7193                        		.dbg	line,	"include\init.c", 82; //**************************************************************************************//
 7194                        	
 7195                        		.dbg	line,	"include\init.c", 83; //                                                                                      //
 7196                        	
 7197                        		.dbg	line,	"include\init.c", 84; //                                        VDC 2                                         //
 7198                        	
 7199                        		.dbg	line,	"include\init.c", 85; //                                                                                      //
 7200                        	
 7201                        		.dbg	line,	"include\init.c", 86; //**************************************************************************************//
 7202                        	
 7203                        		.dbg	line,	"include\init.c", 88; //--------------------------------------------------------------------------------------//
 7204                        	
 7205                        		.dbg	line,	"include\init.c", 89; //                                    LOAD TILESET                                      //
 7206                        	
 7207                        		.dbg	line,	"include\init.c", 90; //--------------------------------------------------------------------------------------//
 7208                        	
 7209                        		.dbg	line,	"include\init.c", 92; sgx_load_vram( 0x1000, tileset_LV1_BG_B, SIZEOF(tileset_LV1_BG_B) >> 1 );
 7210                        		__st.wmiq	4096, _di
         09:D8AE  64 F0      			stz.l	_di
         09:D8B0  A9 10      			lda.h	#4096
         09:D8B2  85 F1      			sta.h	_di
 7211                        		__farptr	_tileset_LV1_BG_B, _bp_bank, _bp
         09:D8B4  A9 80      			lda.l	#$6000 + ($1FFF & (_tileset_LV1_BG_B))
         09:D8B6  85 EC      			sta.l	_bp
         09:D8B8  A9 6D      			lda.h	#$6000 + ($1FFF & (_tileset_LV1_BG_B))
         09:D8BA  85 ED      			sta.h	_bp
         09:D8BC  A9 03      			lda	#bank(_tileset_LV1_BG_B)
         09:D8BE  85 02      			sta	_bp_bank
 7212                        		__ld.wi		___sizeof__tileset_LV1_BG_B
         09:D8C0  A9 E0      			lda.l	#___sizeof__tileset_LV1_BG_B
         09:D8C2  A0 72      			ldy.h	#___sizeof__tileset_LV1_BG_B
 7213                        		__lsr.wi	1
         09:D8C4  42         			say
         09:D8C5  4A         			lsr	a
         09:D8C6  42         			say
         09:D8C7  6A         			ror	a
 7214                        		__st.wmq	_ax
         09:D8C8  85 F8      			sta.l	_ax
         09:D8CA  84 F9      			sty.h	_ax
 7215                        		 _sgx_load_vram.3
         09:D8CC  A2 10      			ldx	#SGX_VDC_OFFSET		; Offset to SGX VDC.
         09:D8CE  20 77 FF   			call	load_vram_x
 7216                        	
 7217                        		.dbg	line,	"include\init.c", 95; //--------------------------------------------------------------------------------------//
 7218                        	
 7219                        		.dbg	line,	"include\init.c", 96; //                               LOAD WALL & DOOR TILES                                 //
 7220                        	
 7221                        		.dbg	line,	"include\init.c", 97; //--------------------------------------------------------------------------------------//
 7222                        	
 7223                        		.dbg	line,	"include\init.c", 99; sgx_load_vram( LV1_WALL_VRAM_ADR, tileset_LV1_WALL, SIZEOF(tileset_LV1_WALL) >> 1 );
 7224                        		__st.wmiq	4096, _di
         09:D8D1  64 F0      			stz.l	_di
         09:D8D3  A9 10      			lda.h	#4096
         09:D8D5  85 F1      			sta.h	_di
 7225                        		__farptr	_tileset_LV1_WALL, _bp_bank, _bp
         09:D8D7  A9 00      			lda.l	#$6000 + ($1FFF & (_tileset_LV1_WALL))
         09:D8D9  85 EC      			sta.l	_bp
         09:D8DB  A9 60      			lda.h	#$6000 + ($1FFF & (_tileset_LV1_WALL))
         09:D8DD  85 ED      			sta.h	_bp
         09:D8DF  A9 03      			lda	#bank(_tileset_LV1_WALL)
         09:D8E1  85 02      			sta	_bp_bank
 7226                        		__ld.wi		___sizeof__tileset_LV1_WALL
         09:D8E3  A9 00      			lda.l	#___sizeof__tileset_LV1_WALL
         09:D8E5  A0 02      			ldy.h	#___sizeof__tileset_LV1_WALL
 7227                        		__lsr.wi	1
         09:D8E7  42         			say
         09:D8E8  4A         			lsr	a
         09:D8E9  42         			say
         09:D8EA  6A         			ror	a
 7228                        		__st.wmq	_ax
         09:D8EB  85 F8      			sta.l	_ax
         09:D8ED  84 F9      			sty.h	_ax
 7229                        		 _sgx_load_vram.3
         09:D8EF  A2 10      			ldx	#SGX_VDC_OFFSET		; Offset to SGX VDC.
         09:D8F1  20 77 FF   			call	load_vram_x
 7230                        	
 7231                        		.dbg	line,	"include\init.c", 100; sgx_load_vram( LV1_DOOR_VRAM_ADR, tileset_LV1_DOOR_OPEN, SIZEOF(tileset_LV1_DOOR_OPEN) >> 1 );
 7232                        		__st.wmiq	4352, _di
         09:D8F4  64 F0      			stz.l	_di
         09:D8F6  A9 11      			lda.h	#4352
         09:D8F8  85 F1      			sta.h	_di
 7233                        		__farptr	_tileset_LV1_DOOR_OPEN, _bp_bank, _bp
         09:D8FA  A9 00      			lda.l	#$6000 + ($1FFF & (_tileset_LV1_DOOR_OPEN))
         09:D8FC  85 EC      			sta.l	_bp
         09:D8FE  A9 62      			lda.h	#$6000 + ($1FFF & (_tileset_LV1_DOOR_OPEN))
         09:D900  85 ED      			sta.h	_bp
         09:D902  A9 03      			lda	#bank(_tileset_LV1_DOOR_OPEN)
         09:D904  85 02      			sta	_bp_bank
 7234                        		__ld.wi		___sizeof__tileset_LV1_DOOR_OPEN
         09:D906  A9 00      			lda.l	#___sizeof__tileset_LV1_DOOR_OPEN
         09:D908  A0 03      			ldy.h	#___sizeof__tileset_LV1_DOOR_OPEN
 7235                        		__lsr.wi	1
         09:D90A  42         			say
         09:D90B  4A         			lsr	a
         09:D90C  42         			say
         09:D90D  6A         			ror	a
 7236                        		__st.wmq	_ax
         09:D90E  85 F8      			sta.l	_ax
         09:D910  84 F9      			sty.h	_ax
 7237                        		 _sgx_load_vram.3
         09:D912  A2 10      			ldx	#SGX_VDC_OFFSET		; Offset to SGX VDC.
         09:D914  20 77 FF   			call	load_vram_x
 7238                        	
 7239                        		.dbg	line,	"include\init.c", 103; //--------------------------------------------------------------------------------------//
 7240                        	
 7241                        		.dbg	line,	"include\init.c", 104; //                                     SET MULTIMAP                                     //
 7242                        	
 7243                        		.dbg	line,	"include\init.c", 105; //--------------------------------------------------------------------------------------//
 7244                        	
 7245                        		.dbg	line,	"include\init.c", 107; // multimap is 2 screens wide //
 7246                        	
 7247                        		.dbg	line,	"include\init.c", 108; sgx_set_multimap( multimap_LV1_BG_B , 5 );
 7248                        		__farptr	_multimap_LV1_BG_B, sgx_scr_bank, sgx_scr_addr
         09:D917  A9 00      			lda.l	#$6000 + ($1FFF & (_multimap_LV1_BG_B))
         09:D919  8D 06 2A   			sta.l	sgx_scr_addr
         09:D91C  A9 71      			lda.h	#$6000 + ($1FFF & (_multimap_LV1_BG_B))
         09:D91E  8D 07 2A   			sta.h	sgx_scr_addr
         09:D921  A9 09      			lda	#bank(_multimap_LV1_BG_B)
         09:D923  8D 08 2A   			sta	sgx_scr_bank
 7249                        		__st.umiq	5, sgx_map_scrn_w
         09:D926  A9 05      			lda.l	#5
         09:D928  8D C7 24   			sta	sgx_map_scrn_w
 7250                        		 _sgx_set_multimap.2
         09:D92B  AD BF 24   			lda	sgx_bat_width
         09:D92E  4A         			lsr	a
         09:D92F  8D C6 24   			sta	sgx_map_line_w
 7251                        	
 7252                        		.dbg	line,	"include\init.c", 111; //--------------------------------------------------------------------------------------//
 7253                        	
 7254                        		.dbg	line,	"include\init.c", 112; //                                    DRAW TILEMAP                                      //
 7255                        	
 7256                        		.dbg	line,	"include\init.c", 113; //--------------------------------------------------------------------------------------//
 7257                        	
 7258                        		.dbg	line,	"include\init.c", 115; // The blkmap is drawn using global variables for the top-left coordinate
 7259                        	
 7260                        		.dbg	line,	"include\init.c", 116; // in pixels, and the draw width and height in terms of 8x8 characters.
 7261                        	
 7262                        		.dbg	line,	"include\init.c", 118; sgx_map_pxl_x = 96;
 7263                        		__st.wmiq	96, _sgx_map_pxl_x
         09:D932  A9 60      			lda.l	#96
         09:D934  8D C8 24   			sta.l	_sgx_map_pxl_x
         09:D937  9C C9 24   			stz.h	_sgx_map_pxl_x
 7264                        	
 7265                        		.dbg	line,	"include\init.c", 119; sgx_map_pxl_y = 768;
 7266                        		__st.wmiq	768, _sgx_map_pxl_y
         09:D93A  9C CA 24   			stz.l	_sgx_map_pxl_y
         09:D93D  A9 03      			lda.h	#768
         09:D93F  8D CB 24   			sta.h	_sgx_map_pxl_y
 7267                        	
 7268                        		.dbg	line,	"include\init.c", 121; sgx_map_draw_w = 63;
 7269                        		__st.umiq	63, _sgx_map_draw_w
         09:D942  A9 3F      			lda.l	#63
         09:D944  8D C4 24   			sta	_sgx_map_draw_w
 7270                        	
 7271                        		.dbg	line,	"include\init.c", 122; sgx_map_draw_h = 29;
 7272                        		__st.umiq	29, _sgx_map_draw_h
         09:D947  A9 1D      			lda.l	#29
         09:D949  8D C5 24   			sta	_sgx_map_draw_h
 7273                        	
 7274                        		.dbg	line,	"include\init.c", 124; sgx_draw_map();
 7275                        		__call		_sgx_draw_map
         09:D94C  20 45 FF   			call	_sgx_draw_map
 7276                        	
 7277                        		.dbg	line,	"include\init.c", 129; //**************************************************************************************//
 7278                        	
 7279                        		.dbg	line,	"include\init.c", 130; //                                                                                      //
 7280                        	
 7281                        		.dbg	line,	"include\init.c", 131; //                                        VDC 1                                         //
 7282                        	
 7283                        		.dbg	line,	"include\init.c", 132; //                                                                                      //
 7284                        	
 7285                        		.dbg	line,	"include\init.c", 133; //**************************************************************************************//
 7286                        	
 7287                        		.dbg	line,	"include\init.c", 135; //--------------------------------------------------------------------------------------//
 7288                        	
 7289                        		.dbg	line,	"include\init.c", 136; //                                    LOAD TILESET                                      //
 7290                        	
 7291                        		.dbg	line,	"include\init.c", 137; //--------------------------------------------------------------------------------------//
 7292                        	
 7293                        		.dbg	line,	"include\init.c", 139; load_vram( 0x1000, tileset_LV1_BG_A, SIZEOF(tileset_LV1_BG_A) >> 1 );
 7294                        		__st.wmiq	4096, _di
         09:D94F  64 F0      			stz.l	_di
         09:D951  A9 10      			lda.h	#4096
         09:D953  85 F1      			sta.h	_di
 7295                        		__farptr	_tileset_LV1_BG_A, _bp_bank, _bp
         09:D955  A9 A0      			lda.l	#$6000 + ($1FFF & (_tileset_LV1_BG_A))
         09:D957  85 EC      			sta.l	_bp
         09:D959  A9 71      			lda.h	#$6000 + ($1FFF & (_tileset_LV1_BG_A))
         09:D95B  85 ED      			sta.h	_bp
         09:D95D  A9 09      			lda	#bank(_tileset_LV1_BG_A)
         09:D95F  85 02      			sta	_bp_bank
 7296                        		__ld.wi		___sizeof__tileset_LV1_BG_A
         09:D961  A9 C0      			lda.l	#___sizeof__tileset_LV1_BG_A
         09:D963  A0 06      			ldy.h	#___sizeof__tileset_LV1_BG_A
 7297                        		__lsr.wi	1
         09:D965  42         			say
         09:D966  4A         			lsr	a
         09:D967  42         			say
         09:D968  6A         			ror	a
 7298                        		__st.wmq	_ax
         09:D969  85 F8      			sta.l	_ax
         09:D96B  84 F9      			sty.h	_ax
 7299                        		 _load_vram.3
         09:D96D  82         			clx				; Offset to PCE VDC.
         09:D96E  20 77 FF   			call	load_vram_x
 7300                        	
 7301                        		.dbg	line,	"include\init.c", 142; //--------------------------------------------------------------------------------------//
 7302                        	
 7303                        		.dbg	line,	"include\init.c", 143; //                                 LOAD LIFABAR TILES                                   //
 7304                        	
 7305                        		.dbg	line,	"include\init.c", 144; //--------------------------------------------------------------------------------------//
 7306                        	
 7307                        		.dbg	line,	"include\init.c", 146; load_vram( LIFEBAR_1_VRAM_ADR, tileset_LIFE_RED, SIZEOF(tileset_LIFE_RED) >> 1 );
 7308                        		__st.wmiq	4096, _di
         09:D971  64 F0      			stz.l	_di
         09:D973  A9 10      			lda.h	#4096
         09:D975  85 F1      			sta.h	_di
 7309                        		__farptr	_tileset_LIFE_RED, _bp_bank, _bp
         09:D977  A9 00      			lda.l	#$6000 + ($1FFF & (_tileset_LIFE_RED))
         09:D979  85 EC      			sta.l	_bp
         09:D97B  A9 68      			lda.h	#$6000 + ($1FFF & (_tileset_LIFE_RED))
         09:D97D  85 ED      			sta.h	_bp
         09:D97F  A9 03      			lda	#bank(_tileset_LIFE_RED)
         09:D981  85 02      			sta	_bp_bank
 7310                        		__ld.wi		___sizeof__tileset_LIFE_RED
         09:D983  A9 40      			lda.l	#___sizeof__tileset_LIFE_RED
         09:D985  A0 00      			ldy.h	#___sizeof__tileset_LIFE_RED
 7311                        		__lsr.wi	1
         09:D987  42         			say
         09:D988  4A         			lsr	a
         09:D989  42         			say
         09:D98A  6A         			ror	a
 7312                        		__st.wmq	_ax
         09:D98B  85 F8      			sta.l	_ax
         09:D98D  84 F9      			sty.h	_ax
 7313                        		 _load_vram.3
         09:D98F  82         			clx				; Offset to PCE VDC.
         09:D990  20 77 FF   			call	load_vram_x
 7314                        	
 7315                        		.dbg	line,	"include\init.c", 147; load_vram( LIFEBAR_2_VRAM_ADR, tileset_LIFE_ORANGE, SIZEOF(tileset_LIFE_ORANGE) >> 1 );
 7316                        		__st.wmiq	4128, _di
         09:D993  A9 20      			lda.l	#4128
         09:D995  85 F0      			sta.l	_di
         09:D997  A9 10      			lda.h	#4128
         09:D999  85 F1      			sta.h	_di
 7317                        		__farptr	_tileset_LIFE_ORANGE, _bp_bank, _bp
         09:D99B  A9 40      			lda.l	#$6000 + ($1FFF & (_tileset_LIFE_ORANGE))
         09:D99D  85 EC      			sta.l	_bp
         09:D99F  A9 68      			lda.h	#$6000 + ($1FFF & (_tileset_LIFE_ORANGE))
         09:D9A1  85 ED      			sta.h	_bp
         09:D9A3  A9 03      			lda	#bank(_tileset_LIFE_ORANGE)
         09:D9A5  85 02      			sta	_bp_bank
 7318                        		__ld.wi		___sizeof__tileset_LIFE_ORANGE
         09:D9A7  A9 40      			lda.l	#___sizeof__tileset_LIFE_ORANGE
         09:D9A9  A0 00      			ldy.h	#___sizeof__tileset_LIFE_ORANGE
 7319                        		__lsr.wi	1
         09:D9AB  42         			say
         09:D9AC  4A         			lsr	a
         09:D9AD  42         			say
         09:D9AE  6A         			ror	a
 7320                        		__st.wmq	_ax
         09:D9AF  85 F8      			sta.l	_ax
         09:D9B1  84 F9      			sty.h	_ax
 7321                        		 _load_vram.3
         09:D9B3  82         			clx				; Offset to PCE VDC.
         09:D9B4  20 77 FF   			call	load_vram_x
 7322                        	
 7323                        		.dbg	line,	"include\init.c", 148; load_vram( LIFEBAR_3_VRAM_ADR, tileset_LIFE_YELLOW, SIZEOF(tileset_LIFE_YELLOW) >> 1 );
 7324                        		__st.wmiq	4160, _di
         09:D9B7  A9 40      			lda.l	#4160
         09:D9B9  85 F0      			sta.l	_di
         09:D9BB  A9 10      			lda.h	#4160
         09:D9BD  85 F1      			sta.h	_di
 7325                        		__farptr	_tileset_LIFE_YELLOW, _bp_bank, _bp
         09:D9BF  A9 80      			lda.l	#$6000 + ($1FFF & (_tileset_LIFE_YELLOW))
         09:D9C1  85 EC      			sta.l	_bp
         09:D9C3  A9 68      			lda.h	#$6000 + ($1FFF & (_tileset_LIFE_YELLOW))
         09:D9C5  85 ED      			sta.h	_bp
         09:D9C7  A9 03      			lda	#bank(_tileset_LIFE_YELLOW)
         09:D9C9  85 02      			sta	_bp_bank
 7326                        		__ld.wi		___sizeof__tileset_LIFE_YELLOW
         09:D9CB  A9 40      			lda.l	#___sizeof__tileset_LIFE_YELLOW
         09:D9CD  A0 00      			ldy.h	#___sizeof__tileset_LIFE_YELLOW
 7327                        		__lsr.wi	1
         09:D9CF  42         			say
         09:D9D0  4A         			lsr	a
         09:D9D1  42         			say
         09:D9D2  6A         			ror	a
 7328                        		__st.wmq	_ax
         09:D9D3  85 F8      			sta.l	_ax
         09:D9D5  84 F9      			sty.h	_ax
 7329                        		 _load_vram.3
         09:D9D7  82         			clx				; Offset to PCE VDC.
         09:D9D8  20 77 FF   			call	load_vram_x
 7330                        	
 7331                        		.dbg	line,	"include\init.c", 149; load_vram( LIFEBAR_4_VRAM_ADR, tileset_LIFE_YELLOW, SIZEOF(tileset_LIFE_YELLOW) >> 1 );
 7332                        		__st.wmiq	4192, _di
         09:D9DB  A9 60      			lda.l	#4192
         09:D9DD  85 F0      			sta.l	_di
         09:D9DF  A9 10      			lda.h	#4192
         09:D9E1  85 F1      			sta.h	_di
 7333                        		__farptr	_tileset_LIFE_YELLOW, _bp_bank, _bp
         09:D9E3  A9 80      			lda.l	#$6000 + ($1FFF & (_tileset_LIFE_YELLOW))
         09:D9E5  85 EC      			sta.l	_bp
         09:D9E7  A9 68      			lda.h	#$6000 + ($1FFF & (_tileset_LIFE_YELLOW))
         09:D9E9  85 ED      			sta.h	_bp
         09:D9EB  A9 03      			lda	#bank(_tileset_LIFE_YELLOW)
         09:D9ED  85 02      			sta	_bp_bank
 7334                        		__ld.wi		___sizeof__tileset_LIFE_YELLOW
         09:D9EF  A9 40      			lda.l	#___sizeof__tileset_LIFE_YELLOW
         09:D9F1  A0 00      			ldy.h	#___sizeof__tileset_LIFE_YELLOW
 7335                        		__lsr.wi	1
         09:D9F3  42         			say
         09:D9F4  4A         			lsr	a
         09:D9F5  42         			say
         09:D9F6  6A         			ror	a
 7336                        		__st.wmq	_ax
         09:D9F7  85 F8      			sta.l	_ax
         09:D9F9  84 F9      			sty.h	_ax
 7337                        		 _load_vram.3
         09:D9FB  82         			clx				; Offset to PCE VDC.
         09:D9FC  20 77 FF   			call	load_vram_x
 7338                        	
 7339                        		.dbg	line,	"include\init.c", 150; load_vram( LIFEBAR_5_VRAM_ADR, tileset_LIFE_EMPTY, SIZEOF(tileset_LIFE_EMPTY) >> 1 );
 7340                        		__st.wmiq	4224, _di
         09:D9FF  A9 80      			lda.l	#4224
         09:DA01  85 F0      			sta.l	_di
         09:DA03  A9 10      			lda.h	#4224
         09:DA05  85 F1      			sta.h	_di
 7341                        		__farptr	_tileset_LIFE_EMPTY, _bp_bank, _bp
         09:DA07  A9 C0      			lda.l	#$6000 + ($1FFF & (_tileset_LIFE_EMPTY))
         09:DA09  85 EC      			sta.l	_bp
         09:DA0B  A9 68      			lda.h	#$6000 + ($1FFF & (_tileset_LIFE_EMPTY))
         09:DA0D  85 ED      			sta.h	_bp
         09:DA0F  A9 03      			lda	#bank(_tileset_LIFE_EMPTY)
         09:DA11  85 02      			sta	_bp_bank
 7342                        		__ld.wi		___sizeof__tileset_LIFE_EMPTY
         09:DA13  A9 40      			lda.l	#___sizeof__tileset_LIFE_EMPTY
         09:DA15  A0 00      			ldy.h	#___sizeof__tileset_LIFE_EMPTY
 7343                        		__lsr.wi	1
         09:DA17  42         			say
         09:DA18  4A         			lsr	a
         09:DA19  42         			say
         09:DA1A  6A         			ror	a
 7344                        		__st.wmq	_ax
         09:DA1B  85 F8      			sta.l	_ax
         09:DA1D  84 F9      			sty.h	_ax
 7345                        		 _load_vram.3
         09:DA1F  82         			clx				; Offset to PCE VDC.
         09:DA20  20 77 FF   			call	load_vram_x
 7346                        	
 7347                        		.dbg	line,	"include\init.c", 153; //--------------------------------------------------------------------------------------//
 7348                        	
 7349                        		.dbg	line,	"include\init.c", 154; //                               LOAD WEAPON + ARMOR TILES                              //
 7350                        	
 7351                        		.dbg	line,	"include\init.c", 155; //--------------------------------------------------------------------------------------//
 7352                        	
 7353                        		.dbg	line,	"include\init.c", 157; load_vram( WEAPON_VRAM_ADR, tileset_WEAPON_1, SIZEOF(tileset_WEAPON_1) >> 1 );
 7354                        		__st.wmiq	4256, _di
         09:DA23  A9 A0      			lda.l	#4256
         09:DA25  85 F0      			sta.l	_di
         09:DA27  A9 10      			lda.h	#4256
         09:DA29  85 F1      			sta.h	_di
 7355                        		__farptr	_tileset_WEAPON_1, _bp_bank, _bp
         09:DA2B  A9 00      			lda.l	#$6000 + ($1FFF & (_tileset_WEAPON_1))
         09:DA2D  85 EC      			sta.l	_bp
         09:DA2F  A9 6B      			lda.h	#$6000 + ($1FFF & (_tileset_WEAPON_1))
         09:DA31  85 ED      			sta.h	_bp
         09:DA33  A9 03      			lda	#bank(_tileset_WEAPON_1)
         09:DA35  85 02      			sta	_bp_bank
 7356                        		__ld.wi		___sizeof__tileset_WEAPON_1
         09:DA37  A9 80      			lda.l	#___sizeof__tileset_WEAPON_1
         09:DA39  A0 00      			ldy.h	#___sizeof__tileset_WEAPON_1
 7357                        		__lsr.wi	1
         09:DA3B  42         			say
         09:DA3C  4A         			lsr	a
         09:DA3D  42         			say
         09:DA3E  6A         			ror	a
 7358                        		__st.wmq	_ax
         09:DA3F  85 F8      			sta.l	_ax
         09:DA41  84 F9      			sty.h	_ax
 7359                        		 _load_vram.3
         09:DA43  82         			clx				; Offset to PCE VDC.
         09:DA44  20 77 FF   			call	load_vram_x
 7360                        	
 7361                        		.dbg	line,	"include\init.c", 158; load_vram( ARMOR_VRAM_ADR, tileset_ARMOR_2, SIZEOF(tileset_ARMOR_2) >> 1 );
 7362                        		__st.wmiq	4320, _di
         09:DA47  A9 E0      			lda.l	#4320
         09:DA49  85 F0      			sta.l	_di
         09:DA4B  A9 10      			lda.h	#4320
         09:DA4D  85 F1      			sta.h	_di
 7363                        		__farptr	_tileset_ARMOR_2, _bp_bank, _bp
         09:DA4F  A9 80      			lda.l	#$6000 + ($1FFF & (_tileset_ARMOR_2))
         09:DA51  85 EC      			sta.l	_bp
         09:DA53  A9 69      			lda.h	#$6000 + ($1FFF & (_tileset_ARMOR_2))
         09:DA55  85 ED      			sta.h	_bp
         09:DA57  A9 03      			lda	#bank(_tileset_ARMOR_2)
         09:DA59  85 02      			sta	_bp_bank
 7364                        		__ld.wi		___sizeof__tileset_ARMOR_2
         09:DA5B  A9 80      			lda.l	#___sizeof__tileset_ARMOR_2
         09:DA5D  A0 00      			ldy.h	#___sizeof__tileset_ARMOR_2
 7365                        		__lsr.wi	1
         09:DA5F  42         			say
         09:DA60  4A         			lsr	a
         09:DA61  42         			say
         09:DA62  6A         			ror	a
 7366                        		__st.wmq	_ax
         09:DA63  85 F8      			sta.l	_ax
         09:DA65  84 F9      			sty.h	_ax
 7367                        		 _load_vram.3
         09:DA67  82         			clx				; Offset to PCE VDC.
         09:DA68  20 77 FF   			call	load_vram_x
 7368                        	
 7369                        		.dbg	line,	"include\init.c", 161; //--------------------------------------------------------------------------------------//
 7370                        	
 7371                        		.dbg	line,	"include\init.c", 162; //                                     SET MULTIMAP                                     //
 7372                        	
 7373                        		.dbg	line,	"include\init.c", 163; //--------------------------------------------------------------------------------------//
 7374                        	
 7375                        		.dbg	line,	"include\init.c", 165; // multimap is 2 screens wide //
 7376                        	
 7377                        		.dbg	line,	"include\init.c", 166; set_multimap( multimap_LV1_BG_A , 5 );
 7378                        		__farptr	_multimap_LV1_BG_A, vdc_scr_bank, vdc_scr_addr
         09:DA6B  A9 00      			lda.l	#$6000 + ($1FFF & (_multimap_LV1_BG_A))
         09:DA6D  8D F6 29   			sta.l	vdc_scr_addr
         09:DA70  A9 78      			lda.h	#$6000 + ($1FFF & (_multimap_LV1_BG_A))
         09:DA72  8D F7 29   			sta.h	vdc_scr_addr
         09:DA75  A9 0B      			lda	#bank(_multimap_LV1_BG_A)
         09:DA77  8D F8 29   			sta	vdc_scr_bank
 7379                        		__st.umiq	5, vdc_map_scrn_w
         09:DA7A  A9 05      			lda.l	#5
         09:DA7C  8D B7 24   			sta	vdc_map_scrn_w
 7380                        		 _set_multimap.2
         09:DA7F  AD AF 24   			lda	vdc_bat_width
         09:DA82  4A         			lsr	a
         09:DA83  8D B6 24   			sta	vdc_map_line_w
 7381                        	
 7382                        		.dbg	line,	"include\init.c", 169; //--------------------------------------------------------------------------------------//
 7383                        	
 7384                        		.dbg	line,	"include\init.c", 170; //                                    DRAW TILEMAP                                      //
 7385                        	
 7386                        		.dbg	line,	"include\init.c", 171; //--------------------------------------------------------------------------------------//
 7387                        	
 7388                        		.dbg	line,	"include\init.c", 173; // The blkmap is drawn using global variables for the top-left coordinate
 7389                        	
 7390                        		.dbg	line,	"include\init.c", 174; // in pixels, and the draw width and height in terms of 8x8 characters.
 7391                        	
 7392                        		.dbg	line,	"include\init.c", 176; vdc_map_pxl_x = 0;
 7393                        		__st.wmiq	0, _vdc_map_pxl_x
         09:DA86  9C B8 24   			stz.l	_vdc_map_pxl_x
         09:DA89  9C B9 24   			stz.h	_vdc_map_pxl_x
 7394                        	
 7395                        		.dbg	line,	"include\init.c", 177; vdc_map_pxl_y = 0;
 7396                        		__st.wmiq	0, _vdc_map_pxl_y
         09:DA8C  9C BA 24   			stz.l	_vdc_map_pxl_y
         09:DA8F  9C BB 24   			stz.h	_vdc_map_pxl_y
 7397                        	
 7398                        		.dbg	line,	"include\init.c", 179; vdc_map_draw_w = 32;
 7399                        		__st.umiq	32, _vdc_map_draw_w
         09:DA92  A9 20      			lda.l	#32
         09:DA94  8D B4 24   			sta	_vdc_map_draw_w
 7400                        	
 7401                        		.dbg	line,	"include\init.c", 180; vdc_map_draw_h = 28;
 7402                        		__st.umiq	28, _vdc_map_draw_h
         09:DA97  A9 1C      			lda.l	#28
         09:DA99  8D B5 24   			sta	_vdc_map_draw_h
 7403                        	
 7404                        		.dbg	line,	"include\init.c", 182; draw_map();
 7405                        		__call		_draw_map
         09:DA9C  20 3B FF   			call	_draw_map
 7406                        	
 7407                        		.dbg	line,	"include\init.c", 187; //**************************************************************************************//
 7408                        	
 7409                        		.dbg	line,	"include\init.c", 188; //                                                                                      //
 7410                        	
 7411                        		.dbg	line,	"include\init.c", 189; //                                  SETUP SCROLL_SPLIT                                  //
 7412                        	
 7413                        		.dbg	line,	"include\init.c", 190; //                                                                                      //
 7414                        	
 7415                        		.dbg	line,	"include\init.c", 191; //**************************************************************************************//
 7416                        	
 7417                        		.dbg	line,	"include\init.c", 193; //--------------------------------------------------------------------------------------//
 7418                        	
 7419                        		.dbg	line,	"include\init.c", 194; //                                        VDC 2                                         //
 7420                        	
 7421                        		.dbg	line,	"include\init.c", 195; //--------------------------------------------------------------------------------------//
 7422                        	
 7423                        		.dbg	line,	"include\init.c", 197; sgx_scroll_map();
 7424                        		__call		_sgx_scroll_map
         09:DA9F  20 95 FF   			call	_sgx_scroll_map
 7425                        	
 7426                        		.dbg	line,	"include\init.c", 199; sgx_scroll_split(0,   0, sgx_map_pxl_x & (BAT_SIZE_W - 1), sgx_map_pxl_y & (BAT_SIZE_H - 1), BKG_ON | SPR_ON);
 7427                        		__st.umiq	0, _al
         09:DAA2  64 F8      			stz	_al
 7428                        		__st.umiq	0, _ah
         09:DAA4  64 F9      			stz	_ah
 7429                        		__ld.wm		_sgx_map_pxl_x
         09:DAA6  AD C8 24   			lda.l	_sgx_map_pxl_x
         09:DAA9  AC C9 24   			ldy.h	_sgx_map_pxl_x
 7430                        		__and.wi	2047
         09:DAAC  29 FF      			and.l	#2047
         09:DAAE  42         			say
         09:DAAF  29 07      			and.h	#2047
         09:DAB1  42         			say
 7431                        		__st.wmq	_bx
         09:DAB2  85 FA      			sta.l	_bx
         09:DAB4  84 FB      			sty.h	_bx
 7432                        		__ld.wm		_sgx_map_pxl_y
         09:DAB6  AD CA 24   			lda.l	_sgx_map_pxl_y
         09:DAB9  AC CB 24   			ldy.h	_sgx_map_pxl_y
 7433                        		__and.wi	255
         09:DABC  29 FF      			and	#255
         09:DABE  C2         			cly
 7434                        		__st.wmq	_cx
         09:DABF  85 FC      			sta.l	_cx
         09:DAC1  84 FD      			sty.h	_cx
 7435                        		__st.umiq	192, _dl
         09:DAC3  A9 C0      			lda.l	#192
         09:DAC5  85 FE      			sta	_dl
 7436                        		__call		_sgx_scroll_split.5
         09:DAC7  20 8B FF   			call	_sgx_scroll_split.5
 7437                        	
 7438                        		.dbg	line,	"include\init.c", 204; //--------------------------------------------------------------------------------------//
 7439                        	
 7440                        		.dbg	line,	"include\init.c", 205; //                                   LOAD BG PALETTES                                   //
 7441                        	
 7442                        		.dbg	line,	"include\init.c", 206; //--------------------------------------------------------------------------------------//
 7443                        	
 7444                        		.dbg	line,	"include\init.c", 208; // LOAD ALL PALETTES AT BG PALETTE 0 //
 7445                        	
 7446                        		.dbg	line,	"include\init.c", 209; load_palette( 0, palette_LV1, 16 );
 7447                        		__st.umiq	0, _al
         09:DACA  64 F8      			stz	_al
 7448                        		__farptr	_palette_LV1, _bp_bank, _bp
         09:DACC  A9 A0      			lda.l	#$6000 + ($1FFF & (_palette_LV1))
         09:DACE  85 EC      			sta.l	_bp
         09:DAD0  A9 78      			lda.h	#$6000 + ($1FFF & (_palette_LV1))
         09:DAD2  85 ED      			sta.h	_bp
         09:DAD4  A9 0B      			lda	#bank(_palette_LV1)
         09:DAD6  85 02      			sta	_bp_bank
 7449                        		__st.umiq	16, _ah
         09:DAD8  A9 10      			lda.l	#16
         09:DADA  85 F9      			sta	_ah
 7450                        		__call		_load_palette.3
         09:DADC  20 31 FF   			call	_load_palette.3
 7451                        	
 7452                        		.dbg	line,	"include\init.c", 214; //**************************************************************************************//
 7453                        	
 7454                        		.dbg	line,	"include\init.c", 215; //                                                                                      //
 7455                        	
 7456                        		.dbg	line,	"include\init.c", 216; //                                       SPRITES                                        //
 7457                        	
 7458                        		.dbg	line,	"include\init.c", 217; //                                                                                      //
 7459                        	
 7460                        		.dbg	line,	"include\init.c", 218; //**************************************************************************************//
 7461                        	
 7462                        		.dbg	line,	"include\init.c", 220; //--------------------------------------------------------------------------------------//
 7463                        	
 7464                        		.dbg	line,	"include\init.c", 221; //                                        PLAYER                                        //
 7465                        	
 7466                        		.dbg	line,	"include\init.c", 222; //--------------------------------------------------------------------------------------//
 7467                        	
 7468                        		.dbg	line,	"include\init.c", 224; // LOAD PLAYER TILES //
 7469                        	
 7470                        		.dbg	line,	"include\init.c", 225; // 0x2000
 7471                        	
 7472                        		.dbg	line,	"include\init.c", 226; // 32 TILES = 512 //
 7473                        	
 7474                        		.dbg	line,	"include\init.c", 227; // LOAD PLAYER FIRST FRAME OF ANIMATION (IDLE)
 7475                        	
 7476                        		.dbg	line,	"include\init.c", 228; load_vram(PLAYER_VRAM_ADR, tiles_SPR_PLAYER , TILES_16);
 7477                        		__st.wmiq	6144, _di
         09:DADF  64 F0      			stz.l	_di
         09:DAE1  A9 18      			lda.h	#6144
         09:DAE3  85 F1      			sta.h	_di
 7478                        		__farptr	_tiles_SPR_PLAYER, _bp_bank, _bp
         09:DAE5  A9 A0      			lda.l	#$6000 + ($1FFF & (_tiles_SPR_PLAYER))
         09:DAE7  85 EC      			sta.l	_bp
         09:DAE9  A9 7A      			lda.h	#$6000 + ($1FFF & (_tiles_SPR_PLAYER))
         09:DAEB  85 ED      			sta.h	_bp
         09:DAED  A9 0B      			lda	#bank(_tiles_SPR_PLAYER)
         09:DAEF  85 02      			sta	_bp_bank
 7479                        		__st.wmiq	256, _ax
         09:DAF1  64 F8      			stz.l	_ax
         09:DAF3  A9 01      			lda.h	#256
         09:DAF5  85 F9      			sta.h	_ax
 7480                        		 _load_vram.3
         09:DAF7  82         			clx				; Offset to PCE VDC.
         09:DAF8  20 77 FF   			call	load_vram_x
 7481                        	
 7482                        		.dbg	line,	"include\init.c", 231; // SELECT PLAYER CORE SPRITE //
 7483                        	
 7484                        		.dbg	line,	"include\init.c", 232; spr_set(player_id); // ID : 2
 7485                        		__ld.umq	_player_id
         09:DAFB  AD 0E 23   			lda	_player_id
 7486                        		__call		_spr_set.1
         09:DAFE  20 DD E7   			call	_spr_set.1
 7487                        	
 7488                        		.dbg	line,	"include\init.c", 235; player_pos_x = 112;
 7489                        		__st.wmiq	112, _player_pos_x
         09:DB01  A9 70      			lda.l	#112
         09:DB03  8D 18 23   			sta.l	_player_pos_x
         09:DB06  9C 19 23   			stz.h	_player_pos_x
 7490                        	
 7491                        		.dbg	line,	"include\init.c", 236; player_pos_y = PLAYER_BASE_Y_POS;
 7492                        		__st.wmiq	128, _player_pos_y
         09:DB09  A9 80      			lda.l	#128
         09:DB0B  8D 1A 23   			sta.l	_player_pos_y
         09:DB0E  9C 1B 23   			stz.h	_player_pos_y
 7493                        	
 7494                        		.dbg	line,	"include\init.c", 239; spr_x(player_pos_x);
 7495                        		__ld.wm		_player_pos_x
         09:DB11  AD 18 23   			lda.l	_player_pos_x
         09:DB14  AC 19 23   			ldy.h	_player_pos_x
 7496                        		__call		_spr_x.1
         09:DB17  20 0A E8   			call	_spr_x.1
 7497                        	
 7498                        		.dbg	line,	"include\init.c", 240; spr_y(player_pos_y);
 7499                        		__ld.wm		_player_pos_y
         09:DB1A  AD 1A 23   			lda.l	_player_pos_y
         09:DB1D  AC 1B 23   			ldy.h	_player_pos_y
 7500                        		__call		_spr_y.1
         09:DB20  20 19 E8   			call	_spr_y.1
 7501                        	
 7502                        		.dbg	line,	"include\init.c", 242; // SET TILES DATA FOR THE PLAYER //
 7503                        	
 7504                        		.dbg	line,	"include\init.c", 243; spr_pattern(PLAYER_VRAM_ADR);
 7505                        		__ld.wi		6144
         09:DB23  62         			cla
         09:DB24  A0 18      			ldy.h	#6144
 7506                        		__call		_spr_pattern.1
         09:DB26  20 26 E8   			call	_spr_pattern.1
 7507                        	
 7508                        		.dbg	line,	"include\init.c", 246; spr_ctrl(FLIP_MAS|SIZE_MAS, NO_FLIP|SZ_32x32);
 7509                        		__st.umiq	185, _al
         09:DB29  A9 B9      			lda.l	#185
         09:DB2B  85 F8      			sta	_al
 7510                        		__ld.uiq	17
         09:DB2D  A9 11      			lda	#17
 7511                        		__call		_spr_ctrl.2
         09:DB2F  20 3C E8   			call	_spr_ctrl.2
 7512                        	
 7513                        		.dbg	line,	"include\init.c", 249; spr_pal(0);
 7514                        		__ld.uiq	0
         09:DB32  62         			cla
 7515                        		__call		_spr_pal.1
         09:DB33  20 4D E8   			call	_spr_pal.1
 7516                        	
 7517                        		.dbg	line,	"include\init.c", 250; spr_pri(TRUE);
 7518                        		__ld.uiq	1
         09:DB36  A9 01      			lda	#1
 7519                        		__call		_spr_pri.1
         09:DB38  20 5C E8   			call	_spr_pri.1
 7520                        	
 7521                        		.dbg	line,	"include\init.c", 255; //--------------------------------------------------------------------------------------//
 7522                        	
 7523                        		.dbg	line,	"include\init.c", 256; //                                       OBJECTS                                        //
 7524                        	
 7525                        		.dbg	line,	"include\init.c", 257; //--------------------------------------------------------------------------------------//
 7526                        	
 7527                        		.dbg	line,	"include\init.c", 259; // LOAD OBJECTS TILES //
 7528                        	
 7529                        		.dbg	line,	"include\init.c", 260; load_vram(POT1_VRAM_ADR, tiles_SPR_POT , TILES_32);
 7530                        		__st.wmiq	7168, _di
         09:DB3B  64 F0      			stz.l	_di
         09:DB3D  A9 1C      			lda.h	#7168
         09:DB3F  85 F1      			sta.h	_di
 7531                        		__farptr	_tiles_SPR_POT, _bp_bank, _bp
         09:DB41  A9 A0      			lda.l	#$6000 + ($1FFF & (_tiles_SPR_POT))
         09:DB43  85 EC      			sta.l	_bp
         09:DB45  A9 65      			lda.h	#$6000 + ($1FFF & (_tiles_SPR_POT))
         09:DB47  85 ED      			sta.h	_bp
         09:DB49  A9 0D      			lda	#bank(_tiles_SPR_POT)
         09:DB4B  85 02      			sta	_bp_bank
 7532                        		__st.wmiq	512, _ax
         09:DB4D  64 F8      			stz.l	_ax
         09:DB4F  A9 02      			lda.h	#512
         09:DB51  85 F9      			sta.h	_ax
 7533                        		 _load_vram.3
         09:DB53  82         			clx				; Offset to PCE VDC.
         09:DB54  20 77 FF   			call	load_vram_x
 7534                        	
 7535                        		.dbg	line,	"include\init.c", 261; load_vram(POW_VRAM_ADR, tiles_SPR_POW , TILES_4);
 7536                        		__st.wmiq	7680, _di
         09:DB57  64 F0      			stz.l	_di
         09:DB59  A9 1E      			lda.h	#7680
         09:DB5B  85 F1      			sta.h	_di
 7537                        		__farptr	_tiles_SPR_POW, _bp_bank, _bp
         09:DB5D  A9 A0      			lda.l	#$6000 + ($1FFF & (_tiles_SPR_POW))
         09:DB5F  85 EC      			sta.l	_bp
         09:DB61  A9 69      			lda.h	#$6000 + ($1FFF & (_tiles_SPR_POW))
         09:DB63  85 ED      			sta.h	_bp
         09:DB65  A9 0D      			lda	#bank(_tiles_SPR_POW)
         09:DB67  85 02      			sta	_bp_bank
 7538                        		__st.wmiq	64, _ax
         09:DB69  A9 40      			lda.l	#64
         09:DB6B  85 F8      			sta.l	_ax
         09:DB6D  64 F9      			stz.h	_ax
 7539                        		 _load_vram.3
         09:DB6F  82         			clx				; Offset to PCE VDC.
         09:DB70  20 77 FF   			call	load_vram_x
 7540                        	
 7541                        		.dbg	line,	"include\init.c", 262; load_vram(GRAY_KEY_VRAM_ADR, tiles_SPR_GRAY_KEY , TILES_4);
 7542                        		__st.wmiq	7744, _di
         09:DB73  A9 40      			lda.l	#7744
         09:DB75  85 F0      			sta.l	_di
         09:DB77  A9 1E      			lda.h	#7744
         09:DB79  85 F1      			sta.h	_di
 7543                        		__farptr	_tiles_SPR_GRAY_KEY, _bp_bank, _bp
         09:DB7B  A9 20      			lda.l	#$6000 + ($1FFF & (_tiles_SPR_GRAY_KEY))
         09:DB7D  85 EC      			sta.l	_bp
         09:DB7F  A9 63      			lda.h	#$6000 + ($1FFF & (_tiles_SPR_GRAY_KEY))
         09:DB81  85 ED      			sta.h	_bp
         09:DB83  A9 0D      			lda	#bank(_tiles_SPR_GRAY_KEY)
         09:DB85  85 02      			sta	_bp_bank
 7544                        		__st.wmiq	64, _ax
         09:DB87  A9 40      			lda.l	#64
         09:DB89  85 F8      			sta.l	_ax
         09:DB8B  64 F9      			stz.h	_ax
 7545                        		 _load_vram.3
         09:DB8D  82         			clx				; Offset to PCE VDC.
         09:DB8E  20 77 FF   			call	load_vram_x
 7546                        	
 7547                        		.dbg	line,	"include\init.c", 263; load_vram(GOLD_KEY_VRAM_ADR, tiles_SPR_GOLD_KEY , TILES_4);
 7548                        		__st.wmiq	7808, _di
         09:DB91  A9 80      			lda.l	#7808
         09:DB93  85 F0      			sta.l	_di
         09:DB95  A9 1E      			lda.h	#7808
         09:DB97  85 F1      			sta.h	_di
 7549                        		__farptr	_tiles_SPR_GOLD_KEY, _bp_bank, _bp
         09:DB99  A9 A0      			lda.l	#$6000 + ($1FFF & (_tiles_SPR_GOLD_KEY))
         09:DB9B  85 EC      			sta.l	_bp
         09:DB9D  A9 63      			lda.h	#$6000 + ($1FFF & (_tiles_SPR_GOLD_KEY))
         09:DB9F  85 ED      			sta.h	_bp
         09:DBA1  A9 0D      			lda	#bank(_tiles_SPR_GOLD_KEY)
         09:DBA3  85 02      			sta	_bp_bank
 7550                        		__st.wmiq	64, _ax
         09:DBA5  A9 40      			lda.l	#64
         09:DBA7  85 F8      			sta.l	_ax
         09:DBA9  64 F9      			stz.h	_ax
 7551                        		 _load_vram.3
         09:DBAB  82         			clx				; Offset to PCE VDC.
         09:DBAC  20 77 FF   			call	load_vram_x
 7552                        	
 7553                        		.dbg	line,	"include\init.c", 264; load_vram(LIFE_VRAM_ADR, tiles_SPR_LIFE , TILES_4);
 7554                        		__st.wmiq	7872, _di
         09:DBAF  A9 C0      			lda.l	#7872
         09:DBB1  85 F0      			sta.l	_di
         09:DBB3  A9 1E      			lda.h	#7872
         09:DBB5  85 F1      			sta.h	_di
 7555                        		__farptr	_tiles_SPR_LIFE, _bp_bank, _bp
         09:DBB7  A9 A0      			lda.l	#$6000 + ($1FFF & (_tiles_SPR_LIFE))
         09:DBB9  85 EC      			sta.l	_bp
         09:DBBB  A9 64      			lda.h	#$6000 + ($1FFF & (_tiles_SPR_LIFE))
         09:DBBD  85 ED      			sta.h	_bp
         09:DBBF  A9 0D      			lda	#bank(_tiles_SPR_LIFE)
         09:DBC1  85 02      			sta	_bp_bank
 7556                        		__st.wmiq	64, _ax
         09:DBC3  A9 40      			lda.l	#64
         09:DBC5  85 F8      			sta.l	_ax
         09:DBC7  64 F9      			stz.h	_ax
 7557                        		 _load_vram.3
         09:DBC9  82         			clx				; Offset to PCE VDC.
         09:DBCA  20 77 FF   			call	load_vram_x
 7558                        	
 7559                        		.dbg	line,	"include\init.c", 265; load_vram(COIN_1_VRAM_ADR, tiles_SPR_COIN_1 , TILES_4);
 7560                        		__st.wmiq	7936, _di
         09:DBCD  64 F0      			stz.l	_di
         09:DBCF  A9 1F      			lda.h	#7936
         09:DBD1  85 F1      			sta.h	_di
 7561                        		__farptr	_tiles_SPR_COIN_1, _bp_bank, _bp
         09:DBD3  A9 20      			lda.l	#$6000 + ($1FFF & (_tiles_SPR_COIN_1))
         09:DBD5  85 EC      			sta.l	_bp
         09:DBD7  A9 7F      			lda.h	#$6000 + ($1FFF & (_tiles_SPR_COIN_1))
         09:DBD9  85 ED      			sta.h	_bp
         09:DBDB  A9 0C      			lda	#bank(_tiles_SPR_COIN_1)
         09:DBDD  85 02      			sta	_bp_bank
 7562                        		__st.wmiq	64, _ax
         09:DBDF  A9 40      			lda.l	#64
         09:DBE1  85 F8      			sta.l	_ax
         09:DBE3  64 F9      			stz.h	_ax
 7563                        		 _load_vram.3
         09:DBE5  82         			clx				; Offset to PCE VDC.
         09:DBE6  20 77 FF   			call	load_vram_x
 7564                        	
 7565                        		.dbg	line,	"include\init.c", 266; load_vram(COIN_5_VRAM_ADR, tiles_SPR_COIN_5 , TILES_4);
 7566                        		__st.wmiq	8000, _di
         09:DBE9  A9 40      			lda.l	#8000
         09:DBEB  85 F0      			sta.l	_di
         09:DBED  A9 1F      			lda.h	#8000
         09:DBEF  85 F1      			sta.h	_di
 7567                        		__farptr	_tiles_SPR_COIN_5, _bp_bank, _bp
         09:DBF1  A9 A0      			lda.l	#$6000 + ($1FFF & (_tiles_SPR_COIN_5))
         09:DBF3  85 EC      			sta.l	_bp
         09:DBF5  A9 7F      			lda.h	#$6000 + ($1FFF & (_tiles_SPR_COIN_5))
         09:DBF7  85 ED      			sta.h	_bp
         09:DBF9  A9 0C      			lda	#bank(_tiles_SPR_COIN_5)
         09:DBFB  85 02      			sta	_bp_bank
 7568                        		__st.wmiq	64, _ax
         09:DBFD  A9 40      			lda.l	#64
         09:DBFF  85 F8      			sta.l	_ax
         09:DC01  64 F9      			stz.h	_ax
 7569                        		 _load_vram.3
         09:DC03  82         			clx				; Offset to PCE VDC.
         09:DC04  20 77 FF   			call	load_vram_x
 7570                        	
 7571                        		.dbg	line,	"include\init.c", 267; load_vram(COIN_10_VRAM_ADR, tiles_SPR_COIN_10 , TILES_4);
 7572                        		__st.wmiq	8064, _di
         09:DC07  A9 80      			lda.l	#8064
         09:DC09  85 F0      			sta.l	_di
         09:DC0B  A9 1F      			lda.h	#8064
         09:DC0D  85 F1      			sta.h	_di
 7573                        		__farptr	_tiles_SPR_COIN_10, _bp_bank, _bp
         09:DC0F  A9 20      			lda.l	#$6000 + ($1FFF & (_tiles_SPR_COIN_10))
         09:DC11  85 EC      			sta.l	_bp
         09:DC13  A9 60      			lda.h	#$6000 + ($1FFF & (_tiles_SPR_COIN_10))
         09:DC15  85 ED      			sta.h	_bp
         09:DC17  A9 0D      			lda	#bank(_tiles_SPR_COIN_10)
         09:DC19  85 02      			sta	_bp_bank
 7574                        		__st.wmiq	64, _ax
         09:DC1B  A9 40      			lda.l	#64
         09:DC1D  85 F8      			sta.l	_ax
         09:DC1F  64 F9      			stz.h	_ax
 7575                        		 _load_vram.3
         09:DC21  82         			clx				; Offset to PCE VDC.
         09:DC22  20 77 FF   			call	load_vram_x
 7576                        	
 7577                        		.dbg	line,	"include\init.c", 268; load_vram(COIN_50_VRAM_ADR, tiles_SPR_COIN_50 , TILES_4);
 7578                        		__st.wmiq	8128, _di
         09:DC25  A9 C0      			lda.l	#8128
         09:DC27  85 F0      			sta.l	_di
         09:DC29  A9 1F      			lda.h	#8128
         09:DC2B  85 F1      			sta.h	_di
 7579                        		__farptr	_tiles_SPR_COIN_50, _bp_bank, _bp
         09:DC2D  A9 A0      			lda.l	#$6000 + ($1FFF & (_tiles_SPR_COIN_50))
         09:DC2F  85 EC      			sta.l	_bp
         09:DC31  A9 60      			lda.h	#$6000 + ($1FFF & (_tiles_SPR_COIN_50))
         09:DC33  85 ED      			sta.h	_bp
         09:DC35  A9 0D      			lda	#bank(_tiles_SPR_COIN_50)
         09:DC37  85 02      			sta	_bp_bank
 7580                        		__st.wmiq	64, _ax
         09:DC39  A9 40      			lda.l	#64
         09:DC3B  85 F8      			sta.l	_ax
         09:DC3D  64 F9      			stz.h	_ax
 7581                        		 _load_vram.3
         09:DC3F  82         			clx				; Offset to PCE VDC.
         09:DC40  20 77 FF   			call	load_vram_x
 7582                        	
 7583                        		.dbg	line,	"include\init.c", 269; load_vram(COIN_100_VRAM_ADR, tiles_SPR_COIN_100 , TILES_4);
 7584                        		__st.wmiq	8192, _di
         09:DC43  64 F0      			stz.l	_di
         09:DC45  A9 20      			lda.h	#8192
         09:DC47  85 F1      			sta.h	_di
 7585                        		__farptr	_tiles_SPR_COIN_100, _bp_bank, _bp
         09:DC49  A9 20      			lda.l	#$6000 + ($1FFF & (_tiles_SPR_COIN_100))
         09:DC4B  85 EC      			sta.l	_bp
         09:DC4D  A9 61      			lda.h	#$6000 + ($1FFF & (_tiles_SPR_COIN_100))
         09:DC4F  85 ED      			sta.h	_bp
         09:DC51  A9 0D      			lda	#bank(_tiles_SPR_COIN_100)
         09:DC53  85 02      			sta	_bp_bank
 7586                        		__st.wmiq	64, _ax
         09:DC55  A9 40      			lda.l	#64
         09:DC57  85 F8      			sta.l	_ax
         09:DC59  64 F9      			stz.h	_ax
 7587                        		 _load_vram.3
         09:DC5B  82         			clx				; Offset to PCE VDC.
         09:DC5C  20 77 FF   			call	load_vram_x
 7588                        	
 7589                        		.dbg	line,	"include\init.c", 270; load_vram(COIN_500_VRAM_ADR, tiles_SPR_COIN_500 , TILES_4);
 7590                        		__st.wmiq	8256, _di
         09:DC5F  A9 40      			lda.l	#8256
         09:DC61  85 F0      			sta.l	_di
         09:DC63  A9 20      			lda.h	#8256
         09:DC65  85 F1      			sta.h	_di
 7591                        		__farptr	_tiles_SPR_COIN_500, _bp_bank, _bp
         09:DC67  A9 A0      			lda.l	#$6000 + ($1FFF & (_tiles_SPR_COIN_500))
         09:DC69  85 EC      			sta.l	_bp
         09:DC6B  A9 61      			lda.h	#$6000 + ($1FFF & (_tiles_SPR_COIN_500))
         09:DC6D  85 ED      			sta.h	_bp
         09:DC6F  A9 0D      			lda	#bank(_tiles_SPR_COIN_500)
         09:DC71  85 02      			sta	_bp_bank
 7592                        		__st.wmiq	64, _ax
         09:DC73  A9 40      			lda.l	#64
         09:DC75  85 F8      			sta.l	_ax
         09:DC77  64 F9      			stz.h	_ax
 7593                        		 _load_vram.3
         09:DC79  82         			clx				; Offset to PCE VDC.
         09:DC7A  20 77 FF   			call	load_vram_x
 7594                        	
 7595                        		.dbg	line,	"include\init.c", 271; load_vram(COIN_1000_VRAM_ADR, tiles_SPR_COIN_1000 , TILES_4);
 7596                        		__st.wmiq	8320, _di
         09:DC7D  A9 80      			lda.l	#8320
         09:DC7F  85 F0      			sta.l	_di
         09:DC81  A9 20      			lda.h	#8320
         09:DC83  85 F1      			sta.h	_di
 7597                        		__farptr	_tiles_SPR_COIN_1000, _bp_bank, _bp
         09:DC85  A9 20      			lda.l	#$6000 + ($1FFF & (_tiles_SPR_COIN_1000))
         09:DC87  85 EC      			sta.l	_bp
         09:DC89  A9 62      			lda.h	#$6000 + ($1FFF & (_tiles_SPR_COIN_1000))
         09:DC8B  85 ED      			sta.h	_bp
         09:DC8D  A9 0D      			lda	#bank(_tiles_SPR_COIN_1000)
         09:DC8F  85 02      			sta	_bp_bank
 7598                        		__st.wmiq	64, _ax
         09:DC91  A9 40      			lda.l	#64
         09:DC93  85 F8      			sta.l	_ax
         09:DC95  64 F9      			stz.h	_ax
 7599                        		 _load_vram.3
         09:DC97  82         			clx				; Offset to PCE VDC.
         09:DC98  20 77 FF   			call	load_vram_x
 7600                        	
 7601                        		.dbg	line,	"include\init.c", 272; load_vram(STAR_VRAM_ADR, tiles_SPR_STAR , TILES_4);
 7602                        		__st.wmiq	8384, _di
         09:DC9B  A9 C0      			lda.l	#8384
         09:DC9D  85 F0      			sta.l	_di
         09:DC9F  A9 20      			lda.h	#8384
         09:DCA1  85 F1      			sta.h	_di
 7603                        		__farptr	_tiles_SPR_STAR, _bp_bank, _bp
         09:DCA3  A9 20      			lda.l	#$6000 + ($1FFF & (_tiles_SPR_STAR))
         09:DCA5  85 EC      			sta.l	_bp
         09:DCA7  A9 6A      			lda.h	#$6000 + ($1FFF & (_tiles_SPR_STAR))
         09:DCA9  85 ED      			sta.h	_bp
         09:DCAB  A9 0D      			lda	#bank(_tiles_SPR_STAR)
         09:DCAD  85 02      			sta	_bp_bank
 7604                        		__st.wmiq	64, _ax
         09:DCAF  A9 40      			lda.l	#64
         09:DCB1  85 F8      			sta.l	_ax
         09:DCB3  64 F9      			stz.h	_ax
 7605                        		 _load_vram.3
         09:DCB5  82         			clx				; Offset to PCE VDC.
         09:DCB6  20 77 FF   			call	load_vram_x
 7606                        	
 7607                        		.dbg	line,	"include\init.c", 273; load_vram(OCTOPUS_VRAM_ADR, tiles_SPR_OCTOPUS , TILES_4);
 7608                        		__st.wmiq	8448, _di
         09:DCB9  64 F0      			stz.l	_di
         09:DCBB  A9 21      			lda.h	#8448
         09:DCBD  85 F1      			sta.h	_di
 7609                        		__farptr	_tiles_SPR_OCTOPUS, _bp_bank, _bp
         09:DCBF  A9 20      			lda.l	#$6000 + ($1FFF & (_tiles_SPR_OCTOPUS))
         09:DCC1  85 EC      			sta.l	_bp
         09:DCC3  A9 65      			lda.h	#$6000 + ($1FFF & (_tiles_SPR_OCTOPUS))
         09:DCC5  85 ED      			sta.h	_bp
         09:DCC7  A9 0D      			lda	#bank(_tiles_SPR_OCTOPUS)
         09:DCC9  85 02      			sta	_bp_bank
 7610                        		__st.wmiq	64, _ax
         09:DCCB  A9 40      			lda.l	#64
         09:DCCD  85 F8      			sta.l	_ax
         09:DCCF  64 F9      			stz.h	_ax
 7611                        		 _load_vram.3
         09:DCD1  82         			clx				; Offset to PCE VDC.
         09:DCD2  20 77 FF   			call	load_vram_x
 7612                        	
 7613                        		.dbg	line,	"include\init.c", 274; load_vram(FRUIT_VRAM_ADR, tiles_SPR_FRUIT , TILES_4);
 7614                        		__st.wmiq	8512, _di
         09:DCD5  A9 40      			lda.l	#8512
         09:DCD7  85 F0      			sta.l	_di
         09:DCD9  A9 21      			lda.h	#8512
         09:DCDB  85 F1      			sta.h	_di
 7615                        		__farptr	_tiles_SPR_FRUIT, _bp_bank, _bp
         09:DCDD  A9 A0      			lda.l	#$6000 + ($1FFF & (_tiles_SPR_FRUIT))
         09:DCDF  85 EC      			sta.l	_bp
         09:DCE1  A9 62      			lda.h	#$6000 + ($1FFF & (_tiles_SPR_FRUIT))
         09:DCE3  85 ED      			sta.h	_bp
         09:DCE5  A9 0D      			lda	#bank(_tiles_SPR_FRUIT)
         09:DCE7  85 02      			sta	_bp_bank
 7616                        		__st.wmiq	64, _ax
         09:DCE9  A9 40      			lda.l	#64
         09:DCEB  85 F8      			sta.l	_ax
         09:DCED  64 F9      			stz.h	_ax
 7617                        		 _load_vram.3
         09:DCEF  82         			clx				; Offset to PCE VDC.
         09:DCF0  20 77 FF   			call	load_vram_x
 7618                        	
 7619                        		.dbg	line,	"include\init.c", 275; load_vram(BARREL_VRAM_ADR, tiles_SPR_BARREL , TILES_4);
 7620                        		__st.wmiq	8576, _di
         09:DCF3  A9 80      			lda.l	#8576
         09:DCF5  85 F0      			sta.l	_di
         09:DCF7  A9 21      			lda.h	#8576
         09:DCF9  85 F1      			sta.h	_di
 7621                        		__farptr	_tiles_SPR_BARREL, _bp_bank, _bp
         09:DCFB  A9 A0      			lda.l	#$6000 + ($1FFF & (_tiles_SPR_BARREL))
         09:DCFD  85 EC      			sta.l	_bp
         09:DCFF  A9 7C      			lda.h	#$6000 + ($1FFF & (_tiles_SPR_BARREL))
         09:DD01  85 ED      			sta.h	_bp
         09:DD03  A9 0C      			lda	#bank(_tiles_SPR_BARREL)
         09:DD05  85 02      			sta	_bp_bank
 7622                        		__st.wmiq	64, _ax
         09:DD07  A9 40      			lda.l	#64
         09:DD09  85 F8      			sta.l	_ax
         09:DD0B  64 F9      			stz.h	_ax
 7623                        		 _load_vram.3
         09:DD0D  82         			clx				; Offset to PCE VDC.
         09:DD0E  20 77 FF   			call	load_vram_x
 7624                        	
 7625                        		.dbg	line,	"include\init.c", 278; load_vram(CHEST_VRAM_ADR, tiles_SPR_CHEST , TILES_16);
 7626                        		__st.wmiq	9216, _di
         09:DD11  64 F0      			stz.l	_di
         09:DD13  A9 24      			lda.h	#9216
         09:DD15  85 F1      			sta.h	_di
 7627                        		__farptr	_tiles_SPR_CHEST, _bp_bank, _bp
         09:DD17  A9 20      			lda.l	#$6000 + ($1FFF & (_tiles_SPR_CHEST))
         09:DD19  85 EC      			sta.l	_bp
         09:DD1B  A9 7D      			lda.h	#$6000 + ($1FFF & (_tiles_SPR_CHEST))
         09:DD1D  85 ED      			sta.h	_bp
         09:DD1F  A9 0C      			lda	#bank(_tiles_SPR_CHEST)
         09:DD21  85 02      			sta	_bp_bank
 7628                        		__st.wmiq	256, _ax
         09:DD23  64 F8      			stz.l	_ax
         09:DD25  A9 01      			lda.h	#256
         09:DD27  85 F9      			sta.h	_ax
 7629                        		 _load_vram.3
         09:DD29  82         			clx				; Offset to PCE VDC.
         09:DD2A  20 77 FF   			call	load_vram_x
 7630                        	
 7631                        		.dbg	line,	"include\init.c", 282; for(i=0 ; i<objects_max ; i++)
 7632                        		__st.umiq	0, __init_LEVEL_end - 1  /* i */
         09:DD2D  9C 0A 23   			stz	__init_LEVEL_end - 1
 7633    09:DD30             	.LL297:
 7634                        		__ld.bm		__init_LEVEL_end - 1  /* i */
         09:DD30  AD 0A 23   			lda	__init_LEVEL_end - 1
         09:DD33  C2         			cly
         09:DD34  10 01      			bpl	!+
         09:DD36  88         			dey
         09:DD37             	!:
 7635                        		__slt_w.um	_objects_max
         09:DD37  CD 17 23   			cmp	_objects_max		; Subtract memory from Y:A.
         09:DD3A  98         			tya
         09:DD3B  E9 00      			sbc	#0
         09:DD3D  50 02      			bvc	!+
         09:DD3F  49 80      			eor	#$80		; -ve if Y:A < memory (signed).
         09:DD41  0A         	!:		asl	a
 7636                        		__btrue		.LL299
         09:DD42  B0 08      			bcs	.LL299
 7637                        		__bra		.LL300
         09:DD44  4C C7 DE   			bra	.LL300
 7638    09:DD47             	.LL298:
 7639                        		__inc.umq	__init_LEVEL_end - 1  /* i */
         09:DD47  EE 0A 23   			inc	__init_LEVEL_end - 1
 7640                        		__bra		.LL297
         09:DD4A  80 E4      			bra	.LL297
 7641    09:DD4C             	.LL299:
 7642                        	
 7643                        		.dbg	line,	"include\init.c", 283; {
 7644                        	
 7645                        		.dbg	line,	"include\init.c", 284; // SET OBJECT PROPERTIES //
 7646                        	
 7647                        		.dbg	line,	"include\init.c", 285; list_objects_type[i] = TABLE_OBJECTS_TYPE_LV1[i];
 7648                        		__ldx.bmq	__init_LEVEL_end - 1  /* i */
         09:DD4C  AE 0A 23   			ldx	__init_LEVEL_end - 1
 7649                        		__ld.uax	_TABLE_OBJECTS_TYPE_LV1
         09:DD4F  BD 1D 60   			lda	_TABLE_OBJECTS_TYPE_LV1, x
         09:DD52  C2         			cly
 7650                        		__ld2x.bm	__init_LEVEL_end - 1  /* i */
         09:DD53  AA         			tax
         09:DD54  AD 0A 23   			lda	__init_LEVEL_end - 1
         09:DD57  0A         			asl	a
         09:DD58  22         			sax
 7651                        		__st.waxq	_list_objects_type
         09:DD59  9D 1E 23   			sta.l	_list_objects_type, x
         09:DD5C  98         			tya
         09:DD5D  9D 1F 23   			sta.h	_list_objects_type, x
 7652                        	
 7653                        		.dbg	line,	"include\init.c", 286; list_objects_x_pos_ref[i] = TABLE_OBJECTS_X_POS_REF_LV1[i];
 7654                        		__ld2x.bmq	__init_LEVEL_end - 1  /* i */
         09:DD60  AD 0A 23   			lda	__init_LEVEL_end - 1
         09:DD63  0A         			asl	a
         09:DD64  AA         			tax
 7655                        		__ld.wax	_TABLE_OBJECTS_X_POS_REF_LV1
         09:DD65  BD 36 60   			lda.l	_TABLE_OBJECTS_X_POS_REF_LV1, x
         09:DD68  BC 37 60   			ldy.h	_TABLE_OBJECTS_X_POS_REF_LV1, x
 7656                        		__ld2x.bm	__init_LEVEL_end - 1  /* i */
         09:DD6B  AA         			tax
         09:DD6C  AD 0A 23   			lda	__init_LEVEL_end - 1
         09:DD6F  0A         			asl	a
         09:DD70  22         			sax
 7657                        		__st.waxq	_list_objects_x_pos_ref
         09:DD71  9D E6 23   			sta.l	_list_objects_x_pos_ref, x
         09:DD74  98         			tya
         09:DD75  9D E7 23   			sta.h	_list_objects_x_pos_ref, x
 7658                        	
 7659                        		.dbg	line,	"include\init.c", 287; list_objects_y_pos_ref[i] = TABLE_OBJECTS_Y_POS_REF_LV1[i];
 7660                        		__ld2x.bmq	__init_LEVEL_end - 1  /* i */
         09:DD78  AD 0A 23   			lda	__init_LEVEL_end - 1
         09:DD7B  0A         			asl	a
         09:DD7C  AA         			tax
 7661                        		__ld.wax	_TABLE_OBJECTS_Y_POS_REF_LV1
         09:DD7D  BD 68 60   			lda.l	_TABLE_OBJECTS_Y_POS_REF_LV1, x
         09:DD80  BC 69 60   			ldy.h	_TABLE_OBJECTS_Y_POS_REF_LV1, x
 7662                        		__ld2x.bm	__init_LEVEL_end - 1  /* i */
         09:DD83  AA         			tax
         09:DD84  AD 0A 23   			lda	__init_LEVEL_end - 1
         09:DD87  0A         			asl	a
         09:DD88  22         			sax
 7663                        		__st.waxq	_list_objects_y_pos_ref
         09:DD89  9D 18 24   			sta.l	_list_objects_y_pos_ref, x
         09:DD8C  98         			tya
         09:DD8D  9D 19 24   			sta.h	_list_objects_y_pos_ref, x
 7664                        	
 7665                        		.dbg	line,	"include\init.c", 288; list_objects_x_pos[i] = -32;
 7666                        		__ld2x.bmq	__init_LEVEL_end - 1  /* i */
         09:DD90  AD 0A 23   			lda	__init_LEVEL_end - 1
         09:DD93  0A         			asl	a
         09:DD94  AA         			tax
 7667                        		__st.waxiq	-32, _list_objects_x_pos
         09:DD95  A9 E0      			lda.l	#-32
         09:DD97  9D 82 23   			sta.l	_list_objects_x_pos, x
         09:DD9A  A9 FF      			lda.h	#-32
         09:DD9C  9D 83 23   			sta.h	_list_objects_x_pos, x
 7668                        	
 7669                        		.dbg	line,	"include\init.c", 289; list_objects_y_pos[i] = -32;
 7670                        		__ld2x.bmq	__init_LEVEL_end - 1  /* i */
         09:DD9F  AD 0A 23   			lda	__init_LEVEL_end - 1
         09:DDA2  0A         			asl	a
         09:DDA3  AA         			tax
 7671                        		__st.waxiq	-32, _list_objects_y_pos
         09:DDA4  A9 E0      			lda.l	#-32
         09:DDA6  9D B4 23   			sta.l	_list_objects_y_pos, x
         09:DDA9  A9 FF      			lda.h	#-32
         09:DDAB  9D B5 23   			sta.h	_list_objects_y_pos, x
 7672                        	
 7673                        		.dbg	line,	"include\init.c", 290; list_objects_state[i] = STATE_ACTIVE;
 7674                        		__ld2x.bmq	__init_LEVEL_end - 1  /* i */
         09:DDAE  AD 0A 23   			lda	__init_LEVEL_end - 1
         09:DDB1  0A         			asl	a
         09:DDB2  AA         			tax
 7675                        		__st.waxiq	0, _list_objects_state
         09:DDB3  9E 50 23   			stz.l	_list_objects_state, x
         09:DDB6  9E 51 23   			stz.h	_list_objects_state, x
 7676                        	
 7677                        		.dbg	line,	"include\init.c", 293; // SET OBJECT SPRITE //
 7678                        	
 7679                        		.dbg	line,	"include\init.c", 294; spr_set(i + 3);
 7680                        		__ld.bm		__init_LEVEL_end - 1  /* i */
         09:DDB9  AD 0A 23   			lda	__init_LEVEL_end - 1
         09:DDBC  C2         			cly
         09:DDBD  10 01      			bpl	!+
         09:DDBF  88         			dey
         09:DDC0             	!:
 7681                        		__add.wi	3
         09:DDC0  18         			clc
         09:DDC1  69 03      			adc.l	#3
         09:DDC3  90 01      			bcc	!+
         09:DDC5  C8         			iny
         09:DDC6             	!:
 7682                        		__call		_spr_set.1
         09:DDC6  20 DD E7   			call	_spr_set.1
 7683                        	
 7684                        		.dbg	line,	"include\init.c", 295; spr_x(list_objects_x_pos[i]);
 7685                        		__ld2x.bmq	__init_LEVEL_end - 1  /* i */
         09:DDC9  AD 0A 23   			lda	__init_LEVEL_end - 1
         09:DDCC  0A         			asl	a
         09:DDCD  AA         			tax
 7686                        		__ld.wax	_list_objects_x_pos
         09:DDCE  BD 82 23   			lda.l	_list_objects_x_pos, x
         09:DDD1  BC 83 23   			ldy.h	_list_objects_x_pos, x
 7687                        		__call		_spr_x.1
         09:DDD4  20 0A E8   			call	_spr_x.1
 7688                        	
 7689                        		.dbg	line,	"include\init.c", 296; spr_y(list_objects_y_pos[i]);
 7690                        		__ld2x.bmq	__init_LEVEL_end - 1  /* i */
         09:DDD7  AD 0A 23   			lda	__init_LEVEL_end - 1
         09:DDDA  0A         			asl	a
         09:DDDB  AA         			tax
 7691                        		__ld.wax	_list_objects_y_pos
         09:DDDC  BD B4 23   			lda.l	_list_objects_y_pos, x
         09:DDDF  BC B5 23   			ldy.h	_list_objects_y_pos, x
 7692                        		__call		_spr_y.1
         09:DDE2  20 19 E8   			call	_spr_y.1
 7693                        	
 7694                        		.dbg	line,	"include\init.c", 297; spr_pri(TRUE);
 7695                        		__ld.uiq	1
         09:DDE5  A9 01      			lda	#1
 7696                        		__call		_spr_pri.1
         09:DDE7  20 5C E8   			call	_spr_pri.1
 7697                        	
 7698                        		.dbg	line,	"include\init.c", 300; if(list_objects_type[i] == TYPE_HOURGLASS)
 7699                        		__ld2x.bmq	__init_LEVEL_end - 1  /* i */
         09:DDEA  AD 0A 23   			lda	__init_LEVEL_end - 1
         09:DDED  0A         			asl	a
         09:DDEE  AA         			tax
 7700                        		__not.wax	_list_objects_type
         09:DDEF  BD 1E 23   			lda.l	_list_objects_type, x
         09:DDF2  1D 1F 23   			ora.h	_list_objects_type, x
         09:DDF5  18         			clc
         09:DDF6  D0 01      			bne	!+
         09:DDF8  38         			sec
         09:DDF9             	!:
 7701                        		__bfalse	.LL301
         09:DDF9  90 21      			bcc	.LL301
 7702                        	
 7703                        		.dbg	line,	"include\init.c", 301; {
 7704                        	
 7705                        		.dbg	line,	"include\init.c", 302; list_objects_energy[i] = 0;
 7706                        		__ld2x.bmq	__init_LEVEL_end - 1  /* i */
         09:DDFB  AD 0A 23   			lda	__init_LEVEL_end - 1
         09:DDFE  0A         			asl	a
         09:DDFF  AA         			tax
 7707                        		__st.waxiq	0, _list_objects_energy
         09:DE00  9E 4A 24   			stz.l	_list_objects_energy, x
         09:DE03  9E 4B 24   			stz.h	_list_objects_energy, x
 7708                        	
 7709                        		.dbg	line,	"include\init.c", 303; spr_pal(18);
 7710                        		__ld.uiq	18
         09:DE06  A9 12      			lda	#18
 7711                        		__call		_spr_pal.1
         09:DE08  20 4D E8   			call	_spr_pal.1
 7712                        	
 7713                        		.dbg	line,	"include\init.c", 304; spr_pattern(POT1_VRAM_ADR);
 7714                        		__ld.wi		7168
         09:DE0B  62         			cla
         09:DE0C  A0 1C      			ldy.h	#7168
 7715                        		__call		_spr_pattern.1
         09:DE0E  20 26 E8   			call	_spr_pattern.1
 7716                        	
 7717                        		.dbg	line,	"include\init.c", 305; spr_ctrl(FLIP_MAS|SIZE_MAS, NO_FLIP|SZ_16x16);
 7718                        		__st.umiq	185, _al
         09:DE11  A9 B9      			lda.l	#185
         09:DE13  85 F8      			sta	_al
 7719                        		__ld.uiq	0
         09:DE15  62         			cla
 7720                        		__call		_spr_ctrl.2
         09:DE16  20 3C E8   			call	_spr_ctrl.2
 7721                        	
 7722                        		.dbg	line,	"include\init.c", 306; }
 7723                        	
 7724                        		.dbg	line,	"include\init.c", 308; else if(list_objects_type[i] == TYPE_POT)
 7725                        		__bra		.LL302
         09:DE19  4C 47 DD   			bra	.LL302
 7726    09:DE1C             	.LL301:
 7727                        		__ld2x.bmq	__init_LEVEL_end - 1  /* i */
         09:DE1C  AD 0A 23   			lda	__init_LEVEL_end - 1
         09:DE1F  0A         			asl	a
         09:DE20  AA         			tax
 7728                        		__ld.wax	_list_objects_type
         09:DE21  BD 1E 23   			lda.l	_list_objects_type, x
         09:DE24  BC 1F 23   			ldy.h	_list_objects_type, x
 7729                        		__equ_w.wi	1
         09:DE27  C9 01      			cmp.l	#1
         09:DE29  D0 04      			bne	!false+
         09:DE2B  C0 00      			cpy.h	#1
         09:DE2D  F0 01      			beq	!+
         09:DE2F  18         	!false:		clc
         09:DE30             	!:
 7730                        		__bfalse	.LL303
         09:DE30  90 23      			bcc	.LL303
 7731                        	
 7732                        		.dbg	line,	"include\init.c", 309; {
 7733                        	
 7734                        		.dbg	line,	"include\init.c", 310; list_objects_energy[i] = 2;
 7735                        		__ld2x.bmq	__init_LEVEL_end - 1  /* i */
         09:DE32  AD 0A 23   			lda	__init_LEVEL_end - 1
         09:DE35  0A         			asl	a
         09:DE36  AA         			tax
 7736                        		__st.waxiq	2, _list_objects_energy
         09:DE37  A9 02      			lda.l	#2
         09:DE39  9D 4A 24   			sta.l	_list_objects_energy, x
         09:DE3C  9E 4B 24   			stz.h	_list_objects_energy, x
 7737                        	
 7738                        		.dbg	line,	"include\init.c", 311; spr_pal(17);
 7739                        		__ld.uiq	17
         09:DE3F  A9 11      			lda	#17
 7740                        		__call		_spr_pal.1
         09:DE41  20 4D E8   			call	_spr_pal.1
 7741                        	
 7742                        		.dbg	line,	"include\init.c", 312; spr_pattern(POT1_VRAM_ADR);
 7743                        		__ld.wi		7168
         09:DE44  62         			cla
         09:DE45  A0 1C      			ldy.h	#7168
 7744                        		__call		_spr_pattern.1
         09:DE47  20 26 E8   			call	_spr_pattern.1
 7745                        	
 7746                        		.dbg	line,	"include\init.c", 313; spr_ctrl(FLIP_MAS|SIZE_MAS, NO_FLIP|SZ_16x16);
 7747                        		__st.umiq	185, _al
         09:DE4A  A9 B9      			lda.l	#185
         09:DE4C  85 F8      			sta	_al
 7748                        		__ld.uiq	0
         09:DE4E  62         			cla
 7749                        		__call		_spr_ctrl.2
         09:DE4F  20 3C E8   			call	_spr_ctrl.2
 7750                        	
 7751                        		.dbg	line,	"include\init.c", 314; }
 7752                        	
 7753                        		.dbg	line,	"include\init.c", 316; else if(list_objects_type[i] == TYPE_POW)
 7754                        		__bra		.LL304
         09:DE52  4C 47 DD   			bra	.LL304
 7755    09:DE55             	.LL303:
 7756                        		__ld2x.bmq	__init_LEVEL_end - 1  /* i */
         09:DE55  AD 0A 23   			lda	__init_LEVEL_end - 1
         09:DE58  0A         			asl	a
         09:DE59  AA         			tax
 7757                        		__ld.wax	_list_objects_type
         09:DE5A  BD 1E 23   			lda.l	_list_objects_type, x
         09:DE5D  BC 1F 23   			ldy.h	_list_objects_type, x
 7758                        		__equ_w.wi	2
         09:DE60  C9 02      			cmp.l	#2
         09:DE62  D0 04      			bne	!false+
         09:DE64  C0 00      			cpy.h	#2
         09:DE66  F0 01      			beq	!+
         09:DE68  18         	!false:		clc
         09:DE69             	!:
 7759                        		__bfalse	.LL305
         09:DE69  90 21      			bcc	.LL305
 7760                        	
 7761                        		.dbg	line,	"include\init.c", 317; {
 7762                        	
 7763                        		.dbg	line,	"include\init.c", 318; list_objects_energy[i] = 0;
 7764                        		__ld2x.bmq	__init_LEVEL_end - 1  /* i */
         09:DE6B  AD 0A 23   			lda	__init_LEVEL_end - 1
         09:DE6E  0A         			asl	a
         09:DE6F  AA         			tax
 7765                        		__st.waxiq	0, _list_objects_energy
         09:DE70  9E 4A 24   			stz.l	_list_objects_energy, x
         09:DE73  9E 4B 24   			stz.h	_list_objects_energy, x
 7766                        	
 7767                        		.dbg	line,	"include\init.c", 319; spr_pal(18);
 7768                        		__ld.uiq	18
         09:DE76  A9 12      			lda	#18
 7769                        		__call		_spr_pal.1
         09:DE78  20 4D E8   			call	_spr_pal.1
 7770                        	
 7771                        		.dbg	line,	"include\init.c", 320; spr_pattern(POW_VRAM_ADR);
 7772                        		__ld.wi		7680
         09:DE7B  62         			cla
         09:DE7C  A0 1E      			ldy.h	#7680
 7773                        		__call		_spr_pattern.1
         09:DE7E  20 26 E8   			call	_spr_pattern.1
 7774                        	
 7775                        		.dbg	line,	"include\init.c", 321; spr_ctrl(FLIP_MAS|SIZE_MAS, NO_FLIP|SZ_16x16);
 7776                        		__st.umiq	185, _al
         09:DE81  A9 B9      			lda.l	#185
         09:DE83  85 F8      			sta	_al
 7777                        		__ld.uiq	0
         09:DE85  62         			cla
 7778                        		__call		_spr_ctrl.2
         09:DE86  20 3C E8   			call	_spr_ctrl.2
 7779                        	
 7780                        		.dbg	line,	"include\init.c", 322; }
 7781                        	
 7782                        		.dbg	line,	"include\init.c", 324; else if(list_objects_type[i] == TYPE_CHEST)
 7783                        		__bra		.LL306
         09:DE89  4C 47 DD   			bra	.LL306
 7784    09:DE8C             	.LL305:
 7785                        		__ld2x.bmq	__init_LEVEL_end - 1  /* i */
         09:DE8C  AD 0A 23   			lda	__init_LEVEL_end - 1
         09:DE8F  0A         			asl	a
         09:DE90  AA         			tax
 7786                        		__ld.wax	_list_objects_type
         09:DE91  BD 1E 23   			lda.l	_list_objects_type, x
         09:DE94  BC 1F 23   			ldy.h	_list_objects_type, x
 7787                        		__equ_w.wi	3
         09:DE97  C9 03      			cmp.l	#3
         09:DE99  D0 04      			bne	!false+
         09:DE9B  C0 00      			cpy.h	#3
         09:DE9D  F0 01      			beq	!+
         09:DE9F  18         	!false:		clc
         09:DEA0             	!:
 7788                        		__bfalse	.LL307
         09:DEA0  B0 03 4C 47			bcc	.LL307
         09:DEA4  DD          
 7789                        	
 7790                        		.dbg	line,	"include\init.c", 325; {
 7791                        	
 7792                        		.dbg	line,	"include\init.c", 326; list_objects_energy[i] = 0;
 7793                        		__ld2x.bmq	__init_LEVEL_end - 1  /* i */
         09:DEA5  AD 0A 23   			lda	__init_LEVEL_end - 1
         09:DEA8  0A         			asl	a
         09:DEA9  AA         			tax
 7794                        		__st.waxiq	0, _list_objects_energy
         09:DEAA  9E 4A 24   			stz.l	_list_objects_energy, x
         09:DEAD  9E 4B 24   			stz.h	_list_objects_energy, x
 7795                        	
 7796                        		.dbg	line,	"include\init.c", 327; spr_pal(18);
 7797                        		__ld.uiq	18
         09:DEB0  A9 12      			lda	#18
 7798                        		__call		_spr_pal.1
         09:DEB2  20 4D E8   			call	_spr_pal.1
 7799                        	
 7800                        		.dbg	line,	"include\init.c", 328; spr_pattern(CHEST_VRAM_ADR);
 7801                        		__ld.wi		9216
         09:DEB5  62         			cla
         09:DEB6  A0 24      			ldy.h	#9216
 7802                        		__call		_spr_pattern.1
         09:DEB8  20 26 E8   			call	_spr_pattern.1
 7803                        	
 7804                        		.dbg	line,	"include\init.c", 329; spr_ctrl(FLIP_MAS|SIZE_MAS, NO_FLIP|SZ_32x32);
 7805                        		__st.umiq	185, _al
         09:DEBB  A9 B9      			lda.l	#185
         09:DEBD  85 F8      			sta	_al
 7806                        		__ld.uiq	17
         09:DEBF  A9 11      			lda	#17
 7807                        		__call		_spr_ctrl.2
         09:DEC1  20 3C E8   			call	_spr_ctrl.2
 7808                        	
 7809                        		.dbg	line,	"include\init.c", 330; }
 7810                        	
 7811                        		.dbg	line,	"include\init.c", 331; }
 7812    09:DEC4             	.LL307	.alias		.LL298
 7813    09:DEC4             	.LL306	.alias		.LL298
 7814    09:DEC4             	.LL304	.alias		.LL298
 7815    09:DEC4             	.LL302	.alias		.LL298
 7816                        		__bra		.LL298
         09:DEC4  4C 47 DD   			bra	.LL298
 7817    09:DEC7             	.LL300:
 7818                        	
 7819                        		.dbg	line,	"include\init.c", 334; scroll_OBJECTS();
 7820                        		__call		_scroll_OBJECTS
         09:DEC7  20 27 FF   			call	_scroll_OBJECTS
 7821                        	
 7822                        		.dbg	line,	"include\init.c", 337; // UPDATE PCE SAT //
 7823                        	
 7824                        		.dbg	line,	"include\init.c", 338; satb_update();
 7825                        		__call		_satb_update
         09:DECA  20 1D FF   			call	_satb_update
 7826                        	
 7827                        		.dbg	line,	"include\init.c", 343; //--------------------------------------------------------------------------------------//
 7828                        	
 7829                        		.dbg	line,	"include\init.c", 344; //                                LOAD SPRITES PALETTES                                 //
 7830                        	
 7831                        		.dbg	line,	"include\init.c", 345; //--------------------------------------------------------------------------------------//
 7832                        	
 7833                        		.dbg	line,	"include\init.c", 347; load_palette( 16, palette_PLAYER,  1 );
 7834                        		__st.umiq	16, _al
         09:DECD  A9 10      			lda.l	#16
         09:DECF  85 F8      			sta	_al
 7835                        		__farptr	_palette_PLAYER, _bp_bank, _bp
         09:DED1  A9 A0      			lda.l	#$6000 + ($1FFF & (_palette_PLAYER))
         09:DED3  85 EC      			sta.l	_bp
         09:DED5  A9 7A      			lda.h	#$6000 + ($1FFF & (_palette_PLAYER))
         09:DED7  85 ED      			sta.h	_bp
         09:DED9  A9 0C      			lda	#bank(_palette_PLAYER)
         09:DEDB  85 02      			sta	_bp_bank
 7836                        		__st.umiq	1, _ah
         09:DEDD  A9 01      			lda.l	#1
         09:DEDF  85 F9      			sta	_ah
 7837                        		__call		_load_palette.3
         09:DEE1  20 31 FF   			call	_load_palette.3
 7838                        	
 7839                        		.dbg	line,	"include\init.c", 348; load_palette( 17, palette_OBJECTS_1, 1 );
 7840                        		__st.umiq	17, _al
         09:DEE4  A9 11      			lda.l	#17
         09:DEE6  85 F8      			sta	_al
 7841                        		__farptr	_palette_OBJECTS_1, _bp_bank, _bp
         09:DEE8  A9 A0      			lda.l	#$6000 + ($1FFF & (_palette_OBJECTS_1))
         09:DEEA  85 EC      			sta.l	_bp
         09:DEEC  A9 6A      			lda.h	#$6000 + ($1FFF & (_palette_OBJECTS_1))
         09:DEEE  85 ED      			sta.h	_bp
         09:DEF0  A9 0D      			lda	#bank(_palette_OBJECTS_1)
         09:DEF2  85 02      			sta	_bp_bank
 7842                        		__st.umiq	1, _ah
         09:DEF4  A9 01      			lda.l	#1
         09:DEF6  85 F9      			sta	_ah
 7843                        		__call		_load_palette.3
         09:DEF8  20 31 FF   			call	_load_palette.3
 7844                        	
 7845                        		.dbg	line,	"include\init.c", 349; load_palette( 18, palette_OBJECTS_2, 1 );
 7846                        		__st.umiq	18, _al
         09:DEFB  A9 12      			lda.l	#18
         09:DEFD  85 F8      			sta	_al
 7847                        		__farptr	_palette_OBJECTS_2, _bp_bank, _bp
         09:DEFF  A9 A0      			lda.l	#$6000 + ($1FFF & (_palette_OBJECTS_2))
         09:DF01  85 EC      			sta.l	_bp
         09:DF03  A9 6C      			lda.h	#$6000 + ($1FFF & (_palette_OBJECTS_2))
         09:DF05  85 ED      			sta.h	_bp
         09:DF07  A9 0D      			lda	#bank(_palette_OBJECTS_2)
         09:DF09  85 02      			sta	_bp_bank
 7848                        		__st.umiq	1, _ah
         09:DF0B  A9 01      			lda.l	#1
         09:DF0D  85 F9      			sta	_ah
 7849                        		__call		_load_palette.3
         09:DF0F  20 31 FF   			call	_load_palette.3
 7850                        	
 7851                        		.dbg	line,	"include\init.c", 357; // VSYNC //
 7852                        	
 7853                        		.dbg	line,	"include\init.c", 358; vsync();
 7854                        		__call		_vsync
         09:DF12  20 09 E3   			call	_vsync
 7855                        	
 7856                        		.dbg	line,	"include\init.c", 360; // ENABLE DISPLAY //
 7857                        	
 7858                        		.dbg	line,	"include\init.c", 361; disp_on();
 7859                        		__call		_disp_on
         09:DF15  20 16 E4   			call	_disp_on
 7860                        	
 7861                        		.dbg	line,	"include\init.c", 362; }
 7862                        	
 7863                        		.dbg	line,	"include\init.c", 363; }
 7864    09:DF18             	.LL296:
 7865    09:DF18             	.LL295:
 7866                        		__return	0
         09:DF18  4C EF FF   			jmp	leave_proc
 7867                        		.dbg	clear
 7868                        		.endp
 7869               6F20     		.data
 7870               230A     		.bss
 7871    F8:230A             	__init_LEVEL_loc:
 7872    F8:230A             			ds	1
 7873    F8:230B             	__init_LEVEL_end:
 7874               E309     		.code
 7875                        		.pceas
 7876                        	
 7877                        		.dbg	line,	"main.c", 30; main()
 7878                        		.dbg	line,	"main.c", 31; {
 7879                        	;***********************
 7880                        	;***********************
 7881                        	
 7882                        		.hucc
 7883    0D:DB34             		.proc		_main
 7884                        		__enter		_main
 7885                        	
 7886                        		.dbg	line,	"main.c", 32; if(!sgx_detect())
 7887                        		 _sgx_detect
         0D:DB34  AD E8 22   			lda	sgx_detected
         0D:DB37  C2         			cly
 7888                        		__not.wr
         0D:DB38  84 00      			sty	__temp
         0D:DB3A  05 00      			ora	__temp
         0D:DB3C  18         			clc
         0D:DB3D  D0 01      			bne	!+
         0D:DB3F  38         			sec
         0D:DB40             	!:
 7889                        		__bfalse	.LL309
         0D:DB40  90 14      			bcc	.LL309
 7890                        	
 7891                        		.dbg	line,	"main.c", 33; {
 7892                        	
 7893                        		.dbg	line,	"main.c", 34; put_string("Halt: SGX hardware not found", 2, 13);
 7894                        		__ld.wi		__const1+0
         0D:DB42  62         			cla
         0D:DB43  A0 60      			ldy.h	#__const1+0
 7895                        		__st.wmq	_bp
         0D:DB45  85 EC      			sta.l	_bp
         0D:DB47  84 ED      			sty.h	_bp
 7896                        		__st.umiq	2, _dil
         0D:DB49  A9 02      			lda.l	#2
         0D:DB4B  85 F0      			sta	_dil
 7897                        		__st.umiq	13, _dih
         0D:DB4D  A9 0D      			lda.l	#13
         0D:DB4F  85 F1      			sta	_dih
 7898                        		__call		_put_string.3
         0D:DB51  20 68 E6   			call	_put_string.3
 7899                        	
 7900                        		.dbg	line,	"main.c", 36; for(;;)
 7901    0D:DB54             	.LL310	.alias		.LL312
 7902    0D:DB54             	.LL311	.alias		.LL312
 7903    0D:DB54             	.LL312:
 7904                        	
 7905                        		.dbg	line,	"main.c", 37; {
 7906                        	
 7907                        		.dbg	line,	"main.c", 38; // INFINITE LOOP //
 7908                        	
 7909                        		.dbg	line,	"main.c", 39; }
 7910                        		__bra		.LL312
         0D:DB54  80 FE      			bra	.LL312
 7911    0D:DB56             	.LL313:
 7912                        	
 7913                        		.dbg	line,	"main.c", 40; }
 7914                        	
 7915                        		.dbg	line,	"main.c", 45; init_VARIABLES();
 7916    0D:DB56             	.LL309:
 7917                        		__call		_init_VARIABLES
         0D:DB56  20 13 FF   			call	_init_VARIABLES
 7918                        	
 7919                        		.dbg	line,	"main.c", 48; init_PLAYER();
 7920                        		__call		_init_PLAYER
         0D:DB59  20 09 FF   			call	_init_PLAYER
 7921                        	
 7922                        		.dbg	line,	"main.c", 53; //**************************************************************************************//
 7923                        	
 7924                        		.dbg	line,	"main.c", 54; //                                                                                      //
 7925                        	
 7926                        		.dbg	line,	"main.c", 55; //                                      TITLE                                           //
 7927                        	
 7928                        		.dbg	line,	"main.c", 56; //                                                                                      //
 7929                        	
 7930                        		.dbg	line,	"main.c", 57; //**************************************************************************************//
 7931                        	
 7932                        		.dbg	line,	"main.c", 58; for(;;)
 7933    0D:DB5C             	.LL314:
 7934    0D:DB5C             	.LL315:
 7935    0D:DB5C             	.LL316:
 7936                        	
 7937                        		.dbg	line,	"main.c", 59; {
 7938                        	
 7939                        		.dbg	line,	"main.c", 61; if(sequence_id == SEQUENCE_TITLE)
 7940                        		__not.um	_sequence_id
         0D:DB5C  AD 0B 23   			lda	_sequence_id
         0D:DB5F  18         			clc
         0D:DB60  D0 01      			bne	!+
         0D:DB62  38         			sec
         0D:DB63             	!:
 7941                        		__bfalse	.LL318
         0D:DB63  90 02      			bcc	.LL318
 7942                        	
 7943                        		.dbg	line,	"main.c", 62; {
 7944                        	
 7945                        		.dbg	line,	"main.c", 64; }
 7946                        	
 7947                        		.dbg	line,	"main.c", 67; else if(sequence_id == SEQUENCE_GAME)
 7948                        		__bra		.LL319
         0D:DB65  80 F5      			bra	.LL319
 7949    0D:DB67             	.LL318:
 7950                        		__ld.umq	_sequence_id
         0D:DB67  AD 0B 23   			lda	_sequence_id
 7951                        		__equ_b.uiq	2
         0D:DB6A  C9 02      			cmp	#2
         0D:DB6C  F0 01      			beq	!+
         0D:DB6E  18         			clc
         0D:DB6F             	!:
 7952                        		__bfalse	.LL320
         0D:DB6F  90 EB      			bcc	.LL320
 7953                        	
 7954                        		.dbg	line,	"main.c", 68; {
 7955                        	
 7956                        		.dbg	line,	"main.c", 69; // LOADING LOGO SCREEN //
 7957                        	
 7958                        		.dbg	line,	"main.c", 70; if(sequence_loaded == FALSE)
 7959                        		__not.um	_sequence_loaded
         0D:DB71  AD 0C 23   			lda	_sequence_loaded
         0D:DB74  18         			clc
         0D:DB75  D0 01      			bne	!+
         0D:DB77  38         			sec
         0D:DB78             	!:
 7960                        		__bfalse	.LL321
         0D:DB78  90 0A      			bcc	.LL321
 7961                        	
 7962                        		.dbg	line,	"main.c", 71; {
 7963                        	
 7964                        		.dbg	line,	"main.c", 72; init_LEVEL();
 7965                        		__call		_init_LEVEL
         0D:DB7A  20 FF FE   			call	_init_LEVEL
 7966                        	
 7967                        		.dbg	line,	"main.c", 74; sequence_loaded = TRUE;
 7968                        		__st.umiq	1, _sequence_loaded
         0D:DB7D  A9 01      			lda.l	#1
         0D:DB7F  8D 0C 23   			sta	_sequence_loaded
 7969                        	
 7970                        		.dbg	line,	"main.c", 75; }
 7971                        	
 7972                        		.dbg	line,	"main.c", 78; else
 7973                        		__bra		.LL322
         0D:DB82  80 D8      			bra	.LL322
 7974    0D:DB84             	.LL321:
 7975                        	
 7976                        		.dbg	line,	"main.c", 79; {
 7977                        	
 7978                        		.dbg	line,	"main.c", 80; if(level_id == 1)
 7979                        		__ld.umq	_level_id
         0D:DB84  AD 0D 23   			lda	_level_id
 7980                        		__equ_b.uiq	1
         0D:DB87  C9 01      			cmp	#1
         0D:DB89  F0 01      			beq	!+
         0D:DB8B  18         			clc
         0D:DB8C             	!:
 7981                        		__bfalse	.LL323
         0D:DB8C  90 14      			bcc	.LL323
 7982                        	
 7983                        		.dbg	line,	"main.c", 81; {
 7984                        	
 7985                        		.dbg	line,	"main.c", 82; vsync();
 7986                        		__call		_vsync
         0D:DB8E  20 09 E3   			call	_vsync
 7987                        	
 7988                        		.dbg	line,	"main.c", 84; update_PLAYER();
 7989                        		__call		_update_PLAYER
         0D:DB91  20 F5 FE   			call	_update_PLAYER
 7990                        	
 7991                        		.dbg	line,	"main.c", 85; //put_number(player_state,1,0,0);
 7992                        	
 7993                        		.dbg	line,	"main.c", 86; //put_number(player_pos_y,3,0,1);
 7994                        	
 7995                        		.dbg	line,	"main.c", 87; //put_number(sgx_map_pxl_y,3,0,2);
 7996                        	
 7997                        		.dbg	line,	"main.c", 90; joypad_DIR();
 7998                        		__call		_joypad_DIR
         0D:DB94  20 EB FE   			call	_joypad_DIR
 7999                        	
 8000                        		.dbg	line,	"main.c", 91; joypad_BUTTONS();
 8001                        		__call		_joypad_BUTTONS
         0D:DB97  20 E1 FE   			call	_joypad_BUTTONS
 8002                        	
 8003                        		.dbg	line,	"main.c", 93; satb_update();
 8004                        		__call		_satb_update
         0D:DB9A  20 1D FF   			call	_satb_update
 8005                        	
 8006                        		.dbg	line,	"main.c", 94; scroll_BG();
 8007                        		__call		_scroll_BG
         0D:DB9D  20 D7 FE   			call	_scroll_BG
 8008                        	
 8009                        		.dbg	line,	"main.c", 95; }
 8010                        	
 8011                        		.dbg	line,	"main.c", 97; else if(level_id == 2)
 8012                        		__bra		.LL324
         0D:DBA0  80 BA      			bra	.LL324
 8013    0D:DBA2             	.LL323:
 8014                        		__ld.umq	_level_id
         0D:DBA2  AD 0D 23   			lda	_level_id
 8015                        		__equ_b.uiq	2
         0D:DBA5  C9 02      			cmp	#2
         0D:DBA7  F0 01      			beq	!+
         0D:DBA9  18         			clc
         0D:DBAA             	!:
 8016                        		__bfalse	.LL325
         0D:DBAA  90 02      			bcc	.LL325
 8017                        	
 8018                        		.dbg	line,	"main.c", 98; {
 8019                        	
 8020                        		.dbg	line,	"main.c", 99; //sequence_LV2();
 8021                        	
 8022                        		.dbg	line,	"main.c", 100; }
 8023                        	
 8024                        		.dbg	line,	"main.c", 102; else if(level_id == 3)
 8025                        		__bra		.LL326
         0D:DBAC  80 AE      			bra	.LL326
 8026    0D:DBAE             	.LL325:
 8027                        		__ld.umq	_level_id
         0D:DBAE  AD 0D 23   			lda	_level_id
 8028                        		__equ_b.uiq	3
         0D:DBB1  C9 03      			cmp	#3
         0D:DBB3  F0 01      			beq	!+
         0D:DBB5  18         			clc
         0D:DBB6             	!:
 8029                        		__bfalse	.LL327
         0D:DBB6  90 02      			bcc	.LL327
 8030                        	
 8031                        		.dbg	line,	"main.c", 103; {
 8032                        	
 8033                        		.dbg	line,	"main.c", 104; //sequence_LV3();
 8034                        	
 8035                        		.dbg	line,	"main.c", 105; }
 8036                        	
 8037                        		.dbg	line,	"main.c", 107; else if(level_id == 4)
 8038                        		__bra		.LL328
         0D:DBB8  80 A2      			bra	.LL328
 8039    0D:DBBA             	.LL327:
 8040                        		__ld.umq	_level_id
         0D:DBBA  AD 0D 23   			lda	_level_id
 8041                        		__equ_b.uiq	4
         0D:DBBD  C9 04      			cmp	#4
         0D:DBBF  F0 01      			beq	!+
         0D:DBC1  18         			clc
         0D:DBC2             	!:
 8042                        		__bfalse	.LL329
         0D:DBC2  90 02      			bcc	.LL329
 8043                        	
 8044                        		.dbg	line,	"main.c", 108; {
 8045                        	
 8046                        		.dbg	line,	"main.c", 109; //sequence_LV4();
 8047                        	
 8048                        		.dbg	line,	"main.c", 110; }
 8049                        	
 8050                        		.dbg	line,	"main.c", 112; else if(level_id == 5)
 8051                        		__bra		.LL330
         0D:DBC4  80 96      			bra	.LL330
 8052    0D:DBC6             	.LL329:
 8053                        		__ld.umq	_level_id
         0D:DBC6  AD 0D 23   			lda	_level_id
 8054                        		__equ_b.uiq	5
         0D:DBC9  C9 05      			cmp	#5
         0D:DBCB  F0 01      			beq	!+
         0D:DBCD  18         			clc
         0D:DBCE             	!:
 8055                        		__bfalse	.LL331
         0D:DBCE  90 8C      			bcc	.LL331
 8056                        	
 8057                        		.dbg	line,	"main.c", 113; {
 8058                        	
 8059                        		.dbg	line,	"main.c", 114; //sequence_LV5();
 8060                        	
 8061                        		.dbg	line,	"main.c", 115; }
 8062                        	
 8063                        		.dbg	line,	"main.c", 116; }
 8064    0D:DBD0             	.LL331	.alias		.LL316
 8065    0D:DBD0             	.LL330	.alias		.LL316
 8066    0D:DBD0             	.LL328	.alias		.LL316
 8067    0D:DBD0             	.LL326	.alias		.LL316
 8068    0D:DBD0             	.LL324	.alias		.LL316
 8069    0D:DBD0             	.LL322	.alias		.LL316
 8070                        	
 8071                        		.dbg	line,	"main.c", 117; }
 8072                        	
 8073                        		.dbg	line,	"main.c", 118; }
 8074    0D:DBD0             	.LL320	.alias		.LL316
 8075    0D:DBD0             	.LL319	.alias		.LL316
 8076                        		__bra		.LL316
         0D:DBD0  80 8A      			bra	.LL316
 8077    0D:DBD2             	.LL317:
 8078                        	
 8079                        		.dbg	line,	"main.c", 121; }
 8080    0D:DBD2             	.LL308:
 8081                        		__return	1
         0D:DBD2  AA         			tax
         0D:DBD3  4C EF FF   			jmp	leave_proc
 8082                        		.dbg	clear
 8083                        		.endp
 8084                        		.pceas
 8085                        	
 8086                        		.dbg	clear
 8087               6000     		.rodata
 8088    01:6000             	__const1:
 8089    01:6000  48 61 6C 74			db	'H','a','l','t',':',' ','S','G'
         01:6004  3A 20 53 47 
 8090    01:6008  58 20 68 61			db	'X',' ','h','a','r','d','w','a'
         01:600C  72 64 77 61 
 8091    01:6010  72 65 20 6E			db	'r','e',' ','n','o','t',' ','f'
         01:6014  6F 74 20 66 
 8092    01:6018  6F 75 6E 64			db	'o','u','n','d',$00
         01:601C  00          
 8093    01:601D             	_TABLE_OBJECTS_TYPE_LV1:
 8094    01:601D  01         			db	1
 8095    01:601E  01         			db	1
 8096    01:601F  01         			db	1
 8097    01:6020  01         			db	1
 8098    01:6021  01         			db	1
 8099    01:6022  01         			db	1
 8100    01:6023  01         			db	1
 8101    01:6024  02         			db	2
 8102    01:6025  01         			db	1
 8103    01:6026  01         			db	1
 8104    01:6027  01         			db	1
 8105    01:6028  01         			db	1
 8106    01:6029  01         			db	1
 8107    01:602A  01         			db	1
 8108    01:602B  01         			db	1
 8109    01:602C  01         			db	1
 8110    01:602D  01         			db	1
 8111    01:602E  03         			db	3
 8112    01:602F  03         			db	3
 8113    01:6030  01         			db	1
 8114    01:6031  01         			db	1
 8115    01:6032  01         			db	1
 8116    01:6033  01         			db	1
 8117    01:6034  01         			db	1
 8118    01:6035  01         			db	1
 8119    01:6036             	_TABLE_OBJECTS_X_POS_REF_LV1:
 8120    01:6036  90 06      			dw	1680
 8121    01:6038  00 05      			dw	1280
 8122    01:603A  C0 05      			dw	1472
 8123    01:603C  A0 05      			dw	1440
 8124    01:603E  90 04      			dw	1168
 8125    01:6040  B0 04      			dw	1200
 8126    01:6042  C0 03      			dw	960
 8127    01:6044  D8 03      			dw	984
 8128    01:6046  50 05      			dw	1360
 8129    01:6048  70 05      			dw	1392
 8130    01:604A  10 06      			dw	1552
 8131    01:604C  90 06      			dw	1680
 8132    01:604E  B0 06      			dw	1712
 8133    01:6050  D0 06      			dw	1744
 8134    01:6052  E0 04      			dw	1248
 8135    01:6054  00 05      			dw	1280
 8136    01:6056  90 04      			dw	1168
 8137    01:6058  30 04      			dw	1072
 8138    01:605A  30 03      			dw	816
 8139    01:605C  10 04      			dw	1040
 8140    01:605E  80 02      			dw	640
 8141    01:6060  A0 02      			dw	672
 8142    01:6062  50 01      			dw	336
 8143    01:6064  70 01      			dw	368
 8144    01:6066  A0 01      			dw	416
 8145    01:6068             	_TABLE_OBJECTS_Y_POS_REF_LV1:
 8146    01:6068  80 01      			dw	384
 8147    01:606A  A0 01      			dw	416
 8148    01:606C  E0 01      			dw	480
 8149    01:606E  F0 01      			dw	496
 8150    01:6070  30 02      			dw	560
 8151    01:6072  30 02      			dw	560
 8152    01:6074  50 02      			dw	592
 8153    01:6076  50 02      			dw	592
 8154    01:6078  50 02      			dw	592
 8155    01:607A  50 02      			dw	592
 8156    01:607C  C0 02      			dw	704
 8157    01:607E  D0 02      			dw	720
 8158    01:6080  D0 02      			dw	720
 8159    01:6082  D0 02      			dw	720
 8160    01:6084  E0 02      			dw	736
 8161    01:6086  E0 02      			dw	736
 8162    01:6088  F0 02      			dw	752
 8163    01:608A  40 03      			dw	832
 8164    01:608C  50 03      			dw	848
 8165    01:608E  50 03      			dw	848
 8166    01:6090  70 03      			dw	880
 8167    01:6092  70 03      			dw	880
 8168    01:6094  80 03      			dw	896
 8169    01:6096  80 03      			dw	896
 8170    01:6098  80 03      			dw	896
 8171    01:609A             	_TABLE_PLAYER_JUMP_V:
 8172    01:609A  FC         			db	-4
 8173    01:609B  FB         			db	-5
 8174    01:609C  F6         			db	-10
 8175    01:609D  FC         			db	-4
 8176    01:609E  FC         			db	-4
 8177    01:609F  F9         			db	-7
 8178    01:60A0  FA         			db	-6
 8179    01:60A1  FD         			db	-3
 8180    01:60A2  FB         			db	-5
 8181    01:60A3  FE         			db	-2
 8182    01:60A4  FC         			db	-4
 8183    01:60A5  FF         			db	-1
 8184    01:60A6  FF         			db	-1
 8185    01:60A7  FF         			db	-1
 8186    01:60A8  FF         			db	-1
 8187    01:60A9  00         			db	0
 8188    01:60AA  00         			db	0
 8189    01:60AB  00         			db	0
 8190    01:60AC  00         			db	0
 8191    01:60AD  01         			db	1
 8192    01:60AE  01         			db	1
 8193    01:60AF  01         			db	1
 8194    01:60B0  01         			db	1
 8195    01:60B1  04         			db	4
 8196    01:60B2  02         			db	2
 8197    01:60B3  05         			db	5
 8198    01:60B4  03         			db	3
 8199    01:60B5  06         			db	6
 8200    01:60B6  07         			db	7
 8201    01:60B7  04         			db	4
 8202    01:60B8  04         			db	4
 8203    01:60B9  0A         			db	10
 8204    01:60BA  04         			db	4
 8205    01:60BB  04         			db	4
 8206    01:60BC  05         			db	5
 8207    01:60BD             	_TABLE_PLAYER_FALL:
 8208    01:60BD  00         			db	0
 8209    01:60BE  00         			db	0
 8210    01:60BF  00         			db	0
 8211    01:60C0  00         			db	0
 8212    01:60C1  01         			db	1
 8213    01:60C2  01         			db	1
 8214    01:60C3  01         			db	1
 8215    01:60C4  01         			db	1
 8216    01:60C5  02         			db	2
 8217    01:60C6  02         			db	2
 8218    01:60C7  02         			db	2
 8219    01:60C8  02         			db	2
 8220    01:60C9  03         			db	3
 8221    01:60CA  03         			db	3
 8222    01:60CB  03         			db	3
 8223    01:60CC  04         			db	4
 8224    01:60CD  04         			db	4
 8225    01:60CE  04         			db	4
 8226    01:60CF  04         			db	4
 8227    01:60D0  04         			db	4
 8228    01:60D1  05         			db	5
 8229    01:60D2             	_TABLE_PLAYER_JUMP_LADDER:
 8230    01:60D2  FC         			db	-4
 8231    01:60D3  FC         			db	-4
 8232    01:60D4  FD         			db	-3
 8233    01:60D5  FD         			db	-3
 8234    01:60D6  FD         			db	-3
 8235    01:60D7  FE         			db	-2
 8236    01:60D8  FE         			db	-2
 8237    01:60D9  FE         			db	-2
 8238    01:60DA  FF         			db	-1
 8239    01:60DB  FF         			db	-1
 8240    01:60DC  FF         			db	-1
 8241    01:60DD  FF         			db	-1
 8242    01:60DE  FF         			db	-1
 8243    01:60DF  00         			db	0
 8244    01:60E0  00         			db	0
 8245    01:60E1  00         			db	0
 8246    01:60E2  00         			db	0
 8247    01:60E3  01         			db	1
 8248    01:60E4  01         			db	1
 8249    01:60E5  01         			db	1
 8250    01:60E6  01         			db	1
 8251    01:60E7  01         			db	1
 8252    01:60E8  02         			db	2
 8253    01:60E9  02         			db	2
 8254    01:60EA  02         			db	2
 8255    01:60EB  03         			db	3
 8256    01:60EC  03         			db	3
 8257    01:60ED  03         			db	3
 8258    01:60EE  04         			db	4
 8259    01:60EF  04         			db	4
 8260                        	
 8261               230B     		.bss
 8262    F8:230B             	_sequence_id:
 8263    F8:230B             			ds	1
 8264    F8:230C             	_sequence_loaded:
 8265    F8:230C             			ds	1
 8266    F8:230D             	_level_id:
 8267    F8:230D             			ds	1
 8268    F8:230E             	_player_id:
 8269    F8:230E             			ds	1
 8270    F8:230F             	_player_state:
 8271    F8:230F             			ds	1
 8272    F8:2310             	_player_axis:
 8273    F8:2310             			ds	1
 8274    F8:2311             	_player_previous_axis:
 8275    F8:2311             			ds	1
 8276    F8:2312             	_player_counter_anim:
 8277    F8:2312             			ds	1
 8278    F8:2313             	_player_index_jump:
 8279    F8:2313             			ds	1
 8280    F8:2314             	_player_index_fall:
 8281    F8:2314             			ds	1
 8282    F8:2315             	_jump_ladder:
 8283    F8:2315             			ds	1
 8284    F8:2316             	_jump_max_index:
 8285    F8:2316             			ds	1
 8286    F8:2317             	_objects_max:
 8287    F8:2317             			ds	1
 8288    F8:2318             	_player_pos_x:
 8289    F8:2318             			ds	2
 8290    F8:231A             	_player_pos_y:
 8291    F8:231A             			ds	2
 8292    F8:231C             	_camera_max_y_position:
 8293    F8:231C             			ds	2
 8294    F8:231E             	_list_objects_type:
 8295    F8:231E             			ds	50
 8296    F8:2350             	_list_objects_state:
 8297    F8:2350             			ds	50
 8298    F8:2382             	_list_objects_x_pos:
 8299    F8:2382             			ds	50
 8300    F8:23B4             	_list_objects_y_pos:
 8301    F8:23B4             			ds	50
 8302    F8:23E6             	_list_objects_x_pos_ref:
 8303    F8:23E6             			ds	50
 8304    F8:2418             	_list_objects_y_pos_ref:
 8305    F8:2418             			ds	50
 8306    F8:244A             	_list_objects_energy:
 8307    F8:244A             			ds	50
 8308    F8:247C             	_ptr_objects_pos_x_ref:
 8309    F8:247C             			ds	2
 8310    F8:247E             	_ptr_objects_pos_y_ref:
 8311    F8:247E             			ds	2
 8312                        	
 8313                        	
 8314                        	;0 error(s) in compilation
 8315                        	;	literal pool:29
 8316                        	;	constant pool:211
 8317                        	;	global pool:393
 8318                        	;	Macro pool:225
 8319    F8:2480             	leaf_loc:
 8320    F8:2480             			ds	4
 8321    F8:2484             	__check_TILE_DEPTH_end:
 8322    F8:2484             	__check_BG_end:
 8323    F8:2484             	__recenter_CAMERA_end:
 8324                        	
 8325    F8:2484             	__bss_init:
 8326                        	
 8327    F8:2484             	__heap_start:
                             #[2]   "..\..\..\include\hucc\hucc-final.asm"
    1                        	; ***************************************************************************
    2                        	; ***************************************************************************
    3                        	;
    4                        	; hucc-final.asm
    5                        	;
    6                        	; PCEAS auto-includes this file at the end of every pass in HuCC or SDCC.
    7                        	;
    8                        	; Copyright John Brandwood 2024.
    9                        	;
   10                        	; Distributed under the Boost Software License, Version 1.0.
   11                        	; (See accompanying file LICENSE_1_0.txt or copy at
   12                        	;  http://www.boost.org/LICENSE_1_0.txt)
   13                        	;
   14                        	; ***************************************************************************
   15                        	; ***************************************************************************
   16                        	;
   17                        	; This is used to select which assembly-language library files to include in
   18                        	; a HuCC project, using labels defined in the compiler's header files.
   19                        	;
   20                        	; ***************************************************************************
   21                        	; ***************************************************************************
   22                        	
   23                        			; Allow projects to customize what is included at the end
   24                        			; of a pass without replacing the entire "hucc-final.asm".
   25                        	
   26               E309     			.code
   27               0000     			.bank	CORE_BANK
   28               E309     			.page	CORE_PAGE
   29                        	
                             #[3]   "..\..\..\include\hucc\hucc-final-extra.asm"
   30                        			include	"hucc-final-extra.asm"
    1                        	; ***************************************************************************
    2                        	; ***************************************************************************
    3                        	;
    4                        	; hucc-final-extra.asm
    5                        	;
    6                        	; hucc-final.asm includes this file at the end of every pass in HuCC or SDCC.
    7                        	;
    8                        	; Copyright John Brandwood 2024.
    9                        	;
   10                        	; Distributed under the Boost Software License, Version 1.0.
   11                        	; (See accompanying file LICENSE_1_0.txt or copy at
   12                        	;  http://www.boost.org/LICENSE_1_0.txt)
   13                        	;
   14                        	; ***************************************************************************
   15                        	; ***************************************************************************
   16                        	;
   17                        	; This is used to select which assembly-language library files to include in
   18                        	; a HuCC project, using labels defined in the compiler's header files.
   19                        	;
   20                        	; ***************************************************************************
   21                        	; ***************************************************************************
                             #[2]   "..\..\..\include\hucc\hucc-final.asm"
   31                        	
   32                        			; Libraries required for basic functionality.
   33                        	
   34               E309     			.code
   35               0000     			.bank	CORE_BANK
   36               E309     			.page	CORE_PAGE
   37                        	
                             #[3]   "..\..\..\include\hucc\common.asm"
   38                        			include	"common.asm"		; Common helpers.
    1                        	; ***************************************************************************
    2                        	; ***************************************************************************
    3                        	;
    4                        	; common.asm
    5                        	;
    6                        	; Small, generic, PCE subroutines that are commonly useful when developing.
    7                        	;
    8                        	; These should be located in permanently-accessible memory!
    9                        	;
   10                        	; Copyright John Brandwood 2021-2024.
   11                        	;
   12                        	; Distributed under the Boost Software License, Version 1.0.
   13                        	; (See accompanying file LICENSE_1_0.txt or copy at
   14                        	;  http://www.boost.org/LICENSE_1_0.txt)
   15                        	;
   16                        	; ***************************************************************************
   17                        	; ***************************************************************************
   18                        	
   19                        	
   20                        	
   21                        	; ***************************************************************************
   22                        	; ***************************************************************************
   23                        	;
   24                        	; Wait for the next VBLANK IRQ.
   25                        	;
   26                        	
   27    00:E309  AD 41 22   	wait_vsync:	lda	irq_cnt			; System Card variable, changed
   28    00:E30C  CD 41 22   	.loop:		cmp	irq_cnt			; every VBLANK interrupt.
   29    00:E30F  F0 FB      			beq	.loop
   30               0001     		.ifdef	HUCC
   31    00:E311  8D EB 22   			sta	old_cnt			; Remember the frame count.
   32                        		.endif
   33    00:E314  60         			rts
   34                        	
   35                        	
   36                        	
   37                        	; ***************************************************************************
   38                        	; ***************************************************************************
   39                        	;
   40                        	; Delay for the next Y VBLANK IRQs.
   41                        	;
   42                        	
   43               0001     		.ifdef	HUCC
   44    00:E315             	_vsync		.alias	wait_vsync
   45                        	
   46    00:E315  AD 41 22   	_vsync.1:	lda	irq_cnt			; HuCC's vsync(n) was defined
   47    00:E318  38         			sec				; as frames from the previous
   48    00:E319  ED EB 22   			sbc	old_cnt			; vsync() call, 1 to 255.
   49    00:E31C  38         			sec
   50    00:E31D  E5 F8      			sbc	<_al
   51    00:E31F  90 02      			bcc	!+
   52    00:E321  A9 FF      			lda	#$FF
   53    00:E323  49 FF      	!:		eor	#$FF
   54    00:E325  1A         			inc	a
   55    00:E326  A8         			tay
   56                        		.endif
   57                        	
   58    00:E327  44 E0      	wait_nvsync:	bsr	wait_vsync		; # of VBLANK IRQs to wait in
   59    00:E329  88         			dey				; the Y register.
   60    00:E32A  D0 FB      			bne	wait_nvsync
   61    00:E32C  60         			rts
   62                        	
   63                        	
   64                        	
   65               0000     		.ifndef	HUCC
  101                        		.endif
  102                        	
  103                        	
  104                        	
  105                        	; ***************************************************************************
  106                        	; ***************************************************************************
  107                        	;
  108                        	; Map the _bp data far-pointer into MPR3 (& MPR4).
  109                        	;
  110                        	; Because the 16KB RAM region at $2000-$5FFF is composed of two separate
  111                        	; banks, with the 2nd bank having no specific relation to the 1st, there
  112                        	; is no way to deal with a bank-increment, so do not map that region.
  113                        	;
  114                        	; N.B. Library code relies on this preserving X and V!
  115                        	;
  116                        	
  117    00:E32D  98         	map_bp_to_mpr3:	tya				; Put bank into MPR3.
  118    00:E32E  F0 0A      			beq	!+
  119    00:E330  53 08      			tam3
  120    00:E332  A5 ED      			lda.h	<_bp			; Do not remap a ptr to RAM,
  121    00:E334  29 1F      			and	#$1F			; Remap ptr to MPR3.
  122    00:E336  09 60      			ora	#$60
  123    00:E338  85 ED      			sta.h	<_bp
  124    00:E33A  60         	!:		rts
  125                        	
  126    00:E33B  98         	map_bp_to_mpr34:tya				; Put bank into MPR3.
  127    00:E33C  F0 0D      			beq	!+
  128    00:E33E  53 08      			tam3
  129    00:E340  1A         			inc	a			; Put next into MPR4.
  130    00:E341  53 10      			tam4
  131    00:E343  A5 ED      			lda.h	<_bp			; Do not remap a ptr to RAM,
  132    00:E345  29 1F      			and	#$1F			; Remap ptr to MPR3.
  133    00:E347  09 60      			ora	#$60
  134    00:E349  85 ED      			sta.h	<_bp
  135    00:E34B  60         	!:		rts
  136                        	
  137                        	
  138                        	
  139                        	; ***************************************************************************
  140                        	; ***************************************************************************
  141                        	;
  142                        	; Increment the hi-byte of _bp and change TMA3 if necessary.
  143                        	;
  144                        	; N.B. Library code relies on this preserving A,X,Y and V!
  145                        	;
  146                        	
  147    00:E34C  E6 ED      	inc.h_bp_mpr3:	inc.h	<_bp			; Increment hi-byte of _bp.
  148    00:E34E  10 0B      			bpl	!+			; OK if within MPR0-MPR3.
  149    00:E350  48         			pha				; Increment the bank in MPR3,
  150    00:E351  43 08      			tma3				; usually when pointer moves
  151    00:E353  1A         			inc	a			; from $7FFF -> $8000.
  152    00:E354  53 08      			tam3
  153    00:E356  A9 60      			lda	#$60
  154    00:E358  85 ED      			sta.h	<_bp
  155    00:E35A  68         			pla
  156    00:E35B  60         	!:		rts
  157                        	
  158                        	
  159                        	
  160                        	; ***************************************************************************
  161                        	; ***************************************************************************
  162                        	;
  163                        	; Increment the hi-byte of _bp and change TMA3 and TMA4 if necessary.
  164                        	;
  165                        	; N.B. Library code relies on this preserving A,X,Y and V!
  166                        	;
  167                        	
  168    00:E35C  E6 ED      	inc.h_bp_mpr34:	inc.h	<_bp			; Increment hi-byte of _bp.
  169    00:E35E  10 0D      			bpl	!+			; OK if within MPR0-MPR3.
  170    00:E360  48         			pha				; Increment the bank in MPR3,
  171    00:E361  43 10      			tma4				; usually when pointer moves
  172    00:E363  53 08      			tam3				; from $7FFF -> $8000.
  173    00:E365  1A         			inc	a
  174    00:E366  53 10      			tam4
  175    00:E368  A9 60      			lda	#$60
  176    00:E36A  85 ED      			sta.h	<_bp
  177    00:E36C  68         			pla
  178    00:E36D  60         	!:		rts
  179                        	
  180                        	
  181                        	
  182                        	; ***************************************************************************
  183                        	; ***************************************************************************
  184                        	;
  185                        	; Put the _di data pointer into the VDC's MARR or MAWR register.
  186                        	;
  187                        	; N.B. Library code relies on this preserving Y!
  188                        	;
  189                        	
  190               0001     		.if	SUPPORT_SGX
  191    00:E36E  A2 10      	sgx_di_to_marr:	ldx	#SGX_VDC_OFFSET		; Offset to SGX VDC.
  192    00:E370  F0         			db	$F0			; Turn "clx" into a "beq".
  193                        		.endif
  194                        	
  195    00:E371  82         	vdc_di_to_marr:	clx				; Offset to PCE VDC.
  196                        	
  197    00:E372  A9 01      	set_di_to_marr	lda	#VDC_MARR		; Set VDC or SGX destination
  198    00:E374  95 F7      			sta	<vdc_reg, x		; address.
  199    00:E376  9D 00 02   			sta	VDC_AR, x
  200    00:E379  80 09      			bra	!+
  201                        	
  202               0001     		.if	SUPPORT_SGX
  203    00:E37B  A2 10      	sgx_di_to_mawr:	ldx	#SGX_VDC_OFFSET		; Offset to SGX VDC.
  204    00:E37D  F0         			db	$F0			; Turn "clx" into a "beq".
  205                        		.endif
  206                        	
  207    00:E37E  82         	vdc_di_to_mawr:	clx				; Offset to PCE VDC.
  208                        	
  209    00:E37F             	set_di_to_mawr;	lda	#VDC_MAWR		; Set VDC or SGX destination
  210    00:E37F  74 F7      			stz	<vdc_reg, x		; address.
  211    00:E381  9E 00 02   			stz	VDC_AR, x
  212                        	
  213    00:E384  A5 F0      	!:		lda	<_di + 0
  214    00:E386  9D 02 02   			sta	VDC_DL, x
  215    00:E389  A5 F1      			lda	<_di + 1
  216    00:E38B  9D 03 02   			sta	VDC_DH, x
  217                        	
  218    00:E38E  A9 02      			lda	#VDC_VWR		; Select the VRR/VWR data
  219    00:E390  95 F7      			sta	<vdc_reg, x		; register.
  220    00:E392  9D 00 02   			sta	VDC_AR, x
  221    00:E395  60         			rts
  222                        	
  223                        	
  224                        	
  225                        	; ***************************************************************************
  226                        	; ***************************************************************************
  227                        	;
  228                        	; Increment the hi-byte of _di and change TMA4 if necessary.
  229                        	;
  230                        	
  231               0000     		.if	0				; Save memory, for now.
  250                        		.endif
  251                        	
  252                        	
  253                        	
  254                        	; ***************************************************************************
  255                        	; ***************************************************************************
  256                        	;
  257                        	; Far-call a function in another bank.
  258                        	;
  259                        	; This is a potential alternative procedure call trampoline that uses only 10
  260                        	; bytes of common memory per bank of procedures, instead of 10 bytes for each
  261                        	; individual procedure call, BUT it uses the X register as a procedure-index,
  262                        	; and it needs a table of addresses at the end of every procedure bank.
  263                        	;
  264                        	; To use this ...
  265                        	;
  266                        	;  ldx #procedure-index
  267                        	;  jsr far_call_nn
  268                        	;
  269                        	; The called .PROC routine must exit with "jmp leave_proc" and not "rts".
  270                        	;
  271                        	; leave_proc:	pla
  272                        	;		tam6
  273                        	;		tya
  274                        	;		rts
  275                        	;
  276                        	; N.B. This costs 21 cycles vs 18 for the .newproc trampoline code (when you
  277                        	;      exclude preserving YA in zero-page).
  278                        	;
  279                        	; N.B. This was written as an excerise, and definitely not for HuC!
  280                        	;
  281                        	
  282               0000     		.if	0
  295                        		.endif					; 21
                             #[2]   "..\..\..\include\hucc\hucc-final.asm"
                             #[3]   "..\..\..\include\hucc\vce.asm"
   39                        			include	"vce.asm"		; Useful VCE routines.
    1                        	; ***************************************************************************
    2                        	; ***************************************************************************
    3                        	;
    4                        	; vce.asm
    5                        	;
    6                        	; Useful routines for operating the HuC6260 Video Color Encoder
    7                        	;
    8                        	; These should be located in permanently-accessible memory!
    9                        	;
   10                        	; Copyright John Brandwood 2021-2025.
   11                        	;
   12                        	; Distributed under the Boost Software License, Version 1.0.
   13                        	; (See accompanying file LICENSE_1_0.txt or copy at
   14                        	;  http://www.boost.org/LICENSE_1_0.txt)
   15                        	;
   16                        	; ***************************************************************************
   17                        	; ***************************************************************************
   18                        	
   19                        	;
   20                        	; Configure Library ...
   21                        	;
   22                        	
   23               0000     		.ifndef VCE_SPLIT_CROSS
   25                        		.endif
   26                        	
   27                        	
   28                        	
   29                        	; ***************************************************************************
   30                        	; ***************************************************************************
   31                        	;
   32                        	; xfer_palettes - Update the VCE with the queued palettes changes.
   33                        	;
   34                        	; This is normally called in a developer's vsync_hook handler, but it can
   35                        	; be called manually as long as it will not also be called in an interrupt.
   36                        	;
   37                        	; The queued transfers are split into 32-byte chunks so that an HSYNC and/or
   38                        	; TIMER IRQ is not delayed for too long during the VBLANK.
   39                        	;
   40                        	
   41    00:E396  A9 80      	xfer_palettes:	lda	#$80			; Acquire color mutex to avoid
   42    00:E398  0C 84 24   			tsb	color_mutex		; conflict with a delayed VBL.
   43    00:E39B  30 5F      			bmi	.busy
   44                        	
   45    00:E39D  AC 85 24   			ldy	color_queue_r		; Are there any palette xfers
   46    00:E3A0  CC 86 24   			cpy	color_queue_w		; queued up?
   47    00:E3A3  F0 54      			beq	.exit
   48                        	
   49    00:E3A5  08         			php				; Enable interrupts so that an
   50    00:E3A6  58         			cli				; HSYNC or TIMER IRQ can occur.
   51                        	
   52    00:E3A7  43 08      			tma3				; Preserve MPR3 & MPR4 because
   53    00:E3A9  48         			pha				; this normally runs in the
   54    00:E3AA  43 10      			tma4				; VBLANK IRQ.
   55    00:E3AC  48         			pha
   56                        	
   57               0001     		.if	!CDROM
   58    00:E3AD  73 02 E4 86			tii	.tia_func, color_tia, 8 ; Copy TIA to RAM.
         00:E3B1  22 08 00    
   59                        		.endif
   60                        	
   61    00:E3B4  B9 87 24   	.next_item:	lda	color_index, y		; Get the next set of palettes
   62    00:E3B7  0A         			asl	a			; from the queue.
   63    00:E3B8  0A         			asl	a
   64    00:E3B9  0A         			asl	a
   65    00:E3BA  0A         			asl	a
   66    00:E3BB  8D 02 04   			sta	VCE_CTA + 0
   67    00:E3BE  62         			cla
   68    00:E3BF  2A         			rol	a
   69    00:E3C0  8D 03 04   			sta	VCE_CTA + 1
   70                        	
   71    00:E3C3  BE 8F 24   			ldx	color_count,y		; How many palettes to xfer?
   72                        	
   73    00:E3C6  B9 A7 24   			lda	color_bank, y		; Map data into MPR3 & MPR4.
   74    00:E3C9  53 08      			tam3
   75    00:E3CB  1A         			inc	a
   76    00:E3CC  53 10      			tam4
   77    00:E3CE  B9 9F 24   			lda	color_addr_h, y
   78    00:E3D1  8D 88 22   			sta	.ram_tia + 2
   79    00:E3D4  B9 97 24   			lda	color_addr_l, y
   80    00:E3D7  8D 87 22   	.palette_loop:	sta	.ram_tia + 1
   81                        	
   82               0000     		.if	CDROM
   84                        		.else
   85    00:E3DA  20 86 22   			jsr	.ram_tia		; Copy 32-bytes to the VCE.
   86                        		.endif
   87                        	
   88    00:E3DD  18         			clc				; Increment the data ptr to
   89    00:E3DE  69 20      			adc	#32			; the next 32-byte palette.
   90    00:E3E0  B0 1B      			bcs	.next_page
   91                        	
   92    00:E3E2  CA         	.next_palette:	dex				; Any palettes left to xfer?
   93    00:E3E3  D0 F2      			bne	.palette_loop
   94                        	
   95    00:E3E5  C8         			iny				; Increment the queue index.
   96    00:E3E6  98         			tya
   97    00:E3E7  29 07      			and	#7
   98    00:E3E9  A8         			tay
   99                        	
  100    00:E3EA  CC 86 24   			cpy	color_queue_w		; Any more items in the queue?
  101    00:E3ED  D0 C5      			bne	.next_item
  102    00:E3EF  8C 85 24   			sty	color_queue_r		; Signal the queue is empty.
  103                        	
  104    00:E3F2  68         			pla				; Restore MPR3 & MPR4.
  105    00:E3F3  53 10      			tam4
  106    00:E3F5  68         			pla
  107    00:E3F6  53 08      			tam3
  108                        	
  109    00:E3F8  28         			plp				; Restore interrupt state.
  110                        	
  111    00:E3F9  9C 84 24   	.exit:		stz	color_mutex		; Release color mutex.
  112                        	
  113    00:E3FC  60         	.busy:		rts
  114                        	
  115    00:E3FD  EE 88 22   	.next_page:	inc	.ram_tia + 2
  116    00:E400  80 E0      			bra	.next_palette
  117                        	
  118               0001     		.if	!CDROM
  119               2286     	.ram_tia	=	color_tia		; Use a TIA in RAM.
  120                        	
  121    00:E402  E3 00 00 04	.tia_func:	tia	0, VCE_CTW, 32
         00:E406  04 20 00    
  122    00:E409  60         			rts
  123                        		.endif	!CDROM
  124                        	
  125               2484     			.bss
  126                        	
  127    F8:2484             	color_mutex:	ds	1			; Mutex for VCE changes.
  128    F8:2485             	color_queue_r:	ds	1			; Ring buffer read index.
  129    F8:2486             	color_queue_w:	ds	1			; Ring buffer write index.
  130    F8:2487             	color_index:	ds	8			; Ring buffer - Palette index.
  131    F8:248F             	color_count:	ds	8			; Ring buffer - Palette count.
  132    F8:2497             	color_addr_l:	ds	8			; Ring buffer - Data Ptr (lo).
  133    F8:249F             	color_addr_h:	ds	8			; Ring buffer - Data Ptr (hi).
  134    F8:24A7             	color_bank:	ds	8			; Ring buffer - Data Ptr (bank).
  135                        	
  136               E40A     			.code
  137                        	
  138                        	
  139                        	
  140                        	; ***************************************************************************
  141                        	; ***************************************************************************
  142                        	;
  143                        	; load_palettes - Queue a set of palettes to upload to the VCE next VBLANK.
  144                        	;
  145                        	; Args: _al = Palette index (0..15 for BG, 16..31 for SPR).
  146                        	; Args: _ah = Palette count (1..32).
  147                        	; Args: _bp = Pointer to palette data.
  148                        	; Args:   Y = Bank to map into MPR3 & MPR4, or zero to leave unchanged.
  149                        	;
  150                        	; N.B. Y==0 is only useful if the palette data is permanently mapped!
  151                        	;
  152                        	
  153                        	load_palettes	.proc
  179                        			.endp
  180                        	
  181                        	
  182                        	
  183                        	; ***************************************************************************
  184                        	; ***************************************************************************
  185                        	;
  186                        	; clear_vce - Clear all 512 of the VCE's palette entries.
  187                        	;
  188                        	
  189    02:C133             	clear_vce	.proc
  190                        	
  191    02:C133  08         			php				; Disable interrupts to avoid
  192    02:C134  78         			sei				; VBLANK palette upload.
  193    02:C135  C2         			cly
  194    02:C136  9C 02 04   			stz	VCE_CTA+0		; Set VCE write address.
  195    02:C139  9C 03 04   			stz	VCE_CTA+1
  196    02:C13C  9C 04 04   	.loop:		stz	VCE_CTW+0		; Set lo-byte of color.
  197    02:C13F  9C 05 04   			stz	VCE_CTW+1		; Write 1 color value.
  198    02:C142  9C 04 04   			stz	VCE_CTW+0		; Set lo-byte of color.
  199    02:C145  9C 05 04   			stz	VCE_CTW+1		; Write 1 color value.
  200    02:C148  88         			dey
  201    02:C149  D0 F1      			bne	.loop
  202    02:C14B  28         			plp
  203                        	
  204                        			leave				; All done, phew!
         02:C14C  4C EF FF   			jmp	leave_proc
  205                        	
  206                        			.endp
  207                        	
  208               0001     		.ifdef	HUCC
  209    00:E40A             			.alias	_clear_palette		= clear_vce
  210                        		.endif
  211                        	
  212                        	
  213                        	
  214                        	; ***************************************************************************
  215                        	; ***************************************************************************
  216                        	;
  217                        	; read_palettes - Read palettes from the VCE into a buffer in RAM.
  218                        	;
  219                        	; Args: _al = Palette index (0..15 for BG, 16..31 for SPR).
  220                        	; Args: _ah = Palette count (1..32).
  221                        	; Args: _di = Pointer to palette data destination in RAM.
  222                        	;
  223                        	; The transfer is split into 32-byte chunks so that an HSYNC and/or TIMER
  224                        	; IRQ is not delayed for too long while executing.
  225                        	;
  226                        	
  227                        	read_palettes	.proc
  281                        			.endp
  282                        	
  283               0001     		.ifdef	HUCC
  284    00:E40A             			.alias	_read_palette.3		= read_palettes
  285                        		.endif
  286                        	
  287                        	
  288                        	
  289                        	vce_fade_funcs	.procgroup
  516                        			.endprocgroup
  517                        	
  518                        	
  519                        	
  520                        	; ***************************************************************************
  521                        	; ***************************************************************************
  522                        	;
  523                        	; cross_fade_to - Cross fade a palette in RAM towards a reference palette.
  524                        	;
  525                        	; Args: _al = Number of colors (1..256).
  526                        	; Args: _di = Pointer to faded palette destination in RAM.
  527                        	; Args: _bp = Pointer to reference palette data.
  528                        	; Args:   Y = Bank to map into MPR3 & MPR4, or zero to leave unchanged.
  529                        	;
  530                        	; N.B. Y==0 is only useful if the reference palette data is already mapped!
  531                        	;
  532                        	; N.B. This only updates the palette in RAM by 1 RGB step, so it will need
  533                        	;      to be called 7 times to guarantee that you've reached the target.
  534                        	;
  535                        	
  536                        	cross_fade_to	.proc
  658                        			.endp
                             #[2]   "..\..\..\include\hucc\hucc-final.asm"
                             #[3]   "..\..\..\include\hucc\vdc.asm"
   40                        			include	"vdc.asm"		; Useful VDC routines.
    1                        	; ***************************************************************************
    2                        	; ***************************************************************************
    3                        	;
    4                        	; vdc.asm
    5                        	;
    6                        	; Useful routines for operating the HuC6270 Video Display Controller.
    7                        	;
    8                        	; These should be located in permanently-accessible memory!
    9                        	;
   10                        	; Copyright John Brandwood 2021-2025.
   11                        	;
   12                        	; Distributed under the Boost Software License, Version 1.0.
   13                        	; (See accompanying file LICENSE_1_0.txt or copy at
   14                        	;  http://www.boost.org/LICENSE_1_0.txt)
   15                        	;
   16                        	; ***************************************************************************
   17                        	; ***************************************************************************
   18                        	
   19                        	;
   20                        	; Include dependancies ...
   21                        	;
   22                        	
   23                        			include "common.asm"		; Common helpers.
   24                        			include "vce.asm"		; Useful VCE routines.
   25                        	
   26                        	;
   27                        	; Choose how much to transfer to VRAM in a single chunk, normally 16-bytes.
   28                        	;
   29                        	; The cycle timings for a TIA-to-VRAM depend upon how the VDC's MWR CPU slots
   30                        	; line up to the CPU's writes, and how long the VDC has to halt the CPU while
   31                        	; it fetches the next scanline's sprite data.
   32                        	;
   33                        	; These cycle timings are for 0 sprites (best) and 16 sprites (worst) ...
   34                        	;
   35                        	; 32-byte TIA takes 270..364 cycles in 5MHz, 242..312 cycles in 7MHz. (8.44 cycles-per-byte best-case at 5MHz.)
   36                        	; 24-byte TIA takes 210..298 cycles in 5MHz, 186..256 cycles in 7MHz. (8.75 cycles-per-byte best-case at 5MHz.)
   37                        	; 16-byte TIA takes 142..234 cycles in 5MHz, 128..200 cycles in 7MHz. (8.88 cycles-per-byte best-case at 5MHz.)
   38                        	;
   39                        	; If a user wishes to be able to put RCR interrupts one-line-after-another,
   40                        	; then it is only safe to use 32-byte chunks if there are no TIMER or IRQ2
   41                        	; interrupts ... which is almost-impossible to rely on in library code!
   42                        	;
   43                        	
   44               0000     		.ifndef	VRAM_XFER_SIZE
   46                        		.endif
   47                        	
   48                        	;
   49                        	; Enable BG & SPR layers, and RCR interrupt.
   50                        	;
   51                        	
   52    00:E40A  A9 04      	set_rcron:	lda	#$04			; Enable RCR interrupt.
   53    00:E40C  80 0A      			bra	!+
   54                        	
   55    00:E40E  A9 80      	set_bgon:	lda	#$80			; Enable BG layer.
   56    00:E410  80 06      			bra	!+
   57                        	
   58    00:E412  A9 40      	set_spron:	lda	#$40			; Enable SPR layer.
   59    00:E414  80 02      			bra	!+
   60                        	
   61    00:E416  A9 C0      	set_dspon:	lda	#$C0			; Enable BG & SPR layers.
   62                        	
   63    00:E418  04 F3      	!:		tsb	<vdc_crl		; These take effect when
   64               0001     		.if	SUPPORT_SGX			; the next VBLANK occurs.
   65    00:E41A  04 03      			tsb	<sgx_crl
   66                        		.endif
   67    00:E41C  60         			rts
   68                        	
   69                        	;
   70                        	; Disable BG & SPR layers, and RCR interrupt.
   71                        	;
   72                        	
   73    00:E41D  A9 04      	set_rcroff:	lda	#$04			; Disable RCR interrupt.
   74    00:E41F  80 0A      			bra	!+
   75                        	
   76    00:E421  A9 80      	set_bgoff:	lda	#$80			; Disable BG layer.
   77    00:E423  80 06      			bra	!+
   78                        	
   79    00:E425  A9 40      	set_sproff:	lda	#$40			; Disable SPR layer.
   80    00:E427  80 02      			bra	!+
   81                        	
   82    00:E429  A9 C0      	set_dspoff:	lda	#$C0			; Disable BG & SPR layers.
   83                        	
   84    00:E42B  14 F3      	!:		trb	<vdc_crl		; These take effect when
   85               0001     		.if	SUPPORT_SGX			; the next VBLANK occurs.
   86    00:E42D  14 03      			trb	<sgx_crl
   87                        		.endif
   88    00:E42F  60         			rts
   89                        	
   90                        	
   91                        	
   92                        	; ***************************************************************************
   93                        	; ***************************************************************************
   94                        	;
   95                        	; Put the _di data pointer into the VDC's MARR or MAWR register.
   96                        	;
   97                        	; N.B. Library code relies on this preserving Y!
   98                        	;
   99                        	; Args: _di + 0 = BAT X coordinate.
  100                        	; Args: _di + 1 = BAT Y coordinate.
  101                        	;
  102                        	; Here because it relies on the "vdc_bat_width" that is defined in this file.
  103                        	;
  104                        	
  105               0001     		.if	SUPPORT_SGX
  106    00:E430  A2 10      	sgx_di_xy_marr:	ldx	#SGX_VDC_OFFSET		; Offset to SGX VDC.
  107    00:E432  F0         			db	$F0			; Turn "clx" into a "beq".
  108                        		.endif
  109                        	
  110    00:E433  82         	vdc_di_xy_marr:	clx				; Offset to PCE VDC.
  111                        	
  112    00:E434  62         	set_di_xy_mawr:	cla
  113    00:E435  3C AF 24   			bit	vdc_bat_width, x	; Set by set_bat_size().
  114    00:E438  30 08      			bmi	.w128
  115    00:E43A  70 03      			bvs	.w64
  116    00:E43C  46 F1      	.w32:		lsr.h	<_di
  117    00:E43E  6A         			ror	a
  118    00:E43F  46 F1      	.w64:		lsr.h	<_di
  119    00:E441  6A         			ror	a
  120    00:E442  46 F1      	.w128:		lsr.h	<_di
  121    00:E444  6A         			ror	a
  122    00:E445  05 F0      			ora.l	<_di
  123    00:E447  85 F0      			sta.l	<_di
  124    00:E449  4C 7F E3   			jmp	set_di_to_mawr		; In "common.asm".
  125                        	
  126                        	
  127                        	
  128    0D:DF7C             	vdc_clear_vram	.procgroup			; These routines share code!
  129                        	
  130                        	; ***************************************************************************
  131                        	; ***************************************************************************
  132                        	;
  133                        	; clear_vram_sgx - Clear all of VRAM in the SGX VDC.
  134                        	; clear_vram_vdc - Clear all of VRAM in the PCE VDC.
  135                        	;
  136                        	; Args: _ax = word value to write to the BAT.
  137                        	; Args: _bl = hi-byte of size of BAT (# of words).
  138                        	;
  139                        	
  140               0001     		.if	SUPPORT_SGX
  141    0D:DF7C             	clear_vram_sgx	.proc
  142                        	
  143    0D:DF7C  A2 10      			ldx	#SGX_VDC_OFFSET		; Offset to SGX VDC.
  144    0D:DF7E  F0         			db	$F0			; Turn "clx" into a "beq".
  145                        	
  146    0D:DF7F             			.ref	clear_vram_vdc		; Need clear_vram_vdc
  147                        			.endp
  148                        		.endif
  149                        	
  150    0D:DF7F             	clear_vram_vdc	.proc
  151                        	
  152    0D:DF7F  82         			clx				; Offset to PCE VDC.
  153                        	
  154    0D:DF80  20 C3 FE   	clear_vram_x:	call	clear_bat_x		; Clear the BAT.
  155                        	
  156    0D:DF83  A9 80      			lda	#$80			; Xvert hi-byte of # words
  157    0D:DF85  38         			sec				; in screen to loop count.
  158    0D:DF86  E5 FA      			sbc	<_bl
  159    0D:DF88  4A         			lsr	a
  160                        	
  161                        	;		cly				; Clear the rest of VRAM.
  162    0D:DF89  9E 02 02   			stz	VDC_DL, x
  163    0D:DF8C  9E 03 02   	.clr_loop:	stz	VDC_DH, x		; Seperate writes to minimize
  164    0D:DF8F  88         			dey				; VDC MWR penalty.
  165    0D:DF90  9E 03 02   			stz	VDC_DH, x
  166    0D:DF93  D0 F7      			bne	.clr_loop
  167    0D:DF95  3A         			dec	a
  168    0D:DF96  D0 F4      			bne	.clr_loop
  169                        	
  170                        			leave				; All done, phew!
         0D:DF98  4C EF FF   			jmp	leave_proc
  171                        	
  172                        			.endp
  173                        	
  174                        	
  175                        	
  176                        	; ***************************************************************************
  177                        	; ***************************************************************************
  178                        	;
  179                        	; clear_bat_sgx - Clear the BAT in the SGX VDC.
  180                        	; clear_bat_vdc - Clear the BAT in the PCE VDC.
  181                        	;
  182                        	; Args: _ax = word value to write to the BAT.
  183                        	; Args: _bl = hi-byte of size of BAT (# of words).
  184                        	;
  185                        	
  186               0001     		.if	SUPPORT_SGX
  187                        	clear_bat_sgx	.proc
  193                        			.endp
  194                        		.endif
  195                        	
  196    0D:DF9B             	clear_bat_vdc	.proc
  197                        	
  198    0D:DF9B  82         			clx				; Offset to PCE VDC.
  199                        	
  200    0D:DF9C             			.ref	clear_bat_x		; Need clear_bat_x
  201                        			.endp
  202                        	
  203    0D:DF9C             	clear_bat_x	.proc				; HuCC uses this entry point.
  204                        	
  205    0D:DF9C  64 F0      			stz	<_di + 0		; Set VDC or SGX destination
  206    0D:DF9E  64 F1      			stz	<_di + 1		; address.
  207    0D:DFA0  20 7F E3   			jsr	set_di_to_mawr
  208                        	
  209    0D:DFA3  A5 FA      			lda	<_bl			; Xvert hi-byte of # words
  210    0D:DFA5  4A         			lsr	a			; in screen to loop count.
  211                        	
  212    0D:DFA6  C2         			cly
  213    0D:DFA7  48         	.bat_loop:	pha
  214    0D:DFA8  A5 F8      			lda	<_ax + 0
  215    0D:DFAA  9D 02 02   			sta	VDC_DL, x
  216    0D:DFAD  A5 F9      			lda	<_ax + 1
  217    0D:DFAF  9D 03 02   	.bat_pair:	sta	VDC_DH, x		; Seperate writes to minimize
  218    0D:DFB2  88         			dey				; VDC MWR penalty.
  219    0D:DFB3  9D 03 02   			sta	VDC_DH, x
  220    0D:DFB6  D0 F7      			bne	.bat_pair
  221                        	
  222    0D:DFB8  68         			pla
  223    0D:DFB9  3A         			dec	a
  224    0D:DFBA  D0 EB      			bne	.bat_loop
  225                        	
  226                        			leave
         0D:DFBC  4C EF FF   			jmp	leave_proc
  227                        	
  228                        			.endp
  229                        	
  230                        			.endprocgroup
  231                        	
  232                        	;
  233                        	;
  234                        	;
  235                        	
  236    09:DF1B             	vdc_set_mode	.procgroup			; These routines share code!
  237                        	
  238                        	; ***************************************************************************
  239                        	; ***************************************************************************
  240                        	;
  241                        	; set_mode_sgx - Set video hardware registers from a data table.
  242                        	; set_mode_vdc - Set video hardware registers from a data table.
  243                        	;
  244                        	; Args: _bp, Y = _farptr to data table mapped into MPR3 & MPR4.
  245                        	;
  246                        	
  247               0001     		.if	SUPPORT_SGX
  248    09:DF1B             	set_mode_sgx	.proc
  249                        	
  250    09:DF1B  A2 10      			ldx	#SGX_VDC_OFFSET		; Offset to SGX VDC.
  251    09:DF1D  F0         			db	$F0			; Turn "clx" into a "beq".
  252                        	
  253                        			.endp
  254                        		.endif
  255                        	
  256    09:DF1E             	set_mode_vdc	.proc
  257                        	
  258    09:DF1E  82         			clx				; Offset to PCE VDC.
  259                        	
  260    09:DF1F  F7 F8      			smb7	<_al			; Signal no set_bat_size() yet.
  261                        	
  262    09:DF21  43 08      			tma3				; Preserve MPR3.
  263    09:DF23  48         			pha
  264    09:DF24  43 10      			tma4				; Preserve MPR4.
  265    09:DF26  48         			pha
  266                        	
  267    09:DF27  20 3B E3   			jsr	map_bp_to_mpr34		; Map data to MPR3 & MPR4.
  268                        	
  269    09:DF2A  08         			php				; Disable interrupts.
  270    09:DF2B  78         			sei
  271                        	
  272    09:DF2C  C2         			cly				; Table size is < 256 bytes.
  273                        	
  274    09:DF2D  B1 EC      	.loop:		lda	[_bp], y		; Get the register #, +ve for
  275    09:DF2F  F0 46      			beq	.done			; VDC, -128 for VCE_CR.
  276    09:DF31  10 0C      			bpl	.set_vdc_reg
  277                        	
  278                        			; Set the VCE_CR register.
  279                        	
  280    09:DF33  C8         	.set_vce_cr:	iny
  281                        	
  282    09:DF34  B1 EC      			lda	[_bp], y		; Get lo-byte of register.
  283    09:DF36  C8         			iny
  284    09:DF37  8D 44 22   			sta	vce_cr			; No SGX shadow for this!
  285    09:DF3A  8D 00 04   			sta	VCE_CR			; Set the VCE clock speed.
  286    09:DF3D  80 EE      			bra	.loop			; Do not set VDC_MWR reg bits!
  287                        	
  288                        			; Set a VDC register.
  289                        	
  290    09:DF3F  C8         	.set_vdc_reg:	iny
  291    09:DF40  9D 00 02   			sta	VDC_AR, x		; Set which VDC register.
  292                        	
  293    09:DF43  C9 05      			cmp	#VDC_CR			; CS if VDC_CR or higher.
  294    09:DF45  F0 14      			beq	.skip_cc
  295    09:DF47  18         			clc				; CC if not VDC_CR.
  296                        	
  297    09:DF48  49 09      			eor	#VDC_MWR		; Check if this the VDC_MWR
  298    09:DF4A  D0 0F      			bne	.skip_cc		; without changing CC.
  299                        	
  300    09:DF4C  B1 EC      			lda	[_bp], y		; Remember the BAT size so that
  301    09:DF4E  8D 42 22   			sta	vdc_mwr			; set_bat_size() can be called.
  302    09:DF51  4A         			lsr	a
  303    09:DF52  4A         			lsr	a
  304    09:DF53  4A         			lsr	a
  305    09:DF54  4A         			lsr	a
  306    09:DF55  85 F8      			sta	<_al
  307    09:DF57  C8         			iny
  308    09:DF58  C8         			iny
  309    09:DF59  80 D2      			bra	.loop
  310                        	
  311    09:DF5B  B1 EC      	.skip_cc:	lda	[_bp], y		; Get lo-byte of register.
  312    09:DF5D  C8         			iny
  313    09:DF5E  90 08      			bcc	.not_vdc_cr
  314                        	
  315               0001     		.if	SUPPORT_SGX
  316    09:DF60  E0 00      			cpx	#0			; Writing to the VDC or SGX?
  317    09:DF62  F0 02      			beq	.save_crl
  318    09:DF64  29 F7      			and	#$F7			; We only need 1 vblank IRQ!
  319                        		.endif
  320                        	
  321    09:DF66  95 F3      	.save_crl:	sta	<vdc_crl, x		; Save VDC_CR shadow register.
  322                        	
  323    09:DF68  9D 02 02   	.not_vdc_cr:	sta	VDC_DL, x		; Write to VDC.
  324                        	
  325    09:DF6B  B1 EC      			lda	[_bp], y		; Get hi-byte of register.
  326    09:DF6D  C8         			iny
  327    09:DF6E  9D 03 02   			sta	VDC_DH, x
  328    09:DF71  90 BA      			bcc	.loop			; Next register, please!
  329                        	
  330    09:DF73  95 F4      			sta	<vdc_crh, x		; Save VDC_CR shadow register.
  331                        	
  332    09:DF75  80 B6      			bra	.loop			; Next register, please!
  333                        	
  334                        			; All registers set!
  335                        	
  336    09:DF77  A9 02      	.done:		lda	#VDC_VWR		; Leave with VDC_VWR set.
  337    09:DF79  95 F7      			sta	<vdc_reg, x
  338                        	;		lda	<vdc_reg, x		; Restore previous VDC_AR from
  339    09:DF7B  9D 00 02   			sta	VDC_AR, x		; the shadow variable.
  340                        	
  341    09:DF7E  28         			plp				; Restore interrupts.
  342                        	
  343    09:DF7F  68         			pla				; Restore MPR4.
  344    09:DF80  53 10      			tam4
  345    09:DF82  68         			pla				; Restore MPR3.
  346    09:DF83  53 08      			tam3
  347                        	
  348    09:DF85  7F F8 07   			bbr7	<_al, set_bat_size	; Update if BAT size changed.
  349                        	
  350                        			leave				; All done, phew!
         09:DF88  4C EF FF   			jmp	leave_proc
  351                        	
  352    09:DF8B             			.ref	set_bat_vdc
  353                        			.endp
  354                        	
  355                        	
  356                        	
  357                        	; ***************************************************************************
  358                        	; ***************************************************************************
  359                        	;
  360                        	; set_bat_sgx - Change the SGX BAT size and initialize variables based on it.
  361                        	; set_bat_vdc - Change the PCE BAT size and initialize variables based on it.
  362                        	;
  363                        	; Args: _al = new size (0-7).
  364                        	;
  365                        	; (VDC_MWR_32x32  >> 4) or in HuCC, SCR_SIZE_32x32.
  366                        	; (VDC_MWR_32x64  >> 4) or in HuCC, SCR_SIZE_32x64.
  367                        	; (VDC_MWR_64x32  >> 4) or in HuCC, SCR_SIZE_64x32.
  368                        	; (VDC_MWR_64x64  >> 4) or in HuCC, SCR_SIZE_64x64.
  369                        	; (VDC_MWR_128x32 >> 4) or in HuCC, SCR_SIZE_128x32.
  370                        	; (VDC_MWR_128x64 >> 4) or in HuCC, SCR_SIZE_128x64.
  371                        	;
  372                        	
  373               0001     		.if	SUPPORT_SGX
  374    09:DF8B             	set_bat_sgx	.proc
  375                        	
  376    09:DF8B  A2 10      			ldx	#SGX_VDC_OFFSET		; Offset to SGX VDC.
  377    09:DF8D  F0         			db	$F0			; Turn "clx" into a "beq".
  378                        	
  379    09:DF8E             			.ref	set_bat_vdc
  380                        			.endp
  381                        		.endif
  382                        	
  383    09:DF8E             	set_bat_vdc	.proc
  384                        	
  385    09:DF8E  82         			clx				; Offset to PCE VDC.
  386                        	
  387    09:DF8F  A5 F8      	set_bat_size:	lda	<_al			; Get BAT size value.
  388    09:DF91  29 07      			and	#7			; Sanitize screen size value.
  389    09:DF93  A8         			tay
  390    09:DF94  0A         			asl	a			; Put it in bits 4..6.
  391    09:DF95  0A         			asl	a
  392    09:DF96  0A         			asl	a
  393    09:DF97  0A         			asl	a
  394    09:DF98  85 00      			sta	<__temp
  395                        	
  396    09:DF9A  B9 DA DF   			lda	.width, y
  397    09:DF9D  9D AF 24   			sta	vdc_bat_width, x
  398    09:DFA0  3A         			dec	a
  399    09:DFA1  9D B1 24   			sta	vdc_bat_x_mask, x
  400                        	
  401    09:DFA4  B9 E2 DF   			lda	.height, y
  402    09:DFA7  9D B0 24   			sta	vdc_bat_height, x
  403    09:DFAA  3A         			dec	a
  404    09:DFAB  9D B2 24   			sta	vdc_bat_y_mask, x
  405                        	
  406    09:DFAE  B9 EA DF   			lda	.limit, y
  407    09:DFB1  9D B3 24   			sta	vdc_bat_limit, x
  408                        	
  409    09:DFB4  B9 F2 DF   			lda	.increment, y		; Put the VRAM increment for a
  410    09:DFB7  95 F4      			sta	<vdc_crh, x		; line into vdc_crh for later.
  411                        	
  412    09:DFB9  08         			php
  413    09:DFBA  78         			sei
  414                        	
  415    09:DFBB  A9 09      			lda	#VDC_MWR
  416    09:DFBD  9D 00 02   			sta	VDC_AR, x
  417                        	
  418    09:DFC0  AD 42 22   			lda	vdc_mwr			; Get the MWR access width bits.
  419    09:DFC3  29 8F      			and	#%10001111
  420    09:DFC5  05 00      			ora	<__temp
  421               0001     		.if	SUPPORT_SGX
  422    09:DFC7  E0 00      			cpx	#PCE_VDC_OFFSET		; This has no SGX shadow!
  423    09:DFC9  D0 03      			bne	!+
  424                        		.endif
  425    09:DFCB  8D 42 22   			sta	vdc_mwr
  426    09:DFCE  9D 02 02   	!:		sta	VDC_DL, x
  427                        	
  428    09:DFD1  B5 F7      			lda	<vdc_reg, x		; Restore previous VDC_AR from
  429    09:DFD3  9D 00 02   			sta	VDC_AR, x		; the shadow variable.
  430                        	
  431    09:DFD6  28         			plp
  432                        	
  433                        			leave
         09:DFD7  4C EF FF   			jmp	leave_proc
  434                        	
  435    09:DFDA  20 40 80 80	.width:		db	$20,$40,$80,$80,$20,$40,$80,$80
         09:DFDE  20 40 80 80 
  436    09:DFE2  20 20 20 20	.height:	db	$20,$20,$20,$20,$40,$40,$40,$40
         09:DFE6  40 40 40 40 
  437    09:DFEA  03 07 0F 0F	.limit:		db	$03,$07,$0F,$0F,$07,$0F,$1F,$1F
         09:DFEE  07 0F 1F 1F 
  438    09:DFF2  08 10 18 18	.increment	db	$08,$10,$18,$18,$08,$10,$18,$18
         09:DFF6  08 10 18 18 
  439                        	
  440               24AF     			.bss
  441                        	
  442                        	; **************
  443                        	; 16-bytes of VDC BAT information.
  444                        	;
  445                        	; N.B. MUST be 16-bytes before the SGX versions to use PCE_VDC_OFFSET.
  446                        	;
  447                        	; N.B. Declared inside this .proc so that they can be stripped if unused.
  448                        	
  449                        	; Initialized by set_bat_vdc.
  450    F8:24AF             	vdc_bat_width:	ds	1	; $20, $40, $80
  451    F8:24B0             	vdc_bat_height:	ds	1	; $20, $40
  452    F8:24B1             	vdc_bat_x_mask:	ds	1	; $1F, $3F, $7F
  453    F8:24B2             	vdc_bat_y_mask:	ds	1	; $1F, $3F
  454    F8:24B3             	vdc_bat_limit:	ds	1	; (>$03FF), (>$07FF), (>$0FFF), (>$1FFF)
  455                        	
  456                        	; From blkmap.asm just to avoid wasting .bss space with padding.
  457    F8:24B4             	vdc_map_draw_w:	ds	1	; (SCR_WIDTH / 8) + 1
  458    F8:24B5             	vdc_map_draw_h:	ds	1	; (SCR_HEIGHT / 8) + 1
  459    F8:24B6             	vdc_map_line_w:	ds	1	; Line width of map data in tiles.
  460    F8:24B7             	vdc_map_scrn_w:	ds	1	; Line width of map data in screens.
  461    F8:24B8             	vdc_map_pxl_x:	ds	2	; Current top-left X in pixels.
  462    F8:24BA             	vdc_map_pxl_y:	ds	2	; Current top-left Y in pixels.
  463    F8:24BC             	vdc_map_option:	ds	1	; Flags to disable BAT alignment.
  464                        	
  465                        	; From hucc-old-spr.asm just to avoid wasting .bss space with padding.
  466    F8:24BD             	spr_max:	ds	1
  467    F8:24BE             	spr_clr:	ds	1
  468                        	
  469               0001     		.if	SUPPORT_SGX
  470                        	
  471                        	; **************
  472                        	; 16-bytes of SGX BAT information.
  473                        	;
  474                        	; N.B. MUST be 16-bytes after the VDC versions to use SGX_VDC_OFFSET.
  475                        	;
  476                        	; N.B. Declared inside this .proc so that they can be stripped if unused.
  477                        	
  478                        	; Initialized by set_bat_sgx.
  479    F8:24BF             	sgx_bat_width:	ds	1	; $20, $40, $80
  480    F8:24C0             	sgx_bat_height:	ds	1	; $20, $40
  481    F8:24C1             	sgx_bat_x_mask:	ds	1	; $1F, $3F, $7F
  482    F8:24C2             	sgx_bat_y_mask:	ds	1	; $1F, $3F
  483    F8:24C3             	sgx_bat_limit:	ds	1	; (>$03FF), (>$07FF), (>$0FFF), (>$1FFF)
  484                        	
  485                        	; From blkmap.asm just to avoid wasting .bss space with padding.
  486    F8:24C4             	sgx_map_draw_w:	ds	1	; (SCR_WIDTH / 8) + 1
  487    F8:24C5             	sgx_map_draw_h:	ds	1	; (SCR_HEIGHT / 8) + 1
  488    F8:24C6             	sgx_map_line_w:	ds	1	; Line width of map data in tiles.
  489    F8:24C7             	sgx_map_scrn_w:	ds	1	; Line width of map data in screens.
  490    F8:24C8             	sgx_map_pxl_x:	ds	2	; Current top-left X in pixels.
  491    F8:24CA             	sgx_map_pxl_y:	ds	2	; Current top-left Y in pixels.
  492    F8:24CC             	sgx_map_option:	ds	1	; Flags to disable BAT alignment.
  493                        	
  494                        	; From hucc-old-spr.asm just to avoid wasting .bss space with padding.
  495    F8:24CD             	sgx_spr_max:	ds	1
  496    F8:24CE             	sgx_spr_clr:	ds	1
  497                        	
  498                        		.endif
  499                        	
  500               DFFA     			.code
  501                        	
  502                        			.endp
  503                        	
  504                        			.endprocgroup
  505                        	
  506                        	
  507                        	
  508                        	; ***************************************************************************
  509                        	; ***************************************************************************
  510                        	;
  511                        	; sgx_detect - Detect whether we're running on a SuperGrafx (and init VPC).
  512                        	;
  513                        	; Returns: X,C-flag, and "sgx_detected" = NZ, CS if detected.
  514                        	;
  515                        	; ***************************************************************************
  516                        	;
  517                        	; https://web.archive.org/web/20161129055659/http://cgfm2.emuviews.com/txt/sgxtech.txt
  518                        	;
  519                        	; ***************************************************************************
  520                        	;
  521                        	; HuC6202 VIDEO PRIORITY CONTROLLER (huge thanks to Charles MacDonald!)
  522                        	;
  523                        	; The VPC has no access to sprite priority data, it can only sort pixels
  524                        	; based upon which VDC and whether they are "sprite" or "background".
  525                        	;
  526                        	; This can sometimes lead to unexpected results with low-priority sprites.
  527                        	;
  528                        	; VPC registers $0008 and $0009 make up four 4-bit values that define the
  529                        	; enabled layers and priority setting for the four possible window areas.
  530                        	;
  531                        	; Bits 3-0 of $0008 are for the region where Window 1 and 2 overlap
  532                        	; Bits 7-4 of $0008 are for the region occupied by only Window 2
  533                        	; Bits 3-0 of $0009 are for the region occupied by only Window 1
  534                        	; Bits 7-4 of $0009 are for the region where no Window is present
  535                        	;
  536                        	;  Each 4-bit value has the same format:
  537                        	;
  538                        	;  Bit 0: VDC #1 graphics are 0=disabled, 1=enabled
  539                        	;  Bit 1: VDC #2 graphics are 0=disabled, 1=enabled
  540                        	;  Bit 2: Bit 0 of priority setting
  541                        	;  Bit 3: Bit 1 of priority setting
  542                        	;
  543                        	;   Priority Setting 0b00xx: (useful when VDC #1 is a fullscreen HUD)
  544                        	;
  545                        	;    FRONT
  546                        	;     SP1 = VDC #1 (pce) sprite pixels
  547                        	;     BG1 = VDC #1 (pce) background pixels
  548                        	;     SP2 = VDC #2 (sgx) sprite pixels
  549                        	;     BG2 = VDC #2 (sgx) background pixels
  550                        	;    BACK
  551                        	;
  552                        	;   Priority Setting 0b01xx: (useful for parallax backgrounds)
  553                        	;
  554                        	;    FRONT
  555                        	;     SP1 = VDC #1 (pce) sprite pixels
  556                        	;     SP2 = VDC #2 (sgx) sprite pixels
  557                        	;     BG1 = VDC #1 (pce) background pixels
  558                        	;     BG2 = VDC #2 (sgx) background pixels
  559                        	;    BACK
  560                        	;
  561                        	;   Priority Setting 0b10xx: (only useful for special effects)
  562                        	;
  563                        	;    FRONT
  564                        	;     BG1 = VDC #1 (pce) background pixels (transparent where sprites)
  565                        	;     BG2 = VDC #2 (sgx) background pixels
  566                        	;     SP1 = VDC #1 (pce) sprite pixels
  567                        	;     SP2 = VDC #2 (sgx) sprite pixels
  568                        	;    BACK
  569                        	
  570               0001     		.if	SUPPORT_SGX
  571               0001     		.if	1
  572    02:C000             	sgx_detect	.proc
  573                        	
  574    02:C000  A0 7F      			ldy	#$7F			; Use VRAM address $7F7F
  575    02:C002  84 F0      			sty.l	<_di			; because it won't cause
  576    02:C004  84 F1      			sty.h	<_di			; a screen glitch.
  577                        	
  578    02:C006  20 7B E3   			jsr	sgx_di_to_mawr		; Write $0001 to SGX VRAM.
  579    02:C009  A0 01      			ldy	#$01
  580    02:C00B  8C 12 02   			sty	SGX_DL
  581    02:C00E  9C 13 02   			stz	SGX_DH
  582                        	
  583    02:C011  20 7E E3   			jsr	vdc_di_to_mawr		; Write $0000 to VDC VRAM.
  584    02:C014  9C 02 02   			stz	VDC_DL
  585    02:C017  9C 03 02   			stz	VDC_DH
  586                        	
  587    02:C01A  20 6E E3   			jsr	sgx_di_to_marr		; Check value in SGX VRAM.
  588    02:C01D  AC 12 02   			ldy	SGX_DL			; $01 if found, $00 if not.
  589    02:C020  8C E8 22   			sty	sgx_detected
  590    02:C023  F0 10      			beq	!+			; Skip the rest if not SGX.
  591                        	
  592    02:C025  20 7B E3   			jsr	sgx_di_to_mawr		; Write $0000 to SGX VRAM
  593    02:C028  9C 12 02   			stz	SGX_DL			; to clean VRAM contents.
  594    02:C02B  9C 13 02   			stz	SGX_DH
  595                        	
  596    02:C02E  73 3B C0 08			tii	.vpc_mode, VPC_CR, 8	; Initialize the HuC6202 VPC.
         02:C032  02 08 00    
  597                        	
  598    02:C035  98         	!:		tya
  599    02:C036  AA         			tax				; "leave" copies X back to A.
  600    02:C037  4A         			lsr	a			; Also CC if PCE, CS if SGX.
  601                        	
  602                        			leave				; All done, phew!
         02:C038  4C EF FF   			jmp	leave_proc
  603                        		.else
  618                        		.endif
  619                        	
  620               0000     		.ifndef	SGX_PARALLAX
  622                        		.endif
  623                        	
  624               0001     		.if	SGX_PARALLAX
  625    02:C03B  00 70      	.vpc_mode:	dw	$7000			; Use SGX as a parallax layer
  626    02:C03D  00 00      			dw	$0000			; behind a VDC background.
  627    02:C03F  00 00      			dw	$0000
  628    02:C041  00 00      			dw	$0000
  629                        		.else
  634                        		.endif	SGX_PARALLAX
  635                        	
  636                        			.endp
  637                        	
  638               0000     		.ifndef	CORE_VERSION			; CORE has this in the kernel.
  642                        		.endif	CORE_VERSION
  643                        	
  644                        		.endif	SUPPORT_SGX
  645                        	
  646                        	
  647                        	
  648                        	
  649                        	vdc_copy_to	.procgroup			; These routines share code!
  799                        			.endprocgroup
  800                        	
  801                        	
  802                        	
  803                        	; ***************************************************************************
  804                        	; ***************************************************************************
  805                        	;
  806                        	; init_240x208 - An example of initializing screen and VRAM.
  807                        	;
  808                        	; This can be used as-is, or copied to your own program and modified.
  809                        	;
  810                        	
  811                        	init_240x208	.proc
  892                        			.endp
  893                        	
  894                        	
  895                        	
  896                        	; ***************************************************************************
  897                        	; ***************************************************************************
  898                        	;
  899                        	; init_256x224 - An example of initializing screen and VRAM.
  900                        	;
  901                        	; This can be used as-is, or copied to your own program and modified.
  902                        	;
  903                        	
  904                        	init_256x224	.proc
  985                        			.endp
  986                        	
  987                        	
  988                        	
  989                        	; ***************************************************************************
  990                        	; ***************************************************************************
  991                        	;
  992                        	; init_352x224 - An example of initializing screen and VRAM.
  993                        	;
  994                        	; This can be used as-is, or copied to your own program and modified.
  995                        	;
  996                        	
  997                        	init_352x224	.proc
 1078                        			.endp
 1079                        	
 1080                        	
 1081                        	
 1082                        	; ***************************************************************************
 1083                        	; ***************************************************************************
 1084                        	;
 1085                        	; init_512x224 - An example of initializing screen and VRAM.
 1086                        	;
 1087                        	; This can be used as-is, or copied to your own program and modified.
 1088                        	;
 1089                        	
 1090                        	init_512x224	.proc
 1171                        			.endp
 1172                        	
 1173                        	
 1174                        	
 1175                        	; ***************************************************************************
 1176                        	; ***************************************************************************
 1177                        	;
 1178                        	; init_320x208 - An example of initializing screen and VRAM.
 1179                        	;
 1180                        	; This can be used as-is, or copied to your own program and modified.
 1181                        	;
 1182                        	; This resolution is rarely-seen, but it has no overscan, so it has a use.
 1183                        	;
 1184                        	
 1185                        	init_320x208	.proc
 1266                        			.endp
                             #[2]   "..\..\..\include\hucc\hucc-final.asm"
   41                        	
                             #[3]   "..\..\..\include\hucc\hucc-math.asm"
   42                        			include	"hucc-math.asm"		; HuCC multiply and divide.
    1                        	; ***************************************************************************
    2                        	; ***************************************************************************
    3                        	;
    4                        	; hucc-math.asm
    5                        	;
    6                        	; Basic (i.e. very slow) 8-bit and 16-bit multiply and divide routines.
    7                        	;
    8                        	; Copyright John Brandwood 2021-2024.
    9                        	;
   10                        	; Distributed under the Boost Software License, Version 1.0.
   11                        	; (See accompanying file LICENSE_1_0.txt or copy at
   12                        	;  http://www.boost.org/LICENSE_1_0.txt)
   13                        	;
   14                        	; ***************************************************************************
   15                        	; ***************************************************************************
   16                        	;
   17                        	; This is basically a set of SDCC-compatible routines, but using Y:A for the
   18                        	; primary register instead of X:A.
   19                        	;
   20                        	; Using Y:A makes the routines instantly usable with HuCC, and it also makes
   21                        	; them usable with SDCC with just an "sxy" before and after the call.
   22                        	;
   23                        	; ***************************************************************************
   24                        	; ***************************************************************************
   25                        	
   26               E44C     			.code
   27                        	
   28               2000     	multiplier	=	__temp
   29               2094     	multiplicand	=	___SDCC_m6502_ret0
   30               2094     	product		=	multiplicand
   31                        	
   32               2000     	__mulint_PARM_2	=	multiplier
   33                        	
   34               2000     	divisor		=	__temp
   35               2094     	dividend	=	___SDCC_m6502_ret0
   36               2094     	quotient	=	dividend
   37               2096     	remainder	=	___SDCC_m6502_ret2
   38                        	
   39               2000     	__moduint_PARM_2 =	divisor
   40               2000     	__modsint_PARM_2 =	divisor
   41               2000     	__divuint_PARM_2 =	divisor
   42               2000     	__divsint_PARM_2 =	divisor
   43                        	
   44                        	
   45                        	
   46                        	; ***************************************************************************
   47                        	; int
   48                        	; _mulint (int a, int b)
   49                        	;
   50                        	; 1st parameter in Y:A (multiplicand)
   51                        	; 2nd parameter in __mulint_PARM_2 (multiplier)
   52                        	; result in Y:A
   53                        	;
   54                        	; N.B. signed and unsigned multiply only differ in the top 16 of the 32bits!
   55                        	
   56    00:E44C  85 94      	__mulint:	sta	<multiplicand + 0
   57    00:E44E  84 95      			sty	<multiplicand + 1
   58                        	
   59    00:E450  A2 10      			ldx	#16			; Loop 16 times.
   60                        	
   61    00:E452  46 95      			lsr	<multiplicand + 1	; Divide multiplicand by 2
   62    00:E454  66 94      			ror	<multiplicand + 0	; and clear the 16th bit.
   63                        	
   64    00:E456  62         			cla				; Clear top word of product.
   65    00:E457  85 96      			sta.l	<multiplicand + 2
   66    00:E459  90 0B      			bcc	.rotate
   67                        	
   68    00:E45B  A8         	.add:		tay				; Add the 16-bit multiplier to
   69    00:E45C  18         			clc				; top 16-bits of the product.
   70    00:E45D  A5 96      			lda	<multiplicand + 2
   71    00:E45F  65 00      			adc.l	<multiplier
   72    00:E461  85 96      			sta	<multiplicand + 2
   73    00:E463  98         			tya
   74    00:E464  65 01      			adc.h	<multiplier
   75                        	
   76    00:E466  6A         	.rotate:	ror	a			; Rotate product into the top
   77    00:E467  66 96      			ror	<multiplicand + 2	; bits of the multiplicand ...
   78    00:E469  66 95      			ror	<multiplicand + 1	; and divide multiplicand by 2.
   79    00:E46B  66 94      			ror	<multiplicand + 0
   80                        	
   81    00:E46D  CA         			dex
   82    00:E46E  B0 EB      			bcs	.add			; Add multiplier to top word?
   83    00:E470  D0 F4      			bne	.rotate			; Completed 16 bits?
   84                        	
   85    00:E472  85 97      			sta	<multiplicand + 3	; Save top byte of product.
   86                        	
   87    00:E474  A5 94      			lda.l	<multiplicand		; Return the bottom 16-bits of
   88    00:E476  A4 95      			ldy.h	<multiplicand		; the 32-bit product.
   89                        	
   90    00:E478  60         			rts
   91                        	
   92                        	
   93                        	
   94                        	; ***************************************************************************
   95                        	; unsigned int
   96                        	; _divuint (unsigned int x, unsigned int y)
   97                        	;
   98                        	; 1st parameter in Y:A (unsigned dividend)
   99                        	; 2nd parameter in __divuint_PARM_2 (unsigned divisor)
  100                        	; result in Y:A
  101                        	
  102    00:E479  20 81 E4   	__divuint:	jsr	__moduint		; Call the basic uint division.
  103                        	
  104    00:E47C  A5 94      			lda.l	<quotient		; Then get the result from where
  105    00:E47E  A4 95      			ldy.h	<quotient		; it was calculated.
  106    00:E480  60         			rts
  107                        	
  108                        	
  109                        	
  110                        	; ***************************************************************************
  111                        	; unsigned int
  112                        	; _moduint (unsigned int x, unsigned int y)
  113                        	;
  114                        	; 1st parameter in Y:A (unsigned dividend)
  115                        	; 2nd parameter in __moduint_PARM_2 (unsigned divisor)
  116                        	; result in Y:A
  117                        	;
  118                        	; If the dividend has more bits than the divisor, then we need to check the
  119                        	; 17th bit of the remainder!
  120                        	
  121               0000     		.if	0
  176                        		.else
  177                        	
  178    00:E481  85 94      	__moduint:	sta.l	<dividend		; 1st SDCC parameter in Y:A.
  179    00:E483  84 95      			sty.h	<dividend
  180                        	
  181    00:E485  A5 00      	divmoduint:	lda.l	<divisor		; Check for a divide-by-zero.
  182    00:E487  05 01      			ora.h	<divisor
  183    00:E489  F0 FE      	.zero:		beq	.zero
  184                        	
  185    00:E48B  A2 11      			ldx	#16 + 1
  186                        	
  187    00:E48D  C2         			cly				; Clear remainder.
  188    00:E48E  84 97      			sty.h	<remainder
  189                        	
  190    00:E490  98         	.skip:		tya				; Restore remainder lo-byte.
  191                        	
  192    00:E491  26 94      	.loop:		rol.l	<dividend		; Quotient bit -> dividend LSB.
  193    00:E493  26 95      			rol.h	<dividend		; Rotate dividend, MSB -> C.
  194                        	
  195    00:E495  CA         			dex
  196    00:E496  F0 14      			beq	.finished
  197                        	
  198    00:E498  2A         			rol	a			; Rotate C into remainder.
  199    00:E499  26 97      			rol.h	<remainder
  200                        	;		php				; Preserve remainder 17th bit.
  201                        	
  202    00:E49B  A8         			tay				; Preserve remainder lo-byte.
  203                        	
  204    00:E49C  C5 00      			cmp.l	<divisor		; Test divisor.
  205    00:E49E  A5 97      			lda.h	<remainder
  206    00:E4A0  E5 01      			sbc.h	<divisor
  207    00:E4A2  90 EC      			bcc	.skip			; CC if divisor > remainder.
  208                        	
  209                        	;		cmp.l	<divisor		; If the dividend has more bits
  210                        	;		lda.h	<remainder		; than the divisor then we need
  211                        	;		sbc.h	<divisor		; to check the remainder hi-bit.
  212                        	;		bcs	.subtract		; CS if divisor <= remainder.
  213                        	;		plp				; Restore remainder 17th bit.
  214                        	;		bcc	.skip			; CC if divisor > remainder.
  215                        	;		db	$90			; Turn "plp" into "bcc" to skip.
  216                        	;.subtract:	plp				; Discard remainder 17th bit.
  217                        	;		sec
  218                        	
  219    00:E4A4  85 97      			sta.h	<remainder		; Subtract divisor.
  220    00:E4A6  98         			tya
  221    00:E4A7  E5 00      			sbc.l	<divisor
  222    00:E4A9  38         			sec				
  223    00:E4AA  80 E5      			bra	.loop
  224                        	
  225    00:E4AC  A4 97      	.finished:	ldy.h	<remainder		; Get the remainder hi-byte.
  226                        	
  227    00:E4AE  60         			rts
  228                        	
  229                        		.endif
  230                        	
  231                        	
  232                        	
  233                        	; ***************************************************************************
  234                        	; int
  235                        	; _divsint (int x, int y)
  236                        	;
  237                        	; 1st parameter in Y:A (signed dividend)
  238                        	; 2nd parameter in __divsint_PARM_2 (signed divisor)
  239                        	; result in Y:A
  240                        	
  241    00:E4AF  20 B7 E4   	__divsint:	jsr	__modsint		; Call the basic sint division.
  242                        	
  243    00:E4B2  A5 94      			lda.l	<quotient		; Then get the result from where
  244    00:E4B4  A4 95      			ldy.h	<quotient		; it was calculated.
  245    00:E4B6  60         			rts
  246                        	
  247                        	
  248                        	
  249                        	; ***************************************************************************
  250                        	; int
  251                        	; _modsint (int x, int y)
  252                        	;
  253                        	; 1st parameter in Y:A (signed dividend)
  254                        	; 2nd parameter in __modsint_PARM_2 (signed divisor)
  255                        	; result in Y:A
  256                        	
  257    00:E4B7  84 95      	__modsint:	sty.h	<dividend
  258                        	
  259    00:E4B9  C0 80      			cpy	#$80			; Remainder -ve if dividend
  260    00:E4BB  08         			php				; was -ve.
  261    00:E4BC  90 03      			bcc	!+
  262    00:E4BE  20 0E E5   			jsr	neg_yacs		; Negate the dividend.
  263                        	
  264    00:E4C1  85 94      	!:		sta.l	<dividend		; Store the dividend.
  265    00:E4C3  A5 95      			lda.h	<dividend
  266    00:E4C5  84 95      			sty.h	<dividend
  267                        	
  268    00:E4C7  45 01      			eor.h	<divisor		; Quotient is -ve if divisor
  269    00:E4C9  08         			php				; and dividend signs differ.
  270                        	
  271    00:E4CA  A5 01      			lda.h	<divisor		; Is the divisor -ve?
  272    00:E4CC  10 0B      			bpl	!+
  273                        	
  274    00:E4CE  38         			sec				; Negate the divisor.
  275    00:E4CF  62         			cla
  276    00:E4D0  E5 00      			sbc.l	<divisor
  277    00:E4D2  85 00      			sta.l	<divisor
  278    00:E4D4  62         			cla
  279    00:E4D5  E5 01      			sbc.h	<divisor
  280    00:E4D7  85 01      			sta.h	<divisor
  281                        	
  282    00:E4D9  20 85 E4   	!:		jsr	divmoduint		; Do the unsigned division.
  283                        	
  284    00:E4DC  28         	.result:	plp				; Should the quotient be -ve?
  285    00:E4DD  10 0D      			bpl	.remainder
  286                        	
  287    00:E4DF  AA         			tax				; Preserve remainder lo-byte.
  288                        	
  289    00:E4E0  38         			sec				; Then negate the quotient.
  290    00:E4E1  62         			cla
  291    00:E4E2  E5 94      			sbc.l	<dividend
  292    00:E4E4  85 94      			sta.l	<dividend
  293    00:E4E6  62         			cla
  294    00:E4E7  E5 95      			sbc.h	<dividend
  295    00:E4E9  85 95      			sta.h	<dividend
  296                        	
  297    00:E4EB  8A         			txa				; Restore remainder lo-byte.
  298                        	
  299    00:E4EC  28         	.remainder:	plp				; Was the dividend -ve?
  300    00:E4ED  B0 1F      			bcs	neg_yacs		; Then negate the remainder.
  301    00:E4EF  60         			rts
  302                        	
  303                        	
  304                        	
  305                        	; ***************************************************************************
  306                        	; unsigned int
  307                        	; _muluchar (unsigned char x, unsigned char y)
  308                        	;
  309                        	; 1st parameter in A (unsigned multiplicand)
  310                        	; 2nd parameter in Y (unsigned multiplier)
  311                        	; result in Y:A
  312                        	
  313    00:E4F0  84 00      	__muluchar:	sty	<multiplier
  314                        	
  315    00:E4F2  A0 08      	muluchar_a:	ldy	#8			; Loop 8 times.
  316                        	
  317    00:E4F4  4A         			lsr	a			; Divide multiplicand by 2
  318    00:E4F5  85 94      			sta	<multiplicand		; and clear the 8th bit.
  319                        	
  320    00:E4F7  62         			cla				; Clear top byte of product.
  321    00:E4F8  90 03      			bcc	.rotate
  322                        	
  323    00:E4FA  18         	.add:		clc				; Add the 8-bit multiplier to
  324    00:E4FB  65 00      			adc	<multiplier		; top 8-bits of the product.
  325                        	
  326    00:E4FD  6A         	.rotate:	ror	a			; Rotate product into the top
  327    00:E4FE  66 94      			ror	<multiplicand		; bits of the multiplicand.
  328                        	
  329    00:E500  88         			dey
  330    00:E501  B0 F7      			bcs	.add			; Add multiplier to top byte?
  331    00:E503  D0 F8      			bne	.rotate			; Completed 8 bits?
  332                        	
  333    00:E505  A8         			tay				; Return the 16-bit product.
  334    00:E506  A5 94      			lda	<multiplicand
  335                        	
  336    00:E508  60         			rts
  337                        	
  338                        	
  339                        	
  340                        	; ***************************************************************************
  341                        	; signed int
  342                        	; abs (signed int x)
  343                        	;
  344                        	; 1st parameter in Y:A (signed)
  345                        	; result in Y:A
  346                        	
  347    00:E509  C0 80      	_abs:		cpy	#$80			; Is the hi-byte -ve?
  348    00:E50B  90 0B      			bcc	!+
  349                        	
  350    00:E50D  38         	neg_ya:		sec
  351    00:E50E  49 FF      	neg_yacs:	eor	#$FF
  352    00:E510  69 00      			adc	#0
  353    00:E512  42         			say
  354    00:E513  49 FF      			eor	#$FF
  355    00:E515  69 00      			adc	#0
  356    00:E517  42         			say
  357    00:E518  60         	!:		rts
  358                        	
  359    00:E519             	_abs.1		.alias	_abs
  360                        	
  361                        	
  362                        	
  363                        	; ***************************************************************************
  364                        	; signed int
  365                        	; _mulschar (signed char x, signed char y)
  366                        	;
  367                        	; 1st parameter in A (signed multiplicand)
  368                        	; 2nd parameter in Y (signed multiplier)
  369                        	; result in Y:A
  370                        	;
  371                        	; N.B. Y and A get swapped to make the code shorter.
  372                        	
  373    00:E519  85 94      	__mulschar:	sta	<multiplicand		; Remember multiplicand sign.
  374                        	
  375    00:E51B  C9 80      			cmp	#$80			; Is the multiplicand -ve?
  376    00:E51D  90 03      			bcc	!+
  377    00:E51F  49 FF      			eor	#$FF			; Negate the multiplicand.
  378    00:E521  1A         			inc	a
  379    00:E522  85 00      	!:		sta	<multiplier		; Then save it as multiplier.
  380                        	
  381    00:E524  98         			tya				; Product -ve if multiplicand
  382    00:E525  45 94      			eor	<multiplicand		; and multiplier signs differ.
  383    00:E527  08         			php				; Remember product sign.
  384                        	
  385    00:E528  98         			tya				; Is the multiplicand -ve?
  386    00:E529  10 03      			bpl	!+
  387    00:E52B  49 FF      			eor	#$FF			; Negate the multiplicand.
  388    00:E52D  1A         			inc	a
  389                        	
  390    00:E52E  20 F2 E4   	!:		jsr	muluchar_a		; Multiplier already saved.
  391                        	
  392    00:E531  28         			plp				; Is the product -ve?
  393    00:E532  30 D9      			bmi	neg_ya
  394    00:E534  60         			rts
  395                        	
  396                        	
  397                        	
  398                        	; ***************************************************************************
  399                        	; unsigned int
  400                        	; _mulsuchar (signed char x, signed char y)
  401                        	;
  402                        	; 1st parameter in A (unsigned multiplicand)
  403                        	; 2nd parameter in Y (signed multiplier)
  404                        	; result in Y:A
  405                        	;
  406                        	; N.B. Y and A get swapped to make the code shorter.
  407                        	
  408    00:E535  42         	__mulsuchar:	say				; Put the signed param in A.
  409                        			; drop through to __muluschar
  410                        	
  411                        	
  412                        	
  413                        	; ***************************************************************************
  414                        	; signed int
  415                        	; _muluschar (unsigned char x, unsigned char y)
  416                        	;
  417                        	; 1st parameter in A (signed multiplicand)
  418                        	; 2nd parameter in Y (unsigned multiplier)
  419                        	; result in Y:A
  420                        	
  421    00:E536  C9 80      	__muluschar:	cmp	#$80			; Is multiplicand -ve?
  422    00:E538  08         			php				; Remember the sign.
  423    00:E539  90 03      			bcc	!+
  424    00:E53B  49 FF      			eor	#$FF			; Negate multiplicand.
  425    00:E53D  1A         			inc	a
  426                        	
  427    00:E53E  20 F0 E4   	!:		jsr	__muluchar		; Do the unsigned multiply.
  428                        	
  429    00:E541  28         			plp				; Was multiplicand -ve?
  430    00:E542  B0 CA      			bcs	neg_yacs		; Then negate the product.
  431    00:E544  60         			rts
  432                        	
  433                        	
  434                        	
  435                        	; ***************************************************************************
  436                        	; unsigned int
  437                        	; _moduchar (unsigned char x, unsigned char y)
  438                        	;
  439                        	; 1st parameter in A (unsigned dividend)
  440                        	; 2nd parameter in Y (unsigned divisor)
  441                        	; result in Y:A
  442                        	
  443    00:E545  84 00      	__moduchar:	sty.l	<divisor
  444                        	
  445    00:E547  0A         	divmodu8_a:	asl	a			; Rotate dividend, MSB -> C.
  446    00:E548  85 94      			sta.l	<dividend
  447    00:E54A  64 95      			stz.h	<dividend		; Clear quotient hi-byte.
  448                        	
  449    00:E54C  A0 08      			ldy	#8
  450    00:E54E  62         			cla				; Clear remainder.
  451    00:E54F  2A         	.loop:		rol	a			; Rotate C into remainder.
  452    00:E550  C5 00      			cmp	<divisor		; Test divisor.
  453    00:E552  90 02      			bcc	.skip			; CC if divisor > remainder.
  454    00:E554  E5 00      			sbc	<divisor		; Subtract divisor.
  455    00:E556  26 94      	.skip:		rol	<dividend		; Quotient bit -> dividend LSB.
  456    00:E558  88         			dey
  457    00:E559  D0 F4      			bne	.loop
  458                        	
  459    00:E55B  C2         			cly				; Clear hi-byte of return.
  460    00:E55C  60         			rts				; Return the 16-bit remainder.
  461                        	
  462                        	
  463                        	
  464                        	; ***************************************************************************
  465                        	; unsigned int
  466                        	; _divuchar (unsigned char x, unsigned char y)
  467                        	;
  468                        	; 1st parameter in A (unsigned dividend)
  469                        	; 2nd parameter in Y (unsigned divisor)
  470                        	; result in Y:A
  471                        	
  472    00:E55D  20 45 E5   	__divuchar:	jsr	__moduchar
  473                        	
  474    00:E560  A5 94      			lda	<dividend		; Get the dividend lo-byte.
  475    00:E562  60         			rts				; Return the 16-bit dividend.
  476                        	
  477                        	
  478                        	
  479                        	; ***************************************************************************
  480                        	; signed int
  481                        	; _modschar (signed char x, signed char y)
  482                        	;
  483                        	; 1st parameter in A (signed dividend)
  484                        	; 2nd parameter in Y (signed divisor)
  485                        	; result in Y:A
  486                        	
  487    00:E563  AA         	__modschar:	tax				; Preserve the dividend.
  488    00:E564  08         			php				; Remember remainder sign.
  489                        	
  490    00:E565  84 00      			sty	<divisor		; Quotient negative if divisor
  491    00:E567  45 00      			eor	<divisor		; and dividend signs differ.
  492    00:E569  08         			php				; Remember the quotient sign.
  493                        	
  494    00:E56A  98         			tya				; Is the divisor -ve?
  495    00:E56B  10 05      			bpl	!+
  496    00:E56D  49 FF      			eor	#$FF			; Negate the divisor.
  497    00:E56F  1A         			inc	a
  498    00:E570  85 00      			sta	<divisor
  499                        	
  500    00:E572  8A         	!:		txa				; Is the dividend -ve?
  501    00:E573  10 03      			bpl	divmods8_a
  502                        	
  503    00:E575  49 FF      	divmods8_neg:	eor	#$FF			; Negate the dividend.
  504    00:E577  1A         			inc	a
  505                        	
  506    00:E578  20 47 E5   	divmods8_a:	jsr	divmodu8_a		; Do the unsigned division.
  507                        	
  508    00:E57B  28         			plp				; Should the quotient be -ve?
  509    00:E57C  10 0C      			bpl	!+
  510                        	
  511    00:E57E  AA         			tax				; Preserve remainder lo-byte.
  512                        	
  513    00:E57F  38         			sec				; Negate the quotient.
  514    00:E580  62         			cla
  515    00:E581  E5 94      			sbc.l	<dividend
  516    00:E583  85 94      			sta.l	<dividend
  517    00:E585  A9 FF      			lda	#$FF
  518    00:E587  85 95      			sta.h	<dividend
  519                        	
  520    00:E589  8A         			txa				; Restore remainder lo-byte.
  521                        	
  522    00:E58A  28         	!:		plp				; Was the dividend -ve?
  523    00:E58B  10 05      			bpl	!+
  524                        	
  525    00:E58D  49 FF      			eor	#$FF			; Then negate the remainder.
  526    00:E58F  1A         			inc	a
  527    00:E590  A0 FF      			ldy	#$FF
  528                        	
  529    00:E592  60         	!:		rts
  530                        	
  531                        	
  532                        	
  533                        	; ***************************************************************************
  534                        	; signed int
  535                        	; _moduschar (unsigned char x, unsigned char y)
  536                        	;
  537                        	; 1st parameter in A (signed dividend)
  538                        	; 2nd parameter in Y (unsigned divisor)
  539                        	; result in Y:A
  540                        	
  541    00:E593  84 00      	__moduschar:	sty.l	<divisor
  542                        	
  543    00:E595  A8         			tay				; Is the dividend -ve?
  544    00:E596  08         			php				; Remember remainder sign.
  545    00:E597  08         			php				; Remember quotient sign.
  546    00:E598  30 DB      			bmi	divmods8_neg
  547    00:E59A  80 DC      			bra	divmods8_a
  548                        	
  549                        	
  550                        	
  551                        	; ***************************************************************************
  552                        	; unsigned int
  553                        	; _modsuchar (signed char x, signed char y)
  554                        	;
  555                        	; 1st parameter in A (unsigned dividend)
  556                        	; 2nd parameter in Y (signed divisor)
  557                        	; result in Y:A
  558                        	
  559    00:E59C  AA         	__modsuchar:	tax				; Preserve the dividend.
  560    00:E59D  08         			php				; Remember remainder sign.
  561                        	
  562    00:E59E  98         			tya				; Check the divisor sign.
  563    00:E59F  08         			php				; Remember quotient sign.
  564    00:E5A0  10 03      			bpl	!+
  565    00:E5A2  49 FF      			eor	#$FF			; Negate the divisor.
  566    00:E5A4  1A         			inc	a
  567    00:E5A5  85 00      	!:		sta.l	<divisor
  568                        	
  569    00:E5A7  8A         			txa				; Restore the dividend.
  570    00:E5A8  80 CE      			bra	divmods8_a
  571                        	
  572                        	
  573                        	
  574                        	; ***************************************************************************
  575                        	; signed int
  576                        	; _divschar (signed char x, signed char y)
  577                        	;
  578                        	; 1st parameter in A (signed dividend)
  579                        	; 2nd parameter in Y (signed divisor)
  580                        	; result in Y:A
  581                        	
  582    00:E5AA  20 63 E5   	__divschar:	jsr	__modschar
  583                        	
  584    00:E5AD  A5 94      			lda.l	<dividend
  585    00:E5AF  A4 95      			ldy.h	<dividend
  586    00:E5B1  60         			rts
  587                        	
  588                        	
  589                        	
  590                        	; ***************************************************************************
  591                        	; signed int
  592                        	; _divuschar (unsigned char x, unsigned char y)
  593                        	;
  594                        	; 1st parameter in A (signed dividend)
  595                        	; 2nd parameter in Y (unsigned divisor)
  596                        	; result in Y:A
  597                        	
  598    00:E5B2  20 93 E5   	__divuschar:	jsr	__moduschar
  599                        	
  600    00:E5B5  A5 94      			lda.l	<dividend
  601    00:E5B7  A4 95      			ldy.h	<dividend
  602    00:E5B9  60         			rts
  603                        	
  604                        	
  605                        	
  606                        	; ***************************************************************************
  607                        	; unsigned int
  608                        	; _divsuchar (signed char x, signed char y)
  609                        	;
  610                        	; 1st parameter in A (unsigned dividend)
  611                        	; 2nd parameter in Y (signed divisor)
  612                        	; result in Y:A
  613                        	
  614    00:E5BA  20 9C E5   	__divsuchar:	jsr	__modsuchar
  615                        	
  616    00:E5BD  A5 94      			lda.l	<dividend
  617    00:E5BF  A4 95      			ldy.h	<dividend
  618    00:E5C1  60         			rts
                             #[2]   "..\..\..\include\hucc\hucc-final.asm"
   43                        	
   44                        			; Define in hucc-config.inc to remove this.
   45                        	
   46               0001     		.ifndef	HUCC_NO_DEFAULT_RANDOM
                             #[3]   "..\..\..\include\hucc\random.asm"
   47                        			include	"random.asm"		; Random number generator.
    1                        	; ***************************************************************************
    2                        	; ***************************************************************************
    3                        	;
    4                        	; random.asm
    5                        	;
    6                        	; Pseudo-random number generator (https://github.com/bbbradsmith/prng_6502)
    7                        	;
    8                        	; Copyright Brad Smith 2019.
    9                        	;
   10                        	; License:
   11                        	;
   12                        	; This code and may be used, reused, and modified for any purpose, commercial
   13                        	; or non-commercial.
   14                        	;
   15                        	; Attribution in released binaries or documentation is appreciated but not
   16                        	; required.
   17                        	;
   18                        	; ***************************************************************************
   19                        	; ***************************************************************************
   20                        	;
   21                        	; This is a linear feedback shift register (LFSR) in Galois form, which is
   22                        	; iterated 8 times to produce an 8-bit pseudo-random number.
   23                        	;
   24                        	; Two widths of LFSR are provided:
   25                        	;
   26                        	;  24-bit requires 3 bytes, and repeats after 16777215 calls.
   27                        	;  32-bit requires 4 bytes, and repeats after 4294967295 calls.
   28                        	;
   29                        	; Usage:
   30                        	;
   31                        	;  Initialize the zero-page "random" variable to any value other than 0.
   32                        	;  The size of "random" is 3 or 4 bytes, depending on the width of LFSR
   33                        	;  chosen.
   34                        	;
   35                        	;  Call one of the RNG functions and an 8-bit result will be returned in the
   36                        	;  A-register (with flags), and the Y-register will be clobbered.
   37                        	;
   38                        	;  Do not mix RNGs of different width in the same program, unless you can
   39                        	;  give them each separate "random" state storage.
   40                        	;
   41                        	; ***************************************************************************
   42                        	; ***************************************************************************
   43                        	
   44                        	
   45               0001     		.ifndef	_KICKC				; Variables defined in C?
   46               2098     			.zp
   47    F8:2098             	random:		.ds	4			; Seed is 3 or 4 bytes.
   48               E5C2     			.code
   49                        		.endif	_KICKC
   50                        	
   51                        	
   52                        	
   53                        	; ***************************************************************************
   54                        	; ***************************************************************************
   55                        	;
   56                        	; init_random - Initialize a 32-bit LFSR using an 8-bit seed value in Y.
   57                        	;
   58                        	; The LFSR is initialized to n'th entry of a standard CRC-32 lookup-table,
   59                        	; which gives it a decent distribution of bits.
   60                        	;
   61                        	; Since seed is an 8-bit value, there are 255 (256-1) possible starting
   62                        	; states for the LFSR, because 0 would generate a 0 state.
   63                        	;
   64                        	; CRC-32 code by Paul Guertin. See http://6502.org/source/integers/crc.htm
   65                        	;
   66                        	
   67    02:C081             	init_random	.proc
   68                        	
   69    02:C081  A9 01      			lda	#1			; Init CRC-32 table value.
   70    02:C083  85 98      			sta	<random + 0
   71    02:C085  98         			tya				; Get and check the seed value.
   72    02:C086  D0 01      			bne	.reverse_seed
   73    02:C088  3A         			dec	a			; Which must be non-zero!
   74    02:C089  4A         	.reverse_seed:	lsr	a			; Reverse the bits so that small changes
   75    02:C08A  26 98      			rol	<random + 0		; in the seed make larger differences in
   76    02:C08C  90 FB      			bcc	.reverse_seed		; the initial state.
   77                        	
   78    02:C08E  64 99      			stz	<random + 1		; A contains the high byte of the CRC-32.
   79    02:C090  64 9A      			stz	<random + 2		; The other three bytes are in memory.
   80    02:C092  62         			cla
   81                        	
   82    02:C093  A0 08      			ldy	#8			; Y counts bits in a byte.
   83    02:C095  4A         	.bit_loop:	lsr	a			; The CRC-32 algorithm is similar to CRC-16
   84    02:C096  66 9A      			ror	<random + 2		; except that it is reversed (originally for
   85    02:C098  66 99      			ror	<random + 1		; hardware reasons). This is why we shift
   86    02:C09A  66 98      			ror	<random + 0		; right instead of left here.
   87    02:C09C  90 16      			bcc	.no_add			; Do nothing if no overflow,
   88    02:C09E  49 ED      			eor	#$ED			; else add CRC-32 polynomial $EDB88320.
   89                        	
   90    02:C0A0  48         			pha				; Save high byte while we do others.
   91    02:C0A1  A5 9A      			lda	<random + 2
   92    02:C0A3  49 B8      			eor	#$B8			; Most reference books give the CRC-32 poly
   93    02:C0A5  85 9A      			sta	<random + 2		; as $04C11DB7. This is actually the same if
   94    02:C0A7  A5 99      			lda	<random + 1		; you write it in binary and read it right-
   95    02:C0A9  49 83      			eor	#$83			; to-left instead of left-to-right. Doing it
   96    02:C0AB  85 99      			sta	<random + 1		; this way means we won't have to explicitly
   97    02:C0AD  A5 98      			lda	<random + 0		; reverse things afterwards.
   98    02:C0AF  49 20      			eor	#$20
   99    02:C0B1  85 98      			sta	<random + 0
  100    02:C0B3  68         			pla				; Restore high byte.
  101                        	
  102    02:C0B4  88         	.no_add:	dey				; Do next bit.
  103    02:C0B5  D0 DE      			bne	.bit_loop
  104                        	
  105    02:C0B7  85 9B      			sta	<random + 3		; Save CRC-32 high-byte.
  106                        	
  107                        			leave				; All done!
         02:C0B9  4C EF FF   			jmp	leave_proc
  108                        	
  109                        			.endp
  110                        	
  111                        	
  112                        	
  113                        	; ***************************************************************************
  114                        	; ***************************************************************************
  115                        	;
  116                        	; get_random - 8-bit LFSR pseudo-random number with a 24-bit cycle.
  117                        	;
  118                        	; The pseudo-random sequence repeats after (2^24)-1 calls.
  119                        	;
  120                        	; Written by Wim Couwenberg, see ...
  121                        	;
  122                        	; "https://wimcouwenberg.wordpress.com/2020/11/15/ ...
  123                        	;  a-fast-24-bit-prng-algorithm-for-the-6502-processor/"
  124                        	;
  125                        	; Takes 68 cycles on the HuC6280, incl JSR & RTS.
  126                        	;
  127                        	; N.B. HuCC library code relies on this preserving X and Y!
  128                        	;
  129                        	
  130    00:E5C2  C2         	_rand8:		cly				; Entry point for HuCC.
  131                        	
  132    00:E5C3  A5 98      	get_random:	lda	<random + 0		; Operation 7 (with carry clear).
  133    00:E5C5  0A         			asl	a
  134    00:E5C6  45 99      			eor	<random + 1
  135    00:E5C8  85 99      			sta	<random + 1
  136    00:E5CA  2A         			rol	a             		; Operation 9.
  137    00:E5CB  45 9A      			eor	<random + 2
  138    00:E5CD  85 9A      			sta	<random + 2
  139    00:E5CF  45 98      			eor	<random + 0		; Operation 5.
  140    00:E5D1  85 98      			sta	<random + 0
  141    00:E5D3  A5 99      			lda	<random + 1		; Operation 15.
  142    00:E5D5  6A         			ror	a
  143    00:E5D6  45 9A      			eor	<random + 2
  144    00:E5D8  85 9A      			sta	<random + 2
  145    00:E5DA  45 99      			eor	<random + 1		; Operation 6.
  146    00:E5DC  85 99      			sta	<random + 1
  147    00:E5DE  60         			rts
  148                        	
  149                        	
  150                        	
  151               0000     		.if	0
  316                        		.endif
                             #[2]   "..\..\..\include\hucc\hucc-final.asm"
   48                        		.endif
   49                        	
   50                        			; Optional libraries that get used when their header files
   51                        			; are included in a HuCC project.
   52                        			;
   53                        			; When the HuCC compiler is invoked with the "--legacy"
   54                        			; option to compile old projects, then the "huc.h" file
   55                        			; is automatically included, which then includes a list
   56                        			; of specific headers corresponding to HuC's library.
   57                        	
   58               0001     		.ifdef	HUCC_USES_GFX
                             #[3]   "..\..\..\include\hucc\hucc-gfx.asm"
   59                        			include	"hucc-gfx.asm"		; Set in hucc_gfx.h
    1                        	; ***************************************************************************
    2                        	; ***************************************************************************
    3                        	;
    4                        	; huc-gfx.asm
    5                        	;
    6                        	; Based on the original HuC and MagicKit functions by David Michel and the
    7                        	; other original HuC developers.
    8                        	;
    9                        	; Modifications copyright John Brandwood 2024-2025.
   10                        	;
   11                        	; Distributed under the Boost Software License, Version 1.0.
   12                        	; (See accompanying file LICENSE_1_0.txt or copy at
   13                        	;  http://www.boost.org/LICENSE_1_0.txt)
   14                        	;
   15                        	; ***************************************************************************
   16                        	; ***************************************************************************
   17                        	
   18                        	;
   19                        	; Include dependancies ...
   20                        	;
   21                        	
   22                        			include "common.asm"		; Common helpers.
   23                        			include "vce.asm"		; Useful VCE routines.
   24                        			include "vdc.asm"		; Useful VCE routines.
   25                        	
   26                        	
   27                        	
   28                        	; ***************************************************************************
   29                        	; ***************************************************************************
   30                        	;
   31                        	; void __fastcall disp_on( void );
   32                        	; void __fastcall disp_off( void );
   33                        	
   34    00:E5DF             			.alias	_disp_on		= set_dspon
   35    00:E5DF             			.alias	_disp_off		= set_dspoff
   36                        	
   37                        	
   38                        	
   39                        	; ***************************************************************************
   40                        	; ***************************************************************************
   41                        	;
   42                        	; void __fastcall set_screen_size( unsigned char value<_al> );
   43                        	; void __fastcall sgx_set_screen_size( unsigned char value<_al> );
   44                        	;
   45                        	
   46    00:E5DF             			.alias	_set_screen_size.1	= set_bat_vdc
   47    00:E5DF             			.alias	_sgx_set_screen_size.1	= set_bat_sgx
   48                        	
   49                        	
   50                        	
   51                        	; ***************************************************************************
   52                        	; ***************************************************************************
   53                        	;
   54                        	; void __fastcall init_256x224( void );
   55                        	
   56    0D:DE84             	_init_256x224	.proc
   57                        	
   58               0800     	.BAT_SIZE	=	64 * 32
   59               0080     	.CHR_0x20	=	.BAT_SIZE / 16		; 1st tile # after the BAT.
   60               7F00     	.SAT_ADDR	=	$7F00			; SAT takes 16 tiles of VRAM.
   61                        	
   62    0D:DE84  08         			php				; Disable interrupts.
   63    0D:DE85  78         			sei
   64                        	
   65    0D:DE86  20 B9 FE   			call	clear_vce		; Clear all palettes.
   66                        	
   67    0D:DE89  A9 80      			lda.l	#.CHR_0x20		; CHR # of ASCII ' '.
   68    0D:DE8B  85 F8      			sta.l	<_ax
   69    0D:DE8D  A9 00      			lda.h	#.CHR_0x20
   70    0D:DE8F  85 F9      			sta.h	<_ax
   71                        	
   72    0D:DE91  A9 08      			lda	#>.BAT_SIZE		; Size of BAT in words.
   73    0D:DE93  85 FA      			sta	<_bl
   74                        	
   75    0D:DE95  20 CD FE   			call	clear_vram_vdc		; Clear VRAM.
   76               0001     		.if	SUPPORT_SGX
   77    0D:DE98  20 AF FE   			call	clear_vram_sgx
   78                        		.endif
   79                        	
   80    0D:DE9B  A9 BF      			lda	#<.mode_256x224		; Disable BKG & SPR layers but
   81    0D:DE9D  85 EC      			sta.l	<_bp			; enable RCR & VBLANK IRQ.
   82    0D:DE9F  A9 DE      			lda	#>.mode_256x224
   83    0D:DEA1  85 ED      			sta.h	<_bp
   84                        	
   85               0001     		.if	SUPPORT_SGX
   86    0D:DEA3  20 A5 FE   			call	sgx_detect		; Are we really on an SGX?
   87    0D:DEA6  90 05      			bcc	!+
   88    0D:DEA8  A0 0D      			ldy	#^.mode_256x224		; Set SGX 1st, with no VBL.
   89    0D:DEAA  20 9B FE   			call	set_mode_sgx
   90                        		.endif
   91    0D:DEAD  A0 0D      	!:		ldy	#^.mode_256x224		; Set VDC 2nd, VBL allowed.
   92    0D:DEAF  20 91 FE   			call	set_mode_vdc
   93                        	
   94               0001     		.if	SUPPORT_SGX
   95    0D:DEB2  2C 10 02   			bit	SGX_SR			; Purge any overdue RCR.
   96                        		.endif
   97    0D:DEB5  2C 00 02   			bit	VDC_SR			; Purge any overdue VBL.
   98    0D:DEB8  28         			plp				; Restore interrupts.
   99                        	
  100    0D:DEB9  20 09 E3   			call	wait_vsync		; Wait for the next VBLANK.
  101                        	
  102                        			leave				; All done, phew!
         0D:DEBC  4C EF FF   			jmp	leave_proc
  103                        	
  104                        			; A standard 256x224 screen with overscan.
  105                        	
  106    0D:DEBF  80         	.mode_256x224:	db	$80			; VCE Control Register.
  107    0D:DEC0  04         			db	VCE_CR_5MHz + XRES_SOFT	;   Video Clock + Artifact Reduction
  108                        	
  109    0D:DEC1  09         			db	VDC_MWR			; Memory-access Width Register
  110    0D:DEC2  10 00      			dw	VDC_MWR_64x32 + VDC_MWR_1CYCLE
  111    0D:DEC4  0A         			db	VDC_HSR			; Horizontal Sync Register
  112    0D:DEC5  02 02      			dw	VDC_HSR_256
  113    0D:DEC7  0B         			db	VDC_HDR			; Horizontal Display Register
  114    0D:DEC8  1F 04      			dw	VDC_HDR_256
  115    0D:DECA  0C         			db	VDC_VPR			; Vertical Sync Register
  116    0D:DECB  02 17      			dw	VDC_VPR_224
  117    0D:DECD  0D         			db	VDC_VDW			; Vertical Display Register
  118    0D:DECE  DF 00      			dw	VDC_VDW_224
  119    0D:DED0  0E         			db	VDC_VCR			; Vertical Display END position Register
  120    0D:DED1  FF 00      			dw	VDC_VCR_224
  121    0D:DED3  0F         			db	VDC_DCR			; DMA Control Register
  122    0D:DED4  10 00      			dw	$0010			;   Enable automatic VRAM->SATB
  123    0D:DED6  13         			db	VDC_DVSSR		; VRAM->SATB address $7F00
  124    0D:DED7  00 7F      			dw	.SAT_ADDR
  125    0D:DED9  07         			db	VDC_BXR			; Background X-Scroll Register
  126    0D:DEDA  00 00      			dw	$0000
  127    0D:DEDC  08         			db	VDC_BYR			; Background Y-Scroll Register
  128    0D:DEDD  00 00      			dw	$0000
  129    0D:DEDF  06         			db	VDC_RCR			; Raster Counter Register
  130    0D:DEE0  00 00      			dw	$0000			;   Never occurs!
  131    0D:DEE2  05         			db	VDC_CR			; Control Register
  132    0D:DEE3  0C 00      			dw	$000C			;   Enable VSYNC & RCR IRQ
  133    0D:DEE5  00         			db	0
  134                        	
  135                        			.endp
  136                        	
  137                        	
  138                        	
  139                        	; ***************************************************************************
  140                        	; ***************************************************************************
  141                        	;
  142                        	; void __fastcall init_240x208( void );
  143                        	
  144                        	_init_240x208	.proc
  223                        			.endp
  224                        	
  225                        	
  226                        	
  227                        	; ***************************************************************************
  228                        	; ***************************************************************************
  229                        	;
  230                        	; void __fastcall _macro set_xres( unsigned int x_pixels<_ax> );
  231                        	; void __fastcall _macro sgx_set_xres( unsigned int x_pixels<_ax> );
  232                        	;
  233                        	; void __fastcall set_xres( unsigned int x_pixels<_ax>, unsigned char blur_flag<_bl> );
  234                        	; void __fastcall sgx_set_xres( unsigned int x_pixels<_ax>, unsigned char blur_flag<_bl> );
  235                        	;
  236                        	; blur_flag = XRES_SOFT (default if not specified), XRES_SHARP or XRES_KEEP
  237                        	
  238                        	set_xres_group	.procgroup			; These routines share code!
  337                        			.endprocgroup	; set_xres_group
  338                        	
  339                        	
  340                        	
  341                        	; ***************************************************************************
  342                        	; ***************************************************************************
  343                        	;
  344                        	; HuC VRAM Functions
  345                        	;
  346                        	; ***************************************************************************
  347                        	; ***************************************************************************
  348                        	
  349                        	
  350    0D:DD4D             	load_vram_group	.procgroup			; These routines share code!
  351                        	
  352                        	; ***************************************************************************
  353                        	; ***************************************************************************
  354                        	;
  355                        	; void __fastcall load_vram( unsigned int vram<_di>, unsigned char __far *data<_bp_bank:_bp>, unsigned int num_words<_ax> );
  356                        	; void __fastcall sgx_load_vram( unsigned int vram<_di>, unsigned char __far *data<_bp_bank:_bp>, unsigned int num_words<_ax> );
  357                        	;
  358                        	; void __fastcall far_load_vram( unsigned int vram<_di>, unsigned int num_words<_ax> );
  359                        	; void __fastcall sgx_far_load_vram( unsigned int vram<_di>, unsigned int num_words<_ax> );
  360                        	;
  361                        	; load_vram_sgx -  copy a block of memory to VRAM
  362                        	; load_vram_vdc -  copy a block of memory to VRAM
  363                        	;
  364                        	; _bp		= BAT memory location
  365                        	; _bp_bank	= BAT bank
  366                        	; _di		= VRAM base address
  367                        	; _ax		= nb of words to copy
  368                        	; ----
  369                        	; N.B. BAT data *must* be word-aligned!
  370                        	
  371               0000     		.ifndef	VRAM_XFER_SIZE
  373                        		.endif
  374                        	
  375    0D:DD4D             	load_vram_x	.proc
  376                        	
  377    0D:DD4D  43 08      			tma3
  378    0D:DD4F  48         			pha
  379    0D:DD50  43 10      			tma4
  380    0D:DD52  48         			pha
  381                        	
  382    0D:DD53  A4 02      			ldy	<_bp_bank
  383    0D:DD55  20 3B E3   			jsr	map_bp_to_mpr34		; Map data to MPR3 & MPR4.
  384                        	
  385    0D:DD58  20 7F E3   			jsr	set_di_to_mawr
  386                        	
  387                        	;		tii	.vdc_tai, ram_tia, 8
  388                        	
  389               0001     		.if	SUPPORT_SGX
  390    0D:DD5B  8A         			txa				; Select which VDC to write
  391    0D:DD5C  1A         			inc	a			; to.
  392    0D:DD5D  1A         			inc	a
  393    0D:DD5E  8D F3 22   			sta.l	ram_tia_dst
  394                        		.endif
  395                        	
  396    0D:DD61  A9 10      			lda	#VRAM_XFER_SIZE		; Split into 16-byte chunks
  397    0D:DD63  8D F5 22   			sta.l	ram_tia_len		; for stable IRQ response.
  398                        	
  399    0D:DD66  A6 EC      			ldx.l	<_bp
  400    0D:DD68  8E F1 22   			stx.l	ram_tia_src
  401    0D:DD6B  A4 ED      			ldy.h	<_bp
  402    0D:DD6D  8C F2 22   			sty.h	ram_tia_src
  403                        	
  404    0D:DD70  A5 F8      			lda.l	<_ax			; Length in words.
  405    0D:DD72  48         			pha				; Preserve length.l
  406                        	
  407    0D:DD73  46 F9      			lsr.h	<_ax
  408    0D:DD75  6A         			ror	a
  409    0D:DD76  46 F9      			lsr.h	<_ax
  410    0D:DD78  6A         			ror	a
  411    0D:DD79  46 F9      			lsr.h	<_ax
  412    0D:DD7B  6A         			ror	a
  413               0000     		.if	VRAM_XFER_SIZE == 32
  416                        		.endif
  417                        	
  418    0D:DD7C  22         			sax				; x=chunks-lo
  419    0D:DD7D  F0 1F      			beq	.next_block		; a=source-lo, y=source-hi
  420                        	
  421    0D:DD7F  20 F0 22   	.chunk_loop:	jsr	ram_tia			; transfer 16-bytes
  422                        	
  423    0D:DD82  18         			clc				; increment source
  424    0D:DD83  69 10      			adc	#VRAM_XFER_SIZE
  425    0D:DD85  8D F1 22   			sta.l	ram_tia_src
  426    0D:DD88  90 11      			bcc	.same_page
  427    0D:DD8A  C8         			iny
  428    0D:DD8B  10 0B      			bpl	.same_bank		; remap_data
  429                        	
  430    0D:DD8D  42         			say
  431    0D:DD8E  43 10      			tma4
  432    0D:DD90  53 08      			tam3
  433    0D:DD92  1A         			inc	a
  434    0D:DD93  53 10      			tam4
  435    0D:DD95  A9 60      			lda	#$60
  436    0D:DD97  42         			say
  437                        	
  438    0D:DD98  8C F2 22   	.same_bank:	sty.h	ram_tia_src
  439                        	
  440    0D:DD9B  CA         	.same_page:	dex
  441    0D:DD9C  D0 E1      			bne	.chunk_loop
  442                        	
  443    0D:DD9E  C6 F9      	.next_block:	dec.h	<_ax
  444    0D:DDA0  10 DD      			bpl	.chunk_loop
  445                        	
  446    0D:DDA2  68         			pla				; Restore length.l
  447    0D:DDA3  29 07      			and	#VRAM_XFER_SIZE / 2 - 1
  448    0D:DDA5  F0 07      			beq	.done
  449                        	
  450    0D:DDA7  0A         			asl	a			; Convert words to bytes.
  451    0D:DDA8  8D F5 22   			sta.l	ram_tia_len
  452                        	
  453    0D:DDAB  20 F0 22   			jsr	ram_tia			; transfer remainder
  454                        	
  455    0D:DDAE  68         	.done:		pla
  456    0D:DDAF  53 10      			tam4
  457    0D:DDB1  68         			pla
  458    0D:DDB2  53 08      			tam3
  459                        	
  460                        			leave
         0D:DDB4  4C EF FF   			jmp	leave_proc
  461                        	
  462                        			.endp
  463                        	
  464                        			.endprocgroup	; load_vram_group
  465                        	
  466                        	
  467                        	
  468                        	; ***************************************************************************
  469                        	; ***************************************************************************
  470                        	;
  471                        	; void __fastcall load_bat( unsigned int vram<_di>, unsigned char __far *data<_bp_bank:_bp>, unsigned char tiles_w<_al>, unsigned char tiles_h<_ah> );
  472                        	; void __fastcall sgx_load_bat( unsigned int vram<_di>, unsigned char __far *data<_bp_bank:_bp>, unsigned char tiles_w<_al>, unsigned char tiles_h<_ah> );
  473                        	;
  474                        	; void __fastcall far_load_bat( unsigned int vram<_di>, unsigned char tiles_w<_al>, unsigned char tiles_h<_ah> );
  475                        	; void __fastcall sgx_far_load_bat( unsigned int vram<_di>, unsigned char tiles_w<_al>, unsigned char tiles_h<_ah> );
  476                        	;
  477                        	; load_bat_sgx - transfer a BAT to VRAM
  478                        	; load_bat_vdc - transfer a BAT to VRAM
  479                        	;
  480                        	; transfer a BAT to VRAM
  481                        	; ----
  482                        	; _bp		= BAT memory location
  483                        	; _bp_bank	= BAT bank
  484                        	; _di		= VRAM base address
  485                        	; _al		= nb of column to copy
  486                        	; _ah		= nb of row
  487                        	; ----
  488                        	; N.B. BAT data *must* be word-aligned!
  489                        	
  490               20EC     	_gfx_load_bat_PARM_2	=	_bp
  491               20F0     	_gfx_load_bat_PARM_3	=	_di
  492               20F8     	_gfx_load_bat_PARM_4	=	_al
  493               20F9     	_gfx_load_bat_PARM_5	=	_ah
  494                        	
  495    0D:DFBF             	load_bat_group	.procgroup			; These routines share code!
  496                        	
  497               0001     		.if	SUPPORT_SGX
  498                        			.proc	_sgx_load_bat.4
  505                        			.endp
  506                        		.endif
  507                        	
  508    0D:DFBF             			.proc	_load_bat.4
  509    0D:DFBF             			.alias	_far_load_bat.3		= _load_bat.4
  510                        	
  511    0D:DFBF  82         			clx				; Offset to PCE VDC.
  512                        	
  513    0D:DFC0  43 08      			tma3
  514    0D:DFC2  48         			pha
  515                        	
  516    0D:DFC3  A4 02      			ldy	<_bp_bank
  517    0D:DFC5  20 2D E3   			jsr	map_bp_to_mpr3		; Map data to MPR3.
  518                        	
  519    0D:DFC8  A4 EC      			ldy.l	<_bp
  520    0D:DFCA  64 EC      			stz.l	<_bp
  521                        	
  522    0D:DFCC  20 7F E3   	.line_loop:	jsr	set_di_to_mawr
  523                        	
  524    0D:DFCF  A5 F8      			lda	<_al
  525    0D:DFD1  85 00      			sta	<__temp
  526    0D:DFD3  B1 EC      	.tile_loop:	lda	[_bp], y
  527    0D:DFD5  9D 02 02   			sta	VDC_DL, x
  528    0D:DFD8  C8         			iny
  529    0D:DFD9  B1 EC      			lda	[_bp], y
  530    0D:DFDB  9D 03 02   			sta	VDC_DH, x
  531    0D:DFDE  C8         			iny
  532    0D:DFDF  D0 03      			bne	!+
  533    0D:DFE1  20 4C E3   			jsr	inc.h_bp_mpr3
  534    0D:DFE4  C6 00      	!:		dec	<__temp
  535    0D:DFE6  D0 EB      			bne	.tile_loop
  536                        	
  537    0D:DFE8  BD AF 24   			lda	vdc_bat_width, x
  538    0D:DFEB  18         			clc
  539    0D:DFEC  65 F0      			adc.l	<_di
  540    0D:DFEE  85 F0      			sta.l	<_di
  541    0D:DFF0  90 02      			bcc	!+
  542    0D:DFF2  E6 F1      			inc.h	<_di
  543                        	
  544    0D:DFF4  C6 F9      	!:		dec	<_ah
  545    0D:DFF6  D0 D4      			bne	.line_loop
  546                        	
  547    0D:DFF8  68         			pla
  548    0D:DFF9  53 08      			tam3
  549                        	
  550                        			leave
         0D:DFFB  4C EF FF   			jmp	leave_proc
  551                        	
  552                        			.endp
  553                        	
  554                        			.endprocgroup	; load_bat_group
  555                        	
  556                        	
  557                        	
  558                        	; ***************************************************************************
  559                        	; ***************************************************************************
  560                        	;
  561                        	; void __fastcall load_palette( unsigned char palette<_al>, unsigned char __far *data<_bp_bank:_bp>, unsigned char num_palettes<_ah> );
  562                        	;
  563                        	; void __fastcall far_load_palette( unsigned char palette<_al>, unsigned char num_palettes<_ah> );
  564                        	
  565    02:C0EA             			.proc	_load_palette.3
  566    02:C0EA             			.alias	_far_load_palette.2	= _load_palette.3
  567                        	
  568    02:C0EA  AC 86 24   			ldy	color_queue_w		; Get the queue's write index.
  569                        	
  570    02:C0ED  A5 EC      			lda.l	<_bp			; Add this set of palettes to
  571    02:C0EF  99 97 24   			sta	color_addr_l, y		; the queue.
  572    02:C0F2  A5 ED      			lda.h	<_bp
  573    02:C0F4  99 9F 24   			sta	color_addr_h, y
  574    02:C0F7  A5 02      			lda	<_bp_bank
  575    02:C0F9  99 A7 24   			sta	color_bank, y
  576    02:C0FC  A5 F8      			lda	<_al
  577    02:C0FE  99 87 24   			sta	color_index, y
  578    02:C101  A5 F9      			lda	<_ah
  579    02:C103  99 8F 24   			sta	color_count, y
  580                        	
  581    02:C106  C8         			iny				; Increment the queue index.
  582    02:C107  98         			tya
  583    02:C108  29 07      			and	#7
  584                        	
  585    02:C10A  CD 85 24   	.wait:		cmp	color_queue_r		; If the queue is full, wait
  586    02:C10D  F0 FB      			beq	.wait			; for the next VBLANK.
  587                        	
  588    02:C10F  8D 86 24   			sta	color_queue_w		; Signal item is in the queue.
  589                        	
  590                        			leave				; All done, phew!
         02:C112  4C EF FF   			jmp	leave_proc
  591                        	
  592                        			.endp
  593                        	
  594                        	
  595                        	
  596               0000     		.if	0
  620                        		.endif
  621                        	
  622                        	
  623                        	
  624                        	; ***************************************************************************
  625                        	; ***************************************************************************
  626                        	;
  627                        	; void __fastcall load_background( unsigned char __far *tiles<_bp_bank:_bp>, unsigned char __far *palettes<__fbank:__fptr>, unsigned char __far *bat<_cl:_bx>, unsigned char w<_dl>, unsigned char w<_dh> );
  628                        	
  629                        			.proc	_load_background.5
  667                        			.endp
  668                        	
  669                        	
  670                        	
  671                        	; ***************************************************************************
  672                        	; ***************************************************************************
  673                        	;
  674                        	; void __fastcall vram2vram( unsigned int vram_dst<_ax>, unsigned int vram_src<_bx>, unsigned int word_len<_cx> );
  675                        	; void __fastcall sgx_vram2vram( unsigned int vram_dst<_ax>, unsigned int vram_src<_bx>, unsigned int word_len<_cx> );
  676                        	;
  677                        	
  678               0001     		.if	SUPPORT_SGX
  679                        			.proc	_sgx_vram2vram.3
  685                        			.endp
  686                        		.endif
  687                        	
  688    02:C043             			.proc	_vram2vram.3
  689                        	
  690    02:C043  82         			clx				; Offset to PCE VDC.
  691                        	
  692    02:C044  08         			php
  693    02:C045  78         			sei
  694    02:C046  A9 11      			lda	#VDC_DESR
  695    02:C048  9D 00 02   			sta	VDC_AR, x
  696    02:C04B  A5 F8      			lda.l	<_ax
  697    02:C04D  9D 02 02   			sta	VDC_DL, x
  698    02:C050  A5 F9      			lda.h	<_ax
  699    02:C052  9D 03 02   			sta	VDC_DH, x
  700                        	
  701    02:C055  A9 10      			lda	#VDC_SOUR
  702    02:C057  9D 00 02   			sta	VDC_AR, x
  703    02:C05A  A5 FA      			lda.l	<_bx
  704    02:C05C  9D 02 02   			sta	VDC_DL, x
  705    02:C05F  A5 FB      			lda.h	<_bx
  706    02:C061  9D 03 02   			sta	VDC_DH, x
  707                        	
  708    02:C064  A9 12      			lda	#VDC_LENR
  709    02:C066  9D 00 02   			sta	VDC_AR, x
  710    02:C069  18         			clc
  711    02:C06A  A5 FC      			lda.l	<_cx
  712    02:C06C  69 FF      			adc	#$FF
  713    02:C06E  9D 02 02   			sta	VDC_DL, x
  714    02:C071  A5 FD      			lda.h	<_cx
  715    02:C073  69 FF      			adc	#$FF
  716    02:C075  9D 03 02   			sta	VDC_DH, x
  717                        	
  718    02:C078  B5 F7      			lda	<vdc_reg, x
  719    02:C07A  8D 00 02   			sta	VDC_AR
  720    02:C07D  28         			plp
  721                        	
  722                        			leave
         02:C07E  4C EF FF   			jmp	leave_proc
  723                        	
  724                        			.endp
  725                        	
  726                        	
  727                        	
  728                        	; ***************************************************************************
  729                        	; ***************************************************************************
  730                        	;
  731                        	; HuC Font Functions
  732                        	;
  733                        	; ***************************************************************************
  734                        	; ***************************************************************************
  735                        	
  736                        	
  737                        	
  738               24CF     			.bss
  739                        	
  740                        	; **************
  741                        	; 16-bytes of VDC BAT information.
  742                        	;
  743                        	; N.B. MUST be 16-bytes before the SGX versions to use PCE_VDC_OFFSET.
  744                        	
  745    F8:24CF             	_vdc_font_base:	ds	2	; Tile number of ASCII '\0'.
  746                        	
  747                        	; From hucc-printf.asm just to avoid wasting .bss space with padding.
  748    F8:24D1             	_vdc_tty_x_lhs:	ds	1	; TTY minimum X position.
  749    F8:24D2             	_vdc_tty_y_top:	ds	1	; TTY minimum Y position.
  750    F8:24D3             	_vdc_tty_x:	ds	1	; TTY current X position.
  751    F8:24D4             	_vdc_tty_y:	ds	1	; TTY current Y position.
  752                        	
  753               0001     		.if	SUPPORT_SGX
  754                        	
  755                        	; **************
  756                        	; 16-bytes of SGX BAT information.
  757                        	;
  758                        	; N.B. MUST be 16-bytes after the VDC versions to use SGX_VDC_OFFSET.
  759                        	
  760    F8:24D5             			ds	10	; Padding to ensure the 16-byte delta.
  761                        	
  762    F8:24DF             	_sgx_font_base:	ds	2	; Tile number of ASCII '\0'.
  763                        	
  764                        	; From hucc-printf.asm just to avoid wasting .bss space with padding.
  765    F8:24E1             	_sgx_tty_x_lhs:	ds	1	; TTY minimum X position.
  766    F8:24E2             	_sgx_tty_y_top:	ds	1	; TTY minimum Y position.
  767    F8:24E3             	_sgx_tty_x:	ds	1	; TTY current X position.
  768    F8:24E4             	_sgx_tty_y:	ds	1	; TTY current Y position.
  769                        	
  770                        		.endif
  771                        	
  772                        	;_font_base	.alias	vdc_font_base
  773                        	
  774               E5DF     			.code
  775                        	
  776                        	
  777                        	
  778                        	; ***************************************************************************
  779                        	; ***************************************************************************
  780                        	;
  781                        	; void __fastcall set_font_addr( unsigned int vram<acc> );
  782                        	; void __fastcall sgx_set_font_addr( unsigned int vram<acc> );
  783                        	
  784               0001     		.if	SUPPORT_SGX
  785    00:E5DF             	_sgx_set_font_addr.1:
  786    00:E5DF  A2 10      			ldx	#SGX_VDC_OFFSET		; Offset to SGX VDC.
  787    00:E5E1  F0         			db	$F0			; Turn "clx" into a "beq".
  788                        		.endif
  789                        	
  790    00:E5E2             	_set_font_addr.1:
  791    00:E5E2  82         			clx				; Offset to PCE VDC.
  792                        	
  793    00:E5E3  84 00      	set_font_addr:	sty	<__temp
  794    00:E5E5  46 00      			lsr	<__temp
  795    00:E5E7  6A         			ror	a
  796    00:E5E8  46 00      			lsr	<__temp
  797    00:E5EA  6A         			ror	a
  798    00:E5EB  46 00      			lsr	<__temp
  799    00:E5ED  6A         			ror	a
  800    00:E5EE  46 00      			lsr	<__temp
  801    00:E5F0  6A         			ror	a
  802    00:E5F1  38         			sec
  803    00:E5F2  E9 20      			sbc	#$20
  804    00:E5F4  9D CF 24   			sta.l	_vdc_font_base,x
  805    00:E5F7  B0 02      			bcs	!+
  806    00:E5F9  C6 00      			dec	<__temp
  807                        	
  808    00:E5FB  BD D0 24   	!:		lda.h	_vdc_font_base, x
  809    00:E5FE  29 F0      			and	#$F0
  810    00:E600  05 00      			ora	<__temp
  811    00:E602  9D D0 24   			sta.h	_vdc_font_base, x
  812    00:E605  60         			rts
  813                        	
  814                        	
  815                        	
  816                        	; ***************************************************************************
  817                        	; ***************************************************************************
  818                        	;
  819                        	; void __fastcall set_font_pal( unsigned char palette<acc> );
  820                        	; void __fastcall sgx_set_font_pal( unsigned char palette<acc> );
  821                        	
  822               0001     		.if	SUPPORT_SGX
  823    00:E606             	_sgx_set_font_pal.1:
  824    00:E606  A2 10      			ldx	#SGX_VDC_OFFSET		; Offset to SGX VDC.
  825    00:E608  F0         			db	$F0			; Turn "clx" into a "beq".
  826                        		.endif
  827                        	
  828    00:E609             	_set_font_pal:					; For compatibility with HuC.
  829    00:E609             	_set_font_pal.1:
  830    00:E609  82         			clx				; Offset to PCE VDC.
  831    00:E60A  0A         			asl	a
  832    00:E60B  0A         			asl	a
  833    00:E60C  0A         			asl	a
  834    00:E60D  0A         			asl	a
  835    00:E60E  85 00      			sta	<__temp
  836                        	
  837    00:E610  BD D0 24   			lda.h	_vdc_font_base, x
  838    00:E613  29 0F      			and	#$0F
  839    00:E615  05 00      			ora	<__temp
  840    00:E617  9D D0 24   			sta.h	_vdc_font_base, x
  841    00:E61A  60         			rts
  842                        	
  843                        	
  844                        	
  845                        	; ***************************************************************************
  846                        	; ***************************************************************************
  847                        	;
  848                        	; void __fastcall load_font( char far *font<_bp_bank:_bp>, unsigned char count<_al> );
  849                        	;
  850                        	; void __fastcall load_font( char far *font<_bp_bank:_bp>, unsigned char count<_al>, unsigned int vram<acc> );
  851                        	; void __fastcall sgx_load_font( char far *font<_bp_bank:_bp>, unsigned char count<_al>, unsigned int vram<acc> );
  852                        	;
  853                        	; void __fastcall far_load_font( unsigned char count<_al>, unsigned int vram<acc> );
  854                        	; void __fastcall sgx_far_load_font( unsigned char count<_al>, unsigned int vram<acc> );
  855                        	
  856    00:E61B  AC B3 24   	_load_font.2:	ldy	vdc_bat_limit		; Load the font directly
  857    00:E61E  C8         			iny				; after the BAT (stupid!).
  858    00:E61F  62         			cla
  859    00:E620  80 03      			bra	_load_font.3
  860                        	
  861               0001     		.if	SUPPORT_SGX
  862    00:E622             	_sgx_load_font.3:
  863    00:E622  A2 10      			ldx	#SGX_VDC_OFFSET		; Offset to SGX VDC.
  864    00:E624  F0         			db	$F0			; Turn "clx" into a "beq".
  865                        		.endif
  866                        	
  867    00:E625  82         	_load_font.3:	clx				; Offset to PCE VDC.
  868                        	
  869    00:E626  85 F0      			sta.l	<_di			; Load the font directly
  870    00:E628  84 F1      			sty.h	<_di			; after the BAT (stupid!).
  871                        	
  872    00:E62A  20 E3 E5   			jsr	set_font_addr		; Set xxx_font_base from addr.
  873                        	
  874    00:E62D  A5 F8      			lda	<__al			; Convert #tiles into #words.
  875    00:E62F  64 F9      			stz	<__ah
  876    00:E631  0A         			asl	a
  877    00:E632  26 F9      			rol	<__ah
  878    00:E634  0A         			asl	a
  879    00:E635  26 F9      			rol	<__ah
  880    00:E637  0A         			asl	a
  881    00:E638  26 F9      			rol	<__ah
  882    00:E63A  0A         			asl	a
  883    00:E63B  26 F9      			rol	<__ah
  884    00:E63D  85 F8      			sta	<__al
  885    00:E63F  4C 77 FF   			jmp	load_vram_x
  886                        	
  887    00:E642             			.alias	_far_load_font.2	= _load_font.3
  888    00:E642             			.alias	_sgx_far_load_font.2	= _sgx_load_font.3
  889                        	
  890                        	
  891                        	
  892                        	; ***************************************************************************
  893                        	; ***************************************************************************
  894                        	;
  895                        	; void __fastcall cls();
  896                        	; void __fastcall sgx_cls();
  897                        	;
  898                        	; void __fastcall cls( int tile<acc> );
  899                        	; void __fastcall sgx_cls( int tile<acc> );
  900                        	
  901               0001     		.if	SUPPORT_SGX
  902    00:E642  A2 10      	_sgx_cls:	ldx	#SGX_VDC_OFFSET		; Offset to SGX VDC.
  903    00:E644  F0         			db	$F0			; Turn "clx" into a "beq".
  904                        		.endif
  905                        	
  906    00:E645  82         	_cls:		clx				; Offset to PCE VDC.
  907                        	
  908    00:E646  BD CF 24   	clear_tty_x:	lda.l	_vdc_font_base, x
  909    00:E649  BC D0 24   			ldy.h	_vdc_font_base, x
  910    00:E64C  18         			clc
  911    00:E64D  69 20      			adc	#' '
  912    00:E64F  90 07      			bcc	!+
  913    00:E651  C8         			iny
  914    00:E652  80 04      			bra	!+
  915                        	
  916               0001     		.if	SUPPORT_SGX
  917    00:E654  A2 10      	_sgx_cls.1:	ldx	#SGX_VDC_OFFSET		; Offset to SGX VDC.
  918    00:E656  F0         			db	$F0			; Turn "clx" into a "beq".
  919                        		.endif
  920                        	
  921    00:E657  82         	_cls.1:		clx
  922                        	
  923    00:E658  85 F8      	!:		sta.l	<_ax			; VRAM word to write.
  924    00:E65A  84 F9      			sty.h	<_ax
  925    00:E65C  BD B3 24   			lda	vdc_bat_limit, x	; BAT size hi-byte.
  926    00:E65F  1A         			inc	a
  927    00:E660  85 FA      			sta	<_bl
  928    00:E662  4C C3 FE   			jmp	clear_bat_x
  929                        	
  930                        	
  931                        	
  932                        	; ***************************************************************************
  933                        	; ***************************************************************************
  934                        	;
  935                        	; void __fastcall __macro load_default_font( void );
  936                        	; void __fastcall __macro sgx_load_default_font( void );
  937                        	;
  938                        	; Args: _bp, _bp_bank = _farptr to font data mapped into MPR3 & MPR4.
  939                        	; Args: _di = VRAM destination address.
  940                        	; Args: monofont_fg = font color (0..15)
  941                        	; Args: monofont_bg = background color (0..15)
  942                        	; Args: _al = number of tiles (aka characters) 0==256
  943                        	
  944    0D:D337             	huc_monofont_x	.proc
  945                        	
  946               24E5     			.bss
  947    F8:24E5             	monofont_fg:	.ds	1
  948    F8:24E6             	monofont_bg:	.ds	1
  949               D337     			.code
  950                        	
  951    0D:D337  BC B3 24   			ldy	vdc_bat_limit, x	; BAT limit mask hi-byte.
  952    0D:D33A  C8         			iny
  953    0D:D33B  62         			cla
  954    0D:D33C  85 F0      			sta.l	<_di			; Load the font directly
  955    0D:D33E  84 F1      			sty.h	<_di			; after the BAT (stupid!).
  956                        	
  957    0D:D340  20 E3 E5   			jsr	set_font_addr		; Set xxx_font_base from addr.
  958                        	
  959    0D:D343  A9 C7      			lda.l	#.font
  960    0D:D345  85 EC      			sta.l	<_bp
  961    0D:D347  A9 D3      			lda.h	#.font
  962    0D:D349  85 ED      			sta.h	<_bp
  963                        	
  964    0D:D34B  A9 60      			lda	#$60			; #characters.
  965    0D:D34D  85 F8      			sta	<_al
  966                        	
  967    0D:D34F  20 7F E3   			jsr	set_di_to_mawr
  968                        	
  969    0D:D352  AD E5 24   			lda	monofont_fg		; Foreground pixel color.
  970    0D:D355  85 00      			sta	<__temp
  971    0D:D357  AD E6 24   			lda	monofont_bg		; Background pixel color.
  972    0D:D35A  DA         			phx
  973    0D:D35B  A2 FC      			ldx.l	#_cx			; Create a bit mask for each
  974    0D:D35D  9E 00 20   	.bg_loop:	stz	$2000, x		; plane of the background.
  975    0D:D360  4A         			lsr	a
  976    0D:D361  90 03      			bcc	.bg_plane
  977    0D:D363  DE 00 20   			dec	$2000, x
  978    0D:D366  E8         	.bg_plane:	inx
  979    0D:D367  D0 F4      			bne	.bg_loop
  980    0D:D369  FA         			plx
  981                        	
  982    0D:D36A  C2         	.tile_loop:	cly
  983                        	
  984    0D:D36B  B1 EC      	.plane01:	lda	[_bp], y		; Get font byte.
  985    0D:D36D  8F 00 06   			bbs0	<__temp, .set_plane0
  986    0D:D370  49 FF      	.clr_plane0:	eor	#$FF			; Clr font bits in background.
  987    0D:D372  25 FC      			and	<_cx + 0
  988    0D:D374  80 02      			bra	.put_plane0
  989    0D:D376  05 FC      	.set_plane0:	ora	<_cx + 0		; Set font bits in background.
  990    0D:D378  9D 02 02   	.put_plane0:	sta	VDC_DL, x
  991                        	
  992    0D:D37B  B1 EC      			lda	[_bp], y		; Get font byte.
  993    0D:D37D  9F 00 06   			bbs1	<__temp, .set_plane1
  994    0D:D380  49 FF      	.clr_plane1:	eor	#$FF			; Clr font bits in background.
  995    0D:D382  25 FD      			and	<_cx + 1
  996    0D:D384  80 02      			bra	.put_plane1
  997    0D:D386  05 FD      	.set_plane1:	ora	<_cx + 1		; Set font bits in background.
  998    0D:D388  9D 03 02   	.put_plane1:	sta	VDC_DH, x
  999                        	
 1000    0D:D38B  C8         			iny
 1001    0D:D38C  C0 08      			cpy	#8
 1002    0D:D38E  90 DB      			bcc	.plane01
 1003                        	
 1004    0D:D390  C2         			cly
 1005                        	
 1006    0D:D391  B1 EC      	.plane23:	lda	[_bp], y		; Get font byte.
 1007    0D:D393  AF 00 06   			bbs2	<__temp, .set_plane2
 1008    0D:D396  49 FF      	.clr_plane2:	eor	#$FF			; Clr font bits in background.
 1009    0D:D398  25 FE      			and	<_cx + 2
 1010    0D:D39A  80 02      			bra	.put_plane2
 1011    0D:D39C  05 FE      	.set_plane2:	ora	<_cx + 2		; Set font bits in background.
 1012    0D:D39E  9D 02 02   	.put_plane2:	sta	VDC_DL, x
 1013                        	
 1014    0D:D3A1  B1 EC      			lda	[_bp], y		; Get font byte.
 1015    0D:D3A3  BF 00 06   			bbs3	<__temp, .set_plane3
 1016    0D:D3A6  49 FF      	.clr_plane3:	eor	#$FF			; Clr font bits in background.
 1017    0D:D3A8  25 FF      			and	<_cx + 3
 1018    0D:D3AA  80 02      			bra	.put_plane3
 1019    0D:D3AC  05 FF      	.set_plane3:	ora	<_cx + 3		; Set font bits in background.
 1020    0D:D3AE  9D 03 02   	.put_plane3:	sta	VDC_DH, x
 1021                        	
 1022    0D:D3B1  C8         			iny
 1023    0D:D3B2  C0 08      			cpy	#8
 1024    0D:D3B4  90 DB      			bcc	.plane23
 1025                        	
 1026    0D:D3B6  A5 EC      			lda.l	<_bp
 1027    0D:D3B8  69 07      			adc	#8-1
 1028    0D:D3BA  85 EC      			sta.l	<_bp
 1029    0D:D3BC  90 02      			bcc	!+
 1030    0D:D3BE  E6 ED      			inc.h	<_bp
 1031                        	
 1032    0D:D3C0  C6 F8      	!:		dec	<_al
 1033    0D:D3C2  D0 A6      			bne	.tile_loop
 1034                        	
 1035                        			leave				; All done, phew!
         0D:D3C4  4C EF FF   			jmp	leave_proc
 1036                        	
 1037    0D:D3C7             	.font:		incbin	"data/font8x8-bold-short-iso646-fr.dat", 128
 1038                        	
 1039                        			.endp
 1040                        	
 1041                        	
 1042                        	
 1043                        	; ***************************************************************************
 1044                        	; ***************************************************************************
 1045                        	;
 1046                        	; HuC Text Output
 1047                        	;
 1048                        	; ***************************************************************************
 1049                        	; ***************************************************************************
 1050                        	
 1051                        	
 1052                        	
 1053    0D:DDB7             	vdc_tty_out	.procgroup			; These routines share code!
 1054                        	
 1055                        	; ***************************************************************************
 1056                        	; ***************************************************************************
 1057                        	;
 1058                        	; void __fastcall put_char( unsigned char digit<_bl>, unsigned char bat_x<_dil>, unsigned char bat_y<_dih> );
 1059                        	
 1060               0001     		.if	SUPPORT_SGX
 1061                        	put_char_sgx	.proc
 1067                        			.endp
 1068                        		.endif
 1069                        	
 1070    0D:DDB7             	put_char_vdc	.proc
 1071                        	
 1072    0D:DDB7  82         			clx				; Offset to PCE VDC.
 1073                        	
 1074    0D:DDB8  20 34 E4   			jsr	set_di_xy_mawr
 1075                        	
 1076    0D:DDBB  62         			cla				; Push EOL marker.
 1077    0D:DDBC  48         			pha
 1078                        	
 1079    0D:DDBD  A5 FA      			lda	<_bl
 1080    0D:DDBF  48         			pha				; Push character to output.
 1081    0D:DDC0  80 58      			bra	!output+
 1082                        	
 1083    0D:DDC2             			.ref	put_hex_vdc		; Need put_number_vdc
 1084                        			.endp
 1085                        	
 1086    0D:DDC2             			.alias	_put_char.3		= put_char_vdc
 1087                        	
 1088                        	
 1089                        	
 1090                        	; ***************************************************************************
 1091                        	; ***************************************************************************
 1092                        	;
 1093                        	; void __fastcall put_digit( unsigned char digit<_bl>, unsigned char bat_x<_dil>, unsigned char bat_y<_dih> );
 1094                        	
 1095               0001     		.if	SUPPORT_SGX
 1096                        	put_digit_sgx	.proc
 1102                        			.endp
 1103                        		.endif
 1104                        	
 1105    0D:DDC2             	put_digit_vdc	.proc
 1106                        	
 1107    0D:DDC2  82         			clx				; Offset to PCE VDC.
 1108                        	
 1109    0D:DDC3  20 34 E4   			jsr	set_di_xy_mawr
 1110                        	
 1111    0D:DDC6  62         			cla				; Push EOL marker.
 1112    0D:DDC7  48         			pha
 1113                        	
 1114    0D:DDC8  A5 FA      			lda	<_bl			; Convert hex digit to ASCII.
 1115    0D:DDCA  29 0F      			and	#$0F
 1116    0D:DDCC  C9 0A      			cmp	#10
 1117    0D:DDCE  90 02      			bcc	!+
 1118    0D:DDD0  69 06      			adc	#6
 1119    0D:DDD2  69 30      	!:		adc	#'0'
 1120    0D:DDD4  48         			pha				; Push character to output.
 1121    0D:DDD5  80 43      			bra	!output+
 1122                        	
 1123    0D:DDD7             			.ref	put_hex_vdc		; Need put_number_vdc
 1124                        			.endp
 1125                        	
 1126    0D:DDD7             			.alias	_put_digit.3		= put_digit_vdc
 1127                        	
 1128                        	
 1129                        	
 1130                        	; ***************************************************************************
 1131                        	; ***************************************************************************
 1132                        	;
 1133                        	; void __fastcall put_hex( unsigned int number<_bx>, unsigned char length<_cl>, unsigned char bat_x<_dil>, unsigned char bat_y<_dih> );
 1134                        	
 1135               0001     		.if	SUPPORT_SGX
 1136                        	put_hex_sgx	.proc
 1141                        			.endp
 1142                        		.endif
 1143                        	
 1144    0D:DDD7             	put_hex_vdc	.proc
 1145                        	
 1146    0D:DDD7  82         			clx				; Offset to PCE VDC.
 1147                        	
 1148    0D:DDD8  20 34 E4   			jsr	set_di_xy_mawr
 1149                        	
 1150    0D:DDDB  A4 FC      			ldy	<_cl			; Total #characters to print,
 1151    0D:DDDD  F0 3E      			beq	!exit+			; NOT minimum #characters!
 1152                        	
 1153    0D:DDDF  86 00      			stx	<__temp			; Preserve which VDC.
 1154                        	
 1155    0D:DDE1  82         			clx				; Push EOL marker.
 1156    0D:DDE2  DA         			phx
 1157                        	
 1158    0D:DDE3  B5 FA      	.hex_byte:	lda.l	<_bx, x			; Convert hex digit to ASCII.
 1159    0D:DDE5  29 0F      			and	#$0F
 1160    0D:DDE7  C9 0A      			cmp	#10
 1161    0D:DDE9  90 02      			bcc	!+
 1162    0D:DDEB  69 06      			adc	#6
 1163    0D:DDED  69 30      	!:		adc	#'0'
 1164    0D:DDEF  48         			pha				; Push character to output.
 1165    0D:DDF0  88         			dey
 1166    0D:DDF1  F0 15      			beq	.hex_done
 1167                        	
 1168    0D:DDF3  B5 FA      			lda.l	<_bx, x			; Convert hex digit to ASCII.
 1169    0D:DDF5  4A         			lsr	a
 1170    0D:DDF6  4A         			lsr	a
 1171    0D:DDF7  4A         			lsr	a
 1172    0D:DDF8  4A         			lsr	a
 1173    0D:DDF9  C9 0A      			cmp	#10
 1174    0D:DDFB  90 02      			bcc	!+
 1175    0D:DDFD  69 06      			adc	#6
 1176    0D:DDFF  69 30      	!:		adc	#'0'
 1177    0D:DE01  48         			pha				; Push character to output.
 1178    0D:DE02  88         			dey
 1179    0D:DE03  F0 03      			beq	.hex_done
 1180                        	
 1181    0D:DE05  E8         			inx
 1182    0D:DE06  80 DB      			bra	.hex_byte
 1183                        	
 1184    0D:DE08  A6 00      	.hex_done:	ldx	<__temp			; Restore which VDC.
 1185    0D:DE0A  80 0E      			bra	!output+
 1186                        	
 1187    0D:DE0C  18         	.write:		clc
 1188    0D:DE0D  7D CF 24   			adc.l	_vdc_font_base, x
 1189    0D:DE10  9D 02 02   			sta	VDC_DL, x
 1190    0D:DE13  62         			cla
 1191    0D:DE14  7D D0 24   			adc.h	_vdc_font_base, x
 1192    0D:DE17  9D 03 02   			sta	VDC_DH, x
 1193                        	
 1194    0D:DE1A  68         	!output:	pla				; Pop the digits and output.
 1195    0D:DE1B  D0 EF      			bne	.write
 1196                        	
 1197                        	!exit:		leave				; All done!
         0D:DE1D  4C EF FF   			jmp	leave_proc
 1198                        	
 1199                        			.endp
 1200                        	
 1201    0D:DE20             			.alias	_put_hex.4 = put_hex_vdc
 1202                        	
 1203                        	
 1204                        	
 1205                        	; ***************************************************************************
 1206                        	; ***************************************************************************
 1207                        	;
 1208                        	; void __fastcall put_number( unsigned int number<_bx>, unsigned char length<_cl>, unsigned char bat_x<_dil>, unsigned char bat_y<_dih> );
 1209                        	
 1210               0001     		.if	SUPPORT_SGX
 1211                        	put_number_sgx	.proc
 1216                        			.endp
 1217                        		.endif
 1218                        	
 1219                        	put_number_vdc	.proc
 1285                        			.endp
 1286                        	
 1287    0D:DE20             			.alias	_put_number.4 = put_number_vdc
 1288                        	
 1289                        	
 1290                        	
 1291                        	; ***************************************************************************
 1292                        	; ***************************************************************************
 1293                        	;
 1294                        	; void __fastcall put_raw( unsigned int data<_bx>, unsigned char bat_x<_dil>, unsigned char bat_y<_dih> );
 1295                        	
 1296               0001     		.if	SUPPORT_SGX
 1297                        	put_raw_sgx	.proc
 1302                        			.endp
 1303                        		.endif
 1304                        	
 1305                        	put_raw_vdc	.proc
 1318                        			.endp
 1319                        	
 1320    0D:DE20             			.alias	_put_raw.3		= put_raw_vdc
 1321                        	
 1322                        			.endprocgroup			; vdc_tty_out
 1323                        	
 1324                        	
 1325                        	
 1326                        	; ***************************************************************************
 1327                        	; ***************************************************************************
 1328                        	;
 1329                        	; void __fastcall put_string( unsigned char *string<_bp>, unsigned char bat_x<_dil>, unsigned char bat_y<_dih> );
 1330                        	;
 1331                        	; N.B. This is not a .proc right now because it is called from procedures
 1332                        	; that contain embedded strings, and the string aren't banked in before
 1333                        	; printing (yet).
 1334                        	
 1335               0001     		.if	SUPPORT_SGX
 1336    00:E665             	_sgx_put_string.3:
 1337    00:E665  A2 10      			ldx	#SGX_VDC_OFFSET		; Offset to SGX VDC.
 1338    00:E667  F0         			db	$F0			; Turn "clx" into a "beq".
 1339                        		.endif
 1340                        	
 1341    00:E668  82         	_put_string.3:	clx				; Offset to PCE VDC.
 1342                        	
 1343    00:E669  20 34 E4   			jsr	set_di_xy_mawr
 1344                        	
 1345    00:E66C  C2         			cly
 1346    00:E66D  B1 EC      	.chr_loop:	lda	[_bp], y
 1347    00:E66F  F0 15      			beq	.done
 1348                        	
 1349    00:E671  18         			clc
 1350    00:E672  7D CF 24   			adc.l	_vdc_font_base, x
 1351    00:E675  9D 02 02   			sta	VDC_DL, x
 1352    00:E678  62         			cla
 1353    00:E679  7D D0 24   			adc.h	_vdc_font_base, x
 1354    00:E67C  9D 03 02   			sta	VDC_DH, x
 1355                        	
 1356    00:E67F  C8         			iny
 1357    00:E680  D0 EB      			bne	.chr_loop
 1358    00:E682  E6 ED      			inc.h	<_bp
 1359    00:E684  80 E7      			bra	.chr_loop
 1360                        	
 1361    00:E686  60         	.done:		rts
 1362                        	
 1363                        	
 1364                        	
 1365                        	; ***************************************************************************
 1366                        	; ***************************************************************************
 1367                        	;
 1368                        	; void __fastcall set_color_rgb( unsigned int index<VCE_CTA>, unsigned char r<_al>, unsigned char g<_ah>, unsigned char b<acc> );
 1369                        	;
 1370                        	; r:	red	RED:	bit 3-5
 1371                        	; g:	green	GREEN:	bit 6-8
 1372                        	; b:	blue	BLUE:	bit 0-2
 1373                        	
 1374    00:E687             	_set_color_rgb.4:
 1375                        	;		and	#7
 1376    00:E687  85 00      			sta	<__temp
 1377    00:E689  A5 F8      			lda	<_al
 1378                        	;		and	#7
 1379    00:E68B  0A         			asl	a
 1380    00:E68C  0A         			asl	a
 1381    00:E68D  0A         			asl	a
 1382    00:E68E  05 00      			ora	<__temp
 1383    00:E690  0A         			asl	a
 1384    00:E691  0A         			asl	a
 1385    00:E692  85 00      			sta	<__temp
 1386    00:E694  A5 F9      			lda	<_ah
 1387                        	;		and	#7
 1388    00:E696  4A         			lsr	a
 1389    00:E697  66 00      			ror	<__temp
 1390    00:E699  4A         			lsr	a
 1391    00:E69A  66 00      			ror	<__temp
 1392    00:E69C  A8         			tay
 1393    00:E69D  A5 00      			lda	<__temp
 1394    00:E69F  8D 04 04   			sta.l	VCE_CTW
 1395    00:E6A2  8C 05 04   			sty.h	VCE_CTW
 1396    00:E6A5  60         			rts
                             #[2]   "..\..\..\include\hucc\hucc-final.asm"
   60                        		.endif
   61                        	
   62               0001     		.ifdef	HUCC_USES_STRING		; Set in hucc_string.h
                             #[3]   "..\..\..\include\hucc\hucc-string.asm"
   63                        			include	"hucc-string.asm"
    1                        	; ***************************************************************************
    2                        	; ***************************************************************************
    3                        	;
    4                        	; hucc-string.asm
    5                        	;
    6                        	; Not-quite-standard, but fast, replacements for <string.h>.
    7                        	;
    8                        	; Copyright John Brandwood 2024.
    9                        	;
   10                        	; Distributed under the Boost Software License, Version 1.0.
   11                        	; (See accompanying file LICENSE_1_0.txt or copy at
   12                        	;  http://www.boost.org/LICENSE_1_0.txt)
   13                        	;
   14                        	; ***************************************************************************
   15                        	; ***************************************************************************
   16                        	;
   17                        	; !!! WARNING : non-standard return values !!!
   18                        	;
   19                        	; Strings are limited to a maximum of 255 characters (+ the terminator)!
   20                        	;
   21                        	; The memcpy(), strcpy() and strcat() functions do NOT return the destination
   22                        	; address, and they are declared "void" to check that the value is not used.
   23                        	;
   24                        	; mempcpy() is provided which returns the end address instead of the starting
   25                        	; address, because this is typically more useful.
   26                        	;
   27                        	; Please note that both memcpy() and memset() are implemented using a TII for
   28                        	; speed, and so the length should be < 16 bytes if used in time-critical bits
   29                        	; of code (such as when using a split screen) because they delay interrupts.
   30                        	;
   31                        	; strncpy() and strncat() are not provided, because strncpy() was not created
   32                        	; for the purpose of avoiding string overruns, and strncat() is just a poorly
   33                        	; designed function.
   34                        	;
   35                        	; POSIX strlcpy() and strlcat() are provided instead, but once again they are
   36                        	; slightly non-standard in that the return value when there is an overflow is
   37                        	; the buffer size (so that the overflow can be detected), instead of the full
   38                        	; size of the destination string that was too big to fit in the buffer.
   39                        	;
   40                        	; ***************************************************************************
   41                        	; ***************************************************************************
   42                        	
   43                        	
   44                        	
   45                        	; ***************************************************************************
   46                        	; ***************************************************************************
   47                        	;
   48                        	; void __fastcall strcpy( char *destination<_di>, char *source<_bp> );
   49                        	; void __fastcall strcat( char *destination<_di>, char *source<_bp> );
   50                        	;
   51                        	; unsigned int __fastcall strlcpy( char *destination<_di>, char *source<_bp>, unsigned char size<acc> );
   52                        	; unsigned int __fastcall strlcat( char *destination<_di>, char *source<_bp>, unsigned char size<acc> );
   53                        	; unsigned int __fastcall strlen( char *source<_bp> );
   54                        	;
   55                        	; NOT WORKING YET (needs compiler changes) ...
   56                        	;
   57                        	; void __fastcall strcpy( char *destination<_di>, char __far *source<_bp_bank:_bp> );
   58                        	; void __fastcall strcat( char *destination<_di>, char __far *source<_bp_bank:_bp> );
   59                        	;
   60                        	; unsigned int __fastcall strlcpy( char *destination<_di>, char __far *source<_bp_bank:_bp>, unsigned char size<acc> );
   61                        	; unsigned int __fastcall strlcat( char *destination<_di>, char __far *source<_bp_bank:_bp>, unsigned char size<acc> );
   62                        	; unsigned int __fastcall strlen( char __far *source<_bp_bank:_bp> );
   63                        	
   64    00:E6A6  62         	_strcat:	cla				; Max string length == 256!
   65    00:E6A7  A0 01      			ldy.h	#256
   66                        	
   67    00:E6A9  AA         	_strlcat:	tax				; X = buffer length (1..256).
   68                        	
   69               0000     		.ifdef	_DEBUG
   74                        		.endif
   75                        	
   76    00:E6AA  43 08      			tma3				; Preserve MPR3 and MPR4.
   77    00:E6AC  48         			pha
   78    00:E6AD  43 10      			tma4
   79    00:E6AF  48         			pha
   80                        	
   81                        	;		ldy	<_bp_bank		; Map the source string.
   82                        	;		beq	.no_bank
   83                        	;		jsr	map_bp_to_mpr34
   84                        	
   85    00:E6B0  C2         	.no_bank:	cly
   86                        	
   87    00:E6B1  B1 F0      	.find:		lda	[_di], y		; Find the end of the string.
   88    00:E6B3  F0 08      			beq	.adjust
   89    00:E6B5  C8         			iny
   90    00:E6B6  CA         			dex
   91    00:E6B7  D0 F8      			bne	.find
   92    00:E6B9  98         			tya				; A:Y = buffer length.
   93    00:E6BA  62         			cla
   94    00:E6BB  80 28      			bra	str_overflow
   95                        	
   96    00:E6BD  98         	.adjust:	tya				; Subtract Y from _bp so that
   97    00:E6BE  49 FF      			eor	#$FF			; _bp and _di use the same Y.
   98    00:E6C0  38         			sec
   99    00:E6C1  65 EC      			adc.l	<_bp
  100    00:E6C3  85 EC      			sta.l	<_bp
  101    00:E6C5  B0 0F      			bcs	str_copy
  102    00:E6C7  C6 ED      			dec.h	<_bp
  103    00:E6C9  80 0B      			bra	str_copy
  104                        	
  105                        			;
  106                        	
  107    00:E6CB  62         	_strcpy:	cla				; Max string length == 256!
  108    00:E6CC  A0 01      			ldy.h	#256
  109                        	
  110    00:E6CE  AA         	_strlcpy:	tax				; X = buffer length (1..256).
  111                        	
  112               0000     		.ifdef	_DEBUG
  117                        		.endif
  118                        	
  119    00:E6CF  43 08      			tma3				; Preserve MPR3 and MPR4.
  120    00:E6D1  48         			pha
  121    00:E6D2  43 10      			tma4
  122    00:E6D4  48         			pha
  123                        	
  124                        	;		ldy	<_bp_bank		; Map the source string.
  125                        	;		beq	.no_bank
  126                        	;		jsr	map_bp_to_mpr34
  127                        	
  128    00:E6D5  C2         	.no_bank:	cly
  129                        	
  130    00:E6D6  B1 EC      	str_copy:	lda	[_bp], y
  131    00:E6D8  91 F0      			sta	[_di], y
  132    00:E6DA  F0 1E      			beq	str_exit		; A:Y = string length.
  133    00:E6DC  C8         			iny
  134    00:E6DD  CA         			dex
  135    00:E6DE  D0 F6      			bne	str_copy
  136                        	
  137    00:E6E0  88         			dey
  138    00:E6E1  62         			cla
  139    00:E6E2  91 F0      			sta	[_di], y
  140    00:E6E4  C8         			iny				; A:Y = buffer length.
  141    00:E6E5  D0 13      	str_overflow:	bne	str_exit
  142    00:E6E7  1A         			inc	a			; A:Y = buffer length = 256.
  143    00:E6E8  80 10      			bra	str_exit
  144                        	
  145                        			;
  146                        	
  147    00:E6EA  43 08      	_strlen:	tma3
  148    00:E6EC  48         			pha
  149    00:E6ED  43 10      			tma4
  150    00:E6EF  48         			pha
  151                        	
  152                        	;		ldy	<_bp_bank
  153                        	;		beq	.no_bank
  154                        	;		jsr	map_bp_to_mpr34
  155                        	
  156    00:E6F0  C2         	.no_bank:	cly
  157                        	
  158    00:E6F1  B1 EC      	.find:		lda	[_bp], y
  159    00:E6F3  F0 05      			beq	str_exit
  160    00:E6F5  C8         			iny
  161    00:E6F6  D0 F9      			bne	.find
  162    00:E6F8  A9 01      			lda.h	#256			; A:Y = overflow length = 256.
  163                        	
  164    00:E6FA  AA         	str_exit:	tax				; X:Y = string or buffer length.
  165                        	
  166    00:E6FB  68         			pla				; Restore MPR3 and MPR4.
  167    00:E6FC  53 10      			tam4
  168    00:E6FE  68         			pla
  169    00:E6FF  53 08      			tam3
  170                        	
  171    00:E701  8A         			txa				; A:Y = string or buffer length.
  172    00:E702  42         			say				; Y:A = string or buffer length.
  173                        	
  174    00:E703  60         			rts
  175                        	
  176    00:E704             			.alias	_strlen.1		= _strlen
  177    00:E704             			.alias	_strcpy.2		= _strcpy
  178    00:E704             			.alias	_strcat.2		= _strcat
  179    00:E704             			.alias	_strlcpy.3		= _strlcpy
  180    00:E704             			.alias	_strlcat.3		= _strlcat
  181                        	
  182                        	
  183                        	
  184                        	; ***************************************************************************
  185                        	; ***************************************************************************
  186                        	;
  187                        	; void __fastcall memcpy( unsigned char *destination<ram_tii_dst>, unsigned char  *source<ram_tii_src>, unsigned int count<acc> );
  188                        	; unsigned char * __fastcall mempcpy( unsigned char *destination<ram_tii_dst>, unsigned char  *source<ram_tii_src>, unsigned int count<acc> );
  189                        	;
  190                        	; void __fastcall farmemcpy( unsigned char *destination<ram_tii_dst>, unsigned char __far *source<_bp_bank:ram_tii_src>, unsigned int count<acc> );
  191                        	; unsigned char * __fastcall farmempcpy( unsigned char *destination<ram_tii_dst>, unsigned char __far *source<_bp_bank:ram_tii_src>, unsigned int count<acc> );
  192                        	;
  193                        	; void __fastcall far_memcpy( unsigned char *destination<ram_tii_dst>, unsigned int count<acc> );
  194                        	; unsigned char * __fastcall far_mempcpy( unsigned char *destination<ram_tii_dst>, unsigned int count<acc> );
  195                        	;
  196                        	
  197    00:E704             	_memcpy.3:
  198    00:E704  64 02      	_mempcpy.3:	stz	<_bp_bank		; Map the source memory.
  199                        	
  200    00:E706             	_farmemcpy.3:
  201    00:E706  8C FE 22   	_farmempcpy.3:	sty.h	ram_tii_len		; Check for zero length.
  202    00:E709  8D FD 22   			sta.l	ram_tii_len
  203    00:E70C  0D FE 22   			ora.h	ram_tii_len
  204    00:E70F  F0 18      			beq	.zero_length
  205                        	
  206    00:E711  43 08      			tma3				; Preserve MPR3 and MPR4.
  207    00:E713  48         			pha
  208    00:E714  43 10      			tma4
  209    00:E716  48         			pha
  210                        	
  211    00:E717  A5 02      			lda	<_bp_bank		; Map the source memory.
  212    00:E719  F0 05      			beq	.no_bank
  213                        	
  214    00:E71B  53 08      			tam3				; Put bank into MPR3.
  215    00:E71D  1A         			inc	a
  216    00:E71E  53 10      			tam4				; Put next into MPR4.
  217                        	
  218                        	;		lda.h	ram_tii_src		; Remap ptr to MPR3.
  219                        	;		and	#$1F
  220                        	;		ora	#$60
  221                        	;		sta.h	ram_tii_src
  222                        	
  223    00:E720  20 F8 22   	.no_bank:	jsr	ram_tii			; Copy the memory.
  224                        	
  225    00:E723  68         			pla				; Restore MPR3 and MPR4.
  226    00:E724  53 10      			tam4
  227    00:E726  68         			pla
  228    00:E727  53 08      			tam3
  229                        	
  230    00:E729  18         	.zero_length:	clc				; Return the end address
  231    00:E72A  AD FB 22   			lda.l	ram_tii_dst		; like mempcpy().
  232    00:E72D  6D FD 22   			adc.l	ram_tii_len
  233    00:E730  A8         			tay
  234    00:E731  AD FC 22   			lda.h	ram_tii_dst
  235    00:E734  6D FE 22   			adc.h	ram_tii_len
  236    00:E737  42         			say
  237                        	
  238    00:E738  60         			rts
  239                        	
  240    00:E739             			.alias	_far_memcpy.2		= _farmemcpy.3
  241    00:E739             			.alias	_far_mempcpy.2		= _farmempcpy.3
  242                        	
  243                        	
  244                        	
  245                        	; ***************************************************************************
  246                        	; ***************************************************************************
  247                        	;
  248                        	; void __fastcall memset( unsigned char *destination<ram_tii_src>, unsigned char value<_al>, unsigned int count<acc> );
  249                        	
  250    00:E739  C9 00      	_memset:	cmp	#0			; Decrement the length, check
  251    00:E73B  D0 05      			bne	!+			; for zero and set C. 
  252    00:E73D  C0 00      			cpy	#0
  253    00:E73F  F0 23      			beq	.zero_length
  254    00:E741  88         			dey
  255    00:E742  3A         	!:		dec	a
  256    00:E743  8D FD 22   			sta.l	ram_tii_len
  257    00:E746  8C FE 22   			sty.h	ram_tii_len
  258                        	
  259    00:E749  AD F9 22   			lda.l	ram_tii_src		; ram_tii_dst = ram_tii_src + 1
  260    00:E74C  85 88      			sta.l	<__ptr
  261    00:E74E  69 00      			adc	#0
  262    00:E750  8D FB 22   			sta.l	ram_tii_dst
  263    00:E753  AD FA 22   			lda.h	ram_tii_src
  264    00:E756  85 89      			sta.h	<__ptr
  265    00:E758  69 00      			adc	#0
  266    00:E75A  8D FC 22   			sta.h	ram_tii_dst
  267                        	
  268    00:E75D  A5 F8      			lda	<_al			; Set the fill value.
  269    00:E75F  92 88      			sta	[__ptr]
  270                        	
  271    00:E761  4C F8 22   			jmp	ram_tii			; Copy the memory.
  272                        	
  273    00:E764  60         	.zero_length:	rts
  274                        	
  275    00:E765             			.alias	_memset.3		= _memset
  276                        	
  277                        	
  278                        	
  279                        	; ***************************************************************************
  280                        	; ***************************************************************************
  281                        	;
  282                        	; int __fastcall strcmp( char *string1<_di>, char *string2<_bp> );
  283                        	; int __fastcall strncmp( char *string1<_di>, char *string2<_bp>, unsigned int count<_ax> );
  284                        	;
  285                        	; int __fastcall __macro memcmp( unsigned char *string1<_di>, unsigned char *string2<_bp>, unsigned int count<_ax> );
  286                        	; int __fastcall farmemcmp( unsigned char *string1<_di>, unsigned char __far *string2<_bp_bank:_bp>, unsigned int count<_ax> );
  287                        	; int __fastcall far_memcmp( unsigned char *string1<_di>, unsigned int count<_ax> );
  288                        	;
  289                        	;  0 	if strings are equal
  290                        	;  1 	if the first non-matching character in string1 > string2 (in ASCII).
  291                        	; -1 	if the first non-matching character in string1 < string2 (in ASCII).
  292                        	
  293    0D:DEE6             	hucc_memcmp	.procgroup
  294                        	
  295                        	_strcmp.2	.proc
  300                        			.endp				; Fall through.
  301                        	
  302    0D:DEE6             	_strncmp.3	.proc
  303    0D:DEE6  64 02      			stz	<_bp_bank		; Assume strings are mapped.
  304    0D:DEE8  89 40      			bit	#$40			; Set the V bit for strcmp.
  305    0D:DEEA  50         			db	$50			; Turn "clv" into "bvc".
  306    0D:DEEB             			.ref	_farmemcmp.3		; Don't strip _farmemcmp.3!
  307                        			.endp				; Fall through.
  308                        	
  309    0D:DEEB             	_farmemcmp.3	.proc
  310    0D:DEEB  B8         			clv				; Clr the V bit for memcmp.
  311                        	
  312    0D:DEEC  43 08      			tma3				; Preserve MPR3 and MPR4.
  313    0D:DEEE  48         			pha
  314    0D:DEEF  43 10      			tma4
  315    0D:DEF1  48         			pha
  316                        	
  317    0D:DEF2  A4 02      			ldy	<_bp_bank		; Map string2.
  318    0D:DEF4  F0 03      			beq	.no_bank
  319                        	
  320    0D:DEF6  20 3B E3   			jsr	map_bp_to_mpr34
  321                        	
  322    0D:DEF9  C2         	.no_bank:	cly
  323                        	
  324    0D:DEFA  A6 F8      			ldx.l	<_ax			; Increment length.l
  325    0D:DEFC  E8         			inx
  326    0D:DEFD  CA         	.loop:		dex				; Decrement length.l
  327    0D:DEFE  F0 17      			beq	.page
  328    0D:DF00  B1 F0      	.test:		lda	[_di], y		; string1 - string2
  329    0D:DF02  D1 EC      			cmp	[_bp], y
  330    0D:DF04  90 1E      			bcc	.return_neg		; string1 < string2 
  331    0D:DF06  D0 17      			bne	.return_pos		; string1 > string2
  332    0D:DF08  50 04      			bvc	!+			; Only check for end-of-string
  333    0D:DF0A  C9 00      			cmp	#0			; if the V flag is set.
  334    0D:DF0C  F0 0D      			beq	.return_same
  335    0D:DF0E  C8         	!:		iny
  336    0D:DF0F  D0 EC      			bne	.loop
  337    0D:DF11  E6 F1      			inc.h	<_di
  338    0D:DF13  E6 ED      			inc.h	<_bp			; Limited to 8KB maximum!
  339                        	;		jsr	inc.h_bp_mpr34
  340    0D:DF15  80 E6      			bra	.loop
  341                        	
  342    0D:DF17  C6 F9      	.page:		dec.h	<_ax			; Decrement length.h 
  343    0D:DF19  10 E5      			bpl	.test			; Limit comparison to 32KB.
  344                        	;		bra	cmp_same
  345                        	
  346    0D:DF1B  82         	.return_same:	clx				; Return code in Y:X, X -> A.
  347    0D:DF1C  C2         			cly
  348    0D:DF1D  80 09      			bra	!+
  349                        	
  350    0D:DF1F  A2 01      	.return_pos:	ldx	#$01			; Return code in Y:X, X -> A.
  351    0D:DF21  C2         			cly
  352    0D:DF22  80 04      			bra	!+
  353                        	
  354    0D:DF24  A2 FF      	.return_neg:	ldx	#$FF			; Return code in Y:X, X -> A.
  355    0D:DF26  A0 FF      			ldy	#$FF
  356                        	
  357    0D:DF28  68         	!:		pla				; Restore MPR3 and MPR4.
  358    0D:DF29  53 10      			tam4
  359    0D:DF2B  68         			pla
  360    0D:DF2C  53 08      			tam3
  361                        	
  362                        			leave				; Return and copy X -> A.
         0D:DF2E  4C EF FF   			jmp	leave_proc
  363                        	
  364                        			.endp
  365                        	
  366                        			.endprocgroup			; hucc_memcmp
  367                        	
  368    00:E765             			.alias	_far_memcmp.2		= _farmemcmp.3
                             #[2]   "..\..\..\include\hucc\hucc-final.asm"
   64                        		.endif
   65                        	
   66               0001     		.ifdef	HUCC_USES_NEW_SCROLL		; Set in hucc_scroll.h
                             #[3]   "..\..\..\include\hucc\hucc-scroll.asm"
   67                        			include	"hucc-scroll.asm"
    1                        	; ***************************************************************************
    2                        	; ***************************************************************************
    3                        	;
    4                        	; hucc-scroll.asm
    5                        	;
    6                        	; Routines for a fast split-screen scrolling system.
    7                        	;
    8                        	; Copyright John Brandwood 2024.
    9                        	;
   10                        	; Distributed under the Boost Software License, Version 1.0.
   11                        	; (See accompanying file LICENSE_1_0.txt or copy at
   12                        	;  http://www.boost.org/LICENSE_1_0.txt)
   13                        	;
   14                        	; ***************************************************************************
   15                        	; ***************************************************************************
   16                        	;
   17                        	; The maximum number of splits for each screen layer is set in your project's
   18                        	; "hucc-config.inc" file, with the library having a limit of 128-per-layer.
   19                        	;
   20                        	; Your first active split must be defined to start at screen line 0, and then
   21                        	; the rest of the active splits must be in increasing line order to match the
   22                        	; way that the PC Engine displays the output image.
   23                        	;
   24                        	; You can have disabled splits interleaved with your active splits.
   25                        	;
   26                        	; Splits that are normally disabled can be used to create full screen effects
   27                        	; such as bouncing the screen up and down by adding blank areas at the top or
   28                        	; bottom of the screen, and then rapidly changing the height of those areas.
   29                        	;
   30                        	; ***************************************************************************
   31                        	; ***************************************************************************
   32                        	
   33                        	
   34                        	
   35               0000     		.ifndef	HUCC_PCE_SPLITS
   37                        		.endif
   38                        	
   39               0000     		.ifndef	HUCC_SGX_SPLITS
   41                        		.endif
   42                        	
   43               0000     		.if	(HUCC_PCE_SPLITS < 2) || (HUCC_PCE_SPLITS > 128)
   45                        		.endif
   46                        	
   47               0000     		.if	(HUCC_SGX_SPLITS < 2) || (HUCC_SGX_SPLITS > 128)
   49                        		.endif
   50                        	
   51               0144     	HUCC_1ST_RCR	=	$144
   52               00E0     	HUCC_SCR_HEIGHT	=	224
   53                        	
   54               E765     			.code
   55                        	
   56                        	
   57                        	
   58                        	; ***************************************************************************
   59                        	; ***************************************************************************
   60                        	;
   61                        	; void __fastcall scroll_split( unsigned char index<_al>, unsigned char screen_line<_ah>, unsigned int bat_x<_bx>, unsigned int bat_y<_cx>, unsigned char display_flags<_dl> );
   62                        	; void __fastcall sgx_scroll_split( unsigned char index<_al>, unsigned char screen_line<_ah>, unsigned int bat_x<_bx>, unsigned int bat_y<_cx>, unsigned char display_flags<_dl> );
   63                        	;
   64                        	; set screen scrolling
   65                        	
   66                        			.proc	_scroll_split.5
  143                        			.endp
  144                        	
  145               0001     		.if	SUPPORT_SGX
  146                        	
  147    0D:DBD6             			.proc	_sgx_scroll_split.5
  148                        	
  149    0D:DBD6  08         			php				; Disable interrupts while
  150    0D:DBD7  78         			sei				; updating this structure.
  151                        	
  152    0D:DBD8  A6 F8      			ldx	<_al			; Region number.
  153    0D:DBDA  E0 08      			cpx	#HUCC_SGX_SPLITS
  154    0D:DBDC  B0 FE      	.hang:		bcs	.hang			; Better a hang than a crash!
  155                        	
  156    0D:DBDE  BD 68 25   			lda	sgx_region_sel, x	; Update the parameter copy
  157    0D:DBE1  5D 70 25   			eor	sgx_region_new, x	; that is not displayed now.
  158    0D:DBE4  D0 3B      			bne	.regionA
  159                        	
  160    0D:DBE6  A5 F9      	.regionB:	lda	<_ah			; Scanline (i.e. top).
  161    0D:DBE8  C9 E0      			cmp	#HUCC_SCR_HEIGHT	; Skip if offscreen.
  162    0D:DBEA  B0 31      			bcs	!done+
  163    0D:DBEC  9D 90 25   			sta	sgx_regionB_rcr, x
  164                        	
  165    0D:DBEF  C9 00      			cmp	#0			; Either Y at top of the frame
  166    0D:DBF1  F0 01      			beq	!+			; or Y-1 because the RCR code
  167    0D:DBF3  18         			clc				; sets it on the line before.
  168    0D:DBF4  A5 FC      	!:		lda.l	<_cx
  169    0D:DBF6  E9 00      			sbc	#0
  170    0D:DBF8  9D C0 25   			sta	sgx_regionB_yl, x
  171    0D:DBFB  A5 FD      			lda.h	<_cx
  172    0D:DBFD  E9 00      			sbc	#0
  173    0D:DBFF  9D D0 25   			sta	sgx_regionB_yh, x
  174                        	
  175    0D:DC02  A5 FA      			lda.l	<_bx
  176    0D:DC04  9D A0 25   			sta	sgx_regionB_xl, x
  177    0D:DC07  A5 FB      			lda.h	<_bx
  178    0D:DC09  9D B0 25   			sta	sgx_regionB_xh, x
  179                        	
  180    0D:DC0C  A5 FE      			lda	<_dl
  181    0D:DC0E  29 C0      			and	#$C0			; Flags (mark it as enabled).
  182    0D:DC10  09 0C      			ora	#$0C
  183    0D:DC12  9D 80 25   			sta	sgx_regionB_crl, x
  184                        	
  185    0D:DC15  A9 01      			lda	#1			; Mark that we've changed the
  186    0D:DC17  9D 70 25   			sta	sgx_region_new, x	; selected region.
  187    0D:DC1A  9D 68 25   			sta	sgx_region_sel, x
  188                        	
  189    0D:DC1D  28         	!done:		plp				; Restore interrupts.
  190                        			leave				; All done!
         0D:DC1E  4C EF FF   			jmp	leave_proc
  191                        	
  192    0D:DC21  A5 F9      	.regionA:	lda	<_ah			; Scanline (i.e. top).
  193    0D:DC23  C9 E0      			cmp	#HUCC_SCR_HEIGHT	; Skip if offscreen.
  194    0D:DC25  B0 31      			bcs	!done+
  195    0D:DC27  9D 88 25   			sta	sgx_regionA_rcr, x
  196                        	
  197    0D:DC2A  C9 00      			cmp	#0			; Either Y at top of the frame
  198    0D:DC2C  F0 01      			beq	!+			; or Y-1 because the RCR code
  199    0D:DC2E  18         			clc				; sets it on the line before.
  200    0D:DC2F  A5 FC      	!:		lda.l	<_cx
  201    0D:DC31  E9 00      			sbc	#0
  202    0D:DC33  9D B8 25   			sta	sgx_regionA_yl, x
  203    0D:DC36  A5 FD      			lda.h	<_cx
  204    0D:DC38  E9 00      			sbc	#0
  205    0D:DC3A  9D C8 25   			sta	sgx_regionA_yh, x
  206                        	
  207    0D:DC3D  A5 FA      			lda.l	<_bx
  208    0D:DC3F  9D 98 25   			sta	sgx_regionA_xl, x
  209    0D:DC42  A5 FB      			lda.h	<_bx
  210    0D:DC44  9D A8 25   			sta	sgx_regionA_xh, x
  211                        	
  212    0D:DC47  A5 FE      			lda	<_dl
  213    0D:DC49  29 C0      			and	#$C0			; Flags (mark it as enabled).
  214    0D:DC4B  09 0C      			ora	#$0C
  215    0D:DC4D  9D 78 25   			sta	sgx_regionA_crl, x
  216                        	
  217    0D:DC50  A9 01      			lda	#1			; Mark that we've changed the
  218    0D:DC52  9D 70 25   			sta	sgx_region_new, x	; selected region.
  219    0D:DC55  9E 68 25   			stz	sgx_region_sel, x
  220                        	
  221    0D:DC58  28         	!done:		plp				; Restore interrupts.
  222                        			leave				; All done!
         0D:DC59  4C EF FF   			jmp	leave_proc
  223                        	
  224                        			.endp
  225                        	
  226                        		.endif	SUPPORT_SGX
  227                        	
  228                        	
  229                        	
  230                        	; ***************************************************************************
  231                        	; ***************************************************************************
  232                        	;
  233                        	; void __fastcall disable_split( unsigned char index<acc> );
  234                        	; void __fastcall sgx_disable_split( unsigned char index<acc> );
  235                        	;
  236                        	; disable screen scrolling for a scroll region
  237                        	
  238    00:E765             	_disable_split.1:
  239    00:E765  08         			php				; Disable interrupts while
  240    00:E766  78         			sei				; updating this structure.
  241                        	
  242    00:E767  C9 08      			cmp	#HUCC_PCE_SPLITS	; Better a hang than a crash!
  243    00:E769  B0 FE      	.hang:		bcs	.hang
  244    00:E76B  AA         			tax
  245                        	
  246    00:E76C  BD E7 24   			lda	vdc_region_sel, x	; Update the parameter copy
  247    00:E76F  5D EF 24   			eor	vdc_region_new, x	; that is not displayed now.
  248    00:E772  D0 0D      			bne	.regionA
  249                        	
  250    00:E774  9E FF 24   	.regionB:	stz	vdc_regionB_crl, x	; Region disabled if $00.
  251                        	
  252    00:E777  A9 01      			lda	#1			; Mark that we've changed the
  253    00:E779  9D EF 24   			sta	vdc_region_new, x	; selected region.
  254    00:E77C  9D E7 24   			sta	vdc_region_sel, x
  255                        	
  256    00:E77F  28         			plp				; Restore interrupts.
  257    00:E780  60         			rts
  258                        	
  259    00:E781  9E F7 24   	.regionA:	stz	vdc_regionA_crl, x	; Region disabled if $00.
  260                        	
  261    00:E784  A9 01      			lda	#1			; Mark that we've changed the
  262    00:E786  9D EF 24   			sta	vdc_region_new, x	; selected region.
  263    00:E789  9E E7 24   			stz	vdc_region_sel, x
  264                        	
  265    00:E78C  28         			plp				; Restore interrupts.
  266    00:E78D  60         			rts
  267                        	
  268               0001     		.if	SUPPORT_SGX
  269                        	
  270    00:E78E             	_sgx_disable_split.1:
  271    00:E78E  08         			php				; Disable interrupts while
  272    00:E78F  78         			sei				; updating this structure.
  273                        	
  274    00:E790  C9 08      			cmp	#HUCC_SGX_SPLITS	; Better a hang than a crash!
  275    00:E792  B0 FE      	.hang:		bcs	.hang
  276    00:E794  AA         			tax
  277                        	
  278    00:E795  BD 68 25   			lda	sgx_region_sel, x	; Update the parameter copy
  279    00:E798  5D 70 25   			eor	sgx_region_new, x	; that is not displayed now.
  280    00:E79B  D0 0D      			bne	.regionA
  281                        	
  282    00:E79D  9E 80 25   	.regionB:	stz	sgx_regionB_crl, x	; Region disabled if $00.
  283                        	
  284    00:E7A0  A9 01      			lda	#1			; Mark that we've changed the
  285    00:E7A2  9D 70 25   			sta	sgx_region_new, x	; selected region.
  286    00:E7A5  9D 68 25   			sta	sgx_region_sel, x
  287                        	
  288    00:E7A8  28         			plp				; Restore interrupts.
  289    00:E7A9  60         			rts
  290                        	
  291    00:E7AA  9E 78 25   	.regionA:	stz	sgx_regionA_crl, x	; Region disabled if $00.
  292                        	
  293    00:E7AD  A9 01      			lda	#1			; Mark that we've changed the
  294    00:E7AF  9D 70 25   			sta	sgx_region_new, x	; selected region.
  295    00:E7B2  9E 68 25   			stz	sgx_region_sel, x
  296                        	
  297    00:E7B5  28         			plp				; Restore interrupts.
  298    00:E7B6  60         			rts
  299                        	
  300                        		.endif	SUPPORT_SGX
  301                        	
  302                        	
  303                        	
  304                        	; ***************************************************************************
  305                        	; ***************************************************************************
  306                        	;
  307                        	; vbl_init_scroll
  308                        	;
  309                        	; From Charles MacDonald's pcetech.txt ...
  310                        	;
  311                        	;  Raster Compare Register (RCR):
  312                        	;
  313                        	;  The range of the RCR is 263 lines, relative to the start of the active
  314                        	;  display period. (defined by VSW, VDS, and VCR) The VDC treats the first
  315                        	;  scanline of the active display period as $0040, so the valid ranges for
  316                        	;  the RCR register are $0040 to $0146.
  317                        	;
  318                        	;  For example, assume VSW=$02, VDS=$17. This positions the first line of
  319                        	;  the active display period at line 25 of the frame. An RCR value of $0040
  320                        	;  (zero) causes an interrupt at line 25, and a value of $0146 (262) causes an
  321                        	;  interrupt at line 24 of the next frame.
  322                        	;
  323                        	;  Any other RCR values that are out of range ($00-$3F, $147-$3FF) will never
  324                        	;  result in a successful line compare.
  325                        	;
  326                        	; Processing time:
  327                        	;
  328                        	; Old HuC rcr_init: 2148 cycles if all 8 regions pre-sorted
  329                        	; Old HuC rcr_init: 4346 cycles if all 8 regions need sorting
  330                        	;
  331                        	; New HuCC vbl_init_scroll:   8 disabled splits:  290 cycles
  332                        	; New HuCC vbl_init_scroll:   8  enabled splits:  384 cycles
  333                        	;
  334                        	; New HuCC vbl_init_scroll:  16 disabled splits:  506 cycles
  335                        	; New HuCC vbl_init_scroll:  16  enabled splits:  672 cycles
  336                        	;
  337                        	; New HuCC vbl_init_scroll:  32 disabled splits:  953 cycles
  338                        	; New HuCC vbl_init_scroll:  32  enabled splits: 1263 cycles
  339                        	;
  340                        	; New HuCC vbl_init_scroll:  64 disabled splits: 1802 cycles
  341                        	; New HuCC vbl_init_scroll:  64  enabled splits: 2400 cycles
  342                        	;
  343                        	; New HuCC vbl_init_scroll: 128 disabled splits: 3530 cycles
  344                        	; New HuCC vbl_init_scroll: 128  enabled splits: 4704 cycles
  345                        	;
  346                        	; Memory used is 16 bytes per scroll per VDC!
  347                        	
  348               24E7     			.bss
  349                        	
  350    F8:24E7             	vdc_region_sel:	.ds	HUCC_PCE_SPLITS		; Use A or B region next frame?
  351    F8:24EF             	vdc_region_new:	.ds	HUCC_PCE_SPLITS		; 1 if vdc_region_sel modified.
  352                        	
  353    F8:24F7             	vdc_regionA_crl:.ds	HUCC_PCE_SPLITS		; Two copies of each setting
  354    F8:24FF             	vdc_regionB_crl:.ds	HUCC_PCE_SPLITS		; HUCC_PCE_SPLITS bytes apart,
  355    F8:2507             	vdc_regionA_rcr:.ds	HUCC_PCE_SPLITS		; one setting for the current
  356    F8:250F             	vdc_regionB_rcr:.ds	HUCC_PCE_SPLITS		; frame, and one setting that
  357    F8:2517             	vdc_regionA_xl:	.ds	HUCC_PCE_SPLITS		; gets modified and then used
  358    F8:251F             	vdc_regionB_xl:	.ds	HUCC_PCE_SPLITS		; on the next frame after the
  359    F8:2527             	vdc_regionA_xh:	.ds	HUCC_PCE_SPLITS		; change is made.
  360    F8:252F             	vdc_regionB_xh:	.ds	HUCC_PCE_SPLITS		; Regions will have different
  361    F8:2537             	vdc_regionA_yl:	.ds	HUCC_PCE_SPLITS		; A or B currently active!
  362    F8:253F             	vdc_regionB_yl:	.ds	HUCC_PCE_SPLITS
  363    F8:2547             	vdc_regionA_yh:	.ds	HUCC_PCE_SPLITS
  364    F8:254F             	vdc_regionB_yh:	.ds	HUCC_PCE_SPLITS
  365                        	
  366    F8:2557             	vdc_next_region:.ds	1			; Linked list of region indexes
  367    F8:2558             	vdc_regionA_nxt:.ds	HUCC_PCE_SPLITS		; for the current frame.
  368    F8:2560             	vdc_regionB_nxt:.ds	HUCC_PCE_SPLITS
  369                        	
  370               0001     		.if	SUPPORT_SGX
  371                        	
  372    F8:2568             	sgx_region_sel:	.ds	HUCC_SGX_SPLITS		; Use A or B region next frame?
  373    F8:2570             	sgx_region_new:	.ds	HUCC_SGX_SPLITS		; 1 if sgx_region_sel modified.
  374                        	
  375    F8:2578             	sgx_regionA_crl:.ds	HUCC_SGX_SPLITS		; Two copies of each setting
  376    F8:2580             	sgx_regionB_crl:.ds	HUCC_SGX_SPLITS		; HUCC_SGX_SPLITS bytes apart,
  377    F8:2588             	sgx_regionA_rcr:.ds	HUCC_SGX_SPLITS		; one setting for the current
  378    F8:2590             	sgx_regionB_rcr:.ds	HUCC_SGX_SPLITS		; frame, and one setting that
  379    F8:2598             	sgx_regionA_xl:	.ds	HUCC_SGX_SPLITS		; gets modified and then used
  380    F8:25A0             	sgx_regionB_xl:	.ds	HUCC_SGX_SPLITS		; on the next frame after the
  381    F8:25A8             	sgx_regionA_xh:	.ds	HUCC_SGX_SPLITS		; change is made.
  382    F8:25B0             	sgx_regionB_xh:	.ds	HUCC_SGX_SPLITS		; Regions will have different
  383    F8:25B8             	sgx_regionA_yl:	.ds	HUCC_SGX_SPLITS		; A or B currently active!
  384    F8:25C0             	sgx_regionB_yl:	.ds	HUCC_SGX_SPLITS
  385    F8:25C8             	sgx_regionA_yh:	.ds	HUCC_SGX_SPLITS
  386    F8:25D0             	sgx_regionB_yh:	.ds	HUCC_SGX_SPLITS
  387                        	
  388    F8:25D8             	sgx_next_region:.ds	1			; Linked list of region indexes
  389    F8:25D9             	sgx_regionA_nxt:.ds	HUCC_SGX_SPLITS		; for the current frame.
  390    F8:25E1             	sgx_regionB_nxt:.ds	HUCC_SGX_SPLITS
  391                        	
  392                        		.endif
  393                        	
  394               E7B7     			.code
  395                        	
  396    01:DF7E             	vbl_init_scroll	.proc
  397                        	
  398    01:DF7E  62         			cla				; A = previous active index
  399    01:DF7F  A2 08      			ldx	#HUCC_PCE_SPLITS	; so $00 for end-of-screen.
  400                        	
  401    01:DF81  18         			clc				; For regionB indexes.
  402                        	
  403    01:DF82  CA         	!next_region:	dex				; All regions updated?
  404    01:DF83  30 20      			bmi	!save_first+
  405                        	
  406    01:DF85  9E EF 24   			stz	vdc_region_new, x	; Clear region modified flag.
  407                        	
  408    01:DF88  BC E7 24   			ldy	vdc_region_sel, x	; 0=regionA or 1=regionB.
  409    01:DF8B  F0 0D      			beq	!use_regionA+
  410                        	
  411    01:DF8D  BC FF 24   	!use_regionB:	ldy	vdc_regionB_crl, x	; Region disabled if $00.
  412    01:DF90  F0 F0      			beq	!next_region-
  413    01:DF92  9D 60 25   			sta	vdc_regionB_nxt, x	; Save index of next region.
  414    01:DF95  8A         			txa				; A = current region index.
  415    01:DF96  69 08      			adc	#HUCC_PCE_SPLITS	; Always leaves CC!
  416    01:DF98  80 E8      			bra	!next_region-
  417                        	
  418    01:DF9A  BC F7 24   	!use_regionA:	ldy	vdc_regionA_crl, x	; Region disabled if $00.
  419    01:DF9D  F0 E3      			beq	!next_region-
  420    01:DF9F  9D 58 25   			sta	vdc_regionA_nxt, x	; Save index of next region.
  421    01:DFA2  8A         			txa				; A = current region index.
  422    01:DFA3  80 DD      			bra	!next_region-
  423                        	
  424    01:DFA5  8D 57 25   	!save_first:	sta	vdc_next_region		; Save index of 1st region.
  425                        	
  426    01:DFA8  AA         			tax				; NZ if first active region
  427    01:DFA9  D0 03      			bne	!init_first+		; is not region 0.
  428    01:DFAB  98         			tya				; NZ if region 0 is active.
  429    01:DFAC  F0 0F      			beq	!+			; If no active leave RCR=0.
  430                        	
  431    01:DFAE  A9 06      	!init_first:	lda	#VDC_RCR		; 1st RCR always happens just
  432    01:DFB0  8D 00 02   			sta	VDC_AR			; before the display starts.
  433    01:DFB3  A9 44      			lda.l	#HUCC_1ST_RCR
  434    01:DFB5  8D 02 02   			sta	VDC_DL
  435    01:DFB8  A9 01      			lda.h	#HUCC_1ST_RCR
  436    01:DFBA  8D 03 02   			sta	VDC_DH
  437                        	
  438               0001     		.if	SUPPORT_SGX
  439                        	
  440    01:DFBD  62         	!:		cla				; A = previous active index
  441    01:DFBE  A2 08      			ldx	#HUCC_SGX_SPLITS	; so $00 for end-of-screen.
  442                        	
  443    01:DFC0  18         			clc				; For regionB indexes.
  444                        	
  445    01:DFC1  CA         	!next_region:	dex				; All regions updated?
  446    01:DFC2  30 20      			bmi	!save_first+
  447                        	
  448    01:DFC4  9E 70 25   			stz	sgx_region_new, x	; Clear region modified flag.
  449                        	
  450    01:DFC7  BC 68 25   			ldy	sgx_region_sel, x	; 0=regionA or 1=regionB.
  451    01:DFCA  F0 0D      			beq	!use_regionA+
  452                        	
  453    01:DFCC  BC 80 25   	!use_regionB:	ldy	sgx_regionB_crl, x	; Region disabled if $00.
  454    01:DFCF  F0 F0      			beq	!next_region-
  455    01:DFD1  9D E1 25   			sta	sgx_regionB_nxt, x	; Save index of next region.
  456    01:DFD4  8A         			txa				; A = current region index.
  457    01:DFD5  69 08      			adc	#HUCC_SGX_SPLITS	; Always leaves CC!
  458    01:DFD7  80 E8      			bra	!next_region-
  459                        	
  460    01:DFD9  BC 78 25   	!use_regionA:	ldy	sgx_regionA_crl, x	; Region disabled if $00.
  461    01:DFDC  F0 E3      			beq	!next_region-
  462    01:DFDE  9D D9 25   			sta	sgx_regionA_nxt, x	; Save index of next region.
  463    01:DFE1  8A         			txa				; A = current region index.
  464    01:DFE2  80 DD      			bra	!next_region-
  465                        	
  466    01:DFE4  8D D8 25   	!save_first:	sta	sgx_next_region		; Save index of 1st region.
  467                        	
  468    01:DFE7  AA         			tax				; NZ if first active region
  469    01:DFE8  D0 03      			bne	!init_first+		; is not region 0.
  470    01:DFEA  98         			tya				; NZ if region 0 is active.
  471    01:DFEB  F0 0F      			beq	!+			; If no active leave RCR=0.
  472                        	
  473    01:DFED  A9 06      	!init_first:	lda	#VDC_RCR		; 1st RCR always happens just
  474    01:DFEF  8D 10 02   			sta	SGX_AR			; before the display starts.
  475    01:DFF2  A9 44      			lda.l	#HUCC_1ST_RCR
  476    01:DFF4  8D 12 02   			sta	SGX_DL
  477    01:DFF7  A9 01      			lda.h	#HUCC_1ST_RCR
  478    01:DFF9  8D 13 02   			sta	SGX_DH
  479                        	
  480                        		.endif	SUPPORT_SGX
  481                        	
  482                        	!:		leave				; All done!
         01:DFFC  4C EF FF   			jmp	leave_proc
  483                        	
  484                        			.endp
  485                        	
  486                        	
  487                        	
  488               0001     		.if	SUPPORT_SGX
  489                        	
  490                        	; ***************************************************************************
  491                        	; ***************************************************************************
  492                        	;
  493                        	; VDC_RCR_MACRO and SGX_RCR_MACRO
  494                        	;
  495                        	; A 16-byte TIA takes 142..234 cycles in 5MHz, 128..200 cycles in 7MHz.
  496                        	; A 32-byte TIA takes 270..364 cycles in 5MHz, 242..312 cycles in 7MHz. (527 DUO)
  497                        	;
  498                        	; You need to write the last RCR setting within 540 cycles in order to catch
  499                        	; the next line (at 256/336/512 resolution).
  500                        	;
  501                        	; That gives 305 cycles from the RCR to write the last setting, or there
  502                        	; will be a visible glitch on the screen.
  503                        	
  504               0000     		.ifndef	USING_RCR_MACROS
  506                        		.endif
  507                        	
  508                        	;		;;;				; 8 (cycles for the INT)
  509                        	;		bbs1	<irq_vec, .hook		; 8
  510                        	;		jmp	[irq1_hook]		; 7
  511                        	
  512                        	;		;;;				; 8 (cycles for the INT)
  513                        	;		jmp	irq1_handler		; 4
  514                        	
  515                        	;irq1_handler:	pha				; 3 Save all registers.
  516                        	;		phx				; 3
  517                        	;		phy				; 3
  518                        	;
  519                        	;		lda	VDC_SR			; 6 Acknowledge the VDC's IRQ.
  520                        	;		sta	<vdc_sr			; 4 Remember what caused it.
  521                        	;
  522                        	;		ldx	SGX_SR			; 6 Read SGX_SR after VDC_SR in
  523                        	;		stx	<sgx_sr			; 4 case this is not an SGX!
  524                        	;
  525                        	;!:		and	#$04			; 2 Is this an HSYNC interrupt?
  526                        	;		beq	!+			; 2
  527                        	
  528                        			.macro	VDC_RCR_MACRO
  529                        	
  530                        			st0	#VDC_RCR		; 5
  531                        	
  532                        			ldx	vdc_next_region		; 5 X and Y can be greater than
  533                        			ldy	vdc_regionA_nxt, x	; 5 HUCC_PCE_SPLITS if regionB!
  534                        			clc				; 2
  535                        			bne	!set_next_rcr+		; 4 Stop RCR if next line is 0.
  536                        	
  537                        			and	const_0000		; 5 A=$00 with the same #cycles
  538                        			bra	!clr_next_rcr+		; 4 as if the branch were taken.
  539                        	
  540                        	!set_next_rcr:	lda	vdc_regionA_rcr, y	; 5 Set next RCR 1 line before
  541                        			adc	#64-1			; 2 the region begins, or 0 to
  542                        	!clr_next_rcr:	sta	VDC_DL			; 6 disable.
  543                        			cla				; 2
  544                        			rol	a			; 2
  545                        			sta	VDC_DH			; 6
  546                        	
  547                        			st0	#VDC_BYR		; 5 Do BYR first to mitigate the
  548                        			lda	vdc_regionA_yl, x	; 5 glitch if the IRQ is delayed.
  549                        			sta	VDC_DL			; 6 = 105 cycles from RCR on SGX
  550                        			lda	vdc_regionA_yh, x	; 5
  551                        			sta	VDC_DH			; 6
  552                        	
  553                        			st0	#VDC_CR			; 5
  554                        			lda	vdc_regionA_crl, x	; 5
  555                        	;		asl	a
  556                        			sta	VDC_DL			; 6
  557                        	
  558                        			st0	#VDC_BXR		; 2
  559                        			lda	vdc_regionA_xl, x	; 5
  560                        			sta	VDC_DL			; 6
  561                        			lda	vdc_regionA_xh, x	; 5
  562                        			sta	VDC_DH			; 6 = 156 cycles from RCR if DUO
  563                        	
  564                        	;		bcc	!+
  565                        	;		lda	vdc_regionA_yh, x	; 5
  566                        	;		sta.l	VCE_CTW			; 6
  567                        	
  568                        			sty	vdc_next_region		; 5
  569                        	
  570                        			.endm
  571                        	
  572                        	;!:		bbr2	<sgx_sr, !+		; 6 Is this an HSYNC interrupt?
  573                        	
  574                        			.macro	SGX_RCR_MACRO
  575                        	
  576                        			lda	#VDC_RCR		; 2
  577                        			sta	SGX_AR			; 6
  578                        	
  579                        			ldx	sgx_next_region		; 5 X and Y can be greater than
  580                        			ldy	sgx_regionA_nxt, x	; 5 HUCC_SGX_SPLITS if regionB!
  581                        			clc				; 2
  582                        			bne	!set_next_rcr+		; 4 Stop RCR if next line is 0.
  583                        	
  584                        			and	const_0000		; 5 A=$00 with the same #cycles
  585                        			bra	!clr_next_rcr+		; 4 as if the branch were taken.
  586                        	
  587                        	!set_next_rcr:	lda	sgx_regionA_rcr, y	; 5 Set next RCR 1 line before
  588                        			adc	#64-1			; 2 the region begins, or 0 to
  589                        	!clr_next_rcr:	sta	SGX_DL			; 6 disable.
  590                        			cla				; 2
  591                        			rol	a			; 2
  592                        			sta	SGX_DH			; 6
  593                        	
  594                        			lda	#VDC_BYR		; 2 Do BYR first to mitigate the
  595                        			sta	SGX_AR			; 6 glitch if the IRQ is delayed.
  596                        			lda	sgx_regionA_yl, x	; 5
  597                        			sta	SGX_DL			; 6
  598                        			lda	sgx_regionA_yh, x	; 5
  599                        			sta	SGX_DH			; 6
  600                        	
  601                        			lda	#VDC_CR			; 2
  602                        			sta	SGX_AR			; 6
  603                        			lda	sgx_regionA_crl, x	; 5
  604                        			sta	SGX_DL			; 6
  605                        	
  606                        			lda	#VDC_BXR		; 2
  607                        			sta	SGX_AR			; 6
  608                        			lda	sgx_regionA_xl, x	; 5
  609                        			sta	SGX_DL			; 6
  610                        			lda	sgx_regionA_xh, x	; 5
  611                        			sta	SGX_DH			; 6 = 293 cycles (282 if no YH)
  612                        	
  613                        			sty	sgx_next_region		; 5
  614                        	
  615                        			.endm
  616                        	
  617                        		.else	SUPPORT_SGX
  697                        		.endif	SUPPORT_SGX
                             #[2]   "..\..\..\include\hucc\hucc-final.asm"
   68                        		.else
   72                        		.endif	HUCC_USES_NEW_SCROLL
   73                        	
   74               0001     		.ifdef	HUCC_USES_OLD_SPR		; Set in hucc_old_spr.h
                             #[3]   "..\..\..\include\hucc\hucc-old-spr.asm"
   75                        			include	"hucc-old-spr.asm"
    1                        	; ***************************************************************************
    2                        	; ***************************************************************************
    3                        	;
    4                        	; hucc-old-spr.asm
    5                        	;
    6                        	; Based on the original HuC and MagicKit functions by David Michel and the
    7                        	; other original HuC developers.
    8                        	;
    9                        	; Modifications copyright John Brandwood 2024.
   10                        	;
   11                        	; Distributed under the Boost Software License, Version 1.0.
   12                        	; (See accompanying file LICENSE_1_0.txt or copy at
   13                        	;  http://www.boost.org/LICENSE_1_0.txt)
   14                        	;
   15                        	; ***************************************************************************
   16                        	; ***************************************************************************
   17                        	
   18                        	;
   19                        	; Include dependancies ...
   20                        	;
   21                        	
   22                        			include "common.asm"		; Common helpers.
   23                        			include "vce.asm"		; Useful VCE routines.
   24                        			include "vdc.asm"		; Useful VCE routines.
   25                        	
   26                        	
   27                        	
   28                        	; ***************************************************************************
   29                        	; ***************************************************************************
   30                        	;
   31                        	; HuC Sprite Functions
   32                        	;
   33                        	; ***************************************************************************
   34                        	; ***************************************************************************
   35                        	
   36               209C     			.zp
   37    F8:209C             	spr_ptr:	ds	2
   38               25E9     			.bss
   39    F8:25E9             	spr_sat:	ds	512
   40               E7B7     			.code
   41                        	
   42               0001     		.if	SUPPORT_SGX
   43               209E     			.zp
   44    F8:209E             	sgx_spr_ptr:	ds	2
   45               27E9     			.bss
   46    F8:27E9             	sgx_spr_sat:	ds	512	; N.B. Directly after spr_sat!
   47               E7B7     			.code
   48                        		.endif
   49                        	
   50                        	; Moved to hucc-old-map.asm just to save space. This NEEDS to be changed!
   51                        	;
   52                        	;		.bss
   53                        	;spr_max:	ds	1
   54                        	;spr_clr:	ds	1
   55                        	;	.if	SUPPORT_SGX
   56                        	;sgx_spr_max:	ds	1
   57                        	;sgx_spr_clr:	ds	1
   58                        	;	.endif
   59                        	;		.code
   60                        	
   61                        	
   62                        	
   63                        	; ***************************************************************************
   64                        	; ***************************************************************************
   65                        	;
   66                        	; void __fastcall init_satb( void );
   67                        	; void __fastcall reset_satb( void );
   68                        	;
   69                        	; void __fastcall sgx_init_satb( void );
   70                        	; void __fastcall sgx_reset_satb( void );
   71                        	
   72    00:E7B7             	_reset_satb:
   73    00:E7B7  C2         	_init_satb:	cly
   74    00:E7B8  62         			cla
   75    00:E7B9  99 E9 25   	!:		sta	spr_sat + $0000, y
   76    00:E7BC  99 E9 26   			sta	spr_sat + $0100, y
   77    00:E7BF  C8         			iny
   78    00:E7C0  D0 F7      			bne	!-
   79    00:E7C2  8C BD 24   			sty	spr_max
   80    00:E7C5  C8         			iny
   81    00:E7C6  8C BE 24   			sty	spr_clr
   82    00:E7C9  60         			rts
   83                        	
   84               0001     		.if	SUPPORT_SGX
   85    00:E7CA             	_sgx_reset_satb:
   86    00:E7CA  C2         	_sgx_init_satb:	cly
   87    00:E7CB  62         			cla
   88    00:E7CC  99 E9 27   	!:		sta	sgx_spr_sat + $0000, y
   89    00:E7CF  99 E9 28   			sta	sgx_spr_sat + $0100, y
   90    00:E7D2  C8         			iny
   91    00:E7D3  D0 F7      			bne	!-
   92    00:E7D5  8C CD 24   			sty	sgx_spr_max
   93    00:E7D8  C8         			iny
   94    00:E7D9  8C CE 24   			sty	sgx_spr_clr
   95    00:E7DC  60         			rts
   96                        		.endif
   97                        	
   98                        	
   99                        	
  100                        	; ***************************************************************************
  101                        	; ***************************************************************************
  102                        	;
  103                        	; void __fastcall satb_update( void );
  104                        	; void __fastcall sgx_satb_update( void );
  105                        	
  106    0D:DF31             	old_satb_group	.procgroup
  107                        	
  108               0001     		.if	SUPPORT_SGX
  109                        			.proc	_sgx_satb_update
  115                        			.endp
  116                        		.endif
  117                        	
  118    0D:DF31             			.proc	_satb_update
  119                        	
  120    0D:DF31  82         			clx				; Offset to PCE VDC.
  121                        	
  122    0D:DF32  A9 7F      			lda.h	#$7F00			; HuC puts the SAT here in VRAM
  123                        	;		lda.h	#$0800			; but we put it here instead
  124    0D:DF34  64 F0      			stz.l	<_di
  125    0D:DF36  85 F1      			sta.h	<_di
  126    0D:DF38  20 7F E3   			jsr	set_di_to_mawr
  127                        	
  128               0001     		.if	SUPPORT_SGX
  129    0D:DF3B  8A         			txa				; Select which VDC to write
  130    0D:DF3C  1A         			inc	a			; to.
  131    0D:DF3D  1A         			inc	a
  132    0D:DF3E  8D F3 22   			sta.l	ram_tia_dst
  133                        		.endif
  134                        	
  135    0D:DF41  A9 10      			lda	#VRAM_XFER_SIZE		; Split into 16-byte chunks
  136    0D:DF43  8D F5 22   			sta.l	ram_tia_len		; for stable IRQ response.
  137                        	
  138    0D:DF46  BC BD 24   			ldy	spr_max, x		; Highest sprite that was set.
  139    0D:DF49  C8         			iny
  140                        	
  141    0D:DF4A  BD BE 24   			lda	spr_clr, x
  142    0D:DF4D  F0 05      			beq	!+
  143    0D:DF4F  9E BE 24   			stz	spr_clr, x
  144    0D:DF52  A0 40      			ldy	#64
  145                        	
  146    0D:DF54  98         	!:		tya
  147    0D:DF55  F0 22      			beq	.exit
  148                        	
  149    0D:DF57  3A         			dec	a			; round up to the next group of 2 sprites
  150    0D:DF58  4A         			lsr	a
  151               0000     		.if	VRAM_XFER_SIZE == 32
  153                        		.endif
  154    0D:DF59  1A         			inc	a
  155    0D:DF5A  A8         			tay
  156                        	
  157    0D:DF5B  A9 25      			lda.h	#spr_sat
  158                        	
  159               0001     		.if	SUPPORT_SGX
  160    0D:DF5D  E0 00      			cpx	#0
  161    0D:DF5F  F0 02      			beq	!+
  162                        	
  163    0D:DF61  A9 27      			lda.h	#sgx_spr_sat
  164                        		.endif
  165                        	
  166    0D:DF63  8D F2 22   	!:		sta.h	ram_tia_src
  167                        	
  168    0D:DF66  A9 E9      			lda.l	#spr_sat		; Same for SGX and PCE!
  169    0D:DF68  8D F1 22   	.chunk_loop:	sta.l	ram_tia_src
  170                        	
  171    0D:DF6B  20 F0 22   			jsr	ram_tia			; transfer 16-bytes
  172                        	
  173    0D:DF6E  18         			clc				; increment source
  174    0D:DF6F  69 10      			adc	#VRAM_XFER_SIZE
  175    0D:DF71  90 03      			bcc	.same_page
  176    0D:DF73  EE F2 22   			inc.h	ram_tia_src
  177                        	
  178    0D:DF76  88         	.same_page:	dey
  179    0D:DF77  D0 EF      			bne	.chunk_loop
  180                        	
  181                        	.exit:		leave
         0D:DF79  4C EF FF   			jmp	leave_proc
  182                        	
  183                        			.endp
  184                        	
  185                        			.endprocgroup	; old_satb_group
  186                        	
  187                        	
  188                        	
  189                        	; ***************************************************************************
  190                        	; ***************************************************************************
  191                        	;
  192                        	; void __fastcall spr_set( unsigned char num<acc> );
  193                        	
  194    00:E7DD  CD BD 24   	_spr_set.1:	cmp	spr_max
  195    00:E7E0  90 03      			bcc	!+
  196    00:E7E2  8D BD 24   			sta	spr_max
  197    00:E7E5  A0 25      	!:		ldy.h	#spr_sat
  198    00:E7E7  0A         			asl	a
  199    00:E7E8  0A         			asl	a
  200    00:E7E9  0A         			asl	a
  201    00:E7EA  90 02      			bcc	!+
  202    00:E7EC  C8         			iny
  203    00:E7ED  18         			clc
  204    00:E7EE  69 E9      	!:		adc.l	#spr_sat
  205    00:E7F0  85 9C      			sta.l	<spr_ptr
  206    00:E7F2  90 01      			bcc	!+
  207    00:E7F4  C8         			iny
  208    00:E7F5  84 9D      	!:		sty.h	<spr_ptr
  209    00:E7F7  60         			rts
  210                        	
  211                        	
  212                        	
  213                        	; ***************************************************************************
  214                        	; ***************************************************************************
  215                        	;
  216                        	; void __fastcall spr_hide( void );
  217                        	
  218    00:E7F8  A0 01      	_spr_hide:	ldy	#1
  219    00:E7FA  B1 9C      			lda	[spr_ptr], y
  220    00:E7FC  09 02      			ora	#2
  221    00:E7FE  91 9C      			sta	[spr_ptr], y
  222    00:E800  60         			rts
  223                        	
  224                        	
  225                        	
  226                        	; ***************************************************************************
  227                        	; ***************************************************************************
  228                        	;
  229                        	; void __fastcall spr_show( void );
  230                        	
  231    00:E801  A0 01      	_spr_show:	ldy	#1
  232    00:E803  B1 9C      			lda	[spr_ptr], y
  233    00:E805  29 01      			and	#1
  234    00:E807  91 9C      			sta	[spr_ptr], y
  235    00:E809  60         			rts
  236                        	
  237                        	
  238                        	
  239                        	; ***************************************************************************
  240                        	; ***************************************************************************
  241                        	;
  242                        	; void __fastcall spr_x( unsigned int value<acc> );
  243                        	
  244    00:E80A  02         	_spr_x.1:	sxy
  245    00:E80B  18         			clc
  246    00:E80C  69 20      			adc	#32
  247    00:E80E  A0 02      			ldy	#2
  248    00:E810  91 9C      			sta	[spr_ptr], y
  249    00:E812  8A         			txa
  250    00:E813  69 00      			adc	#0
  251    00:E815  C8         			iny
  252    00:E816  91 9C      			sta	[spr_ptr], y
  253    00:E818  60         			rts
  254                        	
  255                        	
  256                        	
  257                        	; ***************************************************************************
  258                        	; ***************************************************************************
  259                        	;
  260                        	; void __fastcall spr_y( unsigned int value<acc> );
  261                        	
  262    00:E819  18         	_spr_y.1:	clc
  263    00:E81A  69 40      			adc	#64
  264    00:E81C  92 9C      			sta	[spr_ptr]
  265    00:E81E  98         			tya
  266    00:E81F  69 00      			adc	#0
  267    00:E821  A0 01      			ldy	#1
  268    00:E823  91 9C      			sta	[spr_ptr], y
  269    00:E825  60         			rts
  270                        			
  271                        	
  272                        	
  273                        	; ***************************************************************************
  274                        	; ***************************************************************************
  275                        	;
  276                        	; void __fastcall spr_pattern( unsigned int vaddr<acc> );
  277                        	
  278    00:E826  84 00      	_spr_pattern.1:	sty	<__temp		;     zp=fedcba98 a=76543210
  279    00:E828  0A         			asl	a		; c=f zp=edcba987 a=6543210_
  280    00:E829  26 00      			rol	<__temp
  281    00:E82B  2A         			rol	a		; c=e zp=dcba9876 a=543210_f
  282    00:E82C  26 00      			rol	<__temp
  283    00:E82E  2A         			rol	a		; c=d zp=cba98765 a=43210_fe
  284    00:E82F  26 00      			rol	<__temp
  285    00:E831  2A         			rol	a		; c=4 zp=cba98765 a=3210_fed
  286    00:E832  A0 05      			ldy	#5
  287    00:E834  91 9C      			sta	[spr_ptr], y
  288    00:E836  A5 00      			lda	<__temp
  289    00:E838  88         			dey
  290    00:E839  91 9C      			sta	[spr_ptr], y
  291    00:E83B  60         			rts
  292                        	
  293                        	
  294                        	
  295                        	; ***************************************************************************
  296                        	; ***************************************************************************
  297                        	;
  298                        	; void __fastcall spr_ctrl( unsigned char mask<_al>, unsigned char value<acc> );
  299                        	
  300    00:E83C  25 F8      	_spr_ctrl.2:	and	<_al
  301    00:E83E  85 00      			sta	<__temp
  302    00:E840  A5 F8      			lda	<_al
  303    00:E842  49 FF      			eor	#$FF
  304    00:E844  A0 07      			ldy	#7
  305    00:E846  31 9C      			and	[spr_ptr], y
  306    00:E848  05 00      			ora	<__temp
  307    00:E84A  91 9C      			sta	[spr_ptr], y
  308    00:E84C  60         			rts
  309                        	
  310                        	
  311                        	
  312                        	; ***************************************************************************
  313                        	; ***************************************************************************
  314                        	;
  315                        	; void __fastcall spr_pal( unsigned char palette<acc> )
  316                        	
  317    00:E84D  29 0F      	_spr_pal.1:	and	#$0F
  318    00:E84F  85 00      			sta	<__temp
  319    00:E851  A0 06      			ldy	#6
  320    00:E853  B1 9C      			lda	[spr_ptr], y
  321    00:E855  29 F0      			and	#$F0
  322    00:E857  05 00      			ora	<__temp
  323    00:E859  91 9C      			sta	[spr_ptr], y
  324    00:E85B  60         			rts
  325                        	
  326                        	
  327                        	
  328                        	; ***************************************************************************
  329                        	; ***************************************************************************
  330                        	;
  331                        	; void __fastcall spr_pri( unsigned char priority<acc> )
  332                        	
  333    00:E85C  C9 01      	_spr_pri.1:	cmp	#1
  334    00:E85E  A0 06      			ldy	#6
  335    00:E860  B1 9C      			lda	[spr_ptr], y
  336    00:E862  29 7F      			and	#$7F
  337    00:E864  90 02      			bcc	!+
  338    00:E866  09 80      			ora	#$80
  339    00:E868  91 9C      	!:		sta	[spr_ptr], y
  340    00:E86A  60         			rts
  341                        	
  342                        	
  343                        	
  344                        	; ***************************************************************************
  345                        	; ***************************************************************************
  346                        	;
  347                        	; unsigned int __fastcall spr_get_x( void );
  348                        	
  349    00:E86B  38         	_spr_get_x:	sec
  350    00:E86C  A0 02      			ldy	#2
  351    00:E86E  B1 9C      			lda	[spr_ptr], y
  352    00:E870  E9 20      			sbc	#32
  353    00:E872  AA         			tax
  354    00:E873  C8         			iny
  355    00:E874  B1 9C      			lda	[spr_ptr], y
  356    00:E876  E9 00      			sbc	#0
  357    00:E878  A8         			tay
  358    00:E879  8A         			txa
  359    00:E87A  60         			rts
  360                        	
  361                        	
  362                        	
  363                        	; ***************************************************************************
  364                        	; ***************************************************************************
  365                        	;
  366                        	; unsigned int __fastcall spr_get_y( void );
  367                        	
  368    00:E87B  38         	_spr_get_y:	sec
  369    00:E87C  B2 9C      			lda	[spr_ptr]
  370    00:E87E  E9 40      			sbc	#64
  371    00:E880  AA         			tax
  372    00:E881  A0 01      			ldy	#1
  373    00:E883  B1 9C      			lda	[spr_ptr], y
  374    00:E885  E9 00      			sbc	#0
  375    00:E887  A8         			tay
  376    00:E888  8A         			txa
  377    00:E889  60         			rts
  378                        	
  379                        	
  380                        	
  381               0001     		.if	SUPPORT_SGX
  382                        	
  383                        	; ***************************************************************************
  384                        	; ***************************************************************************
  385                        	;
  386                        	; void __fastcall sgx_spr_set( unsigned char num<acc> );
  387                        	
  388    00:E88A  CD CD 24   	_sgx_spr_set.1:	cmp	sgx_spr_max
  389    00:E88D  90 03      			bcc	!+
  390    00:E88F  8D CD 24   			sta	sgx_spr_max
  391    00:E892  A0 27      	!:		ldy.h	#sgx_spr_sat
  392    00:E894  0A         			asl	a
  393    00:E895  0A         			asl	a
  394    00:E896  0A         			asl	a
  395    00:E897  90 02      			bcc	!+
  396    00:E899  C8         			iny
  397    00:E89A  18         			clc
  398    00:E89B  69 E9      	!:		adc.l	#sgx_spr_sat
  399    00:E89D  85 9E      			sta.l	<sgx_spr_ptr
  400    00:E89F  90 01      			bcc	!+
  401    00:E8A1  C8         			iny
  402    00:E8A2  84 9F      	!:		sty.h	<sgx_spr_ptr
  403    00:E8A4  60         			rts
  404                        	
  405                        	
  406                        	
  407                        	; ***************************************************************************
  408                        	; ***************************************************************************
  409                        	;
  410                        	; void __fastcall sgx_spr_hide( void );
  411                        	
  412    00:E8A5  A0 01      	_sgx_spr_hide:	ldy	#1
  413    00:E8A7  B1 9E      			lda	[sgx_spr_ptr], y
  414    00:E8A9  09 02      			ora	#2
  415    00:E8AB  91 9E      			sta	[sgx_spr_ptr], y
  416    00:E8AD  60         			rts
  417                        	
  418                        	
  419                        	
  420                        	; ***************************************************************************
  421                        	; ***************************************************************************
  422                        	;
  423                        	; void __fastcall sgx_spr_show( void );
  424                        	
  425    00:E8AE  A0 01      	_sgx_spr_show:	ldy	#1
  426    00:E8B0  B1 9E      			lda	[sgx_spr_ptr], y
  427    00:E8B2  29 01      			and	#1
  428    00:E8B4  91 9E      			sta	[sgx_spr_ptr], y
  429    00:E8B6  60         			rts
  430                        	
  431                        	
  432                        	
  433                        	; ***************************************************************************
  434                        	; ***************************************************************************
  435                        	;
  436                        	; void __fastcall sgx_spr_x( unsigned int value<acc> );
  437                        	
  438    00:E8B7  02         	_sgx_spr_x.1:	sxy
  439    00:E8B8  18         			clc
  440    00:E8B9  69 20      			adc	#32
  441    00:E8BB  A0 02      			ldy	#2
  442    00:E8BD  91 9E      			sta	[sgx_spr_ptr], y
  443    00:E8BF  8A         			txa
  444    00:E8C0  69 00      			adc	#0
  445    00:E8C2  C8         			iny
  446    00:E8C3  91 9E      			sta	[sgx_spr_ptr], y
  447    00:E8C5  60         			rts
  448                        	
  449                        	
  450                        	
  451                        	; ***************************************************************************
  452                        	; ***************************************************************************
  453                        	;
  454                        	; void __fastcall sgx_spr_y( unsigned int value<acc> );
  455                        	
  456    00:E8C6  18         	_sgx_spr_y.1:	clc
  457    00:E8C7  69 40      			adc	#64
  458    00:E8C9  92 9E      			sta	[sgx_spr_ptr]
  459    00:E8CB  98         			tya
  460    00:E8CC  69 00      			adc	#0
  461    00:E8CE  A0 01      			ldy	#1
  462    00:E8D0  91 9E      			sta	[sgx_spr_ptr], y
  463    00:E8D2  60         			rts
  464                        			
  465                        	
  466                        	
  467                        	; ***************************************************************************
  468                        	; ***************************************************************************
  469                        	;
  470                        	; void __fastcall sgx_spr_pattern( unsigned int vaddr<acc> );
  471                        	
  472    00:E8D3             	_sgx_spr_pattern.1:
  473    00:E8D3  84 00      			sty	<__temp		;     zp=fedcba98 a=76543210
  474    00:E8D5  0A         			asl	a		; c=f zp=edcba987 a=6543210_
  475    00:E8D6  26 00      			rol	<__temp
  476    00:E8D8  2A         			rol	a		; c=e zp=dcba9876 a=543210_f
  477    00:E8D9  26 00      			rol	<__temp
  478    00:E8DB  2A         			rol	a		; c=d zp=cba98765 a=43210_fe
  479    00:E8DC  26 00      			rol	<__temp
  480    00:E8DE  2A         			rol	a		; c=4 zp=cba98765 a=3210_fed
  481    00:E8DF  A0 05      			ldy	#5
  482    00:E8E1  91 9E      			sta	[sgx_spr_ptr], y
  483    00:E8E3  A5 00      			lda	<__temp
  484    00:E8E5  88         			dey
  485    00:E8E6  91 9E      			sta	[sgx_spr_ptr], y
  486    00:E8E8  60         			rts
  487                        	
  488                        	
  489                        	
  490                        	; ***************************************************************************
  491                        	; ***************************************************************************
  492                        	;
  493                        	; void __fastcall sgx_spr_ctrl( unsigned char mask<_al>, unsigned char value<acc> );
  494                        	
  495    00:E8E9  25 F8      	_sgx_spr_ctrl.2:and	<_al
  496    00:E8EB  85 00      			sta	<__temp
  497    00:E8ED  A5 F8      			lda	<_al
  498    00:E8EF  49 FF      			eor	#$FF
  499    00:E8F1  A0 07      			ldy	#7
  500    00:E8F3  31 9E      			and	[sgx_spr_ptr], y
  501    00:E8F5  05 00      			ora	<__temp
  502    00:E8F7  91 9E      			sta	[sgx_spr_ptr], y
  503    00:E8F9  60         			rts
  504                        	
  505                        	
  506                        	
  507                        	; ***************************************************************************
  508                        	; ***************************************************************************
  509                        	;
  510                        	; void __fastcall sgx_spr_pal( unsigned char palette<acc> )
  511                        	
  512    00:E8FA  29 0F      	_sgx_spr_pal.1:	and	#$0F
  513    00:E8FC  85 00      			sta	<__temp
  514    00:E8FE  A0 06      			ldy	#6
  515    00:E900  B1 9E      			lda	[sgx_spr_ptr], y
  516    00:E902  29 F0      			and	#$F0
  517    00:E904  05 00      			ora	<__temp
  518    00:E906  91 9E      			sta	[sgx_spr_ptr], y
  519    00:E908  60         			rts
  520                        	
  521                        	
  522                        	
  523                        	; ***************************************************************************
  524                        	; ***************************************************************************
  525                        	;
  526                        	; void __fastcall sgx_spr_pri( unsigned char priority<acc> )
  527                        	
  528    00:E909  C9 01      	_sgx_spr_pri.1:	cmp	#1
  529    00:E90B  A0 06      			ldy	#6
  530    00:E90D  B1 9E      			lda	[sgx_spr_ptr], y
  531    00:E90F  29 7F      			and	#$7F
  532    00:E911  90 02      			bcc	!+
  533    00:E913  09 80      			ora	#$80
  534    00:E915  91 9E      	!:		sta	[sgx_spr_ptr], y
  535    00:E917  60         			rts
  536                        	
  537                        	
  538                        	
  539                        	; ***************************************************************************
  540                        	; ***************************************************************************
  541                        	;
  542                        	; unsigned int __fastcall sgx_spr_get_x( void );
  543                        	
  544    00:E918  38         	_sgx_spr_get_x:	sec
  545    00:E919  A0 02      			ldy	#2
  546    00:E91B  B1 9E      			lda	[sgx_spr_ptr], y
  547    00:E91D  E9 20      			sbc	#32
  548    00:E91F  AA         			tax
  549    00:E920  C8         			iny
  550    00:E921  B1 9E      			lda	[sgx_spr_ptr], y
  551    00:E923  E9 00      			sbc	#0
  552    00:E925  A8         			tay
  553    00:E926  8A         			txa
  554    00:E927  60         			rts
  555                        	
  556                        	
  557                        	
  558                        	; ***************************************************************************
  559                        	; ***************************************************************************
  560                        	;
  561                        	; unsigned int __fastcall sgx_spr_get_y( void );
  562                        	
  563    00:E928  38         	_sgx_spr_get_y:	sec
  564    00:E929  B2 9E      			lda	[sgx_spr_ptr]
  565    00:E92B  E9 40      			sbc	#64
  566    00:E92D  AA         			tax
  567    00:E92E  A0 01      			ldy	#1
  568    00:E930  B1 9E      			lda	[sgx_spr_ptr], y
  569    00:E932  E9 00      			sbc	#0
  570    00:E934  A8         			tay
  571    00:E935  8A         			txa
  572    00:E936  60         			rts
  573                        	
  574                        		.endif	SUPPORT_SGX
                             #[2]   "..\..\..\include\hucc\hucc-final.asm"
   76                        		.endif
   77                        	
   78               0001     		.ifdef	HUCC_USES_BLKMAP		; Set in hucc_blkmap.h
                             #[3]   "..\..\..\include\hucc\blkmap.asm"
   79                        			include	"blkmap.asm"
    1                        	; ***************************************************************************
    2                        	; ***************************************************************************
    3                        	;
    4                        	; blkmap.asm
    5                        	;
    6                        	; A map system based on 16x16 meta-tiles (aka "blocks", aka CHR/BLK/MAP).
    7                        	;
    8                        	; Copyright John Brandwood 2025.
    9                        	;
   10                        	; Distributed under the Boost Software License, Version 1.0.
   11                        	; (See accompanying file LICENSE_1_0.txt or copy at
   12                        	;  http://www.boost.org/LICENSE_1_0.txt)
   13                        	;
   14                        	; ***************************************************************************
   15                        	; ***************************************************************************
   16                        	;
   17                        	; The maximum X and Y size for blkmaps is 128 blocks (2048 pixels).
   18                        	;
   19                        	; The maximum total size for a blkmap is 16KBytes, which allows for maps up
   20                        	; to 128x128 blocks (2048x2048 pixels).
   21                        	;
   22                        	; Huge multi-screen blkmaps are also supported (optionally).
   23                        	;
   24                        	; The maximum X and Y for multi-screen maps is 128 screens (32768 pixels).
   25                        	;
   26                        	; The maximum total size for a multi-screen map is 8KBytes, which allows for
   27                        	; a total of 1024 screens.
   28                        	;
   29                        	; ***************************************************************************
   30                        	; ***************************************************************************
   31                        	
   32                        	;
   33                        	; Include dependancies ...
   34                        	;
   35                        	
   36                        			include "common.asm"		; Common helpers.
   37                        			include "vce.asm"		; Useful VCE routines.
   38                        			include "vdc.asm"		; Useful VCE routines.
   39                        	
   40                        	;
   41                        	; Support large blkmaps up to 16KBytes instead of the regular 8KBytes?
   42                        	;
   43                        	; The maximum X and Y size for regular blkmaps is 128 tiles (2048 pixels).
   44                        	;
   45                        	; This allows for individual maps up to 128x128 tiles (2048x2048 pixels) vs
   46                        	; default limit of 128x64 or 64x128.
   47                        	;
   48                        	
   49               0000     		.ifndef	BLKMAP_LARGEMAP
   51                        		.endif
   52                        	
   53                        	;
   54                        	; Support huge multi-screen maps, up to 32768 pixels wide/high?
   55                        	;
   56                        	; These are sectorized maps split into individual BAT-sized "screens", with
   57                        	; a maximum of 1024 screens per map.
   58                        	;
   59                        	; The BAT size that is used when drawing *must* be the same as the BAT size
   60                        	; that was chosen when creating the multi-screen map.
   61                        	;
   62                        	; Each screen can use a unique set of block definitions, or it might choose
   63                        	; to share the same block definitions that are used on another screen.
   64                        	;
   65                        	; Each screen may choose which 8KByte banks of character data to select for
   66                        	; the 4 banks (32KBytes) of VRAM that its block definitions use, with a max
   67                        	; of 16 banks of characters per multi-screen map.
   68                        	;
   69                        	; Loading those character banks dynamically is an exercise for the user!
   70                        	;
   71                        	; Enabling support adds extra library code, and slightly slows down the use
   72                        	; of regular blkmaps.
   73                        	;
   74                        	
   75               0000     		.ifndef	BLKMAP_MULTISCR
   77                        		.endif
   78                        	
   79                        	;
   80                        	; Block definitions can either use character data from VRAM $1000..$7FFF or
   81                        	; they can be limited to use the 32KByte of characters in VRAM $1000..$4FFF
   82                        	; which then frees up 2-bits for flag information for each character in the
   83                        	; block.
   84                        	;
   85                        	; These 2-bits are perfect for using as collision information in game maps,
   86                        	; allowing storage of states like transparent, solid, up-slope, down-slope.
   87                        	;
   88                        	; Typically this flag information is set by the map conversion tools from a
   89                        	; seperate "collision" map layer.
   90                        	;
   91                        	
   92               0000     		.ifndef	BLKDEF_CHR_FLAG
   94                        		.endif
   95                        	
   96                        	;
   97                        	; Block definitions are accessed in MPR2 ($4000..$5FFF), and must not cross
   98                        	; the bank boundary.
   99                        	;
  100                        	; When working this way, 8 pointers in ZP are used to access the individual
  101                        	; bytes in the block definition. This is fine when using a regular map on a
  102                        	; PC Engine, but it is awfully slow when using multi-screen maps or drawing
  103                        	; maps on both VDC chips in a SuperGRAFX because the pointer values must be
  104                        	; constantly changed.
  105                        	;
  106                        	; When using multi-screen maps, or when developing a SuperGRAFX game, or if
  107                        	; developing a CDROM game, then it is usually preferable to store the block
  108                        	; definitions with 2KByte alignment, especially if they are normally stored
  109                        	; compressed and then decompressed into a 2KByte buffer in RAM when needed.
  110                        	;
  111                        	; This option controls whether the definitions are stored 2KByte aligned or
  112                        	; if pointers should be used instead.
  113                        	;
  114                        	
  115               0000     		.ifndef	BLKDEF_POINTERS
  117                        		.endif
  118                        	
  119                        	;
  120                        	; Add a timing bar to the scroll_map() to see how long the drawing takes?
  121                        	;
  122                        	
  123               0000     		.ifndef	BLKMAP_TIMETEST
  125                        		.endif
  126                        	
  127                        	;
  128                        	;
  129                        	;
  130                        	
  131               0000     		.if	BLKDEF_POINTERS
  144                        		.else
  145                        	
  146                        		; If the block definititions are 2KByte aligned.
  147                        	
  148               4000     	BLK_4000_TL_L	=	$4000
  149               4100     	BLK_4000_TR_L	=	$4100
  150               4200     	BLK_4000_BL_L	=	$4200
  151               4300     	BLK_4000_BR_L	=	$4300
  152               4400     	BLK_4000_TL_H	=	$4400
  153               4500     	BLK_4000_TR_H	=	$4500
  154               4600     	BLK_4000_BL_H	=	$4600
  155               4700     	BLK_4000_BR_H	=	$4700
  156                        	
  157               4800     	BLK_4800_TL_L	=	$4800
  158               4900     	BLK_4800_TR_L	=	$4900
  159               4A00     	BLK_4800_BL_L	=	$4A00
  160               4B00     	BLK_4800_BR_L	=	$4B00
  161               4C00     	BLK_4800_TL_H	=	$4C00
  162               4D00     	BLK_4800_TR_H	=	$4D00
  163               4E00     	BLK_4800_BL_H	=	$4E00
  164               4F00     	BLK_4800_BR_H	=	$4F00
  165                        	
  166               5000     	BLK_5000_TL_L	=	$5000
  167               5100     	BLK_5000_TR_L	=	$5100
  168               5200     	BLK_5000_BL_L	=	$5200
  169               5300     	BLK_5000_BR_L	=	$5300
  170               5400     	BLK_5000_TL_H	=	$5400
  171               5500     	BLK_5000_TR_H	=	$5500
  172               5600     	BLK_5000_BL_H	=	$5600
  173               5700     	BLK_5000_BR_H	=	$5700
  174                        	
  175               5800     	BLK_5800_TL_L	=	$5800
  176               5900     	BLK_5800_TR_L	=	$5900
  177               5A00     	BLK_5800_BL_L	=	$5A00
  178               5B00     	BLK_5800_BR_L	=	$5B00
  179               5C00     	BLK_5800_TL_H	=	$5C00
  180               5D00     	BLK_5800_TR_H	=	$5D00
  181               5E00     	BLK_5800_BL_H	=	$5E00
  182               5F00     	BLK_5800_BR_H	=	$5F00
  183                        	
  184                        		.endif
  185                        	
  186               0080     	MAP_UNALIGNED_X	=	$80
  187               0040     	MAP_UNALIGNED_Y	=	$40
  188                        	
  189                        	;
  190                        	;
  191                        	;
  192                        	
  193               29E9     			.bss
  194                        	
  195                        	; **************
  196                        	; 8-byte (or 2-byte) entry for each SCREEN in the MULTI_MAP.
  197                        	
  198               0000     			.rsset	0
  199               0000     		.if	BLKDEF_POINTERS
  202                        		.else
  203               0000     	SCR_MAP_PAGE	.rs	1	; 256-byte aligned.
  204               0001     	SCR_MAP_BANK	.rs	1
  205               0002     	SCR_BLK_PAGE	.rs	1	; >$4000, >$4800, >$5000, or >$5800.
  206               0003     	SCR_BLK_BANK	.rs	1
  207               0004     	SCR_TBL_PAGE	.rs	1	; 256-byte aligned.
  208               0005     	SCR_TBL_BANK	.rs	1
  209               0006     	SCR_CHR_12	.rs	1	; Which CHR banks are used by the BLK, with
  210               0007     	SCR_CHR_34	.rs	1	; a max of 16 CHR banks per MULTI_MAP.
  211                        		.endif
  212                        	
  213                        			; A simple macro to help build a multi-screen map.
  214                        	
  215               0000     		.ifndef	SCREEN
  224                        		.endif
  225                        	
  226    F8:29E9             	map_blk_flag:	ds	1	; Returned from _get_map_block().
  227    F8:29EA             	map_blk_mask:	ds	1	; Returned from _get_map_block().
  228                        	
  229                        	; **************
  230                        	; 16-bytes of VDC blkmap info.
  231                        	;
  232                        	; N.B. MUST be 16-bytes before the SGX versions to use PCE_VDC_OFFSET.
  233                        	
  234    F8:29EB             	vdc_old_chr_x:	ds	1	; Previous top-left X in CHR (lo-byte only).
  235    F8:29EC             	vdc_old_chr_y:	ds	1	; Previous top-left Y in CHR (lo-byte only).
  236                        	
  237    F8:29ED             	vdc_tbl_addr:	ds	2	; 256-byte aligned.
  238    F8:29EF             	vdc_tbl_bank:	ds	1
  239                        	
  240    F8:29F0             	vdc_blk_addr:	ds	2	; 2KBytes of data, 256-byte aligned.
  241    F8:29F2             	vdc_blk_bank:	ds	1
  242                        	
  243    F8:29F3             	vdc_map_addr:	ds	2	; Mapped into MPR3..MPR5, max 16KBytes.
  244    F8:29F5             	vdc_map_bank:	ds	1
  245                        	
  246    F8:29F6             	vdc_scr_addr:	ds	2	; 8KByte maximum size.
  247    F8:29F8             	vdc_scr_bank:	ds	1
  248    F8:29F9             	vdc_scr_chr12:	ds	1	; Which CHR banks are used by the BLK, with
  249    F8:29FA             	vdc_scr_chr34:	ds	1	; a max of 16 banks per multi-screen map.
  250                        	
  251               0001     		.if	SUPPORT_SGX
  252                        	
  253                        	; **************
  254                        	; 16-bytes of SGX blkmap info.
  255                        	;
  256                        	; N.B. MUST be 16-bytes after the VDC versions to use SGX_VDC_OFFSET.
  257                        	
  258    F8:29FB             	sgx_old_chr_x:	ds	1	; Previous top-left X in CHR (lo-byte only).
  259    F8:29FC             	sgx_old_chr_y:	ds	1	; Previous top-left Y in CHR (lo-byte only).
  260                        	
  261    F8:29FD             	sgx_tbl_addr:	ds	2	; 256-byte aligned.
  262    F8:29FF             	sgx_tbl_bank:	ds	1
  263                        	
  264    F8:2A00             	sgx_blk_addr:	ds	2	; 2KBytes of data, 256-byte aligned.
  265    F8:2A02             	sgx_blk_bank:	ds	1
  266                        	
  267    F8:2A03             	sgx_map_addr:	ds	2	; Mapped into MPR3..MPR4, max 8KBytes.
  268    F8:2A05             	sgx_map_bank:	ds	1
  269                        	
  270    F8:2A06             	sgx_scr_addr:	ds	2	; 8KByte maximum size.
  271    F8:2A08             	sgx_scr_bank:	ds	1
  272    F8:2A09             	sgx_scr_chr12:	ds	1	; Which CHR banks are used by the BLK, with
  273    F8:2A0A             	sgx_scr_chr34:	ds	1	; a max of 16 banks per multi-screen map.
  274                        	
  275                        		.endif	SUPPORT_SGX
  276                        	
  277               0000     		.if	0
  310                        		.endif	0
  311                        	
  312                        	; **************
  313                        	; Aliases for the asm variable names in HuCC.
  314                        	;
  315                        	
  316               0001     		.ifdef	HUCC
  317                        	
  318    F8:2A0B             	_map_blk_flag	.alias	map_blk_flag
  319    F8:2A0B             	_map_blk_mask	.alias	map_blk_mask
  320                        	
  321    F8:2A0B             	_vdc_map_draw_w	.alias	vdc_map_draw_w
  322    F8:2A0B             	_vdc_map_draw_h	.alias	vdc_map_draw_h
  323    F8:2A0B             	_vdc_map_pxl_x	.alias	vdc_map_pxl_x
  324    F8:2A0B             	_vdc_map_pxl_y	.alias	vdc_map_pxl_y
  325    F8:2A0B             	_vdc_old_chr_x	.alias	vdc_old_chr_x
  326    F8:2A0B             	_vdc_old_chr_y	.alias	vdc_old_chr_y
  327    F8:2A0B             	_vdc_tbl_addr	.alias	vdc_tbl_addr
  328    F8:2A0B             	_vdc_tbl_bank	.alias	vdc_tbl_bank
  329    F8:2A0B             	_vdc_blk_addr	.alias	vdc_blk_addr
  330    F8:2A0B             	_vdc_blk_bank	.alias	vdc_blk_bank
  331    F8:2A0B             	_vdc_map_line_w	.alias	vdc_map_line_w
  332    F8:2A0B             	_vdc_map_scrn_w	.alias	vdc_map_scrn_w
  333    F8:2A0B             	_vdc_map_addr	.alias	vdc_map_addr
  334    F8:2A0B             	_vdc_map_bank	.alias	vdc_map_bank
  335    F8:2A0B             	_vdc_scr_addr	.alias	vdc_scr_addr
  336    F8:2A0B             	_vdc_scr_bank	.alias	vdc_scr_bank
  337    F8:2A0B             	_vdc_scr_chr12	.alias	vdc_scr_chr12
  338    F8:2A0B             	_vdc_scr_chr34	.alias	vdc_scr_chr34
  339                        	
  340               0001     		.if	SUPPORT_SGX
  341    F8:2A0B             	_sgx_map_draw_w	.alias	sgx_map_draw_w
  342    F8:2A0B             	_sgx_map_draw_h	.alias	sgx_map_draw_h
  343    F8:2A0B             	_sgx_map_pxl_x	.alias	sgx_map_pxl_x
  344    F8:2A0B             	_sgx_map_pxl_y	.alias	sgx_map_pxl_y
  345    F8:2A0B             	_sgx_old_chr_x	.alias	sgx_old_chr_x
  346    F8:2A0B             	_sgx_old_chr_y	.alias	sgx_old_chr_y
  347    F8:2A0B             	_sgx_tbl_addr	.alias	sgx_tbl_addr
  348    F8:2A0B             	_sgx_tbl_bank	.alias	sgx_tbl_bank
  349    F8:2A0B             	_sgx_blk_addr	.alias	sgx_blk_addr
  350    F8:2A0B             	_sgx_blk_bank	.alias	sgx_blk_bank
  351    F8:2A0B             	_sgx_map_line_w	.alias	sgx_map_line_w
  352    F8:2A0B             	_sgx_map_scrn_w	.alias	sgx_map_scrn_w
  353    F8:2A0B             	_sgx_map_addr	.alias	sgx_map_addr
  354    F8:2A0B             	_sgx_map_bank	.alias	sgx_map_bank
  355    F8:2A0B             	_sgx_scr_addr	.alias	sgx_scr_addr
  356    F8:2A0B             	_sgx_scr_bank	.alias	sgx_scr_bank
  357    F8:2A0B             	_sgx_scr_chr12	.alias	sgx_scr_chr12
  358    F8:2A0B             	_sgx_scr_chr34	.alias	sgx_scr_chr34
  359                        		.endif	SUPPORT_SGX
  360                        	
  361                        		.endif	HUCC
  362                        	
  363                        	; **************
  364                        	; Temporary variables for drawing, using common zero-page locations.
  365                        	;
  366                        	
  367               20F8     	map_bat_x	=	_al	; Set by draw_map(), scroll_map() if drawing
  368               20F9     	map_bat_y	=	_ah	; aligned, or as parameters to blit_map().
  369                        	
  370               20FA     	map_draw_w	=	_bl	; Set by draw_map(), scroll_map(), but given
  371               20FB     	map_draw_h	=	_bh	; as parameters to blit_map().
  372                        	
  373               20FC     	map_pxl_x	=	_cx	; Set by draw_map(), scroll_map() and also by
  374               20FC     	map_chr_x	=	_cl	; blit__map(), from current vdc_map_pxl_x.
  375               20FD     	map_scrn_x	=	_ch
  376                        	
  377               20FE     	map_pxl_y	=	_dx	; Set by draw_map(), scroll_map() and also by
  378               20FE     	map_chr_y	=	_dl	; blit__map(), from current vdc_map_pxl_y.
  379               20FF     	map_scrn_y	=	_dh
  380                        	
  381               20EE     	map_line	=	_si	; Start of map data line being drawn.
  382                        	
  383               2000     	map_count	=	__temp + 0
  384               2001     	map_drawn	=	__temp + 1
  385                        	
  386               E937     			.code
  387                        	
  388                        	
  389                        	
  390    01:D60C             	blkmap_group	.procgroup
  391                        	
  392                        	; ***************************************************************************
  393                        	; ***************************************************************************
  394                        	;
  395                        	; _set_blocks - Initialize the block definition pointers.
  396                        	; _sgx_set_blocks - Initialize the block definition pointers.
  397                        	;
  398                        	; void __fastcall set_blocks( unsigned char __far *blk_def<vdc_blk_bank:vdc_blk_addr>, unsigned char __far *flg_def<vdc_tbl_bank:vdc_tbl_addr>, unsigned char number_of_blk<_al> );
  399                        	; void __fastcall sgx_set_blocks( unsigned char __far *blk_def<sgx_blk_bank:sgx_blk_addr>, unsigned char __far *flg_def<sgx_tbl_bank:sgx_tbl_addr>, unsigned char number_of_blk<_al> );
  400                        	;
  401                        	
  402               0001     		.if	SUPPORT_SGX
  403                        	
  404                        			.proc	_sgx_set_blocks.3
  410                        			.endp
  411                        		.endif
  412                        	
  413    01:D60C             			.proc	_set_blocks.3
  414                        	
  415    01:D60C  82         			clx				; Offset to PCE VDC.
  416                        	
  417    01:D60D  BD EE 29   			lda.h	vdc_tbl_addr, x		; Remap the address to MPR2.
  418    01:D610  29 1F      			and	#$1F
  419    01:D612  09 40      			ora	#$40
  420    01:D614  9D EE 29   			sta.h	vdc_tbl_addr, x
  421                        	
  422    01:D617  BD F1 29   			lda.h	vdc_blk_addr, x		; Remap the address to MPR2.
  423    01:D61A  29 1F      			and	#$1F
  424    01:D61C  09 40      			ora	#$40
  425    01:D61E  9D F1 29   			sta.h	vdc_blk_addr, x
  426                        	
  427               0000     		.if	BLKDEF_POINTERS
  479                        		.endif	BLKDEF_POINTERS
  480                        	
  481                        			leave
         01:D621  4C EF FF   			jmp	leave_proc
  482                        	
  483                        			.endp
  484                        	
  485                        	
  486                        	
  487                        	; ***************************************************************************
  488                        	; ***************************************************************************
  489                        	;
  490                        	; _draw_map - Draw the entire screen at the current coordinates.
  491                        	; _sgx_draw_map - Draw the entire screen at the current coordinates.
  492                        	;
  493                        	; void __fastcall draw_map( void );
  494                        	; void __fastcall sgx_draw_map( void );
  495                        	;
  496                        	
  497               0001     		.if	SUPPORT_SGX
  498                        	
  499    01:D624             	_sgx_draw_map	.proc
  500                        	
  501    01:D624  A2 10      			ldx	#SGX_VDC_OFFSET		; Offset to SGX VDC.
  502    01:D626  F0         			db	$F0			; Turn "clx" into a "beq".
  503                        	
  504    01:D627             			.ref	_draw_map
  505                        			.endp
  506                        		.endif
  507                        	
  508    01:D627             	_draw_map	.proc
  509                        	
  510    01:D627  82         			clx				; Offset to PCE VDC.
  511                        	
  512    01:D628  43 04      			tma2				; Preserve MPR2..MPR4.
  513    01:D62A  48         			pha
  514    01:D62B  43 08      			tma3
  515    01:D62D  48         			pha
  516    01:D62E  43 10      			tma4
  517    01:D630  48         			pha
  518               0000     		.if	BLKMAP_LARGEMAP
  521                        		.endif
  522                        	
  523    01:D631  20 33 D7   			jsr	map_pxl_2_chr		; Set up the draw coordinates.
  524                        	
  525    01:D634  A5 FC      			lda	<map_chr_x		; Reset previous X position.
  526    01:D636  9D EB 29   			sta	vdc_old_chr_x, x
  527                        	
  528    01:D639  A5 FE      			lda	<map_chr_y		; Reset previous Y position,
  529    01:D63B  1A         			inc	a			; ready to draw multiple rows.
  530    01:D63C  9D EC 29   			sta	vdc_old_chr_y, x
  531                        	
  532    01:D63F  BD B4 24   			lda	vdc_map_draw_w, x	; Draw the whole screen.
  533    01:D642  85 FA      			sta	<map_draw_w
  534    01:D644  BD B5 24   			lda	vdc_map_draw_h, x
  535    01:D647  85 FB      			sta	<map_draw_h
  536                        	
  537    01:D649  20 89 D9   			jsr	map_scroll_y		; Draw N row of CHR to the BAT.
  538                        	
  539               0000     		.if	BLKMAP_LARGEMAP
  542                        		.endif
  543    01:D64C  68         			pla				; Restore MPR2..MPR4.
  544    01:D64D  53 10      			tam4
  545    01:D64F  68         			pla
  546    01:D650  53 08      			tam3
  547    01:D652  68         			pla
  548    01:D653  53 04      			tam2
  549                        	
  550                        			leave
         01:D655  4C EF FF   			jmp	leave_proc
  551                        	
  552                        			.endp
  553                        	
  554                        	
  555                        	
  556                        	; ***************************************************************************
  557                        	; ***************************************************************************
  558                        	;
  559                        	; _scroll_map - Draw a single row of CHR into the BAT to update the edge.
  560                        	; _sgx_scroll_map - Draw a single row of CHR into the BAT to update the edge.
  561                        	;
  562                        	; void __fastcall scroll_map( void );
  563                        	; void __fastcall sgx_scroll_map( void );
  564                        	;
  565                        	
  566               0001     		.if	SUPPORT_SGX
  567                        	
  568    01:D658             	_sgx_scroll_map	.proc
  569                        	
  570    01:D658  A2 10      			ldx	#SGX_VDC_OFFSET		; Offset to SGX VDC.
  571    01:D65A  F0         			db	$F0			; Turn "clx" into a "beq".
  572                        	
  573    01:D65B             			.ref	_scroll_map
  574                        			.endp
  575                        		.endif
  576                        	
  577    01:D65B             	_scroll_map	.proc
  578                        	
  579    01:D65B  82         			clx				; Offset to PCE VDC.
  580                        	
  581               0000     		.if	BLKMAP_TIMETEST
  587                        		.endif
  588                        	
  589    01:D65C  43 04      			tma2				; Preserve MPR2..MPR4.
  590    01:D65E  48         			pha
  591    01:D65F  43 08      			tma3
  592    01:D661  48         			pha
  593    01:D662  43 10      			tma4
  594    01:D664  48         			pha
  595               0000     		.if	BLKMAP_LARGEMAP
  598                        		.endif
  599                        	
  600    01:D665  20 33 D7   			jsr	map_pxl_2_chr		; Set up the draw coordinates.
  601                        	
  602               0001     		.if	BLKMAP_MULTISCR
  603    01:D668  A5 FD      			lda	<map_scrn_x		; map_scroll_x can change this!
  604    01:D66A  48         			pha
  605                        		.endif
  606                        	
  607    01:D66B  BD B5 24   			lda	vdc_map_draw_h, x	; Draw new LHS or RHS if needed.
  608    01:D66E  85 FB      			sta	<map_draw_h
  609                        	;		lda	#1			; map_scroll_x only ever draws a
  610                        	;		sta	<map_draw_w		; single column.
  611    01:D670  20 6A D8   			jsr	map_scroll_x
  612                        	
  613    01:D673  BD EB 29   			lda	vdc_old_chr_x, x	; Restore map_chr_x which could
  614    01:D676  85 FC      			sta	<map_chr_x		; be changed by map_scroll_x.
  615                        	
  616               0001     		.if	BLKMAP_MULTISCR
  617    01:D678  68         			pla				; Restore before map_scroll_y.
  618    01:D679  85 FD      			sta	<map_scrn_x
  619                        		.endif
  620                        	
  621    01:D67B  BD B4 24   			lda	vdc_map_draw_w, x	; Draw new TOP or BTM if needed.
  622    01:D67E  85 FA      			sta	<map_draw_w
  623    01:D680  A9 01      			lda	#1
  624    01:D682  85 FB      			sta	<map_draw_h
  625    01:D684  20 89 D9   			jsr	map_scroll_y
  626                        	
  627               0000     		.if	BLKMAP_LARGEMAP
  630                        		.endif
  631    01:D687  68         			pla				; Restore MPR2..MPR4.
  632    01:D688  53 10      			tam4
  633    01:D68A  68         			pla
  634    01:D68B  53 08      			tam3
  635    01:D68D  68         			pla
  636    01:D68E  53 04      			tam2
  637                        	
  638               0000     		.if	BLKMAP_TIMETEST
  640                        		.endif
  641                        	
  642                        			leave
         01:D690  4C EF FF   			jmp	leave_proc
  643                        	
  644                        			.endp
  645                        	
  646                        	
  647                        	
  648                        	; ***************************************************************************
  649                        	; ***************************************************************************
  650                        	;
  651                        	; _blit_map - Draw a map rectangle to specific BAT coordinates.
  652                        	; _sgx_blit_map - Draw a map rectangle to specific BAT coordinates.
  653                        	;
  654                        	; void __fastcall blit_map( unsigned char tile_x<map_bat_x>, unsigned char tile_y<map_bat_y>, unsigned char tile_w<map_draw_x>, unsigned char tile_h<map_draw_y> );
  655                        	; void __fastcall sgx_blit_map( unsigned char tile_x<map_bat_x>, unsigned char tile_y<map_bat_y>, unsigned char tile_w<map_draw_x>, unsigned char tile_h<map_draw_y> );
  656                        	;
  657                        	; Normally you'd just use _draw_map() and _scroll_map(), but for those folks
  658                        	; who really wish to take manual control, you can use this.
  659                        	;
  660                        	
  661               0001     		.if	SUPPORT_SGX
  662                        	
  663                        	_sgx_blit_map	.proc
  669                        			.endp
  670                        		.endif
  671                        	
  672    01:D693             	_blit_map	.proc
  673                        	
  674    01:D693  82         			clx				; Offset to PCE VDC.
  675                        	
  676    01:D694  BD F8 29   			lda	vdc_scr_bank, x		; Skip this if a multi-screen
  677    01:D697  D0 36      			bne	.exit			; blkmap.
  678                        	
  679    01:D699  43 04      			tma2				; Preserve MPR2..MPR4.
  680    01:D69B  48         			pha
  681    01:D69C  43 08      			tma3
  682    01:D69E  48         			pha
  683    01:D69F  43 10      			tma4
  684    01:D6A1  48         			pha
  685               0000     		.if	BLKMAP_LARGEMAP
  688                        		.endif
  689                        	
  690    01:D6A2  BD BC 24   			lda	vdc_map_option, x	; Preserve current map options.
  691    01:D6A5  48         			pha
  692    01:D6A6  09 C0      			ora	#MAP_UNALIGNED_X | MAP_UNALIGNED_Y
  693    01:D6A8  9D BC 24   			sta	vdc_map_option, x
  694                        	
  695    01:D6AB  20 33 D7   			jsr	map_pxl_2_chr		; Set up the draw coordinates.
  696                        	
  697    01:D6AE  A5 FA      			lda	<map_draw_w		; Are we drawing just 1 column?
  698    01:D6B0  C9 01      			cmp	#1
  699    01:D6B2  F0 1E      			beq	.draw_column
  700                        	
  701                        			; Draw N rows.
  702                        	
  703    01:D6B4  A5 FC      	.draw_rows:	lda	<map_chr_x		; Reset previous X position.
  704    01:D6B6  9D EB 29   			sta	vdc_old_chr_x, x
  705                        	
  706    01:D6B9  A5 FE      			lda	<map_chr_y		; Reset previous Y position,
  707    01:D6BB  1A         			inc	a			; ready to draw rows upwards.
  708    01:D6BC  9D EC 29   			sta	vdc_old_chr_y, x
  709                        	
  710    01:D6BF  20 89 D9   			jsr	map_scroll_y		; Draw a row of CHR to the BAT.
  711                        	
  712                        			; Drawing completed.
  713                        	
  714    01:D6C2  68         	.finished:	pla				; Restore previous map options.
  715    01:D6C3  9D BC 24   			sta	vdc_map_option, x
  716                        	
  717               0000     		.if	BLKMAP_LARGEMAP
  720                        		.endif
  721    01:D6C6  68         			pla				; Restore MPR2..MPR4.
  722    01:D6C7  53 10      			tam4
  723    01:D6C9  68         			pla
  724    01:D6CA  53 08      			tam3
  725    01:D6CC  68         			pla
  726    01:D6CD  53 04      			tam2
  727                        	
  728                        	.exit:		leave
         01:D6CF  4C EF FF   			jmp	leave_proc
  729                        	
  730                        			; Draw 1 column.
  731                        	
  732    01:D6D2  A5 FC      	.draw_column:	lda	<map_chr_x		; Reset previous X position.
  733    01:D6D4  1A         			inc	a			; ready to draw 1 column.
  734    01:D6D5  9D EB 29   			sta	vdc_old_chr_x, x
  735                        	
  736    01:D6D8  A5 FE      			lda	<map_chr_y		; Reset previous Y position.
  737    01:D6DA  9D EC 29   			sta	vdc_old_chr_y, x
  738                        	
  739    01:D6DD  20 6A D8   			jsr	map_scroll_x		; Draw a single column of CHR.
  740                        	
  741    01:D6E0  80 E0      			bra	.finished
  742                        	
  743                        			.endp
  744                        	
  745                        	
  746                        	
  747                        	; ***************************************************************************
  748                        	; ***************************************************************************
  749                        	;
  750                        	; _get_map_block - Get the block number used at a map pixel coordinate.
  751                        	; _sgx_get_map_block - Get the block number used at a map pixel coordinate.
  752                        	;
  753                        	; unsigned char __fastcall _get_map_block( unsigned int x<map_pxl_x>, unsigned int y<map_pxl_y> );
  754                        	; unsigned char __fastcall _sgx_get_map_block( unsigned int x<map_pxl_x>, unsigned int y<map_pxl_y> );
  755                        	;
  756                        	
  757               0001     		.if	SUPPORT_SGX
  758                        	
  759                        			.proc	_sgx_get_map_block.2
  765                        			.endp
  766                        		.endif
  767                        	
  768    01:D6E2             			.proc	_get_map_block.2
  769                        	
  770    01:D6E2  82         			clx				; Offset to PCE VDC.
  771                        	
  772    01:D6E3  43 04      			tma2				; Preserve MPR2..MPR4.
  773    01:D6E5  48         			pha
  774    01:D6E6  43 08      			tma3
  775    01:D6E8  48         			pha
  776    01:D6E9  43 10      			tma4
  777    01:D6EB  48         			pha
  778               0000     		.if	BLKMAP_LARGEMAP
  781                        		.endif
  782                        	
  783    01:D6EC  20 47 D7   			jsr	xvt_pxl_2_chr		; Set up the query coordinates.
  784                        	
  785    01:D6EF  20 75 D7   			jsr	map_chr_2_data		; Page in the map address.
  786                        	
  787    01:D6F2  B2 EC      			lda	[_bp]			; Read the BLK from the map.
  788    01:D6F4  A8         			tay
  789                        	
  790    01:D6F5  A5 FC      			lda	<map_chr_x		; Calc the BLK address offset
  791    01:D6F7  4A         			lsr	a			; use depending upon even/odd
  792    01:D6F8  A5 FE      			lda	<map_chr_y		; CHR coordinates (not BAT to
  793    01:D6FA  29 01      			and	#1			; support unaligned drawing).
  794    01:D6FC  2A         			rol	a
  795    01:D6FD  09 04      			ora	#4			; Offset to BLK table top byte.
  796    01:D6FF  7D F1 29   			adc.h	vdc_blk_addr, x		; What is the BLK data address?
  797    01:D702  85 ED      			sta.h	<_bp			; $4000, $4800, $5000 or $5800.
  798    01:D704  64 EC      			stz.l	<_bp
  799    01:D706  B1 EC      			lda	[_bp], y		; Read the collision flags from
  800    01:D708  29 0C      			and	#%00001100		; the top byte of the CHR.
  801    01:D70A  4A         			lsr	a
  802    01:D70B  4A         			lsr	a
  803    01:D70C  4A         			lsr	a			; Swizzle the bottom bit to get
  804    01:D70D  90 02      			bcc	!+			; the same bit order as used in
  805    01:D70F  09 02      			ora	#2			; .HALTMAP layer.
  806    01:D711  8D E9 29   	!:		sta	map_blk_flag
  807                        	
  808    01:D714  BD EF 29   			lda	vdc_tbl_bank, x		; Is there a table of flags?
  809    01:D717  F0 09      			beq	!+
  810    01:D719  53 08      			tam3
  811                        	;		inc	a
  812                        	;		tam4
  813                        	;		lda.l	vdc_tbl_addr, x
  814                        	;		sta.l	<_bp
  815    01:D71B  BD EE 29   			lda.h	vdc_tbl_addr, x		; If so, it must be aligned!
  816    01:D71E  85 ED      			sta.h	<_bp
  817    01:D720  B1 EC      			lda	[_bp], y		; Read the .MASKMAP/.OVERMAP
  818    01:D722  8D EA 29   	!:		sta	map_blk_mask		; flag value for this BLK.
  819                        	
  820               0000     		.if	BLKMAP_LARGEMAP
  823                        		.endif
  824    01:D725  68         			pla				; Restore MPR2..MPR4.
  825    01:D726  53 10      			tam4
  826    01:D728  68         			pla
  827    01:D729  53 08      			tam3
  828    01:D72B  68         			pla
  829    01:D72C  53 04      			tam2
  830                        	
  831    01:D72E  02         			sxy				; Put the BLK number in X.
  832    01:D72F  C2         			cly
  833                        	
  834                        			leave				; All done!
         01:D730  4C EF FF   			jmp	leave_proc
  835                        	
  836                        			.endp
  837                        	
  838                        	
  839                        	
  840                        	; ***************************************************************************
  841                        	; ***************************************************************************
  842                        	;
  843                        	; map_pxl_2_chr - Convert PXL to CHR, BLK and SCR coordinates.
  844                        	;
  845                        	
  846    01:D733  BD BA 24   	map_pxl_2_chr:	lda.l	vdc_map_pxl_y, x	; Get current map Y coordinate.
  847    01:D736  85 FE      			sta.l	<map_pxl_y
  848    01:D738  BD BB 24   			lda.h	vdc_map_pxl_y, x
  849    01:D73B  85 FF      			sta.h	<map_pxl_y
  850                        	
  851    01:D73D  BD B8 24   			lda.l	vdc_map_pxl_x, x	; Get current map X coordinate.
  852    01:D740  85 FC      			sta.l	<map_pxl_x
  853    01:D742  BD B9 24   			lda.h	vdc_map_pxl_x, x
  854    01:D745  85 FD      			sta.h	<map_pxl_x
  855                        	
  856    01:D747  A5 FD      	xvt_pxl_2_chr:	lda.h	<map_pxl_x		; Xvert map_pxl_x to map_chr_x.
  857               0001     		.if	BLKMAP_MULTISCR
  858    01:D749  A8         			tay				; Xvert map_pxl_x to map_scrn_x.
  859    01:D74A  3C AF 24   			bit	vdc_bat_width, x
  860    01:D74D  70 03      			bvs	.w64
  861    01:D74F  10 02      			bpl	.w32
  862    01:D751  4A         	.w128:		lsr	a
  863    01:D752  4A         	.w64:		lsr	a
  864    01:D753  85 FD      	.w32:		sta	<map_scrn_x
  865    01:D755  98         			tya
  866                        		.endif
  867    01:D756  4A         			lsr	a
  868    01:D757  66 FC      			ror.l	<map_pxl_x
  869    01:D759  4A         			lsr	a
  870    01:D75A  66 FC      			ror.l	<map_pxl_x
  871    01:D75C  4A         			lsr	a
  872    01:D75D  66 FC      			ror.l	<map_pxl_x		; Max map width is 256 CHR.
  873                        	
  874    01:D75F  A5 FF      			lda.h	<map_pxl_y		; Xvert map_pxl_y to map_chr_y.
  875               0001     		.if	BLKMAP_MULTISCR
  876    01:D761  A8         			tay				; Xvert map_pxl_y to map_scrn_y.
  877    01:D762  3C B0 24   			bit	vdc_bat_height, x
  878    01:D765  50 01      			bvc	.h32
  879    01:D767  4A         	.h64:		lsr	a
  880    01:D768  85 FF      	.h32:		sta	<map_scrn_y
  881    01:D76A  98         			tya
  882                        		.endif
  883    01:D76B  4A         			lsr	a
  884    01:D76C  66 FE      			ror.l	<map_pxl_y
  885    01:D76E  4A         			lsr	a
  886    01:D76F  66 FE      			ror.l	<map_pxl_y
  887    01:D771  4A         			lsr	a
  888    01:D772  66 FE      			ror.l	<map_pxl_y		; Max map width is 256 CHR.
  889                        	
  890    01:D774  60         			rts
  891                        	
  892                        	
  893                        	
  894                        	; ***************************************************************************
  895                        	; ***************************************************************************
  896                        	;
  897                        	; map_chr_2_data - Page in the MAP address for the CHR coordinates.
  898                        	;
  899                        	
  900    01:D775             	map_chr_2_data:
  901                        	
  902               0001     		.if	BLKMAP_MULTISCR
  903                        	
  904                        			; Initialization for a multi-screen map.
  905                        	
  906    01:D775  BD F8 29   			lda	vdc_scr_bank, x		; Skip this if regular blkmap.
  907    01:D778  F0 3A      			beq	.regular
  908                        	
  909    01:D77A  A5 FC      	.multiscreen:	lda	<map_chr_x		; Compare old_x with cur_x.
  910    01:D77C  3D B1 24   			and	vdc_bat_x_mask, x
  911    01:D77F  85 F8      			sta	<map_bat_x		; Save BAT X chr coordinate.
  912                        	
  913    01:D781  A5 FE      			lda	<map_chr_y		; Save BAT Y chr coordinate.
  914    01:D783  3D B2 24   			and	vdc_bat_y_mask, x
  915    01:D786  85 F9      			sta	<map_bat_y
  916    01:D788  4A         			lsr	a			; Map BLK Y coordinate.
  917    01:D789  85 EF      			sta.h	<map_line
  918    01:D78B  62         			cla
  919    01:D78C  3C AF 24   			bit	vdc_bat_width, x
  920    01:D78F  30 08      			bmi	.w128
  921    01:D791  70 03      			bvs	.w64
  922    01:D793  46 EF      	.w32:		lsr.h	<map_line
  923    01:D795  6A         			ror	a
  924    01:D796  46 EF      	.w64:		lsr.h	<map_line
  925    01:D798  6A         			ror	a
  926    01:D799  46 EF      	.w128:		lsr.h	<map_line
  927    01:D79B  6A         			ror	a
  928    01:D79C  46 EF      			lsr.h	<map_line		; Hi-byte of (BLK Y * width).
  929    01:D79E  6A         			ror	a
  930    01:D79F  85 EE      			sta.l	<map_line		; Lo-byte of (BLK Y * width).
  931                        	
  932    01:D7A1  20 F5 D7   			jsr	map_set_screen		; Put BLK & MAP in MPR2-MPR5.
  933                        	
  934    01:D7A4  A5 F8      			lda	<map_bat_x		; Calc map data pointer.
  935    01:D7A6  4A         			lsr	a			; Map BLK X coordinate.
  936    01:D7A7  05 EE      			ora.l	<map_line
  937    01:D7A9  85 EC      			sta.l	<_bp
  938    01:D7AB  A5 EF      			lda.h	<map_line
  939    01:D7AD  18         			clc
  940    01:D7AE  7D F4 29   			adc.h	vdc_map_addr, x		; N.B. 256-byte aligned!
  941    01:D7B1  85 ED      			sta.h	<_bp
  942                        	
  943    01:D7B3  60         			rts
  944                        	
  945                        		.endif	BLKMAP_MULTISCR
  946                        	
  947                        			; Initialization for a regular map.
  948                        	
  949    01:D7B4  A5 FC      	.regular:	lda	<map_chr_x		; Compare old_x with cur_x.
  950                        	;		bit	vdc_map_option, x	; Set bit7 to disable aligning
  951                        	;		bmi	!+			; BAT X with the map X.
  952    01:D7B6  3D B1 24   			and	vdc_bat_x_mask, x
  953    01:D7B9  85 F8      			sta	<map_bat_x		; Save BAT X chr coordinate.
  954                        	
  955    01:D7BB  A5 FE      	!:		lda	<map_chr_y		; A = map CHR Y coordinate.
  956    01:D7BD  A8         			tay
  957    01:D7BE  4A         			lsr	a
  958    01:D7BF  42         			say				; Y = map BLK Y coordinate.
  959                        	
  960                        	;		bit	vdc_map_option, x	; Set bit6 to disable aligning
  961                        	;		bvs	!+			; BAT Y with the map Y.
  962    01:D7C0  3D B2 24   			and	vdc_bat_y_mask, x
  963    01:D7C3  85 F9      			sta	<map_bat_y		; Save BAT Y chr coordinate.
  964                        	
  965               0000     		.if	BLKMAP_LARGEMAP
  970                        		.endif
  971                        	
  972    01:D7C5  BD B6 24   	!:		lda	vdc_map_line_w, x	; Map width in BLK.
  973               0000     		.if	FAST_MULTIPLY
  986                        		.else
  987    01:D7C8  84 EF      			sty.h	<map_line		; Takes 144..176 cycles.
  988    01:D7CA  A0 08      			ldy	#8
  989    01:D7CC  4A         			lsr	a
  990    01:D7CD  85 EE      			sta.l	<map_line
  991    01:D7CF  62         			cla
  992    01:D7D0  90 03      			bcc	.rotate
  993    01:D7D2  18         	.add:		clc
  994    01:D7D3  65 EF      			adc.h	<map_line
  995    01:D7D5  6A         	.rotate:	ror	a
  996    01:D7D6  66 EE      			ror.l	<map_line		; Lo-byte of (BLK Y * width).
  997    01:D7D8  88         			dey
  998    01:D7D9  B0 F7      			bcs	.add
  999    01:D7DB  D0 F8      			bne	.rotate
 1000    01:D7DD  A8         			tay				; Hi-byte of (BLK Y * width).
 1001                        		.endif
 1002                        	
 1003    01:D7DE  A5 FC      	!:		lda	<map_chr_x		; Map CHR X coordinate.
 1004    01:D7E0  4A         			lsr	a			; Map BLK X coordinate.
 1005    01:D7E1  18         			clc
 1006    01:D7E2  65 EE      			adc.l	<map_line		; Lo-byte of (BLK Y * width).
 1007    01:D7E4  90 01      			bcc	!+
 1008    01:D7E6  C8         			iny				; Hi-byte of (BLK Y * width).
 1009                        	
 1010    01:D7E7  18         	!:		clc				; Calc map data pointer.
 1011    01:D7E8  7D F3 29   			adc.l	vdc_map_addr, x
 1012    01:D7EB  85 EC      			sta.l	<_bp			; Maximum map size is 16KBytes
 1013    01:D7ED  98         			tya				; so we don't need to consider
 1014    01:D7EE  7D F4 29   			adc.h	vdc_map_addr, x		; bank overflow.
 1015    01:D7F1  85 ED      			sta.h	<_bp
 1016                        	
 1017    01:D7F3  80 66      			bra	map_set_banks		; Put BLK & MAP in MPR2-MPR5.
 1018                        	
 1019                        	
 1020                        	
 1021               0001     		.if	BLKMAP_MULTISCR
 1022                        	
 1023                        	; ***************************************************************************
 1024                        	; ***************************************************************************
 1025                        	;
 1026                        	; map_set_screen -
 1027                        	;
 1028                        	; Maximum X and Y dimension of 128 screens (32768 pixels).
 1029                        	; Maximum 8KByte total size of screen data (1024 screens).
 1030                        	;
 1031                        	
 1032    01:D7F5  A4 FF      	map_set_screen:	ldy	<map_scrn_y		; Map SCR Y coordinate.
 1033    01:D7F7  BD B7 24   			lda	vdc_map_scrn_w, x	; Map width in SCREENS.
 1034                        	
 1035               0000     		.if	FAST_MULTIPLY
 1048                        		.else
 1049    01:D7FA  84 ED      			sty.h	<_bp			; Takes 144..176 cycles.
 1050    01:D7FC  A0 08      			ldy	#8
 1051    01:D7FE  4A         			lsr	a
 1052    01:D7FF  85 EC      			sta.l	<_bp
 1053    01:D801  62         			cla
 1054    01:D802  90 03      			bcc	.rotate
 1055    01:D804  18         	.add:		clc
 1056    01:D805  65 ED      			adc.h	<_bp
 1057    01:D807  6A         	.rotate:	ror	a
 1058    01:D808  66 EC      			ror.l	<_bp			; Lo-byte of (SCR Y * width).
 1059    01:D80A  88         			dey
 1060    01:D80B  B0 F7      			bcs	.add
 1061    01:D80D  D0 F8      			bne	.rotate
 1062    01:D80F  A8         			tay				; Hi-byte of (SCR Y * width).
 1063                        		.endif
 1064                        	
 1065    01:D810  A5 FD      			lda	<map_scrn_x		; Map SCR X coordinate.
 1066    01:D812  18         			clc
 1067    01:D813  65 EC      			adc.l	<_bp
 1068    01:D815  90 01      			bcc	!+
 1069    01:D817  C8         			iny
 1070                        	
 1071    01:D818  84 ED      	!:		sty.h	<_bp			; 2 bytes per screen entry, max
 1072    01:D81A  0A         			asl	a			; 8KByte screen table.
 1073    01:D81B  26 ED      			rol.h	<_bp
 1074               0001     		.if	BLKDEF_POINTERS == 0
 1075    01:D81D  0A         			asl	a			; 8 bytes per screen entry when
 1076    01:D81E  26 ED      			rol.h	<_bp			; not using BLK pointers.
 1077    01:D820  0A         			asl	a
 1078    01:D821  26 ED      			rol.h	<_bp
 1079                        		.endif
 1080                        	
 1081    01:D823  7D F6 29   			adc.l	vdc_scr_addr, x		; Calc screen data pointer.
 1082    01:D826  85 EC      			sta.l	<_bp			; Maximum data size is 8KBytes
 1083    01:D828  A5 ED      			lda.h	<_bp			; so we don't need to consider
 1084    01:D82A  7D F7 29   			adc.h	vdc_scr_addr, x		; bank overflow.
 1085    01:D82D  85 ED      			sta.h	<_bp
 1086                        	
 1087    01:D82F  BD F8 29   			lda	vdc_scr_bank, x		; Map the SCR data in MPR3..MPR4.
 1088    01:D832  53 08      			tam3
 1089    01:D834  1A         			inc	a
 1090    01:D835  53 10      			tam4
 1091                        	
 1092    01:D837  C2         			cly
 1093    01:D838  B1 EC      			lda	[_bp], y		; Get SCR_MAP_PAGE.
 1094    01:D83A  9D F4 29   			sta.h	vdc_map_addr, x
 1095    01:D83D  C8         			iny
 1096    01:D83E  B1 EC      			lda	[_bp], y		; Get SCR_MAP_BANK.
 1097    01:D840  9D F5 29   			sta	vdc_map_bank, x
 1098                        	
 1099               0001     		.if	BLKDEF_POINTERS == 0
 1100    01:D843  C8         			iny
 1101    01:D844  B1 EC      			lda	[_bp], y		; Get SCR_BLK_PAGE.
 1102    01:D846  9D F1 29   			sta.h	vdc_blk_addr, x
 1103    01:D849  C8         			iny
 1104    01:D84A  B1 EC      			lda	[_bp], y		; Get SCR_BLK_BANK.
 1105    01:D84C  9D F2 29   			sta	vdc_blk_bank, x
 1106    01:D84F  C8         			iny
 1107    01:D850  B1 EC      			lda	[_bp], y		; Get SCR_TBL_PAGE.
 1108    01:D852  9D EE 29   			sta.h	vdc_tbl_addr, x
 1109    01:D855  C8         			iny
 1110    01:D856  B1 EC      			lda	[_bp], y		; Get SCR_TBL_BANK.
 1111    01:D858  9D EF 29   			sta	vdc_tbl_bank, x
 1112               0000     		.if	0				; These are not currently used.
 1119                        		.endif
 1120                        		.endif
 1121                        	
 1122                        	;		lda	vdc_bat_width, x	; Set up the map width.
 1123                        	;		lsr	a			; This should have been set
 1124                        	;		sta	vdc_map_line_w, x	; with the multi-screen map.
 1125                        	
 1126                        	;		jmp	map_set_banks		; Put BLK & MAP in MPR2-MPR5.
 1127                        	
 1128                        			; Fall through to map_set_banks.
 1129                        	
 1130                        		.endif	BLKMAP_MULTISCR
 1131                        	
 1132                        	
 1133                        	
 1134                        	; ***************************************************************************
 1135                        	; ***************************************************************************
 1136                        	;
 1137                        	; map_set_banks - Put BLK & MAP in MPR2-MPR5.
 1138                        	;
 1139                        	
 1140    01:D85B  BD F2 29   	map_set_banks:	lda	vdc_blk_bank, x		; Put the BLK into MPR2.
 1141    01:D85E  53 04      			tam2
 1142                        	
 1143    01:D860  BD F5 29   			lda	vdc_map_bank, x		; Put the MAP into MPR3-MPR5.
 1144    01:D863  53 08      			tam3
 1145    01:D865  1A         			inc	a
 1146    01:D866  53 10      			tam4
 1147               0000     		.if	BLKMAP_LARGEMAP
 1156                        		.endif
 1157                        	
 1158    01:D868  60         	!:		rts
 1159                        	
 1160                        	
 1161                        	
 1162                        	; ***************************************************************************
 1163                        	; ***************************************************************************
 1164                        	;
 1165                        	; map_scroll_x - Update the BAT when X coordinate changes.
 1166                        	;
 1167                        	; N.B. This will alter map_chr_x and map_scrn_x if moved in +ve direction!
 1168                        	;
 1169                        	; N.B. This only ever draws a single column!
 1170                        	;
 1171                        	
 1172    01:D869  60         	!no_change:	rts
 1173                        	
 1174    01:D86A             	map_scroll_x:
 1175                        	
 1176               0001     		.if	BLKMAP_MULTISCR
 1177                        	
 1178                        			; Initialization for a multi-screen map.
 1179                        	
 1180    01:D86A  BD F8 29   			lda	vdc_scr_bank, x		; Skip this if regular blkmap.
 1181    01:D86D  F0 56      			beq	.regular
 1182                        	
 1183    01:D86F  A5 FC      	.multiscreen:	lda	<map_chr_x		; Compare old_x with cur_x.
 1184    01:D871  DD EB 29   			cmp	vdc_old_chr_x, x
 1185               0001     		.if	BLKMAP_TIMETEST == 0
 1186    01:D874  F0 F3      			beq	!no_change-		; Do nothing if no change.
 1187                        		.endif
 1188    01:D876  9D EB 29   			sta	vdc_old_chr_x, x
 1189    01:D879  30 11      			bmi	!+			; Test the sign of the change.
 1190                        	
 1191    01:D87B  18         			clc				; Draw RHS if chr_x >= old_x.
 1192    01:D87C  3D B1 24   			and	vdc_bat_x_mask, x
 1193    01:D87F  7D B4 24   			adc	vdc_map_draw_w, x	; Usually (SCR_WIDTH / 8) + 1.
 1194    01:D882  3A         			dec	a
 1195    01:D883  85 FC      			sta	<map_chr_x		; Update CHR X chr coordinate.
 1196    01:D885  3C AF 24   			bit	vdc_bat_width, x
 1197    01:D888  F0 02      			beq	!+
 1198    01:D88A  E6 FD      			inc	<map_scrn_x		; Wrapped to the next screen.
 1199                        	
 1200    01:D88C  3D B1 24   	!:		and	vdc_bat_x_mask, x
 1201    01:D88F  85 F8      			sta	<map_bat_x		; Save BAT X chr coordinate.
 1202                        	
 1203    01:D891  A5 FE      			lda	<map_chr_y		; Save BAT Y chr coordinate.
 1204    01:D893  3D B2 24   			and	vdc_bat_y_mask, x
 1205    01:D896  85 F9      			sta	<map_bat_y
 1206    01:D898  4A         			lsr	a			; Map BLK Y coordinate.
 1207    01:D899  85 EF      			sta.h	<map_line
 1208    01:D89B  62         			cla
 1209    01:D89C  3C AF 24   			bit	vdc_bat_width, x
 1210    01:D89F  30 08      			bmi	.w128
 1211    01:D8A1  70 03      			bvs	.w64
 1212    01:D8A3  46 EF      	.w32:		lsr.h	<map_line
 1213    01:D8A5  6A         			ror	a
 1214    01:D8A6  46 EF      	.w64:		lsr.h	<map_line
 1215    01:D8A8  6A         			ror	a
 1216    01:D8A9  46 EF      	.w128:		lsr.h	<map_line
 1217    01:D8AB  6A         			ror	a
 1218    01:D8AC  46 EF      			lsr.h	<map_line		; Hi-byte of (BLK Y * width).
 1219    01:D8AE  6A         			ror	a
 1220    01:D8AF  85 EE      			sta.l	<map_line		; Lo-byte of (BLK Y * width).
 1221                        	
 1222    01:D8B1  20 F5 D7   			jsr	map_set_screen		; Put BLK & MAP in MPR2-MPR5.
 1223                        	
 1224    01:D8B4  A5 F8      			lda	<map_bat_x		; Calc map data pointer.
 1225    01:D8B6  4A         			lsr	a			; Map BLK X coordinate.
 1226    01:D8B7  05 EE      			ora.l	<map_line
 1227    01:D8B9  85 EC      			sta.l	<_bp
 1228    01:D8BB  A5 EF      			lda.h	<map_line
 1229    01:D8BD  18         			clc
 1230    01:D8BE  7D F4 29   			adc.h	vdc_map_addr, x		; N.B. 256-byte aligned!
 1231    01:D8C1  85 ED      			sta.h	<_bp
 1232                        	
 1233    01:D8C3  80 5D      			bra	.draw_col		; Now draw it.
 1234                        	
 1235                        		.endif	BLKMAP_MULTISCR
 1236                        	
 1237                        			; Initialization for a regular map.
 1238                        	
 1239    01:D8C5  A5 FC      	.regular:	lda	<map_chr_x		; Compare old_x with cur_x.
 1240    01:D8C7  DD EB 29   			cmp	vdc_old_chr_x, x
 1241               0001     		.if	BLKMAP_TIMETEST == 0
 1242    01:D8CA  F0 9D      			beq	!no_change-		; Do nothing if no change.
 1243                        		.endif
 1244    01:D8CC  9D EB 29   			sta	vdc_old_chr_x, x
 1245    01:D8CF  30 07      			bmi	!+			; Test the sign of the change.
 1246                        	
 1247    01:D8D1  18         			clc				; Draw RHS if chr_x >= old_x.
 1248    01:D8D2  7D B4 24   			adc	vdc_map_draw_w, x	; Usually (SCR_WIDTH / 8) + 1.
 1249    01:D8D5  3A         			dec	a
 1250    01:D8D6  85 FC      			sta	<map_chr_x		; Update CHR X chr coordinate.
 1251                        	
 1252    01:D8D8  3C BC 24   	!:		bit	vdc_map_option, x	; Set bit7 to disable aligning
 1253    01:D8DB  30 05      			bmi	!+			; BAT X with the map X.
 1254    01:D8DD  3D B1 24   			and	vdc_bat_x_mask, x
 1255    01:D8E0  85 F8      			sta	<map_bat_x		; Save BAT X chr coordinate.
 1256                        	
 1257    01:D8E2  A5 FE      	!:		lda	<map_chr_y		; A = map CHR Y coordinate.
 1258    01:D8E4  A8         			tay
 1259    01:D8E5  4A         			lsr	a
 1260    01:D8E6  42         			say				; Y = map BLK Y coordinate.
 1261                        	
 1262    01:D8E7  3C BC 24   			bit	vdc_map_option, x	; Set bit6 to disable aligning
 1263    01:D8EA  70 05      			bvs	!+			; BAT Y with the map Y.
 1264    01:D8EC  3D B2 24   			and	vdc_bat_y_mask, x
 1265    01:D8EF  85 F9      			sta	<map_bat_y		; Save BAT Y chr coordinate.
 1266                        	
 1267               0000     		.if	BLKMAP_LARGEMAP
 1272                        		.endif
 1273                        	
 1274    01:D8F1  BD B6 24   	!:		lda	vdc_map_line_w, x	; Map width in BLK.
 1275               0000     		.if	FAST_MULTIPLY
 1288                        		.else
 1289    01:D8F4  84 EF      			sty.h	<map_line		; Takes 144..176 cycles.
 1290    01:D8F6  A0 08      			ldy	#8
 1291    01:D8F8  4A         			lsr	a
 1292    01:D8F9  85 EE      			sta.l	<map_line
 1293    01:D8FB  62         			cla
 1294    01:D8FC  90 03      			bcc	.rotate
 1295    01:D8FE  18         	.add:		clc
 1296    01:D8FF  65 EF      			adc.h	<map_line
 1297    01:D901  6A         	.rotate:	ror	a
 1298    01:D902  66 EE      			ror.l	<map_line		; Lo-byte of (BLK Y * width).
 1299    01:D904  88         			dey
 1300    01:D905  B0 F7      			bcs	.add
 1301    01:D907  D0 F8      			bne	.rotate
 1302    01:D909  A8         			tay				; Hi-byte of (BLK Y * width).
 1303                        		.endif
 1304                        	
 1305    01:D90A  A5 FC      	!:		lda	<map_chr_x		; Map CHR X coordinate.
 1306    01:D90C  4A         			lsr	a			; Map BLK X coordinate.
 1307    01:D90D  18         			clc
 1308    01:D90E  65 EE      			adc.l	<map_line		; Lo-byte of (BLK Y * width).
 1309    01:D910  90 01      			bcc	!+
 1310    01:D912  C8         			iny				; Hi-byte of (BLK Y * width).
 1311                        	
 1312    01:D913  18         	!:		clc				; Calc map data pointer.
 1313    01:D914  7D F3 29   			adc.l	vdc_map_addr, x
 1314    01:D917  85 EC      			sta.l	<_bp			; Maximum map size is 16KBytes
 1315    01:D919  98         			tya				; so we don't need to consider
 1316    01:D91A  7D F4 29   			adc.h	vdc_map_addr, x		; bank overflow.
 1317    01:D91D  85 ED      			sta.h	<_bp
 1318                        	
 1319    01:D91F  20 5B D8   			jsr	map_set_banks		; Put BLK & MAP in MPR2-MPR5.
 1320                        	
 1321                        			; Draw the first part of the column.
 1322                        	
 1323    01:D922  A5 F8      	.draw_col:	lda	<map_bat_x		; Set the BAT VRAM destination
 1324    01:D924  85 F0      			sta.l	<_di			; coordinates.
 1325    01:D926  A5 F9      			lda	<map_bat_y
 1326    01:D928  85 F1      			sta.h	<_di
 1327                        	
 1328    01:D92A  5D B2 24   			eor	vdc_bat_y_mask, x	; Calc CHR before wrap.
 1329    01:D92D  1A         			inc	a
 1330    01:D92E  DD B5 24   			cmp	vdc_map_draw_h, x	; Usually (SCR_HEIGHT / 8) + 1.
 1331    01:D931  90 03      			bcc	!+
 1332    01:D933  BD B5 24   			lda	vdc_map_draw_h, x	; Maximum CHR to draw.
 1333    01:D936  85 00      	!:		sta	<map_count		; Set number of CHR to draw.
 1334    01:D938  85 01      			sta	<map_drawn		; Preserve number of CHR drawn.
 1335                        	
 1336    01:D93A  A9 05      			lda	#VDC_CR			; Set VDC auto-increment from
 1337    01:D93C  95 F7      			sta	<vdc_reg, x		; the BAT width, which is set
 1338    01:D93E  9D 00 02   			sta	VDC_AR, x		; up by set_screen_size().
 1339    01:D941  B5 F4      			lda	<vdc_crh, x
 1340    01:D943  9D 03 02   			sta	VDC_DH, x
 1341                        	
 1342    01:D946  20 88 DC   			jsr	blk_col_strip		; Draw top of vertical strip.
 1343                        	
 1344                        			; Wrap around and draw the rest of the column (if needed).
 1345                        	
 1346    01:D949  38         			sec				; Are there any more CHR that
 1347    01:D94A  BD B5 24   			lda	vdc_map_draw_h, x	; need to be drawn?
 1348    01:D94D  E5 01      			sbc	<map_drawn
 1349    01:D94F  F0 2C      			beq	.done
 1350                        	
 1351    01:D951  85 00      			sta	<map_count		; Set number of CHR to draw.
 1352                        	
 1353    01:D953  A5 FE      			lda	<map_chr_y		; Update CHR Y coordinate for
 1354    01:D955  48         			pha				; drawing unaligned tiles.
 1355    01:D956  18         			clc
 1356    01:D957  65 01      			adc	<map_drawn
 1357    01:D959  85 FE      			sta	<map_chr_y
 1358                        	
 1359               0001     		.if	BLKMAP_MULTISCR
 1360    01:D95B  BD F8 29   			lda	vdc_scr_bank, x		; Skip this if regular blkmap.
 1361    01:D95E  F0 0F      			beq	!+
 1362                        	
 1363    01:D960  E6 FF      			inc	<map_scrn_y		; Wrapped to the next screen.
 1364                        	
 1365    01:D962  20 F5 D7   			jsr	map_set_screen		; Put BLK & MAP in MPR2-MPR5.
 1366                        	
 1367    01:D965  A5 F8      			lda	<map_bat_x		; Calc map data pointer.
 1368    01:D967  4A         			lsr	a			; Map BLK X coordinate.
 1369    01:D968  85 EC      			sta.l	<_bp
 1370    01:D96A  BD F4 29   			lda.h	vdc_map_addr, x		; N.B. 256-byte aligned!
 1371    01:D96D  85 ED      			sta.h	<_bp
 1372                        		.endif
 1373                        	
 1374    01:D96F  A5 F8      	!:		lda	<map_bat_x		; Set the BAT VRAM destination
 1375    01:D971  85 F0      			sta.l	<_di			; coordinates.
 1376    01:D973  64 F1      			stz.h	<_di			; Reset 1st row to draw.
 1377                        	
 1378    01:D975  20 88 DC   			jsr	blk_col_strip		; Draw btm of vertical strip.
 1379                        	
 1380               0001     		.if	BLKMAP_MULTISCR
 1381    01:D978  C6 FF      			dec	<map_scrn_y		; Restore, no check if should.
 1382                        		.endif
 1383                        	
 1384    01:D97A  68         			pla				; Restore CHR Y coordinate, we
 1385    01:D97B  85 FE      			sta	<map_chr_y		; might draw another column!
 1386                        	
 1387    01:D97D  A9 05      	.done:		lda	#VDC_CR			; Set VDC auto-increment to 1.
 1388    01:D97F  95 F7      			sta	<vdc_reg, x
 1389    01:D981  9D 00 02   			sta	VDC_AR, x
 1390    01:D984  9E 03 02   			stz	VDC_DH, x
 1391                        	
 1392    01:D987  60         			rts
 1393                        	
 1394                        	
 1395                        	
 1396                        	; ***************************************************************************
 1397                        	; ***************************************************************************
 1398                        	;
 1399                        	; map_scroll_y - Update the BAT when Y coordinate changes.
 1400                        	;
 1401                        	; N.B. This will alter map_chr_y and map_scrn_y if moved in +ve direction!
 1402                        	;
 1403                        	; N.B. This draws multiple rows when called from _draw_map or _blit_map.
 1404                        	;
 1405                        	
 1406    01:D988  60         	!no_change:	rts
 1407                        	
 1408    01:D989             	map_scroll_y:
 1409                        	
 1410               0001     		.if	BLKMAP_MULTISCR
 1411                        	
 1412                        			; Initialization for a multi-screen map.
 1413                        	
 1414    01:D989  BD F8 29   			lda	vdc_scr_bank, x		; Skip this if regular blkmap.
 1415    01:D98C  F0 56      			beq	.regular
 1416                        	
 1417    01:D98E  A5 FE      	.multiscr:	lda	<map_chr_y		; Compare old_y with cur_y.
 1418    01:D990  DD EC 29   			cmp	vdc_old_chr_y, x
 1419               0001     		.if	BLKMAP_TIMETEST == 0
 1420    01:D993  F0 F3      			beq	!no_change-		; Do nothing if no change.
 1421                        		.endif
 1422    01:D995  9D EC 29   			sta	vdc_old_chr_y, x
 1423    01:D998  30 11      			bmi	!+			; Test the sign of the change.
 1424                        	
 1425    01:D99A  18         			clc				; Draw bottom if chr_y >= old_y.
 1426    01:D99B  3D B2 24   			and	vdc_bat_y_mask, x
 1427    01:D99E  7D B5 24   			adc	vdc_map_draw_h, x	; Usually (SCR_HEIGHT / 8) + 1.
 1428    01:D9A1  3A         			dec	a
 1429    01:D9A2  85 FE      			sta	<map_chr_y		; Update CHR Y chr coordinate.
 1430    01:D9A4  3C B0 24   			bit	vdc_bat_height, x
 1431    01:D9A7  F0 02      			beq	!+
 1432    01:D9A9  E6 FF      			inc	<map_scrn_y		; Wrapped to the next screen.
 1433                        	
 1434    01:D9AB  3D B2 24   	!:		and	vdc_bat_y_mask, x
 1435    01:D9AE  85 F9      			sta	<map_bat_y		; Save BAT Y chr coordinate.
 1436                        	
 1437    01:D9B0  4A         			lsr	a			; Map BLK Y coordinate.
 1438    01:D9B1  85 EF      			sta.h	<map_line
 1439    01:D9B3  62         			cla
 1440    01:D9B4  3C AF 24   			bit	vdc_bat_width, x
 1441    01:D9B7  30 08      			bmi	.w128
 1442    01:D9B9  70 03      			bvs	.w64
 1443    01:D9BB  46 EF      	.w32:		lsr.h	<map_line
 1444    01:D9BD  6A         			ror	a
 1445    01:D9BE  46 EF      	.w64:		lsr.h	<map_line
 1446    01:D9C0  6A         			ror	a
 1447    01:D9C1  46 EF      	.w128:		lsr.h	<map_line
 1448    01:D9C3  6A         			ror	a
 1449    01:D9C4  46 EF      			lsr.h	<map_line		; Hi-byte of (BLK Y * width).
 1450    01:D9C6  6A         			ror	a
 1451    01:D9C7  85 EE      			sta.l	<map_line		; Lo-byte of (BLK Y * width).
 1452                        	
 1453    01:D9C9  A5 FC      			lda	<map_chr_x
 1454    01:D9CB  3D B1 24   			and	vdc_bat_x_mask, x
 1455    01:D9CE  85 F8      			sta	<map_bat_x		; Save BAT X chr coordinate.
 1456                        	
 1457                        			; Loop to here if drawing multiple multi-screen rows.
 1458                        	
 1459    01:D9D0  20 F5 D7   	.multiscr_row:	jsr	map_set_screen		; Put BLK & MAP in MPR2-MPR5.
 1460                        	
 1461    01:D9D3  A5 F8      			lda	<map_bat_x		; Calc map data pointer.
 1462    01:D9D5  4A         			lsr	a			; Map BLK X coordinate.
 1463    01:D9D6  05 EE      			ora.l	<map_line
 1464    01:D9D8  85 EC      			sta.l	<_bp
 1465    01:D9DA  A5 EF      			lda.h	<map_line
 1466    01:D9DC  18         			clc
 1467    01:D9DD  7D F4 29   			adc.h	vdc_map_addr, x		; N.B. 256-byte aligned!
 1468    01:D9E0  85 ED      			sta.h	<_bp
 1469                        	
 1470    01:D9E2  80 60      			bra	.draw_row		; Now draw it.
 1471                        	
 1472                        		.endif	BLKMAP_MULTISCR
 1473                        	
 1474                        			; Initialization for a regular blkmap.
 1475                        	
 1476    01:D9E4  A5 FE      	.regular:	lda	<map_chr_y		; Compare old_y with cur_y.
 1477    01:D9E6  DD EC 29   			cmp	vdc_old_chr_y, x
 1478               0001     		.if	BLKMAP_TIMETEST == 0
 1479    01:D9E9  F0 9D      			beq	!no_change-		; Do nothing if no change.
 1480                        		.endif
 1481    01:D9EB  9D EC 29   			sta	vdc_old_chr_y, x
 1482    01:D9EE  30 07      			bmi	!+			; Test the sign of the change.
 1483                        	
 1484    01:D9F0  18         			clc				; Draw bottom if chr_y >= old_y.
 1485    01:D9F1  7D B5 24   			adc	vdc_map_draw_h, x	; Usually (SCR_HEIGHT / 8) + 1.
 1486    01:D9F4  3A         			dec	a
 1487    01:D9F5  85 FE      			sta	<map_chr_y		; Update CHR Y chr coordinate.
 1488                        	
 1489    01:D9F7  A8         	!:		tay				; A = map CHR Y coordinate.
 1490    01:D9F8  4A         			lsr	a
 1491    01:D9F9  42         			say				; Y = map BLK Y coordinate.
 1492                        	
 1493    01:D9FA  3C BC 24   			bit	vdc_map_option, x	; Set bit6 to disable aligning
 1494    01:D9FD  70 05      			bvs	!+			; BAT Y with the map Y.
 1495    01:D9FF  3D B2 24   			and	vdc_bat_y_mask, x
 1496    01:DA02  85 F9      			sta	<map_bat_y		; Save BAT Y chr coordinate.
 1497                        	
 1498    01:DA04  3C BC 24   	!:		bit	vdc_map_option, x	; Set bit7 to disable aligning
 1499    01:DA07  30 07      			bmi	!+			; BAT X with the map X.
 1500    01:DA09  A5 FC      			lda	<map_chr_x
 1501    01:DA0B  3D B1 24   			and	vdc_bat_x_mask, x
 1502    01:DA0E  85 F8      			sta	<map_bat_x		; Save BAT X chr coordinate.
 1503    01:DA10             	!:
 1504                        	
 1505               0000     		.if	BLKMAP_LARGEMAP
 1510                        		.endif
 1511                        	
 1512    01:DA10  BD B6 24   			lda	vdc_map_line_w, x	; Map width in BLK.
 1513               0000     		.if	FAST_MULTIPLY
 1526                        		.else
 1527    01:DA13  84 EF      			sty.h	<map_line		; Takes 144..176 cycles.
 1528    01:DA15  A0 08      			ldy	#8
 1529    01:DA17  4A         			lsr	a
 1530    01:DA18  85 EE      			sta.l	<map_line
 1531    01:DA1A  62         			cla
 1532    01:DA1B  90 03      			bcc	.rotate
 1533    01:DA1D  18         	.add:		clc
 1534    01:DA1E  65 EF      			adc.h	<map_line
 1535    01:DA20  6A         	.rotate:	ror	a
 1536    01:DA21  66 EE      			ror.l	<map_line		; Lo-byte of (BLK Y * width).
 1537    01:DA23  88         			dey
 1538    01:DA24  B0 F7      			bcs	.add
 1539    01:DA26  D0 F8      			bne	.rotate
 1540    01:DA28  85 EF      			sta.h	<map_line		; Hi-byte of (BLK Y * width).
 1541                        		.endif
 1542                        	
 1543    01:DA2A  20 5B D8   			jsr	map_set_banks		; Put BLK & MAP in MPR2-MPR5.
 1544                        	
 1545                        			; Loop to here if drawing multiple regular blkmap rows.
 1546                        	
 1547    01:DA2D  A4 EF      	.regular_row:	ldy.h	<map_line		; Hi-byte of (BLK Y * width).
 1548    01:DA2F  A5 FC      			lda	<map_chr_x		; Map CHR X coordinate.
 1549    01:DA31  4A         			lsr	a			; Map BLK X coordinate.
 1550    01:DA32  18         			clc
 1551    01:DA33  65 EE      			adc.l	<map_line		; Lo-byte of (BLK Y * width).
 1552    01:DA35  90 01      			bcc	!+
 1553    01:DA37  C8         			iny
 1554    01:DA38  18         	!:		clc				; Calc map data pointer.
 1555    01:DA39  7D F3 29   			adc.l	vdc_map_addr, x
 1556    01:DA3C  85 EC      			sta.l	<_bp			; Maximum map size is 16KBytes
 1557    01:DA3E  98         			tya				; so we don't need to consider
 1558    01:DA3F  7D F4 29   			adc.h	vdc_map_addr, x		; bank overflow.
 1559    01:DA42  85 ED      			sta.h	<_bp
 1560                        	
 1561                        			; Draw the first part of the row.
 1562                        	
 1563    01:DA44  A5 F9      	.draw_row:	lda	<map_bat_y		; Set the BAT VRAM destination
 1564    01:DA46  85 F1      			sta.h	<_di			; coordinates.
 1565    01:DA48  A5 F8      			lda	<map_bat_x
 1566    01:DA4A  85 F0      			sta.l	<_di
 1567                        	
 1568    01:DA4C  5D B1 24   			eor	vdc_bat_x_mask, x	; Calc CHR before wrap.
 1569    01:DA4F  1A         			inc	a
 1570    01:DA50  C5 FA      			cmp	<map_draw_w		; Usually (SCR_WIDTH / 8) + 1.
 1571    01:DA52  90 02      			bcc	!+
 1572    01:DA54  A5 FA      			lda	<map_draw_w		; Maximum CHR to draw.
 1573    01:DA56  85 00      	!:		sta	<map_count		; Set number of CHR to draw.
 1574    01:DA58  85 01      			sta	<map_drawn		; Preserve number of CHR drawn.
 1575                        	
 1576    01:DA5A  20 CA DA   			jsr	blk_row_strip		; Draw lhs of horizontal strip.
 1577                        	
 1578                        			; Wrap around and draw the rest of the row (if needed).
 1579                        	
 1580    01:DA5D  38         			sec				; Are there any more CHR that
 1581    01:DA5E  A5 FA      			lda	<map_draw_w		; need to be drawn?
 1582    01:DA60  E5 01      			sbc	<map_drawn
 1583    01:DA62  F0 2E      			beq	.done_row
 1584                        	
 1585    01:DA64  85 00      			sta	<map_count		; Set number of CHR to draw.
 1586                        	
 1587    01:DA66  A5 FC      			lda	<map_chr_x		; Update CHR X coordinate for
 1588    01:DA68  48         			pha				; drawing unaligned tiles.
 1589    01:DA69  18         			clc
 1590    01:DA6A  65 01      			adc	<map_drawn
 1591    01:DA6C  85 FC      			sta	<map_chr_x
 1592                        	
 1593               0001     		.if	BLKMAP_MULTISCR
 1594    01:DA6E  BD F8 29   			lda	vdc_scr_bank, x		; Skip this if regular blkmap.
 1595    01:DA71  F0 11      			beq	!+
 1596                        	
 1597    01:DA73  E6 FD      			inc	<map_scrn_x		; Wrapped to the next screen.
 1598                        	
 1599    01:DA75  20 F5 D7   			jsr	map_set_screen		; Locate screen's BLK and MAP.
 1600                        	
 1601    01:DA78  18         			clc				; Calc map data pointer.
 1602    01:DA79  A5 EE      			lda.l	<map_line
 1603    01:DA7B  85 EC      			sta.l	<_bp
 1604    01:DA7D  A5 EF      			lda.h	<map_line
 1605    01:DA7F  7D F4 29   			adc.h	vdc_map_addr, x		; N.B. 256-byte aligned!
 1606    01:DA82  85 ED      			sta.h	<_bp
 1607                        		.endif
 1608                        	
 1609    01:DA84  A5 F9      	!:		lda	<map_bat_y		; Set the BAT VRAM destination
 1610    01:DA86  85 F1      			sta.h	<_di			; coordinates.
 1611    01:DA88  64 F0      			stz.l	<_di			; Reset 1st column to draw.
 1612                        	
 1613    01:DA8A  20 CA DA   			jsr	blk_row_strip		; Draw rhs of horizontal strip.
 1614                        	
 1615               0001     		.if	BLKMAP_MULTISCR
 1616    01:DA8D  C6 FD      			dec	<map_scrn_x		; Restore, no check if should.
 1617                        		.endif	BLKMAP_MULTISCR
 1618                        	
 1619    01:DA8F  68         			pla				; Restore CHR X coordinate, we
 1620    01:DA90  85 FC      			sta	<map_chr_x		; might draw another row!
 1621                        	
 1622    01:DA92  C6 FB      	.done_row:	dec	<map_draw_h		; Are all desired rows drawn?
 1623    01:DA94  F0 33      			beq	.finished
 1624                        	
 1625    01:DA96  E6 FE      			inc	<map_chr_y		; Move CHR Y down by 1.
 1626                        	
 1627    01:DA98  A5 FE      			lda	<map_chr_y		; If new BLK then ...
 1628    01:DA9A  4A         			lsr	a
 1629    01:DA9B  B0 0B      			bcs	!+
 1630    01:DA9D  BD B6 24   			lda	vdc_map_line_w, x	; Move the map line pointer to
 1631    01:DAA0  65 EE      			adc.l	<map_line		; the next line.
 1632    01:DAA2  85 EE      			sta.l	<map_line
 1633    01:DAA4  90 02      			bcc	!+
 1634    01:DAA6  E6 EF      			inc.h	<map_line
 1635                        	
 1636    01:DAA8  A5 F9      	!:		lda	<map_bat_y		; Move BAT Y down by 1.
 1637    01:DAAA  1A         			inc	a
 1638    01:DAAB  3D B2 24   			and	vdc_bat_y_mask, x
 1639    01:DAAE  85 F9      			sta	<map_bat_y
 1640                        	
 1641               0001     		.if	BLKMAP_MULTISCR
 1642    01:DAB0  BC F8 29   			ldy	vdc_scr_bank, x		; Skip this if regular blkmap.
 1643    01:DAB3  D0 03 4C 2D			beq	.regular_row
         01:DAB7  DA          
 1644                        	
 1645    01:DAB8  A8         			tay				; If wrapped to the top line of
 1646    01:DAB9  D0 0B      			bne	!+			; of the BAT then increment the
 1647    01:DABB  E6 FF      			inc	<map_scrn_y		; screen.
 1648                        	
 1649    01:DABD  BD B3 24   			lda	vdc_bat_limit, x	; The map line must wrap around
 1650    01:DAC0  4A         			lsr	a			; too. This is simple since its
 1651    01:DAC1  4A         			lsr	a			; size (in bytes) is 1/4 of the
 1652    01:DAC2  25 EF      			and.h	<map_line		; BAT size (in words) and it is
 1653    01:DAC4  85 EF      			sta.h	<map_line		; a power-of-2.
 1654                        	
 1655    01:DAC6  4C D0 D9   	!:		jmp	.multiscr_row		; Draw next row.
 1656                        		.else
 1658                        		.endif	BLKMAP_MULTISCR
 1659                        	
 1660    01:DAC9  60         	.finished:	rts
 1661                        	
 1662                        	
 1663                        	
 1664               0000     		.if	BLKDEF_POINTERS
 1858                        		.else	BLKDEF_POINTERS
 1859                        	
 1860                        	
 1861                        	
 1862                        	; ***************************************************************************
 1863                        	; ***************************************************************************
 1864                        	;
 1865                        	; blk_row_strip - Draw a single row of CHR into the BAT.
 1866                        	;
 1867                        	
 1868    01:DACA  20 34 E4   	blk_row_strip:	jsr	set_di_xy_mawr		; Set the BAT VRAM destination.
 1869                        	
 1870    01:DACD  A5 FC      			lda	<map_chr_x		; Select what drawing code to
 1871    01:DACF  4A         			lsr	a			; use depending upon even/odd
 1872    01:DAD0  A5 FE      			lda	<map_chr_y		; CHR coordinates (not BAT to
 1873    01:DAD2  29 01      			and	#1			; support unaligned drawing).
 1874    01:DAD4  2A         			rol	a
 1875    01:DAD5  0A         			asl	a
 1876    01:DAD6  1D F1 29   			ora.h	vdc_blk_addr, x		; What is the BLK data address?
 1877    01:DAD9  29 1E      			and	#%00011110		; $4000, $4800, $5000 or $5800.
 1878    01:DADB  A8         			tay
 1879    01:DADC  B9 E9 DA   			lda.h	.jump_table, y		; Push the address of the code.
 1880    01:DADF  48         			pha
 1881    01:DAE0  B9 E8 DA   			lda.l	.jump_table, y
 1882    01:DAE3  48         			pha
 1883                        	
 1884    01:DAE4  B2 EC      			lda	[_bp]			; Get the first BLK number.
 1885    01:DAE6  A8         			tay
 1886                        	
 1887    01:DAE7  60         			rts				; Jump to the drawing code.
 1888                        	
 1889    01:DAE8  0A DB      	.jump_table:	dw	b4000_top_even - 1
 1890    01:DAEA  1D DB      			dw	b4000_top_odd - 1
 1891    01:DAEC  3A DB      			dw	b4000_btm_even - 1
 1892    01:DAEE  4D DB      			dw	b4000_btm_odd - 1
 1893                        	
 1894    01:DAF0  6A DB      			dw	b4800_top_even - 1
 1895    01:DAF2  7D DB      			dw	b4800_top_odd - 1
 1896    01:DAF4  9A DB      			dw	b4800_btm_even - 1
 1897    01:DAF6  AD DB      			dw	b4800_btm_odd - 1
 1898                        	
 1899    01:DAF8  CA DB      			dw	b5000_top_even - 1
 1900    01:DAFA  DD DB      			dw	b5000_top_odd - 1
 1901    01:DAFC  FA DB      			dw	b5000_btm_even - 1
 1902    01:DAFE  0D DC      			dw	b5000_btm_odd - 1
 1903                        	
 1904    01:DB00  2A DC      			dw	b5800_top_even - 1
 1905    01:DB02  3D DC      			dw	b5800_top_odd - 1
 1906    01:DB04  5A DC      			dw	b5800_btm_even - 1
 1907    01:DB06  6D DC      			dw	b5800_btm_odd - 1
 1908                        	
 1909                        			; top horizontal (32+2 rept)
 1910                        			;
 1911                        			; 89 cycles per block * 17 -> 1513 cycles
 1912                        	
 1913    01:DB08  B2 EC      	!repeat:	lda	[_bp]			; 7
 1914    01:DB0A  A8         			tay				; 2
 1915                        	
 1916    01:DB0B  B9 00 40   	b4000_top_even:	lda	BLK_4000_TL_L, y	; 5
 1917    01:DB0E  9D 02 02   			sta	VDC_DL, x		; 6
 1918    01:DB11  B9 00 44   			lda	BLK_4000_TL_H, y	; 5
 1919               0001     		.if	BLKDEF_CHR_FLAG
 1920    01:DB14  29 F3      			and	#%11110011		; 2
 1921                        		.endif
 1922    01:DB16  1A         			inc	a			; 2
 1923    01:DB17  9D 03 02   			sta	VDC_DH, x		; 6
 1924                        	
 1925    01:DB1A  C6 00      			dec	<map_count		; 6
 1926    01:DB1C  F0 19      			beq	!end+			; 2
 1927                        	
 1928    01:DB1E  B9 00 41   	b4000_top_odd:	lda	BLK_4000_TR_L, y	; 5
 1929    01:DB21  9D 02 02   			sta	VDC_DL, x		; 6
 1930    01:DB24  B9 00 45   			lda	BLK_4000_TR_H, y	; 5
 1931               0001     		.if	BLKDEF_CHR_FLAG
 1932    01:DB27  29 F3      			and	#%11110011		; 2
 1933                        		.endif
 1934    01:DB29  1A         			inc	a			; 2
 1935    01:DB2A  9D 03 02   			sta	VDC_DH, x		; 6
 1936                        	
 1937    01:DB2D  E6 EC      			inc.l	<_bp			; 6
 1938    01:DB2F  D0 02      			bne	!+			; 2/4
 1939    01:DB31  E6 ED      			inc.h	<_bp			; 6
 1940                        	
 1941    01:DB33  C6 00      	!:		dec	<map_count		; 6
 1942    01:DB35  D0 D1      			bne	!repeat-		; 4
 1943                        	
 1944    01:DB37  60         	!end:		rts
 1945                        	
 1946                        			; btm horizontal (32+2 rept)
 1947                        			;
 1948                        			; 89 cycles per block * 17 -> 1513 cycles
 1949                        	
 1950    01:DB38  B2 EC      	!repeat:	lda	[_bp]			; 7
 1951    01:DB3A  A8         			tay				; 2
 1952                        	
 1953    01:DB3B  B9 00 42   	b4000_btm_even:	lda	BLK_4000_BL_L, y	; 5
 1954    01:DB3E  9D 02 02   			sta	VDC_DL, x		; 6
 1955    01:DB41  B9 00 46   			lda	BLK_4000_BL_H, y	; 5
 1956               0001     		.if	BLKDEF_CHR_FLAG
 1957    01:DB44  29 F3      			and	#%11110011		; 2
 1958                        		.endif
 1959    01:DB46  1A         			inc	a			; 2
 1960    01:DB47  9D 03 02   			sta	VDC_DH, x		; 6
 1961                        	
 1962    01:DB4A  C6 00      			dec	<map_count		; 6
 1963    01:DB4C  F0 19      			beq	!end+			; 2
 1964                        	
 1965    01:DB4E  B9 00 43   	b4000_btm_odd:	lda	BLK_4000_BR_L, y	; 5
 1966    01:DB51  9D 02 02   			sta	VDC_DL, x		; 6
 1967    01:DB54  B9 00 47   			lda	BLK_4000_BR_H, y	; 5
 1968               0001     		.if	BLKDEF_CHR_FLAG
 1969    01:DB57  29 F3      			and	#%11110011		; 2
 1970                        		.endif
 1971    01:DB59  1A         			inc	a			; 2
 1972    01:DB5A  9D 03 02   			sta	VDC_DH, x		; 6
 1973                        	
 1974    01:DB5D  E6 EC      			inc.l	<_bp			; 6
 1975    01:DB5F  D0 02      			bne	!+			; 2/4
 1976    01:DB61  E6 ED      			inc.h	<_bp			; 6
 1977                        	
 1978    01:DB63  C6 00      	!:		dec	<map_count		; 6
 1979    01:DB65  D0 D1      			bne	!repeat-		; 4
 1980                        	
 1981    01:DB67  60         	!end:		rts
 1982                        	
 1983                        			; top horizontal (32+2 rept)
 1984                        			;
 1985                        			; 89 cycles per block * 17 -> 1513 cycles
 1986                        	
 1987    01:DB68  B2 EC      	!repeat:	lda	[_bp]			; 7
 1988    01:DB6A  A8         			tay				; 2
 1989                        	
 1990    01:DB6B  B9 00 48   	b4800_top_even:	lda	BLK_4800_TL_L, y	; 5
 1991    01:DB6E  9D 02 02   			sta	VDC_DL, x		; 6
 1992    01:DB71  B9 00 4C   			lda	BLK_4800_TL_H, y	; 5
 1993               0001     		.if	BLKDEF_CHR_FLAG
 1994    01:DB74  29 F3      			and	#%11110011		; 2
 1995                        		.endif
 1996    01:DB76  1A         			inc	a			; 2
 1997    01:DB77  9D 03 02   			sta	VDC_DH, x		; 6
 1998                        	
 1999    01:DB7A  C6 00      			dec	<map_count		; 6
 2000    01:DB7C  F0 19      			beq	!end+			; 2
 2001                        	
 2002    01:DB7E  B9 00 49   	b4800_top_odd:	lda	BLK_4800_TR_L, y	; 5
 2003    01:DB81  9D 02 02   			sta	VDC_DL, x		; 6
 2004    01:DB84  B9 00 4D   			lda	BLK_4800_TR_H, y	; 5
 2005               0001     		.if	BLKDEF_CHR_FLAG
 2006    01:DB87  29 F3      			and	#%11110011		; 2
 2007                        		.endif
 2008    01:DB89  1A         			inc	a			; 2
 2009    01:DB8A  9D 03 02   			sta	VDC_DH, x		; 6
 2010                        	
 2011    01:DB8D  E6 EC      			inc.l	<_bp			; 6
 2012    01:DB8F  D0 02      			bne	!+			; 2/4
 2013    01:DB91  E6 ED      			inc.h	<_bp			; 6
 2014                        	
 2015    01:DB93  C6 00      	!:		dec	<map_count		; 6
 2016    01:DB95  D0 D1      			bne	!repeat-		; 4
 2017                        	
 2018    01:DB97  60         	!end:		rts
 2019                        	
 2020                        			; btm horizontal (32+2 rept)
 2021                        			;
 2022                        			; 89 cycles per block * 17 -> 1513 cycles
 2023                        	
 2024    01:DB98  B2 EC      	!repeat:	lda	[_bp]			; 7
 2025    01:DB9A  A8         			tay				; 2
 2026                        	
 2027    01:DB9B  B9 00 4A   	b4800_btm_even:	lda	BLK_4800_BL_L, y	; 5
 2028    01:DB9E  9D 02 02   			sta	VDC_DL, x		; 6
 2029    01:DBA1  B9 00 4E   			lda	BLK_4800_BL_H, y	; 5
 2030               0001     		.if	BLKDEF_CHR_FLAG
 2031    01:DBA4  29 F3      			and	#%11110011		; 2
 2032                        		.endif
 2033    01:DBA6  1A         			inc	a			; 2
 2034    01:DBA7  9D 03 02   			sta	VDC_DH, x		; 6
 2035                        	
 2036    01:DBAA  C6 00      			dec	<map_count		; 6
 2037    01:DBAC  F0 19      			beq	!end+			; 2
 2038                        	
 2039    01:DBAE  B9 00 4B   	b4800_btm_odd:	lda	BLK_4800_BR_L, y	; 5
 2040    01:DBB1  9D 02 02   			sta	VDC_DL, x		; 6
 2041    01:DBB4  B9 00 4F   			lda	BLK_4800_BR_H, y	; 5
 2042               0001     		.if	BLKDEF_CHR_FLAG
 2043    01:DBB7  29 F3      			and	#%11110011		; 2
 2044                        		.endif
 2045    01:DBB9  1A         			inc	a			; 2
 2046    01:DBBA  9D 03 02   			sta	VDC_DH, x		; 6
 2047                        	
 2048    01:DBBD  E6 EC      			inc.l	<_bp			; 6
 2049    01:DBBF  D0 02      			bne	!+			; 2/4
 2050    01:DBC1  E6 ED      			inc.h	<_bp			; 6
 2051                        	
 2052    01:DBC3  C6 00      	!:		dec	<map_count		; 6
 2053    01:DBC5  D0 D1      			bne	!repeat-		; 4
 2054                        	
 2055    01:DBC7  60         	!end:		rts
 2056                        	
 2057                        			; top horizontal (32+2 rept)
 2058                        			;
 2059                        			; 89 cycles per block * 17 -> 1513 cycles
 2060                        	
 2061    01:DBC8  B2 EC      	!repeat:	lda	[_bp]			; 7
 2062    01:DBCA  A8         			tay				; 2
 2063                        	
 2064    01:DBCB  B9 00 50   	b5000_top_even:	lda	BLK_5000_TL_L, y	; 5
 2065    01:DBCE  9D 02 02   			sta	VDC_DL, x		; 6
 2066    01:DBD1  B9 00 54   			lda	BLK_5000_TL_H, y	; 5
 2067               0001     		.if	BLKDEF_CHR_FLAG
 2068    01:DBD4  29 F3      			and	#%11110011		; 2
 2069                        		.endif
 2070    01:DBD6  1A         			inc	a			; 2
 2071    01:DBD7  9D 03 02   			sta	VDC_DH, x		; 6
 2072                        	
 2073    01:DBDA  C6 00      			dec	<map_count		; 6
 2074    01:DBDC  F0 19      			beq	!end+			; 2
 2075                        	
 2076    01:DBDE  B9 00 51   	b5000_top_odd:	lda	BLK_5000_TR_L, y	; 5
 2077    01:DBE1  9D 02 02   			sta	VDC_DL, x		; 6
 2078    01:DBE4  B9 00 55   			lda	BLK_5000_TR_H, y	; 5
 2079               0001     		.if	BLKDEF_CHR_FLAG
 2080    01:DBE7  29 F3      			and	#%11110011		; 2
 2081                        		.endif
 2082    01:DBE9  1A         			inc	a			; 2
 2083    01:DBEA  9D 03 02   			sta	VDC_DH, x		; 6
 2084                        	
 2085    01:DBED  E6 EC      			inc.l	<_bp			; 6
 2086    01:DBEF  D0 02      			bne	!+			; 2/4
 2087    01:DBF1  E6 ED      			inc.h	<_bp			; 6
 2088                        	
 2089    01:DBF3  C6 00      	!:		dec	<map_count		; 6
 2090    01:DBF5  D0 D1      			bne	!repeat-		; 4
 2091                        	
 2092    01:DBF7  60         	!end:		rts
 2093                        	
 2094                        			; btm horizontal (32+2 rept)
 2095                        			;
 2096                        			; 89 cycles per block * 17 -> 1513 cycles
 2097                        	
 2098    01:DBF8  B2 EC      	!repeat:	lda	[_bp]			; 7
 2099    01:DBFA  A8         			tay				; 2
 2100                        	
 2101    01:DBFB  B9 00 52   	b5000_btm_even:	lda	BLK_5000_BL_L, y	; 5
 2102    01:DBFE  9D 02 02   			sta	VDC_DL, x		; 6
 2103    01:DC01  B9 00 56   			lda	BLK_5000_BL_H, y	; 5
 2104               0001     		.if	BLKDEF_CHR_FLAG
 2105    01:DC04  29 F3      			and	#%11110011		; 2
 2106                        		.endif
 2107    01:DC06  1A         			inc	a			; 2
 2108    01:DC07  9D 03 02   			sta	VDC_DH, x		; 6
 2109                        	
 2110    01:DC0A  C6 00      			dec	<map_count		; 6
 2111    01:DC0C  F0 19      			beq	!end+			; 2
 2112                        	
 2113    01:DC0E  B9 00 53   	b5000_btm_odd:	lda	BLK_5000_BR_L, y	; 5
 2114    01:DC11  9D 02 02   			sta	VDC_DL, x		; 6
 2115    01:DC14  B9 00 57   			lda	BLK_5000_BR_H, y	; 5
 2116               0001     		.if	BLKDEF_CHR_FLAG
 2117    01:DC17  29 F3      			and	#%11110011		; 2
 2118                        		.endif
 2119    01:DC19  1A         			inc	a			; 2
 2120    01:DC1A  9D 03 02   			sta	VDC_DH, x		; 6
 2121                        	
 2122    01:DC1D  E6 EC      			inc.l	<_bp			; 6
 2123    01:DC1F  D0 02      			bne	!+			; 2/4
 2124    01:DC21  E6 ED      			inc.h	<_bp			; 6
 2125                        	
 2126    01:DC23  C6 00      	!:		dec	<map_count		; 6
 2127    01:DC25  D0 D1      			bne	!repeat-		; 4
 2128                        	
 2129    01:DC27  60         	!end:		rts
 2130                        	
 2131                        			; top horizontal (32+2 rept)
 2132                        			;
 2133                        			; 89 cycles per block * 17 -> 1513 cycles
 2134                        	
 2135    01:DC28  B2 EC      	!repeat:	lda	[_bp]			; 7
 2136    01:DC2A  A8         			tay				; 2
 2137                        	
 2138    01:DC2B  B9 00 58   	b5800_top_even:	lda	BLK_5800_TL_L, y	; 5
 2139    01:DC2E  9D 02 02   			sta	VDC_DL, x		; 6
 2140    01:DC31  B9 00 5C   			lda	BLK_5800_TL_H, y	; 5
 2141               0001     		.if	BLKDEF_CHR_FLAG
 2142    01:DC34  29 F3      			and	#%11110011		; 2
 2143                        		.endif
 2144    01:DC36  1A         			inc	a			; 2
 2145    01:DC37  9D 03 02   			sta	VDC_DH, x		; 6
 2146                        	
 2147    01:DC3A  C6 00      			dec	<map_count		; 6
 2148    01:DC3C  F0 19      			beq	!end+			; 2
 2149                        	
 2150    01:DC3E  B9 00 59   	b5800_top_odd:	lda	BLK_5800_TR_L, y	; 5
 2151    01:DC41  9D 02 02   			sta	VDC_DL, x		; 6
 2152    01:DC44  B9 00 5D   			lda	BLK_5800_TR_H, y	; 5
 2153               0001     		.if	BLKDEF_CHR_FLAG
 2154    01:DC47  29 F3      			and	#%11110011		; 2
 2155                        		.endif
 2156    01:DC49  1A         			inc	a			; 2
 2157    01:DC4A  9D 03 02   			sta	VDC_DH, x		; 6
 2158                        	
 2159    01:DC4D  E6 EC      			inc.l	<_bp			; 6
 2160    01:DC4F  D0 02      			bne	!+			; 2/4
 2161    01:DC51  E6 ED      			inc.h	<_bp			; 6
 2162                        	
 2163    01:DC53  C6 00      	!:		dec	<map_count		; 6
 2164    01:DC55  D0 D1      			bne	!repeat-		; 4
 2165                        	
 2166    01:DC57  60         	!end:		rts
 2167                        	
 2168                        			; btm horizontal (32+2 rept)
 2169                        			;
 2170                        			; 89 cycles per block * 17 -> 1513 cycles
 2171                        	
 2172    01:DC58  B2 EC      	!repeat:	lda	[_bp]		; 7
 2173    01:DC5A  A8         			tay				; 2
 2174                        	
 2175    01:DC5B  B9 00 5A   	b5800_btm_even:	lda	BLK_5800_BL_L, y	; 5
 2176    01:DC5E  9D 02 02   			sta	VDC_DL, x		; 6
 2177    01:DC61  B9 00 5E   			lda	BLK_5800_BL_H, y	; 5
 2178               0001     		.if	BLKDEF_CHR_FLAG
 2179    01:DC64  29 F3      			and	#%11110011		; 2
 2180                        		.endif
 2181    01:DC66  1A         			inc	a			; 2
 2182    01:DC67  9D 03 02   			sta	VDC_DH, x		; 6
 2183                        	
 2184    01:DC6A  C6 00      			dec	<map_count		; 6
 2185    01:DC6C  F0 19      			beq	!end+			; 2
 2186                        	
 2187    01:DC6E  B9 00 5B   	b5800_btm_odd:	lda	BLK_5800_BR_L, y	; 5
 2188    01:DC71  9D 02 02   			sta	VDC_DL, x		; 6
 2189    01:DC74  B9 00 5F   			lda	BLK_5800_BR_H, y	; 5
 2190               0001     		.if	BLKDEF_CHR_FLAG
 2191    01:DC77  29 F3      			and	#%11110011		; 2
 2192                        		.endif
 2193    01:DC79  1A         			inc	a			; 2
 2194    01:DC7A  9D 03 02   			sta	VDC_DH, x		; 6
 2195                        	
 2196    01:DC7D  E6 EC      			inc.l	<_bp			; 6
 2197    01:DC7F  D0 02      			bne	!+			; 2/4
 2198    01:DC81  E6 ED      			inc.h	<_bp			; 6
 2199                        	
 2200    01:DC83  C6 00      	!:		dec	<map_count		; 6
 2201    01:DC85  D0 D1      			bne	!repeat-		; 4
 2202                        	
 2203    01:DC87  60         	!end:		rts
 2204                        	
 2205                        	
 2206                        	
 2207                        	; ***************************************************************************
 2208                        	; ***************************************************************************
 2209                        	;
 2210                        	; blk_col_strip - Draw a single column of CHR into the BAT.
 2211                        	;
 2212                        	
 2213    01:DC88  20 34 E4   	blk_col_strip:	jsr	set_di_xy_mawr		; Set the BAT VRAM destination.
 2214                        	
 2215    01:DC8B  A5 FC      			lda	<map_chr_x		; Select what drawing code to
 2216    01:DC8D  4A         			lsr	a			; use depending upon even/odd
 2217    01:DC8E  A5 FE      			lda	<map_chr_y		; CHR coordinates (not BAT to
 2218    01:DC90  29 01      			and	#1			; support unaligned drawing).
 2219    01:DC92  2A         			rol	a
 2220    01:DC93  0A         			asl	a			; N.B. Always leaves C clear.
 2221    01:DC94  1D F1 29   			ora.h	vdc_blk_addr, x		; What is the BLK data address?
 2222    01:DC97  29 1E      			and	#%00011110		; $4000, $4800, $5000 or $5800.
 2223    01:DC99  A8         			tay
 2224    01:DC9A  B9 A7 DC   			lda.h	.jump_table, y		; Push the address of the code.
 2225    01:DC9D  48         			pha
 2226    01:DC9E  B9 A6 DC   			lda.l	.jump_table, y
 2227    01:DCA1  48         			pha
 2228                        	
 2229    01:DCA2  B2 EC      			lda	[_bp]			; Get the first BLK number.
 2230    01:DCA4  A8         			tay
 2231                        	
 2232    01:DCA5  60         			rts				; Jump to the drawing code.
 2233                        	
 2234    01:DCA6  C8 DC      	.jump_table:	dw	b4000_lhs_even - 1
 2235    01:DCA8  FE DC      			dw	b4000_rhs_even - 1
 2236    01:DCAA  DB DC      			dw	b4000_lhs_odd - 1
 2237    01:DCAC  11 DD      			dw	b4000_rhs_odd - 1
 2238                        	
 2239    01:DCAE  34 DD      			dw	b4800_lhs_even - 1
 2240    01:DCB0  6A DD      			dw	b4800_rhs_even - 1
 2241    01:DCB2  47 DD      			dw	b4800_lhs_odd - 1
 2242    01:DCB4  7D DD      			dw	b4800_rhs_odd - 1
 2243                        	
 2244    01:DCB6  A0 DD      			dw	b5000_lhs_even - 1
 2245    01:DCB8  D6 DD      			dw	b5000_rhs_even - 1
 2246    01:DCBA  B3 DD      			dw	b5000_lhs_odd - 1
 2247    01:DCBC  E9 DD      			dw	b5000_rhs_odd - 1
 2248                        	
 2249    01:DCBE  0C DE      			dw	b5800_lhs_even - 1
 2250    01:DCC0  42 DE      			dw	b5800_rhs_even - 1
 2251    01:DCC2  1F DE      			dw	b5800_lhs_odd - 1
 2252    01:DCC4  55 DE      			dw	b5800_rhs_odd - 1
 2253                        	
 2254                        			; lhs vertical (28+2 rept)
 2255                        			;
 2256                        			; N.B. C is always clear on entry.
 2257                        			;
 2258                        			; 100 cycles per block * 15 -> 1500 cycles
 2259                        	
 2260    01:DCC6  B2 EC      	!repeat:	lda	[_bp]			; 7
 2261    01:DCC8  A8         			tay				; 2
 2262                        	
 2263    01:DCC9  B9 00 40   	b4000_lhs_even:	lda	BLK_4000_TL_L, y	; 5
 2264    01:DCCC  9D 02 02   			sta	VDC_DL, x		; 6
 2265    01:DCCF  B9 00 44   			lda	BLK_4000_TL_H, y	; 5
 2266               0001     		.if	BLKDEF_CHR_FLAG
 2267    01:DCD2  29 F3      			and	#%11110011		; 2
 2268                        		.endif
 2269    01:DCD4  1A         			inc	a			; 2
 2270    01:DCD5  9D 03 02   			sta	VDC_DH, x		; 6
 2271                        	
 2272    01:DCD8  C6 00      			dec	<map_count		; 6
 2273    01:DCDA  F0 1F      			beq	!end+			; 2
 2274                        	
 2275    01:DCDC  B9 00 42   	b4000_lhs_odd:	lda	BLK_4000_BL_L, y	; 5
 2276    01:DCDF  9D 02 02   			sta	VDC_DL, x		; 6
 2277    01:DCE2  B9 00 46   			lda	BLK_4000_BL_H, y	; 5
 2278               0001     		.if	BLKDEF_CHR_FLAG
 2279    01:DCE5  29 F3      			and	#%11110011		; 2
 2280                        		.endif
 2281    01:DCE7  1A         			inc	a			; 2
 2282    01:DCE8  9D 03 02   			sta	VDC_DH, x		; 6
 2283                        	
 2284    01:DCEB  BD B6 24   			lda	vdc_map_line_w, x	; 5
 2285    01:DCEE  65 EC      			adc.l	<_bp			; 4
 2286    01:DCF0  85 EC      			sta.l	<_bp			; 4
 2287    01:DCF2  90 03      			bcc	!+			; 2/4
 2288    01:DCF4  E6 ED      			inc.h	<_bp			; 6
 2289    01:DCF6  18         			clc				; 2
 2290                        	
 2291    01:DCF7  C6 00      	!:		dec	<map_count		; 6
 2292    01:DCF9  D0 CB      			bne	!repeat-		; 4
 2293                        	
 2294    01:DCFB  60         	!end:		rts
 2295                        	
 2296                        			; rhs vertical (28+2 rept)
 2297                        			;
 2298                        			; N.B. C is always clear on entry.
 2299                        			;
 2300                        			; 100 cycles per block * 15 -> 1500 cycles
 2301                        	
 2302    01:DCFC  B2 EC      	!repeat:	lda	[_bp]			; 7
 2303    01:DCFE  A8         			tay				; 2
 2304                        	
 2305    01:DCFF  B9 00 41   	b4000_rhs_even:	lda	BLK_4000_TR_L, y	; 5
 2306    01:DD02  9D 02 02   			sta	VDC_DL, x		; 6
 2307    01:DD05  B9 00 45   			lda	BLK_4000_TR_H, y	; 5
 2308               0001     		.if	BLKDEF_CHR_FLAG
 2309    01:DD08  29 F3      			and	#%11110011		; 2
 2310                        		.endif
 2311    01:DD0A  1A         			inc	a			; 2
 2312    01:DD0B  9D 03 02   			sta	VDC_DH, x		; 6
 2313                        	
 2314    01:DD0E  C6 00      			dec	<map_count		; 6
 2315    01:DD10  F0 1F      			beq	!end+			; 2
 2316                        	
 2317    01:DD12  B9 00 43   	b4000_rhs_odd:	lda	BLK_4000_BR_L, y	; 5
 2318    01:DD15  9D 02 02   			sta	VDC_DL, x		; 6
 2319    01:DD18  B9 00 47   			lda	BLK_4000_BR_H, y	; 5
 2320               0001     		.if	BLKDEF_CHR_FLAG
 2321    01:DD1B  29 F3      			and	#%11110011		; 2
 2322                        		.endif
 2323    01:DD1D  1A         			inc	a			; 2
 2324    01:DD1E  9D 03 02   			sta	VDC_DH, x		; 6
 2325                        	
 2326    01:DD21  BD B6 24   			lda	vdc_map_line_w, x	; 5
 2327    01:DD24  65 EC      			adc.l	<_bp			; 4
 2328    01:DD26  85 EC      			sta.l	<_bp			; 4
 2329    01:DD28  90 03      			bcc	!+			; 2/4
 2330    01:DD2A  E6 ED      			inc.h	<_bp			; 6
 2331    01:DD2C  18         			clc				; 2
 2332                        	
 2333    01:DD2D  C6 00      	!:		dec	<map_count		; 6
 2334    01:DD2F  D0 CB      			bne	!repeat-		; 4
 2335                        	
 2336    01:DD31  60         	!end:		rts
 2337                        	
 2338                        			; lhs vertical (28+2 rept)
 2339                        			;
 2340                        			; N.B. C is always clear on entry.
 2341                        			;
 2342                        			; 100 cycles per block * 15 -> 1500 cycles
 2343                        	
 2344    01:DD32  B2 EC      	!repeat:	lda	[_bp]			; 7
 2345    01:DD34  A8         			tay				; 2
 2346                        	
 2347    01:DD35  B9 00 48   	b4800_lhs_even:	lda	BLK_4800_TL_L, y	; 5
 2348    01:DD38  9D 02 02   			sta	VDC_DL, x		; 6
 2349    01:DD3B  B9 00 4C   			lda	BLK_4800_TL_H, y	; 5
 2350               0001     		.if	BLKDEF_CHR_FLAG
 2351    01:DD3E  29 F3      			and	#%11110011		; 2
 2352                        		.endif
 2353    01:DD40  1A         			inc	a			; 2
 2354    01:DD41  9D 03 02   			sta	VDC_DH, x		; 6
 2355                        	
 2356    01:DD44  C6 00      			dec	<map_count		; 6
 2357    01:DD46  F0 1F      			beq	!end+			; 2
 2358                        	
 2359    01:DD48  B9 00 4A   	b4800_lhs_odd:	lda	BLK_4800_BL_L, y	; 5
 2360    01:DD4B  9D 02 02   			sta	VDC_DL, x		; 6
 2361    01:DD4E  B9 00 4E   			lda	BLK_4800_BL_H, y	; 5
 2362               0001     		.if	BLKDEF_CHR_FLAG
 2363    01:DD51  29 F3      			and	#%11110011		; 2
 2364                        		.endif
 2365    01:DD53  1A         			inc	a			; 2
 2366    01:DD54  9D 03 02   			sta	VDC_DH, x		; 6
 2367                        	
 2368    01:DD57  BD B6 24   			lda	vdc_map_line_w, x	; 5
 2369    01:DD5A  65 EC      			adc.l	<_bp			; 4
 2370    01:DD5C  85 EC      			sta.l	<_bp			; 4
 2371    01:DD5E  90 03      			bcc	!+			; 2/4
 2372    01:DD60  E6 ED      			inc.h	<_bp			; 6
 2373    01:DD62  18         			clc				; 2
 2374                        	
 2375    01:DD63  C6 00      	!:		dec	<map_count		; 6
 2376    01:DD65  D0 CB      			bne	!repeat-		; 4
 2377                        	
 2378    01:DD67  60         	!end:		rts
 2379                        	
 2380                        			; rhs vertical (28+2 rept)
 2381                        			;
 2382                        			; N.B. C is always clear on entry.
 2383                        			;
 2384                        			; 100 cycles per block * 15 -> 1500 cycles
 2385                        	
 2386    01:DD68  B2 EC      	!repeat:	lda	[_bp]			; 7
 2387    01:DD6A  A8         			tay				; 2
 2388                        	
 2389    01:DD6B  B9 00 49   	b4800_rhs_even:	lda	BLK_4800_TR_L, y	; 5
 2390    01:DD6E  9D 02 02   			sta	VDC_DL, x		; 6
 2391    01:DD71  B9 00 4D   			lda	BLK_4800_TR_H, y	; 5
 2392               0001     		.if	BLKDEF_CHR_FLAG
 2393    01:DD74  29 F3      			and	#%11110011		; 2
 2394                        		.endif
 2395    01:DD76  1A         			inc	a			; 2
 2396    01:DD77  9D 03 02   			sta	VDC_DH, x		; 6
 2397                        	
 2398    01:DD7A  C6 00      			dec	<map_count		; 6
 2399    01:DD7C  F0 1F      			beq	!end+			; 2
 2400                        	
 2401    01:DD7E  B9 00 4B   	b4800_rhs_odd:	lda	BLK_4800_BR_L, y	; 5
 2402    01:DD81  9D 02 02   			sta	VDC_DL, x		; 6
 2403    01:DD84  B9 00 4F   			lda	BLK_4800_BR_H, y	; 5
 2404               0001     		.if	BLKDEF_CHR_FLAG
 2405    01:DD87  29 F3      			and	#%11110011		; 2
 2406                        		.endif
 2407    01:DD89  1A         			inc	a			; 2
 2408    01:DD8A  9D 03 02   			sta	VDC_DH, x		; 6
 2409                        	
 2410    01:DD8D  BD B6 24   			lda	vdc_map_line_w, x	; 5
 2411    01:DD90  65 EC      			adc.l	<_bp			; 4
 2412    01:DD92  85 EC      			sta.l	<_bp			; 4
 2413    01:DD94  90 03      			bcc	!+			; 2/4
 2414    01:DD96  E6 ED      			inc.h	<_bp			; 6
 2415    01:DD98  18         			clc				; 2
 2416                        	
 2417    01:DD99  C6 00      	!:		dec	<map_count		; 6
 2418    01:DD9B  D0 CB      			bne	!repeat-		; 4
 2419                        	
 2420    01:DD9D  60         	!end:		rts
 2421                        	
 2422                        			; lhs vertical (28+2 rept)
 2423                        			;
 2424                        			; N.B. C is always clear on entry.
 2425                        			;
 2426                        			; 100 cycles per block * 15 -> 1500 cycles
 2427                        	
 2428    01:DD9E  B2 EC      	!repeat:	lda	[_bp]			; 7
 2429    01:DDA0  A8         			tay				; 2
 2430                        	
 2431    01:DDA1  B9 00 50   	b5000_lhs_even:	lda	BLK_5000_TL_L, y	; 5
 2432    01:DDA4  9D 02 02   			sta	VDC_DL, x		; 6
 2433    01:DDA7  B9 00 54   			lda	BLK_5000_TL_H, y	; 5
 2434               0001     		.if	BLKDEF_CHR_FLAG
 2435    01:DDAA  29 F3      			and	#%11110011		; 2
 2436                        		.endif
 2437    01:DDAC  1A         			inc	a			; 2
 2438    01:DDAD  9D 03 02   			sta	VDC_DH, x		; 6
 2439                        	
 2440    01:DDB0  C6 00      			dec	<map_count		; 6
 2441    01:DDB2  F0 1F      			beq	!end+			; 2
 2442                        	
 2443    01:DDB4  B9 00 52   	b5000_lhs_odd:	lda	BLK_5000_BL_L, y	; 5
 2444    01:DDB7  9D 02 02   			sta	VDC_DL, x		; 6
 2445    01:DDBA  B9 00 56   			lda	BLK_5000_BL_H, y	; 5
 2446               0001     		.if	BLKDEF_CHR_FLAG
 2447    01:DDBD  29 F3      			and	#%11110011		; 2
 2448                        		.endif
 2449    01:DDBF  1A         			inc	a			; 2
 2450    01:DDC0  9D 03 02   			sta	VDC_DH, x		; 6
 2451                        	
 2452    01:DDC3  BD B6 24   			lda	vdc_map_line_w, x	; 5
 2453    01:DDC6  65 EC      			adc.l	<_bp			; 4
 2454    01:DDC8  85 EC      			sta.l	<_bp			; 4
 2455    01:DDCA  90 03      			bcc	!+			; 2/4
 2456    01:DDCC  E6 ED      			inc.h	<_bp			; 6
 2457    01:DDCE  18         			clc				; 2
 2458                        	
 2459    01:DDCF  C6 00      	!:		dec	<map_count		; 6
 2460    01:DDD1  D0 CB      			bne	!repeat-		; 4
 2461                        	
 2462    01:DDD3  60         	!end:		rts
 2463                        	
 2464                        			; rhs vertical (28+2 rept)
 2465                        			;
 2466                        			; N.B. C is always clear on entry.
 2467                        			;
 2468                        			; 100 cycles per block * 15 -> 1500 cycles
 2469                        	
 2470    01:DDD4  B2 EC      	!repeat:	lda	[_bp]			; 7
 2471    01:DDD6  A8         			tay				; 2
 2472                        	
 2473    01:DDD7  B9 00 51   	b5000_rhs_even:	lda	BLK_5000_TR_L, y	; 5
 2474    01:DDDA  9D 02 02   			sta	VDC_DL, x		; 6
 2475    01:DDDD  B9 00 55   			lda	BLK_5000_TR_H, y	; 5
 2476               0001     		.if	BLKDEF_CHR_FLAG
 2477    01:DDE0  29 F3      			and	#%11110011		; 2
 2478                        		.endif
 2479    01:DDE2  1A         			inc	a			; 2
 2480    01:DDE3  9D 03 02   			sta	VDC_DH, x		; 6
 2481                        	
 2482    01:DDE6  C6 00      			dec	<map_count		; 6
 2483    01:DDE8  F0 1F      			beq	!end+			; 2
 2484                        	
 2485    01:DDEA  B9 00 53   	b5000_rhs_odd:	lda	BLK_5000_BR_L, y	; 5
 2486    01:DDED  9D 02 02   			sta	VDC_DL, x		; 6
 2487    01:DDF0  B9 00 57   			lda	BLK_5000_BR_H, y	; 5
 2488               0001     		.if	BLKDEF_CHR_FLAG
 2489    01:DDF3  29 F3      			and	#%11110011		; 2
 2490                        		.endif
 2491    01:DDF5  1A         			inc	a			; 2
 2492    01:DDF6  9D 03 02   			sta	VDC_DH, x		; 6
 2493                        	
 2494    01:DDF9  BD B6 24   			lda	vdc_map_line_w, x	; 5
 2495    01:DDFC  65 EC      			adc.l	<_bp			; 4
 2496    01:DDFE  85 EC      			sta.l	<_bp			; 4
 2497    01:DE00  90 03      			bcc	!+			; 2/4
 2498    01:DE02  E6 ED      			inc.h	<_bp			; 6
 2499    01:DE04  18         			clc				; 2
 2500                        	
 2501    01:DE05  C6 00      	!:		dec	<map_count		; 6
 2502    01:DE07  D0 CB      			bne	!repeat-		; 4
 2503                        	
 2504    01:DE09  60         	!end:		rts
 2505                        	
 2506                        			; lhs vertical (28+2 rept)
 2507                        			;
 2508                        			; N.B. C is always clear on entry.
 2509                        			;
 2510                        			; 100 cycles per block * 15 -> 1500 cycles
 2511                        	
 2512    01:DE0A  B2 EC      	!repeat:	lda	[_bp]			; 7
 2513    01:DE0C  A8         			tay				; 2
 2514                        	
 2515    01:DE0D  B9 00 58   	b5800_lhs_even:	lda	BLK_5800_TL_L, y	; 5
 2516    01:DE10  9D 02 02   			sta	VDC_DL, x		; 6
 2517    01:DE13  B9 00 5C   			lda	BLK_5800_TL_H, y	; 5
 2518               0001     		.if	BLKDEF_CHR_FLAG
 2519    01:DE16  29 F3      			and	#%11110011		; 2
 2520                        		.endif
 2521    01:DE18  1A         			inc	a			; 2
 2522    01:DE19  9D 03 02   			sta	VDC_DH, x		; 6
 2523                        	
 2524    01:DE1C  C6 00      			dec	<map_count		; 6
 2525    01:DE1E  F0 1F      			beq	!end+			; 2
 2526                        	
 2527    01:DE20  B9 00 5A   	b5800_lhs_odd:	lda	BLK_5800_BL_L, y	; 5
 2528    01:DE23  9D 02 02   			sta	VDC_DL, x		; 6
 2529    01:DE26  B9 00 5E   			lda	BLK_5800_BL_H, y	; 5
 2530               0001     		.if	BLKDEF_CHR_FLAG
 2531    01:DE29  29 F3      			and	#%11110011		; 2
 2532                        		.endif
 2533    01:DE2B  1A         			inc	a			; 2
 2534    01:DE2C  9D 03 02   			sta	VDC_DH, x		; 6
 2535                        	
 2536    01:DE2F  BD B6 24   			lda	vdc_map_line_w, x	; 5
 2537    01:DE32  65 EC      			adc.l	<_bp			; 4
 2538    01:DE34  85 EC      			sta.l	<_bp			; 4
 2539    01:DE36  90 03      			bcc	!+			; 2/4
 2540    01:DE38  E6 ED      			inc.h	<_bp			; 6
 2541    01:DE3A  18         			clc				; 2
 2542                        	
 2543    01:DE3B  C6 00      	!:		dec	<map_count		; 6
 2544    01:DE3D  D0 CB      			bne	!repeat-		; 4
 2545                        	
 2546    01:DE3F  60         	!end:		rts
 2547                        	
 2548                        			; rhs vertical (28+2 rept)
 2549                        			;
 2550                        			; N.B. C is always clear on entry.
 2551                        			;
 2552                        			; 100 cycles per block * 15 -> 1500 cycles
 2553                        	
 2554    01:DE40  B2 EC      	!repeat:	lda	[_bp]			; 7
 2555    01:DE42  A8         			tay				; 2
 2556                        	
 2557    01:DE43  B9 00 59   	b5800_rhs_even:	lda	BLK_5800_TR_L, y	; 5
 2558    01:DE46  9D 02 02   			sta	VDC_DL, x		; 6
 2559    01:DE49  B9 00 5D   			lda	BLK_5800_TR_H, y	; 5
 2560               0001     		.if	BLKDEF_CHR_FLAG
 2561    01:DE4C  29 F3      			and	#%11110011		; 2
 2562                        		.endif
 2563    01:DE4E  1A         			inc	a			; 2
 2564    01:DE4F  9D 03 02   			sta	VDC_DH, x		; 6
 2565                        	
 2566    01:DE52  C6 00      			dec	<map_count		; 6
 2567    01:DE54  F0 1F      			beq	!end+			; 2
 2568                        	
 2569    01:DE56  B9 00 5B   	b5800_rhs_odd:	lda	BLK_5800_BR_L, y	; 5
 2570    01:DE59  9D 02 02   			sta	VDC_DL, x		; 6
 2571    01:DE5C  B9 00 5F   			lda	BLK_5800_BR_H, y	; 5
 2572               0001     		.if	BLKDEF_CHR_FLAG
 2573    01:DE5F  29 F3      			and	#%11110011		; 2
 2574                        		.endif
 2575    01:DE61  1A         			inc	a			; 2
 2576    01:DE62  9D 03 02   			sta	VDC_DH, x		; 6
 2577                        	
 2578    01:DE65  BD B6 24   			lda	vdc_map_line_w, x	; 5
 2579    01:DE68  65 EC      			adc.l	<_bp			; 4
 2580    01:DE6A  85 EC      			sta.l	<_bp			; 4
 2581    01:DE6C  90 03      			bcc	!+			; 2/4
 2582    01:DE6E  E6 ED      			inc.h	<_bp			; 6
 2583    01:DE70  18         			clc				; 2
 2584                        	
 2585    01:DE71  C6 00      	!:		dec	<map_count		; 6
 2586    01:DE73  D0 CB      			bne	!repeat-		; 4
 2587                        	
 2588    01:DE75  60         	!end:		rts
 2589                        	
 2590                        		.endif	BLKDEF_POINTERS
 2591                        	
 2592                        		.endprocgroup	; blkmap_group
                             #[2]   "..\..\..\include\hucc\hucc-final.asm"
   80                        		.else
   84                        		.endif	HUCC_USES_BLKMAP
   85                        	
   86               0001     		.ifdef	HUCC_USES_CHRMAP		; Set in hucc_chrmap.h
                             #[3]   "..\..\..\include\hucc\chrmap.asm"
   87                        			include	"chrmap.asm"
    1                        	; ***************************************************************************
    2                        	; ***************************************************************************
    3                        	;
    4                        	; chrmap.asm
    5                        	;
    6                        	; A simple map system based on 8x8 characters (aka "tiles") in BAT format.
    7                        	;
    8                        	; Copyright John Brandwood 2025.
    9                        	;
   10                        	; Distributed under the Boost Software License, Version 1.0.
   11                        	; (See accompanying file LICENSE_1_0.txt or copy at
   12                        	;  http://www.boost.org/LICENSE_1_0.txt)
   13                        	;
   14                        	; ***************************************************************************
   15                        	; ***************************************************************************
   16                        	;
   17                        	; The maximum X and Y size for chrmaps is 256 characters (2048 pixels).
   18                        	;
   19                        	; The maximum total size for a chrmap is 16KBytes, which allows for maps up
   20                        	; to 256x32 tiles (2048x256 pixels).
   21                        	;
   22                        	; ***************************************************************************
   23                        	; ***************************************************************************
   24                        	
   25                        	;
   26                        	; Include dependancies ...
   27                        	;
   28                        	
   29                        			include "blkmap.asm"		; This defines the variables.
   30                        	
   31                        	;
   32                        	; Chrmaps in BAT format normally address all of VRAM from $0400..$7FFF, but
   33                        	; they can be limited to use the 32KByte of characters in VRAM $1000..$4FFF
   34                        	; which then frees up 2-bits for flag information for each character in the
   35                        	; BAT entry.
   36                        	;
   37                        	; These 2-bits are perfect for using as collision information in game maps,
   38                        	; allowing storage of states like transparent, solid, up-slope, down-slope.
   39                        	;
   40                        	; Typically this flag information is set by the map conversion tools from a
   41                        	; seperate "collision" map layer.
   42                        	;
   43                        	
   44               0000     		.ifndef	CHRMAP_BAT_FLAG
   46                        		.endif
   47                        	
   48                        	;
   49                        	;
   50                        	;
   51                        	
   52                        	
   53                        	
   54    0D:D6C7             	chrmap_group	.procgroup
   55                        	
   56                        	; ***************************************************************************
   57                        	; ***************************************************************************
   58                        	;
   59                        	; _draw_bat - Draw the entire screen at the current coordinates.
   60                        	; _sgx_draw_bat - Draw the entire screen at the current coordinates.
   61                        	;
   62                        	; void __fastcall draw_bat( void );
   63                        	; void __fastcall sgx_draw_bat( void );
   64                        	;
   65                        	
   66               0001     		.if	SUPPORT_SGX
   67                        	
   68                        	_sgx_draw_bat	.proc
   74                        			.endp
   75                        		.endif
   76                        	
   77    0D:D6C7             	_draw_bat	.proc
   78                        	
   79    0D:D6C7  82         			clx				; Offset to PCE VDC.
   80                        	
   81    0D:D6C8  43 08      			tma3				; Preserve MPR3..MPR5.
   82    0D:D6CA  48         			pha
   83    0D:D6CB  43 10      			tma4
   84    0D:D6CD  48         			pha
   85    0D:D6CE  43 20      			tma5
   86    0D:D6D0  48         			pha
   87                        	
   88    0D:D6D1  20 74 D7   			jsr	bat_pxl_2_chr		; Set up the draw coordinates.
   89                        	
   90    0D:D6D4  A5 FC      			lda	<map_chr_x		; Reset previous X position.
   91    0D:D6D6  9D EB 29   			sta	vdc_old_chr_x, x
   92                        	
   93    0D:D6D9  A5 FE      			lda	<map_chr_y		; Reset previous Y position,
   94    0D:D6DB  1A         			inc	a			; ready to draw rows upwards.
   95    0D:D6DC  9D EC 29   			sta	vdc_old_chr_y, x
   96                        	
   97    0D:D6DF  BD B4 24   			lda	vdc_map_draw_w, x	; Draw the whole screen.
   98    0D:D6E2  85 FA      			sta	<map_draw_w
   99    0D:D6E4  BD B5 24   			lda	vdc_map_draw_h, x
  100    0D:D6E7  85 FB      			sta	<map_draw_h
  101                        	
  102    0D:D6E9  20 57 D8   			jsr	bat_scroll_y		; Draw N row of CHR to the BAT.
  103                        	
  104    0D:D6EC  68         			pla				; Restore MPR3..MPR5.
  105    0D:D6ED  53 20      			tam5
  106    0D:D6EF  68         			pla
  107    0D:D6F0  53 10      			tam4
  108    0D:D6F2  68         			pla
  109    0D:D6F3  53 08      			tam3
  110                        	
  111                        			leave
         0D:D6F5  4C EF FF   			jmp	leave_proc
  112                        	
  113                        			.endp
  114                        	
  115                        	
  116                        	
  117                        	; ***************************************************************************
  118                        	; ***************************************************************************
  119                        	;
  120                        	; _scroll_bat - Draw a single row of CHR into the BAT to update the edge.
  121                        	; _sgx_scroll_bat - Draw a single row of CHR into the BAT to update the edge.
  122                        	;
  123                        	; void __fastcall scroll_bat( void );
  124                        	; void __fastcall sgx_scroll_bat( void );
  125                        	;
  126                        	
  127               0001     		.if	SUPPORT_SGX
  128                        	
  129                        	_sgx_scroll_bat	.proc
  135                        			.endp
  136                        		.endif
  137                        	
  138    0D:D6F8             	_scroll_bat	.proc
  139                        	
  140    0D:D6F8  82         			clx				; Offset to PCE VDC.
  141                        	
  142    0D:D6F9  43 08      			tma3				; Preserve MPR3..MPR5.
  143    0D:D6FB  48         			pha
  144    0D:D6FC  43 10      			tma4
  145    0D:D6FE  48         			pha
  146    0D:D6FF  43 20      			tma5
  147    0D:D701  48         			pha
  148                        	
  149    0D:D702  20 74 D7   			jsr	bat_pxl_2_chr		; Set up the draw coordinates.
  150                        	
  151    0D:D705  BD B5 24   			lda	vdc_map_draw_h, x	; Draw new LHS or RHS if needed.
  152    0D:D708  85 FB      			sta	<map_draw_h
  153                        	;		lda	#1			; bat_scroll_x only ever draws a
  154                        	;		sta	<map_draw_w		; single column.
  155    0D:D70A  20 98 D7   			jsr	bat_scroll_x
  156                        	
  157    0D:D70D  BD EB 29   			lda	vdc_old_chr_x, x	; Restore map_chr_x which could
  158    0D:D710  85 FC      			sta	<map_chr_x		; be changed by bat_scroll_x.
  159                        	
  160    0D:D712  BD B4 24   			lda	vdc_map_draw_w, x	; Draw new TOP or BTM if needed.
  161    0D:D715  85 FA      			sta	<map_draw_w
  162    0D:D717  A9 01      			lda	#1
  163    0D:D719  85 FB      			sta	<map_draw_h
  164    0D:D71B  20 57 D8   			jsr	bat_scroll_y
  165                        	
  166    0D:D71E  68         			pla				; Restore MPR3..MPR5.
  167    0D:D71F  53 20      			tam5
  168    0D:D721  68         			pla
  169    0D:D722  53 10      			tam4
  170    0D:D724  68         			pla
  171    0D:D725  53 08      			tam3
  172                        	
  173                        			leave
         0D:D727  4C EF FF   			jmp	leave_proc
  174                        	
  175                        			.endp
  176                        	
  177                        	
  178                        	
  179                        	; ***************************************************************************
  180                        	; ***************************************************************************
  181                        	;
  182                        	; _blit_bat - Draw a map rectangle to specific BAT coordinates.
  183                        	; _sgx_blit_bat - Draw a map rectangle to specific BAT coordinates.
  184                        	;
  185                        	; void __fastcall blit_bat( unsigned char tile_x<map_bat_x>, unsigned char tile_y<map_bat_y>, unsigned char tile_w<map_draw_x>, unsigned char tile_h<map_draw_y> );
  186                        	; void __fastcall sgx_blit_bat( unsigned char tile_x<map_bat_x>, unsigned char tile_y<map_bat_y>, unsigned char tile_w<map_draw_x>, unsigned char tile_h<map_draw_y> );
  187                        	;
  188                        	; Normally you'd just use _draw_bat() and _scroll_bat(), but for those folks
  189                        	; who really wish to take manual control, you can use this.
  190                        	;
  191                        	
  192               0001     		.if	SUPPORT_SGX
  193                        	
  194                        	_sgx_blit_bat	.proc
  200                        			.endp
  201                        		.endif
  202                        	
  203    0D:D72A             	_blit_bat	.proc
  204                        	
  205    0D:D72A  82         			clx				; Offset to PCE VDC.
  206                        	
  207    0D:D72B  43 08      			tma3				; Preserve MPR3..MPR5.
  208    0D:D72D  48         			pha
  209    0D:D72E  43 10      			tma4
  210    0D:D730  48         			pha
  211    0D:D731  43 20      			tma5
  212    0D:D733  48         			pha
  213                        	
  214    0D:D734  BD BC 24   			lda	vdc_map_option, x	; Preserve current map options.
  215    0D:D737  48         			pha
  216    0D:D738  09 C0      			ora	#MAP_UNALIGNED_X | MAP_UNALIGNED_Y
  217    0D:D73A  9D BC 24   			sta	vdc_map_option, x
  218                        	
  219    0D:D73D  20 74 D7   			jsr	bat_pxl_2_chr		; Set up the draw coordinates.
  220                        	
  221    0D:D740  A5 FA      			lda	<map_draw_w		; Are we drawing just 1 column?
  222    0D:D742  C9 01      			cmp	#1
  223    0D:D744  F0 1E      			beq	.draw_column
  224                        	
  225                        			; Draw N rows.
  226                        	
  227    0D:D746  A5 FC      	.draw_rows:	lda	<map_chr_x		; Reset previous X position.
  228    0D:D748  9D EB 29   			sta	vdc_old_chr_x, x
  229                        	
  230    0D:D74B  A5 FE      			lda	<map_chr_y		; Reset previous Y position,
  231    0D:D74D  1A         			inc	a			; ready to draw rows upwards.
  232    0D:D74E  9D EC 29   			sta	vdc_old_chr_y, x
  233                        	
  234    0D:D751  20 57 D8   			jsr	bat_scroll_y		; Draw a row of CHR to the BAT.
  235                        	
  236                        			; Drawing completed.
  237                        	
  238    0D:D754  68         	.finished:	pla				; Restore previous map options.
  239    0D:D755  9D BC 24   			sta	vdc_map_option, x
  240                        	
  241    0D:D758  68         			pla				; Restore MPR3..MPR5.
  242    0D:D759  53 20      			tam5
  243    0D:D75B  68         			pla
  244    0D:D75C  53 10      			tam4
  245    0D:D75E  68         			pla
  246    0D:D75F  53 08      			tam3
  247                        	
  248                        	.exit:		leave
         0D:D761  4C EF FF   			jmp	leave_proc
  249                        	
  250                        			; Draw 1 column.
  251                        	
  252    0D:D764  A5 FC      	.draw_column:	lda	<map_chr_x		; Reset previous X position.
  253    0D:D766  1A         			inc	a			; ready to draw 1 column.
  254    0D:D767  9D EB 29   			sta	vdc_old_chr_x, x
  255                        	
  256    0D:D76A  A5 FE      			lda	<map_chr_y		; Reset previous Y position.
  257    0D:D76C  9D EC 29   			sta	vdc_old_chr_y, x
  258                        	
  259    0D:D76F  20 98 D7   			jsr	bat_scroll_x		; Draw a single column of CHR.
  260                        	
  261    0D:D772  80 E0      			bra	.finished
  262                        	
  263                        			.endp
  264                        	
  265                        	
  266                        	
  267                        	; ***************************************************************************
  268                        	; ***************************************************************************
  269                        	;
  270                        	
  271    0D:D774  BD B8 24   	bat_pxl_2_chr:	lda.l	vdc_map_pxl_x, x	; Get current map X coordinate.
  272    0D:D777  85 FC      			sta.l	<map_pxl_x
  273    0D:D779  BD B9 24   			lda.h	vdc_map_pxl_x, x	; Xvert map_pxl_x to map_chr_x.
  274    0D:D77C  4A         			lsr	a
  275    0D:D77D  66 FC      			ror.l	<map_pxl_x
  276    0D:D77F  4A         			lsr	a
  277    0D:D780  66 FC      			ror.l	<map_pxl_x
  278    0D:D782  4A         			lsr	a
  279    0D:D783  66 FC      			ror.l	<map_pxl_x		; Max map width is 256 CHR.
  280                        	
  281    0D:D785  BD BA 24   			lda.l	vdc_map_pxl_y, x	; Get current map Y coordinate.
  282    0D:D788  85 FE      			sta.l	<map_pxl_y
  283    0D:D78A  BD BB 24   			lda.h	vdc_map_pxl_y, x	; Xvert map_pxl_y to map_chr_y.
  284    0D:D78D  4A         			lsr	a
  285    0D:D78E  66 FE      			ror.l	<map_pxl_y
  286    0D:D790  4A         			lsr	a
  287    0D:D791  66 FE      			ror.l	<map_pxl_y
  288    0D:D793  4A         			lsr	a
  289    0D:D794  66 FE      			ror.l	<map_pxl_y		; Max map width is 256 CHR.
  290                        	
  291    0D:D796  60         			rts
  292                        	
  293                        	
  294                        	
  295                        	; ***************************************************************************
  296                        	; ***************************************************************************
  297                        	;
  298                        	; bat_scroll_x - Update the BAT when X coordinate changes.
  299                        	;
  300                        	; N.B. This only ever draws a single column!
  301                        	;
  302                        	
  303    0D:D797  60         	!no_change:	rts
  304                        	
  305    0D:D798  A5 FC      	bat_scroll_x:	lda	<map_chr_x		; Compare old_x with cur_x.
  306    0D:D79A  DD EB 29   			cmp	vdc_old_chr_x, x
  307    0D:D79D  F0 F8      			beq	!no_change-		; Do nothing if no change.
  308    0D:D79F  9D EB 29   			sta	vdc_old_chr_x, x
  309    0D:D7A2  30 05      			bmi	.moved			; Test the sign of the change.
  310                        	
  311    0D:D7A4  18         			clc				; Draw RHS if chr_x >= old_x.
  312    0D:D7A5  7D B4 24   			adc	vdc_map_draw_w, x	; Usually (SCR_WIDTH / 8) + 1.
  313    0D:D7A8  3A         			dec	a
  314                        	
  315    0D:D7A9  48         	.moved:		pha				; Push chr_x in map section.
  316                        	
  317    0D:D7AA  3C BC 24   			bit	vdc_map_option, x	; Set bit7 to disable aligning
  318    0D:D7AD  30 05      			bmi	!+			; BAT X with the map X.
  319    0D:D7AF  3D B1 24   			and	vdc_bat_x_mask, x
  320    0D:D7B2  85 F8      			sta	<map_bat_x		; Save BAT X chr coordinate.
  321                        	
  322    0D:D7B4  A5 FE      	!:		lda	<map_chr_y		; Y = chr_y in map section.
  323    0D:D7B6  A8         			tay
  324                        	
  325    0D:D7B7  3C BC 24   			bit	vdc_map_option, x	; Set bit6 to disable aligning
  326    0D:D7BA  70 05      			bvs	!+			; BAT Y with the map Y.
  327    0D:D7BC  3D B2 24   			and	vdc_bat_y_mask, x
  328    0D:D7BF  85 F9      			sta	<map_bat_y		; Save BAT Y chr coordinate.
  329                        	
  330               0000     		.if	FAST_MULTIPLY
  333                        		.endif
  334                        	
  335    0D:D7C1  BD B6 24   	!:		lda	vdc_map_line_w, x	; Map width in CHR (0 == 256).
  336    0D:D7C4  D0 05      			bne	!+
  337                        	
  338    0D:D7C6  64 EE      			stz.l	<map_line		; Multiply by 256 is easy!
  339    0D:D7C8  98         			tya
  340    0D:D7C9  80 15      			bra	.double
  341                        	
  342               0000     		.if	FAST_MULTIPLY
  354                        		.else
  355    0D:D7CB  84 EF      	!:		sty.h	<map_line		; Takes 144..176 cycles.
  356    0D:D7CD  A0 08      			ldy	#8
  357    0D:D7CF  4A         			lsr	a
  358    0D:D7D0  85 EE      			sta.l	<map_line
  359    0D:D7D2  62         			cla
  360    0D:D7D3  90 03      			bcc	.rotate
  361    0D:D7D5  18         	.add:		clc
  362    0D:D7D6  65 EF      			adc.h	<map_line
  363    0D:D7D8  6A         	.rotate:	ror	a
  364    0D:D7D9  66 EE      			ror.l	<map_line		; Lo-byte of (CHR Y * width).
  365    0D:D7DB  88         			dey
  366    0D:D7DC  B0 F7      			bcs	.add
  367    0D:D7DE  D0 F8      			bne	.rotate
  368                        		.endif
  369                        	
  370    0D:D7E0  06 EE      	.double:	asl.l	<map_line		; Lo-byte of (CHR Y * width * 2).
  371    0D:D7E2  2A         			rol	a
  372    0D:D7E3  A8         			tay				; Hi-byte of (CHR Y * width * 2).
  373                        	
  374    0D:D7E4  BD F5 29   			lda	vdc_map_bank, x		; Put the MAP into MPR3-MPR5.
  375    0D:D7E7  53 08      			tam3				; Allow for 16KByte chrmap.
  376    0D:D7E9  1A         			inc	a
  377    0D:D7EA  53 10      			tam4
  378    0D:D7EC  1A         			inc	a
  379    0D:D7ED  53 20      			tam5
  380                        	
  381    0D:D7EF  68         			pla				; Pop chr_x in map section.
  382    0D:D7F0  0A         			asl	a			; 2-bytes for a BAT value.
  383    0D:D7F1  90 02      			bcc	!+
  384    0D:D7F3  C8         			iny				; Hi-byte of (CHR Y * width * 2).
  385    0D:D7F4  18         			clc
  386    0D:D7F5  65 EE      	!:		adc.l	<map_line		; Lo-byte of (CHR Y * width * 2).
  387    0D:D7F7  90 01      			bcc	!+
  388    0D:D7F9  C8         			iny
  389                        	
  390    0D:D7FA  18         	!:		clc				; Calc map data pointer.
  391    0D:D7FB  7D F3 29   			adc.l	vdc_map_addr, x
  392    0D:D7FE  85 EC      			sta.l	<_bp			; Maximum map size is 16KBytes
  393    0D:D800  98         			tya				; so we don't need to consider
  394    0D:D801  7D F4 29   			adc.h	vdc_map_addr, x		; bank overflow.
  395    0D:D804  85 ED      			sta.h	<_bp
  396                        	
  397    0D:D806  C2         			cly				; Calculate the map line delta
  398    0D:D807  BD B6 24   			lda	vdc_map_line_w, x	; in bytes.
  399    0D:D80A  D0 01      			bne	!+
  400    0D:D80C  C8         			iny
  401    0D:D80D  0A         	!:		asl	a
  402    0D:D80E  85 EE      			sta.l	<map_line
  403    0D:D810  98         			tya
  404    0D:D811  2A         			rol	a
  405    0D:D812  85 EF      			sta.h	<map_line
  406                        	
  407                        			; Draw the first part of the column.
  408                        	
  409    0D:D814  A5 F8      	.draw_col:	lda	<map_bat_x		; Set the BAT VRAM destination
  410    0D:D816  85 F0      			sta.l	<_di			; coordinates.
  411    0D:D818  A5 F9      			lda	<map_bat_y
  412    0D:D81A  85 F1      			sta.h	<_di
  413                        	
  414    0D:D81C  5D B2 24   			eor	vdc_bat_y_mask, x	; Calc CHR before wrap.
  415    0D:D81F  1A         			inc	a
  416    0D:D820  C5 FB      			cmp	<map_draw_h		; Usually (SCR_HEIGHT / 8) + 1.
  417    0D:D822  90 02      			bcc	!+
  418    0D:D824  A5 FB      			lda	<map_draw_h		; Maximum CHR to draw.
  419    0D:D826  85 00      	!:		sta	<map_count		; Set number of CHR to draw.
  420    0D:D828  85 01      			sta	<map_drawn		; Preserve number of CHR drawn.
  421                        	
  422    0D:D82A  A9 05      			lda	#VDC_CR			; Set VDC auto-increment from
  423    0D:D82C  95 F7      			sta	<vdc_reg, x		; the BAT width, which is set
  424    0D:D82E  9D 00 02   			sta	VDC_AR, x		; up by set_screen_size().
  425    0D:D831  B5 F4      			lda	<vdc_crh, x
  426    0D:D833  9D 03 02   			sta	VDC_DH, x
  427                        	
  428    0D:D836  20 38 D9   			jsr	bat_col_strip		; Draw top of vertical strip.
  429                        	
  430                        			; Wrap around and draw the rest of the column (if needed).
  431                        	
  432    0D:D839  38         			sec				; Are there any more CHR that
  433    0D:D83A  A5 FB      			lda	<map_draw_h		; need to be drawn?
  434    0D:D83C  E5 01      			sbc	<map_drawn
  435    0D:D83E  F0 0B      			beq	.done
  436                        	
  437    0D:D840  85 00      			sta	<map_count		; Set number of CHR to draw.
  438                        	
  439    0D:D842  A5 F8      			lda	<map_bat_x		; Set the BAT VRAM destination
  440    0D:D844  85 F0      			sta.l	<_di			; coordinates.
  441    0D:D846  64 F1      			stz.h	<_di			; Reset 1st row to draw.
  442                        	
  443    0D:D848  20 38 D9   			jsr	bat_col_strip		; Draw btm of vertical strip.
  444                        	
  445    0D:D84B  A9 05      	.done:		lda	#VDC_CR			; Set VDC auto-increment to 1.
  446    0D:D84D  95 F7      			sta	<vdc_reg, x
  447    0D:D84F  9D 00 02   			sta	VDC_AR, x
  448    0D:D852  9E 03 02   			stz	VDC_DH, x
  449                        	
  450    0D:D855  60         			rts
  451                        	
  452                        	
  453                        	
  454                        	; ***************************************************************************
  455                        	; ***************************************************************************
  456                        	;
  457                        	; bat_scroll_y - Update the BAT when Y coordinate changes.
  458                        	;
  459                        	; N.B. This draws multiple rows when called from _draw_bat or _blit_bat.
  460                        	;
  461                        	
  462    0D:D856  60         	!no_change:	rts
  463                        	
  464    0D:D857  A5 FE      	bat_scroll_y:	lda	<map_chr_y		; Compare old_y with cur_y.
  465    0D:D859  DD EC 29   			cmp	vdc_old_chr_y, x
  466    0D:D85C  F0 F8      			beq	!no_change-		; Do nothing if no change.
  467    0D:D85E  9D EC 29   			sta	vdc_old_chr_y, x
  468    0D:D861  30 05      			bmi	.moved			; Test the sign of the change.
  469                        	
  470    0D:D863  18         			clc				; Draw bottom if chr_y >= old_y.
  471    0D:D864  7D B5 24   			adc	vdc_map_draw_h, x	; Usually (SCR_HEIGHT / 8) + 1.
  472    0D:D867  3A         			dec	a
  473                        	
  474    0D:D868  A8         	.moved:		tay				; Y = chr_y in map section.
  475                        	
  476    0D:D869  3C BC 24   			bit	vdc_map_option, x	; Set bit6 to disable aligning
  477    0D:D86C  70 05      			bvs	!+			; BAT Y with the map Y.
  478    0D:D86E  3D B2 24   			and	vdc_bat_y_mask, x
  479    0D:D871  85 F9      			sta	<map_bat_y		; Save BAT Y chr coordinate.
  480                        	
  481    0D:D873  3C BC 24   	!:		bit	vdc_map_option, x	; Set bit7 to disable aligning
  482    0D:D876  30 07      			bmi	!+			; BAT X with the map X.
  483    0D:D878  A5 FC      			lda	<map_chr_x
  484    0D:D87A  3D B1 24   			and	vdc_bat_x_mask, x
  485    0D:D87D  85 F8      			sta	<map_bat_x		; Save BAT X chr coordinate.
  486                        	
  487               0000     		.if	FAST_MULTIPLY
  490                        		.endif
  491                        	
  492    0D:D87F  BD B6 24   	!:		lda	vdc_map_line_w, x	; Map width in CHR (0 == 256).
  493    0D:D882  D0 05      			bne	!+
  494                        	
  495    0D:D884  64 EE      			stz.l	<map_line		; Multiply by 256 is easy!
  496    0D:D886  98         			tya
  497    0D:D887  80 15      			bra	.double
  498                        	
  499               0000     		.if	FAST_MULTIPLY
  511                        		.else
  512    0D:D889  84 EF      	!:		sty.h	<map_line		; Takes 144..176 cycles.
  513    0D:D88B  A0 08      			ldy	#8
  514    0D:D88D  4A         			lsr	a
  515    0D:D88E  85 EE      			sta.l	<map_line
  516    0D:D890  62         			cla
  517    0D:D891  90 03      			bcc	.rotate
  518    0D:D893  18         	.add:		clc
  519    0D:D894  65 EF      			adc.h	<map_line
  520    0D:D896  6A         	.rotate:	ror	a
  521    0D:D897  66 EE      			ror.l	<map_line		; Lo-byte of (CHR Y * width).
  522    0D:D899  88         			dey
  523    0D:D89A  B0 F7      			bcs	.add
  524    0D:D89C  D0 F8      			bne	.rotate
  525                        		.endif
  526                        	
  527    0D:D89E  06 EE      	.double:	asl.l	<map_line		; Lo-byte of (CHR Y * width * 2).
  528    0D:D8A0  2A         			rol	a
  529    0D:D8A1  85 EF      			sta.h	<map_line		; Hi-byte of (CHR Y * width * 2).
  530    0D:D8A3  A8         			tay
  531                        	
  532    0D:D8A4  BD F5 29   			lda	vdc_map_bank, x		; Put the MAP into MPR3-MPR5.
  533    0D:D8A7  53 08      			tam3				; Allow for 16KByte chrmap.
  534    0D:D8A9  1A         			inc	a
  535    0D:D8AA  53 10      			tam4
  536    0D:D8AC  1A         			inc	a
  537    0D:D8AD  53 20      			tam5
  538                        	
  539                        			; Loop to here if drawing multiple rows.
  540                        	
  541    0D:D8AF  A5 FC      	.next_row:	lda	<map_chr_x		; Map CHR X coordinate.
  542    0D:D8B1  0A         			asl	a			; 2-bytes for a BAT value!
  543    0D:D8B2  90 02      			bcc	!+
  544    0D:D8B4  C8         			iny				; Hi-byte of (CHR Y * width * 2).
  545    0D:D8B5  18         			clc
  546    0D:D8B6  65 EE      	!:		adc.l	<map_line		; Lo-byte of (CHR Y * width * 2).
  547    0D:D8B8  90 01      			bcc	!+
  548    0D:D8BA  C8         			iny
  549    0D:D8BB  18         	!:		clc				; Calc map data pointer.
  550    0D:D8BC  7D F3 29   			adc.l	vdc_map_addr, x
  551    0D:D8BF  85 EC      			sta.l	<_bp			; Maximum map size is 16KBytes
  552    0D:D8C1  98         			tya				; so we don't need to consider
  553    0D:D8C2  7D F4 29   			adc.h	vdc_map_addr, x		; bank overflow.
  554    0D:D8C5  85 ED      			sta.h	<_bp
  555                        	
  556                        			; Draw the first part of the row.
  557                        	
  558    0D:D8C7  A5 F9      	.draw_row:	lda	<map_bat_y		; Set the BAT VRAM destination
  559    0D:D8C9  85 F1      			sta.h	<_di			; coordinates.
  560    0D:D8CB  A5 F8      			lda	<map_bat_x
  561    0D:D8CD  85 F0      			sta.l	<_di
  562                        	
  563    0D:D8CF  5D B1 24   			eor	vdc_bat_x_mask, x	; Calc CHR before wrap.
  564    0D:D8D2  1A         			inc	a
  565    0D:D8D3  C5 FA      			cmp	<map_draw_w		; Usually (SCR_WIDTH / 8) + 1.
  566    0D:D8D5  90 02      			bcc	!+
  567    0D:D8D7  A5 FA      			lda	<map_draw_w		; Maximum CHR to draw.
  568    0D:D8D9  85 00      	!:		sta	<map_count		; Set number of CHR to draw.
  569    0D:D8DB  85 01      			sta	<map_drawn		; Preserve number of CHR drawn.
  570                        	
  571    0D:D8DD  20 17 D9   			jsr	bat_row_strip		; Draw lhs of horizontal strip.
  572                        	
  573                        			; Wrap around and draw the rest of the row (if needed).
  574                        	
  575    0D:D8E0  38         			sec				; Are there any more CHR that
  576    0D:D8E1  A5 FA      			lda	<map_draw_w		; need to be drawn?
  577    0D:D8E3  E5 01      			sbc	<map_drawn
  578    0D:D8E5  F0 0B      			beq	.done_row
  579                        	
  580    0D:D8E7  85 00      			sta	<map_count		; Set number of CHR to draw.
  581                        	
  582    0D:D8E9  A5 F9      			lda	<map_bat_y		; Set the BAT VRAM destination
  583    0D:D8EB  85 F1      			sta.h	<_di			; coordinates.
  584    0D:D8ED  64 F0      			stz.l	<_di			; Reset 1st column to draw.
  585                        	
  586    0D:D8EF  20 17 D9   			jsr	bat_row_strip		; Draw rhs of horizontal strip.
  587                        	
  588    0D:D8F2  C6 FB      	.done_row:	dec	<map_draw_h		; Are all desired rows drawn?
  589    0D:D8F4  F0 20      			beq	.finished
  590                        	
  591    0D:D8F6  A5 F9      			lda	<map_bat_y		; Move BAT Y down by 1.
  592    0D:D8F8  1A         			inc	a
  593    0D:D8F9  3D B2 24   			and	vdc_bat_y_mask, x
  594    0D:D8FC  85 F9      			sta	<map_bat_y
  595                        	
  596    0D:D8FE  A4 EF      			ldy.h	<map_line		; Move the map line pointer to
  597    0D:D900  C8         			iny				; the next line.
  598    0D:D901  BD B6 24   			lda	vdc_map_line_w, x
  599    0D:D904  F0 0B      			beq	!++			; vdc_map_line_w == 0 == 256.
  600    0D:D906  0A         			asl	a			; 2-bytes for a BAT value!
  601    0D:D907  B0 01      			bcs	!+
  602    0D:D909  88         			dey				; Fix if vdc_map_line_w <= 127.
  603    0D:D90A  18         	!:		clc
  604    0D:D90B  65 EE      			adc.l	<map_line
  605    0D:D90D  85 EE      			sta.l	<map_line
  606    0D:D90F  90 01      			bcc	!++
  607    0D:D911  C8         	!:		iny
  608    0D:D912  84 EF      	!:		sty.h	<map_line		; Needed for .next_row!
  609                        	
  610    0D:D914  80 99      			bra	.next_row		; Draw next row.
  611                        	
  612    0D:D916  60         	.finished:	rts
  613                        	
  614                        	
  615                        	
  616                        	; ***************************************************************************
  617                        	; ***************************************************************************
  618                        	;
  619                        	; bat_row_strip - Draw a single row of CHR into the BAT.
  620                        	;
  621                        	
  622    0D:D917  20 34 E4   	bat_row_strip:	jsr	set_di_xy_mawr		; Set the BAT VRAM destination.
  623                        	
  624    0D:D91A  C2         			cly				; 2
  625    0D:D91B  B1 EC      	.repeat:	lda	[_bp], y		; 7
  626    0D:D91D  9D 02 02   			sta	VDC_DL, x		; 6
  627    0D:D920  C8         			iny				; 2
  628    0D:D921  B1 EC      			lda	[_bp], y		; 7
  629               0000     		.if	CHRMAP_BAT_FLAG
  634                        		.endif
  635    0D:D923  9D 03 02   			sta	VDC_DH, x		; 6
  636    0D:D926  C8         			iny				; 2
  637                        	
  638    0D:D927  C6 00      	!:		dec	<map_count		; 6
  639    0D:D929  D0 F0      			bne	.repeat			; 4
  640                        	
  641    0D:D92B  98         			tya				; 2
  642    0D:D92C  F0 07      			beq	!+			; 2/4
  643    0D:D92E  18         			clc				; 2
  644    0D:D92F  65 EC      			adc.l	<_bp			; 4
  645    0D:D931  85 EC      			sta.l	<_bp			; 4
  646    0D:D933  90 02      			bcc	.done			; 2/4
  647    0D:D935  E6 ED      	!:		inc.h	<_bp			; 6
  648                        	
  649    0D:D937  60         	.done:		rts
  650                        	
  651                        	
  652                        	
  653                        	; ***************************************************************************
  654                        	; ***************************************************************************
  655                        	;
  656                        	; bat_col_strip - Draw a single column of CHR into the BAT.
  657                        	;
  658                        	
  659    0D:D938  20 34 E4   	bat_col_strip:	jsr	set_di_xy_mawr		; Set the BAT VRAM destination.
  660                        	
  661    0D:D93B  A0 01      			ldy	#1			; 2
  662    0D:D93D  B2 EC      	.repeat:	lda	[_bp]			; 7
  663    0D:D93F  9D 02 02   			sta	VDC_DL, x		; 6
  664    0D:D942  B1 EC      			lda	[_bp], y		; 7
  665               0000     		.if	CHRMAP_BAT_FLAG
  670                        		.endif
  671    0D:D944  9D 03 02   			sta	VDC_DH, x		; 6
  672                        	
  673    0D:D947  18         			clc				; 2
  674    0D:D948  A5 EE      			lda.l	<map_line		; 4
  675    0D:D94A  65 EC      			adc.l	<_bp			; 4
  676    0D:D94C  85 EC      			sta.l	<_bp			; 4
  677    0D:D94E  A5 EF      			lda.h	<map_line		; 4
  678    0D:D950  65 ED      			adc.h	<_bp			; 4
  679    0D:D952  85 ED      			sta.h	<_bp			; 4
  680                        	
  681    0D:D954  C6 00      			dec	<map_count		; 6
  682    0D:D956  D0 E5      			bne	.repeat			; 4
  683                        	
  684    0D:D958  60         			rts
  685                        	
  686                        		.endprocgroup	; chrmap_group
                             #[2]   "..\..\..\include\hucc\hucc-final.asm"
   88                        		.endif	HUCC_USES_CHRMAP
   89                        	
   90               0001     		.ifdef	HUCC_USES_OLD_LINE		; Set in hucc_old_line.h
                             #[3]   "..\..\..\include\hucc\hucc-old-line.asm"
   91                        			include	"hucc-old-line.asm"
    1                        	; ***************************************************************************
    2                        	; ***************************************************************************
    3                        	;
    4                        	; hucc-old-line.asm
    5                        	;
    6                        	; Based on the original HuC and MagicKit functions by David Michel and the
    7                        	; other original HuC developers.
    8                        	;
    9                        	; Modifications copyright John Brandwood 2024-2025.
   10                        	;
   11                        	; Distributed under the Boost Software License, Version 1.0.
   12                        	; (See accompanying file LICENSE_1_0.txt or copy at
   13                        	;  http://www.boost.org/LICENSE_1_0.txt)
   14                        	;
   15                        	; ***************************************************************************
   16                        	; ***************************************************************************
   17                        	
   18                        	
   19                        	
   20                        	; ***************************************************************************
   21                        	; ***************************************************************************
   22                        	;
   23                        	; void __fastcall gfx_init( unsigned int start_vram_addr<_ax> );
   24                        	;
   25                        	; initialize graphics mode
   26                        	; - points graphics map to tiles at start_vram_addr
   27                        	
   28                        	_gfx_init.1	.proc
   73                        			.endp
   74                        	
   75                        	
   76                        	
   77                        	; ***************************************************************************
   78                        	; ***************************************************************************
   79                        	;
   80                        	; void __fastcall gfx_clear( unsigned int start_vram_addr<_di> );
   81                        	;
   82                        	; Clear the values in the graphics tiles
   83                        	; - places zeroes in graphics tiles at start_vram_addr
   84                        	
   85                        	_gfx_clear.1	.proc
  105                        			.endp
  106                        	
  107                        	
  108                        	
  109                        	; ***************************************************************************
  110                        	; ***************************************************************************
  111                        	;
  112                        	; void __fastcall gfx_line( unsigned int x1<_gfx_x1>, unsigned int y1<_gfx_y1>, unsigned int x2<_gfx_x2>, unsigned int y2<_gfx_y2>, unsigned char color<_gfx_color> );
  113                        	
  114                        	huc_gfx_line	.procgroup
  459                        			.endprocgroup	; huc_gfx_line
                             #[2]   "..\..\..\include\hucc\hucc-final.asm"
   92                        		.endif
   93                        	
   94               0000     		.ifdef	HUCC_USES_ZX0			; Set in hucc_zx0.h
   96                        		.endif
   97                        	
   98                        	
   99                        	
  100                        	; ***************************************************************************
  101                        	; ***************************************************************************
  102                        	;
  103                        	; Check that C "__zp" declarations aren't overwriting System Card variables.
  104                        	;
  105                        	
  106               20A0     			.zp
  107               0000     		.if	(* > zpg_sys_top) || (USING_PSGDRIVER && (* > zpg_psg_top))
  109                        		.endif
  110                        	
  111                        	
  112                        	
  113                        	; ***************************************************************************
  114                        	; ***************************************************************************
  115                        	;
  116                        	; Check that there isn't too much C "const" data in the ".RODATA" section.
  117                        	;
  118                        	
  119               60F0     			.rodata
  120               0000     		.if	(bank(*) - _bank_base) >= (CONST_BANK + 2)
  122                        		.endif
  123               E937     			.code
                             #[1]   "main.s"

PROCEDURE LIST (in order of size):

Size: $151C, Addr: $01:C0F0,      .proc _update_PLAYER
Size: $086A, Addr: $01:D60C, .procgroup blkmap_group
Size: $06BB, Addr: $09:D860,      .proc _init_LEVEL
Size: $0417, Addr: $0D:CF20,      .proc _joypad_DIR
Size: $0390, Addr: $0D:D337,      .proc huc_monofont_x
Size: $0292, Addr: $0D:D6C7, .procgroup chrmap_group
Size: $0108, Addr: $01:DE76,      .proc read_joypads
Size: $0107, Addr: $0D:D959,      .proc _recenter_CAMERA
Size: $00DF, Addr: $09:DF1B, .procgroup vdc_set_mode
Size: $00D4, Addr: $0D:DA60,      .proc _joypad_BUTTONS
Size: $00A2, Addr: $0D:DB34,      .proc _main
Size: $0086, Addr: $0D:DBD6,      .proc _sgx_scroll_split.5
Size: $0081, Addr: $01:DF7E,      .proc vbl_init_scroll
Size: $007A, Addr: $0D:DC5C,      .proc _check_TILE_DEPTH
Size: $0077, Addr: $0D:DCD6,      .proc core_main
Size: $006A, Addr: $0D:DD4D, .procgroup load_vram_group
Size: $0069, Addr: $0D:DDB7, .procgroup vdc_tty_out
Size: $0064, Addr: $0D:DE20,      .proc _check_BG
Size: $0062, Addr: $0D:DE84,      .proc _init_256x224
Size: $004B, Addr: $0D:DEE6, .procgroup hucc_memcmp
Size: $004B, Addr: $0D:DF31, .procgroup old_satb_group
Size: $0043, Addr: $0D:DF7C, .procgroup vdc_clear_vram
Size: $0043, Addr: $02:C000,      .proc sgx_detect
Size: $003F, Addr: $0D:DFBF, .procgroup load_bat_group
Size: $003E, Addr: $02:C043,      .proc _vram2vram.3
Size: $003B, Addr: $02:C081,      .proc init_random
Size: $002E, Addr: $02:C0BC,      .proc _scroll_BG
Size: $002B, Addr: $02:C0EA,      .proc _load_palette.3
Size: $001E, Addr: $02:C115,      .proc _init_PLAYER
Size: $001C, Addr: $02:C133,      .proc clear_vce
Size: $0010, Addr: $02:C14F,      .proc _init_VARIABLES
Size: $0003, Addr: $09:DFFA,      .proc _scroll_OBJECTS
